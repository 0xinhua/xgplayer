window["HlsJsPlayer"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/eventemitter3/index.js":
/*!***********************************************************************************************!*\
  !*** /Users/leonardo/Documents/front-end/player/xgplayer/node_modules/eventemitter3/index.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "../../node_modules/events/events.js":
/*!*****************************************************************************************!*\
  !*** /Users/leonardo/Documents/front-end/player/xgplayer/node_modules/events/events.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),

/***/ "../../node_modules/url-toolkit/src/url-toolkit.js":
/*!*******************************************************************************************************!*\
  !*** /Users/leonardo/Documents/front-end/player/xgplayer/node_modules/url-toolkit/src/url-toolkit.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// see https://tools.ietf.org/html/rfc1808

/* jshint ignore:start */
(function(root) { 
/* jshint ignore:end */

  var URL_REGEX = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/\?#]*\/)*.*?)??(;.*?)?(\?.*?)?(#.*?)?$/;
  var FIRST_SEGMENT_REGEX = /^([^\/?#]*)(.*)$/;
  var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
  var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g;

  var URLToolkit = { // jshint ignore:line
    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
    // E.g
    // With opts.alwaysNormalize = false (default, spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
    // With opts.alwaysNormalize = true (not spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
    buildAbsoluteURL: function(baseURL, relativeURL, opts) {
      opts = opts || {};
      // remove any remaining space and CRLF
      baseURL = baseURL.trim();
      relativeURL = relativeURL.trim();
      if (!relativeURL) {
        // 2a) If the embedded URL is entirely empty, it inherits the
        // entire base URL (i.e., is set equal to the base URL)
        // and we are done.
        if (!opts.alwaysNormalize) {
          return baseURL;
        }
        var basePartsForNormalise = URLToolkit.parseURL(baseURL);
        if (!basePartsForNormalise) {
          throw new Error('Error trying to parse base URL.');
        }
        basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
        return URLToolkit.buildURLFromParts(basePartsForNormalise);
      }
      var relativeParts = URLToolkit.parseURL(relativeURL);
      if (!relativeParts) {
        throw new Error('Error trying to parse relative URL.');
      }
      if (relativeParts.scheme) {
        // 2b) If the embedded URL starts with a scheme name, it is
        // interpreted as an absolute URL and we are done.
        if (!opts.alwaysNormalize) {
          return relativeURL;
        }
        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
        return URLToolkit.buildURLFromParts(relativeParts);
      }
      var baseParts = URLToolkit.parseURL(baseURL);
      if (!baseParts) {
        throw new Error('Error trying to parse base URL.');
      }
      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc
        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
        baseParts.netLoc = pathParts[1];
        baseParts.path = pathParts[2];
      }
      if (baseParts.netLoc && !baseParts.path) {
        baseParts.path = '/';
      }
      var builtParts = {
        // 2c) Otherwise, the embedded URL inherits the scheme of
        // the base URL.
        scheme: baseParts.scheme,
        netLoc: relativeParts.netLoc,
        path: null,
        params: relativeParts.params,
        query: relativeParts.query,
        fragment: relativeParts.fragment
      };
      if (!relativeParts.netLoc) {
        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
        // (if any) of the base URL.
        builtParts.netLoc = baseParts.netLoc;
        // 4) If the embedded URL path is preceded by a slash "/", the
        // path is not relative and we skip to Step 7.
        if (relativeParts.path[0] !== '/') {
          if (!relativeParts.path) {
            // 5) If the embedded URL path is empty (and not preceded by a
            // slash), then the embedded URL inherits the base URL path
            builtParts.path = baseParts.path;
            // 5a) if the embedded URL's <params> is non-empty, we skip to
            // step 7; otherwise, it inherits the <params> of the base
            // URL (if any) and
            if (!relativeParts.params) {
              builtParts.params = baseParts.params;
              // 5b) if the embedded URL's <query> is non-empty, we skip to
              // step 7; otherwise, it inherits the <query> of the base
              // URL (if any) and we skip to step 7.
              if (!relativeParts.query) {
                builtParts.query = baseParts.query;
              }
            }
          } else {
            // 6) The last segment of the base URL's path (anything
            // following the rightmost slash "/", or the entire path if no
            // slash is present) is removed and the embedded URL's path is
            // appended in its place.
            var baseURLPath = baseParts.path;
            var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;
            builtParts.path = URLToolkit.normalizePath(newPath);
          }
        }
      }
      if (builtParts.path === null) {
        builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
      }
      return URLToolkit.buildURLFromParts(builtParts);
    },
    parseURL: function(url) {
      var parts = URL_REGEX.exec(url);
      if (!parts) {
        return null;
      }
      return {
        scheme: parts[1] || '',
        netLoc: parts[2] || '',
        path: parts[3] || '',
        params: parts[4] || '',
        query: parts[5] || '',
        fragment: parts[6] || ''
      };
    },
    normalizePath: function(path) {
      // The following operations are
      // then applied, in order, to the new path:
      // 6a) All occurrences of "./", where "." is a complete path
      // segment, are removed.
      // 6b) If the path ends with "." as a complete path segment,
      // that "." is removed.
      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
      // 6c) All occurrences of "<segment>/../", where <segment> is a
      // complete path segment not equal to "..", are removed.
      // Removal of these path segments is performed iteratively,
      // removing the leftmost matching pattern on each iteration,
      // until no matching pattern remains.
      // 6d) If the path ends with "<segment>/..", where <segment> is a
      // complete path segment not equal to "..", that
      // "<segment>/.." is removed.
      while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {} // jshint ignore:line
      return path.split('').reverse().join('');
    },
    buildURLFromParts: function(parts) {
      return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
    }
  };

/* jshint ignore:start */
  if(true)
    module.exports = URLToolkit;
  else {}
})(this);
/* jshint ignore:end */


/***/ }),

/***/ "../../node_modules/webworkify-webpack/index.js":
/*!****************************************************************************************************!*\
  !*** /Users/leonardo/Documents/front-end/player/xgplayer/node_modules/webworkify-webpack/index.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function webpackBootstrapFunc (modules) {
/******/  // The module cache
/******/  var installedModules = {};

/******/  // The require function
/******/  function __webpack_require__(moduleId) {

/******/    // Check if module is in cache
/******/    if(installedModules[moduleId])
/******/      return installedModules[moduleId].exports;

/******/    // Create a new module (and put it into the cache)
/******/    var module = installedModules[moduleId] = {
/******/      i: moduleId,
/******/      l: false,
/******/      exports: {}
/******/    };

/******/    // Execute the module function
/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/    // Flag the module as loaded
/******/    module.l = true;

/******/    // Return the exports of the module
/******/    return module.exports;
/******/  }

/******/  // expose the modules object (__webpack_modules__)
/******/  __webpack_require__.m = modules;

/******/  // expose the module cache
/******/  __webpack_require__.c = installedModules;

/******/  // identity function for calling harmony imports with the correct context
/******/  __webpack_require__.i = function(value) { return value; };

/******/  // define getter function for harmony exports
/******/  __webpack_require__.d = function(exports, name, getter) {
/******/    if(!__webpack_require__.o(exports, name)) {
/******/      Object.defineProperty(exports, name, {
/******/        configurable: false,
/******/        enumerable: true,
/******/        get: getter
/******/      });
/******/    }
/******/  };

/******/  // define __esModule on exports
/******/  __webpack_require__.r = function(exports) {
/******/    Object.defineProperty(exports, '__esModule', { value: true });
/******/  };

/******/  // getDefaultExport function for compatibility with non-harmony modules
/******/  __webpack_require__.n = function(module) {
/******/    var getter = module && module.__esModule ?
/******/      function getDefault() { return module['default']; } :
/******/      function getModuleExports() { return module; };
/******/    __webpack_require__.d(getter, 'a', getter);
/******/    return getter;
/******/  };

/******/  // Object.prototype.hasOwnProperty.call
/******/  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/  // __webpack_public_path__
/******/  __webpack_require__.p = "/";

/******/  // on error function for async loading
/******/  __webpack_require__.oe = function(err) { console.error(err); throw err; };

  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE)
  return f.default || f // try to call default if defined to also support babel esmodule exports
}

var moduleNameReqExp = '[\\.|\\-|\\+|\\w|\/|@]+'
var dependencyRegExp = '\\(\\s*(\/\\*.*?\\*\/)?\\s*.*?(' + moduleNameReqExp + ').*?\\)' // additional chars when output.pathinfo is true

// http://stackoverflow.com/a/2593661/130442
function quoteRegExp (str) {
  return (str + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&')
}

function isNumeric(n) {
  return !isNaN(1 * n); // 1 * n converts integers, integers as string ("123"), 1e3 and "1e3" to integers and strings to NaN
}

function getModuleDependencies (sources, module, queueName) {
  var retval = {}
  retval[queueName] = []

  var fnString = module.toString()
  var wrapperSignature = fnString.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/)
  if (!wrapperSignature) return retval
  var webpackRequireName = wrapperSignature[1]

  // main bundle deps
  var re = new RegExp('(\\\\n|\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g')
  var match
  while ((match = re.exec(fnString))) {
    if (match[3] === 'dll-reference') continue
    retval[queueName].push(match[3])
  }

  // dll deps
  re = new RegExp('\\(' + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, 'g')
  while ((match = re.exec(fnString))) {
    if (!sources[match[2]]) {
      retval[queueName].push(match[1])
      sources[match[2]] = __webpack_require__(match[1]).m
    }
    retval[match[2]] = retval[match[2]] || []
    retval[match[2]].push(match[4])
  }

  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3
  var keys = Object.keys(retval);
  for (var i = 0; i < keys.length; i++) {
    for (var j = 0; j < retval[keys[i]].length; j++) {
      if (isNumeric(retval[keys[i]][j])) {
        retval[keys[i]][j] = 1 * retval[keys[i]][j];
      }
    }
  }

  return retval
}

function hasValuesInQueues (queues) {
  var keys = Object.keys(queues)
  return keys.reduce(function (hasValues, key) {
    return hasValues || queues[key].length > 0
  }, false)
}

function getRequiredModules (sources, moduleId) {
  var modulesQueue = {
    main: [moduleId]
  }
  var requiredModules = {
    main: []
  }
  var seenModules = {
    main: {}
  }

  while (hasValuesInQueues(modulesQueue)) {
    var queues = Object.keys(modulesQueue)
    for (var i = 0; i < queues.length; i++) {
      var queueName = queues[i]
      var queue = modulesQueue[queueName]
      var moduleToCheck = queue.pop()
      seenModules[queueName] = seenModules[queueName] || {}
      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue
      seenModules[queueName][moduleToCheck] = true
      requiredModules[queueName] = requiredModules[queueName] || []
      requiredModules[queueName].push(moduleToCheck)
      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName)
      var newModulesKeys = Object.keys(newModules)
      for (var j = 0; j < newModulesKeys.length; j++) {
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || []
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]])
      }
    }
  }

  return requiredModules
}

module.exports = function (moduleId, options) {
  options = options || {}
  var sources = {
    main: __webpack_require__.m
  }

  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId)

  var src = ''

  Object.keys(requiredModules).filter(function (m) { return m !== 'main' }).forEach(function (module) {
    var entryModule = 0
    while (requiredModules[module][entryModule]) {
      entryModule++
    }
    requiredModules[module].push(entryModule)
    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'
    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[module][id].toString() }).join(',') + '});\n'
  })

  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources.main[id].toString() }).join(',') + '}))(self);'

  var blob = new window.Blob([src], { type: 'text/javascript' })
  if (options.bare) { return blob }

  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL

  var workerUrl = URL.createObjectURL(blob)
  var worker = new window.Worker(workerUrl)
  worker.objectURL = workerUrl

  return worker
}


/***/ }),

/***/ "./src/hls.js/config.js":
/*!******************************!*\
  !*** ./src/hls.js/config.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hlsDefaultConfig = undefined;

var _abrController = __webpack_require__(/*! ./controller/abr-controller */ "./src/hls.js/controller/abr-controller.js");

var _abrController2 = _interopRequireDefault(_abrController);

var _bufferController = __webpack_require__(/*! ./controller/buffer-controller */ "./src/hls.js/controller/buffer-controller.js");

var _bufferController2 = _interopRequireDefault(_bufferController);

var _capLevelController = __webpack_require__(/*! ./controller/cap-level-controller */ "./src/hls.js/controller/cap-level-controller.js");

var _capLevelController2 = _interopRequireDefault(_capLevelController);

var _fpsController = __webpack_require__(/*! ./controller/fps-controller */ "./src/hls.js/controller/fps-controller.js");

var _fpsController2 = _interopRequireDefault(_fpsController);

var _xhrLoader = __webpack_require__(/*! ./utils/xhr-loader */ "./src/hls.js/utils/xhr-loader.js");

var _xhrLoader2 = _interopRequireDefault(_xhrLoader);

var _audioTrackController = __webpack_require__(/*! ./controller/audio-track-controller */ "./src/hls.js/controller/audio-track-controller.js");

var _audioTrackController2 = _interopRequireDefault(_audioTrackController);

var _audioStreamController = __webpack_require__(/*! ./controller/audio-stream-controller */ "./src/hls.js/controller/audio-stream-controller.js");

var _audioStreamController2 = _interopRequireDefault(_audioStreamController);

var _cues = __webpack_require__(/*! ./utils/cues */ "./src/hls.js/utils/cues.js");

var Cues = _interopRequireWildcard(_cues);

var _timelineController = __webpack_require__(/*! ./controller/timeline-controller */ "./src/hls.js/controller/timeline-controller.js");

var _timelineController2 = _interopRequireDefault(_timelineController);

var _subtitleTrackController = __webpack_require__(/*! ./controller/subtitle-track-controller */ "./src/hls.js/controller/subtitle-track-controller.js");

var _subtitleTrackController2 = _interopRequireDefault(_subtitleTrackController);

var _subtitleStreamController = __webpack_require__(/*! ./controller/subtitle-stream-controller */ "./src/hls.js/controller/subtitle-stream-controller.js");

var _emeController = __webpack_require__(/*! ./controller/eme-controller */ "./src/hls.js/controller/eme-controller.js");

var _emeController2 = _interopRequireDefault(_emeController);

var _mediakeysHelper = __webpack_require__(/*! ./utils/mediakeys-helper */ "./src/hls.js/utils/mediakeys-helper.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import FetchLoader from './utils/fetch-loader';

var hlsDefaultConfig = exports.hlsDefaultConfig = {
  autoStartLoad: true, // used by stream-controller
  startPosition: -1, // used by stream-controller
  defaultAudioCodec: undefined, // used by stream-controller
  debug: false, // used by logger
  capLevelOnFPSDrop: false, // used by fps-controller
  capLevelToPlayerSize: false, // used by cap-level-controller
  initialLiveManifestSize: 1, // used by stream-controller
  maxBufferLength: 30, // used by stream-controller
  maxBufferSize: 60 * 1000 * 1000, // used by stream-controller
  maxBufferHole: 0.5, // used by stream-controller

  lowBufferWatchdogPeriod: 0.5, // used by stream-controller
  highBufferWatchdogPeriod: 3, // used by stream-controller
  nudgeOffset: 0.1, // used by stream-controller
  nudgeMaxRetry: 3, // used by stream-controller
  maxFragLookUpTolerance: 0.25, // used by stream-controller
  liveSyncDurationCount: 3, // used by stream-controller
  liveMaxLatencyDurationCount: Infinity, // used by stream-controller
  liveSyncDuration: undefined, // used by stream-controller
  liveMaxLatencyDuration: undefined, // used by stream-controller
  liveDurationInfinity: false, // used by buffer-controller
  liveBackBufferLength: Infinity, // used by buffer-controller
  maxMaxBufferLength: 600, // used by stream-controller
  enableWorker: true, // used by demuxer
  enableSoftwareAES: true, // used by decrypter
  manifestLoadingTimeOut: 10000, // used by playlist-loader
  manifestLoadingMaxRetry: 1, // used by playlist-loader
  manifestLoadingRetryDelay: 1000, // used by playlist-loader
  manifestLoadingMaxRetryTimeout: 64000, // used by playlist-loader
  startLevel: undefined, // used by level-controller
  levelLoadingTimeOut: 10000, // used by playlist-loader
  levelLoadingMaxRetry: 4, // used by playlist-loader
  levelLoadingRetryDelay: 1000, // used by playlist-loader
  levelLoadingMaxRetryTimeout: 64000, // used by playlist-loader
  fragLoadingTimeOut: 20000, // used by fragment-loader
  fragLoadingMaxRetry: 6, // used by fragment-loader
  fragLoadingRetryDelay: 1000, // used by fragment-loader
  fragLoadingMaxRetryTimeout: 64000, // used by fragment-loader
  startFragPrefetch: false, // used by stream-controller
  fpsDroppedMonitoringPeriod: 5000, // used by fps-controller
  fpsDroppedMonitoringThreshold: 0.2, // used by fps-controller
  appendErrorMaxRetry: 3, // used by buffer-controller
  loader: _xhrLoader2.default,
  // loader: FetchLoader,
  fLoader: undefined, // used by fragment-loader
  pLoader: undefined, // used by playlist-loader
  xhrSetup: undefined, // used by xhr-loader
  licenseXhrSetup: undefined, // used by eme-controller
  // fetchSetup: undefined,
  abrController: _abrController2.default,
  bufferController: _bufferController2.default,
  capLevelController: _capLevelController2.default,
  fpsController: _fpsController2.default,
  stretchShortVideoTrack: false, // used by mp4-remuxer
  maxAudioFramesDrift: 1, // used by mp4-remuxer
  forceKeyFrameOnDiscontinuity: true, // used by ts-demuxer
  abrEwmaFastLive: 3, // used by abr-controller
  abrEwmaSlowLive: 9, // used by abr-controller
  abrEwmaFastVoD: 3, // used by abr-controller
  abrEwmaSlowVoD: 9, // used by abr-controller
  abrEwmaDefaultEstimate: 5e5, // 500 kbps  // used by abr-controller
  abrBandWidthFactor: 0.95, // used by abr-controller
  abrBandWidthUpFactor: 0.7, // used by abr-controller
  abrMaxWithRealBitrate: false, // used by abr-controller
  maxStarvationDelay: 4, // used by abr-controller
  maxLoadingDelay: 4, // used by abr-controller
  minAutoBitrate: 0, // used by hls
  emeEnabled: false, // used by eme-controller
  widevineLicenseUrl: undefined, // used by eme-controller
  requestMediaKeySystemAccessFunc: _mediakeysHelper.requestMediaKeySystemAccess // used by eme-controller
}; /**
    * HLS config
    */

hlsDefaultConfig.subtitleStreamController = _subtitleStreamController.SubtitleStreamController;
hlsDefaultConfig.subtitleTrackController = _subtitleTrackController2.default;
hlsDefaultConfig.timelineController = _timelineController2.default;
hlsDefaultConfig.cueHandler = Cues; // used by timeline-controller
hlsDefaultConfig.enableCEA708Captions = true; // used by timeline-controller
hlsDefaultConfig.enableWebVTT = true; // used by timeline-controller
hlsDefaultConfig.captionsTextTrack1Label = 'English'; // used by timeline-controller
hlsDefaultConfig.captionsTextTrack1LanguageCode = 'en'; // used by timeline-controller
hlsDefaultConfig.captionsTextTrack2Label = 'Spanish'; // used by timeline-controller
hlsDefaultConfig.captionsTextTrack2LanguageCode = 'es'; // used by timeline-controller


hlsDefaultConfig.audioStreamController = _audioStreamController2.default;
hlsDefaultConfig.audioTrackController = _audioTrackController2.default;

hlsDefaultConfig.emeController = _emeController2.default;

/***/ }),

/***/ "./src/hls.js/controller/abr-controller.js":
/*!*************************************************!*\
  !*** ./src/hls.js/controller/abr-controller.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _ewmaBandwidthEstimator = __webpack_require__(/*! ../utils/ewma-bandwidth-estimator */ "./src/hls.js/utils/ewma-bandwidth-estimator.js");

var _ewmaBandwidthEstimator2 = _interopRequireDefault(_ewmaBandwidthEstimator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * simple ABR Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - compute next level based on last fragment bw heuristics
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _window = window,
    performance = _window.performance;

var AbrController = function (_EventHandler) {
  _inherits(AbrController, _EventHandler);

  function AbrController(hls) {
    _classCallCheck(this, AbrController);

    var _this = _possibleConstructorReturn(this, (AbrController.__proto__ || Object.getPrototypeOf(AbrController)).call(this, hls, _events2.default.FRAG_LOADING, _events2.default.FRAG_LOADED, _events2.default.FRAG_BUFFERED, _events2.default.ERROR));

    _this.lastLoadedFragLevel = 0;
    _this._nextAutoLevel = -1;
    _this.hls = hls;
    _this.timer = null;
    _this._bwEstimator = null;
    _this.onCheck = _this._abandonRulesCheck.bind(_this);
    return _this;
  }

  _createClass(AbrController, [{
    key: 'destroy',
    value: function destroy() {
      this.clearTimer();
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag;
      if (frag.type === 'main') {
        if (!this.timer) {
          this.fragCurrent = frag;
          this.timer = setInterval(this.onCheck, 100);
        }

        // lazy init of BwEstimator, rationale is that we use different params for Live/VoD
        // so we need to wait for stream manifest / playlist type to instantiate it.
        if (!this._bwEstimator) {
          var hls = this.hls;
          var config = hls.config;
          var level = frag.levels;
          var isLive = hls.levels[level].details.live;

          var ewmaFast = void 0,
              ewmaSlow = void 0;
          if (isLive) {
            ewmaFast = config.abrEwmaFastLive;
            ewmaSlow = config.abrEwmaSlowLive;
          } else {
            ewmaFast = config.abrEwmaFastVoD;
            ewmaSlow = config.abrEwmaSlowVoD;
          }
          this._bwEstimator = new _ewmaBandwidthEstimator2.default(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);
        }
      }
    }
  }, {
    key: '_abandonRulesCheck',
    value: function _abandonRulesCheck() {
      /*
        monitor fragment retrieval time...
        we compute expected time of arrival of the complete fragment.
        we compare it to expected time of buffer starvation
      */
      var hls = this.hls;
      var video = hls.media;
      var frag = this.fragCurrent;

      if (!frag) {
        return;
      }

      var loader = frag.loader;
      var minAutoLevel = hls.minAutoLevel;

      // if loader has been destroyed or loading has been aborted, stop timer and return
      if (!loader || loader.stats && loader.stats.aborted) {
        _logger.logger.warn('frag loader destroy or aborted, disarm abandonRules');
        this.clearTimer();
        // reset forced auto level value so that next level will be selected
        this._nextAutoLevel = -1;
        return;
      }
      var stats = loader.stats;
      /* only monitor frag retrieval time if
      (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */
      if (video && stats && (!video.paused && video.playbackRate !== 0 || !video.readyState) && frag.autoLevel && frag.levels) {
        var requestDelay = performance.now() - stats.trequest,
            playbackRate = Math.abs(video.playbackRate);
        // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
        if (requestDelay > 500 * frag.duration / playbackRate) {
          var levels = hls.levels,
              loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay),
              // byte/s; at least 1 byte/s to avoid division by zero
          // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size
          level = levels[frag.levels],
              levelBitrate = level.realBitrate ? Math.max(level.realBitrate, level.bitrate) : level.bitrate,
              expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levelBitrate / 8)),
              pos = video.currentTime,
              fragLoadedDelay = (expectedLen - stats.loaded) / loadRate,
              bufferStarvationDelay = (_bufferHelper.BufferHelper.bufferInfo(video, pos, hls.config.maxBufferHole).end - pos) / playbackRate;
          // consider emergency switch down only if we have less than 2 frag buffered AND
          // time to finish loading current fragment is bigger than buffer starvation delay
          // ie if we risk buffer starvation if bw does not increase quickly
          if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) {
            var fragLevelNextLoadedDelay = void 0,
                nextLoadLevel = void 0;
            // lets iterate through lower level and try to find the biggest one that could avoid rebuffering
            // we start from current level - 1 and we step down , until we find a matching level
            for (nextLoadLevel = frag.levels - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
              // compute time to load next fragment at lower level
              // 0.8 : consider only 80% of current bw to be conservative
              // 8 = bits per byte (bps/Bps)
              var levelNextBitrate = levels[nextLoadLevel].realBitrate ? Math.max(levels[nextLoadLevel].realBitrate, levels[nextLoadLevel].bitrate) : levels[nextLoadLevel].bitrate;
              fragLevelNextLoadedDelay = frag.duration * levelNextBitrate / (8 * 0.8 * loadRate);
              if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
                // we found a lower level that be rebuffering free with current estimated bw !
                break;
              }
            }
            // only emergency switch down if it takes less time to load new fragment at lowest level instead
            // of finishing loading current one ...
            if (fragLevelNextLoadedDelay < fragLoadedDelay) {
              _logger.logger.warn('loading too slow, abort fragment loading and switch to level ' + nextLoadLevel + ':fragLoadedDelay[' + nextLoadLevel + ']<fragLoadedDelay[' + (frag.levels - 1) + '];bufferStarvationDelay:' + fragLevelNextLoadedDelay.toFixed(1) + '<' + fragLoadedDelay.toFixed(1) + ':' + bufferStarvationDelay.toFixed(1));
              // force next load level in auto mode
              hls.nextLoadLevel = nextLoadLevel;
              // update bw estimate for this fragment before cancelling load (this will help reducing the bw)
              this._bwEstimator.sample(requestDelay, stats.loaded);
              // abort fragment loading
              loader.abort();
              // stop abandon rules timer
              this.clearTimer();
              hls.trigger(_events2.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag, stats: stats });
            }
          }
        }
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var frag = data.frag;
      if (frag.type === 'main' && Number.isFinite(frag.sn)) {
        // stop monitoring bw once frag loaded
        this.clearTimer();
        // store level id after successful fragment load
        this.lastLoadedFragLevel = frag.levels;
        // reset forced auto level value so that next level will be selected
        this._nextAutoLevel = -1;

        // compute level average bitrate
        if (this.hls.config.abrMaxWithRealBitrate) {
          var level = this.hls.levels[frag.levels];
          var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + data.stats.loaded;
          var loadedDuration = (level.loaded ? level.loaded.duration : 0) + data.frag.duration;
          level.loaded = { bytes: loadedBytes, duration: loadedDuration };
          level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
        }
        // if fragment has been loaded to perform a bitrate test,
        if (data.frag.bitrateTest) {
          var stats = data.stats;
          stats.tparsed = stats.tbuffered = stats.tload;
          this.onFragBuffered(data);
        }
      }
    }
  }, {
    key: 'onFragBuffered',
    value: function onFragBuffered(data) {
      var stats = data.stats;
      var frag = data.frag;
      // only update stats on first frag buffering
      // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
      // and leading to wrong bw estimation
      // on bitrate test, also only update stats once (if tload = tbuffered == on FRAG_LOADED)
      if (stats.aborted !== true && frag.type === 'main' && Number.isFinite(frag.sn) && (!frag.bitrateTest || stats.tload === stats.tbuffered)) {
        // use tparsed-trequest instead of tbuffered-trequest to compute fragLoadingProcessing; rationale is that  buffer appending only happens once media is attached
        // in case we use config.startFragPrefetch while media is not attached yet, fragment might be parsed while media not attached yet, but it will only be buffered on media attached
        // as a consequence it could happen really late in the process. meaning that appending duration might appears huge ... leading to underestimated throughput estimation
        var fragLoadingProcessingMs = stats.tparsed - stats.trequest;
        _logger.logger.log('latency/loading/parsing/append/kbps:' + Math.round(stats.tfirst - stats.trequest) + '/' + Math.round(stats.tload - stats.tfirst) + '/' + Math.round(stats.tparsed - stats.tload) + '/' + Math.round(stats.tbuffered - stats.tparsed) + '/' + Math.round(8 * stats.loaded / (stats.tbuffered - stats.trequest)));
        this._bwEstimator.sample(fragLoadingProcessingMs, stats.loaded);
        stats.bwEstimate = this._bwEstimator.getEstimate();
        // if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration
        if (frag.bitrateTest) {
          this.bitrateTestDelay = fragLoadingProcessingMs / 1000;
        } else {
          this.bitrateTestDelay = 0;
        }
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      // stop timer in case of frag loading error
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          this.clearTimer();
          break;
        default:
          break;
      }
    }
  }, {
    key: 'clearTimer',
    value: function clearTimer() {
      clearInterval(this.timer);
      this.timer = null;
    }

    // return next auto level

  }, {
    key: '_findBestLevel',
    value: function _findBestLevel(currentLevel, currentFragDuration, currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor, levels) {
      for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
        var levelInfo = levels[i];

        if (!levelInfo) {
          continue;
        }

        var levelDetails = levelInfo.details,
            avgDuration = levelDetails ? levelDetails.totalduration / levelDetails.fragments.length : currentFragDuration,
            live = levelDetails ? levelDetails.live : false,
            adjustedbw = void 0;
        // follow algorithm captured from stagefright :
        // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
        // Pick the highest bandwidth stream below or equal to estimated bandwidth.
        // consider only 80% of the available bandwidth, but if we are switching up,
        // be even more conservative (70%) to avoid overestimating and immediately
        // switching back.
        if (i <= currentLevel) {
          adjustedbw = bwFactor * currentBw;
        } else {
          adjustedbw = bwUpFactor * currentBw;
        }

        var bitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate,
            fetchDuration = bitrate * avgDuration / adjustedbw;

        _logger.logger.trace('level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: ' + i + '/' + Math.round(adjustedbw) + '/' + bitrate + '/' + avgDuration + '/' + maxFetchDuration + '/' + fetchDuration);
        // if adjusted bw is greater than level bitrate AND
        if (adjustedbw > bitrate && (
        // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
        // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
        // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that _findBestLevel will return -1
        !fetchDuration || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {
          // as we are looping from highest to lowest, this will return the best achievable quality level
          return i;
        }
      }
      // not enough time budget even with quality level 0 ... rebuffering might happen
      return -1;
    }
  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var forcedAutoLevel = this._nextAutoLevel;
      var bwEstimator = this._bwEstimator;
      // in case next auto level has been forced, and bw not available or not reliable, return forced value
      if (forcedAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {
        return forcedAutoLevel;
      }

      // compute next level using ABR logic
      var nextABRAutoLevel = this._nextABRAutoLevel;
      // if forced auto level has been defined, use it to cap ABR computed quality level
      if (forcedAutoLevel !== -1) {
        nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);
      }

      return nextABRAutoLevel;
    },
    set: function set(nextLevel) {
      this._nextAutoLevel = nextLevel;
    }
  }, {
    key: '_nextABRAutoLevel',
    get: function get() {
      var hls = this.hls,
          maxAutoLevel = hls.maxAutoLevel,
          levels = hls.levels,
          config = hls.config,
          minAutoLevel = hls.minAutoLevel;
      var video = hls.media,
          currentLevel = this.lastLoadedFragLevel,
          currentFragDuration = this.fragCurrent ? this.fragCurrent.duration : 0,
          pos = video ? video.currentTime : 0,

      // playbackRate is the absolute value of the playback rate; if video.playbackRate is 0, we use 1 to load as
      // if we're playing back at the normal rate.
      playbackRate = video && video.playbackRate !== 0 ? Math.abs(video.playbackRate) : 1.0,
          avgbw = this._bwEstimator ? this._bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate,

      // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.
      bufferStarvationDelay = (_bufferHelper.BufferHelper.bufferInfo(video, pos, config.maxBufferHole).end - pos) / playbackRate;

      // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all
      var bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);
      if (bestLevel >= 0) {
        return bestLevel;
      } else {
        _logger.logger.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering');
        // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering
        // if no matching level found, logic will return 0
        var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay,
            bwFactor = config.abrBandWidthFactor,
            bwUpFactor = config.abrBandWidthUpFactor;
        if (bufferStarvationDelay === 0) {
          // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
          var bitrateTestDelay = this.bitrateTestDelay;
          if (bitrateTestDelay) {
            // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
            // max video loading delay used in  automatic start level selection :
            // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
            // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
            // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration
            var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
            maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
            _logger.logger.trace('bitrate test took ' + Math.round(1000 * bitrateTestDelay) + 'ms, set first fragment max fetchDuration to ' + Math.round(1000 * maxStarvationDelay) + ' ms');
            // don't use conservative factor on bitrate test
            bwFactor = bwUpFactor = 1;
          }
        }
        bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor, levels);
        return Math.max(bestLevel, 0);
      }
    }
  }]);

  return AbrController;
}(_eventHandler2.default);

exports.default = AbrController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/audio-stream-controller.js":
/*!**********************************************************!*\
  !*** ./src/hls.js/controller/audio-stream-controller.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = __webpack_require__(/*! ../utils/binary-search */ "./src/hls.js/utils/binary-search.js");

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _demuxer = __webpack_require__(/*! ../demux/demuxer */ "./src/hls.js/demux/demuxer.js");

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

var LevelHelper = _interopRequireWildcard(_levelHelper);

var _timeRanges = __webpack_require__(/*! ../utils/time-ranges */ "./src/hls.js/utils/time-ranges.js");

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _discontinuities = __webpack_require__(/*! ../utils/discontinuities */ "./src/hls.js/utils/discontinuities.js");

var _fragmentTracker = __webpack_require__(/*! ./fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _fragment = __webpack_require__(/*! ../loader/fragment */ "./src/hls.js/loader/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _baseStreamController = __webpack_require__(/*! ./base-stream-controller */ "./src/hls.js/controller/base-stream-controller.js");

var _baseStreamController2 = _interopRequireDefault(_baseStreamController);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Audio Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var _window = window,
    performance = _window.performance;


var TICK_INTERVAL = 100; // how often to tick in ms

var AudioStreamController = function (_BaseStreamController) {
  _inherits(AudioStreamController, _BaseStreamController);

  function AudioStreamController(hls, fragmentTracker) {
    _classCallCheck(this, AudioStreamController);

    var _this = _possibleConstructorReturn(this, (AudioStreamController.__proto__ || Object.getPrototypeOf(AudioStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.AUDIO_TRACKS_UPDATED, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.BUFFER_RESET, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED, _events2.default.INIT_PTS_FOUND));

    _this.fragmentTracker = fragmentTracker;
    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this._state = _baseStreamController.State.STOPPED;
    _this.initPTS = [];
    _this.waitingFragment = null;
    _this.videoTrackCC = null;
    return _this;
  }

  // Signal that video PTS was found


  _createClass(AudioStreamController, [{
    key: 'onInitPtsFound',
    value: function onInitPtsFound(data) {
      var demuxerId = data.id,
          cc = data.frag.cc,
          initPTS = data.initPTS;
      if (demuxerId === 'main') {
        // Always update the new INIT PTS
        // Can change due level switch
        this.initPTS[cc] = initPTS;
        this.videoTrackCC = cc;
        _logger.logger.log('InitPTS for cc: ' + cc + ' found from video track: ' + initPTS);

        // If we are waiting we need to demux/remux the waiting frag
        // With the new initPTS
        if (this.state === _baseStreamController.State.WAITING_INIT_PTS) {
          this.tick();
        }
      }
    }
  }, {
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.tracks) {
        var lastCurrentTime = this.lastCurrentTime;
        this.stopLoad();
        this.setInterval(TICK_INTERVAL);
        this.fragLoadError = 0;
        if (lastCurrentTime > 0 && startPosition === -1) {
          _logger.logger.log('audio:override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
          this.state = _baseStreamController.State.IDLE;
        } else {
          this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
          this.state = _baseStreamController.State.STARTING;
        }
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
        this.tick();
      } else {
        this.startPosition = startPosition;
        this.state = _baseStreamController.State.STOPPED;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      var pos = void 0,
          track = void 0,
          trackDetails = void 0,
          hls = this.hls,
          config = hls.config;
      // logger.log('audioStream:' + this.state);
      switch (this.state) {
        case _baseStreamController.State.ERROR:
        // don't do anything in error state to avoid breaking further ...
        case _baseStreamController.State.PAUSED:
        // don't do anything in paused state either ...
        case _baseStreamController.State.BUFFER_FLUSHING:
          break;
        case _baseStreamController.State.STARTING:
          this.state = _baseStreamController.State.WAITING_TRACK;
          this.loadedmetadata = false;
          break;
        case _baseStreamController.State.IDLE:
          var tracks = this.tracks;
          // audio tracks not received => exit loop
          if (!tracks) {
            break;
          }

          // if video not attached AND
          // start fragment already requested OR start frag prefetch disable
          // exit loop
          // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
          if (!this.media && (this.startFragRequested || !config.startFragPrefetch)) {
            break;
          }

          // determine next candidate fragment to be loaded, based on current position and
          //  end of buffer position
          // if we have not yet loaded any fragment, start loading from start position
          if (this.loadedmetadata) {
            pos = this.media.currentTime;
          } else {
            pos = this.nextLoadPosition;
            if (pos === undefined) {
              break;
            }
          }
          var media = this.mediaBuffer ? this.mediaBuffer : this.media,
              videoBuffer = this.videoBuffer ? this.videoBuffer : this.media,
              bufferInfo = _bufferHelper.BufferHelper.bufferInfo(media, pos, config.maxBufferHole),
              mainBufferInfo = _bufferHelper.BufferHelper.bufferInfo(videoBuffer, pos, config.maxBufferHole),
              bufferLen = bufferInfo.len,
              bufferEnd = bufferInfo.end,
              fragPrevious = this.fragPrevious,

          // ensure we buffer at least config.maxBufferLength (default 30s) or config.maxMaxBufferLength (default: 600s)
          // whichever is smaller.
          // once we reach that threshold, don't buffer more than video (mainBufferInfo.len)
          maxConfigBuffer = Math.min(config.maxBufferLength, config.maxMaxBufferLength),
              maxBufLen = Math.max(maxConfigBuffer, mainBufferInfo.len),
              audioSwitch = this.audioSwitch,
              trackId = this.trackId;

          // if buffer length is less than maxBufLen try to load a new fragment
          if ((bufferLen < maxBufLen || audioSwitch) && trackId < tracks.length) {
            trackDetails = tracks[trackId].details;
            // if track info not retrieved yet, switch state and wait for track retrieval
            if (typeof trackDetails === 'undefined') {
              this.state = _baseStreamController.State.WAITING_TRACK;
              break;
            }

            if (!audioSwitch && this._streamEnded(bufferInfo, trackDetails)) {
              this.hls.trigger(_events2.default.BUFFER_EOS, { type: 'audio' });
              this.state = _baseStreamController.State.ENDED;
              return;
            }

            // find fragment index, contiguous with end of buffer position
            var fragments = trackDetails.fragments,
                fragLen = fragments.length,
                start = fragments[0].start,
                end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
                frag = void 0;

            // When switching audio track, reload audio as close as possible to currentTime
            if (audioSwitch) {
              if (trackDetails.live && !trackDetails.PTSKnown) {
                _logger.logger.log('switching audiotrack, live stream, unknown PTS,load first fragment');
                bufferEnd = 0;
              } else {
                bufferEnd = pos;
                // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime
                if (trackDetails.PTSKnown && pos < start) {
                  // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start
                  if (bufferInfo.end > start || bufferInfo.nextStart) {
                    _logger.logger.log('alt audio track ahead of main track, seek to start of alt audio track');
                    this.media.currentTime = start + 0.05;
                  } else {
                    return;
                  }
                }
              }
            }
            if (trackDetails.initSegment && !trackDetails.initSegment.data) {
              frag = trackDetails.initSegment;
            } // eslint-disable-line brace-style
            // if bufferEnd before start of playlist, load first fragment
            else if (bufferEnd <= start) {
                frag = fragments[0];
                if (this.videoTrackCC !== null && frag.cc !== this.videoTrackCC) {
                  // Ensure we find a fragment which matches the continuity of the video track
                  frag = (0, _discontinuities.findFragWithCC)(fragments, this.videoTrackCC);
                }
                if (trackDetails.live && frag.loadIdx && frag.loadIdx === this.fragLoadIdx) {
                  // we just loaded this first fragment, and we are still lagging behind the start of the live playlist
                  // let's force seek to start
                  var nextBuffered = bufferInfo.nextStart ? bufferInfo.nextStart : start;
                  _logger.logger.log('no alt audio available @currentTime:' + this.media.currentTime + ', seeking @' + (nextBuffered + 0.05));
                  this.media.currentTime = nextBuffered + 0.05;
                  return;
                }
              } else {
                var foundFrag = void 0;
                var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;
                var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {
                  // offset should be within fragment boundary - config.maxFragLookUpTolerance
                  // this is to cope with situations like
                  // bufferEnd = 9.991
                  // frag[Ø] : [0,10]
                  // frag[1] : [10,20]
                  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
                  //              frag start               frag start+duration
                  //                  |-----------------------------|
                  //              <--->                         <--->
                  //  ...--------><-----------------------------><---------....
                  // previous frag         matching fragment         next frag
                  //  return -1             return 0                 return 1
                  // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
                  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
                  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);
                  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
                    return 1;
                  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
                    // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
                    return -1;
                  }

                  return 0;
                };

                if (bufferEnd < end) {
                  if (bufferEnd > end - maxFragLookUpTolerance) {
                    maxFragLookUpTolerance = 0;
                  }

                  // Prefer the next fragment if it's within tolerance
                  if (fragNext && !fragmentWithinToleranceTest(fragNext)) {
                    foundFrag = fragNext;
                  } else {
                    foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);
                  }
                } else {
                  // reach end of playlist
                  foundFrag = fragments[fragLen - 1];
                }
                if (foundFrag) {
                  frag = foundFrag;
                  start = foundFrag.start;
                  // logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
                  if (fragPrevious && frag.levels === fragPrevious.levels && frag.sn === fragPrevious.sn) {
                    if (frag.sn < trackDetails.endSN) {
                      frag = fragments[frag.sn + 1 - trackDetails.startSN];
                      _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
                    } else {
                      frag = null;
                    }
                  }
                }
              }
            if (frag) {
              // logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
              if (frag.encrypted) {
                _logger.logger.log('Loading key for ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId);
                this.state = _baseStreamController.State.KEY_LOADING;
                hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
              } else {
                _logger.logger.log('Loading ' + frag.sn + ', cc: ' + frag.cc + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));
                // only load if fragment is not loaded or if in audio switch
                // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch
                this.fragCurrent = frag;
                if (audioSwitch || this.fragmentTracker.getState(frag) === _fragmentTracker.FragmentState.NOT_LOADED) {
                  this.startFragRequested = true;
                  if (Number.isFinite(frag.sn)) {
                    this.nextLoadPosition = frag.start + frag.duration;
                  }

                  hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
                  this.state = _baseStreamController.State.FRAG_LOADING;
                }
              }
            }
          }
          break;
        case _baseStreamController.State.WAITING_TRACK:
          track = this.tracks[this.trackId];
          // check if playlist is already loaded
          if (track && track.details) {
            this.state = _baseStreamController.State.IDLE;
          }

          break;
        case _baseStreamController.State.FRAG_LOADING_WAITING_RETRY:
          var now = performance.now();
          var retryDate = this.retryDate;
          media = this.media;
          var isSeeking = media && media.seeking;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || isSeeking) {
            _logger.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');
            this.state = _baseStreamController.State.IDLE;
          }
          break;
        case _baseStreamController.State.WAITING_INIT_PTS:
          var videoTrackCC = this.videoTrackCC;
          if (this.initPTS[videoTrackCC] === undefined) {
            break;
          }

          // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS
          var waitingFrag = this.waitingFragment;
          if (waitingFrag) {
            var waitingFragCC = waitingFrag.frag.cc;
            if (videoTrackCC !== waitingFragCC) {
              track = this.tracks[this.trackId];
              if (track.details && track.details.live) {
                _logger.logger.warn('Waiting fragment CC (' + waitingFragCC + ') does not match video track CC (' + videoTrackCC + ')');
                this.waitingFragment = null;
                this.state = _baseStreamController.State.IDLE;
              }
            } else {
              this.state = _baseStreamController.State.FRAG_LOADING;
              this.onFragLoaded(this.waitingFragment);
              this.waitingFragment = null;
            }
          } else {
            this.state = _baseStreamController.State.IDLE;
          }

          break;
        case _baseStreamController.State.STOPPED:
        case _baseStreamController.State.FRAG_LOADING:
        case _baseStreamController.State.PARSING:
        case _baseStreamController.State.PARSED:
        case _baseStreamController.State.ENDED:
          break;
        default:
          break;
      }
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.tracks && config.autoStartLoad) {
        this.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = this.mediaBuffer = this.videoBuffer = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onAudioTracksUpdated',
    value: function onAudioTracksUpdated(data) {
      _logger.logger.log('audio tracks updated');
      this.tracks = data.audioTracks;
    }
  }, {
    key: 'onAudioTrackSwitching',
    value: function onAudioTrackSwitching(data) {
      // if any URL found on new audio track, it is an alternate audio track
      var altAudio = !!data.url;
      this.trackId = data.id;

      this.fragCurrent = null;
      this.state = _baseStreamController.State.PAUSED;
      this.waitingFragment = null;
      // destroy useless demuxer when switching audio to main
      if (!altAudio) {
        if (this.demuxer) {
          this.demuxer.destroy();
          this.demuxer = null;
        }
      } else {
        // switching to audio track, start timer if not already started
        this.setInterval(TICK_INTERVAL);
      }

      // should we switch tracks ?
      if (altAudio) {
        this.audioSwitch = true;
        // main audio track are handled by stream-controller, just do something if switching to alt audio track
        this.state = _baseStreamController.State.IDLE;
      }
      this.tick();
    }
  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      var newDetails = data.details,
          trackId = data.id,
          track = this.tracks[trackId],
          duration = newDetails.totalduration,
          sliding = 0;

      _logger.logger.log('track ' + trackId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);

      if (newDetails.live) {
        var curDetails = track.details;
        if (curDetails && newDetails.fragments.length > 0) {
          // we already have details for that level, merge them
          LevelHelper.mergeDetails(curDetails, newDetails);
          sliding = newDetails.fragments[0].start;
          // TODO
          // this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
          if (newDetails.PTSKnown) {
            _logger.logger.log('live audio playlist sliding:' + sliding.toFixed(3));
          } else {
            _logger.logger.log('live audio playlist - outdated PTS, unknown sliding');
          }
        } else {
          newDetails.PTSKnown = false;
          _logger.logger.log('live audio playlist - first load, unknown sliding');
        }
      } else {
        newDetails.PTSKnown = false;
      }
      track.details = newDetails;

      // compute start position
      if (!this.startFragRequested) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = newDetails.startTimeOffset;
          if (Number.isFinite(startTimeOffset)) {
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            this.startPosition = 0;
          }
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment
      if (this.state === _baseStreamController.State.WAITING_TRACK) {
        this.state = _baseStreamController.State.IDLE;
      }

      // trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === _baseStreamController.State.KEY_LOADING) {
        this.state = _baseStreamController.State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent,
          fragLoaded = data.frag;
      if (this.state === _baseStreamController.State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'audio' && fragLoaded.levels === fragCurrent.levels && fragLoaded.sn === fragCurrent.sn) {
        var track = this.tracks[this.trackId],
            details = track.details,
            duration = details.totalduration,
            trackId = fragCurrent.levels,
            sn = fragCurrent.sn,
            cc = fragCurrent.cc,
            audioCodec = this.config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2',
            stats = this.stats = data.stats;
        if (sn === 'initSegment') {
          this.state = _baseStreamController.State.IDLE;

          stats.tparsed = stats.tbuffered = performance.now();
          details.initSegment.data = data.payload;
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'audio' });
          this.tick();
        } else {
          this.state = _baseStreamController.State.PARSING;
          // transmux the MPEG-TS data to ISO-BMFF segments
          this.appended = false;
          if (!this.demuxer) {
            this.demuxer = new _demuxer2.default(this.hls, 'audio');
          }

          // Check if we have video initPTS
          // If not we need to wait for it
          var initPTS = this.initPTS[cc];
          var initSegmentData = details.initSegment ? details.initSegment.data : [];
          if (details.initSegment || initPTS !== undefined) {
            this.pendingBuffering = true;
            _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
            // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
            var accurateTimeOffset = false; // details.PTSKnown || !details.live;
            this.demuxer.push(data.payload, initSegmentData, audioCodec, null, fragCurrent, duration, accurateTimeOffset, initPTS);
          } else {
            _logger.logger.log('unknown video PTS for continuity counter ' + cc + ', waiting for video PTS before demuxing audio frag ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
            this.waitingFragment = data;
            this.state = _baseStreamController.State.WAITING_INIT_PTS;
          }
        }
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.levels === fragCurrent.levels && this.state === _baseStreamController.State.PARSING) {
        var tracks = data.tracks,
            track = void 0;

        // delete any video track found on audio demuxer
        if (tracks.video) {
          delete tracks.video;
        }

        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          track.levelCodec = track.codec;
          track.id = data.id;
          this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
          _logger.logger.log('audio track:audio,container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            var appendObj = { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' };
            if (this.audioSwitch) {
              this.pendingData = [appendObj];
            } else {
              this.appended = true;
              // arm pending Buffering flag before appending a segment
              this.pendingBuffering = true;
              this.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
            }
          }
          // trigger handler right now
          this.tick();
        }
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'audio' && data.type === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.levels === fragCurrent.levels && this.state === _baseStreamController.State.PARSING) {
        var trackId = this.trackId,
            track = this.tracks[trackId],
            hls = this.hls;

        if (!Number.isFinite(data.endPTS)) {
          data.endPTS = data.startPTS + fragCurrent.duration;
          data.endDTS = data.startDTS + fragCurrent.duration;
        }

        fragCurrent.addElementaryStream(_fragment2.default.ElementaryStreamTypes.AUDIO);

        _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb);
        LevelHelper.updateFragPTSDTS(track.details, fragCurrent, data.startPTS, data.endPTS);

        var audioSwitch = this.audioSwitch,
            media = this.media,
            appendOnBufferFlush = false;
        // Only flush audio from old audio tracks when PTS is known on new audio track
        if (audioSwitch && media) {
          if (media.readyState) {
            var currentTime = media.currentTime;
            _logger.logger.log('switching audio track : currentTime:' + currentTime);
            if (currentTime >= data.startPTS) {
              _logger.logger.log('switching audio track : flushing all audio');
              this.state = _baseStreamController.State.BUFFER_FLUSHING;
              hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
              appendOnBufferFlush = true;
              // Lets announce that the initial audio track switch flush occur
              this.audioSwitch = false;
              hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
            }
          } else {
            // Lets announce that the initial audio track switch flush occur
            this.audioSwitch = false;
            hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
          }
        }

        var pendingData = this.pendingData;

        if (!pendingData) {
          _logger.logger.warn('Apparently attempt to enqueue media payload without codec initialization data upfront');
          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: null, fatal: true });
          return;
        }

        if (!this.audioSwitch) {
          [data.data1, data.data2].forEach(function (buffer) {
            if (buffer && buffer.length) {
              pendingData.push({ type: data.type, data: buffer, parent: 'audio', content: 'data' });
            }
          });
          if (!appendOnBufferFlush && pendingData.length) {
            pendingData.forEach(function (appendObj) {
              // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
              // in that case it is useless to append following segments
              if (_this2.state === _baseStreamController.State.PARSING) {
                // arm pending Buffering flag before appending a segment
                _this2.pendingBuffering = true;
                _this2.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
              }
            });
            this.pendingData = [];
            this.appended = true;
          }
        }
        // trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.levels === fragCurrent.levels && this.state === _baseStreamController.State.PARSING) {
        this.stats.tparsed = performance.now();
        this.state = _baseStreamController.State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onBufferReset',
    value: function onBufferReset() {
      // reset reference to sourcebuffers
      this.mediaBuffer = this.videoBuffer = null;
      this.loadedmetadata = false;
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var audioTrack = data.tracks.audio;
      if (audioTrack) {
        this.mediaBuffer = audioTrack.buffer;
        this.loadedmetadata = true;
      }
      if (data.tracks.video) {
        this.videoBuffer = data.tracks.video.buffer;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'audio') {
        var state = this.state;
        if (state === _baseStreamController.State.PARSING || state === _baseStreamController.State.PARSED) {
          // check if all buffers have been appended
          this.pendingBuffering = data.pending > 0;
          this._checkAppendedParsed();
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      // trigger handler right now
      if (this.state === _baseStreamController.State.PARSED && (!this.appended || !this.pendingBuffering)) {
        var frag = this.fragCurrent,
            stats = this.stats,
            hls = this.hls;
        if (frag) {
          this.fragPrevious = frag;
          stats.tbuffered = performance.now();
          hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('audio buffered : ' + _timeRanges2.default.toString(media.buffered));
          if (this.audioSwitch && this.appended) {
            this.audioSwitch = false;
            hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: this.trackId });
          }
          this.state = _baseStreamController.State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle frag error not related to audio fragment
      if (frag && frag.type !== 'audio') {
        return;
      }

      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          var _frag = data.frag;
          // don't handle frag error not related to audio fragment
          if (_frag && _frag.type !== 'audio') {
            break;
          }

          if (!data.fatal) {
            var loadError = this.fragLoadError;
            if (loadError) {
              loadError++;
            } else {
              loadError = 1;
            }

            var config = this.config;
            if (loadError <= config.fragLoadingMaxRetry) {
              this.fragLoadError = loadError;
              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
              _logger.logger.warn('AudioStreamController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = performance.now() + delay;
              // retry loading state
              this.state = _baseStreamController.State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('AudioStreamController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // switch error to fatal
              data.fatal = true;
              this.state = _baseStreamController.State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
          if (this.state !== _baseStreamController.State.ERROR) {
            // if fatal error, stop processing, otherwise move to IDLE to retry loading
            this.state = data.fatal ? _baseStreamController.State.ERROR : _baseStreamController.State.IDLE;
            _logger.logger.warn('AudioStreamController: ' + data.details + ' while loading frag, now switching to ' + this.state + ' state ...');
          }
          break;
        case _errors.ErrorDetails.BUFFER_FULL_ERROR:
          // if in appending state
          if (data.parent === 'audio' && (this.state === _baseStreamController.State.PARSING || this.state === _baseStreamController.State.PARSED)) {
            var media = this.mediaBuffer,
                currentTime = this.media.currentTime,
                mediaBuffered = media && _bufferHelper.BufferHelper.isBuffered(media, currentTime) && _bufferHelper.BufferHelper.isBuffered(media, currentTime + 0.5);
            // reduce max buf len if current position is buffered
            if (mediaBuffered) {
              var _config = this.config;
              if (_config.maxMaxBufferLength >= _config.maxBufferLength) {
                // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
                _config.maxMaxBufferLength /= 2;
                _logger.logger.warn('AudioStreamController: reduce max buffer length to ' + _config.maxMaxBufferLength + 's');
              }
              this.state = _baseStreamController.State.IDLE;
            } else {
              // current position is not buffered, but browser is still complaining about buffer full error
              // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
              // in that case flush the whole audio buffer to recover
              _logger.logger.warn('AudioStreamController: buffer full error also media.currentTime is not buffered, flush audio buffer');
              this.fragCurrent = null;
              // flush everything
              this.state = _baseStreamController.State.BUFFER_FLUSHING;
              this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
            }
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      var _this3 = this;

      var pendingData = this.pendingData;
      if (pendingData && pendingData.length) {
        _logger.logger.log('AudioStreamController: appending pending audio data after buffer flushed');
        pendingData.forEach(function (appendObj) {
          _this3.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
        });
        this.appended = true;
        this.pendingData = [];
        this.state = _baseStreamController.State.PARSED;
      } else {
        // move to IDLE once flush complete. this should trigger new fragment loading
        this.state = _baseStreamController.State.IDLE;
        // reset reference to frag
        this.fragPrevious = null;
        this.tick();
      }
    }
  }, {
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        _logger.logger.log('audio stream:' + previousState + '->' + nextState);
      }
    },
    get: function get() {
      return this._state;
    }
  }]);

  return AudioStreamController;
}(_baseStreamController2.default);

exports.default = AudioStreamController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/audio-track-controller.js":
/*!*********************************************************!*\
  !*** ./src/hls.js/controller/audio-track-controller.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _taskLoop = __webpack_require__(/*! ../task-loop */ "./src/hls.js/task-loop.js");

var _taskLoop2 = _interopRequireDefault(_taskLoop);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class AudioTrackController
 * @implements {EventHandler}
 *
 * Handles main manifest and audio-track metadata loaded,
 * owns and exposes the selectable audio-tracks data-models.
 *
 * Exposes internal interface to select available audio-tracks.
 *
 * Handles errors on loading audio-track playlists. Manages fallback mechanism
 * with redundants tracks (group-IDs).
 *
 * Handles level-loading and group-ID switches for video (fallback on video levels),
 * and eventually adapts the audio-track group-ID to match.
 *
 * @fires AUDIO_TRACK_LOADING
 * @fires AUDIO_TRACK_SWITCHING
 * @fires AUDIO_TRACKS_UPDATED
 * @fires ERROR
 *
 */
var AudioTrackController = function (_TaskLoop) {
  _inherits(AudioTrackController, _TaskLoop);

  function AudioTrackController(hls) {
    _classCallCheck(this, AudioTrackController);

    /**
     * @private
     * Currently selected index in `tracks`
     * @member {number} trackId
     */
    var _this = _possibleConstructorReturn(this, (AudioTrackController.__proto__ || Object.getPrototypeOf(AudioTrackController)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.AUDIO_TRACK_LOADED, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.LEVEL_LOADED, _events2.default.ERROR));

    _this._trackId = -1;

    /**
     * @private
     * If should select tracks according to default track attribute
     * @member {boolean} _selectDefaultTrack
     */
    _this._selectDefaultTrack = true;

    /**
     * @public
     * All tracks available
     * @member {AudioTrack[]}
     */
    _this.tracks = [];

    /**
     * @public
     * List of blacklisted audio track IDs (that have caused failure)
     * @member {number[]}
     */
    _this.trackIdBlacklist = Object.create(null);

    /**
     * @public
     * The currently running group ID for audio
     * (we grab this on manifest-parsed and new level-loaded)
     * @member {string}
     */
    _this.audioGroupId = null;
    return _this;
  }

  /**
   * Reset audio tracks on new manifest loading.
   */


  _createClass(AudioTrackController, [{
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.tracks = [];
      this._trackId = -1;
      this._selectDefaultTrack = true;
    }

    /**
     * Store tracks data from manifest parsed data.
     *
     * Trigger AUDIO_TRACKS_UPDATED event.
     *
     * @param {*} data
     */

  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var tracks = this.tracks = data.audioTracks || [];
      this.hls.trigger(_events2.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks });
    }

    /**
     * Store track details of loaded track in our data-model.
     *
     * Set-up metadata update interval task for live-mode streams.
     *
     * @param {} data
     */

  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      if (data.id >= this.tracks.length) {
        _logger.logger.warn('Invalid audio track id:', data.id);
        return;
      }

      _logger.logger.log('audioTrack ' + data.id + ' loaded');

      this.tracks[data.id].details = data.details;

      // check if current playlist is a live playlist
      // and if we have already our reload interval setup
      if (data.details.live && !this.hasInterval()) {
        // if live playlist we will have to reload it periodically
        // set reload period to playlist target duration
        var updatePeriodMs = data.details.targetduration * 1000;
        this.setInterval(updatePeriodMs);
      }

      if (!data.details.live && this.hasInterval()) {
        // playlist is not live and timer is scheduled: cancel it
        this.clearInterval();
      }
    }

    /**
     * Update the internal group ID to any audio-track we may have set manually
     * or because of a failure-handling fallback.
     *
     * Quality-levels should update to that group ID in this case.
     *
     * @param {*} data
     */

  }, {
    key: 'onAudioTrackSwitched',
    value: function onAudioTrackSwitched(data) {
      var audioGroupId = this.tracks[data.id].groupId;
      if (audioGroupId && this.audioGroupId !== audioGroupId) {
        this.audioGroupId = audioGroupId;
      }
    }

    /**
     * When a level gets loaded, if it has redundant audioGroupIds (in the same ordinality as it's redundant URLs)
     * we are setting our audio-group ID internally to the one set, if it is different from the group ID currently set.
     *
     * If group-ID got update, we re-select the appropriate audio-track with this group-ID matching the currently
     * selected one (based on NAME property).
     *
     * @param {*} data
     */

  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      // FIXME: crashes because currentLevel is undefined
      // const levelInfo = this.hls.levels[this.hls.currentLevel];

      var levelInfo = this.hls.levels[data.levels];

      if (!levelInfo.audioGroupIds) {
        return;
      }

      var audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];
      if (this.audioGroupId !== audioGroupId) {
        this.audioGroupId = audioGroupId;
        this._selectInitialAudioTrack();
      }
    }

    /**
     * Handle network errors loading audio track manifests
     * and also pausing on any netwok errors.
     *
     * @param {ErrorEventData} data
     */

  }, {
    key: 'onError',
    value: function onError(data) {
      // Only handle network errors
      if (data.type !== _errors.ErrorTypes.NETWORK_ERROR) {
        return;
      }

      // If fatal network error, cancel update task
      if (data.fatal) {
        this.clearInterval();
      }

      // If not an audio-track loading error don't handle further
      if (data.details !== _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR) {
        return;
      }

      _logger.logger.warn('Network failure on audio-track id:', data.context.id);
      this._handleLoadError();
    }

    /**
     * @type {AudioTrack[]} Audio-track list we own
     */

  }, {
    key: '_setAudioTrack',


    /**
     * @private
     * @param {number} newId
     */
    value: function _setAudioTrack(newId) {
      // noop on same audio track id as already set
      if (this._trackId === newId && this.tracks[this._trackId].details) {
        _logger.logger.debug('Same id as current audio-track passed, and track details available -> no-op');
        return;
      }

      // check if level idx is valid
      if (newId < 0 || newId >= this.tracks.length) {
        _logger.logger.warn('Invalid id passed to audio-track controller');
        return;
      }

      var audioTrack = this.tracks[newId];

      _logger.logger.log('Now switching to audio-track index ' + newId);

      // stopping live reloading timer if any
      this.clearInterval();
      this._trackId = newId;

      var url = audioTrack.url,
          type = audioTrack.type,
          id = audioTrack.id;

      this.hls.trigger(_events2.default.AUDIO_TRACK_SWITCHING, { id: id, type: type, url: url });
      this._loadTrackDetailsIfNeeded(audioTrack);
    }

    /**
     * @override
     */

  }, {
    key: 'doTick',
    value: function doTick() {
      this._updateTrack(this._trackId);
    }

    /**
     * Select initial track
     * @private
     */

  }, {
    key: '_selectInitialAudioTrack',
    value: function _selectInitialAudioTrack() {
      var _this2 = this;

      var tracks = this.tracks;
      if (!tracks.length) {
        return;
      }

      var currentAudioTrack = this.tracks[this._trackId];

      var name = null;
      if (currentAudioTrack) {
        name = currentAudioTrack.name;
      }

      // Pre-select default tracks if there are any
      if (this._selectDefaultTrack) {
        var defaultTracks = tracks.filter(function (track) {
          return track.default;
        });
        if (defaultTracks.length) {
          tracks = defaultTracks;
        } else {
          _logger.logger.warn('No default audio tracks defined');
        }
      }

      var trackFound = false;

      var traverseTracks = function traverseTracks() {
        // Select track with right group ID
        tracks.forEach(function (track) {
          if (trackFound) {
            return;
          }
          // We need to match the (pre-)selected group ID
          // and the NAME of the current track.
          if ((!_this2.audioGroupId || track.groupId === _this2.audioGroupId) && (!name || name === track.name)) {
            // If there was a previous track try to stay with the same `NAME`.
            // It should be unique across tracks of same group, and consistent through redundant track groups.
            _this2._setAudioTrack(track.id);
            trackFound = true;
          }
        });
      };

      traverseTracks();

      if (!trackFound) {
        name = null;
        traverseTracks();
      }

      if (!trackFound) {
        _logger.logger.error('No track found for running audio group-ID: ' + this.audioGroupId);

        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR,
          fatal: true
        });
      }
    }

    /**
     * @private
     * @param {AudioTrack} audioTrack
     * @returns {boolean}
     */

  }, {
    key: '_needsTrackLoading',
    value: function _needsTrackLoading(audioTrack) {
      var details = audioTrack.details,
          url = audioTrack.url;


      if (!details || details.live) {
        // check if we face an audio track embedded in main playlist (audio track without URI attribute)
        return !!url;
      }

      return false;
    }

    /**
     * @private
     * @param {AudioTrack} audioTrack
     */

  }, {
    key: '_loadTrackDetailsIfNeeded',
    value: function _loadTrackDetailsIfNeeded(audioTrack) {
      if (this._needsTrackLoading(audioTrack)) {
        var url = audioTrack.url,
            id = audioTrack.id;
        // track not retrieved yet, or live playlist we need to (re)load it

        _logger.logger.log('loading audio-track playlist for id: ' + id);
        this.hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: id });
      }
    }

    /**
     * @private
     * @param {number} newId
     */

  }, {
    key: '_updateTrack',
    value: function _updateTrack(newId) {
      // check if level idx is valid
      if (newId < 0 || newId >= this.tracks.length) {
        return;
      }

      // stopping live reloading timer if any
      this.clearInterval();
      this._trackId = newId;
      _logger.logger.log('trying to update audio-track ' + newId);
      var audioTrack = this.tracks[newId];
      this._loadTrackDetailsIfNeeded(audioTrack);
    }

    /**
     * @private
     */

  }, {
    key: '_handleLoadError',
    value: function _handleLoadError() {
      // First, let's black list current track id
      this.trackIdBlacklist[this._trackId] = true;

      // Let's try to fall back on a functional audio-track with the same group ID
      var previousId = this._trackId;
      var _tracks$previousId = this.tracks[previousId],
          name = _tracks$previousId.name,
          language = _tracks$previousId.language,
          groupId = _tracks$previousId.groupId;


      _logger.logger.warn('Loading failed on audio track id: ' + previousId + ', group-id: ' + groupId + ', name/language: "' + name + '" / "' + language + '"');

      // Find a non-blacklisted track ID with the same NAME
      // At least a track that is not blacklisted, thus on another group-ID.
      var newId = previousId;
      for (var i = 0; i < this.tracks.length; i++) {
        if (this.trackIdBlacklist[i]) {
          continue;
        }
        var newTrack = this.tracks[i];
        if (newTrack.name === name) {
          newId = i;
          break;
        }
      }

      if (newId === previousId) {
        _logger.logger.warn('No fallback audio-track found for name/language: "' + name + '" / "' + language + '"');
        return;
      }

      _logger.logger.log('Attempting audio-track fallback id:', newId, 'group-id:', this.tracks[newId].groupId);

      this._setAudioTrack(newId);
    }
  }, {
    key: 'audioTracks',
    get: function get() {
      return this.tracks;
    }

    /**
     * @type {number} Index into audio-tracks list of currently selected track.
     */

  }, {
    key: 'audioTrack',
    get: function get() {
      return this._trackId;
    }

    /**
     * Select current track by index
     */
    ,
    set: function set(newId) {
      this._setAudioTrack(newId);
      // If audio track is selected from API then don't choose from the manifest default track
      this._selectDefaultTrack = false;
    }
  }]);

  return AudioTrackController;
}(_taskLoop2.default);

exports.default = AudioTrackController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/base-stream-controller.js":
/*!*********************************************************!*\
  !*** ./src/hls.js/controller/base-stream-controller.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.State = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _taskLoop = __webpack_require__(/*! ../task-loop */ "./src/hls.js/task-loop.js");

var _taskLoop2 = _interopRequireDefault(_taskLoop);

var _fragmentTracker = __webpack_require__(/*! ./fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var State = exports.State = {
  STOPPED: 'STOPPED',
  STARTING: 'STARTING',
  IDLE: 'IDLE',
  PAUSED: 'PAUSED',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_TRACK: 'WAITING_TRACK',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  BUFFER_FLUSHING: 'BUFFER_FLUSHING',
  ENDED: 'ENDED',
  ERROR: 'ERROR',
  WAITING_INIT_PTS: 'WAITING_INIT_PTS',
  WAITING_LEVEL: 'WAITING_LEVEL'
};

var BaseStreamController = function (_TaskLoop) {
  _inherits(BaseStreamController, _TaskLoop);

  function BaseStreamController() {
    _classCallCheck(this, BaseStreamController);

    return _possibleConstructorReturn(this, (BaseStreamController.__proto__ || Object.getPrototypeOf(BaseStreamController)).apply(this, arguments));
  }

  _createClass(BaseStreamController, [{
    key: 'doTick',
    value: function doTick() {}
  }, {
    key: 'startLoad',
    value: function startLoad() {}
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      var frag = this.fragCurrent;
      if (frag) {
        if (frag.loader) {
          frag.loader.abort();
        }
        this.fragmentTracker.removeFragment(frag);
      }
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
      this.fragCurrent = null;
      this.fragPrevious = null;
      this.clearInterval();
      this.clearNextTick();
      this.state = State.STOPPED;
    }
  }, {
    key: '_streamEnded',
    value: function _streamEnded(bufferInfo, levelDetails) {
      var fragCurrent = this.fragCurrent,
          fragmentTracker = this.fragmentTracker;
      // we just got done loading the final fragment and there is no other buffered range after ...
      // rationale is that in case there are any buffered ranges after, it means that there are unbuffered portion in between
      // so we should not switch to ENDED in that case, to be able to buffer them
      // dont switch to ENDED if we need to backtrack last fragment

      if (!levelDetails.live && fragCurrent && !fragCurrent.backtracked && fragCurrent.sn === levelDetails.endSN && !bufferInfo.nextStart) {
        var fragState = fragmentTracker.getState(fragCurrent);
        return fragState === _fragmentTracker.FragmentState.PARTIAL || fragState === _fragmentTracker.FragmentState.OK;
      }
      return false;
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      var config = this.config,
          media = this.media,
          mediaBuffer = this.mediaBuffer,
          state = this.state;

      var currentTime = media ? media.currentTime : null;
      var bufferInfo = _bufferHelper.BufferHelper.bufferInfo(mediaBuffer || media, currentTime, this.config.maxBufferHole);

      if (Number.isFinite(currentTime)) {
        _logger.logger.log('media seeking to ' + currentTime.toFixed(3));
      }

      if (state === State.FRAG_LOADING) {
        var fragCurrent = this.fragCurrent;
        // check if we are seeking to a unbuffered area AND if frag loading is in progress
        if (bufferInfo.len === 0 && fragCurrent) {
          var tolerance = config.maxFragLookUpTolerance;
          var fragStartOffset = fragCurrent.start - tolerance;
          var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
          // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything
          if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
            if (fragCurrent.loader) {
              _logger.logger.log('seeking outside of buffer while fragment load in progress, cancel fragment load');
              fragCurrent.loader.abort();
            }
            this.fragCurrent = null;
            this.fragPrevious = null;
            // switch to IDLE state to load new fragment
            this.state = State.IDLE;
          } else {
            _logger.logger.log('seeking outside of buffer but within currently loaded fragment range');
          }
        }
      } else if (state === State.ENDED) {
        // if seeking to unbuffered area, clean up fragPrevious
        if (bufferInfo.len === 0) {
          this.fragPrevious = null;
          this.fragCurrent = null;
        }

        // switch to IDLE state to check for potential new fragment
        this.state = State.IDLE;
      }
      if (media) {
        this.lastCurrentTime = currentTime;
      }

      // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target
      if (!this.loadedmetadata) {
        this.nextLoadPosition = this.startPosition = currentTime;
      }

      // tick to speed up processing
      this.tick();
    }
  }, {
    key: 'onMediaEnded',
    value: function onMediaEnded() {
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onHandlerDestroying',
    value: function onHandlerDestroying() {
      this.stopLoad();
      _get(BaseStreamController.prototype.__proto__ || Object.getPrototypeOf(BaseStreamController.prototype), 'onHandlerDestroying', this).call(this);
    }
  }, {
    key: 'onHandlerDestroyed',
    value: function onHandlerDestroyed() {
      this.state = State.STOPPED;
      this.fragmentTracker = null;
    }
  }]);

  return BaseStreamController;
}(_taskLoop2.default);

exports.default = BaseStreamController;

/***/ }),

/***/ "./src/hls.js/controller/buffer-controller.js":
/*!****************************************************!*\
  !*** ./src/hls.js/controller/buffer-controller.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _mediasourceHelper = __webpack_require__(/*! ../utils/mediasource-helper */ "./src/hls.js/utils/mediasource-helper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Buffer Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var MediaSource = (0, _mediasourceHelper.getMediaSource)();

var BufferController = function (_EventHandler) {
  _inherits(BufferController, _EventHandler);

  function BufferController(hls) {
    _classCallCheck(this, BufferController);

    // the value that we have set mediasource.duration to
    // (the actual duration may be tweaked slighly by the browser)
    var _this = _possibleConstructorReturn(this, (BufferController.__proto__ || Object.getPrototypeOf(BufferController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_RESET, _events2.default.BUFFER_APPENDING, _events2.default.BUFFER_CODECS, _events2.default.BUFFER_EOS, _events2.default.BUFFER_FLUSHING, _events2.default.LEVEL_PTS_UPDATED, _events2.default.LEVEL_UPDATED));

    _this._msDuration = null;
    // the value that we want to set mediaSource.duration to
    _this._levelDuration = null;
    // the target duration of the current media playlist
    _this._levelTargetDuration = 10;
    // current stream state: true - for live broadcast, false - for VoD content
    _this._live = null;
    // cache the self generated object url to detect hijack of video tag
    _this._objectUrl = null;
    // The number of BUFFER_CODEC events received before any sourceBuffers are created
    _this.bufferCodecEventsExpected = 0;

    // Source Buffer listeners
    _this.onsbue = _this.onSBUpdateEnd.bind(_this);
    _this.onsbe = _this.onSBUpdateError.bind(_this);
    _this.pendingTracks = {};
    _this.tracks = {};
    return _this;
  }

  _createClass(BufferController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onLevelPtsUpdated',
    value: function onLevelPtsUpdated(data) {
      var type = data.type;
      var audioTrack = this.tracks.audio;

      // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)
      // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`
      // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue
      // `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend`
      // event if SB is in updating state.
      // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486

      if (type === 'audio' && audioTrack && audioTrack.container === 'audio/mpeg') {
        // Chrome audio mp3 track
        var audioBuffer = this.sourceBuffer.audio;
        var delta = Math.abs(audioBuffer.timestampOffset - data.start);

        // adjust timestamp offset if time delta is greater than 100ms
        if (delta > 0.1) {
          var updating = audioBuffer.updating;

          try {
            audioBuffer.abort();
          } catch (err) {
            _logger.logger.warn('can not abort audio buffer: ' + err);
          }

          if (!updating) {
            _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + data.start);
            audioBuffer.timestampOffset = data.start;
          } else {
            this.audioTimestampOffset = data.start;
          }
        }
      }
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller
      // sourcebuffers will be created all at once when the expected nb of tracks will be reached
      // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller
      // it will contain the expected nb of source buffers, no need to compute it
      this.bufferCodecEventsExpected = data.altAudio ? 2 : 1;
      _logger.logger.log(this.bufferCodecEventsExpected + ' bufferCodec event(s) expected');
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      var media = this.media = data.media;
      if (media) {
        // setup the media source
        var ms = this.mediaSource = new MediaSource();
        // Media Source listeners
        this.onmso = this.onMediaSourceOpen.bind(this);
        this.onmse = this.onMediaSourceEnded.bind(this);
        this.onmsc = this.onMediaSourceClose.bind(this);
        ms.addEventListener('sourceopen', this.onmso);
        ms.addEventListener('sourceended', this.onmse);
        ms.addEventListener('sourceclose', this.onmsc);
        // link video and media Source
        media.src = window.URL.createObjectURL(ms);
        // cache the locally generated object url
        this._objectUrl = media.src;
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      _logger.logger.log('media source detaching');
      var ms = this.mediaSource;
      if (ms) {
        if (ms.readyState === 'open') {
          try {
            // endOfStream could trigger exception if any sourcebuffer is in updating state
            // we don't really care about checking sourcebuffer state here,
            // as we are anyway detaching the MediaSource
            // let's just avoid this exception to propagate
            ms.endOfStream();
          } catch (err) {
            _logger.logger.warn('onMediaDetaching:' + err.message + ' while calling endOfStream');
          }
        }
        ms.removeEventListener('sourceopen', this.onmso);
        ms.removeEventListener('sourceended', this.onmse);
        ms.removeEventListener('sourceclose', this.onmsc);

        // Detach properly the MediaSource from the HTMLMediaElement as
        // suggested in https://github.com/w3c/media-source/issues/53.
        if (this.media) {
          window.URL.revokeObjectURL(this._objectUrl);

          // clean up video tag src only if it's our own url. some external libraries might
          // hijack the video tag and change its 'src' without destroying the Hls instance first
          if (this.media.src === this._objectUrl) {
            this.media.removeAttribute('src');
            this.media.load();
          } else {
            _logger.logger.warn('media.src was changed by a third party - skip cleanup');
          }
        }

        this.mediaSource = null;
        this.media = null;
        this._objectUrl = null;
        this.pendingTracks = {};
        this.tracks = {};
        this.sourceBuffer = {};
        this.flushRange = [];
        this.segments = [];
        this.appended = 0;
      }
      this.onmso = this.onmse = this.onmsc = null;
      this.hls.trigger(_events2.default.MEDIA_DETACHED);
    }
  }, {
    key: 'onMediaSourceOpen',
    value: function onMediaSourceOpen() {
      _logger.logger.log('media source opened');
      this.hls.trigger(_events2.default.MEDIA_ATTACHED, { media: this.media });
      var mediaSource = this.mediaSource;
      if (mediaSource) {
        // once received, don't listen anymore to sourceopen event
        mediaSource.removeEventListener('sourceopen', this.onmso);
      }
      this.checkPendingTracks();
    }
  }, {
    key: 'checkPendingTracks',
    value: function checkPendingTracks() {
      var bufferCodecEventsExpected = this.bufferCodecEventsExpected,
          pendingTracks = this.pendingTracks;
      // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.
      // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after
      // data has been appended to existing ones.
      // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.

      var pendingTracksCount = Object.keys(pendingTracks).length;
      if (pendingTracksCount && !bufferCodecEventsExpected || pendingTracksCount === 2) {
        // ok, let's create them now !
        this.createSourceBuffers(pendingTracks);
        this.pendingTracks = {};
        // append any pending segments now !
        this.doAppending();
      }
    }
  }, {
    key: 'onMediaSourceClose',
    value: function onMediaSourceClose() {
      _logger.logger.log('media source closed');
    }
  }, {
    key: 'onMediaSourceEnded',
    value: function onMediaSourceEnded() {
      _logger.logger.log('media source ended');
    }
  }, {
    key: 'onSBUpdateEnd',
    value: function onSBUpdateEnd() {
      // update timestampOffset
      if (this.audioTimestampOffset) {
        var audioBuffer = this.sourceBuffer.audio;
        _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + this.audioTimestampOffset);
        audioBuffer.timestampOffset = this.audioTimestampOffset;
        delete this.audioTimestampOffset;
      }

      if (this._needsFlush) {
        this.doFlush();
      }

      if (this._needsEos) {
        this.checkEos();
      }

      this.appending = false;
      var parent = this.parent;
      // count nb of pending segments waiting for appending on this sourcebuffer
      var pending = this.segments.reduce(function (counter, segment) {
        return segment.parent === parent ? counter + 1 : counter;
      }, 0);

      // this.sourceBuffer is better to use than media.buffered as it is closer to the PTS data from the fragments
      var timeRanges = {};
      var sourceBuffer = this.sourceBuffer;
      for (var streamType in sourceBuffer) {
        timeRanges[streamType] = sourceBuffer[streamType].buffered;
      }

      // 寻找可播放的起始点。如果没有自动播放，需要手动Seek
      if (this._paused === false && timeRanges["video"] && timeRanges["video"].length > 0 && timeRanges["audio"] && timeRanges["audio"].length > 0) {

        if (timeRanges["video"].end(0) - timeRanges["video"].start(0) > 1 && timeRanges["audio"].end(0) - timeRanges["audio"].start(0) > 1) {
          // Seek to the point that can play;
          var startTime = Math.max(timeRanges["video"].start(0), timeRanges["audio"].start(0));
          this.media.currentTime = startTime;
          this.media.play();
          delete this["_paused"];
        } else {
          // Try to seek more
          var endTime = Math.max(timeRanges["video"].end(0), timeRanges["audio"].end(0));
          this.media.currentTime = endTime;
          this.media.play();
        }
      }

      this.hls.trigger(_events2.default.BUFFER_APPENDED, { parent: parent, pending: pending, timeRanges: timeRanges });
      // don't append in flushing mode
      if (!this._needsFlush) {
        this.doAppending();
      }

      this.updateMediaElementDuration();

      // appending goes first
      if (pending === 0) {
        this.flushLiveBackBuffer();
      }
    }
  }, {
    key: 'onSBUpdateError',
    value: function onSBUpdateError(event) {
      _logger.logger.error('sourceBuffer error:', event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
      // we don't need to do more than that, as accordin to the spec, updateend will be fired just after
    }
  }, {
    key: 'onBufferReset',
    value: function onBufferReset() {
      var sourceBuffer = this.sourceBuffer;
      for (var type in sourceBuffer) {
        var sb = sourceBuffer[type];
        try {
          this.mediaSource.removeSourceBuffer(sb);
          sb.removeEventListener('updateend', this.onsbue);
          sb.removeEventListener('error', this.onsbe);
        } catch (err) {}
      }
      this.sourceBuffer = {};
      this.flushRange = [];
      this.segments = [];
      this.appended = 0;
    }
  }, {
    key: 'onBufferCodecs',
    value: function onBufferCodecs(tracks) {
      var _this2 = this;

      // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
      // if sourcebuffers already created, do nothing ...
      /** 需要放过tracks, 有新的track需要重新加buffer 使得画面到达时，可以播放画面
      if (Object.keys(this.sourceBuffer).length) {
        return;
      }*/

      Object.keys(tracks).forEach(function (trackName) {
        _this2.pendingTracks[trackName] = tracks[trackName];
      });
      var mediaSource = this.mediaSource;

      this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);
      if (mediaSource && mediaSource.readyState === 'open') {
        this.checkPendingTracks();
      }
    }
  }, {
    key: 'createSourceBuffers',
    value: function createSourceBuffers(tracks) {
      var sourceBuffer = this.sourceBuffer,
          mediaSource = this.mediaSource;
      for (var trackName in tracks) {
        if (!sourceBuffer[trackName]) {
          var track = tracks[trackName];
          // use levelCodec as first priority
          var codec = track.levelCodec || track.codec;
          var mimeType = track.container + ';codecs=' + codec;
          _logger.logger.log('creating sourceBuffer(' + mimeType + ')');
          try {
            var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
            sb.addEventListener('updateend', this.onsbue);
            sb.addEventListener('error', this.onsbe);
            this.tracks[trackName] = { codec: codec, container: track.container };
            track.buffer = sb;
          } catch (err) {
            if (err.code == 22) {
              _logger.logger.log("Found new track, try to rebuild");
              this._paused = false;
              // setup the media source
              var ms = this.mediaSource = new MediaSource();
              // Media Source listeners
              this.onmso = this.onMediaSourceOpen.bind(this);
              this.onmse = this.onMediaSourceEnded.bind(this);
              this.onmsc = this.onMediaSourceClose.bind(this);

              for (var i = 0; i < Object.keys(this.tracks).length; i++) {
                var _track = this.tracks[Object.keys(this.tracks)[i]];
                this.pendingTracks[Object.keys(this.tracks)[i]] = _track;
              }
              this.tracks = {};
              this.sourceBuffer = {};
              ms.addEventListener('sourceopen', this.onmso);
              ms.addEventListener('sourceended', this.onmse);
              ms.addEventListener('sourceclose', this.onmsc);
              // link video and media Source
              this.media.src = window.URL.createObjectURL(ms);
              // cache the locally generated object url
              this._objectUrl = media.src;
            } else {
              _logger.logger.error('error while trying to add sourceBuffer:' + err.message);
              this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });
            }
          }
        }
      }

      this.hls.trigger(_events2.default.BUFFER_CREATED, { tracks: tracks });
    }
  }, {
    key: 'onBufferAppending',
    value: function onBufferAppending(data) {
      if (!this._needsFlush) {
        if (!this.segments) {
          this.segments = [data];
        } else {
          this.segments.push(data);
        }

        this.doAppending();
      }
    }
  }, {
    key: 'onBufferAppendFail',
    value: function onBufferAppendFail(data) {
      _logger.logger.error('sourceBuffer error:', data.event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
    }

    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()

  }, {
    key: 'onBufferEos',
    value: function onBufferEos(data) {
      var sb = this.sourceBuffer;
      var dataType = data.type;
      for (var type in sb) {
        if (!dataType || type === dataType) {
          if (!sb[type].ended) {
            sb[type].ended = true;
            _logger.logger.log(type + ' sourceBuffer now EOS');
          }
        }
      }
      this.checkEos();
    }

    // if all source buffers are marked as ended, signal endOfStream() to MediaSource.

  }, {
    key: 'checkEos',
    value: function checkEos() {
      var sb = this.sourceBuffer,
          mediaSource = this.mediaSource;
      if (!mediaSource || mediaSource.readyState !== 'open') {
        this._needsEos = false;
        return;
      }
      for (var type in sb) {
        var sbobj = sb[type];
        if (!sbobj.ended) {
          return;
        }

        if (sbobj.updating) {
          this._needsEos = true;
          return;
        }
      }
      _logger.logger.log('all media data are available, signal endOfStream() to MediaSource and stop loading fragment');
      // Notify the media element that it now has all of the media data
      try {
        mediaSource.endOfStream();
      } catch (e) {
        _logger.logger.warn('exception while calling mediaSource.endOfStream()');
      }
      this._needsEos = false;
    }
  }, {
    key: 'onBufferFlushing',
    value: function onBufferFlushing(data) {
      this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });
      // attempt flush immediately
      this.flushBufferCounter = 0;
      this.doFlush();
    }
  }, {
    key: 'flushLiveBackBuffer',
    value: function flushLiveBackBuffer() {
      // clear back buffer for live only
      if (!this._live) {
        return;
      }

      var liveBackBufferLength = this.hls.config.liveBackBufferLength;
      if (!isFinite(liveBackBufferLength) || liveBackBufferLength < 0) {
        return;
      }

      var currentTime = this.media.currentTime;
      var sourceBuffer = this.sourceBuffer;
      var bufferTypes = Object.keys(sourceBuffer);
      var targetBackBufferPosition = currentTime - Math.max(liveBackBufferLength, this._levelTargetDuration);

      for (var index = bufferTypes.length - 1; index >= 0; index--) {
        var bufferType = bufferTypes[index],
            buffered = sourceBuffer[bufferType].buffered;

        // when target buffer start exceeds actual buffer start
        if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {
          // remove buffer up until current time minus minimum back buffer length (removing buffer too close to current
          // time will lead to playback freezing)
          // credits for level target duration - https://github.com/videojs/http-streaming/blob/3132933b6aa99ddefab29c10447624efd6fd6e52/src/segment-loader.js#L91
          this.removeBufferRange(bufferType, sourceBuffer[bufferType], 0, targetBackBufferPosition);
        }
      }
    }
  }, {
    key: 'onLevelUpdated',
    value: function onLevelUpdated(_ref) {
      var details = _ref.details;

      if (details.fragments.length > 0) {
        this._levelDuration = details.totalduration + details.fragments[0].start;
        this._levelTargetDuration = details.averagetargetduration || details.targetduration || 10;
        this._live = details.live;
        this.updateMediaElementDuration();
      }
    }

    /**
     * Update Media Source duration to current level duration or override to Infinity if configuration parameter
     * 'liveDurationInfinity` is set to `true`
     * More details: https://github.com/video-dev/hls.js/issues/355
     */

  }, {
    key: 'updateMediaElementDuration',
    value: function updateMediaElementDuration() {
      var config = this.hls.config;

      var duration = void 0;

      if (this._levelDuration === null || !this.media || !this.mediaSource || !this.sourceBuffer || this.media.readyState === 0 || this.mediaSource.readyState !== 'open') {
        return;
      }

      for (var type in this.sourceBuffer) {
        if (this.sourceBuffer[type].updating === true) {
          // can't set duration whilst a buffer is updating
          return;
        }
      }

      duration = this.media.duration;
      // initialise to the value that the media source is reporting
      if (this._msDuration === null) {
        this._msDuration = this.mediaSource.duration;
      }

      if (this._live === true && config.liveDurationInfinity === true) {
        // Override duration to Infinity
        _logger.logger.log('Media Source duration is set to Infinity');
        this._msDuration = this.mediaSource.duration = Infinity;
      } else if (this._levelDuration > this._msDuration && this._levelDuration > duration || !Number.isFinite(duration)) {
        // levelDuration was the last value we set.
        // not using mediaSource.duration as the browser may tweak this value
        // only update Media Source duration if its value increase, this is to avoid
        // flushing already buffered portion when switching between quality level
        _logger.logger.log('Updating Media Source duration to ' + this._levelDuration.toFixed(3));
        this._msDuration = this.mediaSource.duration = this._levelDuration;
      }
    }
  }, {
    key: 'doFlush',
    value: function doFlush() {
      // loop through all buffer ranges to flush
      while (this.flushRange.length) {
        var range = this.flushRange[0];
        // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer
        if (this.flushBuffer(range.start, range.end, range.type)) {
          // range flushed, remove from flush array
          this.flushRange.shift();
          this.flushBufferCounter = 0;
        } else {
          this._needsFlush = true;
          // avoid looping, wait for SB update end to retrigger a flush
          return;
        }
      }
      if (this.flushRange.length === 0) {
        // everything flushed
        this._needsFlush = false;

        // let's recompute this.appended, which is used to avoid flush looping
        var appended = 0;
        var sourceBuffer = this.sourceBuffer;
        try {
          for (var type in sourceBuffer) {
            appended += sourceBuffer[type].buffered.length;
          }
        } catch (error) {
          // error could be thrown while accessing buffered, in case sourcebuffer has already been removed from MediaSource
          // this is harmess at this stage, catch this to avoid reporting an internal exception
          _logger.logger.error('error while accessing sourceBuffer.buffered');
        }
        this.appended = appended;
        this.hls.trigger(_events2.default.BUFFER_FLUSHED);
      }
    }
  }, {
    key: 'doAppending',
    value: function doAppending() {
      var hls = this.hls,
          segments = this.segments,
          sourceBuffer = this.sourceBuffer;

      if (Object.keys(sourceBuffer).length) {
        if (this.media.error) {
          this.segments = [];
          _logger.logger.error('trying to append although a media error occured, flush segment and abort');
          return;
        }
        if (this.appending) {
          // logger.log(`sb appending in progress`);
          return;
        }
        if (segments && segments.length) {
          var segment = segments.shift();
          try {
            var type = segment.type,
                sb = sourceBuffer[type];
            if (sb) {
              if (!sb.updating) {
                // reset sourceBuffer ended flag before appending segment
                sb.ended = false;
                // logger.log(`appending ${segment.content} ${type} SB, size:${segment.data.length}, ${segment.parent}`);
                this.parent = segment.parent;
                console.log('append buffer ', segment);
                sb.appendBuffer(segment.data);
                this.appendError = 0;
                this.appended++;
                this.appending = true;
              } else {
                segments.unshift(segment);
              }
            } else {
              // in case we don't have any source buffer matching with this segment type,
              // it means that Mediasource fails to create sourcebuffer
              // discard this segment, and trigger update end
              this.onSBUpdateEnd();
            }
          } catch (err) {
            // in case any error occured while appending, put back segment in segments table
            _logger.logger.error('error while trying to append buffer:' + err.message);
            segments.unshift(segment);
            var event = { type: _errors.ErrorTypes.MEDIA_ERROR, parent: segment.parent };
            if (err.code !== 22) {
              if (this.appendError) {
                this.appendError++;
              } else {
                this.appendError = 1;
              }

              event.details = _errors.ErrorDetails.BUFFER_APPEND_ERROR;
              /* with UHD content, we could get loop of quota exceeded error until
                browser is able to evict some data from sourcebuffer. retrying help recovering this
              */
              if (this.appendError > hls.config.appendErrorMaxRetry) {
                _logger.logger.log('fail ' + hls.config.appendErrorMaxRetry + ' times to append segment in sourceBuffer');
                this.segments = [];
                event.fatal = true;
                hls.trigger(_events2.default.ERROR, event);
              } else {
                event.fatal = false;
                hls.trigger(_events2.default.ERROR, event);
              }
            } else {
              // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
              // let's stop appending any segments, and report BUFFER_FULL_ERROR error
              this.segments = [];
              event.details = _errors.ErrorDetails.BUFFER_FULL_ERROR;
              event.fatal = false;
              hls.trigger(_events2.default.ERROR, event);
            }
          }
        }
      }
    }

    /*
      flush specified buffered range,
      return true once range has been flushed.
      as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
    */

  }, {
    key: 'flushBuffer',
    value: function flushBuffer(startOffset, endOffset, typeIn) {
      var sb = void 0;
      var sourceBuffer = this.sourceBuffer;
      if (Object.keys(sourceBuffer).length) {
        _logger.logger.log('flushBuffer,pos/start/end: ' + this.media.currentTime.toFixed(3) + '/' + startOffset + '/' + endOffset);
        // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments
        if (this.flushBufferCounter < this.appended) {
          for (var type in sourceBuffer) {
            // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one
            // if no, let's flush all sourcebuffers
            if (typeIn && type !== typeIn) {
              continue;
            }

            sb = sourceBuffer[type];
            // we are going to flush buffer, mark source buffer as 'not ended'
            sb.ended = false;
            if (!sb.updating) {
              if (this.removeBufferRange(type, sb, startOffset, endOffset)) {
                this.flushBufferCounter++;
                return false;
              }
            } else {
              _logger.logger.warn('cannot flush, sb updating in progress');
              return false;
            }
          }
        } else {
          _logger.logger.warn('abort flushing too many retries');
        }
        _logger.logger.log('buffer flushed');
      }
      // everything flushed !
      return true;
    }

    /**
     * Removes first buffered range from provided source buffer that lies within given start and end offsets.
     *
     * @param type Type of the source buffer, logging purposes only.
     * @param sb Target SourceBuffer instance.
     * @param startOffset
     * @param endOffset
     *
     * @returns {boolean} True when source buffer remove requested.
     */

  }, {
    key: 'removeBufferRange',
    value: function removeBufferRange(type, sb, startOffset, endOffset) {
      try {
        for (var i = 0; i < sb.buffered.length; i++) {
          var bufStart = sb.buffered.start(i);
          var bufEnd = sb.buffered.end(i);
          var removeStart = Math.max(bufStart, startOffset);
          var removeEnd = Math.min(bufEnd, endOffset);

          /* sometimes sourcebuffer.remove() does not flush
            the exact expected time range.
            to avoid rounding issues/infinite loop,
            only flush buffer range of length greater than 500ms.
          */
          if (Math.min(removeEnd, bufEnd) - removeStart > 0.5) {
            _logger.logger.log('sb remove ' + type + ' [' + removeStart + ',' + removeEnd + '], of [' + bufStart + ',' + bufEnd + '], pos:' + this.media.currentTime);
            sb.remove(removeStart, removeEnd);
            return true;
          }
        }
      } catch (error) {
        _logger.logger.warn('removeBufferRange failed', error);
      }

      return false;
    }
  }]);

  return BufferController;
}(_eventHandler2.default);

exports.default = BufferController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/cap-level-controller.js":
/*!*******************************************************!*\
  !*** ./src/hls.js/controller/cap-level-controller.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * cap stream level to media size dimension controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var CapLevelController = function (_EventHandler) {
  _inherits(CapLevelController, _EventHandler);

  function CapLevelController(hls) {
    _classCallCheck(this, CapLevelController);

    var _this = _possibleConstructorReturn(this, (CapLevelController.__proto__ || Object.getPrototypeOf(CapLevelController)).call(this, hls, _events2.default.FPS_DROP_LEVEL_CAPPING, _events2.default.MEDIA_ATTACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_CODECS, _events2.default.MEDIA_DETACHING));

    _this.autoLevelCapping = Number.POSITIVE_INFINITY;
    _this.firstLevel = null;
    _this.levels = [];
    _this.media = null;
    _this.restrictedLevels = [];
    _this.timer = null;
    return _this;
  }

  _createClass(CapLevelController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.hls.config.capLevelToPlayerSize) {
        this.media = null;
        this._stopCapping();
      }
    }
  }, {
    key: 'onFpsDropLevelCapping',
    value: function onFpsDropLevelCapping(data) {
      // Don't add a restricted level more than once
      if (CapLevelController.isLevelAllowed(data.droppedLevel, this.restrictedLevels)) {
        this.restrictedLevels.push(data.droppedLevel);
      }
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media instanceof window.HTMLVideoElement ? data.media : null;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var hls = this.hls;
      this.restrictedLevels = [];
      this.levels = data.levels;
      this.firstLevel = data.firstLevel;
      if (hls.config.capLevelToPlayerSize && data.video) {
        // Start capping immediately if the manifest has signaled video codecs
        this._startCapping();
      }
    }

    // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted
    // to the first level

  }, {
    key: 'onBufferCodecs',
    value: function onBufferCodecs(data) {
      var hls = this.hls;
      if (hls.config.capLevelToPlayerSize && data.video) {
        // If the manifest did not signal a video codec capping has been deferred until we're certain video is present
        this._startCapping();
      }
    }
  }, {
    key: 'onLevelsUpdated',
    value: function onLevelsUpdated(data) {
      this.levels = data.levels;
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      this._stopCapping();
    }
  }, {
    key: 'detectPlayerSize',
    value: function detectPlayerSize() {
      if (this.media) {
        var levelsLength = this.levels ? this.levels.length : 0;
        if (levelsLength) {
          var hls = this.hls;
          hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);
          if (hls.autoLevelCapping > this.autoLevelCapping) {
            // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
            // usually happen when the user go to the fullscreen mode.
            hls.streamController.nextLevelSwitch();
          }
          this.autoLevelCapping = hls.autoLevelCapping;
        }
      }
    }

    /*
    * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
    */

  }, {
    key: 'getMaxLevel',
    value: function getMaxLevel(capLevelIndex) {
      var _this2 = this;

      if (!this.levels) {
        return -1;
      }

      var validLevels = this.levels.filter(function (level, index) {
        return CapLevelController.isLevelAllowed(index, _this2.restrictedLevels) && index <= capLevelIndex;
      });

      return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
    }
  }, {
    key: '_startCapping',
    value: function _startCapping() {
      if (this.timer) {
        // Don't reset capping if started twice; this can happen if the manifest signals a video codec
        return;
      }
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      this.hls.firstLevel = this.getMaxLevel(this.firstLevel);
      clearInterval(this.timer);
      this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);
      this.detectPlayerSize();
    }
  }, {
    key: '_stopCapping',
    value: function _stopCapping() {
      this.restrictedLevels = [];
      this.firstLevel = null;
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      if (this.timer) {
        this.timer = clearInterval(this.timer);
        this.timer = null;
      }
    }
  }, {
    key: 'mediaWidth',
    get: function get() {
      var width = void 0;
      var media = this.media;
      if (media) {
        width = media.width || media.clientWidth || media.offsetWidth;
        width *= CapLevelController.contentScaleFactor;
      }
      return width;
    }
  }, {
    key: 'mediaHeight',
    get: function get() {
      var height = void 0;
      var media = this.media;
      if (media) {
        height = media.height || media.clientHeight || media.offsetHeight;
        height *= CapLevelController.contentScaleFactor;
      }
      return height;
    }
  }], [{
    key: 'isLevelAllowed',
    value: function isLevelAllowed(level) {
      var restrictedLevels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      return restrictedLevels.indexOf(level) === -1;
    }
  }, {
    key: 'getMaxLevelByMediaSize',
    value: function getMaxLevelByMediaSize(levels, width, height) {
      if (!levels || levels && !levels.length) {
        return -1;
      }

      // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next
      // to determine whether we've chosen the greatest bandwidth for the media's dimensions
      var atGreatestBandiwdth = function atGreatestBandiwdth(curLevel, nextLevel) {
        if (!nextLevel) {
          return true;
        }

        return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
      };

      // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to
      // the max level
      var maxLevelIndex = levels.length - 1;

      for (var i = 0; i < levels.length; i += 1) {
        var level = levels[i];
        if ((level.width >= width || level.height >= height) && atGreatestBandiwdth(level, levels[i + 1])) {
          maxLevelIndex = i;
          break;
        }
      }

      return maxLevelIndex;
    }
  }, {
    key: 'contentScaleFactor',
    get: function get() {
      var pixelRatio = 1;
      try {
        pixelRatio = window.devicePixelRatio;
      } catch (e) {}
      return pixelRatio;
    }
  }]);

  return CapLevelController;
}(_eventHandler2.default);

exports.default = CapLevelController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/eme-controller.js":
/*!*************************************************!*\
  !*** ./src/hls.js/controller/eme-controller.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author Stephan Hesse <disparat@gmail.com> | <tchakabam@gmail.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * DRM support for Hls.js
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _window = window,
    XMLHttpRequest = _window.XMLHttpRequest;


var MAX_LICENSE_REQUEST_FAILURES = 3;

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess
 */
var KeySystems = {
  WIDEVINE: 'com.widevine.alpha',
  PLAYREADY: 'com.microsoft.playready'
};

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration
 * @param {Array<string>} audioCodecs List of required audio codecs to support
 * @param {Array<string>} videoCodecs List of required video codecs to support
 * @param {object} drmSystemOptions Optional parameters/requirements for the key-system
 * @returns {Array<MediaSystemConfiguration>} An array of supported configurations
 */

var createWidevineMediaKeySystemConfigurations = function createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs, drmSystemOptions) {
  /* jshint ignore:line */
  var baseConfig = {
    // initDataTypes: ['keyids', 'mp4'],
    // label: "",
    // persistentState: "not-allowed", // or "required" ?
    // distinctiveIdentifier: "not-allowed", // or "required" ?
    // sessionTypes: ['temporary'],
    videoCapabilities: [
      // { contentType: 'video/mp4; codecs="avc1.42E01E"' }
    ]
  };

  videoCodecs.forEach(function (codec) {
    baseConfig.videoCapabilities.push({
      contentType: 'video/mp4; codecs="' + codec + '"'
    });
  });

  return [baseConfig];
};

/**
 * The idea here is to handle key-system (and their respective platforms) specific configuration differences
 * in order to work with the local requestMediaKeySystemAccess method.
 *
 * We can also rule-out platform-related key-system support at this point by throwing an error or returning null.
 *
 * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum
 * @param {Array<string>} audioCodecs List of required audio codecs to support
 * @param {Array<string>} videoCodecs List of required video codecs to support
 * @returns {Array<MediaSystemConfiguration> | null} A non-empty Array of MediaKeySystemConfiguration objects or `null`
 */
var getSupportedMediaKeySystemConfigurations = function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs) {
  switch (keySystem) {
    case KeySystems.WIDEVINE:
      return createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs);
    default:
      throw Error('Unknown key-system: ' + keySystem);
  }
};

/**
 * Controller to deal with encrypted media extensions (EME)
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API
 *
 * @class
 * @constructor
 */

var EMEController = function (_EventHandler) {
  _inherits(EMEController, _EventHandler);

  /**
     * @constructs
     * @param {Hls} hls Our Hls.js instance
     */
  function EMEController(hls) {
    _classCallCheck(this, EMEController);

    var _this = _possibleConstructorReturn(this, (EMEController.__proto__ || Object.getPrototypeOf(EMEController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MANIFEST_PARSED));

    _this._widevineLicenseUrl = hls.config.widevineLicenseUrl;
    _this._licenseXhrSetup = hls.config.licenseXhrSetup;
    _this._emeEnabled = hls.config.emeEnabled;

    _this._requestMediaKeySystemAccess = hls.config.requestMediaKeySystemAccessFunc;

    _this._mediaKeysList = [];
    _this._media = null;

    _this._hasSetMediaKeys = false;
    _this._isMediaEncrypted = false;

    _this._requestLicenseFailureCount = 0;
    return _this;
  }

  /**
     *
     * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum
     * @returns {string} License server URL for key-system (if any configured, otherwise causes error)
     */


  _createClass(EMEController, [{
    key: 'getLicenseServerUrl',
    value: function getLicenseServerUrl(keySystem) {
      var url = void 0;
      switch (keySystem) {
        case KeySystems.WIDEVINE:
          url = this._widevineLicenseUrl;
          break;
        default:
          url = null;
          break;
      }

      if (!url) {
        _logger.logger.error('No license server URL configured for key-system "' + keySystem + '"');
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
          fatal: true
        });
      }

      return url;
    }

    /**
       * Requests access object and adds it to our list upon success
       * @private
       * @param {string} keySystem System ID (see `KeySystems`)
       * @param {Array<string>} audioCodecs List of required audio codecs to support
       * @param {Array<string>} videoCodecs List of required video codecs to support
       */

  }, {
    key: '_attemptKeySystemAccess',
    value: function _attemptKeySystemAccess(keySystem, audioCodecs, videoCodecs) {
      var _this2 = this;

      // TODO: add other DRM "options"

      var mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs);

      if (!mediaKeySystemConfigs) {
        _logger.logger.warn('Can not create config for key-system (maybe because platform is not supported):', keySystem);
        return;
      }

      _logger.logger.log('Requesting encrypted media key-system access');

      // expecting interface like window.navigator.requestMediaKeySystemAccess
      this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs).then(function (mediaKeySystemAccess) {
        _this2._onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess);
      }).catch(function (err) {
        _logger.logger.error('Failed to obtain key-system "' + keySystem + '" access:', err);
      });
    }
  }, {
    key: '_onMediaKeySystemAccessObtained',


    /**
       * Handles obtaining access to a key-system
       *
       * @param {string} keySystem
       * @param {MediaKeySystemAccess} mediaKeySystemAccess https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemAccess
       */
    value: function _onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess) {
      var _this3 = this;

      _logger.logger.log('Access for key-system "' + keySystem + '" obtained');

      var mediaKeysListItem = {
        mediaKeys: null,
        mediaKeysSession: null,
        mediaKeysSessionInitialized: false,
        mediaKeySystemAccess: mediaKeySystemAccess,
        mediaKeySystemDomain: keySystem
      };

      this._mediaKeysList.push(mediaKeysListItem);

      mediaKeySystemAccess.createMediaKeys().then(function (mediaKeys) {
        mediaKeysListItem.mediaKeys = mediaKeys;

        _logger.logger.log('Media-keys created for key-system "' + keySystem + '"');

        _this3._onMediaKeysCreated();
      }).catch(function (err) {
        _logger.logger.error('Failed to create media-keys:', err);
      });
    }

    /**
       * Handles key-creation (represents access to CDM). We are going to create key-sessions upon this
       * for all existing keys where no session exists yet.
       */

  }, {
    key: '_onMediaKeysCreated',
    value: function _onMediaKeysCreated() {
      var _this4 = this;

      // check for all key-list items if a session exists, otherwise, create one
      this._mediaKeysList.forEach(function (mediaKeysListItem) {
        if (!mediaKeysListItem.mediaKeysSession) {
          mediaKeysListItem.mediaKeysSession = mediaKeysListItem.mediaKeys.createSession();
          _this4._onNewMediaKeySession(mediaKeysListItem.mediaKeysSession);
        }
      });
    }

    /**
       *
       * @param {*} keySession
       */

  }, {
    key: '_onNewMediaKeySession',
    value: function _onNewMediaKeySession(keySession) {
      var _this5 = this;

      _logger.logger.log('New key-system session ' + keySession.sessionId);

      keySession.addEventListener('message', function (event) {
        _this5._onKeySessionMessage(keySession, event.message);
      }, false);
    }
  }, {
    key: '_onKeySessionMessage',
    value: function _onKeySessionMessage(keySession, message) {
      _logger.logger.log('Got EME message event, creating license request');

      this._requestLicense(message, function (data) {
        _logger.logger.log('Received license data, updating key-session');
        keySession.update(data);
      });
    }
  }, {
    key: '_onMediaEncrypted',
    value: function _onMediaEncrypted(initDataType, initData) {
      _logger.logger.log('Media is encrypted using "' + initDataType + '" init data type');

      this._isMediaEncrypted = true;
      this._mediaEncryptionInitDataType = initDataType;
      this._mediaEncryptionInitData = initData;

      this._attemptSetMediaKeys();
      this._generateRequestWithPreferredKeySession();
    }
  }, {
    key: '_attemptSetMediaKeys',
    value: function _attemptSetMediaKeys() {
      if (!this._hasSetMediaKeys) {
        // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?
        var keysListItem = this._mediaKeysList[0];
        if (!keysListItem || !keysListItem.mediaKeys) {
          _logger.logger.error('Fatal: Media is encrypted but no CDM access or no keys have been obtained yet');
          this.hls.trigger(_events2.default.ERROR, {
            type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
            details: _errors.ErrorDetails.KEY_SYSTEM_NO_KEYS,
            fatal: true
          });
          return;
        }

        _logger.logger.log('Setting keys for encrypted media');

        this._media.setMediaKeys(keysListItem.mediaKeys);
        this._hasSetMediaKeys = true;
      }
    }
  }, {
    key: '_generateRequestWithPreferredKeySession',
    value: function _generateRequestWithPreferredKeySession() {
      var _this6 = this;

      // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?
      var keysListItem = this._mediaKeysList[0];
      if (!keysListItem) {
        _logger.logger.error('Fatal: Media is encrypted but not any key-system access has been obtained yet');
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
          fatal: true
        });
        return;
      }

      if (keysListItem.mediaKeysSessionInitialized) {
        _logger.logger.warn('Key-Session already initialized but requested again');
        return;
      }

      var keySession = keysListItem.mediaKeysSession;
      if (!keySession) {
        _logger.logger.error('Fatal: Media is encrypted but no key-session existing');
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_NO_SESSION,
          fatal: true
        });
      }

      var initDataType = this._mediaEncryptionInitDataType;
      var initData = this._mediaEncryptionInitData;

      _logger.logger.log('Generating key-session request for "' + initDataType + '" init data type');

      keysListItem.mediaKeysSessionInitialized = true;

      keySession.generateRequest(initDataType, initData).then(function () {
        _logger.logger.debug('Key-session generation succeeded');
      }).catch(function (err) {
        _logger.logger.error('Error generating key-session request:', err);
        _this6.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_NO_SESSION,
          fatal: false
        });
      });
    }

    /**
       * @param {string} url License server URL
       * @param {ArrayBuffer} keyMessage Message data issued by key-system
       * @param {function} callback Called when XHR has succeeded
       * @returns {XMLHttpRequest} Unsent (but opened state) XHR object
       */

  }, {
    key: '_createLicenseXhr',
    value: function _createLicenseXhr(url, keyMessage, callback) {
      var xhr = new XMLHttpRequest();
      var licenseXhrSetup = this._licenseXhrSetup;

      try {
        if (licenseXhrSetup) {
          try {
            licenseXhrSetup(xhr, url);
          } catch (e) {
            // let's try to open before running setup
            xhr.open('POST', url, true);
            licenseXhrSetup(xhr, url);
          }
        }
        // if licenseXhrSetup did not yet call open, let's do it now
        if (!xhr.readyState) {
          xhr.open('POST', url, true);
        }
      } catch (e) {
        // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
        _logger.logger.error('Error setting up key-system license XHR', e);
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
          fatal: true
        });
        return;
      }

      xhr.responseType = 'arraybuffer';
      xhr.onreadystatechange = this._onLicenseRequestReadyStageChange.bind(this, xhr, url, keyMessage, callback);
      return xhr;
    }

    /**
       * @param {XMLHttpRequest} xhr
       * @param {string} url License server URL
       * @param {ArrayBuffer} keyMessage Message data issued by key-system
       * @param {function} callback Called when XHR has succeeded
       *
       */

  }, {
    key: '_onLicenseRequestReadyStageChange',
    value: function _onLicenseRequestReadyStageChange(xhr, url, keyMessage, callback) {
      switch (xhr.readyState) {
        case 4:
          if (xhr.status === 200) {
            this._requestLicenseFailureCount = 0;
            _logger.logger.log('License request succeeded');
            callback(xhr.response);
          } else {
            _logger.logger.error('License Request XHR failed (' + url + '). Status: ' + xhr.status + ' (' + xhr.statusText + ')');

            this._requestLicenseFailureCount++;
            if (this._requestLicenseFailureCount <= MAX_LICENSE_REQUEST_FAILURES) {
              var attemptsLeft = MAX_LICENSE_REQUEST_FAILURES - this._requestLicenseFailureCount + 1;
              _logger.logger.warn('Retrying license request, ' + attemptsLeft + ' attempts left');
              this._requestLicense(keyMessage, callback);
              return;
            }

            this.hls.trigger(_events2.default.ERROR, {
              type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
              details: _errors.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
              fatal: true
            });
          }
          break;
      }
    }

    /**
       * @param {object} keysListItem
       * @param {ArrayBuffer} keyMessage
       * @returns {ArrayBuffer} Challenge data posted to license server
       */

  }, {
    key: '_generateLicenseRequestChallenge',
    value: function _generateLicenseRequestChallenge(keysListItem, keyMessage) {
      var challenge = void 0;

      if (keysListItem.mediaKeySystemDomain === KeySystems.PLAYREADY) {
        _logger.logger.error('PlayReady is not supported (yet)');

        // from https://github.com/MicrosoftEdge/Demos/blob/master/eme/scripts/demo.js
        /*
          if (this.licenseType !== this.LICENSE_TYPE_WIDEVINE) {
              // For PlayReady CDMs, we need to dig the Challenge out of the XML.
              var keyMessageXml = new DOMParser().parseFromString(String.fromCharCode.apply(null, new Uint16Array(keyMessage)), 'application/xml');
              if (keyMessageXml.getElementsByTagName('Challenge')[0]) {
                  challenge = atob(keyMessageXml.getElementsByTagName('Challenge')[0].childNodes[0].nodeValue);
              } else {
                  throw 'Cannot find <Challenge> in key message';
              }
              var headerNames = keyMessageXml.getElementsByTagName('name');
              var headerValues = keyMessageXml.getElementsByTagName('value');
              if (headerNames.length !== headerValues.length) {
                  throw 'Mismatched header <name>/<value> pair in key message';
              }
              for (var i = 0; i < headerNames.length; i++) {
                  xhr.setRequestHeader(headerNames[i].childNodes[0].nodeValue, headerValues[i].childNodes[0].nodeValue);
              }
          }
          */
      } else if (keysListItem.mediaKeySystemDomain === KeySystems.WIDEVINE) {
        // For Widevine CDMs, the challenge is the keyMessage.
        challenge = keyMessage;
      } else {
        _logger.logger.error('Unsupported key-system:', keysListItem.mediaKeySystemDomain);
      }

      return challenge;
    }
  }, {
    key: '_requestLicense',
    value: function _requestLicense(keyMessage, callback) {
      _logger.logger.log('Requesting content license for key-system');

      var keysListItem = this._mediaKeysList[0];
      if (!keysListItem) {
        _logger.logger.error('Fatal error: Media is encrypted but no key-system access has been obtained yet');
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
          fatal: true
        });
        return;
      }

      var url = this.getLicenseServerUrl(keysListItem.mediaKeySystemDomain);
      var xhr = this._createLicenseXhr(url, keyMessage, callback);

      _logger.logger.log('Sending license request to URL: ' + url);

      xhr.send(this._generateLicenseRequestChallenge(keysListItem, keyMessage));
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var _this7 = this;

      if (!this._emeEnabled) {
        return;
      }

      var media = data.media;

      // keep reference of media
      this._media = media;

      // FIXME: also handle detaching media !

      media.addEventListener('encrypted', function (e) {
        _this7._onMediaEncrypted(e.initDataType, e.initData);
      });
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      if (!this._emeEnabled) {
        return;
      }

      var audioCodecs = data.levels.map(function (level) {
        return level.audioCodec;
      });
      var videoCodecs = data.levels.map(function (level) {
        return level.videoCodec;
      });

      this._attemptKeySystemAccess(KeySystems.WIDEVINE, audioCodecs, videoCodecs);
    }
  }, {
    key: 'requestMediaKeySystemAccess',
    get: function get() {
      if (!this._requestMediaKeySystemAccess) {
        throw new Error('No requestMediaKeySystemAccess function configured');
      }

      return this._requestMediaKeySystemAccess;
    }
  }]);

  return EMEController;
}(_eventHandler2.default);

exports.default = EMEController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/fps-controller.js":
/*!*************************************************!*\
  !*** ./src/hls.js/controller/fps-controller.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FPS Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var _window = window,
    performance = _window.performance;

var FPSController = function (_EventHandler) {
  _inherits(FPSController, _EventHandler);

  function FPSController(hls) {
    _classCallCheck(this, FPSController);

    return _possibleConstructorReturn(this, (FPSController.__proto__ || Object.getPrototypeOf(FPSController)).call(this, hls, _events2.default.MEDIA_ATTACHING));
  }

  _createClass(FPSController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.timer) {
        clearInterval(this.timer);
      }

      this.isVideoPlaybackQualityAvailable = false;
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      var config = this.hls.config;
      if (config.capLevelOnFPSDrop) {
        var video = this.video = data.media instanceof window.HTMLVideoElement ? data.media : null;
        if (typeof video.getVideoPlaybackQuality === 'function') {
          this.isVideoPlaybackQualityAvailable = true;
        }

        clearInterval(this.timer);
        this.timer = setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
      }
    }
  }, {
    key: 'checkFPS',
    value: function checkFPS(video, decodedFrames, droppedFrames) {
      var currentTime = performance.now();
      if (decodedFrames) {
        if (this.lastTime) {
          var currentPeriod = currentTime - this.lastTime,
              currentDropped = droppedFrames - this.lastDroppedFrames,
              currentDecoded = decodedFrames - this.lastDecodedFrames,
              droppedFPS = 1000 * currentDropped / currentPeriod,
              hls = this.hls;
          hls.trigger(_events2.default.FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });
          if (droppedFPS > 0) {
            // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
            if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
              var currentLevel = hls.currentLevel;
              _logger.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);
              if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
                currentLevel = currentLevel - 1;
                hls.trigger(_events2.default.FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: hls.currentLevel });
                hls.autoLevelCapping = currentLevel;
                hls.streamController.nextLevelSwitch();
              }
            }
          }
        }
        this.lastTime = currentTime;
        this.lastDroppedFrames = droppedFrames;
        this.lastDecodedFrames = decodedFrames;
      }
    }
  }, {
    key: 'checkFPSInterval',
    value: function checkFPSInterval() {
      var video = this.video;
      if (video) {
        if (this.isVideoPlaybackQualityAvailable) {
          var videoPlaybackQuality = video.getVideoPlaybackQuality();
          this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
        } else {
          this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
        }
      }
    }
  }]);

  return FPSController;
}(_eventHandler2.default);

exports.default = FPSController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/fragment-finders.js":
/*!***************************************************!*\
  !*** ./src/hls.js/controller/fragment-finders.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findFragmentByPDT = findFragmentByPDT;
exports.findFragmentByPTS = findFragmentByPTS;
exports.fragmentWithinToleranceTest = fragmentWithinToleranceTest;
exports.pdtWithinToleranceTest = pdtWithinToleranceTest;

var _binarySearch = __webpack_require__(/*! ../utils/binary-search */ "./src/hls.js/utils/binary-search.js");

var _binarySearch2 = _interopRequireDefault(_binarySearch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns first fragment whose endPdt value exceeds the given PDT.
 * @param {Array<Fragment>} fragments - The array of candidate fragments
 * @param {number|null} [PDTValue = null] - The PDT value which must be exceeded
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start/end can be within in order to be considered contiguous
 * @returns {*|null} fragment - The best matching fragment
 */
function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
  if (!Array.isArray(fragments) || !fragments.length || !Number.isFinite(PDTValue)) {
    return null;
  }

  // if less than start
  if (PDTValue < fragments[0].programDateTime) {
    return null;
  }

  if (PDTValue >= fragments[fragments.length - 1].endProgramDateTime) {
    return null;
  }

  maxFragLookUpTolerance = maxFragLookUpTolerance || 0;
  for (var seg = 0; seg < fragments.length; ++seg) {
    var frag = fragments[seg];
    if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
      return frag;
    }
  }

  return null;
}

/**
 * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.
 * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus
 * breaking any traps which would cause the same fragment to be continuously selected within a small range.
 * @param {*} fragPrevious - The last frag successfully appended
 * @param {Array<Fragment>} fragments - The array of candidate fragments
 * @param {number} [bufferEnd = 0] - The end of the contiguous buffered range the playhead is currently within
 * @param {number} maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous
 * @returns {*} foundFrag - The best matching fragment
 */
function findFragmentByPTS(fragPrevious, fragments) {
  var bufferEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var maxFragLookUpTolerance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : null;
  // Prefer the next fragment if it's within tolerance
  if (fragNext && !fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext)) {
    return fragNext;
  }
  return _binarySearch2.default.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));
}

/**
 * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.
 * @param {*} candidate - The fragment to test
 * @param {number} [bufferEnd = 0] - The end of the current buffered range the playhead is currently within
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous
 * @returns {number} - 0 if it matches, 1 if too low, -1 if too high
 */
function fragmentWithinToleranceTest() {
  var bufferEnd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var maxFragLookUpTolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var candidate = arguments[2];

  // offset should be within fragment boundary - config.maxFragLookUpTolerance
  // this is to cope with situations like
  // bufferEnd = 9.991
  // frag[Ø] : [0,10]
  // frag[1] : [10,20]
  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
  //              frag start               frag start+duration
  //                  |-----------------------------|
  //              <--->                         <--->
  //  ...--------><-----------------------------><---------....
  // previous frag         matching fragment         next frag
  //  return -1             return 0                 return 1
  // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
    return 1;
  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
    // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
    return -1;
  }

  return 0;
}

/**
 * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.
 * This function tests the candidate's program date time values, as represented in Unix time
 * @param {*} candidate - The fragment to test
 * @param {number} [pdtBufferEnd = 0] - The Unix time representing the end of the current buffered range
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous
 * @returns {boolean} True if contiguous, false otherwise
 */
function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;
  return candidate.endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
}

/***/ }),

/***/ "./src/hls.js/controller/fragment-tracker.js":
/*!***************************************************!*\
  !*** ./src/hls.js/controller/fragment-tracker.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FragmentTracker = exports.FragmentState = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FragmentState = exports.FragmentState = {
  NOT_LOADED: 'NOT_LOADED',
  APPENDING: 'APPENDING',
  PARTIAL: 'PARTIAL',
  OK: 'OK'
};

var FragmentTracker = exports.FragmentTracker = function (_EventHandler) {
  _inherits(FragmentTracker, _EventHandler);

  function FragmentTracker(hls) {
    _classCallCheck(this, FragmentTracker);

    var _this = _possibleConstructorReturn(this, (FragmentTracker.__proto__ || Object.getPrototypeOf(FragmentTracker)).call(this, hls, _events2.default.BUFFER_APPENDED, _events2.default.FRAG_BUFFERED, _events2.default.FRAG_LOADED));

    _this.bufferPadding = 0.2;

    _this.fragments = Object.create(null);
    _this.timeRanges = Object.create(null);

    _this.config = hls.config;
    return _this;
  }

  _createClass(FragmentTracker, [{
    key: 'destroy',
    value: function destroy() {
      this.fragments = Object.create(null);
      this.timeRanges = Object.create(null);
      this.config = null;
      _eventHandler2.default.prototype.destroy.call(this);
      _get(FragmentTracker.prototype.__proto__ || Object.getPrototypeOf(FragmentTracker.prototype), 'destroy', this).call(this);
    }

    /**
     * Return a Fragment that match the position and levelType.
     * If not found any Fragment, return null
     * @param {number} position
     * @param {LevelType} levelType
     * @returns {Fragment|null}
     */

  }, {
    key: 'getBufferedFrag',
    value: function getBufferedFrag(position, levelType) {
      var fragments = this.fragments;
      var bufferedFrags = Object.keys(fragments).filter(function (key) {
        var fragmentEntity = fragments[key];
        if (fragmentEntity.body.type !== levelType) {
          return false;
        }

        if (!fragmentEntity.buffered) {
          return false;
        }

        var frag = fragmentEntity.body;
        return frag.startPTS <= position && position <= frag.endPTS;
      });
      if (bufferedFrags.length === 0) {
        return null;
      } else {
        // https://github.com/video-dev/hls.js/pull/1545#discussion_r166229566
        var bufferedFragKey = bufferedFrags.pop();
        return fragments[bufferedFragKey].body;
      }
    }

    /**
     * Partial fragments effected by coded frame eviction will be removed
     * The browser will unload parts of the buffer to free up memory for new buffer data
     * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
     * @param {String} elementaryStream The elementaryStream of media this is (eg. video/audio)
     * @param {TimeRanges} timeRange TimeRange object from a sourceBuffer
     */

  }, {
    key: 'detectEvictedFragments',
    value: function detectEvictedFragments(elementaryStream, timeRange) {
      var _this2 = this;

      var fragmentTimes = void 0,
          time = void 0;
      // Check if any flagged fragments have been unloaded
      Object.keys(this.fragments).forEach(function (key) {
        var fragmentEntity = _this2.fragments[key];
        if (fragmentEntity.buffered === true) {
          var esData = fragmentEntity.range[elementaryStream];
          if (esData) {
            fragmentTimes = esData.time;
            for (var i = 0; i < fragmentTimes.length; i++) {
              time = fragmentTimes[i];

              if (_this2.isTimeBuffered(time.startPTS, time.endPTS, timeRange) === false) {
                // Unregister partial fragment as it needs to load again to be reused
                _this2.removeFragment(fragmentEntity.body);
                break;
              }
            }
          }
        }
      });
    }

    /**
     * Checks if the fragment passed in is loaded in the buffer properly
     * Partially loaded fragments will be registered as a partial fragment
     * @param {Object} fragment Check the fragment against all sourceBuffers loaded
     */

  }, {
    key: 'detectPartialFragments',
    value: function detectPartialFragments(fragment) {
      var _this3 = this;

      var fragKey = this.getFragmentKey(fragment);
      var fragmentEntity = this.fragments[fragKey];
      if (fragmentEntity) {
        fragmentEntity.buffered = true;

        Object.keys(this.timeRanges).forEach(function (elementaryStream) {
          if (fragment.hasElementaryStream(elementaryStream)) {
            var timeRange = _this3.timeRanges[elementaryStream];
            // Check for malformed fragments
            // Gaps need to be calculated for each elementaryStream
            fragmentEntity.range[elementaryStream] = _this3.getBufferedTimes(fragment.startPTS, fragment.endPTS, timeRange);
          }
        });
      }
    }
  }, {
    key: 'getBufferedTimes',
    value: function getBufferedTimes(startPTS, endPTS, timeRange) {
      var fragmentTimes = [];
      var startTime = void 0,
          endTime = void 0;
      var fragmentPartial = false;
      for (var i = 0; i < timeRange.length; i++) {
        startTime = timeRange.start(i) - this.bufferPadding;
        endTime = timeRange.end(i) + this.bufferPadding;
        if (startPTS >= startTime && endPTS <= endTime) {
          // Fragment is entirely contained in buffer
          // No need to check the other timeRange times since it's completely playable
          fragmentTimes.push({
            startPTS: Math.max(startPTS, timeRange.start(i)),
            endPTS: Math.min(endPTS, timeRange.end(i))
          });
          break;
        } else if (startPTS < endTime && endPTS > startTime) {
          // Check for intersection with buffer
          // Get playable sections of the fragment
          fragmentTimes.push({
            startPTS: Math.max(startPTS, timeRange.start(i)),
            endPTS: Math.min(endPTS, timeRange.end(i))
          });
          fragmentPartial = true;
        } else if (endPTS <= startTime) {
          // No need to check the rest of the timeRange as it is in order
          break;
        }
      }

      return {
        time: fragmentTimes,
        partial: fragmentPartial
      };
    }
  }, {
    key: 'getFragmentKey',
    value: function getFragmentKey(fragment) {
      return fragment.type + '_' + fragment.levels + '_' + fragment.urlId + '_' + fragment.sn;
    }

    /**
     * Gets the partial fragment for a certain time
     * @param {Number} time
     * @returns {Object} fragment Returns a partial fragment at a time or null if there is no partial fragment
     */

  }, {
    key: 'getPartialFragment',
    value: function getPartialFragment(time) {
      var _this4 = this;

      var timePadding = void 0,
          startTime = void 0,
          endTime = void 0;
      var bestFragment = null;
      var bestOverlap = 0;
      Object.keys(this.fragments).forEach(function (key) {
        var fragmentEntity = _this4.fragments[key];
        if (_this4.isPartial(fragmentEntity)) {
          startTime = fragmentEntity.body.startPTS - _this4.bufferPadding;
          endTime = fragmentEntity.body.endPTS + _this4.bufferPadding;
          if (time >= startTime && time <= endTime) {
            // Use the fragment that has the most padding from start and end time
            timePadding = Math.min(time - startTime, endTime - time);
            if (bestOverlap <= timePadding) {
              bestFragment = fragmentEntity.body;
              bestOverlap = timePadding;
            }
          }
        }
      });
      return bestFragment;
    }

    /**
     * @param {Object} fragment The fragment to check
     * @returns {String} Returns the fragment state when a fragment never loaded or if it partially loaded
     */

  }, {
    key: 'getState',
    value: function getState(fragment) {
      var fragKey = this.getFragmentKey(fragment);
      var fragmentEntity = this.fragments[fragKey];
      var state = FragmentState.NOT_LOADED;

      if (fragmentEntity !== undefined) {
        if (!fragmentEntity.buffered) {
          state = FragmentState.APPENDING;
        } else if (this.isPartial(fragmentEntity) === true) {
          state = FragmentState.PARTIAL;
        } else {
          state = FragmentState.OK;
        }
      }

      return state;
    }
  }, {
    key: 'isPartial',
    value: function isPartial(fragmentEntity) {
      return fragmentEntity.buffered === true && (fragmentEntity.range.video !== undefined && fragmentEntity.range.video.partial === true || fragmentEntity.range.audio !== undefined && fragmentEntity.range.audio.partial === true);
    }
  }, {
    key: 'isTimeBuffered',
    value: function isTimeBuffered(startPTS, endPTS, timeRange) {
      var startTime = void 0,
          endTime = void 0;
      for (var i = 0; i < timeRange.length; i++) {
        startTime = timeRange.start(i) - this.bufferPadding;
        endTime = timeRange.end(i) + this.bufferPadding;
        if (startPTS >= startTime && endPTS <= endTime) {
          return true;
        }

        if (endPTS <= startTime) {
          // No need to check the rest of the timeRange as it is in order
          return false;
        }
      }

      return false;
    }

    /**
     * Fires when a fragment loading is completed
     */

  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(e) {
      var fragment = e.frag;
      // don't track initsegment (for which sn is not a number)
      // don't track frags used for bitrateTest, they're irrelevant.
      if (!Number.isFinite(fragment.sn) || fragment.bitrateTest) {
        return;
      }

      this.fragments[this.getFragmentKey(fragment)] = {
        body: fragment,
        range: Object.create(null),
        buffered: false
      };
    }

    /**
     * Fires when the buffer is updated
     */

  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(e) {
      var _this5 = this;

      // Store the latest timeRanges loaded in the buffer
      this.timeRanges = e.timeRanges;
      Object.keys(this.timeRanges).forEach(function (elementaryStream) {
        var timeRange = _this5.timeRanges[elementaryStream];
        _this5.detectEvictedFragments(elementaryStream, timeRange);
      });
    }

    /**
     * Fires after a fragment has been loaded into the source buffer
     */

  }, {
    key: 'onFragBuffered',
    value: function onFragBuffered(e) {
      this.detectPartialFragments(e.frag);
    }

    /**
     * Return true if fragment tracker has the fragment.
     * @param {Object} fragment
     * @returns {boolean}
     */

  }, {
    key: 'hasFragment',
    value: function hasFragment(fragment) {
      var fragKey = this.getFragmentKey(fragment);
      return this.fragments[fragKey] !== undefined;
    }

    /**
     * Remove a fragment from fragment tracker until it is loaded again
     * @param {Object} fragment The fragment to remove
     */

  }, {
    key: 'removeFragment',
    value: function removeFragment(fragment) {
      var fragKey = this.getFragmentKey(fragment);
      delete this.fragments[fragKey];
    }

    /**
     * Remove all fragments from fragment tracker.
     */

  }, {
    key: 'removeAllFragments',
    value: function removeAllFragments() {
      this.fragments = Object.create(null);
    }
  }]);

  return FragmentTracker;
}(_eventHandler2.default);

/***/ }),

/***/ "./src/hls.js/controller/gap-controller.js":
/*!*************************************************!*\
  !*** ./src/hls.js/controller/gap-controller.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var stallDebounceInterval = 1000;
var jumpThreshold = 0.5; // tolerance needed as some browsers stalls playback before reaching buffered range end

var GapController = function () {
  function GapController(config, media, fragmentTracker, hls) {
    _classCallCheck(this, GapController);

    this.config = config;
    this.media = media;
    this.fragmentTracker = fragmentTracker;
    this.hls = hls;
    this.stallReported = false;
  }

  /**
   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.
   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).
   * @param lastCurrentTime
   * @param buffered
   */


  _createClass(GapController, [{
    key: 'poll',
    value: function poll(lastCurrentTime, buffered) {
      var config = this.config,
          media = this.media;

      var currentTime = media.currentTime;
      var tnow = window.performance.now();

      if (currentTime !== lastCurrentTime) {
        // The playhead is now moving, but was previously stalled
        if (this.stallReported) {
          _logger.logger.warn('playback not stuck anymore @' + currentTime + ', after ' + Math.round(tnow - this.stalled) + 'ms');
          this.stallReported = false;
        }
        this.stalled = null;
        this.nudgeRetry = 0;
        return;
      }

      if (media.ended || !media.buffered.length || media.readyState > 2) {
        return;
      }

      if (media.seeking && _bufferHelper.BufferHelper.isBuffered(media, currentTime)) {
        return;
      }

      // The playhead isn't moving but it should be
      // Allow some slack time to for small stalls to resolve themselves
      var stalledDuration = tnow - this.stalled;
      var bufferInfo = _bufferHelper.BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);
      if (!this.stalled) {
        this.stalled = tnow;
        return;
      } else if (stalledDuration >= stallDebounceInterval) {
        // Report stalling after trying to fix
        this._reportStall(bufferInfo.len);
      }

      this._tryFixBufferStall(bufferInfo, stalledDuration);
    }

    /**
     * Detects and attempts to fix known buffer stalling issues.
     * @param bufferInfo - The properties of the current buffer.
     * @param stalledDuration - The amount of time Hls.js has been stalling for.
     * @private
     */

  }, {
    key: '_tryFixBufferStall',
    value: function _tryFixBufferStall(bufferInfo, stalledDuration) {
      var config = this.config,
          fragmentTracker = this.fragmentTracker,
          media = this.media;

      var currentTime = media.currentTime;

      var partial = fragmentTracker.getPartialFragment(currentTime);
      if (partial) {
        // Try to skip over the buffer hole caused by a partial fragment
        // This method isn't limited by the size of the gap between buffered ranges
        this._trySkipBufferHole(partial);
      }

      if (bufferInfo.len > jumpThreshold && stalledDuration > config.highBufferWatchdogPeriod * 1000) {
        // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds
        // We only try to jump the hole if it's under the configured size
        // Reset stalled so to rearm watchdog timer
        this.stalled = null;
        this._tryNudgeBuffer();
      }
    }

    /**
     * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.
     * @param bufferLen - The playhead distance from the end of the current buffer segment.
     * @private
     */

  }, {
    key: '_reportStall',
    value: function _reportStall(bufferLen) {
      var hls = this.hls,
          media = this.media,
          stallReported = this.stallReported;

      if (!stallReported) {
        // Report stalled error once
        this.stallReported = true;
        _logger.logger.warn('Playback stalling at @' + media.currentTime + ' due to low buffer');
        hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.BUFFER_STALLED_ERROR,
          fatal: false,
          buffer: bufferLen
        });
      }
    }

    /**
     * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments
     * @param partial - The partial fragment found at the current time (where playback is stalling).
     * @private
     */

  }, {
    key: '_trySkipBufferHole',
    value: function _trySkipBufferHole(partial) {
      var hls = this.hls,
          media = this.media;

      var currentTime = media.currentTime;
      var lastEndTime = 0;
      // Check if currentTime is between unbuffered regions of partial fragments
      for (var i = 0; i < media.buffered.length; i++) {
        var startTime = media.buffered.start(i);
        if (currentTime >= lastEndTime && currentTime < startTime) {
          media.currentTime = Math.max(startTime, media.currentTime + 0.1);
          _logger.logger.warn('skipping hole, adjusting currentTime from ' + currentTime + ' to ' + media.currentTime);
          this.stalled = null;
          hls.trigger(_events2.default.ERROR, {
            type: _errors.ErrorTypes.MEDIA_ERROR,
            details: _errors.ErrorDetails.BUFFER_SEEK_OVER_HOLE,
            fatal: false,
            reason: 'fragment loaded with buffer holes, seeking from ' + currentTime + ' to ' + media.currentTime,
            frag: partial
          });
          return;
        }
        lastEndTime = media.buffered.end(i);
      }
    }

    /**
     * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.
     * @private
     */

  }, {
    key: '_tryNudgeBuffer',
    value: function _tryNudgeBuffer() {
      var config = this.config,
          hls = this.hls,
          media = this.media;

      var currentTime = media.currentTime;
      var nudgeRetry = (this.nudgeRetry || 0) + 1;
      this.nudgeRetry = nudgeRetry;

      if (nudgeRetry < config.nudgeMaxRetry) {
        var targetTime = currentTime + nudgeRetry * config.nudgeOffset;
        _logger.logger.log('adjust currentTime from ' + currentTime + ' to ' + targetTime);
        // playback stalled in buffered area ... let's nudge currentTime to try to overcome this
        media.currentTime = targetTime;
        hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.BUFFER_NUDGE_ON_STALL,
          fatal: false
        });
      } else {
        _logger.logger.error('still stuck in high buffer @' + currentTime + ' after ' + config.nudgeMaxRetry + ', raise fatal error');
        hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.BUFFER_STALLED_ERROR,
          fatal: true
        });
      }
    }
  }]);

  return GapController;
}();

exports.default = GapController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/id3-track-controller.js":
/*!*******************************************************!*\
  !*** ./src/hls.js/controller/id3-track-controller.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _id = __webpack_require__(/*! ../demux/id3 */ "./src/hls.js/demux/id3.js");

var _id2 = _interopRequireDefault(_id);

var _texttrackUtils = __webpack_require__(/*! ../utils/texttrack-utils */ "./src/hls.js/utils/texttrack-utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * id3 metadata track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var ID3TrackController = function (_EventHandler) {
  _inherits(ID3TrackController, _EventHandler);

  function ID3TrackController(hls) {
    _classCallCheck(this, ID3TrackController);

    var _this = _possibleConstructorReturn(this, (ID3TrackController.__proto__ || Object.getPrototypeOf(ID3TrackController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_METADATA));

    _this.id3Track = undefined;
    _this.media = undefined;
    return _this;
  }

  _createClass(ID3TrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }

    // Add ID3 metatadata text track.

  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      this.media = data.media;
      if (!this.media) {}
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      (0, _texttrackUtils.clearCurrentCues)(this.id3Track);
      this.id3Track = undefined;
      this.media = undefined;
    }
  }, {
    key: 'getID3Track',
    value: function getID3Track(textTracks) {
      for (var i = 0; i < textTracks.length; i++) {
        var textTrack = textTracks[i];
        if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {
          // send 'addtrack' when reusing the textTrack for metadata,
          // same as what we do for captions
          (0, _texttrackUtils.sendAddTrackEvent)(textTrack, this.media);

          return textTrack;
        }
      }
      return this.media.addTextTrack('metadata', 'id3');
    }
  }, {
    key: 'onFragParsingMetadata',
    value: function onFragParsingMetadata(data) {
      var fragment = data.frag;
      var samples = data.samples;

      // create track dynamically
      if (!this.id3Track) {
        this.id3Track = this.getID3Track(this.media.textTracks);
        this.id3Track.mode = 'hidden';
      }

      // Attempt to recreate Safari functionality by creating
      // WebKitDataCue objects when available and store the decoded
      // ID3 data in the value property of the cue
      var Cue = window.WebKitDataCue || window.VTTCue || window.TextTrackCue;

      for (var i = 0; i < samples.length; i++) {
        var frames = _id2.default.getID3Frames(samples[i].data);
        if (frames) {
          var startTime = samples[i].pts;
          var endTime = i < samples.length - 1 ? samples[i + 1].pts : fragment.endPTS;

          // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
          if (startTime === endTime) {
            endTime += 0.0001;
          }

          for (var j = 0; j < frames.length; j++) {
            var frame = frames[j];
            // Safari doesn't put the timestamp frame in the TextTrack
            if (!_id2.default.isTimeStampFrame(frame)) {
              var cue = new Cue(startTime, endTime, '');
              cue.value = frame;
              this.id3Track.addCue(cue);
            }
          }
        }
      }
    }
  }]);

  return ID3TrackController;
}(_eventHandler2.default);

exports.default = ID3TrackController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/level-controller.js":
/*!***************************************************!*\
  !*** ./src/hls.js/controller/level-controller.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _codecs = __webpack_require__(/*! ../utils/codecs */ "./src/hls.js/utils/codecs.js");

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Level Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var _window = window,
    performance = _window.performance;

var chromeOrFirefox = void 0;

var LevelController = function (_EventHandler) {
  _inherits(LevelController, _EventHandler);

  function LevelController(hls) {
    _classCallCheck(this, LevelController);

    var _this = _possibleConstructorReturn(this, (LevelController.__proto__ || Object.getPrototypeOf(LevelController)).call(this, hls, _events2.default.MANIFEST_LOADED, _events2.default.LEVEL_LOADED, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.FRAG_LOADED, _events2.default.ERROR));

    _this.canload = false;
    _this.currentLevelIndex = null;
    _this.manualLevelIndex = -1;
    _this.timer = null;

    chromeOrFirefox = /chrome|firefox/.test(navigator.userAgent.toLowerCase());
    return _this;
  }

  _createClass(LevelController, [{
    key: 'onHandlerDestroying',
    value: function onHandlerDestroying() {
      this.clearTimer();
      this.manualLevelIndex = -1;
    }
  }, {
    key: 'clearTimer',
    value: function clearTimer() {
      if (this.timer !== null) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      var levels = this._levels;

      this.canload = true;
      this.levelRetryCount = 0;

      // clean up live level details to force reload them, and reset load errors
      if (levels) {
        levels.forEach(function (level) {
          level.loadError = 0;
          var levelDetails = level.details;
          if (levelDetails && levelDetails.live) {
            level.details = undefined;
          }
        });
      }
      // speed up live playlist refresh if timer exists
      if (this.timer !== null) {
        this.loadLevel();
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.canload = false;
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var levels = [];
      var audioTracks = [];
      var bitrateStart = void 0;
      var levelSet = {};
      var levelFromSet = null;
      var videoCodecFound = false;
      var audioCodecFound = false;

      // regroup redundant levels together
      data.levels.forEach(function (level) {
        var attributes = level.attrs;
        level.loadError = 0;
        level.fragmentError = false;

        videoCodecFound = videoCodecFound || !!level.videoCodec;
        audioCodecFound = audioCodecFound || !!level.audioCodec;

        // erase audio codec info if browser does not support mp4a.40.34.
        // demuxer will autodetect codec and fallback to mpeg/audio
        if (chromeOrFirefox && level.audioCodec && level.audioCodec.indexOf('mp4a.40.34') !== -1) {
          level.audioCodec = undefined;
        }

        levelFromSet = levelSet[level.bitrate]; // FIXME: we would also have to match the resolution here

        if (!levelFromSet) {
          level.url = [level.url];
          level.urlId = 0;
          levelSet[level.bitrate] = level;
          levels.push(level);
        } else {
          levelFromSet.url.push(level.url);
        }

        if (attributes) {
          if (attributes.AUDIO) {
            audioCodecFound = true;
            (0, _levelHelper.addGroupId)(levelFromSet || level, 'audio', attributes.AUDIO);
          }
          if (attributes.SUBTITLES) {
            (0, _levelHelper.addGroupId)(levelFromSet || level, 'text', attributes.SUBTITLES);
          }
        }
      });

      // remove audio-only level if we also have levels with audio+video codecs signalled
      if (videoCodecFound && audioCodecFound) {
        levels = levels.filter(function (_ref) {
          var videoCodec = _ref.videoCodec;
          return !!videoCodec;
        });
      }

      // only keep levels with supported audio/video codecs
      levels = levels.filter(function (_ref2) {
        var audioCodec = _ref2.audioCodec,
            videoCodec = _ref2.videoCodec;

        return (!audioCodec || (0, _codecs.isCodecSupportedInMp4)(audioCodec, 'audio')) && (!videoCodec || (0, _codecs.isCodecSupportedInMp4)(videoCodec, 'video'));
      });

      if (data.audioTracks) {
        audioTracks = data.audioTracks.filter(function (track) {
          return !track.audioCodec || (0, _codecs.isCodecSupportedInMp4)(track.audioCodec, 'audio');
        });
        // Reassign id's after filtering since they're used as array indices
        audioTracks.forEach(function (track, index) {
          track.id = index;
        });
      }

      if (levels.length > 0) {
        // start bitrate is the first bitrate of the manifest
        bitrateStart = levels[0].bitrate;
        // sort level on bitrate
        levels.sort(function (a, b) {
          return a.bitrate - b.bitrate;
        });
        this._levels = levels;
        // find index of first level in sorted levels
        for (var i = 0; i < levels.length; i++) {
          if (levels[i].bitrate === bitrateStart) {
            this._firstLevel = i;
            _logger.logger.log('manifest loaded,' + levels.length + ' level(s) found, first bitrate:' + bitrateStart);
            break;
          }
        }

        // Audio is only alternate if manifest include a URI along with the audio group tag
        this.hls.trigger(_events2.default.MANIFEST_PARSED, {
          levels: levels,
          audioTracks: audioTracks,
          firstLevel: this._firstLevel,
          stats: data.stats,
          audio: audioCodecFound,
          video: videoCodecFound,
          altAudio: audioTracks.some(function (t) {
            return !!t.url;
          })
        });
      } else {
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
          fatal: true,
          url: this.hls.url,
          reason: 'no level with compatible codecs found in manifest'
        });
      }
    }
  }, {
    key: 'setLevelInternal',
    value: function setLevelInternal(newLevel) {
      var levels = this._levels;
      var hls = this.hls;
      // check if level idx is valid
      if (newLevel >= 0 && newLevel < levels.length) {
        // stopping live reloading timer if any
        this.clearTimer();
        if (this.currentLevelIndex !== newLevel) {
          _logger.logger.log('switching to level ' + newLevel);
          this.currentLevelIndex = newLevel;
          var levelProperties = levels[newLevel];
          levelProperties.level = newLevel;
          hls.trigger(_events2.default.LEVEL_SWITCHING, levelProperties);
        }
        var level = levels[newLevel];
        var levelDetails = level.details;

        // check if we need to load playlist for this level
        if (!levelDetails || levelDetails.live) {
          // level not retrieved yet, or live playlist we need to (re)load it
          var urlId = level.urlId;
          hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: newLevel, id: urlId });
        }
      } else {
        // invalid level id given, trigger error
        hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.OTHER_ERROR,
          details: _errors.ErrorDetails.LEVEL_SWITCH_ERROR,
          level: newLevel,
          fatal: false,
          reason: 'invalid level idx'
        });
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      if (data.fatal) {
        if (data.type === _errors.ErrorTypes.NETWORK_ERROR) {
          this.clearTimer();
        }

        return;
      }

      var levelError = false,
          fragmentError = false;
      var levelIndex = void 0;

      // try to recover not fatal errors
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          levelIndex = data.frag.levels;
          fragmentError = true;
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          levelIndex = data.context.levels;
          levelError = true;
          break;
        case _errors.ErrorDetails.REMUX_ALLOC_ERROR:
          levelIndex = data.levels;
          levelError = true;
          break;
      }

      if (levelIndex !== undefined) {
        this.recoverLevel(data, levelIndex, levelError, fragmentError);
      }
    }

    /**
     * Switch to a redundant stream if any available.
     * If redundant stream is not available, emergency switch down if ABR mode is enabled.
     *
     * @param {Object} errorEvent
     * @param {Number} levelIndex current level index
     * @param {Boolean} levelError
     * @param {Boolean} fragmentError
     */
    // FIXME Find a better abstraction where fragment/level retry management is well decoupled

  }, {
    key: 'recoverLevel',
    value: function recoverLevel(errorEvent, levelIndex, levelError, fragmentError) {
      var _this2 = this;

      var config = this.hls.config;
      var errorDetails = errorEvent.details;

      var level = this._levels[levelIndex];
      var redundantLevels = void 0,
          delay = void 0,
          nextLevel = void 0;

      level.loadError++;
      level.fragmentError = fragmentError;

      if (levelError) {
        if (this.levelRetryCount + 1 <= config.levelLoadingMaxRetry) {
          // exponential backoff capped to max retry timeout
          delay = Math.min(Math.pow(2, this.levelRetryCount) * config.levelLoadingRetryDelay, config.levelLoadingMaxRetryTimeout);
          // Schedule level reload
          this.timer = setTimeout(function () {
            return _this2.loadLevel();
          }, delay);
          // boolean used to inform stream controller not to switch back to IDLE on non fatal error
          errorEvent.levelRetry = true;
          this.levelRetryCount++;
          _logger.logger.warn('level controller, ' + errorDetails + ', retry in ' + delay + ' ms, current retry count is ' + this.levelRetryCount);
        } else {
          _logger.logger.error('level controller, cannot recover from ' + errorDetails + ' error');
          this.currentLevelIndex = null;
          // stopping live reloading timer if any
          this.clearTimer();
          // switch error to fatal
          errorEvent.fatal = true;
          return;
        }
      }

      // Try any redundant streams if available for both errors: level and fragment
      // If level.loadError reaches redundantLevels it means that we tried them all, no hope  => let's switch down
      if (levelError || fragmentError) {
        redundantLevels = level.url.length;

        if (redundantLevels > 1 && level.loadError < redundantLevels) {
          level.urlId = (level.urlId + 1) % redundantLevels;
          level.details = undefined;

          _logger.logger.warn('level controller, ' + errorDetails + ' for level ' + levelIndex + ': switching to redundant URL-id ' + level.urlId);

          // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);
          // console.log('New video quality level audio group id:', level.attrs.AUDIO);
        } else {
          // Search for available level
          if (this.manualLevelIndex === -1) {
            // When lowest level has been reached, let's start hunt from the top
            nextLevel = levelIndex === 0 ? this._levels.length - 1 : levelIndex - 1;
            _logger.logger.warn('level controller, ' + errorDetails + ': switch to ' + nextLevel);
            this.hls.nextAutoLevel = this.currentLevelIndex = nextLevel;
          } else if (fragmentError) {
            // Allow fragment retry as long as configuration allows.
            // reset this._level so that another call to set level() will trigger again a frag load
            _logger.logger.warn('level controller, ' + errorDetails + ': reload a fragment');
            this.currentLevelIndex = null;
          }
        }
      }
    }

    // reset errors on the successful load of a fragment

  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(_ref3) {
      var frag = _ref3.frag;

      if (frag !== undefined && frag.type === 'main') {
        var level = this._levels[frag.levels];
        if (level !== undefined) {
          level.fragmentError = false;
          level.loadError = 0;
          this.levelRetryCount = 0;
        }
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var _this3 = this;

      var level = data.level,
          details = data.details;
      // only process level loaded events matching with expected level

      if (level !== this.currentLevelIndex) {
        return;
      }

      var curLevel = this._levels[level];
      // reset level load error counter on successful level loaded only if there is no issues with fragments
      if (!curLevel.fragmentError) {
        curLevel.loadError = 0;
        this.levelRetryCount = 0;
      }
      // if current playlist is a live playlist, arm a timer to reload it
      if (details.live) {
        var reloadInterval = (0, _levelHelper.computeReloadInterval)(curLevel.details, details, data.stats.trequest);
        _logger.logger.log('live playlist, reload in ' + Math.round(reloadInterval) + ' ms');
        this.timer = setTimeout(function () {
          return _this3.loadLevel();
        }, reloadInterval);
      } else {
        this.clearTimer();
      }
    }
  }, {
    key: 'onAudioTrackSwitched',
    value: function onAudioTrackSwitched(data) {
      var audioGroupId = this.hls.audioTracks[data.id].groupId;

      var currentLevel = this.hls.levels[this.currentLevelIndex];
      if (!currentLevel) {
        return;
      }

      if (currentLevel.audioGroupIds) {
        var urlId = -1;

        for (var i = 0; i < currentLevel.audioGroupIds.length; i++) {
          if (currentLevel.audioGroupIds[i] === audioGroupId) {
            urlId = i;
            break;
          }
        }

        if (urlId !== currentLevel.urlId) {
          currentLevel.urlId = urlId;
          this.startLoad();
        }
      }
    }
  }, {
    key: 'loadLevel',
    value: function loadLevel() {
      _logger.logger.debug('call to loadLevel');

      if (this.currentLevelIndex !== null && this.canload) {
        var levelObject = this._levels[this.currentLevelIndex];

        if ((typeof levelObject === 'undefined' ? 'undefined' : _typeof(levelObject)) === 'object' && levelObject.url.length > 0) {
          var level = this.currentLevelIndex;
          var id = levelObject.urlId;
          var url = levelObject.url[id];

          _logger.logger.log('Attempt loading level index ' + level + ' with URL-id ' + id);

          // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);
          // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);

          this.hls.trigger(_events2.default.LEVEL_LOADING, { url: url, level: level, id: id });
        }
      }
    }
  }, {
    key: 'levels',
    get: function get() {
      return this._levels;
    }
  }, {
    key: 'level',
    get: function get() {
      return this.currentLevelIndex;
    },
    set: function set(newLevel) {
      var levels = this._levels;
      if (levels) {
        newLevel = Math.min(newLevel, levels.length - 1);
        if (this.currentLevelIndex !== newLevel || !levels[newLevel].details) {
          this.setLevelInternal(newLevel);
        }
      }
    }
  }, {
    key: 'manualLevel',
    get: function get() {
      return this.manualLevelIndex;
    },
    set: function set(newLevel) {
      this.manualLevelIndex = newLevel;
      if (this._startLevel === undefined) {
        this._startLevel = newLevel;
      }

      if (newLevel !== -1) {
        this.level = newLevel;
      }
    }
  }, {
    key: 'firstLevel',
    get: function get() {
      return this._firstLevel;
    },
    set: function set(newLevel) {
      this._firstLevel = newLevel;
    }
  }, {
    key: 'startLevel',
    get: function get() {
      // hls.startLevel takes precedence over config.startLevel
      // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)
      if (this._startLevel === undefined) {
        var configStartLevel = this.hls.config.startLevel;
        if (configStartLevel !== undefined) {
          return configStartLevel;
        } else {
          return this._firstLevel;
        }
      } else {
        return this._startLevel;
      }
    },
    set: function set(newLevel) {
      this._startLevel = newLevel;
    }
  }, {
    key: 'nextLoadLevel',
    get: function get() {
      if (this.manualLevelIndex !== -1) {
        return this.manualLevelIndex;
      } else {
        return this.hls.nextAutoLevel;
      }
    },
    set: function set(nextLevel) {
      this.level = nextLevel;
      if (this.manualLevelIndex === -1) {
        this.hls.nextAutoLevel = nextLevel;
      }
    }
  }]);

  return LevelController;
}(_eventHandler2.default);

exports.default = LevelController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/level-helper.js":
/*!***********************************************!*\
  !*** ./src/hls.js/controller/level-helper.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addGroupId = addGroupId;
exports.updatePTS = updatePTS;
exports.updateFragPTSDTS = updateFragPTSDTS;
exports.mergeDetails = mergeDetails;
exports.mergeSubtitlePlaylists = mergeSubtitlePlaylists;
exports.mapFragmentIntersection = mapFragmentIntersection;
exports.adjustSliding = adjustSliding;
exports.computeReloadInterval = computeReloadInterval;

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function addGroupId(level, type, id) {
  switch (type) {
    case 'audio':
      if (!level.audioGroupIds) {
        level.audioGroupIds = [];
      }
      level.audioGroupIds.push(id);
      break;
    case 'text':
      if (!level.textGroupIds) {
        level.textGroupIds = [];
      }
      level.textGroupIds.push(id);
      break;
  }
} /**
   * @module LevelHelper
   *
   * Providing methods dealing with playlist sliding and drift
   *
   * TODO: Create an actual `Level` class/model that deals with all this logic in an object-oriented-manner.
   *
   * */

function updatePTS(fragments, fromIdx, toIdx) {
  var fragFrom = fragments[fromIdx],
      fragTo = fragments[toIdx],
      fragToPTS = fragTo.startPTS;
  // if we know startPTS[toIdx]
  if (Number.isFinite(fragToPTS)) {
    // update fragment duration.
    // it helps to fix drifts between playlist reported duration and fragment real duration
    if (toIdx > fromIdx) {
      fragFrom.duration = fragToPTS - fragFrom.start;
      if (fragFrom.duration < 0) {
        _logger.logger.warn('negative duration computed for frag ' + fragFrom.sn + ',level ' + fragFrom.levels + ', there should be some duration drift between playlist and fragment!');
      }
    } else {
      fragTo.duration = fragFrom.start - fragToPTS;
      if (fragTo.duration < 0) {
        _logger.logger.warn('negative duration computed for frag ' + fragTo.sn + ',level ' + fragTo.levels + ', there should be some duration drift between playlist and fragment!');
      }
    }
  } else {
    // we dont know startPTS[toIdx]
    if (toIdx > fromIdx) {
      fragTo.start = fragFrom.start + fragFrom.duration;
    } else {
      fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
    }
  }
}

function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
  // update frag PTS/DTS
  var maxStartPTS = startPTS;
  if (Number.isFinite(frag.startPTS)) {
    // delta PTS between audio and video
    var deltaPTS = Math.abs(frag.startPTS - startPTS);
    if (!Number.isFinite(frag.deltaPTS)) {
      frag.deltaPTS = deltaPTS;
    } else {
      frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
    }

    maxStartPTS = Math.max(startPTS, frag.startPTS);
    startPTS = Math.min(startPTS, frag.startPTS);
    endPTS = Math.max(endPTS, frag.endPTS);
    startDTS = Math.min(startDTS, frag.startDTS);
    endDTS = Math.max(endDTS, frag.endDTS);
  }

  var drift = startPTS - frag.start;
  frag.start = frag.startPTS = startPTS;
  frag.maxStartPTS = maxStartPTS;
  frag.endPTS = endPTS;
  frag.startDTS = startDTS;
  frag.endDTS = endDTS;
  frag.duration = endPTS - startPTS;

  var sn = frag.sn;
  // exit if sn out of range
  if (!details || sn < details.startSN || sn > details.endSN) {
    return 0;
  }

  var fragIdx = void 0,
      fragments = void 0,
      i = void 0;
  fragIdx = sn - details.startSN;
  fragments = details.fragments;
  // update frag reference in fragments array
  // rationale is that fragments array might not contain this frag object.
  // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()
  // if we don't update frag, we won't be able to propagate PTS info on the playlist
  // resulting in invalid sliding computation
  fragments[fragIdx] = frag;
  // adjust fragment PTS/duration from seqnum-1 to frag 0
  for (i = fragIdx; i > 0; i--) {
    updatePTS(fragments, i, i - 1);
  }

  // adjust fragment PTS/duration from seqnum to last frag
  for (i = fragIdx; i < fragments.length - 1; i++) {
    updatePTS(fragments, i, i + 1);
  }

  details.PTSKnown = true;
  return drift;
}

function mergeDetails(oldDetails, newDetails) {
  // potentially retrieve cached initsegment
  if (newDetails.initSegment && oldDetails.initSegment) {
    newDetails.initSegment = oldDetails.initSegment;
  }

  // check if old/new playlists have fragments in common
  // loop through overlapping SN and update startPTS , cc, and duration if any found
  var ccOffset = 0;
  var PTSFrag = void 0;
  mapFragmentIntersection(oldDetails, newDetails, function (oldFrag, newFrag) {
    ccOffset = oldFrag.cc - newFrag.cc;
    if (Number.isFinite(oldFrag.startPTS)) {
      newFrag.start = newFrag.startPTS = oldFrag.startPTS;
      newFrag.endPTS = oldFrag.endPTS;
      newFrag.duration = oldFrag.duration;
      newFrag.backtracked = oldFrag.backtracked;
      newFrag.dropped = oldFrag.dropped;
      PTSFrag = newFrag;
    }
    // PTS is known when there are overlapping segments
    newDetails.PTSKnown = true;
  });

  if (!newDetails.PTSKnown) {
    return;
  }

  if (ccOffset) {
    _logger.logger.log('discontinuity sliding from playlist, take drift into account');
    var newFragments = newDetails.fragments;
    for (var i = 0; i < newFragments.length; i++) {
      newFragments[i].cc += ccOffset;
    }
  }

  // if at least one fragment contains PTS info, recompute PTS information for all fragments
  if (PTSFrag) {
    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
  } else {
    // ensure that delta is within oldFragments range
    // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
    // in that case we also need to adjust start offset of all fragments
    adjustSliding(oldDetails, newDetails);
  }
  // if we are here, it means we have fragments overlapping between
  // old and new level. reliable PTS info is thus relying on old level
  newDetails.PTSKnown = oldDetails.PTSKnown;
}

function mergeSubtitlePlaylists(oldPlaylist, newPlaylist) {
  var referenceStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var lastIndex = -1;
  mapFragmentIntersection(oldPlaylist, newPlaylist, function (oldFrag, newFrag, index) {
    newFrag.start = oldFrag.start;
    lastIndex = index;
  });

  var frags = newPlaylist.fragments;
  if (lastIndex < 0) {
    frags.forEach(function (frag) {
      frag.start += referenceStart;
    });
    return;
  }

  for (var i = lastIndex + 1; i < frags.length; i++) {
    frags[i].start = frags[i - 1].start + frags[i - 1].duration;
  }
}

function mapFragmentIntersection(oldPlaylist, newPlaylist, intersectionFn) {
  if (!oldPlaylist || !newPlaylist) {
    return;
  }

  var start = Math.max(oldPlaylist.startSN, newPlaylist.startSN) - newPlaylist.startSN;
  var end = Math.min(oldPlaylist.endSN, newPlaylist.endSN) - newPlaylist.startSN;
  var delta = newPlaylist.startSN - oldPlaylist.startSN;

  for (var i = start; i <= end; i++) {
    var oldFrag = oldPlaylist.fragments[delta + i];
    var newFrag = newPlaylist.fragments[i];
    if (!oldFrag || !newFrag) {
      break;
    }
    intersectionFn(oldFrag, newFrag, i);
  }
}

function adjustSliding(oldPlaylist, newPlaylist) {
  var delta = newPlaylist.startSN - oldPlaylist.startSN;
  var oldFragments = oldPlaylist.fragments;
  var newFragments = newPlaylist.fragments;

  if (delta < 0 || delta > oldFragments.length) {
    return;
  }
  for (var i = 0; i < newFragments.length; i++) {
    newFragments[i].start += oldFragments[delta].start;
  }
}

function computeReloadInterval(currentPlaylist, newPlaylist, lastRequestTime) {
  var reloadInterval = 1000 * (newPlaylist.averagetargetduration ? newPlaylist.averagetargetduration : newPlaylist.targetduration);
  var minReloadInterval = reloadInterval / 2;
  if (currentPlaylist && newPlaylist.endSN === currentPlaylist.endSN) {
    // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
    // changed then it MUST wait for a period of one-half the target
    // duration before retrying.
    reloadInterval = minReloadInterval;
  }

  if (lastRequestTime) {
    reloadInterval = Math.max(minReloadInterval, reloadInterval - (window.performance.now() - lastRequestTime));
  }
  // in any case, don't reload more than half of target duration
  return Math.round(reloadInterval);
}

/***/ }),

/***/ "./src/hls.js/controller/stream-controller.js":
/*!****************************************************!*\
  !*** ./src/hls.js/controller/stream-controller.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _binarySearch = __webpack_require__(/*! ../utils/binary-search */ "./src/hls.js/utils/binary-search.js");

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _demuxer = __webpack_require__(/*! ../demux/demuxer */ "./src/hls.js/demux/demuxer.js");

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _fragmentTracker = __webpack_require__(/*! ./fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _fragment = __webpack_require__(/*! ../loader/fragment */ "./src/hls.js/loader/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _playlistLoader = __webpack_require__(/*! ../loader/playlist-loader */ "./src/hls.js/loader/playlist-loader.js");

var _playlistLoader2 = _interopRequireDefault(_playlistLoader);

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

var LevelHelper = _interopRequireWildcard(_levelHelper);

var _timeRanges = __webpack_require__(/*! ../utils/time-ranges */ "./src/hls.js/utils/time-ranges.js");

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _discontinuities = __webpack_require__(/*! ../utils/discontinuities */ "./src/hls.js/utils/discontinuities.js");

var _fragmentFinders = __webpack_require__(/*! ./fragment-finders */ "./src/hls.js/controller/fragment-finders.js");

var _gapController = __webpack_require__(/*! ./gap-controller */ "./src/hls.js/controller/gap-controller.js");

var _gapController2 = _interopRequireDefault(_gapController);

var _baseStreamController = __webpack_require__(/*! ./base-stream-controller */ "./src/hls.js/controller/base-stream-controller.js");

var _baseStreamController2 = _interopRequireDefault(_baseStreamController);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var TICK_INTERVAL = 100; // how often to tick in ms

var StreamController = function (_BaseStreamController) {
  _inherits(StreamController, _BaseStreamController);

  function StreamController(hls, fragmentTracker) {
    _classCallCheck(this, StreamController);

    var _this = _possibleConstructorReturn(this, (StreamController.__proto__ || Object.getPrototypeOf(StreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.LEVEL_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_LOAD_EMERGENCY_ABORTED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED));

    _this.fragmentTracker = fragmentTracker;
    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this._state = _baseStreamController.State.STOPPED;
    _this.stallReported = false;
    _this.gapController = null;
    return _this;
  }

  _createClass(StreamController, [{
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.levels) {
        var lastCurrentTime = this.lastCurrentTime,
            hls = this.hls;
        this.stopLoad();
        this.setInterval(TICK_INTERVAL);
        this.level = -1;
        this.fragLoadError = 0;
        if (!this.startFragRequested) {
          // determine load level
          var startLevel = hls.startLevel;
          if (startLevel === -1) {
            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
            startLevel = 0;
            this.bitrateTest = true;
          }
          // set new level to playlist loader : this will trigger start level load
          // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded
          this.level = hls.nextLoadLevel = startLevel;
          this.loadedmetadata = false;
        }
        // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime
        if (lastCurrentTime > 0 && startPosition === -1) {
          _logger.logger.log('override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
          startPosition = lastCurrentTime;
        }
        this.state = _baseStreamController.State.IDLE;
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
        this.tick();
      } else {
        this.forceStartLoad = true;
        this.state = _baseStreamController.State.STOPPED;
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.forceStartLoad = false;
      _get(StreamController.prototype.__proto__ || Object.getPrototypeOf(StreamController.prototype), 'stopLoad', this).call(this);
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      switch (this.state) {
        case _baseStreamController.State.BUFFER_FLUSHING:
          // in buffer flushing state, reset fragLoadError counter
          this.fragLoadError = 0;
          break;
        case _baseStreamController.State.IDLE:
          this._doTickIdle();
          break;
        case _baseStreamController.State.WAITING_LEVEL:
          var level = this.levels[this.level];
          // check if playlist is already loaded
          if (level && level.details) {
            this.state = _baseStreamController.State.IDLE;
          }

          break;
        case _baseStreamController.State.FRAG_LOADING_WAITING_RETRY:
          var now = window.performance.now();
          var retryDate = this.retryDate;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || this.media && this.media.seeking) {
            _logger.logger.log('mediaController: retryDate reached, switch back to IDLE state');
            this.state = _baseStreamController.State.IDLE;
          }
          break;
        case _baseStreamController.State.ERROR:
        case _baseStreamController.State.STOPPED:
        case _baseStreamController.State.FRAG_LOADING:
        case _baseStreamController.State.PARSING:
        case _baseStreamController.State.PARSED:
        case _baseStreamController.State.ENDED:
          break;
        default:
          break;
      }
      // check buffer
      this._checkBuffer();
      // check/update current fragment
      this._checkFragmentChanged();
    }

    // Ironically the "idle" state is the on we do the most logic in it seems ....
    // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently
    //       played segment, or on pause/play/seek instead of naively checking every 100ms?

  }, {
    key: '_doTickIdle',
    value: function _doTickIdle() {
      var hls = this.hls,
          config = hls.config,
          media = this.media;

      // if start level not parsed yet OR
      // if video not attached AND start fragment already requested OR start frag prefetch disable
      // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment
      if (this.levelLastLoaded === undefined || !media && (this.startFragRequested || !config.startFragPrefetch)) {
        return;
      }

      // if we have not yet loaded any fragment, start loading from start position
      var pos = void 0;
      if (this.loadedmetadata) {
        pos = media.currentTime;
      } else {
        pos = this.nextLoadPosition;
      }

      // determine next load level
      var level = hls.nextLoadLevel,
          levelInfo = this.levels[level];

      if (!levelInfo) {
        return;
      }

      var levelBitrate = levelInfo.bitrate,
          maxBufLen = void 0;

      // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
      if (levelBitrate) {
        maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
      } else {
        maxBufLen = config.maxBufferLength;
      }

      maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);

      // determine next candidate fragment to be loaded, based on current position and end of buffer position
      // ensure up to `config.maxMaxBufferLength` of buffer upfront

      var bufferInfo = _bufferHelper.BufferHelper.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, config.maxBufferHole),
          bufferLen = bufferInfo.len;
      // Stay idle if we are still with buffer margins
      if (bufferLen >= maxBufLen) {
        return;
      }

      // if buffer length is less than maxBufLen try to load a new fragment ...
      _logger.logger.trace('buffer length of ' + bufferLen.toFixed(3) + ' is below max of ' + maxBufLen.toFixed(3) + '. checking for more payload ...');

      // set next load level : this will trigger a playlist load if needed
      this.level = hls.nextLoadLevel = level;

      var levelDetails = levelInfo.details;
      // if level info not retrieved yet, switch state and wait for level retrieval
      // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
      // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)
      if (!levelDetails || levelDetails.live && this.levelLastLoaded !== level) {
        this.state = _baseStreamController.State.WAITING_LEVEL;
        return;
      }

      if (this._streamEnded(bufferInfo, levelDetails)) {
        var data = {};
        if (this.altAudio) {
          data.type = 'video';
        }

        this.hls.trigger(_events2.default.BUFFER_EOS, data);
        this.state = _baseStreamController.State.ENDED;
        return;
      }
      // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)
      this._fetchPayloadOrEos(pos, bufferInfo, levelDetails);
    }
  }, {
    key: '_fetchPayloadOrEos',
    value: function _fetchPayloadOrEos(pos, bufferInfo, levelDetails) {
      var fragPrevious = this.fragPrevious,
          level = this.level,
          fragments = levelDetails.fragments,
          fragLen = fragments.length;

      // empty playlist
      if (fragLen === 0) {
        return;
      }

      // find fragment index, contiguous with end of buffer position
      var start = fragments[0].start,
          end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
          bufferEnd = bufferInfo.end,
          frag = void 0;

      if (levelDetails.initSegment && !levelDetails.initSegment.data) {
        frag = levelDetails.initSegment;
      } else {
        // in case of live playlist we need to ensure that requested position is not located before playlist start
        if (levelDetails.live) {
          var initialLiveManifestSize = this.config.initialLiveManifestSize;
          if (fragLen < initialLiveManifestSize) {
            _logger.logger.warn('Can not start playback of a level, reason: not enough fragments ' + fragLen + ' < ' + initialLiveManifestSize);
            return;
          }

          frag = this._ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen);
          // if it explicitely returns null don't load any fragment and exit function now
          if (frag === null) {
            return;
          }
        } else {
          // VoD playlist: if bufferEnd before start of playlist, load first fragment
          if (bufferEnd < start) {
            frag = fragments[0];
          }
        }
      }
      if (!frag) {
        frag = this._findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails);
      }

      if (frag) {
        if (frag.encrypted) {
          _logger.logger.log('Loading key for ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level);
          this._loadKey(frag);
        } else {
          _logger.logger.log('Loading ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level + ', currentTime:' + pos.toFixed(3) + ',bufferEnd:' + bufferEnd.toFixed(3));
          this._loadFragment(frag);
        }
      }
    }
  }, {
    key: '_ensureFragmentAtLivePoint',
    value: function _ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen) {
      var config = this.hls.config,
          media = this.media;

      var frag = void 0;

      // check if requested position is within seekable boundaries :
      // logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);
      var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;

      if (bufferEnd < Math.max(start - config.maxFragLookUpTolerance, end - maxLatency)) {
        var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);
        _logger.logger.log('buffer end: ' + bufferEnd.toFixed(3) + ' is located too far from the end of live sliding playlist, reset currentTime to : ' + liveSyncPosition.toFixed(3));
        bufferEnd = liveSyncPosition;
        if (media && media.readyState && media.duration > liveSyncPosition) {
          media.currentTime = liveSyncPosition;
        }

        this.nextLoadPosition = liveSyncPosition;
      }

      // if end of buffer greater than live edge, don't load any fragment
      // this could happen if live playlist intermittently slides in the past.
      // level 1 loaded [182580161,182580167]
      // level 1 loaded [182580162,182580169]
      // Loading 182580168 of [182580162 ,182580169],level 1 ..
      // Loading 182580169 of [182580162 ,182580169],level 1 ..
      // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168
      // level 1 loaded [182580164,182580171]
      //
      // don't return null in case media not loaded yet (readystate === 0)
      if (levelDetails.PTSKnown && bufferEnd > end && media && media.readyState) {
        return null;
      }

      if (this.startFragRequested && !levelDetails.PTSKnown) {
        /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...
           try to load frag matching with next SN.
           even if SN are not synchronized between playlists, loading this frag will help us
           compute playlist sliding and find the right one after in case it was not the right consecutive one */
        if (fragPrevious) {
          if (levelDetails.hasProgramDateTime) {
            // Relies on PDT in order to switch bitrates (Support EXT-X-DISCONTINUITY without EXT-X-DISCONTINUITY-SEQUENCE)
            _logger.logger.log('live playlist, switching playlist, load frag with same PDT: ' + fragPrevious.programDateTime);
            frag = (0, _fragmentFinders.findFragmentByPDT)(fragments, fragPrevious.endProgramDateTime, config.maxFragLookUpTolerance);
          } else {
            // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)
            var targetSN = fragPrevious.sn + 1;
            if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
              var fragNext = fragments[targetSN - levelDetails.startSN];
              if (fragPrevious.cc === fragNext.cc) {
                frag = fragNext;
                _logger.logger.log('live playlist, switching playlist, load frag with next SN: ' + frag.sn);
              }
            }
            // next frag SN not available (or not with same continuity counter)
            // look for a frag sharing the same CC
            if (!frag) {
              frag = _binarySearch2.default.search(fragments, function (frag) {
                return fragPrevious.cc - frag.cc;
              });
              if (frag) {
                _logger.logger.log('live playlist, switching playlist, load frag with same CC: ' + frag.sn);
              }
            }
          }
        }
        if (!frag) {
          /* we have no idea about which fragment should be loaded.
             so let's load mid fragment. it will help computing playlist sliding and find the right one
          */
          frag = fragments[Math.min(fragLen - 1, Math.round(fragLen / 2))];
          _logger.logger.log('live playlist, switching playlist, unknown, load middle frag : ' + frag.sn);
        }
      }

      return frag;
    }
  }, {
    key: '_findFragment',
    value: function _findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails) {
      var config = this.hls.config;
      var frag = void 0;

      if (bufferEnd < end) {
        var lookupTolerance = bufferEnd > end - config.maxFragLookUpTolerance ? 0 : config.maxFragLookUpTolerance;
        // Remove the tolerance if it would put the bufferEnd past the actual end of stream
        // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)
        frag = (0, _fragmentFinders.findFragmentByPTS)(fragPrevious, fragments, bufferEnd, lookupTolerance);
      } else {
        // reach end of playlist
        frag = fragments[fragLen - 1];
      }
      if (frag) {
        var curSNIdx = frag.sn - levelDetails.startSN;
        var sameLevel = fragPrevious && frag.levels === fragPrevious.levels;
        var prevFrag = fragments[curSNIdx - 1];
        var nextFrag = fragments[curSNIdx + 1];
        // logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
        if (fragPrevious && frag.sn === fragPrevious.sn) {
          if (sameLevel && !frag.backtracked) {
            if (frag.sn < levelDetails.endSN) {
              var deltaPTS = fragPrevious.deltaPTS;
              // if there is a significant delta between audio and video, larger than max allowed hole,
              // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)
              // let's try to load previous fragment again to get last keyframe
              // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)
              if (deltaPTS && deltaPTS > config.maxBufferHole && fragPrevious.dropped && curSNIdx) {
                frag = prevFrag;
                _logger.logger.warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');
              } else {
                frag = nextFrag;
                _logger.logger.log('SN just loaded, load next one: ' + frag.sn, frag);
              }
            } else {
              frag = null;
            }
          } else if (frag.backtracked) {
            // Only backtrack a max of 1 consecutive fragment to prevent sliding back too far when little or no frags start with keyframes
            if (nextFrag && nextFrag.backtracked) {
              _logger.logger.warn('Already backtracked from fragment ' + nextFrag.sn + ', will not backtrack to fragment ' + frag.sn + '. Loading fragment ' + nextFrag.sn);
              frag = nextFrag;
            } else {
              // If a fragment has dropped frames and it's in a same level/sequence, load the previous fragment to try and find the keyframe
              // Reset the dropped count now since it won't be reset until we parse the fragment again, which prevents infinite backtracking on the same segment
              _logger.logger.warn('Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe');
              frag.dropped = 0;
              if (prevFrag) {
                frag = prevFrag;
                frag.backtracked = true;
              } else if (curSNIdx) {
                // can't backtrack on very first fragment
                frag = null;
              }
            }
          }
        }
      }
      return frag;
    }
  }, {
    key: '_loadKey',
    value: function _loadKey(frag) {
      this.state = _baseStreamController.State.KEY_LOADING;
      this.hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
    }
  }, {
    key: '_loadFragment',
    value: function _loadFragment(frag) {
      // Check if fragment is not loaded
      var fragState = this.fragmentTracker.getState(frag);

      this.fragCurrent = frag;
      this.startFragRequested = true;
      // Don't update nextLoadPosition for fragments which are not buffered
      if (Number.isFinite(frag.sn) && !frag.bitrateTest) {
        this.nextLoadPosition = frag.start + frag.duration;
      }

      // Allow backtracked fragments to load
      if (frag.backtracked || fragState === _fragmentTracker.FragmentState.NOT_LOADED || fragState === _fragmentTracker.FragmentState.PARTIAL) {
        frag.autoLevel = this.hls.autoLevelEnabled;
        frag.bitrateTest = this.bitrateTest;

        this.hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
        // lazy demuxer init, as this could take some time ... do it during frag loading
        if (!this.demuxer) {
          this.demuxer = new _demuxer2.default(this.hls, 'main');
        }

        this.state = _baseStreamController.State.FRAG_LOADING;
      } else if (fragState === _fragmentTracker.FragmentState.APPENDING) {
        // Lower the buffer size and try again
        if (this._reduceMaxBufferLength(frag.duration)) {
          this.fragmentTracker.removeFragment(frag);
        }
      }
    }
  }, {
    key: 'getBufferedFrag',
    value: function getBufferedFrag(position) {
      return this.fragmentTracker.getBufferedFrag(position, _playlistLoader2.default.LevelType.MAIN);
    }
  }, {
    key: 'followingBufferedFrag',
    value: function followingBufferedFrag(frag) {
      if (frag) {
        // try to get range of next fragment (500ms after this range)
        return this.getBufferedFrag(frag.endPTS + 0.5);
      }
      return null;
    }
  }, {
    key: '_checkFragmentChanged',
    value: function _checkFragmentChanged() {
      var fragPlayingCurrent = void 0,
          currentTime = void 0,
          video = this.media;
      if (video && video.readyState && video.seeking === false) {
        currentTime = video.currentTime;
        /* if video element is in seeked state, currentTime can only increase.
          (assuming that playback rate is positive ...)
          As sometimes currentTime jumps back to zero after a
          media decode error, check this, to avoid seeking back to
          wrong position after a media decode error
        */
        if (currentTime > this.lastCurrentTime) {
          this.lastCurrentTime = currentTime;
        }

        if (_bufferHelper.BufferHelper.isBuffered(video, currentTime)) {
          fragPlayingCurrent = this.getBufferedFrag(currentTime);
        } else if (_bufferHelper.BufferHelper.isBuffered(video, currentTime + 0.1)) {
          /* ensure that FRAG_CHANGED event is triggered at startup,
            when first video frame is displayed and playback is paused.
            add a tolerance of 100ms, in case current position is not buffered,
            check if current pos+100ms is buffered and use that buffer range
            for FRAG_CHANGED event reporting */
          fragPlayingCurrent = this.getBufferedFrag(currentTime + 0.1);
        }
        if (fragPlayingCurrent) {
          var fragPlaying = fragPlayingCurrent;
          if (fragPlaying !== this.fragPlaying) {
            this.hls.trigger(_events2.default.FRAG_CHANGED, { frag: fragPlaying });
            var fragPlayingLevel = fragPlaying.levels;
            if (!this.fragPlaying || this.fragPlaying.levels !== fragPlayingLevel) {
              this.hls.trigger(_events2.default.LEVEL_SWITCHED, { level: fragPlayingLevel });
            }

            this.fragPlaying = fragPlaying;
          }
        }
      }
    }

    /*
      on immediate level switch :
       - pause playback if playing
       - cancel any pending load request
       - and trigger a buffer flush
    */

  }, {
    key: 'immediateLevelSwitch',
    value: function immediateLevelSwitch() {
      _logger.logger.log('immediateLevelSwitch');
      if (!this.immediateSwitch) {
        this.immediateSwitch = true;
        var media = this.media,
            previouslyPaused = void 0;
        if (media) {
          previouslyPaused = media.paused;
          media.pause();
        } else {
          // don't restart playback after instant level switch in case media not attached
          previouslyPaused = true;
        }
        this.previouslyPaused = previouslyPaused;
      }
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && fragCurrent.loader) {
        fragCurrent.loader.abort();
      }

      this.fragCurrent = null;
      // flush everything
      this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
    }

    /**
     * on immediate level switch end, after new fragment has been buffered:
     * - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)
     * - resume the playback if needed
     */

  }, {
    key: 'immediateLevelSwitchEnd',
    value: function immediateLevelSwitchEnd() {
      var media = this.media;
      if (media && media.buffered.length) {
        this.immediateSwitch = false;
        if (_bufferHelper.BufferHelper.isBuffered(media, media.currentTime)) {
          // only nudge if currentTime is buffered
          media.currentTime -= 0.0001;
        }
        if (!this.previouslyPaused) {
          media.play();
        }
      }
    }

    /**
     * try to switch ASAP without breaking video playback:
     * in order to ensure smooth but quick level switching,
     * we need to find the next flushable buffer range
     * we should take into account new segment fetch time
     */

  }, {
    key: 'nextLevelSwitch',
    value: function nextLevelSwitch() {
      var media = this.media;
      // ensure that media is defined and that metadata are available (to retrieve currentTime)
      if (media && media.readyState) {
        var fetchdelay = void 0,
            fragPlayingCurrent = void 0,
            nextBufferedFrag = void 0;
        fragPlayingCurrent = this.getBufferedFrag(media.currentTime);
        if (fragPlayingCurrent && fragPlayingCurrent.startPTS > 1) {
          // flush buffer preceding current fragment (flush until current fragment start offset)
          // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
          this.flushMainBuffer(0, fragPlayingCurrent.startPTS - 1);
        }
        if (!media.paused) {
          // add a safety delay of 1s
          var nextLevelId = this.hls.nextLoadLevel,
              nextLevel = this.levels[nextLevelId],
              fragLastKbps = this.fragLastKbps;
          if (fragLastKbps && this.fragCurrent) {
            fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1000 * fragLastKbps) + 1;
          } else {
            fetchdelay = 0;
          }
        } else {
          fetchdelay = 0;
        }
        // logger.log('fetchdelay:'+fetchdelay);
        // find buffer range that will be reached once new fragment will be fetched
        nextBufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
        if (nextBufferedFrag) {
          // we can flush buffer range following this one without stalling playback
          nextBufferedFrag = this.followingBufferedFrag(nextBufferedFrag);
          if (nextBufferedFrag) {
            // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
            var fragCurrent = this.fragCurrent;
            if (fragCurrent && fragCurrent.loader) {
              fragCurrent.loader.abort();
            }

            this.fragCurrent = null;
            // start flush position is the start PTS of next buffered frag.
            // we use frag.naxStartPTS which is max(audio startPTS, video startPTS).
            // in case there is a small PTS Delta between audio and video, using maxStartPTS avoids flushing last samples from current fragment
            this.flushMainBuffer(nextBufferedFrag.maxStartPTS, Number.POSITIVE_INFINITY);
          }
        }
      }
    }
  }, {
    key: 'flushMainBuffer',
    value: function flushMainBuffer(startOffset, endOffset) {
      this.state = _baseStreamController.State.BUFFER_FLUSHING;
      var flushScope = { startOffset: startOffset, endOffset: endOffset };
      // if alternate audio tracks are used, only flush video, otherwise flush everything
      if (this.altAudio) {
        flushScope.type = 'video';
      }

      this.hls.trigger(_events2.default.BUFFER_FLUSHING, flushScope);
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvseeked = this.onMediaSeeked.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('seeked', this.onvseeked);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.levels && config.autoStartLoad) {
        this.hls.startLoad(config.startPosition);
      }

      this.gapController = new _gapController2.default(config, media, this.fragmentTracker, this.hls);
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // reset fragment backtracked flag
      var levels = this.levels;
      if (levels) {
        levels.forEach(function (level) {
          if (level.details) {
            level.details.fragments.forEach(function (fragment) {
              fragment.backtracked = undefined;
            });
          }
        });
      }
      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('seeked', this.onvseeked);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = this.mediaBuffer = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onMediaSeeked',
    value: function onMediaSeeked() {
      var media = this.media,
          currentTime = media ? media.currentTime : undefined;
      if (Number.isFinite(currentTime)) {
        _logger.logger.log('media seeked to ' + currentTime.toFixed(3));
      }

      // tick to speed up FRAGMENT_PLAYING triggering
      this.tick();
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      // reset buffer on manifest loading
      _logger.logger.log('trigger BUFFER_RESET');
      this.hls.trigger(_events2.default.BUFFER_RESET);
      this.fragmentTracker.removeAllFragments();
      this.stalled = false;
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var aac = false,
          heaac = false,
          codec = void 0;
      data.levels.forEach(function (level) {
        // detect if we have different kind of audio codecs used amongst playlists
        codec = level.audioCodec;
        if (codec) {
          if (codec.indexOf('mp4a.40.2') !== -1) {
            aac = true;
          }

          if (codec.indexOf('mp4a.40.5') !== -1) {
            heaac = true;
          }
        }
      });
      this.audioCodecSwitch = aac && heaac;
      if (this.audioCodecSwitch) {
        _logger.logger.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
      }

      this.levels = data.levels;
      this.startFragRequested = false;
      var config = this.config;
      if (config.autoStartLoad || this.forceStartLoad) {
        this.hls.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var newDetails = data.details;
      var newLevelId = data.levels;
      var lastLevel = this.levels[this.levelLastLoaded];
      var curLevel = this.levels[newLevelId];
      var duration = newDetails.totalduration;
      var sliding = 0;

      _logger.logger.log('level ' + newLevelId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);

      if (newDetails.live) {
        var curDetails = curLevel.details;
        if (curDetails && newDetails.fragments.length > 0) {
          // we already have details for that level, merge them
          LevelHelper.mergeDetails(curDetails, newDetails);
          sliding = newDetails.fragments[0].start;
          this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
          if (newDetails.PTSKnown && Number.isFinite(sliding)) {
            _logger.logger.log('live playlist sliding:' + sliding.toFixed(3));
          } else {
            _logger.logger.log('live playlist - outdated PTS, unknown sliding');
            (0, _discontinuities.alignStream)(this.fragPrevious, lastLevel, newDetails);
          }
        } else {
          _logger.logger.log('live playlist - first load, unknown sliding');
          newDetails.PTSKnown = false;
          (0, _discontinuities.alignStream)(this.fragPrevious, lastLevel, newDetails);
        }
      } else {
        newDetails.PTSKnown = false;
      }
      // override level info
      curLevel.details = newDetails;
      this.levelLastLoaded = newLevelId;
      this.hls.trigger(_events2.default.LEVEL_UPDATED, { details: newDetails, level: newLevelId });

      if (this.startFragRequested === false) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1 || this.lastCurrentTime === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = newDetails.startTimeOffset;
          if (Number.isFinite(startTimeOffset)) {
            if (startTimeOffset < 0) {
              _logger.logger.log('negative start time offset ' + startTimeOffset + ', count from end of last fragment');
              startTimeOffset = sliding + duration + startTimeOffset;
            }
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)
            if (newDetails.live) {
              this.startPosition = this.computeLivePosition(sliding, newDetails);
              _logger.logger.log('configure startPosition to ' + this.startPosition);
            } else {
              this.startPosition = 0;
            }
          }
          this.lastCurrentTime = this.startPosition;
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment
      if (this.state === _baseStreamController.State.WAITING_LEVEL) {
        this.state = _baseStreamController.State.IDLE;
      }

      // trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === _baseStreamController.State.KEY_LOADING) {
        this.state = _baseStreamController.State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent,
          hls = this.hls,
          levels = this.levels,
          media = this.media;

      var fragLoaded = data.frag;
      if (this.state === _baseStreamController.State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'main' && fragLoaded.levels === fragCurrent.levels && fragLoaded.sn === fragCurrent.sn) {
        var stats = data.stats;
        var currentLevel = levels[fragCurrent.levels];
        var details = currentLevel.details;
        // reset frag bitrate test in any case after frag loaded event
        // if this frag was loaded to perform a bitrate test AND if hls.nextLoadLevel is greater than 0
        // then this means that we should be able to load a fragment at a higher quality level
        this.bitrateTest = false;
        this.stats = stats;

        _logger.logger.log('Loaded ' + fragCurrent.sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + fragCurrent.levels);
        if (fragLoaded.bitrateTest && hls.nextLoadLevel) {
          // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo
          this.state = _baseStreamController.State.IDLE;
          this.startFragRequested = false;
          stats.tparsed = stats.tbuffered = window.performance.now();
          hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
          this.tick();
        } else if (fragLoaded.sn === 'initSegment') {
          this.state = _baseStreamController.State.IDLE;
          stats.tparsed = stats.tbuffered = window.performance.now();
          details.initSegment.data = data.payload;
          hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
          this.tick();
        } else {
          _logger.logger.log('Parsing ' + fragCurrent.sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + fragCurrent.levels + ', cc ' + fragCurrent.cc);
          this.state = _baseStreamController.State.PARSING;
          this.pendingBuffering = true;
          this.appended = false;

          // Bitrate test frags are not usually buffered so the fragment tracker ignores them. If Hls.js decides to buffer
          // it (and therefore ends up at this line), then the fragment tracker needs to be manually informed.
          if (fragLoaded.bitrateTest) {
            fragLoaded.bitrateTest = false;
            this.fragmentTracker.onFragLoaded({
              frag: fragLoaded
            });
          }

          // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live) and if media is not seeking (this is to overcome potential timestamp drifts between playlists and fragments)
          var accurateTimeOffset = !(media && media.seeking) && (details.PTSKnown || !details.live);
          var initSegmentData = details.initSegment ? details.initSegment.data : [];
          var audioCodec = this._getAudioCodec(currentLevel);

          // transmux the MPEG-TS data to ISO-BMFF segments
          var demuxer = this.demuxer = this.demuxer || new _demuxer2.default(this.hls, 'main');
          demuxer.push(data.payload, initSegmentData, audioCodec, currentLevel.videoCodec, fragCurrent, details.totalduration, accurateTimeOffset);
        }
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;

      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.levels === fragCurrent.levels && this.state === _baseStreamController.State.PARSING) {
        var tracks = data.tracks,
            trackName = void 0,
            track = void 0;

        // if audio track is expected to come from audio stream controller, discard any coming from main
        if (tracks.audio && this.altAudio) {
          delete tracks.audio;
        }

        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          var audioCodec = this.levels[this.level].audioCodec,
              ua = navigator.userAgent.toLowerCase();
          if (audioCodec && this.audioCodecSwap) {
            _logger.logger.log('swapping playlist audio codec');
            if (audioCodec.indexOf('mp4a.40.5') !== -1) {
              audioCodec = 'mp4a.40.2';
            } else {
              audioCodec = 'mp4a.40.5';
            }
          }
          // in case AAC and HE-AAC audio codecs are signalled in manifest
          // force HE-AAC , as it seems that most browsers prefers that way,
          // except for mono streams OR on FF
          // these conditions might need to be reviewed ...
          if (this.audioCodecSwitch) {
            // don't force HE-AAC if mono stream
            if (track.metadata.channelCount !== 1 &&
            // don't force HE-AAC if firefox
            ua.indexOf('firefox') === -1) {
              audioCodec = 'mp4a.40.5';
            }
          }
          // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise
          if (ua.indexOf('android') !== -1 && track.container !== 'audio/mpeg') {
            // Exclude mpeg audio
            audioCodec = 'mp4a.40.2';
            _logger.logger.log('Android: force audio codec to ' + audioCodec);
          }
          track.levelCodec = audioCodec;
          track.id = data.id;
        }
        track = tracks.video;
        if (track) {
          track.levelCodec = this.levels[this.level].videoCodec;
          track.id = data.id;
        }
        this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
        // loop through tracks that are going to be provided to bufferController
        for (trackName in tracks) {
          track = tracks[trackName];
          _logger.logger.log('main track:' + trackName + ',container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            this.appended = true;
            // arm pending Buffering flag before appending a segment
            this.pendingBuffering = true;
            this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: trackName, data: initSegment, parent: 'main', content: 'initSegment' });
          }
        }
        // trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.levels === fragCurrent.levels && !(data.type === 'audio' && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
      this.state === _baseStreamController.State.PARSING) {
        var level = this.levels[this.level],
            frag = fragCurrent;
        if (!Number.isFinite(data.endPTS)) {
          data.endPTS = data.startPTS + fragCurrent.duration;
          data.endDTS = data.startDTS + fragCurrent.duration;
        }

        if (data.hasAudio === true) {
          frag.addElementaryStream(_fragment2.default.ElementaryStreamTypes.AUDIO);
        }

        if (data.hasVideo === true) {
          frag.addElementaryStream(_fragment2.default.ElementaryStreamTypes.VIDEO);
        }

        _logger.logger.log('Parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb + ',dropped:' + (data.dropped || 0));

        // Detect gaps in a fragment  and try to fix it by finding a keyframe in the previous fragment (see _findFragments)
        if (data.type === 'video') {
          frag.dropped = data.dropped;
          if (frag.dropped) {
            if (!frag.backtracked) {
              var levelDetails = level.details;
              if (levelDetails && frag.sn === levelDetails.startSN) {
                _logger.logger.warn('missing video frame(s) on first frag, appending with gap', frag.sn);
              } else {
                _logger.logger.warn('missing video frame(s), backtracking fragment', frag.sn);
                // Return back to the IDLE state without appending to buffer
                // Causes findFragments to backtrack a segment and find the keyframe
                // Audio fragments arriving before video sets the nextLoadPosition, causing _findFragments to skip the backtracked fragment
                this.fragmentTracker.removeFragment(frag);
                frag.backtracked = true;
                this.nextLoadPosition = data.startPTS;
                this.state = _baseStreamController.State.IDLE;
                this.fragPrevious = frag;
                this.tick();
                return;
              }
            } else {
              _logger.logger.warn('Already backtracked on this fragment, appending with the gap', frag.sn);
            }
          } else {
            // Only reset the backtracked flag if we've loaded the frag without any dropped frames
            frag.backtracked = false;
          }
        }

        var drift = LevelHelper.updateFragPTSDTS(level.details, frag, data.startPTS, data.endPTS, data.startDTS, data.endDTS),
            hls = this.hls;
        hls.trigger(_events2.default.LEVEL_PTS_UPDATED, { details: level.details, level: this.level, drift: drift, type: data.type, start: data.startPTS, end: data.endPTS });
        // has remuxer dropped video frames located before first keyframe ?
        [data.data1, data.data2].forEach(function (buffer) {
          // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
          // in that case it is useless to append following segments
          if (buffer && buffer.length && _this2.state === _baseStreamController.State.PARSING) {
            _this2.appended = true;
            // arm pending Buffering flag before appending a segment
            _this2.pendingBuffering = true;
            hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'main', content: 'data' });
          }
        });
        // trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.levels === fragCurrent.levels && this.state === _baseStreamController.State.PARSING) {
        this.stats.tparsed = window.performance.now();
        this.state = _baseStreamController.State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onAudioTrackSwitching',
    value: function onAudioTrackSwitching(data) {
      // if any URL found on new audio track, it is an alternate audio track
      var altAudio = !!data.url,
          trackId = data.id;
      // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
      // don't do anything if we switch to alt audio: audio stream controller is handling it.
      // we will just have to change buffer scheduling on audioTrackSwitched
      if (!altAudio) {
        if (this.mediaBuffer !== this.media) {
          _logger.logger.log('switching on main audio, use media.buffered to schedule main fragment loading');
          this.mediaBuffer = this.media;
          var fragCurrent = this.fragCurrent;
          // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch
          if (fragCurrent.loader) {
            _logger.logger.log('switching to main audio track, cancel main fragment load');
            fragCurrent.loader.abort();
          }
          this.fragCurrent = null;
          this.fragPrevious = null;
          // destroy demuxer to force init segment generation (following audio switch)
          if (this.demuxer) {
            this.demuxer.destroy();
            this.demuxer = null;
          }
          // switch to IDLE state to load new fragment
          this.state = _baseStreamController.State.IDLE;
        }
        var hls = this.hls;
        // switching to main audio, flush all audio and trigger track switched
        hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
        hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
        this.altAudio = false;
      }
    }
  }, {
    key: 'onAudioTrackSwitched',
    value: function onAudioTrackSwitched(data) {
      var trackId = data.id,
          altAudio = !!this.hls.audioTracks[trackId].url;
      if (altAudio) {
        var videoBuffer = this.videoBuffer;
        // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered
        if (videoBuffer && this.mediaBuffer !== videoBuffer) {
          _logger.logger.log('switching on alternate audio, use video.buffered to schedule main fragment loading');
          this.mediaBuffer = videoBuffer;
        }
      }
      this.altAudio = altAudio;
      this.tick();
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var tracks = data.tracks,
          mediaTrack = void 0,
          name = void 0,
          alternate = false;
      for (var type in tracks) {
        var track = tracks[type];
        if (track.id === 'main') {
          name = type;
          mediaTrack = track;
          // keep video source buffer reference
          if (type === 'video') {
            this.videoBuffer = tracks[type].buffer;
          }
        } else {
          alternate = true;
        }
      }
      if (alternate && mediaTrack) {
        _logger.logger.log('alternate track found, use ' + name + '.buffered to schedule main fragment loading');
        this.mediaBuffer = mediaTrack.buffer;
      } else {
        this.mediaBuffer = this.media;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'main') {
        var state = this.state;
        if (state === _baseStreamController.State.PARSING || state === _baseStreamController.State.PARSED) {
          // check if all buffers have been appended
          this.pendingBuffering = data.pending > 0;
          this._checkAppendedParsed();
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      // trigger handler right now
      if (this.state === _baseStreamController.State.PARSED && (!this.appended || !this.pendingBuffering)) {
        var frag = this.fragCurrent;
        if (frag) {
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('main buffered : ' + _timeRanges2.default.toString(media.buffered));
          this.fragPrevious = frag;
          var stats = this.stats;
          stats.tbuffered = window.performance.now();
          // we should get rid of this.fragLastKbps
          this.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'main' });
          this.state = _baseStreamController.State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag || this.fragCurrent;
      // don't handle frag error not related to main fragment
      if (frag && frag.type !== 'main') {
        return;
      }

      // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
      var mediaBuffered = !!this.media && _bufferHelper.BufferHelper.isBuffered(this.media, this.media.currentTime) && _bufferHelper.BufferHelper.isBuffered(this.media, this.media.currentTime + 0.5);

      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          if (!data.fatal) {
            // keep retrying until the limit will be reached
            if (this.fragLoadError + 1 <= this.config.fragLoadingMaxRetry) {
              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
              var delay = Math.min(Math.pow(2, this.fragLoadError) * this.config.fragLoadingRetryDelay, this.config.fragLoadingMaxRetryTimeout);
              _logger.logger.warn('mediaController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = window.performance.now() + delay;
              // retry loading state
              // if loadedmetadata is not set, it means that we are emergency switch down on first frag
              // in that case, reset startFragRequested flag
              if (!this.loadedmetadata) {
                this.startFragRequested = false;
                this.nextLoadPosition = this.startPosition;
              }
              this.fragLoadError++;
              this.state = _baseStreamController.State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('mediaController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // switch error to fatal
              data.fatal = true;
              this.state = _baseStreamController.State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          if (this.state !== _baseStreamController.State.ERROR) {
            if (data.fatal) {
              // if fatal error, stop processing
              this.state = _baseStreamController.State.ERROR;
              _logger.logger.warn('streamController: ' + data.details + ',switch to ' + this.state + ' state ...');
            } else {
              // in case of non fatal error while loading level, if level controller is not retrying to load level , switch back to IDLE
              if (!data.levelRetry && this.state === _baseStreamController.State.WAITING_LEVEL) {
                this.state = _baseStreamController.State.IDLE;
              }
            }
          }
          break;
        case _errors.ErrorDetails.BUFFER_FULL_ERROR:
          // if in appending state
          if (data.parent === 'main' && (this.state === _baseStreamController.State.PARSING || this.state === _baseStreamController.State.PARSED)) {
            // reduce max buf len if current position is buffered
            if (mediaBuffered) {
              this._reduceMaxBufferLength(this.config.maxBufferLength);
              this.state = _baseStreamController.State.IDLE;
            } else {
              // current position is not buffered, but browser is still complaining about buffer full error
              // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
              // in that case flush the whole buffer to recover
              _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush everything');
              this.fragCurrent = null;
              // flush everything
              this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
            }
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: '_reduceMaxBufferLength',
    value: function _reduceMaxBufferLength(minLength) {
      var config = this.config;
      if (config.maxMaxBufferLength >= minLength) {
        // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
        config.maxMaxBufferLength /= 2;
        _logger.logger.warn('main:reduce max buffer length to ' + config.maxMaxBufferLength + 's');
        return true;
      }
      return false;
    }

    /**
     * Checks the health of the buffer and attempts to resolve playback stalls.
     * @private
     */

  }, {
    key: '_checkBuffer',
    value: function _checkBuffer() {
      var media = this.media;

      if (!media || media.readyState === 0) {
        // Exit early if we don't have media or if the media hasn't bufferd anything yet (readyState 0)
        return;
      }

      var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;
      var buffered = mediaBuffer.buffered;

      if (!this.loadedmetadata && buffered.length) {
        this.loadedmetadata = true;
        this._seekToStartPos();
      } else if (this.immediateSwitch) {
        this.immediateLevelSwitchEnd();
      } else {
        this.gapController.poll(this.lastCurrentTime, buffered);
      }
    }
  }, {
    key: 'onFragLoadEmergencyAborted',
    value: function onFragLoadEmergencyAborted() {
      this.state = _baseStreamController.State.IDLE;
      // if loadedmetadata is not set, it means that we are emergency switch down on first frag
      // in that case, reset startFragRequested flag
      if (!this.loadedmetadata) {
        this.startFragRequested = false;
        this.nextLoadPosition = this.startPosition;
      }
      this.tick();
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      /* after successful buffer flushing, filter flushed fragments from bufferedFrags
        use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)
      */
      var media = this.mediaBuffer ? this.mediaBuffer : this.media;
      if (media) {
        // filter fragments potentially evicted from buffer. this is to avoid memleak on live streams
        this.fragmentTracker.detectEvictedFragments(_fragment2.default.ElementaryStreamTypes.VIDEO, media.buffered);
      }
      // move to IDLE once flush complete. this should trigger new fragment loading
      this.state = _baseStreamController.State.IDLE;
      // reset reference to frag
      this.fragPrevious = null;
    }
  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      this.audioCodecSwap = !this.audioCodecSwap;
    }
  }, {
    key: 'computeLivePosition',
    value: function computeLivePosition(sliding, levelDetails) {
      var targetLatency = this.config.liveSyncDuration !== undefined ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;
      return sliding + Math.max(0, levelDetails.totalduration - targetLatency);
    }

    /**
     * Seeks to the set startPosition if not equal to the mediaElement's current time.
     * @private
     */

  }, {
    key: '_seekToStartPos',
    value: function _seekToStartPos() {
      var media = this.media;

      var currentTime = media.currentTime;
      // only adjust currentTime if different from startPosition or if startPosition not buffered
      // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered
      var startPosition = media.seeking ? currentTime : this.startPosition;
      // if currentTime not matching with expected startPosition or startPosition not buffered but close to first buffered
      if (currentTime !== startPosition) {
        // if startPosition not buffered, let's seek to buffered.start(0)
        _logger.logger.log('target start position not buffered, seek to buffered.start(0) ' + startPosition + ' from current time ' + currentTime + ' ');
        media.currentTime = startPosition;
      }
    }
  }, {
    key: '_getAudioCodec',
    value: function _getAudioCodec(currentLevel) {
      var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
      if (this.audioCodecSwap) {
        _logger.logger.log('swapping playlist audio codec');
        if (audioCodec) {
          if (audioCodec.indexOf('mp4a.40.5') !== -1) {
            audioCodec = 'mp4a.40.2';
          } else {
            audioCodec = 'mp4a.40.5';
          }
        }
      }

      return audioCodec;
    }
  }, {
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        _logger.logger.log('main stream:' + previousState + '->' + nextState);
        this.hls.trigger(_events2.default.STREAM_STATE_TRANSITION, { previousState: previousState, nextState: nextState });
      }
    },
    get: function get() {
      return this._state;
    }
  }, {
    key: 'currentLevel',
    get: function get() {
      var media = this.media;
      if (media) {
        var frag = this.getBufferedFrag(media.currentTime);
        if (frag) {
          return frag.levels;
        }
      }
      return -1;
    }
  }, {
    key: 'nextBufferedFrag',
    get: function get() {
      var media = this.media;
      if (media) {
        // first get end range of current fragment
        return this.followingBufferedFrag(this.getBufferedFrag(media.currentTime));
      } else {
        return null;
      }
    }
  }, {
    key: 'nextLevel',
    get: function get() {
      var frag = this.nextBufferedFrag;
      if (frag) {
        return frag.levels;
      } else {
        return -1;
      }
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this._liveSyncPosition;
    },
    set: function set(value) {
      this._liveSyncPosition = value;
    }
  }]);

  return StreamController;
}(_baseStreamController2.default);

exports.default = StreamController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/subtitle-stream-controller.js":
/*!*************************************************************!*\
  !*** ./src/hls.js/controller/subtitle-stream-controller.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SubtitleStreamController = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _decrypter = __webpack_require__(/*! ../crypt/decrypter */ "./src/hls.js/crypt/decrypter.js");

var _decrypter2 = _interopRequireDefault(_decrypter);

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _fragmentFinders = __webpack_require__(/*! ./fragment-finders */ "./src/hls.js/controller/fragment-finders.js");

var _fragmentTracker = __webpack_require__(/*! ./fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _baseStreamController = __webpack_require__(/*! ./base-stream-controller */ "./src/hls.js/controller/base-stream-controller.js");

var _baseStreamController2 = _interopRequireDefault(_baseStreamController);

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @class SubtitleStreamController
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _window = window,
    performance = _window.performance;

var TICK_INTERVAL = 500; // how often to tick in ms

var SubtitleStreamController = exports.SubtitleStreamController = function (_BaseStreamController) {
  _inherits(SubtitleStreamController, _BaseStreamController);

  function SubtitleStreamController(hls, fragmentTracker) {
    _classCallCheck(this, SubtitleStreamController);

    var _this = _possibleConstructorReturn(this, (SubtitleStreamController.__proto__ || Object.getPrototypeOf(SubtitleStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.ERROR, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.SUBTITLE_TRACKS_UPDATED, _events2.default.SUBTITLE_TRACK_SWITCH, _events2.default.SUBTITLE_TRACK_LOADED, _events2.default.SUBTITLE_FRAG_PROCESSED, _events2.default.LEVEL_UPDATED));

    _this.fragmentTracker = fragmentTracker;
    _this.config = hls.config;
    _this.state = _baseStreamController.State.STOPPED;
    _this.tracks = [];
    _this.tracksBuffered = [];
    _this.currentTrackId = -1;
    _this.decrypter = new _decrypter2.default(hls, hls.config);
    // lastAVStart stores the time in seconds for the start time of a level load
    _this.lastAVStart = 0;
    _this._onMediaSeeking = _this.onMediaSeeking.bind(_this);
    return _this;
  }

  _createClass(SubtitleStreamController, [{
    key: 'onSubtitleFragProcessed',
    value: function onSubtitleFragProcessed(data) {
      var frag = data.frag,
          success = data.success;

      this.fragPrevious = frag;
      this.state = _baseStreamController.State.IDLE;
      if (!success) {
        return;
      }

      var buffered = this.tracksBuffered[this.currentTrackId];
      if (!buffered) {
        return;
      }

      // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo
      // so we can re-use the logic used to detect how much have been buffered
      var timeRange = void 0;
      var fragStart = frag.start;
      for (var i = 0; i < buffered.length; i++) {
        if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {
          timeRange = buffered[i];
          break;
        }
      }

      var fragEnd = frag.start + frag.duration;
      if (timeRange) {
        timeRange.end = fragEnd;
      } else {
        timeRange = {
          start: fragStart,
          end: fragEnd
        };
        buffered.push(timeRange);
      }
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(_ref) {
      var media = _ref.media;

      this.media = media;
      media.addEventListener('seeking', this._onMediaSeeking);
      this.state = _baseStreamController.State.IDLE;
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      this.media.removeEventListener('seeking', this._onMediaSeeking);
      this.media = null;
      this.state = _baseStreamController.State.STOPPED;
    }

    // If something goes wrong, proceed to next frag, if we were processing one.

  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle error not related to subtitle fragment
      if (!frag || frag.type !== 'subtitle') {
        return;
      }
      this.state = _baseStreamController.State.IDLE;
    }

    // Got all new subtitle tracks.

  }, {
    key: 'onSubtitleTracksUpdated',
    value: function onSubtitleTracksUpdated(data) {
      var _this2 = this;

      _logger.logger.log('subtitle tracks updated');
      this.tracksBuffered = [];
      this.tracks = data.subtitleTracks;
      this.tracks.forEach(function (track) {
        _this2.tracksBuffered[track.id] = [];
      });
    }
  }, {
    key: 'onSubtitleTrackSwitch',
    value: function onSubtitleTrackSwitch(data) {
      this.currentTrackId = data.id;

      if (!this.tracks || this.currentTrackId === -1) {
        this.clearInterval();
        return;
      }

      // Check if track has the necessary details to load fragments
      var currentTrack = this.tracks[this.currentTrackId];
      if (currentTrack && currentTrack.details) {
        this.setInterval(TICK_INTERVAL);
      }
    }

    // Got a new set of subtitle fragments.

  }, {
    key: 'onSubtitleTrackLoaded',
    value: function onSubtitleTrackLoaded(data) {
      var id = data.id,
          details = data.details;
      var currentTrackId = this.currentTrackId,
          tracks = this.tracks;

      var currentTrack = tracks[currentTrackId];
      if (id >= tracks.length || id !== currentTrackId || !currentTrack) {
        return;
      }

      if (details.live) {
        (0, _levelHelper.mergeSubtitlePlaylists)(currentTrack.details, details, this.lastAVStart);
      }
      currentTrack.details = details;
      this.setInterval(TICK_INTERVAL);
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === _baseStreamController.State.KEY_LOADING) {
        this.state = _baseStreamController.State.IDLE;
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent;
      var decryptData = data.frag.decryptdata;
      var fragLoaded = data.frag;
      var hls = this.hls;

      if (this.state === _baseStreamController.State.FRAG_LOADING && fragCurrent && data.frag.type === 'subtitle' && fragCurrent.sn === data.frag.sn) {
        // check to see if the payload needs to be decrypted
        if (data.payload.byteLength > 0 && decryptData && decryptData.key && decryptData.method === 'AES-128') {
          var startTime = performance.now();

          // decrypt the subtitles
          this.decrypter.decrypt(data.payload, decryptData.key.buffer, decryptData.iv.buffer, function (decryptedData) {
            var endTime = performance.now();
            hls.trigger(_events2.default.FRAG_DECRYPTED, { frag: fragLoaded, payload: decryptedData, stats: { tstart: startTime, tdecrypt: endTime } });
          });
        }
      }
    }
  }, {
    key: 'onLevelUpdated',
    value: function onLevelUpdated(_ref2) {
      var details = _ref2.details;

      var frags = details.fragments;
      this.lastAVStart = frags.length ? frags[0].start : 0;
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      if (!this.media) {
        this.state = _baseStreamController.State.IDLE;
        return;
      }

      switch (this.state) {
        case _baseStreamController.State.IDLE:
          {
            var config = this.config,
                currentTrackId = this.currentTrackId,
                fragmentTracker = this.fragmentTracker,
                media = this.media,
                tracks = this.tracks;

            if (!tracks || !tracks[currentTrackId] || !tracks[currentTrackId].details) {
              break;
            }

            var maxBufferHole = config.maxBufferHole,
                maxFragLookUpTolerance = config.maxFragLookUpTolerance;

            var maxConfigBuffer = Math.min(config.maxBufferLength, config.maxMaxBufferLength);
            var bufferedInfo = _bufferHelper.BufferHelper.bufferedInfo(this._getBuffered(), media.currentTime, maxBufferHole);
            var bufferEnd = bufferedInfo.end,
                bufferLen = bufferedInfo.len;


            var trackDetails = tracks[currentTrackId].details;
            var fragments = trackDetails.fragments;
            var fragLen = fragments.length;
            var end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration;

            if (bufferLen > maxConfigBuffer) {
              return;
            }

            var foundFrag = void 0;
            var fragPrevious = this.fragPrevious;
            if (bufferEnd < end) {
              if (fragPrevious && trackDetails.hasProgramDateTime) {
                foundFrag = (0, _fragmentFinders.findFragmentByPDT)(fragments, fragPrevious.endProgramDateTime, maxFragLookUpTolerance);
              }
              if (!foundFrag) {
                foundFrag = (0, _fragmentFinders.findFragmentByPTS)(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance);
              }
            } else {
              foundFrag = fragments[fragLen - 1];
            }

            if (foundFrag && foundFrag.encrypted) {
              _logger.logger.log('Loading key for ' + foundFrag.sn);
              this.state = _baseStreamController.State.KEY_LOADING;
              this.hls.trigger(_events2.default.KEY_LOADING, { frag: foundFrag });
            } else if (foundFrag && fragmentTracker.getState(foundFrag) === _fragmentTracker.FragmentState.NOT_LOADED) {
              // only load if fragment is not loaded
              this.fragCurrent = foundFrag;
              this.state = _baseStreamController.State.FRAG_LOADING;
              this.hls.trigger(_events2.default.FRAG_LOADING, { frag: foundFrag });
            }
          }
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.lastAVStart = 0;
      _get(SubtitleStreamController.prototype.__proto__ || Object.getPrototypeOf(SubtitleStreamController.prototype), 'stopLoad', this).call(this);
    }
  }, {
    key: '_getBuffered',
    value: function _getBuffered() {
      return this.tracksBuffered[this.currentTrackId] || [];
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      this.fragPrevious = null;
    }
  }]);

  return SubtitleStreamController;
}(_baseStreamController2.default);

/***/ }),

/***/ "./src/hls.js/controller/subtitle-track-controller.js":
/*!************************************************************!*\
  !*** ./src/hls.js/controller/subtitle-track-controller.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SubtitleTrackController = function (_EventHandler) {
  _inherits(SubtitleTrackController, _EventHandler);

  function SubtitleTrackController(hls) {
    _classCallCheck(this, SubtitleTrackController);

    var _this = _possibleConstructorReturn(this, (SubtitleTrackController.__proto__ || Object.getPrototypeOf(SubtitleTrackController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADED, _events2.default.SUBTITLE_TRACK_LOADED));

    _this.tracks = [];
    _this.trackId = -1;
    _this.media = null;
    _this.stopped = true;

    /**
     * @member {boolean} subtitleDisplay Enable/disable subtitle display rendering
     */
    _this.subtitleDisplay = true;
    return _this;
  }

  _createClass(SubtitleTrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }

    // Listen for subtitle track change, then extract the current track ID.

  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var _this2 = this;

      this.media = data.media;
      if (!this.media) {
        return;
      }

      if (this.queuedDefaultTrack) {
        this.subtitleTrack = this.queuedDefaultTrack;
        delete this.queuedDefaultTrack;
      }

      this.trackChangeListener = this._onTextTracksChanged.bind(this);

      this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);
      if (this.useTextTrackPolling) {
        this.subtitlePollingInterval = setInterval(function () {
          _this2.trackChangeListener();
        }, 500);
      } else {
        this.media.textTracks.addEventListener('change', this.trackChangeListener);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      if (!this.media) {
        return;
      }

      if (this.useTextTrackPolling) {
        clearInterval(this.subtitlePollingInterval);
      } else {
        this.media.textTracks.removeEventListener('change', this.trackChangeListener);
      }

      this.media = null;
    }

    // Fired whenever a new manifest is loaded.

  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this3 = this;

      var tracks = data.subtitles || [];
      this.tracks = tracks;
      this.hls.trigger(_events2.default.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: tracks });

      // loop through available subtitle tracks and autoselect default if needed
      // TODO: improve selection logic to handle forced, etc
      tracks.forEach(function (track) {
        if (track.default) {
          // setting this.subtitleTrack will trigger internal logic
          // if media has not been attached yet, it will fail
          // we keep a reference to the default track id
          // and we'll set subtitleTrack when onMediaAttached is triggered
          if (_this3.media) {
            _this3.subtitleTrack = track.id;
          } else {
            _this3.queuedDefaultTrack = track.id;
          }
        }
      });
    }
  }, {
    key: 'onSubtitleTrackLoaded',
    value: function onSubtitleTrackLoaded(data) {
      var _this4 = this;

      var id = data.id,
          details = data.details;
      var trackId = this.trackId,
          tracks = this.tracks;

      var currentTrack = tracks[trackId];
      if (id >= tracks.length || id !== trackId || !currentTrack || this.stopped) {
        this._clearReloadTimer();
        return;
      }

      _logger.logger.log('subtitle track ' + id + ' loaded');
      if (details.live) {
        var reloadInterval = (0, _levelHelper.computeReloadInterval)(currentTrack.details, details, data.stats.trequest);
        _logger.logger.log('Reloading live subtitle playlist in ' + reloadInterval + 'ms');
        this.timer = setTimeout(function () {
          _this4._loadCurrentTrack();
        }, reloadInterval);
      } else {
        this._clearReloadTimer();
      }
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      this.stopped = false;
      this._loadCurrentTrack();
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.stopped = true;
      this._clearReloadTimer();
    }

    /** get alternate subtitle tracks list from playlist **/

  }, {
    key: '_clearReloadTimer',
    value: function _clearReloadTimer() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    }
  }, {
    key: '_loadCurrentTrack',
    value: function _loadCurrentTrack() {
      var trackId = this.trackId,
          tracks = this.tracks,
          hls = this.hls;

      var currentTrack = tracks[trackId];
      if (trackId < 0 || !currentTrack || currentTrack.details && !currentTrack.details.live) {
        return;
      }
      _logger.logger.log('Loading subtitle track ' + trackId);
      hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: currentTrack.url, id: trackId });
    }

    /**
     * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.
     * This operates on the DOM textTracks.
     * A value of -1 will disable all subtitle tracks.
     * @param newId - The id of the next track to enable
     * @private
     */

  }, {
    key: '_toggleTrackModes',
    value: function _toggleTrackModes(newId) {
      var media = this.media,
          subtitleDisplay = this.subtitleDisplay,
          trackId = this.trackId;

      if (!media) {
        return;
      }

      var textTracks = filterSubtitleTracks(media.textTracks);
      if (newId === -1) {
        [].slice.call(textTracks).forEach(function (track) {
          track.mode = 'disabled';
        });
      } else {
        var oldTrack = textTracks[trackId];
        if (oldTrack) {
          oldTrack.mode = 'disabled';
        }
      }

      var nextTrack = textTracks[newId];
      if (nextTrack) {
        nextTrack.mode = subtitleDisplay ? 'showing' : 'hidden';
      }
    }

    /**
       * This method is responsible for validating the subtitle index and periodically reloading if live.
       * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.
       * @param newId - The id of the subtitle track to activate.
       */

  }, {
    key: '_setSubtitleTrackInternal',
    value: function _setSubtitleTrackInternal(newId) {
      var hls = this.hls,
          tracks = this.tracks;

      if (!Number.isFinite(newId) || newId < -1 || newId >= tracks.length) {
        return;
      }

      this.trackId = newId;
      _logger.logger.log('Switching to subtitle track ' + newId);
      hls.trigger(_events2.default.SUBTITLE_TRACK_SWITCH, { id: newId });
      this._loadCurrentTrack();
    }
  }, {
    key: '_onTextTracksChanged',
    value: function _onTextTracksChanged() {
      // Media is undefined when switching streams via loadSource()
      if (!this.media) {
        return;
      }

      var trackId = -1;
      var tracks = filterSubtitleTracks(this.media.textTracks);
      for (var id = 0; id < tracks.length; id++) {
        if (tracks[id].mode === 'hidden') {
          // Do not break in case there is a following track with showing.
          trackId = id;
        } else if (tracks[id].mode === 'showing') {
          trackId = id;
          break;
        }
      }

      // Setting current subtitleTrack will invoke code.
      this.subtitleTrack = trackId;
    }
  }, {
    key: 'subtitleTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected subtitle track (index in subtitle track lists) **/

  }, {
    key: 'subtitleTrack',
    get: function get() {
      return this.trackId;
    }

    /** select a subtitle track, based on its index in subtitle track lists**/
    ,
    set: function set(subtitleTrackId) {
      if (this.trackId !== subtitleTrackId) {
        this._toggleTrackModes(subtitleTrackId);
        this._setSubtitleTrackInternal(subtitleTrackId);
      }
    }
  }]);

  return SubtitleTrackController;
}(_eventHandler2.default);

function filterSubtitleTracks(textTrackList) {
  var tracks = [];
  for (var i = 0; i < textTrackList.length; i++) {
    var track = textTrackList[i];
    // Edge adds a track without a label; we don't want to use it
    if (track.kind === 'subtitles' && track.label) {
      tracks.push(textTrackList[i]);
    }
  }
  return tracks;
}

exports.default = SubtitleTrackController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/timeline-controller.js":
/*!******************************************************!*\
  !*** ./src/hls.js/controller/timeline-controller.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _cea608Parser = __webpack_require__(/*! ../utils/cea-608-parser */ "./src/hls.js/utils/cea-608-parser.js");

var _cea608Parser2 = _interopRequireDefault(_cea608Parser);

var _outputFilter = __webpack_require__(/*! ../utils/output-filter */ "./src/hls.js/utils/output-filter.js");

var _outputFilter2 = _interopRequireDefault(_outputFilter);

var _webvttParser = __webpack_require__(/*! ../utils/webvtt-parser */ "./src/hls.js/utils/webvtt-parser.js");

var _webvttParser2 = _interopRequireDefault(_webvttParser);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _texttrackUtils = __webpack_require__(/*! ../utils/texttrack-utils */ "./src/hls.js/utils/texttrack-utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Timeline Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

function canReuseVttTextTrack(inUseTrack, manifestTrack) {
  return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
}

function intersection(x1, x2, y1, y2) {
  return Math.min(x2, y2) - Math.max(x1, y1);
}

var TimelineController = function (_EventHandler) {
  _inherits(TimelineController, _EventHandler);

  function TimelineController(hls) {
    _classCallCheck(this, TimelineController);

    var _this = _possibleConstructorReturn(this, (TimelineController.__proto__ || Object.getPrototypeOf(TimelineController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_USERDATA, _events2.default.FRAG_DECRYPTED, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.FRAG_LOADED, _events2.default.LEVEL_SWITCHING, _events2.default.INIT_PTS_FOUND));

    _this.hls = hls;
    _this.config = hls.config;
    _this.enabled = true;
    _this.Cues = hls.config.cueHandler;
    _this.textTracks = [];
    _this.tracks = [];
    _this.unparsedVttFrags = [];
    _this.initPTS = [];
    _this.cueRanges = [];
    _this.captionsTracks = {};

    _this.captionsProperties = {
      textTrack1: {
        label: _this.config.captionsTextTrack1Label,
        languageCode: _this.config.captionsTextTrack1LanguageCode
      },
      textTrack2: {
        label: _this.config.captionsTextTrack2Label,
        languageCode: _this.config.captionsTextTrack2LanguageCode
      }
    };

    if (_this.config.enableCEA708Captions) {
      var channel1 = new _outputFilter2.default(_this, 'textTrack1');
      var channel2 = new _outputFilter2.default(_this, 'textTrack2');

      _this.cea608Parser = new _cea608Parser2.default(0, channel1, channel2);
    }
    return _this;
  }

  _createClass(TimelineController, [{
    key: 'addCues',
    value: function addCues(trackName, startTime, endTime, screen) {
      // skip cues which overlap more than 50% with previously parsed time ranges
      var ranges = this.cueRanges;
      var merged = false;
      for (var i = ranges.length; i--;) {
        var cueRange = ranges[i];
        var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
        if (overlap >= 0) {
          cueRange[0] = Math.min(cueRange[0], startTime);
          cueRange[1] = Math.max(cueRange[1], endTime);
          merged = true;
          if (overlap / (endTime - startTime) > 0.5) {
            return;
          }
        }
      }
      if (!merged) {
        ranges.push([startTime, endTime]);
      }

      this.Cues.newCue(this.captionsTracks[trackName], startTime, endTime, screen);
    }

    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.

  }, {
    key: 'onInitPtsFound',
    value: function onInitPtsFound(data) {
      var _this2 = this;

      if (data.id === 'main') {
        this.initPTS[data.frag.cc] = data.initPTS;
      }

      // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.
      // Parse any unparsed fragments upon receiving the initial PTS.
      if (this.unparsedVttFrags.length) {
        var unparsedVttFrags = this.unparsedVttFrags;
        this.unparsedVttFrags = [];
        unparsedVttFrags.forEach(function (frag) {
          _this2.onFragLoaded(frag);
        });
      }
    }
  }, {
    key: 'getExistingTrack',
    value: function getExistingTrack(trackName) {
      var media = this.media;

      if (media) {
        for (var i = 0; i < media.textTracks.length; i++) {
          var textTrack = media.textTracks[i];
          if (textTrack[trackName]) {
            return textTrack;
          }
        }
      }
      return null;
    }
  }, {
    key: 'createCaptionsTrack',
    value: function createCaptionsTrack(trackName) {
      var _captionsProperties$t = this.captionsProperties[trackName],
          label = _captionsProperties$t.label,
          languageCode = _captionsProperties$t.languageCode;

      var captionsTracks = this.captionsTracks;
      if (!captionsTracks[trackName]) {
        // Enable reuse of existing text track.
        var existingTrack = this.getExistingTrack(trackName);
        if (!existingTrack) {
          var textTrack = this.createTextTrack('captions', label, languageCode);
          if (textTrack) {
            // Set a special property on the track so we know it's managed by Hls.js
            textTrack[trackName] = true;
            captionsTracks[trackName] = textTrack;
          }
        } else {
          captionsTracks[trackName] = existingTrack;
          (0, _texttrackUtils.clearCurrentCues)(captionsTracks[trackName]);
          (0, _texttrackUtils.sendAddTrackEvent)(captionsTracks[trackName], this.media);
        }
      }
    }
  }, {
    key: 'createTextTrack',
    value: function createTextTrack(kind, label, lang) {
      var media = this.media;
      if (media) {
        return media.addTextTrack(kind, label, lang);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media;
      this._cleanTracks();
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var captionsTracks = this.captionsTracks;

      Object.keys(captionsTracks).forEach(function (trackName) {
        (0, _texttrackUtils.clearCurrentCues)(captionsTracks[trackName]);
        delete captionsTracks[trackName];
      });
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.lastSn = -1; // Detect discontiguity in fragment parsing
      this.prevCC = -1;
      this.vttCCs = { // Detect discontinuity in subtitle manifests
        ccOffset: 0,
        presentationOffset: 0,
        0: {
          start: 0, prevCC: -1, new: false
        }
      };
      this._cleanTracks();
    }
  }, {
    key: '_cleanTracks',
    value: function _cleanTracks() {
      // clear outdated subtitles
      var media = this.media;
      if (media) {
        var textTracks = media.textTracks;
        if (textTracks) {
          for (var i = 0; i < textTracks.length; i++) {
            (0, _texttrackUtils.clearCurrentCues)(textTracks[i]);
          }
        }
      }
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this3 = this;

      this.textTracks = [];
      this.unparsedVttFrags = this.unparsedVttFrags || [];
      this.initPTS = [];
      this.cueRanges = [];

      if (this.config.enableWebVTT) {
        this.tracks = data.subtitles || [];
        var inUseTracks = this.media ? this.media.textTracks : [];

        this.tracks.forEach(function (track, index) {
          var textTrack = void 0;
          if (index < inUseTracks.length) {
            var inUseTrack = null;

            for (var i = 0; i < inUseTracks.length; i++) {
              if (canReuseVttTextTrack(inUseTracks[i], track)) {
                inUseTrack = inUseTracks[i];
                break;
              }
            }

            // Reuse tracks with the same label, but do not reuse 608/708 tracks
            if (inUseTrack) {
              textTrack = inUseTrack;
            }
          }
          if (!textTrack) {
            textTrack = _this3.createTextTrack('subtitles', track.name, track.lang);
          }

          if (track.default) {
            textTrack.mode = _this3.hls.subtitleDisplay ? 'showing' : 'hidden';
          } else {
            textTrack.mode = 'disabled';
          }

          _this3.textTracks.push(textTrack);
        });
      }
    }
  }, {
    key: 'onLevelSwitching',
    value: function onLevelSwitching() {
      this.enabled = this.hls.currentLevel.closedCaptions !== 'NONE';
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var frag = data.frag,
          payload = data.payload;
      if (frag.type === 'main') {
        var sn = frag.sn;
        // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack
        if (sn !== this.lastSn + 1) {
          var cea608Parser = this.cea608Parser;
          if (cea608Parser) {
            cea608Parser.reset();
          }
        }
        this.lastSn = sn;
      } // eslint-disable-line brace-style
      // If fragment is subtitle type, parse as WebVTT.
      else if (frag.type === 'subtitle') {
          if (payload.byteLength) {
            // We need an initial synchronisation PTS. Store fragments as long as none has arrived.
            if (!Number.isFinite(this.initPTS[frag.cc])) {
              this.unparsedVttFrags.push(data);
              if (this.initPTS.length) {
                // finish unsuccessfully, otherwise the subtitle-stream-controller could be blocked from loading new frags.
                this.hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
              }
              return;
            }

            var decryptData = frag.decryptdata;
            // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.
            if (decryptData == null || decryptData.key == null || decryptData.method !== 'AES-128') {
              this._parseVTTs(frag, payload);
            }
          } else {
            // In case there is no payload, finish unsuccessfully.
            this.hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
          }
        }
    }
  }, {
    key: '_parseVTTs',
    value: function _parseVTTs(frag, payload) {
      var vttCCs = this.vttCCs;
      if (!vttCCs[frag.cc]) {
        vttCCs[frag.cc] = { start: frag.start, prevCC: this.prevCC, new: true };
        this.prevCC = frag.cc;
      }
      var textTracks = this.textTracks,
          hls = this.hls;

      // Parse the WebVTT file contents.
      _webvttParser2.default.parse(payload, this.initPTS[frag.cc], vttCCs, frag.cc, function (cues) {
        var currentTrack = textTracks[frag.levels];
        // WebVTTParser.parse is an async method and if the currently selected text track mode is set to "disabled"
        // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null
        // and trying to access getCueById method of cues will throw an exception
        if (currentTrack.mode === 'disabled') {
          hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
          return;
        }
        // Add cues and trigger event with success true.
        cues.forEach(function (cue) {
          // Sometimes there are cue overlaps on segmented vtts so the same
          // cue can appear more than once in different vtt files.
          // This avoid showing duplicated cues with same timecode and text.
          if (!currentTrack.cues.getCueById(cue.id)) {
            try {
              currentTrack.addCue(cue);
            } catch (err) {
              var textTrackCue = new window.TextTrackCue(cue.startTime, cue.endTime, cue.text);
              textTrackCue.id = cue.id;
              currentTrack.addCue(textTrackCue);
            }
          }
        });
        hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: true, frag: frag });
      }, function (e) {
        // Something went wrong while parsing. Trigger event with success false.
        _logger.logger.log('Failed to parse VTT cue: ' + e);
        hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
      });
    }
  }, {
    key: 'onFragDecrypted',
    value: function onFragDecrypted(data) {
      var decryptedData = data.payload,
          frag = data.frag;

      if (frag.type === 'subtitle') {
        if (!Number.isFinite(this.initPTS[frag.cc])) {
          this.unparsedVttFrags.push(data);
          return;
        }

        this._parseVTTs(frag, decryptedData);
      }
    }
  }, {
    key: 'onFragParsingUserdata',
    value: function onFragParsingUserdata(data) {
      // push all of the CEA-708 messages into the interpreter
      // immediately. It will create the proper timestamps based on our PTS value
      if (this.enabled && this.config.enableCEA708Captions) {
        for (var i = 0; i < data.samples.length; i++) {
          var ccdatas = this.extractCea608Data(data.samples[i].bytes);
          this.cea608Parser.addData(data.samples[i].pts, ccdatas);
        }
      }
    }
  }, {
    key: 'extractCea608Data',
    value: function extractCea608Data(byteArray) {
      var count = byteArray[0] & 31;
      var position = 2;
      var tmpByte = void 0,
          ccbyte1 = void 0,
          ccbyte2 = void 0,
          ccValid = void 0,
          ccType = void 0;
      var actualCCBytes = [];

      for (var j = 0; j < count; j++) {
        tmpByte = byteArray[position++];
        ccbyte1 = 0x7F & byteArray[position++];
        ccbyte2 = 0x7F & byteArray[position++];
        ccValid = (4 & tmpByte) !== 0;
        ccType = 3 & tmpByte;

        if (ccbyte1 === 0 && ccbyte2 === 0) {
          continue;
        }

        if (ccValid) {
          if (ccType === 0) {
            // || ccType === 1
            actualCCBytes.push(ccbyte1);
            actualCCBytes.push(ccbyte2);
          }
        }
      }
      return actualCCBytes;
    }
  }]);

  return TimelineController;
}(_eventHandler2.default);

exports.default = TimelineController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/crypt/aes-crypto.js":
/*!****************************************!*\
  !*** ./src/hls.js/crypt/aes-crypto.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AESCrypto = function () {
  function AESCrypto(subtle, iv) {
    _classCallCheck(this, AESCrypto);

    this.subtle = subtle;
    this.aesIV = iv;
  }

  _createClass(AESCrypto, [{
    key: 'decrypt',
    value: function decrypt(data, key) {
      return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);
    }
  }]);

  return AESCrypto;
}();

exports.default = AESCrypto;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/crypt/aes-decryptor.js":
/*!*******************************************!*\
  !*** ./src/hls.js/crypt/aes-decryptor.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.removePadding = removePadding;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// PKCS7
function removePadding(buffer) {
  var outputBytes = buffer.byteLength;
  var paddingBytes = outputBytes && new DataView(buffer).getUint8(outputBytes - 1);
  if (paddingBytes) {
    return buffer.slice(0, outputBytes - paddingBytes);
  } else {
    return buffer;
  }
}

var AESDecryptor = function () {
  function AESDecryptor() {
    _classCallCheck(this, AESDecryptor);

    // Static after running initTable
    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.sBox = new Uint32Array(256);
    this.invSBox = new Uint32Array(256);

    // Changes during runtime
    this.key = new Uint32Array(0);

    this.initTable();
  }

  // Using view.getUint32() also swaps the byte order.


  _createClass(AESDecryptor, [{
    key: 'uint8ArrayToUint32Array_',
    value: function uint8ArrayToUint32Array_(arrayBuffer) {
      var view = new DataView(arrayBuffer);
      var newArray = new Uint32Array(4);
      for (var i = 0; i < 4; i++) {
        newArray[i] = view.getUint32(i * 4);
      }

      return newArray;
    }
  }, {
    key: 'initTable',
    value: function initTable() {
      var sBox = this.sBox;
      var invSBox = this.invSBox;
      var subMix = this.subMix;
      var subMix0 = subMix[0];
      var subMix1 = subMix[1];
      var subMix2 = subMix[2];
      var subMix3 = subMix[3];
      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var d = new Uint32Array(256);
      var x = 0;
      var xi = 0;
      var i = 0;
      for (i = 0; i < 256; i++) {
        if (i < 128) {
          d[i] = i << 1;
        } else {
          d[i] = i << 1 ^ 0x11b;
        }
      }

      for (i = 0; i < 256; i++) {
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        sBox[x] = sx;
        invSBox[sx] = x;

        // Compute multiplication
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];

        // Compute sub/invSub bytes, mix columns tables
        var t = d[sx] * 0x101 ^ sx * 0x1010100;
        subMix0[x] = t << 24 | t >>> 8;
        subMix1[x] = t << 16 | t >>> 16;
        subMix2[x] = t << 8 | t >>> 24;
        subMix3[x] = t;

        // Compute inv sub bytes, inv mix columns tables
        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        invSubMix0[sx] = t << 24 | t >>> 8;
        invSubMix1[sx] = t << 16 | t >>> 16;
        invSubMix2[sx] = t << 8 | t >>> 24;
        invSubMix3[sx] = t;

        // Compute next counter
        if (!x) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
    }
  }, {
    key: 'expandKey',
    value: function expandKey(keyBuffer) {
      // convert keyBuffer to Uint32Array
      var key = this.uint8ArrayToUint32Array_(keyBuffer);
      var sameKey = true;
      var offset = 0;

      while (offset < key.length && sameKey) {
        sameKey = key[offset] === this.key[offset];
        offset++;
      }

      if (sameKey) {
        return;
      }

      this.key = key;
      var keySize = this.keySize = key.length;

      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
        throw new Error('Invalid aes key size=' + keySize);
      }

      var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
      var ksRow = void 0;
      var invKsRow = void 0;

      var keySchedule = this.keySchedule = new Uint32Array(ksRows);
      var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
      var sbox = this.sBox;
      var rcon = this.rcon;

      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var prev = void 0;
      var t = void 0;

      for (ksRow = 0; ksRow < ksRows; ksRow++) {
        if (ksRow < keySize) {
          prev = keySchedule[ksRow] = key[ksRow];
          continue;
        }
        t = prev;

        if (ksRow % keySize === 0) {
          // Rot word
          t = t << 8 | t >>> 24;

          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];

          // Mix Rcon
          t ^= rcon[ksRow / keySize | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
        }

        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
      }

      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        ksRow = ksRows - invKsRow;
        if (invKsRow & 3) {
          t = keySchedule[ksRow];
        } else {
          t = keySchedule[ksRow - 4];
        }

        if (invKsRow < 4 || ksRow <= 4) {
          invKeySchedule[invKsRow] = t;
        } else {
          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
        }

        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
      }
    }

    // Adding this as a method greatly improves performance.

  }, {
    key: 'networkToHostOrderSwap',
    value: function networkToHostOrderSwap(word) {
      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
    }
  }, {
    key: 'decrypt',
    value: function decrypt(inputArrayBuffer, offset, aesIV, removePKCS7Padding) {
      var nRounds = this.keySize + 6;
      var invKeySchedule = this.invKeySchedule;
      var invSBOX = this.invSBox;

      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var initVector = this.uint8ArrayToUint32Array_(aesIV);
      var initVector0 = initVector[0];
      var initVector1 = initVector[1];
      var initVector2 = initVector[2];
      var initVector3 = initVector[3];

      var inputInt32 = new Int32Array(inputArrayBuffer);
      var outputInt32 = new Int32Array(inputInt32.length);

      var t0 = void 0,
          t1 = void 0,
          t2 = void 0,
          t3 = void 0;
      var s0 = void 0,
          s1 = void 0,
          s2 = void 0,
          s3 = void 0;
      var inputWords0 = void 0,
          inputWords1 = void 0,
          inputWords2 = void 0,
          inputWords3 = void 0;

      var ksRow = void 0,
          i = void 0;
      var swapWord = this.networkToHostOrderSwap;

      while (offset < inputInt32.length) {
        inputWords0 = swapWord(inputInt32[offset]);
        inputWords1 = swapWord(inputInt32[offset + 1]);
        inputWords2 = swapWord(inputInt32[offset + 2]);
        inputWords3 = swapWord(inputInt32[offset + 3]);

        s0 = inputWords0 ^ invKeySchedule[0];
        s1 = inputWords3 ^ invKeySchedule[1];
        s2 = inputWords2 ^ invKeySchedule[2];
        s3 = inputWords1 ^ invKeySchedule[3];

        ksRow = 4;

        // Iterate through the rounds of decryption
        for (i = 1; i < nRounds; i++) {
          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
          // Update state
          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;

          ksRow = ksRow + 4;
        }

        // Shift rows, sub bytes, add round key
        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];
        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
        ksRow = ksRow + 3;

        // Write
        outputInt32[offset] = swapWord(t0 ^ initVector0);
        outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
        outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
        outputInt32[offset + 3] = swapWord(t1 ^ initVector3);

        // reset initVector to last 4 unsigned int
        initVector0 = inputWords0;
        initVector1 = inputWords1;
        initVector2 = inputWords2;
        initVector3 = inputWords3;

        offset = offset + 4;
      }

      return removePKCS7Padding ? removePadding(outputInt32.buffer) : outputInt32.buffer;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.key = undefined;
      this.keySize = undefined;
      this.ksRows = undefined;

      this.sBox = undefined;
      this.invSBox = undefined;
      this.subMix = undefined;
      this.invSubMix = undefined;
      this.keySchedule = undefined;
      this.invKeySchedule = undefined;

      this.rcon = undefined;
    }
  }]);

  return AESDecryptor;
}();

exports.default = AESDecryptor;

/***/ }),

/***/ "./src/hls.js/crypt/decrypter.js":
/*!***************************************!*\
  !*** ./src/hls.js/crypt/decrypter.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _aesCrypto = __webpack_require__(/*! ./aes-crypto */ "./src/hls.js/crypt/aes-crypto.js");

var _aesCrypto2 = _interopRequireDefault(_aesCrypto);

var _fastAesKey = __webpack_require__(/*! ./fast-aes-key */ "./src/hls.js/crypt/fast-aes-key.js");

var _fastAesKey2 = _interopRequireDefault(_fastAesKey);

var _aesDecryptor = __webpack_require__(/*! ./aes-decryptor */ "./src/hls.js/crypt/aes-decryptor.js");

var _aesDecryptor2 = _interopRequireDefault(_aesDecryptor);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _getSelfScope = __webpack_require__(/*! ../utils/get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// see https://stackoverflow.com/a/11237259/589493
var global = (0, _getSelfScope.getSelfScope)(); // safeguard for code that might run both on worker and main thread

var Decrypter = function () {
  function Decrypter(observer, config) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$removePKCS7Paddi = _ref.removePKCS7Padding,
        removePKCS7Padding = _ref$removePKCS7Paddi === undefined ? true : _ref$removePKCS7Paddi;

    _classCallCheck(this, Decrypter);

    this.logEnabled = true;
    this.observer = observer;
    this.config = config;
    this.removePKCS7Padding = removePKCS7Padding;
    // built in decryptor expects PKCS7 padding
    if (removePKCS7Padding) {
      try {
        var browserCrypto = global.crypto;
        if (browserCrypto) {
          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
        }
      } catch (e) {}
    }
    this.disableWebCrypto = !this.subtle;
  }

  _createClass(Decrypter, [{
    key: 'isSync',
    value: function isSync() {
      return this.disableWebCrypto && this.config.enableSoftwareAES;
    }
  }, {
    key: 'decrypt',
    value: function decrypt(data, key, iv, callback) {
      var _this = this;

      if (this.disableWebCrypto && this.config.enableSoftwareAES) {
        if (this.logEnabled) {
          _logger.logger.log('JS AES decrypt');
          this.logEnabled = false;
        }
        var decryptor = this.decryptor;
        if (!decryptor) {
          this.decryptor = decryptor = new _aesDecryptor2.default();
        }

        decryptor.expandKey(key);
        callback(decryptor.decrypt(data, 0, iv, this.removePKCS7Padding));
      } else {
        if (this.logEnabled) {
          _logger.logger.log('WebCrypto AES decrypt');
          this.logEnabled = false;
        }
        var subtle = this.subtle;
        if (this.key !== key) {
          this.key = key;
          this.fastAesKey = new _fastAesKey2.default(subtle, key);
        }

        this.fastAesKey.expandKey().then(function (aesKey) {
          // decrypt using web crypto
          var crypto = new _aesCrypto2.default(subtle, iv);
          crypto.decrypt(data, aesKey).catch(function (err) {
            _this.onWebCryptoError(err, data, key, iv, callback);
          }).then(function (result) {
            callback(result);
          });
        }).catch(function (err) {
          _this.onWebCryptoError(err, data, key, iv, callback);
        });
      }
    }
  }, {
    key: 'onWebCryptoError',
    value: function onWebCryptoError(err, data, key, iv, callback) {
      if (this.config.enableSoftwareAES) {
        _logger.logger.log('WebCrypto Error, disable WebCrypto API');
        this.disableWebCrypto = true;
        this.logEnabled = true;
        this.decrypt(data, key, iv, callback);
      } else {
        _logger.logger.error('decrypting error : ' + err.message);
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var decryptor = this.decryptor;
      if (decryptor) {
        decryptor.destroy();
        this.decryptor = undefined;
      }
    }
  }]);

  return Decrypter;
}();

exports.default = Decrypter;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/crypt/fast-aes-key.js":
/*!******************************************!*\
  !*** ./src/hls.js/crypt/fast-aes-key.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FastAESKey = function () {
  function FastAESKey(subtle, key) {
    _classCallCheck(this, FastAESKey);

    this.subtle = subtle;
    this.key = key;
  }

  _createClass(FastAESKey, [{
    key: 'expandKey',
    value: function expandKey() {
      return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);
    }
  }]);

  return FastAESKey;
}();

exports.default = FastAESKey;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/aacdemuxer.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/aacdemuxer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AAC demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _adts = __webpack_require__(/*! ./adts */ "./src/hls.js/demux/adts.js");

var ADTS = _interopRequireWildcard(_adts);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _id = __webpack_require__(/*! ../demux/id3 */ "./src/hls.js/demux/id3.js");

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AACDemuxer = function () {
  function AACDemuxer(observer, remuxer, config) {
    _classCallCheck(this, AACDemuxer);

    this.observer = observer;
    this.config = config;
    this.remuxer = remuxer;
  }

  _createClass(AACDemuxer, [{
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this._audioTrack = { container: 'audio/adts', type: 'audio', id: 0, sequenceNumber: 0, isAAC: true, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
    }
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var track = this._audioTrack;
      var id3Data = _id2.default.getID3Data(data, 0) || [];
      var timestamp = _id2.default.getTimeStamp(id3Data);
      var pts = Number.isFinite(timestamp) ? timestamp * 90 : timeOffset * 90000;
      var frameIndex = 0;
      var stamp = pts;
      var length = data.length;
      var offset = id3Data.length;

      var id3Samples = [{ pts: stamp, dts: stamp, data: id3Data }];

      while (offset < length - 1) {
        if (ADTS.isHeader(data, offset) && offset + 5 < length) {
          ADTS.initTrackConfig(track, this.observer, data, offset, track.manifestCodec);
          var frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);
          if (frame) {
            offset += frame.length;
            stamp = frame.sample.pts;
            frameIndex++;
          } else {
            _logger.logger.log('Unable to parse AAC frame');
            break;
          }
        } else if (_id2.default.isHeader(data, offset)) {
          id3Data = _id2.default.getID3Data(data, offset);
          id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });
          offset += id3Data.length;
        } else {
          // nothing found, keep looking
          offset++;
        }
      }

      this.remuxer.remux(track, { samples: [] }, { samples: id3Samples, inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      if (!data) {
        return false;
      }

      // Check for the ADTS sync word
      // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
      // Layer bits (position 14 and 15) in header should be always 0 for ADTS
      // More info https://wiki.multimedia.cx/index.php?title=ADTS
      var id3Data = _id2.default.getID3Data(data, 0) || [];
      var offset = id3Data.length;

      for (var length = data.length; offset < length; offset++) {
        if (ADTS.probe(data, offset)) {
          _logger.logger.log('ADTS sync word found !');
          return true;
        }
      }
      return false;
    }
  }]);

  return AACDemuxer;
}();

exports.default = AACDemuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/adts.js":
/*!**********************************!*\
  !*** ./src/hls.js/demux/adts.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAudioConfig = getAudioConfig;
exports.isHeaderPattern = isHeaderPattern;
exports.getHeaderLength = getHeaderLength;
exports.getFullFrameLength = getFullFrameLength;
exports.isHeader = isHeader;
exports.probe = probe;
exports.initTrackConfig = initTrackConfig;
exports.getFrameDuration = getFrameDuration;
exports.parseFrameHeader = parseFrameHeader;
exports.appendFrame = appendFrame;

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _getSelfScope = __webpack_require__(/*! ../utils/get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *  ADTS parser helper
 */
function getAudioConfig(observer, data, offset, audioCodec) {
  var adtsObjectType = void 0,
      // :int
  adtsSampleingIndex = void 0,
      // :int
  adtsExtensionSampleingIndex = void 0,
      // :int
  adtsChanelConfig = void 0,
      // :int
  config = void 0,
      userAgent = navigator.userAgent.toLowerCase(),
      manifestCodec = audioCodec,
      adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
  // byte 2
  adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;
  adtsSampleingIndex = (data[offset + 2] & 0x3C) >>> 2;
  if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
    observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'invalid ADTS sampling index:' + adtsSampleingIndex });
    return;
  }
  adtsChanelConfig = (data[offset + 2] & 0x01) << 2;
  // byte 3
  adtsChanelConfig |= (data[offset + 3] & 0xC0) >>> 6;
  _logger.logger.log('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);
  // firefox: freq less than 24kHz = AAC SBR (HE-AAC)
  if (/firefox/i.test(userAgent)) {
    if (adtsSampleingIndex >= 6) {
      adtsObjectType = 5;
      config = new Array(4);
      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
      // there is a factor 2 between frame sample rate and output sample rate
      // multiply frequency by 2 (see table below, equivalent to substract 3)
      adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
    } else {
      adtsObjectType = 2;
      config = new Array(2);
      adtsExtensionSampleingIndex = adtsSampleingIndex;
    }
    // Android : always use AAC
  } else if (userAgent.indexOf('android') !== -1) {
    adtsObjectType = 2;
    config = new Array(2);
    adtsExtensionSampleingIndex = adtsSampleingIndex;
  } else {
    /*  for other browsers (Chrome/Vivaldi/Opera ...)
        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
    */
    adtsObjectType = 5;
    config = new Array(4);
    // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
    if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {
      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
      // there is a factor 2 between frame sample rate and output sample rate
      // multiply frequency by 2 (see table below, equivalent to substract 3)
      adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
    } else {
      // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
      // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
      if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChanelConfig === 1) {
        adtsObjectType = 2;
        config = new Array(2);
      }
      adtsExtensionSampleingIndex = adtsSampleingIndex;
    }
  }
  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
      ISO 14496-3 (AAC).pdf - Table 1.13 — Syntax of AudioSpecificConfig()
    Audio Profile / Audio Object Type
    0: Null
    1: AAC Main
    2: AAC LC (Low Complexity)
    3: AAC SSR (Scalable Sample Rate)
    4: AAC LTP (Long Term Prediction)
    5: SBR (Spectral Band Replication)
    6: AAC Scalable
   sampling freq
    0: 96000 Hz
    1: 88200 Hz
    2: 64000 Hz
    3: 48000 Hz
    4: 44100 Hz
    5: 32000 Hz
    6: 24000 Hz
    7: 22050 Hz
    8: 16000 Hz
    9: 12000 Hz
    10: 11025 Hz
    11: 8000 Hz
    12: 7350 Hz
    13: Reserved
    14: Reserved
    15: frequency is written explictly
    Channel Configurations
    These are the channel configurations:
    0: Defined in AOT Specifc Config
    1: 1 channel: front-center
    2: 2 channels: front-left, front-right
  */
  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
  config[0] = adtsObjectType << 3;
  // samplingFrequencyIndex
  config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
  config[1] |= (adtsSampleingIndex & 0x01) << 7;
  // channelConfiguration
  config[1] |= adtsChanelConfig << 3;
  if (adtsObjectType === 5) {
    // adtsExtensionSampleingIndex
    config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
    config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;
    // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
    //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
    config[2] |= 2 << 2;
    config[3] = 0;
  }
  return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: 'mp4a.40.' + adtsObjectType, manifestCodec: manifestCodec };
}

function isHeaderPattern(data, offset) {
  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;
}

function getHeaderLength(data, offset) {
  return data[offset + 1] & 0x01 ? 7 : 9;
}

function getFullFrameLength(data, offset) {
  return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
}

function isHeader(data, offset) {
  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
  // Layer bits (position 14 and 15) in header should be always 0 for ADTS
  // More info https://wiki.multimedia.cx/index.php?title=ADTS
  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
    return true;
  }

  return false;
}

function probe(data, offset) {
  // same as isHeader but we also check that ADTS frame follows last ADTS frame
  // or end of data is reached
  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
    // ADTS header Length
    var headerLength = getHeaderLength(data, offset);
    // ADTS frame Length
    var frameLength = headerLength;
    if (offset + 5 < data.length) {
      frameLength = getFullFrameLength(data, offset);
    }

    var newOffset = offset + frameLength;
    if (newOffset === data.length || newOffset + 1 < data.length && isHeaderPattern(data, newOffset)) {
      return true;
    }
  }
  return false;
}

function initTrackConfig(track, observer, data, offset, audioCodec) {
  if (!track.samplerate) {
    var config = getAudioConfig(observer, data, offset, audioCodec);
    track.config = config.config;
    track.samplerate = config.samplerate;
    track.channelCount = config.channelCount;
    track.codec = config.codec;
    track.manifestCodec = config.manifestCodec;
    _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
  }
}

function getFrameDuration(samplerate) {
  return 1024 * 90000 / samplerate;
}

function parseFrameHeader(data, offset, pts, frameIndex, frameDuration) {
  var headerLength = void 0,
      frameLength = void 0,
      stamp = void 0;
  var length = data.length;

  // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
  headerLength = getHeaderLength(data, offset);
  // retrieve frame size
  frameLength = getFullFrameLength(data, offset);
  frameLength -= headerLength;

  if (frameLength > 0 && offset + headerLength + frameLength <= length) {
    stamp = pts + frameIndex * frameDuration;
    // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
    return { headerLength: headerLength, frameLength: frameLength, stamp: stamp };
  }

  return undefined;
}

function appendFrame(track, data, offset, pts, frameIndex) {
  var frameDuration = getFrameDuration(track.samplerate);
  var header = parseFrameHeader(data, offset, pts, frameIndex, frameDuration);
  if (header) {
    var stamp = header.stamp;
    var headerLength = header.headerLength;
    var frameLength = header.frameLength;

    // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
    var aacSample = {
      unit: data.subarray(offset + headerLength, offset + headerLength + frameLength),
      pts: stamp,
      dts: stamp
    };

    track.samples.push(aacSample);
    track.len += frameLength;

    return { sample: aacSample, length: frameLength + headerLength };
  }

  return undefined;
}

/***/ }),

/***/ "./src/hls.js/demux/demuxer-inline.js":
/*!********************************************!*\
  !*** ./src/hls.js/demux/demuxer-inline.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * inline demuxer: probe fragments and instantiate
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _decrypter = __webpack_require__(/*! ../crypt/decrypter */ "./src/hls.js/crypt/decrypter.js");

var _decrypter2 = _interopRequireDefault(_decrypter);

var _aacdemuxer = __webpack_require__(/*! ../demux/aacdemuxer */ "./src/hls.js/demux/aacdemuxer.js");

var _aacdemuxer2 = _interopRequireDefault(_aacdemuxer);

var _mp4demuxer = __webpack_require__(/*! ../demux/mp4demuxer */ "./src/hls.js/demux/mp4demuxer.js");

var _mp4demuxer2 = _interopRequireDefault(_mp4demuxer);

var _tsdemuxer = __webpack_require__(/*! ../demux/tsdemuxer */ "./src/hls.js/demux/tsdemuxer.js");

var _tsdemuxer2 = _interopRequireDefault(_tsdemuxer);

var _mp3demuxer = __webpack_require__(/*! ../demux/mp3demuxer */ "./src/hls.js/demux/mp3demuxer.js");

var _mp3demuxer2 = _interopRequireDefault(_mp3demuxer);

var _mp4Remuxer = __webpack_require__(/*! ../remux/mp4-remuxer */ "./src/hls.js/remux/mp4-remuxer.js");

var _mp4Remuxer2 = _interopRequireDefault(_mp4Remuxer);

var _passthroughRemuxer = __webpack_require__(/*! ../remux/passthrough-remuxer */ "./src/hls.js/remux/passthrough-remuxer.js");

var _passthroughRemuxer2 = _interopRequireDefault(_passthroughRemuxer);

var _getSelfScope = __webpack_require__(/*! ../utils/get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// see https://stackoverflow.com/a/11237259/589493
var global = (0, _getSelfScope.getSelfScope)(); // safeguard for code that might run both on worker and main thread

var now = void 0;
// performance.now() not available on WebWorker, at least on Safari Desktop
try {
  now = global.performance.now.bind(global.performance);
} catch (err) {
  _logger.logger.debug('Unable to use Performance API on this environment');
  now = global.Date.now;
}

var DemuxerInline = function () {
  function DemuxerInline(observer, typeSupported, config, vendor) {
    _classCallCheck(this, DemuxerInline);

    this.observer = observer;
    this.typeSupported = typeSupported;
    this.config = config;
    this.vendor = vendor;
  }

  _createClass(DemuxerInline, [{
    key: 'destroy',
    value: function destroy() {
      var demuxer = this.demuxer;
      if (demuxer) {
        demuxer.destroy();
      }
    }
  }, {
    key: 'push',
    value: function push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
      var _this = this;

      if (data.byteLength > 0 && decryptdata != null && decryptdata.key != null && decryptdata.method === 'AES-128') {
        var decrypter = this.decrypter;
        if (decrypter == null) {
          decrypter = this.decrypter = new _decrypter2.default(this.observer, this.config);
        }

        var startTime = now();
        decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function (decryptedData) {
          var endTime = now();
          _this.observer.trigger(_events2.default.FRAG_DECRYPTED, { stats: { tstart: startTime, tdecrypt: endTime } });
          _this.pushDecrypted(new Uint8Array(decryptedData), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
        });
      } else {
        this.pushDecrypted(new Uint8Array(data), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
      }
    }
  }, {
    key: 'pushDecrypted',
    value: function pushDecrypted(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
      var demuxer = this.demuxer;
      if (!demuxer ||
      // in case of continuity change, or track switch
      // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)
      // so let's check that current demuxer is still valid
      (discontinuity || trackSwitch) && !this.probe(data)) {
        var observer = this.observer;
        var typeSupported = this.typeSupported;
        var config = this.config;
        // probing order is TS/AAC/MP3/MP4
        var muxConfig = [{ demux: _tsdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _mp4demuxer2.default, remux: _passthroughRemuxer2.default }, { demux: _aacdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _mp3demuxer2.default, remux: _mp4Remuxer2.default }];

        // probe for content type
        for (var i = 0, len = muxConfig.length; i < len; i++) {
          var mux = muxConfig[i];
          var probe = mux.demux.probe;
          if (probe(data)) {
            var _remuxer = this.remuxer = new mux.remux(observer, config, typeSupported, this.vendor);
            demuxer = new mux.demux(observer, _remuxer, config, typeSupported);
            this.probe = probe;
            break;
          }
        }
        if (!demuxer) {
          observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });
          return;
        }
        this.demuxer = demuxer;
      }
      var remuxer = this.remuxer;

      if (discontinuity || trackSwitch) {
        demuxer.resetInitSegment(initSegment, audioCodec, videoCodec, duration);
        remuxer.resetInitSegment();
      }
      if (discontinuity) {
        demuxer.resetTimeStamp(defaultInitPTS);
        remuxer.resetTimeStamp(defaultInitPTS);
      }
      if (typeof demuxer.setDecryptData === 'function') {
        demuxer.setDecryptData(decryptdata);
      }

      demuxer.append(data, timeOffset, contiguous, accurateTimeOffset);
    }
  }]);

  return DemuxerInline;
}();

exports.default = DemuxerInline;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/demuxer-worker.js":
/*!********************************************!*\
  !*** ./src/hls.js/demux/demuxer-worker.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _demuxerInline = __webpack_require__(/*! ../demux/demuxer-inline */ "./src/hls.js/demux/demuxer-inline.js");

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _events3 = __webpack_require__(/*! events */ "../../node_modules/events/events.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* demuxer web worker.
 *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
 *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
 */

var DemuxerWorker = function DemuxerWorker(self) {
  // observer setup
  var observer = new _events3.EventEmitter();
  observer.trigger = function trigger(event) {
    for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    observer.emit.apply(observer, [event, event].concat(data));
  };

  observer.off = function off(event) {
    for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      data[_key2 - 1] = arguments[_key2];
    }

    observer.removeListener.apply(observer, [event].concat(data));
  };

  var forwardMessage = function forwardMessage(ev, data) {
    self.postMessage({ event: ev, data: data });
  };

  self.addEventListener('message', function (ev) {
    var data = ev.data;
    // console.log('demuxer cmd:' + data.cmd);
    switch (data.cmd) {
      case 'init':
        var config = JSON.parse(data.config);
        self.demuxer = new _demuxerInline2.default(observer, data.typeSupported, config, data.vendor);

        (0, _logger.enableLogs)(config.debug);

        // signal end of worker init
        forwardMessage('init', null);
        break;
      case 'demux':
        self.demuxer.push(data.data, data.decryptdata, data.initSegment, data.audioCodec, data.videoCodec, data.timeOffset, data.discontinuity, data.trackSwitch, data.contiguous, data.duration, data.accurateTimeOffset, data.defaultInitPTS);
        break;
      default:
        break;
    }
  });

  // forward events to main thread
  observer.on(_events2.default.FRAG_DECRYPTED, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
  observer.on(_events2.default.FRAG_PARSED, forwardMessage);
  observer.on(_events2.default.ERROR, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);
  observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);

  // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)
  observer.on(_events2.default.FRAG_PARSING_DATA, function (ev, data) {
    var transferable = [];
    var message = { event: ev, data: data };
    if (data.data1) {
      message.data1 = data.data1.buffer;
      transferable.push(data.data1.buffer);
      delete data.data1;
    }
    if (data.data2) {
      message.data2 = data.data2.buffer;
      transferable.push(data.data2.buffer);
      delete data.data2;
    }
    self.postMessage(message, transferable);
  });
};

exports.default = DemuxerWorker;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/demuxer.js":
/*!*************************************!*\
  !*** ./src/hls.js/demux/demuxer.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! events */ "../../node_modules/events/events.js");

var _webworkifyWebpack = __webpack_require__(/*! webworkify-webpack */ "../../node_modules/webworkify-webpack/index.js");

var work = _interopRequireWildcard(_webworkifyWebpack);

var _events2 = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events3 = _interopRequireDefault(_events2);

var _demuxerInline = __webpack_require__(/*! ../demux/demuxer-inline */ "./src/hls.js/demux/demuxer-inline.js");

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _mediasourceHelper = __webpack_require__(/*! ../utils/mediasource-helper */ "./src/hls.js/utils/mediasource-helper.js");

var _getSelfScope = __webpack_require__(/*! ../utils/get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

var _observer = __webpack_require__(/*! ../observer */ "./src/hls.js/observer.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// see https://stackoverflow.com/a/11237259/589493
var global = (0, _getSelfScope.getSelfScope)(); // safeguard for code that might run both on worker and main thread
var MediaSource = (0, _mediasourceHelper.getMediaSource)();

var Demuxer = function () {
  function Demuxer(hls, id) {
    var _this = this;

    _classCallCheck(this, Demuxer);

    this.hls = hls;
    this.id = id;

    var observer = this.observer = new _observer.Observer();
    var config = hls.config;

    var forwardMessage = function forwardMessage(ev, data) {
      data = data || {};
      data.frag = _this.frag;
      data.id = _this.id;
      hls.trigger(ev, data);
    };

    // forward events to main thread
    observer.on(_events3.default.FRAG_DECRYPTED, forwardMessage);
    observer.on(_events3.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
    observer.on(_events3.default.FRAG_PARSING_DATA, forwardMessage);
    observer.on(_events3.default.FRAG_PARSED, forwardMessage);
    observer.on(_events3.default.ERROR, forwardMessage);
    observer.on(_events3.default.FRAG_PARSING_METADATA, forwardMessage);
    observer.on(_events3.default.FRAG_PARSING_USERDATA, forwardMessage);
    observer.on(_events3.default.INIT_PTS_FOUND, forwardMessage);

    var typeSupported = {
      mp4: MediaSource.isTypeSupported('video/mp4'),
      mpeg: MediaSource.isTypeSupported('audio/mpeg'),
      mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"')
    };
    // navigator.vendor is not always available in Web Worker
    // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator
    var vendor = navigator.vendor;
    if (config.enableWorker && typeof Worker !== 'undefined') {
      _logger.logger.log('demuxing in webworker');
      var w = void 0;
      try {
        w = this.w = work(/*require.resolve*/(/*! ../demux/demuxer-worker.js */ "./src/hls.js/demux/demuxer-worker.js"));
        this.onwmsg = this.onWorkerMessage.bind(this);
        w.addEventListener('message', this.onwmsg);
        w.onerror = function (event) {
          hls.trigger(_events3.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });
        };
        w.postMessage({ cmd: 'init', typeSupported: typeSupported, vendor: vendor, id: id, config: JSON.stringify(config) });
      } catch (err) {
        _logger.logger.warn('Error in worker:', err);
        _logger.logger.error('Error while initializing DemuxerWorker, fallback on DemuxerInline');
        if (w) {
          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
          global.URL.revokeObjectURL(w.objectURL);
        }
        this.demuxer = new _demuxerInline2.default(observer, typeSupported, config, vendor);
        this.w = undefined;
      }
    } else {
      this.demuxer = new _demuxerInline2.default(observer, typeSupported, config, vendor);
    }
  }

  _createClass(Demuxer, [{
    key: 'destroy',
    value: function destroy() {
      var w = this.w;
      if (w) {
        w.removeEventListener('message', this.onwmsg);
        w.terminate();
        this.w = null;
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.destroy();
          this.demuxer = null;
        }
      }
      var observer = this.observer;
      if (observer) {
        observer.removeAllListeners();
        this.observer = null;
      }
    }
  }, {
    key: 'push',
    value: function push(data, initSegment, audioCodec, videoCodec, frag, duration, accurateTimeOffset, defaultInitPTS) {
      var w = this.w;
      var timeOffset = Number.isFinite(frag.startPTS) ? frag.startPTS : frag.start;
      var decryptdata = frag.decryptdata;
      var lastFrag = this.frag;
      var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
      var trackSwitch = !(lastFrag && frag.levels === lastFrag.levels);
      var nextSN = lastFrag && frag.sn === lastFrag.sn + 1;
      var contiguous = !trackSwitch && nextSN;
      if (discontinuity) {
        _logger.logger.log(this.id + ':discontinuity detected');
      }

      if (trackSwitch) {
        _logger.logger.log(this.id + ':switch detected');
      }

      this.frag = frag;
      if (w) {
        // post fragment payload as transferable objects for ArrayBuffer (no copy)
        w.postMessage({ cmd: 'demux', data: data, decryptdata: decryptdata, initSegment: initSegment, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, discontinuity: discontinuity, trackSwitch: trackSwitch, contiguous: contiguous, duration: duration, accurateTimeOffset: accurateTimeOffset, defaultInitPTS: defaultInitPTS }, data instanceof ArrayBuffer ? [data] : []);
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
        }
      }
    }
  }, {
    key: 'onWorkerMessage',
    value: function onWorkerMessage(ev) {
      var data = ev.data,
          hls = this.hls;
      switch (data.event) {
        case 'init':
          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
          global.URL.revokeObjectURL(this.w.objectURL);
          break;
        // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects
        case _events3.default.FRAG_PARSING_DATA:
          data.data.data1 = new Uint8Array(data.data1);
          if (data.data2) {
            data.data.data2 = new Uint8Array(data.data2);
          }

        /* falls through */
        default:
          data.data = data.data || {};
          data.data.frag = this.frag;
          data.data.id = this.id;
          hls.trigger(data.event, data.data);
          break;
      }
    }
  }]);

  return Demuxer;
}();

exports.default = Demuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/exp-golomb.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/exp-golomb.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ExpGolomb = function () {
  function ExpGolomb(data) {
    _classCallCheck(this, ExpGolomb);

    this.data = data;
    // the number of bytes left to examine in this.data
    this.bytesAvailable = data.byteLength;
    // the current word being examined
    this.word = 0; // :uint
    // the number of bits left to examine in the current word
    this.bitsAvailable = 0; // :uint
  }

  // ():void


  _createClass(ExpGolomb, [{
    key: 'loadWord',
    value: function loadWord() {
      var data = this.data,
          bytesAvailable = this.bytesAvailable,
          position = data.byteLength - bytesAvailable,
          workingBytes = new Uint8Array(4),
          availableBytes = Math.min(4, bytesAvailable);
      if (availableBytes === 0) {
        throw new Error('no bytes available');
      }

      workingBytes.set(data.subarray(position, position + availableBytes));
      this.word = new DataView(workingBytes.buffer).getUint32(0);
      // track the amount of this.data that has been processed
      this.bitsAvailable = availableBytes * 8;
      this.bytesAvailable -= availableBytes;
    }

    // (count:int):void

  }, {
    key: 'skipBits',
    value: function skipBits(count) {
      var skipBytes = void 0; // :int
      if (this.bitsAvailable > count) {
        this.word <<= count;
        this.bitsAvailable -= count;
      } else {
        count -= this.bitsAvailable;
        skipBytes = count >> 3;
        count -= skipBytes >> 3;
        this.bytesAvailable -= skipBytes;
        this.loadWord();
        this.word <<= count;
        this.bitsAvailable -= count;
      }
    }

    // (size:int):uint

  }, {
    key: 'readBits',
    value: function readBits(size) {
      var bits = Math.min(this.bitsAvailable, size),
          // :uint
      valu = this.word >>> 32 - bits; // :uint
      if (size > 32) {
        _logger.logger.error('Cannot read more than 32 bits at a time');
      }

      this.bitsAvailable -= bits;
      if (this.bitsAvailable > 0) {
        this.word <<= bits;
      } else if (this.bytesAvailable > 0) {
        this.loadWord();
      }

      bits = size - bits;
      if (bits > 0 && this.bitsAvailable) {
        return valu << bits | this.readBits(bits);
      } else {
        return valu;
      }
    }

    // ():uint

  }, {
    key: 'skipLZ',
    value: function skipLZ() {
      var leadingZeroCount = void 0; // :uint
      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
        if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {
          // the first bit of working word is 1
          this.word <<= leadingZeroCount;
          this.bitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      // we exhausted word and still have not found a 1
      this.loadWord();
      return leadingZeroCount + this.skipLZ();
    }

    // ():void

  }, {
    key: 'skipUEG',
    value: function skipUEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():void

  }, {
    key: 'skipEG',
    value: function skipEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():uint

  }, {
    key: 'readUEG',
    value: function readUEG() {
      var clz = this.skipLZ(); // :uint
      return this.readBits(clz + 1) - 1;
    }

    // ():int

  }, {
    key: 'readEG',
    value: function readEG() {
      var valu = this.readUEG(); // :int
      if (0x01 & valu) {
        // the number is odd if the low order bit is set
        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2
      } else {
        return -1 * (valu >>> 1); // divide by two then make it negative
      }
    }

    // Some convenience functions
    // :Boolean

  }, {
    key: 'readBoolean',
    value: function readBoolean() {
      return this.readBits(1) === 1;
    }

    // ():int

  }, {
    key: 'readUByte',
    value: function readUByte() {
      return this.readBits(8);
    }

    // ():int

  }, {
    key: 'readUShort',
    value: function readUShort() {
      return this.readBits(16);
    }
    // ():int

  }, {
    key: 'readUInt',
    value: function readUInt() {
      return this.readBits(32);
    }

    /**
     * Advance the ExpGolomb decoder past a scaling list. The scaling
     * list is optionally transmitted as part of a sequence parameter
     * set and is not relevant to transmuxing.
     * @param count {number} the number of entries in this scaling list
     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
     */

  }, {
    key: 'skipScalingList',
    value: function skipScalingList(count) {
      var lastScale = 8,
          nextScale = 8,
          j = void 0,
          deltaScale = void 0;
      for (j = 0; j < count; j++) {
        if (nextScale !== 0) {
          deltaScale = this.readEG();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    }

    /**
     * Read a sequence parameter set and return some interesting video
     * properties. A sequence parameter set is the H264 metadata that
     * describes the properties of upcoming video frames.
     * @param data {Uint8Array} the bytes of a sequence parameter set
     * @return {object} an object with configuration parsed from the
     * sequence parameter set, including the dimensions of the
     * associated video frames.
     */

  }, {
    key: 'readSPS',
    value: function readSPS() {
      var frameCropLeftOffset = 0,
          frameCropRightOffset = 0,
          frameCropTopOffset = 0,
          frameCropBottomOffset = 0,
          profileIdc = void 0,
          profileCompat = void 0,
          levelIdc = void 0,
          numRefFramesInPicOrderCntCycle = void 0,
          picWidthInMbsMinus1 = void 0,
          picHeightInMapUnitsMinus1 = void 0,
          frameMbsOnlyFlag = void 0,
          scalingListCount = void 0,
          i = void 0,
          readUByte = this.readUByte.bind(this),
          readBits = this.readBits.bind(this),
          readUEG = this.readUEG.bind(this),
          readBoolean = this.readBoolean.bind(this),
          skipBits = this.skipBits.bind(this),
          skipEG = this.skipEG.bind(this),
          skipUEG = this.skipUEG.bind(this),
          skipScalingList = this.skipScalingList.bind(this);

      readUByte();
      profileIdc = readUByte(); // profile_idc
      profileCompat = readBits(5); // constraint_set[0-4]_flag, u(5)
      skipBits(3); // reserved_zero_3bits u(3),
      levelIdc = readUByte(); // level_idc u(8)
      skipUEG(); // seq_parameter_set_id
      // some profiles have more optional data we don't need
      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
        var chromaFormatIdc = readUEG();
        if (chromaFormatIdc === 3) {
          skipBits(1);
        } // separate_colour_plane_flag

        skipUEG(); // bit_depth_luma_minus8
        skipUEG(); // bit_depth_chroma_minus8
        skipBits(1); // qpprime_y_zero_transform_bypass_flag
        if (readBoolean()) {
          // seq_scaling_matrix_present_flag
          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (i = 0; i < scalingListCount; i++) {
            if (readBoolean()) {
              // seq_scaling_list_present_flag[ i ]
              if (i < 6) {
                skipScalingList(16);
              } else {
                skipScalingList(64);
              }
            }
          }
        }
      }
      skipUEG(); // log2_max_frame_num_minus4
      var picOrderCntType = readUEG();
      if (picOrderCntType === 0) {
        readUEG(); // log2_max_pic_order_cnt_lsb_minus4
      } else if (picOrderCntType === 1) {
        skipBits(1); // delta_pic_order_always_zero_flag
        skipEG(); // offset_for_non_ref_pic
        skipEG(); // offset_for_top_to_bottom_field
        numRefFramesInPicOrderCntCycle = readUEG();
        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
          skipEG();
        } // offset_for_ref_frame[ i ]
      }
      skipUEG(); // max_num_ref_frames
      skipBits(1); // gaps_in_frame_num_value_allowed_flag
      picWidthInMbsMinus1 = readUEG();
      picHeightInMapUnitsMinus1 = readUEG();
      frameMbsOnlyFlag = readBits(1);
      if (frameMbsOnlyFlag === 0) {
        skipBits(1);
      } // mb_adaptive_frame_field_flag

      skipBits(1); // direct_8x8_inference_flag
      if (readBoolean()) {
        // frame_cropping_flag
        frameCropLeftOffset = readUEG();
        frameCropRightOffset = readUEG();
        frameCropTopOffset = readUEG();
        frameCropBottomOffset = readUEG();
      }
      var pixelRatio = [1, 1];
      if (readBoolean()) {
        // vui_parameters_present_flag
        if (readBoolean()) {
          // aspect_ratio_info_present_flag
          var aspectRatioIdc = readUByte();
          switch (aspectRatioIdc) {
            case 1:
              pixelRatio = [1, 1];break;
            case 2:
              pixelRatio = [12, 11];break;
            case 3:
              pixelRatio = [10, 11];break;
            case 4:
              pixelRatio = [16, 11];break;
            case 5:
              pixelRatio = [40, 33];break;
            case 6:
              pixelRatio = [24, 11];break;
            case 7:
              pixelRatio = [20, 11];break;
            case 8:
              pixelRatio = [32, 11];break;
            case 9:
              pixelRatio = [80, 33];break;
            case 10:
              pixelRatio = [18, 11];break;
            case 11:
              pixelRatio = [15, 11];break;
            case 12:
              pixelRatio = [64, 33];break;
            case 13:
              pixelRatio = [160, 99];break;
            case 14:
              pixelRatio = [4, 3];break;
            case 15:
              pixelRatio = [3, 2];break;
            case 16:
              pixelRatio = [2, 1];break;
            case 255:
              {
                pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
                break;
              }
          }
        }
      }
      return {
        width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
        pixelRatio: pixelRatio
      };
    }
  }, {
    key: 'readSliceType',
    value: function readSliceType() {
      // skip NALu type
      this.readUByte();
      // discard first_mb_in_slice
      this.readUEG();
      // return slice_type
      return this.readUEG();
    }
  }]);

  return ExpGolomb;
}();

exports.default = ExpGolomb;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/id3.js":
/*!*********************************!*\
  !*** ./src/hls.js/demux/id3.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * ID3 parser
 */
var ID3 = function () {
  function ID3() {
    _classCallCheck(this, ID3);
  }

  _createClass(ID3, null, [{
    key: 'isHeader',

    /**
     * Returns true if an ID3 header can be found at offset in data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {boolean} - True if an ID3 header is found
     */
    value: function isHeader(data, offset) {
      /*
      * http://id3.org/id3v2.3.0
      * [0]     = 'I'
      * [1]     = 'D'
      * [2]     = '3'
      * [3,4]   = {Version}
      * [5]     = {Flags}
      * [6-9]   = {ID3 Size}
      *
      * An ID3v2 tag can be detected with the following pattern:
      *  $49 44 33 yy yy xx zz zz zz zz
      * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80
      */
      if (offset + 10 <= data.length) {
        // look for 'ID3' identifier
        if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {
          // check version is within range
          if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
            // check size is within range
            if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
              return true;
            }
          }
        }
      }

      return false;
    }

    /**
     * Returns true if an ID3 footer can be found at offset in data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {boolean} - True if an ID3 footer is found
     */

  }, {
    key: 'isFooter',
    value: function isFooter(data, offset) {
      /*
      * The footer is a copy of the header, but with a different identifier
      */
      if (offset + 10 <= data.length) {
        // look for '3DI' identifier
        if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {
          // check version is within range
          if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
            // check size is within range
            if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
              return true;
            }
          }
        }
      }

      return false;
    }

    /**
     * Returns any adjacent ID3 tags found in data starting at offset, as one block of data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {Uint8Array} - The block of data containing any ID3 tags found
     */

  }, {
    key: 'getID3Data',
    value: function getID3Data(data, offset) {
      var front = offset;
      var length = 0;

      while (ID3.isHeader(data, offset)) {
        // ID3 header is 10 bytes
        length += 10;

        var size = ID3._readSize(data, offset + 6);
        length += size;

        if (ID3.isFooter(data, offset + 10)) {
          // ID3 footer is 10 bytes
          length += 10;
        }

        offset += length;
      }

      if (length > 0) {
        return data.subarray(front, front + length);
      }

      return undefined;
    }
  }, {
    key: '_readSize',
    value: function _readSize(data, offset) {
      var size = 0;
      size = (data[offset] & 0x7f) << 21;
      size |= (data[offset + 1] & 0x7f) << 14;
      size |= (data[offset + 2] & 0x7f) << 7;
      size |= data[offset + 3] & 0x7f;
      return size;
    }

    /**
     * Searches for the Elementary Stream timestamp found in the ID3 data chunk
     * @param {Uint8Array} data - Block of data containing one or more ID3 tags
     * @return {number} - The timestamp
     */

  }, {
    key: 'getTimeStamp',
    value: function getTimeStamp(data) {
      var frames = ID3.getID3Frames(data);
      for (var i = 0; i < frames.length; i++) {
        var frame = frames[i];
        if (ID3.isTimeStampFrame(frame)) {
          return ID3._readTimeStamp(frame);
        }
      }

      return undefined;
    }

    /**
     * Returns true if the ID3 frame is an Elementary Stream timestamp frame
     * @param {ID3 frame} frame
     */

  }, {
    key: 'isTimeStampFrame',
    value: function isTimeStampFrame(frame) {
      return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';
    }
  }, {
    key: '_getFrameData',
    value: function _getFrameData(data) {
      /*
      Frame ID       $xx xx xx xx (four characters)
      Size           $xx xx xx xx
      Flags          $xx xx
      */
      var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
      var size = ID3._readSize(data, 4);

      // skip frame id, size, and flags
      var offset = 10;

      return { type: type, size: size, data: data.subarray(offset, offset + size) };
    }

    /**
     * Returns an array of ID3 frames found in all the ID3 tags in the id3Data
     * @param {Uint8Array} id3Data - The ID3 data containing one or more ID3 tags
     * @return {ID3 frame[]} - Array of ID3 frame objects
     */

  }, {
    key: 'getID3Frames',
    value: function getID3Frames(id3Data) {
      var offset = 0;
      var frames = [];

      while (ID3.isHeader(id3Data, offset)) {
        var size = ID3._readSize(id3Data, offset + 6);
        // skip past ID3 header
        offset += 10;
        var end = offset + size;
        // loop through frames in the ID3 tag
        while (offset + 8 < end) {
          var frameData = ID3._getFrameData(id3Data.subarray(offset));
          var frame = ID3._decodeFrame(frameData);
          if (frame) {
            frames.push(frame);
          }

          // skip frame header and frame data
          offset += frameData.size + 10;
        }

        if (ID3.isFooter(id3Data, offset)) {
          offset += 10;
        }
      }

      return frames;
    }
  }, {
    key: '_decodeFrame',
    value: function _decodeFrame(frame) {
      if (frame.type === 'PRIV') {
        return ID3._decodePrivFrame(frame);
      } else if (frame.type[0] === 'T') {
        return ID3._decodeTextFrame(frame);
      } else if (frame.type[0] === 'W') {
        return ID3._decodeURLFrame(frame);
      }

      return undefined;
    }
  }, {
    key: '_readTimeStamp',
    value: function _readTimeStamp(timeStampFrame) {
      if (timeStampFrame.data.byteLength === 8) {
        var data = new Uint8Array(timeStampFrame.data);
        // timestamp is 33 bit expressed as a big-endian eight-octet number,
        // with the upper 31 bits set to zero.
        var pts33Bit = data[3] & 0x1;
        var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
        timestamp /= 45;

        if (pts33Bit) {
          timestamp += 47721858.84;
        } // 2^32 / 90

        return Math.round(timestamp);
      }

      return undefined;
    }
  }, {
    key: '_decodePrivFrame',
    value: function _decodePrivFrame(frame) {
      /*
      Format: <text string>\0<binary data>
      */
      if (frame.size < 2) {
        return undefined;
      }

      var owner = ID3._utf8ArrayToStr(frame.data, true);
      var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));

      return { key: frame.type, info: owner, data: privateData.buffer };
    }
  }, {
    key: '_decodeTextFrame',
    value: function _decodeTextFrame(frame) {
      if (frame.size < 2) {
        return undefined;
      }

      if (frame.type === 'TXXX') {
        /*
        Format:
        [0]   = {Text Encoding}
        [1-?] = {Description}\0{Value}
        */
        var index = 1;
        var description = ID3._utf8ArrayToStr(frame.data.subarray(index));

        index += description.length + 1;
        var value = ID3._utf8ArrayToStr(frame.data.subarray(index));

        return { key: frame.type, info: description, data: value };
      } else {
        /*
        Format:
        [0]   = {Text Encoding}
        [1-?] = {Value}
        */
        var text = ID3._utf8ArrayToStr(frame.data.subarray(1));
        return { key: frame.type, data: text };
      }
    }
  }, {
    key: '_decodeURLFrame',
    value: function _decodeURLFrame(frame) {
      if (frame.type === 'WXXX') {
        /*
        Format:
        [0]   = {Text Encoding}
        [1-?] = {Description}\0{URL}
        */
        if (frame.size < 2) {
          return undefined;
        }

        var index = 1;
        var description = ID3._utf8ArrayToStr(frame.data.subarray(index));

        index += description.length + 1;
        var value = ID3._utf8ArrayToStr(frame.data.subarray(index));

        return { key: frame.type, info: description, data: value };
      } else {
        /*
        Format:
        [0-?] = {URL}
        */
        var url = ID3._utf8ArrayToStr(frame.data);
        return { key: frame.type, data: url };
      }
    }

    // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197
    // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
    /* utf.js - UTF-8 <=> UTF-16 convertion
     *
     * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
     * Version: 1.0
     * LastModified: Dec 25 1999
     * This library is free.  You can redistribute it and/or modify it.
     */

  }, {
    key: '_utf8ArrayToStr',
    value: function _utf8ArrayToStr(array) {
      var exitOnNull = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var len = array.length;
      var c = void 0;
      var char2 = void 0;
      var char3 = void 0;
      var out = '';
      var i = 0;
      while (i < len) {
        c = array[i++];
        if (c === 0x00 && exitOnNull) {
          return out;
        } else if (c === 0x00 || c === 0x03) {
          // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it
          continue;
        }
        switch (c >> 4) {
          case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:
            // 0xxxxxxx
            out += String.fromCharCode(c);
            break;
          case 12:case 13:
            // 110x xxxx   10xx xxxx
            char2 = array[i++];
            out += String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F);
            break;
          case 14:
            // 1110 xxxx  10xx xxxx  10xx xxxx
            char2 = array[i++];
            char3 = array[i++];
            out += String.fromCharCode((c & 0x0F) << 12 | (char2 & 0x3F) << 6 | (char3 & 0x3F) << 0);
            break;
          default:
        }
      }
      return out;
    }
  }]);

  return ID3;
}();

var utf8ArrayToStr = ID3._utf8ArrayToStr;

exports.default = ID3;
exports.utf8ArrayToStr = utf8ArrayToStr;

/***/ }),

/***/ "./src/hls.js/demux/mp3demuxer.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/mp3demuxer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * MP3 demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _id = __webpack_require__(/*! ../demux/id3 */ "./src/hls.js/demux/id3.js");

var _id2 = _interopRequireDefault(_id);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _mpegaudio = __webpack_require__(/*! ./mpegaudio */ "./src/hls.js/demux/mpegaudio.js");

var _mpegaudio2 = _interopRequireDefault(_mpegaudio);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MP3Demuxer = function () {
  function MP3Demuxer(observer, remuxer, config) {
    _classCallCheck(this, MP3Demuxer);

    this.observer = observer;
    this.config = config;
    this.remuxer = remuxer;
  }

  _createClass(MP3Demuxer, [{
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this._audioTrack = { container: 'audio/mpeg', type: 'audio', id: -1, sequenceNumber: 0, isAAC: false, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
    }
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var id3Data = _id2.default.getID3Data(data, 0);
      var timestamp = _id2.default.getTimeStamp(id3Data);
      var pts = timestamp ? 90 * timestamp : timeOffset * 90000;
      var offset = id3Data.length;
      var length = data.length;
      var frameIndex = 0,
          stamp = 0;
      var track = this._audioTrack;

      var id3Samples = [{ pts: pts, dts: pts, data: id3Data }];

      while (offset < length) {
        if (_mpegaudio2.default.isHeader(data, offset)) {
          var frame = _mpegaudio2.default.appendFrame(track, data, offset, pts, frameIndex);
          if (frame) {
            offset += frame.length;
            stamp = frame.sample.pts;
            frameIndex++;
          } else {
            // logger.log('Unable to parse Mpeg audio frame');
            break;
          }
        } else if (_id2.default.isHeader(data, offset)) {
          id3Data = _id2.default.getID3Data(data, offset);
          id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });
          offset += id3Data.length;
        } else {
          // nothing found, keep looking
          offset++;
        }
      }

      this.remuxer.remux(track, { samples: [] }, { samples: id3Samples, inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      // check if data contains ID3 timestamp and MPEG sync word
      var offset = void 0,
          length = void 0;
      var id3Data = _id2.default.getID3Data(data, 0);
      if (id3Data && _id2.default.getTimeStamp(id3Data) !== undefined) {
        // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
        // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
        // More info http://www.mp3-tech.org/programmer/frame_header.html
        for (offset = id3Data.length, length = Math.min(data.length - 1, offset + 100); offset < length; offset++) {
          if (_mpegaudio2.default.probe(data, offset)) {
            _logger.logger.log('MPEG Audio sync word found !');
            return true;
          }
        }
      }
      return false;
    }
  }]);

  return MP3Demuxer;
}();

exports.default = MP3Demuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/mp4demuxer.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/mp4demuxer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * MP4 demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UINT32_MAX = Math.pow(2, 32) - 1;

var MP4Demuxer = function () {
  function MP4Demuxer(observer, remuxer) {
    _classCallCheck(this, MP4Demuxer);

    this.observer = observer;
    this.remuxer = remuxer;
  }

  _createClass(MP4Demuxer, [{
    key: 'resetTimeStamp',
    value: function resetTimeStamp(initPTS) {
      this.initPTS = initPTS;
    }
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      // jshint unused:false
      if (initSegment && initSegment.byteLength) {
        var initData = this.initData = MP4Demuxer.parseInitSegment(initSegment);

        // default audio codec if nothing specified
        // TODO : extract that from initsegment
        if (audioCodec == null) {
          audioCodec = 'mp4a.40.5';
        }

        if (videoCodec == null) {
          videoCodec = 'avc1.42e01e';
        }

        var tracks = {};
        if (initData.audio && initData.video) {
          tracks.audiovideo = { container: 'video/mp4', codec: audioCodec + ',' + videoCodec, initSegment: duration ? initSegment : null };
        } else {
          if (initData.audio) {
            tracks.audio = { container: 'audio/mp4', codec: audioCodec, initSegment: duration ? initSegment : null };
          }

          if (initData.video) {
            tracks.video = { container: 'video/mp4', codec: videoCodec, initSegment: duration ? initSegment : null };
          }
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, { tracks: tracks });
      } else {
        if (audioCodec) {
          this.audioCodec = audioCodec;
        }

        if (videoCodec) {
          this.videoCodec = videoCodec;
        }
      }
    }
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var initData = this.initData;
      if (!initData) {
        this.resetInitSegment(data, this.audioCodec, this.videoCodec, false);
        initData = this.initData;
      }
      var startDTS = void 0,
          initPTS = this.initPTS;
      if (initPTS === undefined) {
        var _startDTS = MP4Demuxer.getStartDTS(initData, data);
        this.initPTS = initPTS = _startDTS - timeOffset;
        this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });
      }
      MP4Demuxer.offsetStartDTS(initData, data, initPTS);
      startDTS = MP4Demuxer.getStartDTS(initData, data);
      this.remuxer.remux(initData.audio, initData.video, null, null, startDTS, contiguous, accurateTimeOffset, data);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      // ensure we find a moof box in the first 16 kB
      return MP4Demuxer.findBox({ data: data, start: 0, end: Math.min(data.length, 16384) }, ['moof']).length > 0;
    }
  }, {
    key: 'bin2str',
    value: function bin2str(buffer) {
      return String.fromCharCode.apply(null, buffer);
    }
  }, {
    key: 'readUint16',
    value: function readUint16(buffer, offset) {
      if (buffer.data) {
        offset += buffer.start;
        buffer = buffer.data;
      }

      var val = buffer[offset] << 8 | buffer[offset + 1];

      return val < 0 ? 65536 + val : val;
    }
  }, {
    key: 'readUint32',
    value: function readUint32(buffer, offset) {
      if (buffer.data) {
        offset += buffer.start;
        buffer = buffer.data;
      }

      var val = buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
      return val < 0 ? 4294967296 + val : val;
    }
  }, {
    key: 'writeUint32',
    value: function writeUint32(buffer, offset, value) {
      if (buffer.data) {
        offset += buffer.start;
        buffer = buffer.data;
      }
      buffer[offset] = value >> 24;
      buffer[offset + 1] = value >> 16 & 0xff;
      buffer[offset + 2] = value >> 8 & 0xff;
      buffer[offset + 3] = value & 0xff;
    }

    // Find the data for a box specified by its path

  }, {
    key: 'findBox',
    value: function findBox(data, path) {
      var results = [],
          i = void 0,
          size = void 0,
          type = void 0,
          end = void 0,
          subresults = void 0,
          start = void 0,
          endbox = void 0;

      if (data.data) {
        start = data.start;
        end = data.end;
        data = data.data;
      } else {
        start = 0;
        end = data.byteLength;
      }

      if (!path.length) {
        // short-circuit the search for empty paths
        return null;
      }

      for (i = start; i < end;) {
        size = MP4Demuxer.readUint32(data, i);
        type = MP4Demuxer.bin2str(data.subarray(i + 4, i + 8));
        endbox = size > 1 ? i + size : end;

        if (type === path[0]) {
          if (path.length === 1) {
            // this is the end of the path and we've found the box we were
            // looking for
            results.push({ data: data, start: i + 8, end: endbox });
          } else {
            // recursively search for the next box along the path
            subresults = MP4Demuxer.findBox({ data: data, start: i + 8, end: endbox }, path.slice(1));
            if (subresults.length) {
              results = results.concat(subresults);
            }
          }
        }
        i = endbox;
      }

      // we've finished searching all of data
      return results;
    }
  }, {
    key: 'parseSegmentIndex',
    value: function parseSegmentIndex(initSegment) {
      var moov = MP4Demuxer.findBox(initSegment, ['moov'])[0];
      var moovEndOffset = moov ? moov.end : null; // we need this in case we need to chop of garbage of the end of current data

      var index = 0;
      var sidx = MP4Demuxer.findBox(initSegment, ['sidx']);
      var references = void 0;

      if (!sidx || !sidx[0]) {
        return null;
      }

      references = [];
      sidx = sidx[0];

      var version = sidx.data[0];

      // set initial offset, we skip the reference ID (not needed)
      index = version === 0 ? 8 : 16;

      var timescale = MP4Demuxer.readUint32(sidx, index);
      index += 4;

      // TODO: parse earliestPresentationTime and firstOffset
      // usually zero in our case
      var earliestPresentationTime = 0;
      var firstOffset = 0;

      if (version === 0) {
        index += 8;
      } else {
        index += 16;
      }

      // skip reserved
      index += 2;

      var startByte = sidx.end + firstOffset;

      var referencesCount = MP4Demuxer.readUint16(sidx, index);
      index += 2;

      for (var i = 0; i < referencesCount; i++) {
        var referenceIndex = index;

        var referenceInfo = MP4Demuxer.readUint32(sidx, referenceIndex);
        referenceIndex += 4;

        var referenceSize = referenceInfo & 0x7FFFFFFF;
        var referenceType = (referenceInfo & 0x80000000) >>> 31;

        if (referenceType === 1) {
          console.warn('SIDX has hierarchical references (not supported)');
          return;
        }

        var subsegmentDuration = MP4Demuxer.readUint32(sidx, referenceIndex);
        referenceIndex += 4;

        references.push({
          referenceSize: referenceSize,
          subsegmentDuration: subsegmentDuration, // unscaled
          info: {
            duration: subsegmentDuration / timescale,
            start: startByte,
            end: startByte + referenceSize - 1
          }
        });

        startByte += referenceSize;

        // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits
        // for |sapDelta|.
        referenceIndex += 4;

        // skip to next ref
        index = referenceIndex;
      }

      return {
        earliestPresentationTime: earliestPresentationTime,
        timescale: timescale,
        version: version,
        referencesCount: referencesCount,
        references: references,
        moovEndOffset: moovEndOffset
      };
    }

    /**
     * Parses an MP4 initialization segment and extracts stream type and
     * timescale values for any declared tracks. Timescale values indicate the
     * number of clock ticks per second to assume for time-based values
     * elsewhere in the MP4.
     *
     * To determine the start time of an MP4, you need two pieces of
     * information: the timescale unit and the earliest base media decode
     * time. Multiple timescales can be specified within an MP4 but the
     * base media decode time is always expressed in the timescale from
     * the media header box for the track:
     * ```
     * moov > trak > mdia > mdhd.timescale
     * moov > trak > mdia > hdlr
     * ```
     * @param init {Uint8Array} the bytes of the init segment
     * @return {object} a hash of track type to timescale values or null if
     * the init segment is malformed.
     */

  }, {
    key: 'parseInitSegment',
    value: function parseInitSegment(initSegment) {
      var result = [];
      var traks = MP4Demuxer.findBox(initSegment, ['moov', 'trak']);

      traks.forEach(function (trak) {
        var tkhd = MP4Demuxer.findBox(trak, ['tkhd'])[0];
        if (tkhd) {
          var version = tkhd.data[tkhd.start];
          var index = version === 0 ? 12 : 20;
          var trackId = MP4Demuxer.readUint32(tkhd, index);

          var mdhd = MP4Demuxer.findBox(trak, ['mdia', 'mdhd'])[0];
          if (mdhd) {
            version = mdhd.data[mdhd.start];
            index = version === 0 ? 12 : 20;
            var timescale = MP4Demuxer.readUint32(mdhd, index);

            var hdlr = MP4Demuxer.findBox(trak, ['mdia', 'hdlr'])[0];
            if (hdlr) {
              var hdlrType = MP4Demuxer.bin2str(hdlr.data.subarray(hdlr.start + 8, hdlr.start + 12));
              var type = { 'soun': 'audio', 'vide': 'video' }[hdlrType];
              if (type) {
                // extract codec info. TODO : parse codec details to be able to build MIME type
                var codecBox = MP4Demuxer.findBox(trak, ['mdia', 'minf', 'stbl', 'stsd']);
                if (codecBox.length) {
                  codecBox = codecBox[0];
                  var codecType = MP4Demuxer.bin2str(codecBox.data.subarray(codecBox.start + 12, codecBox.start + 16));
                  _logger.logger.log('MP4Demuxer:' + type + ':' + codecType + ' found');
                }
                result[trackId] = { timescale: timescale, type: type };
                result[type] = { timescale: timescale, id: trackId };
              }
            }
          }
        }
      });
      return result;
    }

    /**
    * Determine the base media decode start time, in seconds, for an MP4
    * fragment. If multiple fragments are specified, the earliest time is
    * returned.
    *
    * The base media decode time can be parsed from track fragment
    * metadata:
    * ```
    * moof > traf > tfdt.baseMediaDecodeTime
    * ```
    * It requires the timescale value from the mdhd to interpret.
    *
    * @param timescale {object} a hash of track ids to timescale values.
    * @return {number} the earliest base media decode start time for the
    * fragment, in seconds
    */

  }, {
    key: 'getStartDTS',
    value: function getStartDTS(initData, fragment) {
      var trafs = void 0,
          baseTimes = void 0,
          result = void 0;

      // we need info from two childrend of each track fragment box
      trafs = MP4Demuxer.findBox(fragment, ['moof', 'traf']);

      // determine the start times for each track
      baseTimes = [].concat.apply([], trafs.map(function (traf) {
        return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
          var id = void 0,
              scale = void 0,
              baseTime = void 0;

          // get the track id from the tfhd
          id = MP4Demuxer.readUint32(tfhd, 4);
          // assume a 90kHz clock if no timescale was specified
          scale = initData[id].timescale || 90e3;

          // get the base media decode time from the tfdt
          baseTime = MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
            var version = void 0,
                result = void 0;

            version = tfdt.data[tfdt.start];
            result = MP4Demuxer.readUint32(tfdt, 4);
            if (version === 1) {
              result *= Math.pow(2, 32);

              result += MP4Demuxer.readUint32(tfdt, 8);
            }
            return result;
          })[0];
          // convert base time to seconds
          return baseTime / scale;
        });
      }));

      // return the minimum
      result = Math.min.apply(null, baseTimes);
      return isFinite(result) ? result : 0;
    }
  }, {
    key: 'offsetStartDTS',
    value: function offsetStartDTS(initData, fragment, timeOffset) {
      MP4Demuxer.findBox(fragment, ['moof', 'traf']).map(function (traf) {
        return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
          // get the track id from the tfhd
          var id = MP4Demuxer.readUint32(tfhd, 4);
          // assume a 90kHz clock if no timescale was specified
          var timescale = initData[id].timescale || 90e3;

          // get the base media decode time from the tfdt
          MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
            var version = tfdt.data[tfdt.start];
            var baseMediaDecodeTime = MP4Demuxer.readUint32(tfdt, 4);
            if (version === 0) {
              MP4Demuxer.writeUint32(tfdt, 4, baseMediaDecodeTime - timeOffset * timescale);
            } else {
              baseMediaDecodeTime *= Math.pow(2, 32);
              baseMediaDecodeTime += MP4Demuxer.readUint32(tfdt, 8);
              baseMediaDecodeTime -= timeOffset * timescale;
              baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
              var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
              var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
              MP4Demuxer.writeUint32(tfdt, 4, upper);
              MP4Demuxer.writeUint32(tfdt, 8, lower);
            }
          });
        });
      });
    }
  }]);

  return MP4Demuxer;
}();

exports.default = MP4Demuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/mpegaudio.js":
/*!***************************************!*\
  !*** ./src/hls.js/demux/mpegaudio.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 *  MPEG parser helper
 */

var MpegAudio = {

  BitratesMap: [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],

  SamplingRateMap: [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000],

  SamplesCoefficients: [
  // MPEG 2.5
  [0, // Reserved
  72, // Layer3
  144, // Layer2
  12 // Layer1
  ],
  // Reserved
  [0, // Reserved
  0, // Layer3
  0, // Layer2
  0 // Layer1
  ],
  // MPEG 2
  [0, // Reserved
  72, // Layer3
  144, // Layer2
  12 // Layer1
  ],
  // MPEG 1
  [0, // Reserved
  144, // Layer3
  144, // Layer2
  12 // Layer1
  ]],

  BytesInSlot: [0, // Reserved
  1, // Layer3
  1, // Layer2
  4 // Layer1
  ],

  appendFrame: function appendFrame(track, data, offset, pts, frameIndex) {
    // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference
    if (offset + 24 > data.length) {
      return undefined;
    }

    var header = this.parseHeader(data, offset);
    if (header && offset + header.frameLength <= data.length) {
      var frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;
      var stamp = pts + frameIndex * frameDuration;
      var sample = { unit: data.subarray(offset, offset + header.frameLength), pts: stamp, dts: stamp };

      track.config = [];
      track.channelCount = header.channelCount;
      track.samplerate = header.sampleRate;
      track.samples.push(sample);
      track.len += header.frameLength;

      return { sample: sample, length: header.frameLength };
    }

    return undefined;
  },

  parseHeader: function parseHeader(data, offset) {
    var headerB = data[offset + 1] >> 3 & 3;
    var headerC = data[offset + 1] >> 1 & 3;
    var headerE = data[offset + 2] >> 4 & 15;
    var headerF = data[offset + 2] >> 2 & 3;
    var headerG = data[offset + 2] >> 1 & 1;
    if (headerB !== 1 && headerE !== 0 && headerE !== 15 && headerF !== 3) {
      var columnInBitrates = headerB === 3 ? 3 - headerC : headerC === 3 ? 3 : 4;
      var bitRate = MpegAudio.BitratesMap[columnInBitrates * 14 + headerE - 1] * 1000;
      var columnInSampleRates = headerB === 3 ? 0 : headerB === 2 ? 1 : 2;
      var sampleRate = MpegAudio.SamplingRateMap[columnInSampleRates * 3 + headerF];
      var channelCount = data[offset + 3] >> 6 === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)
      var sampleCoefficient = MpegAudio.SamplesCoefficients[headerB][headerC];
      var bytesInSlot = MpegAudio.BytesInSlot[headerC];
      var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
      var frameLength = parseInt(sampleCoefficient * bitRate / sampleRate + headerG, 10) * bytesInSlot;

      return { sampleRate: sampleRate, channelCount: channelCount, frameLength: frameLength, samplesPerFrame: samplesPerFrame };
    }

    return undefined;
  },

  isHeaderPattern: function isHeaderPattern(data, offset) {
    return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;
  },

  isHeader: function isHeader(data, offset) {
    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
    // More info http://www.mp3-tech.org/programmer/frame_header.html
    if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
      return true;
    }

    return false;
  },

  probe: function probe(data, offset) {
    // same as isHeader but we also check that MPEG frame follows last MPEG frame
    // or end of data is reached
    if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
      // MPEG header Length
      var headerLength = 4;
      // MPEG frame Length
      var header = this.parseHeader(data, offset);
      var frameLength = headerLength;
      if (header && header.frameLength) {
        frameLength = header.frameLength;
      }

      var newOffset = offset + frameLength;
      if (newOffset === data.length || newOffset + 1 < data.length && this.isHeaderPattern(data, newOffset)) {
        return true;
      }
    }
    return false;
  }
};

exports.default = MpegAudio;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/demux/sample-aes.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/sample-aes.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * SAMPLE-AES decrypter
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _decrypter = __webpack_require__(/*! ../crypt/decrypter */ "./src/hls.js/crypt/decrypter.js");

var _decrypter2 = _interopRequireDefault(_decrypter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SampleAesDecrypter = function () {
  function SampleAesDecrypter(observer, config, decryptdata, discardEPB) {
    _classCallCheck(this, SampleAesDecrypter);

    this.decryptdata = decryptdata;
    this.discardEPB = discardEPB;
    this.decrypter = new _decrypter2.default(observer, config, { removePKCS7Padding: false });
  }

  _createClass(SampleAesDecrypter, [{
    key: 'decryptBuffer',
    value: function decryptBuffer(encryptedData, callback) {
      this.decrypter.decrypt(encryptedData, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, callback);
    }

    // AAC - encrypt all full 16 bytes blocks starting from offset 16

  }, {
    key: 'decryptAacSample',
    value: function decryptAacSample(samples, sampleIndex, callback, sync) {
      var curUnit = samples[sampleIndex].unit;
      var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
      var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);

      var localthis = this;
      this.decryptBuffer(encryptedBuffer, function (decryptedData) {
        decryptedData = new Uint8Array(decryptedData);
        curUnit.set(decryptedData, 16);

        if (!sync) {
          localthis.decryptAacSamples(samples, sampleIndex + 1, callback);
        }
      });
    }
  }, {
    key: 'decryptAacSamples',
    value: function decryptAacSamples(samples, sampleIndex, callback) {
      for (;; sampleIndex++) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }

        if (samples[sampleIndex].unit.length < 32) {
          continue;
        }

        var sync = this.decrypter.isSync();

        this.decryptAacSample(samples, sampleIndex, callback, sync);

        if (!sync) {
          return;
        }
      }
    }

    // AVC - encrypt one 16 bytes block out of ten, starting from offset 32

  }, {
    key: 'getAvcEncryptedData',
    value: function getAvcEncryptedData(decodedData) {
      var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
      var encryptedData = new Int8Array(encryptedDataLen);
      var outputPos = 0;
      for (var inputPos = 32; inputPos <= decodedData.length - 16; inputPos += 160, outputPos += 16) {
        encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
      }

      return encryptedData;
    }
  }, {
    key: 'getAvcDecryptedUnit',
    value: function getAvcDecryptedUnit(decodedData, decryptedData) {
      decryptedData = new Uint8Array(decryptedData);
      var inputPos = 0;
      for (var outputPos = 32; outputPos <= decodedData.length - 16; outputPos += 160, inputPos += 16) {
        decodedData.set(decryptedData.subarray(inputPos, inputPos + 16), outputPos);
      }

      return decodedData;
    }
  }, {
    key: 'decryptAvcSample',
    value: function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync) {
      var decodedData = this.discardEPB(curUnit.data);
      var encryptedData = this.getAvcEncryptedData(decodedData);
      var localthis = this;

      this.decryptBuffer(encryptedData.buffer, function (decryptedData) {
        curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedData);

        if (!sync) {
          localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
        }
      });
    }
  }, {
    key: 'decryptAvcSamples',
    value: function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
      for (;; sampleIndex++, unitIndex = 0) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }

        var curUnits = samples[sampleIndex].units;
        for (;; unitIndex++) {
          if (unitIndex >= curUnits.length) {
            break;
          }

          var curUnit = curUnits[unitIndex];
          if (curUnit.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
            continue;
          }

          var sync = this.decrypter.isSync();

          this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);

          if (!sync) {
            return;
          }
        }
      }
    }
  }]);

  return SampleAesDecrypter;
}();

exports.default = SampleAesDecrypter;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/tsdemuxer.js":
/*!***************************************!*\
  !*** ./src/hls.js/demux/tsdemuxer.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * highly optimized TS demuxer:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * parse PAT, PMT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract PES packet from audio and video PIDs
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * trigger the remuxer upon parsing completion
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also controls the remuxing process :
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

// import Hex from '../utils/hex';


var _adts = __webpack_require__(/*! ./adts */ "./src/hls.js/demux/adts.js");

var ADTS = _interopRequireWildcard(_adts);

var _mpegaudio = __webpack_require__(/*! ./mpegaudio */ "./src/hls.js/demux/mpegaudio.js");

var _mpegaudio2 = _interopRequireDefault(_mpegaudio);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _expGolomb = __webpack_require__(/*! ./exp-golomb */ "./src/hls.js/demux/exp-golomb.js");

var _expGolomb2 = _interopRequireDefault(_expGolomb);

var _sampleAes = __webpack_require__(/*! ./sample-aes */ "./src/hls.js/demux/sample-aes.js");

var _sampleAes2 = _interopRequireDefault(_sampleAes);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// We are using fixed track IDs for driving the MP4 remuxer
// instead of following the TS PIDs.
// There is no reason not to do this and some browsers/SourceBuffer-demuxers
// may not like if there are TrackID "switches"
// See https://github.com/video-dev/hls.js/issues/1331
// Here we are mapping our internal track types to constant MP4 track IDs
// With MSE currently one can only have one track of each, and we are muxing
// whatever video/audio rendition in them.
var RemuxerTrackIdConfig = {
  video: 1,
  audio: 2,
  id3: 3,
  text: 4
};

var TSDemuxer = function () {
  function TSDemuxer(observer, remuxer, config, typeSupported) {
    _classCallCheck(this, TSDemuxer);

    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    this.remuxer = remuxer;
    this.sampleAes = null;
  }

  _createClass(TSDemuxer, [{
    key: 'setDecryptData',
    value: function setDecryptData(decryptdata) {
      if (decryptdata != null && decryptdata.key != null && decryptdata.method === 'SAMPLE-AES') {
        this.sampleAes = new _sampleAes2.default(this.observer, this.config, decryptdata, this.discardEPB);
      } else {
        this.sampleAes = null;
      }
    }
  }, {
    key: 'resetInitSegment',


    /**
     * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
     * Resets all internal track instances of the demuxer.
     *
     * @override Implements generic demuxing/remuxing interface (see DemuxerInline)
     * @param {object} initSegment
     * @param {string} audioCodec
     * @param {string} videoCodec
     * @param {number} duration (in TS timescale = 90kHz)
     */
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this.pmtParsed = false;
      this._pmtId = -1;

      this._avcTrack = TSDemuxer.createTrack('video', duration);
      this._audioTrack = TSDemuxer.createTrack('audio', duration);
      this._id3Track = TSDemuxer.createTrack('id3', duration);
      this._txtTrack = TSDemuxer.createTrack('text', duration);

      // flush any partial content
      this.aacOverFlow = null;
      this.aacLastPTS = null;
      this.avcSample = null;
      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this._duration = duration;
    }

    /**
     *
     * @override
     */

  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}

    // feed incoming data to the front of the parsing pipeline

  }, {
    key: 'append',
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var start = void 0,
          len = data.length,
          stt = void 0,
          pid = void 0,
          atf = void 0,
          offset = void 0,
          pes = void 0,
          unknownPIDs = false;
      this.contiguous = contiguous;
      var pmtParsed = this.pmtParsed,
          avcTrack = this._avcTrack,
          audioTrack = this._audioTrack,
          id3Track = this._id3Track,
          avcId = avcTrack.pid,
          audioId = audioTrack.pid,
          id3Id = id3Track.pid,
          pmtId = this._pmtId,
          avcData = avcTrack.pesData,
          audioData = audioTrack.pesData,
          id3Data = id3Track.pesData,
          parsePAT = this._parsePAT,
          parsePMT = this._parsePMT,
          parsePES = this._parsePES,
          parseAVCPES = this._parseAVCPES.bind(this),
          parseAACPES = this._parseAACPES.bind(this),
          parseMPEGPES = this._parseMPEGPES.bind(this),
          parseID3PES = this._parseID3PES.bind(this);

      var syncOffset = TSDemuxer._syncOffset(data);

      // don't parse last TS packet if incomplete
      len -= (len + syncOffset) % 188;

      // loop through TS packets
      for (start = syncOffset; start < len; start += 188) {
        if (data[start] === 0x47) {
          stt = !!(data[start + 1] & 0x40);
          // pid is a 13-bit field starting at the last bit of TS[1]
          pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
          atf = (data[start + 3] & 0x30) >> 4;
          // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
          if (atf > 1) {
            offset = start + 5 + data[start + 4];
            // continue if there is only adaptation field
            if (offset === start + 188) {
              continue;
            }
          } else {
            offset = start + 4;
          }
          switch (pid) {
            case avcId:
              if (stt) {
                if (avcData && (pes = parsePES(avcData)) && pes.pts !== undefined) {
                  parseAVCPES(pes, false);
                }

                avcData = { data: [], size: 0 };
              }
              if (avcData) {
                avcData.data.push(data.subarray(offset, start + 188));
                avcData.size += start + 188 - offset;
              }
              break;
            case audioId:
              if (stt) {
                if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {
                  if (audioTrack.isAAC) {
                    parseAACPES(pes);
                  } else {
                    parseMPEGPES(pes);
                  }
                }
                audioData = { data: [], size: 0 };
              }
              if (audioData) {
                audioData.data.push(data.subarray(offset, start + 188));
                audioData.size += start + 188 - offset;
              }
              break;
            case id3Id:
              if (stt) {
                if (id3Data && (pes = parsePES(id3Data)) && pes.pts !== undefined) {
                  parseID3PES(pes);
                }

                id3Data = { data: [], size: 0 };
              }
              if (id3Data) {
                id3Data.data.push(data.subarray(offset, start + 188));
                id3Data.size += start + 188 - offset;
              }
              break;
            case 0:
              if (stt) {
                offset += data[offset] + 1;
              }

              pmtId = this._pmtId = parsePAT(data, offset);
              break;
            case pmtId:
              if (stt) {
                offset += data[offset] + 1;
              }

              var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, this.sampleAes != null);

              // only update track id if track PID found while parsing PMT
              // this is to avoid resetting the PID to -1 in case
              // track PID transiently disappears from the stream
              // this could happen in case of transient missing audio samples for example
              // NOTE this is only the PID of the track as found in TS,
              // but we are not using this for MP4 track IDs.
              avcId = parsedPIDs.avc;
              if (avcId > 0) {
                avcTrack.pid = avcId;
              }

              audioId = parsedPIDs.audio;
              if (audioId > 0) {
                audioTrack.pid = audioId;
                audioTrack.isAAC = parsedPIDs.isAAC;
              }
              id3Id = parsedPIDs.id3;
              if (id3Id > 0) {
                id3Track.pid = id3Id;
              }

              if (unknownPIDs && !pmtParsed) {
                _logger.logger.log('reparse from beginning');
                unknownPIDs = false;
                // we set it to -188, the += 188 in the for loop will reset start to 0
                start = syncOffset - 188;
              }
              pmtParsed = this.pmtParsed = true;
              break;
            case 17:
            case 0x1fff:
              break;
            default:
              unknownPIDs = true;
              break;
          }
        } else {
          this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });
        }
      }
      // try to parse last PES packets
      if (avcData && (pes = parsePES(avcData)) && pes.pts !== undefined) {
        parseAVCPES(pes, true);
        avcTrack.pesData = null;
      } else {
        // either avcData null or PES truncated, keep it for next frag parsing
        avcTrack.pesData = avcData;
      }

      if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {
        if (audioTrack.isAAC) {
          parseAACPES(pes);
        } else {
          parseMPEGPES(pes);
        }

        audioTrack.pesData = null;
      } else {
        if (audioData && audioData.size) {
          _logger.logger.log('last AAC PES packet truncated,might overlap between fragments');
        }

        // either audioData null or PES truncated, keep it for next frag parsing
        audioTrack.pesData = audioData;
      }

      if (id3Data && (pes = parsePES(id3Data)) && pes.pts !== undefined) {
        parseID3PES(pes);
        id3Track.pesData = null;
      } else {
        // either id3Data null or PES truncated, keep it for next frag parsing
        id3Track.pesData = id3Data;
      }

      if (this.sampleAes == null) {
        this.remuxer.remux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
      } else {
        this.decryptAndRemux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'decryptAndRemux',
    value: function decryptAndRemux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      if (audioTrack.samples && audioTrack.isAAC) {
        var localthis = this;
        this.sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {
          localthis.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
        });
      } else {
        this.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'decryptAndRemuxAvc',
    value: function decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      if (videoTrack.samples) {
        var localthis = this;
        this.sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {
          localthis.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
        });
      } else {
        this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this._initPTS = this._initDTS = undefined;
      this._duration = 0;
    }
  }, {
    key: '_parsePAT',
    value: function _parsePAT(data, offset) {
      // skip the PSI header and parse the first PMT entry
      return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];
      // logger.log('PMT PID:'  + this._pmtId);
    }
  }, {
    key: '_parsePMT',
    value: function _parsePMT(data, offset, mpegSupported, isSampleAes) {
      var sectionLength = void 0,
          tableEnd = void 0,
          programInfoLength = void 0,
          pid = void 0,
          result = { audio: -1, avc: -1, id3: -1, isAAC: true };
      sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
      tableEnd = offset + 3 + sectionLength - 4;
      // to determine where the table is, we have to figure out how
      // long the program info descriptors are
      programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];
      // advance the offset to the first entry in the mapping table
      offset += 12 + programInfoLength;
      while (offset < tableEnd) {
        pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];
        switch (data[offset]) {
          case 0xcf:
            // SAMPLE-AES AAC
            if (!isSampleAes) {
              _logger.logger.log('unkown stream type:' + data[offset]);
              break;
            }
          /* falls through */

          // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
          case 0x0f:
            // logger.log('AAC PID:'  + pid);
            if (result.audio === -1) {
              result.audio = pid;
            }

            break;

          // Packetized metadata (ID3)
          case 0x15:
            // logger.log('ID3 PID:'  + pid);
            if (result.id3 === -1) {
              result.id3 = pid;
            }

            break;

          case 0xdb:
            // SAMPLE-AES AVC
            if (!isSampleAes) {
              _logger.logger.log('unkown stream type:' + data[offset]);
              break;
            }
          /* falls through */

          // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
          case 0x1b:
            // logger.log('AVC PID:'  + pid);
            if (result.avc === -1) {
              result.avc = pid;
            }

            break;

          // ISO/IEC 11172-3 (MPEG-1 audio)
          // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
          case 0x03:
          case 0x04:
            // logger.log('MPEG PID:'  + pid);
            if (!mpegSupported) {
              _logger.logger.log('MPEG audio found, not supported in this browser for now');
            } else if (result.audio === -1) {
              result.audio = pid;
              result.isAAC = false;
            }
            break;

          case 0x24:
            _logger.logger.warn('HEVC stream type found, not supported for now');
            break;

          default:
            _logger.logger.log('unkown stream type:' + data[offset]);
            break;
        }
        // move to the next table entry
        // skip past the elementary stream descriptors, if present
        offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;
      }
      return result;
    }
  }, {
    key: '_parsePES',
    value: function _parsePES(stream) {
      var i = 0,
          frag = void 0,
          pesFlags = void 0,
          pesPrefix = void 0,
          pesLen = void 0,
          pesHdrLen = void 0,
          pesData = void 0,
          pesPts = void 0,
          pesDts = void 0,
          payloadStartOffset = void 0,
          data = stream.data;
      // safety check
      if (!stream || stream.size === 0) {
        return null;
      }

      // we might need up to 19 bytes to read PES header
      // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
      // usually only one merge is needed (and this is rare ...)
      while (data[0].length < 19 && data.length > 1) {
        var newData = new Uint8Array(data[0].length + data[1].length);
        newData.set(data[0]);
        newData.set(data[1], data[0].length);
        data[0] = newData;
        data.splice(1, 1);
      }
      // retrieve PTS/DTS from first fragment
      frag = data[0];
      pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
      if (pesPrefix === 1) {
        pesLen = (frag[4] << 8) + frag[5];
        // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated
        // minus 6 : PES header size
        if (pesLen && pesLen > stream.size - 6) {
          return null;
        }

        pesFlags = frag[7];
        if (pesFlags & 0xC0) {
          /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
              as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
              as Bitwise operators treat their operands as a sequence of 32 bits */
          pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29
          (frag[10] & 0xFF) * 4194304 + // 1 << 22
          (frag[11] & 0xFE) * 16384 + // 1 << 14
          (frag[12] & 0xFF) * 128 + // 1 << 7
          (frag[13] & 0xFE) / 2;
          // check if greater than 2^32 -1
          if (pesPts > 4294967295) {
            // decrement 2^33
            pesPts -= 8589934592;
          }
          if (pesFlags & 0x40) {
            pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29
            (frag[15] & 0xFF) * 4194304 + // 1 << 22
            (frag[16] & 0xFE) * 16384 + // 1 << 14
            (frag[17] & 0xFF) * 128 + // 1 << 7
            (frag[18] & 0xFE) / 2;
            // check if greater than 2^32 -1
            if (pesDts > 4294967295) {
              // decrement 2^33
              pesDts -= 8589934592;
            }
            if (pesPts - pesDts > 60 * 90000) {
              _logger.logger.warn(Math.round((pesPts - pesDts) / 90000) + 's delta between PTS and DTS, align them');
              pesPts = pesDts;
            }
          } else {
            pesDts = pesPts;
          }
        }
        pesHdrLen = frag[8];
        // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension
        payloadStartOffset = pesHdrLen + 9;

        stream.size -= payloadStartOffset;
        // reassemble PES packet
        pesData = new Uint8Array(stream.size);
        for (var j = 0, dataLen = data.length; j < dataLen; j++) {
          frag = data[j];
          var len = frag.byteLength;
          if (payloadStartOffset) {
            if (payloadStartOffset > len) {
              // trim full frag if PES header bigger than frag
              payloadStartOffset -= len;
              continue;
            } else {
              // trim partial frag if PES header smaller than frag
              frag = frag.subarray(payloadStartOffset);
              len -= payloadStartOffset;
              payloadStartOffset = 0;
            }
          }
          pesData.set(frag, i);
          i += len;
        }
        if (pesLen) {
          // payload size : remove PES header + PES extension
          pesLen -= pesHdrLen + 3;
        }
        return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };
      } else {
        return null;
      }
    }
  }, {
    key: 'pushAccesUnit',
    value: function pushAccesUnit(avcSample, avcTrack) {
      if (avcSample.units.length && avcSample.frame) {
        var samples = avcTrack.samples;
        var nbSamples = samples.length;
        // only push AVC sample if starting with a keyframe is not mandatory OR
        //    if keyframe already found in this fragment OR
        //       keyframe found in last fragment (track.sps) AND
        //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
        if (!this.config.forceKeyFrameOnDiscontinuity || avcSample.key === true || avcTrack.sps && (nbSamples || this.contiguous)) {
          avcSample.id = nbSamples;
          samples.push(avcSample);
        } else {
          // dropped samples, track it
          avcTrack.dropped++;
        }
      }
      if (avcSample.debug.length) {
        _logger.logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);
      }
    }
  }, {
    key: '_parseAVCPES',
    value: function _parseAVCPES(pes, last) {
      var _this = this;

      // logger.log('parse new PES');
      var track = this._avcTrack,
          units = this._parseAVCNALu(pes.data),
          debug = false,
          expGolombDecoder = void 0,
          avcSample = this.avcSample,
          push = void 0,
          spsfound = false,
          i = void 0,
          pushAccesUnit = this.pushAccesUnit.bind(this),
          createAVCSample = function createAVCSample(key, pts, dts, debug) {
        return { key: key, pts: pts, dts: dts, units: [], debug: debug };
      };
      // free pes.data to save up some memory
      pes.data = null;

      // if new NAL units found and last sample still there, let's push ...
      // this helps parsing streams with missing AUD (only do this if AUD never found)
      if (avcSample && units.length && !track.audFound) {
        pushAccesUnit(avcSample, track);
        avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');
      }

      units.forEach(function (unit) {
        switch (unit.type) {
          // NDR
          case 1:
            push = true;
            if (!avcSample) {
              avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');
            }

            if (debug) {
              avcSample.debug += 'NDR ';
            }

            avcSample.frame = true;
            var data = unit.data;
            // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)
            if (spsfound && data.length > 4) {
              // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR
              var sliceType = new _expGolomb2.default(data).readSliceType();
              // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice
              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.
              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.
              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.
              // if (sliceType === 2 || sliceType === 7) {
              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                avcSample.key = true;
              }
            }
            break;
          // IDR
          case 5:
            push = true;
            // handle PES not starting with AUD
            if (!avcSample) {
              avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');
            }

            if (debug) {
              avcSample.debug += 'IDR ';
            }

            avcSample.key = true;
            avcSample.frame = true;
            break;
          // SEI
          case 6:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'SEI ';
            }

            expGolombDecoder = new _expGolomb2.default(_this.discardEPB(unit.data));

            // skip frameType
            expGolombDecoder.readUByte();

            var payloadType = 0;
            var payloadSize = 0;
            var endOfCaptions = false;
            var b = 0;

            while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
              payloadType = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadType += b;
              } while (b === 0xFF);

              // Parse payload size.
              payloadSize = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadSize += b;
              } while (b === 0xFF);

              // TODO: there can be more than one payload in an SEI packet...
              // TODO: need to read type and size in a while loop to get them all
              if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {
                endOfCaptions = true;

                var countryCode = expGolombDecoder.readUByte();

                if (countryCode === 181) {
                  var providerCode = expGolombDecoder.readUShort();

                  if (providerCode === 49) {
                    var userStructure = expGolombDecoder.readUInt();

                    if (userStructure === 0x47413934) {
                      var userDataType = expGolombDecoder.readUByte();

                      // Raw CEA-608 bytes wrapped in CEA-708 packet
                      if (userDataType === 3) {
                        var firstByte = expGolombDecoder.readUByte();
                        var secondByte = expGolombDecoder.readUByte();

                        var totalCCs = 31 & firstByte;
                        var byteArray = [firstByte, secondByte];

                        for (i = 0; i < totalCCs; i++) {
                          // 3 bytes per CC
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                        }

                        _this._insertSampleInOrder(_this._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });
                      }
                    }
                  }
                }
              } else if (payloadSize < expGolombDecoder.bytesAvailable) {
                for (i = 0; i < payloadSize; i++) {
                  expGolombDecoder.readUByte();
                }
              }
            }
            break;
          // SPS
          case 7:
            push = true;
            spsfound = true;
            if (debug && avcSample) {
              avcSample.debug += 'SPS ';
            }

            if (!track.sps) {
              expGolombDecoder = new _expGolomb2.default(unit.data);
              var config = expGolombDecoder.readSPS();
              track.width = config.width;
              track.height = config.height;
              track.pixelRatio = config.pixelRatio;
              track.sps = [unit.data];
              track.duration = _this._duration;
              var codecarray = unit.data.subarray(1, 4);
              var codecstring = 'avc1.';
              for (i = 0; i < 3; i++) {
                var h = codecarray[i].toString(16);
                if (h.length < 2) {
                  h = '0' + h;
                }

                codecstring += h;
              }
              track.codec = codecstring;
            }
            break;
          // PPS
          case 8:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'PPS ';
            }

            if (!track.pps) {
              track.pps = [unit.data];
            }

            break;
          // AUD
          case 9:
            push = false;
            track.audFound = true;
            if (avcSample) {
              pushAccesUnit(avcSample, track);
            }

            avcSample = _this.avcSample = createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');
            break;
          // Filler Data
          case 12:
            push = false;
            break;
          default:
            push = false;
            if (avcSample) {
              avcSample.debug += 'unknown NAL ' + unit.type + ' ';
            }

            break;
        }
        if (avcSample && push) {
          var _units = avcSample.units;
          _units.push(unit);
        }
      });
      // if last PES packet, push samples
      if (last && avcSample) {
        pushAccesUnit(avcSample, track);
        this.avcSample = null;
      }
    }
  }, {
    key: '_insertSampleInOrder',
    value: function _insertSampleInOrder(arr, data) {
      var len = arr.length;
      if (len > 0) {
        if (data.pts >= arr[len - 1].pts) {
          arr.push(data);
        } else {
          for (var pos = len - 1; pos >= 0; pos--) {
            if (data.pts < arr[pos].pts) {
              arr.splice(pos, 0, data);
              break;
            }
          }
        }
      } else {
        arr.push(data);
      }
    }
  }, {
    key: '_getLastNalUnit',
    value: function _getLastNalUnit() {
      var avcSample = this.avcSample,
          lastUnit = void 0;
      // try to fallback to previous sample if current one is empty
      if (!avcSample || avcSample.units.length === 0) {
        var track = this._avcTrack,
            samples = track.samples;
        avcSample = samples[samples.length - 1];
      }
      if (avcSample) {
        var units = avcSample.units;
        lastUnit = units[units.length - 1];
      }
      return lastUnit;
    }
  }, {
    key: '_parseAVCNALu',
    value: function _parseAVCNALu(array) {
      var i = 0,
          len = array.byteLength,
          value = void 0,
          overflow = void 0,
          track = this._avcTrack,
          state = track.naluState || 0,
          lastState = state;
      var units = [],
          unit = void 0,
          unitType = void 0,
          lastUnitStart = -1,
          lastUnitType = void 0;
      // logger.log('PES:' + Hex.hexDump(array));

      if (state === -1) {
        // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
        lastUnitStart = 0;
        // NALu type is value read from offset 0
        lastUnitType = array[0] & 0x1f;
        state = 0;
        i = 1;
      }

      while (i < len) {
        value = array[i++];
        // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case
        if (!state) {
          state = value ? 0 : 1;
          continue;
        }
        if (state === 1) {
          state = value ? 0 : 2;
          continue;
        }
        // here we have state either equal to 2 or 3
        if (!value) {
          state = 3;
        } else if (value === 1) {
          if (lastUnitStart >= 0) {
            unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
            // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
            units.push(unit);
          } else {
            // lastUnitStart is undefined => this is the first start code found in this PES packet
            // first check if start code delimiter is overlapping between 2 PES packets,
            // ie it started in last packet (lastState not zero)
            // and ended at the beginning of this PES packet (i <= 4 - lastState)
            var lastUnit = this._getLastNalUnit();
            if (lastUnit) {
              if (lastState && i <= 4 - lastState) {
                // start delimiter overlapping between PES packets
                // strip start delimiter bytes from the end of last NAL unit
                // check if lastUnit had a state different from zero
                if (lastUnit.state) {
                  // strip last bytes
                  lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                }
              }
              // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
              overflow = i - state - 1;
              if (overflow > 0) {
                // logger.log('first NALU found with overflow:' + overflow);
                var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
                tmp.set(lastUnit.data, 0);
                tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
                lastUnit.data = tmp;
              }
            }
          }
          // check if we can read unit type
          if (i < len) {
            unitType = array[i] & 0x1f;
            // logger.log('find NALU @ offset:' + i + ',type:' + unitType);
            lastUnitStart = i;
            lastUnitType = unitType;
            state = 0;
          } else {
            // not enough byte to read unit type. let's read it on next PES parsing
            state = -1;
          }
        } else {
          state = 0;
        }
      }
      if (lastUnitStart >= 0 && state >= 0) {
        unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
        units.push(unit);
        // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
      }
      // no NALu found
      if (units.length === 0) {
        // append pes.data to previous NAL unit
        var _lastUnit = this._getLastNalUnit();
        if (_lastUnit) {
          var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);
          _tmp.set(_lastUnit.data, 0);
          _tmp.set(array, _lastUnit.data.byteLength);
          _lastUnit.data = _tmp;
        }
      }
      track.naluState = state;
      return units;
    }

    /**
     * remove Emulation Prevention bytes from a RBSP
     */

  }, {
    key: 'discardEPB',
    value: function discardEPB(data) {
      var length = data.byteLength,
          EPBPositions = [],
          i = 1,
          newLength = void 0,
          newData = void 0;

      // Find all `Emulation Prevention Bytes`
      while (i < length - 2) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
          EPBPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }

      // If no Emulation Prevention Bytes were found just return the original
      // array
      if (EPBPositions.length === 0) {
        return data;
      }

      // Create a new array to hold the NAL unit data
      newLength = length - EPBPositions.length;
      newData = new Uint8Array(newLength);
      var sourceIndex = 0;

      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === EPBPositions[0]) {
          // Skip this byte
          sourceIndex++;
          // Remove this position index
          EPBPositions.shift();
        }
        newData[i] = data[sourceIndex];
      }
      return newData;
    }
  }, {
    key: '_parseAACPES',
    value: function _parseAACPES(pes) {
      var track = this._audioTrack,
          data = pes.data,
          pts = pes.pts,
          startOffset = 0,
          aacOverFlow = this.aacOverFlow,
          aacLastPTS = this.aacLastPTS,
          frameDuration = void 0,
          frameIndex = void 0,
          offset = void 0,
          stamp = void 0,
          len = void 0;
      if (aacOverFlow) {
        var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
        tmp.set(aacOverFlow, 0);
        tmp.set(data, aacOverFlow.byteLength);
        // logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);
        data = tmp;
      }
      // look for ADTS header (0xFFFx)
      for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
        if (ADTS.isHeader(data, offset)) {
          break;
        }
      }
      // if ADTS header does not start straight from the beginning of the PES payload, raise an error
      if (offset) {
        var reason = void 0,
            fatal = void 0;
        if (offset < len - 1) {
          reason = 'AAC PES did not start with ADTS header,offset:' + offset;
          fatal = false;
        } else {
          reason = 'no ADTS header found in AAC PES';
          fatal = true;
        }
        _logger.logger.warn('parsing error:' + reason);
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });
        if (fatal) {
          return;
        }
      }

      ADTS.initTrackConfig(track, this.observer, data, offset, this.audioCodec);
      frameIndex = 0;
      frameDuration = ADTS.getFrameDuration(track.samplerate);

      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
      // first sample PTS should be equal to last sample PTS + frameDuration
      if (aacOverFlow && aacLastPTS) {
        var newPTS = aacLastPTS + frameDuration;
        if (Math.abs(newPTS - pts) > 1) {
          _logger.logger.log('AAC: align PTS for overlapping frames by ' + Math.round((newPTS - pts) / 90));
          pts = newPTS;
        }
      }

      // scan for aac samples
      while (offset < len) {
        if (ADTS.isHeader(data, offset) && offset + 5 < len) {
          var frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);
          if (frame) {
            // logger.log(`${Math.round(frame.sample.pts)} : AAC`);
            offset += frame.length;
            stamp = frame.sample.pts;
            frameIndex++;
          } else {
            // logger.log('Unable to parse AAC frame');
            break;
          }
        } else {
          // nothing found, keep looking
          offset++;
        }
      }

      if (offset < len) {
        aacOverFlow = data.subarray(offset, len);
        // logger.log(`AAC: overflow detected:${len-offset}`);
      } else {
        aacOverFlow = null;
      }

      this.aacOverFlow = aacOverFlow;
      this.aacLastPTS = stamp;
    }
  }, {
    key: '_parseMPEGPES',
    value: function _parseMPEGPES(pes) {
      var data = pes.data;
      var length = data.length;
      var frameIndex = 0;
      var offset = 0;
      var pts = pes.pts;

      while (offset < length) {
        if (_mpegaudio2.default.isHeader(data, offset)) {
          var frame = _mpegaudio2.default.appendFrame(this._audioTrack, data, offset, pts, frameIndex);
          if (frame) {
            offset += frame.length;
            frameIndex++;
          } else {
            // logger.log('Unable to parse Mpeg audio frame');
            break;
          }
        } else {
          // nothing found, keep looking
          offset++;
        }
      }
    }
  }, {
    key: '_parseID3PES',
    value: function _parseID3PES(pes) {
      this._id3Track.samples.push(pes);
    }
  }], [{
    key: 'probe',
    value: function probe(data) {
      var syncOffset = TSDemuxer._syncOffset(data);
      if (syncOffset < 0) {
        return false;
      } else {
        if (syncOffset) {
          _logger.logger.warn('MPEG2-TS detected but first sync word found @ offset ' + syncOffset + ', junk ahead ?');
        }

        return true;
      }
    }
  }, {
    key: '_syncOffset',
    value: function _syncOffset(data) {
      // scan 1000 first bytes
      var scanwindow = Math.min(1000, data.length - 3 * 188);
      var i = 0;
      while (i < scanwindow) {
        // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
        if (data[i] === 0x47 && data[i + 188] === 0x47 && data[i + 2 * 188] === 0x47) {
          return i;
        } else {
          i++;
        }
      }
      return -1;
    }

    /**
     * Creates a track model internal to demuxer used to drive remuxing input
     *
     * @param {string} type 'audio' | 'video' | 'id3' | 'text'
     * @param {number} duration
     * @return {object} TSDemuxer's internal track model
     */

  }, {
    key: 'createTrack',
    value: function createTrack(type, duration) {
      return {
        container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,
        type: type,
        id: RemuxerTrackIdConfig[type],
        pid: -1,
        inputTimeScale: 90000,
        sequenceNumber: 0,
        samples: [],
        len: 0,
        dropped: type === 'video' ? 0 : undefined,
        isAAC: type === 'audio' ? true : undefined,
        duration: type === 'audio' ? duration : undefined
      };
    }
  }]);

  return TSDemuxer;
}();

exports.default = TSDemuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/errors.js":
/*!******************************!*\
  !*** ./src/hls.js/errors.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var ErrorTypes = exports.ErrorTypes = {
  // Identifier for a network error (loading error / timeout ...)
  NETWORK_ERROR: 'networkError',
  // Identifier for a media Error (video/parsing/mediasource error)
  MEDIA_ERROR: 'mediaError',
  // EME (encrypted media extensions) errors
  KEY_SYSTEM_ERROR: 'keySystemError',
  // Identifier for a mux Error (demuxing/remuxing)
  MUX_ERROR: 'muxError',
  // Identifier for all other errors
  OTHER_ERROR: 'otherError'
};

/**
 * @enum {ErrorDetails}
 * @typedef {string} ErrorDetail
 */
var ErrorDetails = exports.ErrorDetails = {
  KEY_SYSTEM_NO_KEYS: 'keySystemNoKeys',
  KEY_SYSTEM_NO_ACCESS: 'keySystemNoAccess',
  KEY_SYSTEM_NO_SESSION: 'keySystemNoSession',
  KEY_SYSTEM_LICENSE_REQUEST_FAILED: 'keySystemLicenseRequestFailed',
  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_ERROR: 'manifestLoadError',
  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',
  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
  MANIFEST_PARSING_ERROR: 'manifestParsingError',
  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
  MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',
  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_ERROR: 'levelLoadError',
  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',
  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
  LEVEL_SWITCH_ERROR: 'levelSwitchError',
  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',
  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',
  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  FRAG_LOAD_ERROR: 'fragLoadError',
  // Identifier for fragment load timeout error - data: { frag : fragment object}
  FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',
  // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }
  FRAG_DECRYPT_ERROR: 'fragDecryptError',
  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
  FRAG_PARSING_ERROR: 'fragParsingError',
  // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }
  REMUX_ALLOC_ERROR: 'remuxAllocError',
  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  KEY_LOAD_ERROR: 'keyLoadError',
  // Identifier for decrypt key load timeout error - data: { frag : fragment object}
  KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',
  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
  BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',
  // Identifier for a buffer append error - data: append error description
  BUFFER_APPEND_ERROR: 'bufferAppendError',
  // Identifier for a buffer appending error event - data: appending error description
  BUFFER_APPENDING_ERROR: 'bufferAppendingError',
  // Identifier for a buffer stalled error event
  BUFFER_STALLED_ERROR: 'bufferStalledError',
  // Identifier for a buffer full event
  BUFFER_FULL_ERROR: 'bufferFullError',
  // Identifier for a buffer seek over hole event
  BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',
  // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)
  BUFFER_NUDGE_ON_STALL: 'bufferNudgeOnStall',
  // Identifier for an internal exception happening inside hls.js while handling an event
  INTERNAL_EXCEPTION: 'internalException'
};

/***/ }),

/***/ "./src/hls.js/event-handler.js":
/*!*************************************!*\
  !*** ./src/hls.js/event-handler.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * All objects in the event handling chain should inherit from this class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = __webpack_require__(/*! ./utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ./errors */ "./src/hls.js/errors.js");

var _events = __webpack_require__(/*! ./events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FORBIDDEN_EVENT_NAMES = {
  'hlsEventGeneric': true,
  'hlsHandlerDestroying': true,
  'hlsHandlerDestroyed': true
};

var EventHandler = function () {
  function EventHandler(hls) {
    _classCallCheck(this, EventHandler);

    this.hls = hls;
    this.onEvent = this.onEvent.bind(this);

    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      events[_key - 1] = arguments[_key];
    }

    this.handledEvents = events;
    this.useGenericHandler = true;

    this.registerListeners();
  }

  _createClass(EventHandler, [{
    key: 'destroy',
    value: function destroy() {
      this.onHandlerDestroying();
      this.unregisterListeners();
      this.onHandlerDestroyed();
    }
  }, {
    key: 'onHandlerDestroying',
    value: function onHandlerDestroying() {}
  }, {
    key: 'onHandlerDestroyed',
    value: function onHandlerDestroyed() {}
  }, {
    key: 'isEventHandler',
    value: function isEventHandler() {
      return _typeof(this.handledEvents) === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';
    }
  }, {
    key: 'registerListeners',
    value: function registerListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          if (FORBIDDEN_EVENT_NAMES[event]) {
            throw new Error('Forbidden event-name: ' + event);
          }

          this.hls.on(event, this.onEvent);
        }, this);
      }
    }
  }, {
    key: 'unregisterListeners',
    value: function unregisterListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          this.hls.off(event, this.onEvent);
        }, this);
      }
    }

    /**
     * arguments: event (string), data (any)
     */

  }, {
    key: 'onEvent',
    value: function onEvent(event, data) {
      this.onEventGeneric(event, data);
    }
  }, {
    key: 'onEventGeneric',
    value: function onEventGeneric(event, data) {
      var eventToFunction = function eventToFunction(event, data) {
        var funcName = 'on' + event.replace('hls', '');
        if (typeof this[funcName] !== 'function') {
          throw new Error('Event ' + event + ' has no generic handler in this ' + this.constructor.name + ' class (tried ' + funcName + ')');
        }

        return this[funcName].bind(this, data);
      };
      try {
        eventToFunction.call(this, event, data).call();
      } catch (err) {
        _logger.logger.error('An internal error happened while handling event ' + event + '. Error message: "' + err.message + '". Here is a stacktrace:', err);
        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: event, err: err });
      }
    }
  }]);

  return EventHandler;
}();

exports.default = EventHandler;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/events.js":
/*!******************************!*\
  !*** ./src/hls.js/events.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @readonly
 * @enum {string}
 */
var HlsEvents = {
  // fired before MediaSource is attaching to media element - data: { media }
  MEDIA_ATTACHING: 'hlsMediaAttaching',
  // fired when MediaSource has been succesfully attached to media element - data: { }
  MEDIA_ATTACHED: 'hlsMediaAttached',
  // fired before detaching MediaSource from media element - data: { }
  MEDIA_DETACHING: 'hlsMediaDetaching',
  // fired when MediaSource has been detached from media element - data: { }
  MEDIA_DETACHED: 'hlsMediaDetached',
  // fired when we buffer is going to be reset - data: { }
  BUFFER_RESET: 'hlsBufferReset',
  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
  BUFFER_CODECS: 'hlsBufferCodecs',
  // fired when sourcebuffers have been created - data: { tracks : tracks }
  BUFFER_CREATED: 'hlsBufferCreated',
  // fired when we append a segment to the buffer - data: { segment: segment object }
  BUFFER_APPENDING: 'hlsBufferAppending',
  // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
  BUFFER_APPENDED: 'hlsBufferAppended',
  // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
  BUFFER_EOS: 'hlsBufferEos',
  // fired when the media buffer should be flushed - data { startOffset, endOffset }
  BUFFER_FLUSHING: 'hlsBufferFlushing',
  // fired when the media buffer has been flushed - data: { }
  BUFFER_FLUSHED: 'hlsBufferFlushed',
  // fired to signal that a manifest loading starts - data: { url : manifestURL}
  MANIFEST_LOADING: 'hlsManifestLoading',
  // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
  MANIFEST_LOADED: 'hlsManifestLoaded',
  // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
  MANIFEST_PARSED: 'hlsManifestParsed',
  // fired when a level switch is requested - data: { level : id of new level }
  LEVEL_SWITCHING: 'hlsLevelSwitching',
  // fired when a level switch is effective - data: { level : id of new level }
  LEVEL_SWITCHED: 'hlsLevelSwitched',
  // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
  LEVEL_LOADING: 'hlsLevelLoading',
  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
  LEVEL_LOADED: 'hlsLevelLoaded',
  // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
  LEVEL_UPDATED: 'hlsLevelUpdated',
  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
  // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
  // fired when an audio track switching is requested - data: { id : audio track id }
  AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',
  // fired when an audio track switch actually occurs - data: { id : audio track id }
  AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',
  // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
  // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
  // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
  SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',
  // fired when an subtitle track switch occurs - data: { id : subtitle track id }
  SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',
  // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
  SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',
  // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
  SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',
  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
  SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',
  // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
  INIT_PTS_FOUND: 'hlsInitPtsFound',
  // fired when a fragment loading starts - data: { frag : fragment object }
  FRAG_LOADING: 'hlsFragLoading',
  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
  // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
  FRAG_LOADED: 'hlsFragLoaded',
  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }
  FRAG_DECRYPTED: 'hlsFragDecrypted',
  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
  // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
  FRAG_PARSING_DATA: 'hlsFragParsingData',
  // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
  FRAG_PARSED: 'hlsFragParsed',
  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
  FRAG_BUFFERED: 'hlsFragBuffered',
  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
  FRAG_CHANGED: 'hlsFragChanged',
  // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
  FPS_DROP: 'hlsFpsDrop',
  // triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
  ERROR: 'hlsError',
  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
  DESTROYING: 'hlsDestroying',
  // fired when a decrypt key loading starts - data: { frag : fragment object }
  KEY_LOADING: 'hlsKeyLoading',
  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
  KEY_LOADED: 'hlsKeyLoaded',
  // fired upon stream controller state transitions - data: { previousState, nextState }
  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
};

exports.default = HlsEvents;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/hls.js":
/*!***************************!*\
  !*** ./src/hls.js/hls.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "../../node_modules/url-toolkit/src/url-toolkit.js");

var URLToolkit = _interopRequireWildcard(_urlToolkit);

var _errors = __webpack_require__(/*! ./errors */ "./src/hls.js/errors.js");

var _playlistLoader = __webpack_require__(/*! ./loader/playlist-loader */ "./src/hls.js/loader/playlist-loader.js");

var _playlistLoader2 = _interopRequireDefault(_playlistLoader);

var _fragmentLoader = __webpack_require__(/*! ./loader/fragment-loader */ "./src/hls.js/loader/fragment-loader.js");

var _fragmentLoader2 = _interopRequireDefault(_fragmentLoader);

var _keyLoader = __webpack_require__(/*! ./loader/key-loader */ "./src/hls.js/loader/key-loader.js");

var _keyLoader2 = _interopRequireDefault(_keyLoader);

var _fragmentTracker = __webpack_require__(/*! ./controller/fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _streamController = __webpack_require__(/*! ./controller/stream-controller */ "./src/hls.js/controller/stream-controller.js");

var _streamController2 = _interopRequireDefault(_streamController);

var _levelController = __webpack_require__(/*! ./controller/level-controller */ "./src/hls.js/controller/level-controller.js");

var _levelController2 = _interopRequireDefault(_levelController);

var _id3TrackController = __webpack_require__(/*! ./controller/id3-track-controller */ "./src/hls.js/controller/id3-track-controller.js");

var _id3TrackController2 = _interopRequireDefault(_id3TrackController);

var _isSupported2 = __webpack_require__(/*! ./is-supported */ "./src/hls.js/is-supported.js");

var _logger = __webpack_require__(/*! ./utils/logger */ "./src/hls.js/utils/logger.js");

var _config = __webpack_require__(/*! ./config */ "./src/hls.js/config.js");

var _events = __webpack_require__(/*! ./events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _observer = __webpack_require__(/*! ./observer */ "./src/hls.js/observer.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @module Hls
 * @class
 * @constructor
 */
var Hls = function (_Observer) {
  _inherits(Hls, _Observer);

  _createClass(Hls, null, [{
    key: 'isSupported',


    /**
     * @type {boolean}
     */
    value: function isSupported() {
      return (0, _isSupported2.isSupported)();
    }

    /**
     * @type {HlsEvents}
     */

  }, {
    key: 'version',

    /**
     * @type {string}
     */
    get: function get() {
      return __VERSION__;
    }
  }, {
    key: 'Events',
    get: function get() {
      return _events2.default;
    }

    /**
     * @type {HlsErrorTypes}
     */

  }, {
    key: 'ErrorTypes',
    get: function get() {
      return _errors.ErrorTypes;
    }

    /**
     * @type {HlsErrorDetails}
     */

  }, {
    key: 'ErrorDetails',
    get: function get() {
      return _errors.ErrorDetails;
    }

    /**
     * @type {HlsConfig}
     */

  }, {
    key: 'DefaultConfig',
    get: function get() {
      if (!Hls.defaultConfig) {
        return _config.hlsDefaultConfig;
      }

      return Hls.defaultConfig;
    }

    /**
     * @type {HlsConfig}
     */
    ,
    set: function set(defaultConfig) {
      Hls.defaultConfig = defaultConfig;
    }

    /**
     * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.
     *
     * @constructs Hls
     * @param {HlsConfig} config
     */

  }]);

  function Hls() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Hls);

    var _this = _possibleConstructorReturn(this, (Hls.__proto__ || Object.getPrototypeOf(Hls)).call(this));

    var defaultConfig = Hls.DefaultConfig;

    if ((config.liveSyncDurationCount || config.liveMaxLatencyDurationCount) && (config.liveSyncDuration || config.liveMaxLatencyDuration)) {
      throw new Error('Illegal hls.js config: don\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');
    }

    for (var prop in defaultConfig) {
      if (prop in config) continue;
      config[prop] = defaultConfig[prop];
    }

    if (config.liveMaxLatencyDurationCount !== undefined && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
    }

    if (config.liveMaxLatencyDuration !== undefined && (config.liveMaxLatencyDuration <= config.liveSyncDuration || config.liveSyncDuration === undefined)) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
    }

    (0, _logger.enableLogs)(config.debug);
    _this.config = config;
    _this._autoLevelCapping = -1;

    // core controllers and network loaders

    /**
     * @member {AbrController} abrController
     */
    var abrController = _this.abrController = new config.abrController(_this);

    var bufferController = new config.bufferController(_this);
    var capLevelController = new config.capLevelController(_this);
    var fpsController = new config.fpsController(_this);
    var playListLoader = new _playlistLoader2.default(_this);
    var fragmentLoader = new _fragmentLoader2.default(_this);
    var keyLoader = new _keyLoader2.default(_this);
    var id3TrackController = new _id3TrackController2.default(_this);

    // network controllers

    /**
     * @member {LevelController} levelController
     */
    var levelController = _this.levelController = new _levelController2.default(_this);

    // FIXME: FragmentTracker must be defined before StreamController because the order of event handling is important
    var fragmentTracker = new _fragmentTracker.FragmentTracker(_this);

    /**
     * @member {StreamController} streamController
     */
    var streamController = _this.streamController = new _streamController2.default(_this, fragmentTracker);

    var networkControllers = [levelController, streamController];

    // optional audio stream controller
    /**
     * @var {ICoreComponent | Controller}
     */
    var Controller = config.audioStreamController;
    if (Controller) {
      networkControllers.push(new Controller(_this, fragmentTracker));
    }

    /**
     * @member {INetworkController[]} networkControllers
     */
    _this.networkControllers = networkControllers;

    /**
     * @var {ICoreComponent[]}
     */
    var coreComponents = [playListLoader, fragmentLoader, keyLoader, abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];

    // optional audio track and subtitle controller
    Controller = config.audioTrackController;
    if (Controller) {
      var audioTrackController = new Controller(_this);

      /**
       * @member {AudioTrackController} audioTrackController
       */
      _this.audioTrackController = audioTrackController;
      coreComponents.push(audioTrackController);
    }

    Controller = config.subtitleTrackController;
    if (Controller) {
      var subtitleTrackController = new Controller(_this);

      /**
       * @member {SubtitleTrackController} subtitleTrackController
       */
      _this.subtitleTrackController = subtitleTrackController;
      networkControllers.push(subtitleTrackController);
    }

    Controller = config.emeController;
    if (Controller) {
      var emeController = new Controller(_this);

      /**
       * @member {EMEController} emeController
       */
      _this.emeController = emeController;
      coreComponents.push(emeController);
    }

    // optional subtitle controllers
    Controller = config.subtitleStreamController;
    if (Controller) {
      networkControllers.push(new Controller(_this, fragmentTracker));
    }
    Controller = config.timelineController;
    if (Controller) {
      coreComponents.push(new Controller(_this));
    }

    /**
     * @member {ICoreComponent[]}
     */
    _this.coreComponents = coreComponents;
    return _this;
  }

  /**
   * Dispose of the instance
   */


  _createClass(Hls, [{
    key: 'destroy',
    value: function destroy() {
      _logger.logger.log('destroy');
      this.trigger(_events2.default.DESTROYING);
      this.detachMedia();
      this.coreComponents.concat(this.networkControllers).forEach(function (component) {
        component.destroy();
      });
      this.url = null;
      this.removeAllListeners();
      this._autoLevelCapping = -1;
    }

    /**
     * Attach a media element
     * @param {HTMLMediaElement} media
     */

  }, {
    key: 'attachMedia',
    value: function attachMedia(media) {
      _logger.logger.log('attachMedia');
      this.media = media;
      this.trigger(_events2.default.MEDIA_ATTACHING, { media: media });
    }

    /**
     * Detach from the media
     */

  }, {
    key: 'detachMedia',
    value: function detachMedia() {
      _logger.logger.log('detachMedia');
      this.trigger(_events2.default.MEDIA_DETACHING);
      this.media = null;
    }

    /**
     * Set the source URL. Can be relative or absolute.
     * @param {string} url
     */

  }, {
    key: 'loadSource',
    value: function loadSource(url) {
      url = URLToolkit.buildAbsoluteURL(window.location.href, url, { alwaysNormalize: true });
      _logger.logger.log('loadSource:' + url);
      this.url = url;
      // when attaching to a source URL, trigger a playlist load
      this.trigger(_events2.default.MANIFEST_LOADING, { url: url });
    }

    /**
     * Start loading data from the stream source.
     * Depending on default config, client starts loading automatically when a source is set.
     *
     * @param {number} startPosition Set the start position to stream from
     * @default -1 None (from earliest point)
     */

  }, {
    key: 'startLoad',
    value: function startLoad() {
      var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;

      _logger.logger.log('startLoad(' + startPosition + ')');
      this.networkControllers.forEach(function (controller) {
        controller.startLoad(startPosition);
      });
    }

    /**
     * Stop loading of any stream data.
     */

  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      _logger.logger.log('stopLoad');
      this.networkControllers.forEach(function (controller) {
        controller.stopLoad();
      });
    }

    /**
     * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)
     */

  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      _logger.logger.log('swapAudioCodec');
      this.streamController.swapAudioCodec();
    }

    /**
     * When the media-element fails, this allows to detach and then re-attach it
     * as one call (convenience method).
     *
     * Automatic recovery of media-errors by this process is configurable.
     */

  }, {
    key: 'recoverMediaError',
    value: function recoverMediaError() {
      _logger.logger.log('recoverMediaError');
      var media = this.media;
      this.detachMedia();
      this.attachMedia(media);
    }

    /**
     * @type {QualityLevel[]}
     */

  }, {
    key: 'levels',
    get: function get() {
      return this.levelController.levels;
    }

    /**
     * Index of quality level currently played
     * @type {number}
     */

  }, {
    key: 'currentLevel',
    get: function get() {
      return this.streamController.currentLevel;
    }

    /**
     * Set quality level index immediately .
     * This will flush the current buffer to replace the quality asap.
     * That means playback will interrupt at least shortly to re-buffer and re-sync eventually.
     * @type {number} -1 for automatic level selection
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set currentLevel:' + newLevel);
      this.loadLevel = newLevel;
      this.streamController.immediateLevelSwitch();
    }

    /**
     * Index of next quality level loaded as scheduled by stream controller.
     * @type {number}
     */

  }, {
    key: 'nextLevel',
    get: function get() {
      return this.streamController.nextLevel;
    }

    /**
     * Set quality level index for next loaded data.
     * This will switch the video quality asap, without interrupting playback.
     * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).
     * @type {number} -1 for automatic level selection
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set nextLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
      this.streamController.nextLevelSwitch();
    }

    /**
     * Return the quality level of the currently or last (of none is loaded currently) segment
     * @type {number}
     */

  }, {
    key: 'loadLevel',
    get: function get() {
      return this.levelController.level;
    }

    /**
     * Set quality level index for next loaded data in a conservative way.
     * This will switch the quality without flushing, but interrupt current loading.
     * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.
     * @type {number} newLevel -1 for automatic level selection
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set loadLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
    }

    /**
     * get next quality level loaded
     * @type {number}
     */

  }, {
    key: 'nextLoadLevel',
    get: function get() {
      return this.levelController.nextLoadLevel;
    }

    /**
     * Set quality level of next loaded segment in a fully "non-destructive" way.
     * Same as `loadLevel` but will wait for next switch (until current loading is done).
     * @type {number} level
     */
    ,
    set: function set(level) {
      this.levelController.nextLoadLevel = level;
    }

    /**
     * Return "first level": like a default level, if not set,
     * falls back to index of first level referenced in manifest
     * @type {number}
     */

  }, {
    key: 'firstLevel',
    get: function get() {
      return Math.max(this.levelController.firstLevel, this.minAutoLevel);
    }

    /**
     * Sets "first-level", see getter.
     * @type {number}
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set firstLevel:' + newLevel);
      this.levelController.firstLevel = newLevel;
    }

    /**
     * Return start level (level of first fragment that will be played back)
     * if not overrided by user, first level appearing in manifest will be used as start level
     * if -1 : automatic start level selection, playback will start from level matching download bandwidth
     * (determined from download of first segment)
     * @type {number}
     */

  }, {
    key: 'startLevel',
    get: function get() {
      return this.levelController.startLevel;
    }

    /**
     * set  start level (level of first fragment that will be played back)
     * if not overrided by user, first level appearing in manifest will be used as start level
     * if -1 : automatic start level selection, playback will start from level matching download bandwidth
     * (determined from download of first segment)
     * @type {number} newLevel
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set startLevel:' + newLevel);
      var hls = this;
      // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel
      if (newLevel !== -1) {
        newLevel = Math.max(newLevel, hls.minAutoLevel);
      }

      hls.levelController.startLevel = newLevel;
    }

    /**
     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
     * @type {number}
     */

  }, {
    key: 'autoLevelCapping',
    get: function get() {
      return this._autoLevelCapping;
    }

    /**
     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
     * @type {number}
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set autoLevelCapping:' + newLevel);
      this._autoLevelCapping = newLevel;
    }

    /**
     * True when automatic level selection enabled
     * @type {boolean}
     */

  }, {
    key: 'autoLevelEnabled',
    get: function get() {
      return this.levelController.manualLevel === -1;
    }

    /**
     * Level set manually (if any)
     * @type {number}
     */

  }, {
    key: 'manualLevel',
    get: function get() {
      return this.levelController.manualLevel;
    }

    /**
     * min level selectable in auto mode according to config.minAutoBitrate
     * @type {number}
     */

  }, {
    key: 'minAutoLevel',
    get: function get() {
      var hls = this,
          levels = hls.levels,
          minAutoBitrate = hls.config.minAutoBitrate,
          len = levels ? levels.length : 0;
      for (var i = 0; i < len; i++) {
        var levelNextBitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate;
        if (levelNextBitrate > minAutoBitrate) {
          return i;
        }
      }
      return 0;
    }

    /**
     * max level selectable in auto mode according to autoLevelCapping
     * @type {number}
     */

  }, {
    key: 'maxAutoLevel',
    get: function get() {
      var hls = this;
      var levels = hls.levels;
      var autoLevelCapping = hls.autoLevelCapping;
      var maxAutoLevel = void 0;
      if (autoLevelCapping === -1 && levels && levels.length) {
        maxAutoLevel = levels.length - 1;
      } else {
        maxAutoLevel = autoLevelCapping;
      }

      return maxAutoLevel;
    }

    /**
     * next automatically selected quality level
     * @type {number}
     */

  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var hls = this;
      // ensure next auto level is between  min and max auto level
      return Math.min(Math.max(hls.abrController.nextAutoLevel, hls.minAutoLevel), hls.maxAutoLevel);
    }

    /**
     * this setter is used to force next auto level.
     * this is useful to force a switch down in auto mode:
     * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
     * forced value is valid for one fragment. upon succesful frag loading at forced level,
     * this value will be resetted to -1 by ABR controller.
     * @type {number}
     */
    ,
    set: function set(nextLevel) {
      var hls = this;
      hls.abrController.nextAutoLevel = Math.max(hls.minAutoLevel, nextLevel);
    }

    /**
     * @type {AudioTrack[]}
     */

  }, {
    key: 'audioTracks',
    get: function get() {
      var audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTracks : [];
    }

    /**
     * index of the selected audio track (index in audio track lists)
     * @type {number}
     */

  }, {
    key: 'audioTrack',
    get: function get() {
      var audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTrack : -1;
    }

    /**
     * selects an audio track, based on its index in audio track lists
     * @type {number}
     */
    ,
    set: function set(audioTrackId) {
      var audioTrackController = this.audioTrackController;
      if (audioTrackController) {
        audioTrackController.audioTrack = audioTrackId;
      }
    }

    /**
     * @type {Seconds}
     */

  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this.streamController.liveSyncPosition;
    }

    /**
     * get alternate subtitle tracks list from playlist
     * @type {SubtitleTrack[]}
     */

  }, {
    key: 'subtitleTracks',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
    }

    /**
     * index of the selected subtitle track (index in subtitle track lists)
     * @type {number}
     */

  }, {
    key: 'subtitleTrack',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
    }

    /**
     * select an subtitle track, based on its index in subtitle track lists
     * @type{number}
     */
    ,
    set: function set(subtitleTrackId) {
      var subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleTrack = subtitleTrackId;
      }
    }

    /**
     * @type {boolean}
     */

  }, {
    key: 'subtitleDisplay',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
    }

    /**
     * Enable/disable subtitle display rendering
     * @type {boolean}
     */
    ,
    set: function set(value) {
      var subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleDisplay = value;
      }
    }
  }]);

  return Hls;
}(_observer.Observer);

exports.default = Hls;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/is-supported.js":
/*!************************************!*\
  !*** ./src/hls.js/is-supported.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSupported = isSupported;

var _mediasourceHelper = __webpack_require__(/*! ./utils/mediasource-helper */ "./src/hls.js/utils/mediasource-helper.js");

function isSupported() {
  var mediaSource = (0, _mediasourceHelper.getMediaSource)();
  var sourceBuffer = window.SourceBuffer || window.WebKitSourceBuffer;
  var isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === 'function' && mediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');

  // if SourceBuffer is exposed ensure its API is valid
  // safari and old version of Chrome doe not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible
  var sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';
  return !!isTypeSupported && !!sourceBufferValidAPI;
}

/***/ }),

/***/ "./src/hls.js/loader/fragment-loader.js":
/*!**********************************************!*\
  !*** ./src/hls.js/loader/fragment-loader.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Fragment Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FragmentLoader = function (_EventHandler) {
  _inherits(FragmentLoader, _EventHandler);

  function FragmentLoader(hls) {
    _classCallCheck(this, FragmentLoader);

    var _this = _possibleConstructorReturn(this, (FragmentLoader.__proto__ || Object.getPrototypeOf(FragmentLoader)).call(this, hls, _events2.default.FRAG_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(FragmentLoader, [{
    key: 'destroy',
    value: function destroy() {
      var loaders = this.loaders;
      for (var loaderName in loaders) {
        var loader = loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};

      _get(FragmentLoader.prototype.__proto__ || Object.getPrototypeOf(FragmentLoader.prototype), 'destroy', this).call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loaders = this.loaders,
          config = this.hls.config,
          FragmentILoader = config.fLoader,
          DefaultILoader = config.loader;

      // reset fragment state
      frag.loaded = 0;

      var loader = loaders[type];
      if (loader) {
        _logger.logger.warn('abort previous fragment loader for type: ' + type);
        loader.abort();
      }

      loader = loaders[type] = frag.loader = config.fLoader ? new FragmentILoader(config) : new DefaultILoader(config);

      var loaderContext = void 0,
          loaderConfig = void 0,
          loaderCallbacks = void 0;

      loaderContext = { url: frag.url, frag: frag, responseType: 'arraybuffer', progressData: false };

      var start = frag.byteRangeStartOffset,
          end = frag.byteRangeEndOffset;

      if (Number.isFinite(start) && Number.isFinite(end)) {
        loaderContext.rangeStart = start;
        loaderContext.rangeEnd = end;
      }

      loaderConfig = {
        timeout: config.fragLoadingTimeOut,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: config.fragLoadingMaxRetryTimeout
      };

      loaderCallbacks = {
        onSuccess: this.loadsuccess.bind(this),
        onError: this.loaderror.bind(this),
        onTimeout: this.loadtimeout.bind(this),
        onProgress: this.loadprogress.bind(this)
      };

      loader.load(loaderContext, loaderConfig, loaderCallbacks);
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var payload = response.data,
          frag = context.frag;
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.FRAG_LOADED, { payload: payload, frag: frag, stats: stats, networkDetails: networkDetails });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var frag = context.frag;
      var loader = frag.loader;
      if (loader) {
        loader.abort();
      }

      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: context.frag, response: response, networkDetails: networkDetails });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var frag = context.frag;
      var loader = frag.loader;
      if (loader) {
        loader.abort();
      }

      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: context.frag, networkDetails: networkDetails });
    }

    // data will be used for progressive parsing

  }, {
    key: 'loadprogress',
    value: function loadprogress(stats, context, data) {
      var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      // jshint ignore:line
      var frag = context.frag;
      frag.loaded = stats.loaded;
      this.hls.trigger(_events2.default.FRAG_LOAD_PROGRESS, { frag: frag, stats: stats, networkDetails: networkDetails });
    }
  }]);

  return FragmentLoader;
}(_eventHandler2.default);

exports.default = FragmentLoader;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/fragment.js":
/*!***************************************!*\
  !*** ./src/hls.js/loader/fragment.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "../../node_modules/url-toolkit/src/url-toolkit.js");

var URLToolkit = _interopRequireWildcard(_urlToolkit);

var _levelKey = __webpack_require__(/*! ./level-key */ "./src/hls.js/loader/level-key.js");

var _levelKey2 = _interopRequireDefault(_levelKey);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Fragment = function () {
  function Fragment() {
    var _elementaryStreams;

    _classCallCheck(this, Fragment);

    this._url = null;
    this._byteRange = null;
    this._decryptdata = null;
    this.tagList = [];
    this.programDateTime = null;
    this.rawProgramDateTime = null;

    // Holds the types of data this fragment supports
    this._elementaryStreams = (_elementaryStreams = {}, _defineProperty(_elementaryStreams, Fragment.ElementaryStreamTypes.AUDIO, false), _defineProperty(_elementaryStreams, Fragment.ElementaryStreamTypes.VIDEO, false), _elementaryStreams);
  }

  /**
   * `type` property for this._elementaryStreams
   *
   * @enum
   */


  _createClass(Fragment, [{
    key: 'addElementaryStream',


    /**
     * @param {ElementaryStreamType} type
     */
    value: function addElementaryStream(type) {
      this._elementaryStreams[type] = true;
    }

    /**
     * @param {ElementaryStreamType} type
     */

  }, {
    key: 'hasElementaryStream',
    value: function hasElementaryStream(type) {
      return this._elementaryStreams[type] === true;
    }

    /**
     * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
     * @returns {Uint8Array}
     */

  }, {
    key: 'createInitializationVector',
    value: function createInitializationVector(segmentNumber) {
      var uint8View = new Uint8Array(16);

      for (var i = 12; i < 16; i++) {
        uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
      }

      return uint8View;
    }

    /**
     * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
     * @param levelkey - a playlist's encryption info
     * @param segmentNumber - the fragment's segment number
     * @returns {*} - an object to be applied as a fragment's decryptdata
     */

  }, {
    key: 'fragmentDecryptdataFromLevelkey',
    value: function fragmentDecryptdataFromLevelkey(levelkey, segmentNumber) {
      var decryptdata = levelkey;

      if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {
        decryptdata = new _levelKey2.default();
        decryptdata.method = levelkey.method;
        decryptdata.baseuri = levelkey.baseuri;
        decryptdata.reluri = levelkey.reluri;
        decryptdata.iv = this.createInitializationVector(segmentNumber);
      }

      return decryptdata;
    }
  }, {
    key: 'url',
    get: function get() {
      if (!this._url && this.relurl) {
        this._url = URLToolkit.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: true });
      }

      return this._url;
    },
    set: function set(value) {
      this._url = value;
    }
  }, {
    key: 'byteRange',
    get: function get() {
      if (!this._byteRange && !this.rawByteRange) {
        return [];
      }

      if (this._byteRange) {
        return this._byteRange;
      }

      var byteRange = [];
      if (this.rawByteRange) {
        var params = this.rawByteRange.split('@', 2);
        if (params.length === 1) {
          var lastByteRangeEndOffset = this.lastByteRangeEndOffset;
          byteRange[0] = lastByteRangeEndOffset || 0;
        } else {
          byteRange[0] = parseInt(params[1]);
        }
        byteRange[1] = parseInt(params[0]) + byteRange[0];
        this._byteRange = byteRange;
      }
      return byteRange;
    }

    /**
     * @type {number}
     */

  }, {
    key: 'byteRangeStartOffset',
    get: function get() {
      return this.byteRange[0];
    }
  }, {
    key: 'byteRangeEndOffset',
    get: function get() {
      return this.byteRange[1];
    }
  }, {
    key: 'decryptdata',
    get: function get() {
      if (!this._decryptdata) {
        this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn);
      }

      return this._decryptdata;
    }
  }, {
    key: 'endProgramDateTime',
    get: function get() {
      if (!Number.isFinite(this.programDateTime)) {
        return null;
      }

      var duration = !Number.isFinite(this.duration) ? 0 : this.duration;

      return this.programDateTime + duration * 1000;
    }
  }, {
    key: 'encrypted',
    get: function get() {
      return !!(this.decryptdata && this.decryptdata.uri !== null && this.decryptdata.key === null);
    }
  }], [{
    key: 'ElementaryStreamTypes',
    get: function get() {
      return {
        AUDIO: 'audio',
        VIDEO: 'video'
      };
    }
  }]);

  return Fragment;
}();

exports.default = Fragment;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/key-loader.js":
/*!*****************************************!*\
  !*** ./src/hls.js/loader/key-loader.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Decrypt key Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var KeyLoader = function (_EventHandler) {
  _inherits(KeyLoader, _EventHandler);

  function KeyLoader(hls) {
    _classCallCheck(this, KeyLoader);

    var _this = _possibleConstructorReturn(this, (KeyLoader.__proto__ || Object.getPrototypeOf(KeyLoader)).call(this, hls, _events2.default.KEY_LOADING));

    _this.loaders = {};
    _this.decryptkey = null;
    _this.decrypturl = null;
    return _this;
  }

  _createClass(KeyLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onKeyLoading',
    value: function onKeyLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loader = this.loaders[type],
          decryptdata = frag.decryptdata,
          uri = decryptdata.uri;
      // if uri is different from previous one or if decrypt key not retrieved yet
      if (uri !== this.decrypturl || this.decryptkey === null) {
        var config = this.hls.config;

        if (loader) {
          _logger.logger.warn('abort previous key loader for type:' + type);
          loader.abort();
        }
        frag.loader = this.loaders[type] = new config.loader(config);
        this.decrypturl = uri;
        this.decryptkey = null;

        var loaderContext = void 0,
            loaderConfig = void 0,
            loaderCallbacks = void 0;
        loaderContext = { url: uri, frag: frag, responseType: 'arraybuffer' };
        // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,
        // key-loader will trigger an error and rely on stream-controller to handle retry logic.
        // this will also align retry logic with fragment-loader
        loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
        loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
        frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);
      } else if (this.decryptkey) {
        // we already loaded this key, return it
        decryptdata.key = this.decryptkey;
        this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
      }
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var frag = context.frag;
      this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }

      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_ERROR, fatal: false, frag: frag, response: response });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }

      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: false, frag: frag });
    }
  }]);

  return KeyLoader;
}(_eventHandler2.default);

exports.default = KeyLoader;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/level-key.js":
/*!****************************************!*\
  !*** ./src/hls.js/loader/level-key.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "../../node_modules/url-toolkit/src/url-toolkit.js");

var URLToolkit = _interopRequireWildcard(_urlToolkit);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LevelKey = function () {
  function LevelKey() {
    _classCallCheck(this, LevelKey);

    this.method = null;
    this.key = null;
    this.iv = null;
    this._uri = null;
  }

  _createClass(LevelKey, [{
    key: 'uri',
    get: function get() {
      if (!this._uri && this.reluri) {
        this._uri = URLToolkit.buildAbsoluteURL(this.baseuri, this.reluri, { alwaysNormalize: true });
      }

      return this._uri;
    }
  }]);

  return LevelKey;
}();

exports.default = LevelKey;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/level.js":
/*!************************************!*\
  !*** ./src/hls.js/loader/level.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Level = function () {
  function Level(baseUrl) {
    _classCallCheck(this, Level);

    // Please keep properties in alphabetical order
    this.endCC = 0;
    this.endSN = 0;
    this.fragments = [];
    this.initSegment = null;
    this.live = true;
    this.needSidxRanges = false;
    this.startCC = 0;
    this.startSN = 0;
    this.startTimeOffset = null;
    this.targetduration = 0;
    this.totalduration = 0;
    this.type = null;
    this.url = baseUrl;
    this.version = null;
  }

  _createClass(Level, [{
    key: "hasProgramDateTime",
    get: function get() {
      return !!(this.fragments[0] && Number.isFinite(this.fragments[0].programDateTime));
    }
  }]);

  return Level;
}();

exports.default = Level;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/loader/m3u8-parser.js":
/*!******************************************!*\
  !*** ./src/hls.js/loader/m3u8-parser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "../../node_modules/url-toolkit/src/url-toolkit.js");

var URLToolkit = _interopRequireWildcard(_urlToolkit);

var _fragment = __webpack_require__(/*! ./fragment */ "./src/hls.js/loader/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _level = __webpack_require__(/*! ./level */ "./src/hls.js/loader/level.js");

var _level2 = _interopRequireDefault(_level);

var _levelKey = __webpack_require__(/*! ./level-key */ "./src/hls.js/loader/level-key.js");

var _levelKey2 = _interopRequireDefault(_levelKey);

var _attrList = __webpack_require__(/*! ../utils/attr-list */ "./src/hls.js/utils/attr-list.js");

var _attrList2 = _interopRequireDefault(_attrList);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _codecs = __webpack_require__(/*! ../utils/codecs */ "./src/hls.js/utils/codecs.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * M3U8 parser
 * @module
 */

// https://regex101.com is your friend
var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;
var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;

var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
/|(?!#)([\S+ ?]+)/.source, // segment URI, group 3 => the URI (note newline is not eaten)
/|#EXT-X-BYTERANGE:*(.+)/.source, // next segment's byterange, group 4 => range spec (x@y)
/|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, // next segment's program date/time group 5 => the datetime spec
/|#.*/.source // All other non-segment oriented tags will match with all groups empty
].join(''), 'g');

var LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)([^:]*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/;

var MP4_REGEX_SUFFIX = /\.(mp4|m4s|m4v|m4a)$/i;

var M3U8Parser = function () {
  function M3U8Parser() {
    _classCallCheck(this, M3U8Parser);
  }

  _createClass(M3U8Parser, null, [{
    key: 'findGroup',
    value: function findGroup(groups, mediaGroupId) {
      if (!groups) {
        return null;
      }

      var matchingGroup = null;

      for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        if (group.id === mediaGroupId) {
          matchingGroup = group;
        }
      }

      return matchingGroup;
    }
  }, {
    key: 'convertAVC1ToAVCOTI',
    value: function convertAVC1ToAVCOTI(codec) {
      var result = void 0,
          avcdata = codec.split('.');
      if (avcdata.length > 2) {
        result = avcdata.shift() + '.';
        result += parseInt(avcdata.shift()).toString(16);
        result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);
      } else {
        result = codec;
      }
      return result;
    }
  }, {
    key: 'resolve',
    value: function resolve(url, baseUrl) {
      return URLToolkit.buildAbsoluteURL(baseUrl, url, { alwaysNormalize: true });
    }
  }, {
    key: 'parseMasterPlaylist',
    value: function parseMasterPlaylist(string, baseurl) {
      var levels = [],
          result = void 0;
      MASTER_PLAYLIST_REGEX.lastIndex = 0;

      function setCodecs(codecs, level) {
        ['video', 'audio'].forEach(function (type) {
          var filtered = codecs.filter(function (codec) {
            return (0, _codecs.isCodecType)(codec, type);
          });
          if (filtered.length) {
            var preferred = filtered.filter(function (codec) {
              return codec.lastIndexOf('avc1', 0) === 0 || codec.lastIndexOf('mp4a', 0) === 0;
            });
            level[type + 'Codec'] = preferred.length > 0 ? preferred[0] : filtered[0];

            // remove from list
            codecs = codecs.filter(function (codec) {
              return filtered.indexOf(codec) === -1;
            });
          }
        });

        level.unknownCodecs = codecs;
      }

      while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
        var level = {};

        var attrs = level.attrs = new _attrList2.default(result[1]);
        level.url = M3U8Parser.resolve(result[2], baseurl);

        var resolution = attrs.decimalResolution('RESOLUTION');
        if (resolution) {
          level.width = resolution.width;
          level.height = resolution.height;
        }
        level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');
        level.name = attrs.NAME;

        setCodecs([].concat((attrs.CODECS || '').split(/[ ,]+/)), level);

        if (level.videoCodec && level.videoCodec.indexOf('avc1') !== -1) {
          level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);
        }

        levels.push(level);
      }
      return levels;
    }
  }, {
    key: 'parseMasterPlaylistMedia',
    value: function parseMasterPlaylistMedia(string, baseurl, type) {
      var audioGroups = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

      var result = void 0;
      var medias = [];
      var id = 0;
      MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
      while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
        var media = {};
        var attrs = new _attrList2.default(result[1]);
        if (attrs.TYPE === type) {
          media.groupId = attrs['GROUP-ID'];
          media.name = attrs.NAME;
          media.type = type;
          media.default = attrs.DEFAULT === 'YES';
          media.autoselect = attrs.AUTOSELECT === 'YES';
          media.forced = attrs.FORCED === 'YES';
          if (attrs.URI) {
            media.url = M3U8Parser.resolve(attrs.URI, baseurl);
          }

          media.lang = attrs.LANGUAGE;
          if (!media.name) {
            media.name = media.lang;
          }

          if (audioGroups.length) {
            var groupCodec = M3U8Parser.findGroup(audioGroups, media.groupId);
            media.audioCodec = groupCodec ? groupCodec.codec : audioGroups[0].codec;
          }
          media.id = id++;
          medias.push(media);
        }
      }
      return medias;
    }
  }, {
    key: 'parseLevelPlaylist',
    value: function parseLevelPlaylist(string, baseurl, id, type, levelUrlId) {
      var currentSN = 0;
      var totalduration = 0;
      var level = new _level2.default(baseurl);
      var levelkey = new _levelKey2.default();
      var cc = 0;
      var prevFrag = null;
      var frag = new _fragment2.default();
      var result = void 0;
      var i = void 0;

      var firstPdtIndex = null;

      LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;

      while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
        var duration = result[1];
        if (duration) {
          // INF
          frag.duration = parseFloat(duration);
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          var title = (' ' + result[2]).slice(1);
          frag.title = title || null;
          frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);
        } else if (result[3]) {
          // url
          if (Number.isFinite(frag.duration)) {
            var sn = currentSN++;
            frag.type = type;
            frag.start = totalduration;
            frag.levelkey = levelkey;
            frag.sn = sn;
            frag.level = id;
            frag.cc = cc;
            frag.urlId = levelUrlId;
            frag.baseurl = baseurl;
            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
            frag.relurl = (' ' + result[3]).slice(1);
            assignProgramDateTime(frag, prevFrag);

            level.fragments.push(frag);
            prevFrag = frag;
            totalduration += frag.duration;

            frag = new _fragment2.default();
          }
        } else if (result[4]) {
          // X-BYTERANGE
          frag.rawByteRange = (' ' + result[4]).slice(1);
          if (prevFrag) {
            var lastByteRangeEndOffset = prevFrag.byteRangeEndOffset;
            if (lastByteRangeEndOffset) {
              frag.lastByteRangeEndOffset = lastByteRangeEndOffset;
            }
          }
        } else if (result[5]) {
          // PROGRAM-DATE-TIME
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          frag.rawProgramDateTime = (' ' + result[5]).slice(1);
          frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);
          if (firstPdtIndex === null) {
            firstPdtIndex = level.fragments.length;
          }
        } else {
          result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
          for (i = 1; i < result.length; i++) {
            if (result[i] !== undefined) {
              break;
            }
          }

          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          var value1 = (' ' + result[i + 1]).slice(1);
          var value2 = (' ' + result[i + 2]).slice(1);

          switch (result[i]) {
            case '#':
              frag.tagList.push(value2 ? [value1, value2] : [value1]);
              break;
            case 'PLAYLIST-TYPE':
              level.type = value1.toUpperCase();
              break;
            case 'MEDIA-SEQUENCE':
              currentSN = level.startSN = parseInt(value1);
              break;
            case 'TARGETDURATION':
              level.targetduration = parseFloat(value1);
              break;
            case 'VERSION':
              level.version = parseInt(value1);
              break;
            case 'EXTM3U':
              break;
            case 'ENDLIST':
              level.live = false;
              break;
            case 'DIS':
              cc++;
              frag.tagList.push(['DIS']);
              break;
            case 'DISCONTINUITY-SEQ':
              cc = parseInt(value1);
              break;
            case 'KEY':
              // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
              var decryptparams = value1;
              var keyAttrs = new _attrList2.default(decryptparams);
              var decryptmethod = keyAttrs.enumeratedString('METHOD'),
                  decrypturi = keyAttrs.URI,
                  decryptiv = keyAttrs.hexadecimalInteger('IV');
              if (decryptmethod) {
                levelkey = new _levelKey2.default();
                if (decrypturi && ['AES-128', 'SAMPLE-AES', 'SAMPLE-AES-CENC'].indexOf(decryptmethod) >= 0) {
                  levelkey.method = decryptmethod;
                  // URI to get the key
                  levelkey.baseuri = baseurl;
                  levelkey.reluri = decrypturi;
                  levelkey.key = null;
                  // Initialization Vector (IV)
                  levelkey.iv = decryptiv;
                }
              }
              break;
            case 'START':
              var startParams = value1;
              var startAttrs = new _attrList2.default(startParams);
              var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
              // TIME-OFFSET can be 0
              if (Number.isFinite(startTimeOffset)) {
                level.startTimeOffset = startTimeOffset;
              }

              break;
            case 'MAP':
              var mapAttrs = new _attrList2.default(value1);
              frag.relurl = mapAttrs.URI;
              frag.rawByteRange = mapAttrs.BYTERANGE;
              frag.baseurl = baseurl;
              frag.level = id;
              frag.type = type;
              frag.sn = 'initSegment';
              level.initSegment = frag;
              frag = new _fragment2.default();
              frag.rawProgramDateTime = level.initSegment.rawProgramDateTime;
              break;
            default:
              _logger.logger.warn('line parsed but not handled: ' + result);
              break;
          }
        }
      }
      frag = prevFrag;
      // logger.log('found ' + level.fragments.length + ' fragments');
      if (frag && !frag.relurl) {
        level.fragments.pop();
        totalduration -= frag.duration;
      }
      level.totalduration = totalduration;
      level.averagetargetduration = totalduration / level.fragments.length;
      level.endSN = currentSN - 1;
      level.startCC = level.fragments[0] ? level.fragments[0].cc : 0;
      level.endCC = cc;

      if (!level.initSegment && level.fragments.length) {
        // this is a bit lurky but HLS really has no other way to tell us
        // if the fragments are TS or MP4, except if we download them :/
        // but this is to be able to handle SIDX.
        if (level.fragments.every(function (frag) {
          return MP4_REGEX_SUFFIX.test(frag.relurl);
        })) {
          _logger.logger.warn('MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX');

          frag = new _fragment2.default();
          frag.relurl = level.fragments[0].relurl;
          frag.baseurl = baseurl;
          frag.level = id;
          frag.type = type;
          frag.sn = 'initSegment';

          level.initSegment = frag;
          level.needSidxRanges = true;
        }
      }

      /**
       * Backfill any missing PDT values
         "If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after
         one or more Media Segment URIs, the client SHOULD extrapolate
         backward from that tag (using EXTINF durations and/or media
         timestamps) to associate dates with those segments."
       * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs
       * computed.
       */
      if (firstPdtIndex) {
        backfillProgramDateTimes(level.fragments, firstPdtIndex);
      }

      return level;
    }
  }]);

  return M3U8Parser;
}();

exports.default = M3U8Parser;


function backfillProgramDateTimes(fragments, startIndex) {
  var fragPrev = fragments[startIndex];
  for (var i = startIndex - 1; i >= 0; i--) {
    var frag = fragments[i];
    frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;
    fragPrev = frag;
  }
}

function assignProgramDateTime(frag, prevFrag) {
  if (frag.rawProgramDateTime) {
    frag.programDateTime = Date.parse(frag.rawProgramDateTime);
  } else if (prevFrag && prevFrag.programDateTime) {
    frag.programDateTime = prevFrag.endProgramDateTime;
  }

  if (!Number.isFinite(frag.programDateTime)) {
    frag.programDateTime = null;
    frag.rawProgramDateTime = null;
  }
}
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/playlist-loader.js":
/*!**********************************************!*\
  !*** ./src/hls.js/loader/playlist-loader.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _mp4demuxer = __webpack_require__(/*! ../demux/mp4demuxer */ "./src/hls.js/demux/mp4demuxer.js");

var _mp4demuxer2 = _interopRequireDefault(_mp4demuxer);

var _m3u8Parser = __webpack_require__(/*! ./m3u8-parser */ "./src/hls.js/loader/m3u8-parser.js");

var _m3u8Parser2 = _interopRequireDefault(_m3u8Parser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * PlaylistLoader - delegate for media manifest/playlist loading tasks. Takes care of parsing media to internal data-models.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Once loaded, dispatches events with parsed data-models of manifest/levels/audio/subtitle tracks.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Uses loader(s) set in config to do actual internal loading of resource tasks.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _window = window,
    performance = _window.performance;

/**
 * `type` property values for this loaders' context object
 * @enum
 *
 */

var ContextType = {
  MANIFEST: 'manifest',
  LEVEL: 'levels.js',
  AUDIO_TRACK: 'audioTrack',
  SUBTITLE_TRACK: 'subtitleTrack'
};

/**
 * @enum {string}
 */
var LevelType = {
  MAIN: 'main',
  AUDIO: 'audio',
  SUBTITLE: 'subtitle'
};

/**
 * @constructor
 */

var PlaylistLoader = function (_EventHandler) {
  _inherits(PlaylistLoader, _EventHandler);

  /**
   * @constructs
   * @param {Hls} hls
   */
  function PlaylistLoader(hls) {
    _classCallCheck(this, PlaylistLoader);

    var _this = _possibleConstructorReturn(this, (PlaylistLoader.__proto__ || Object.getPrototypeOf(PlaylistLoader)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.LEVEL_LOADING, _events2.default.AUDIO_TRACK_LOADING, _events2.default.SUBTITLE_TRACK_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(PlaylistLoader, [{
    key: 'createInternalLoader',


    /**
     * Returns defaults or configured loader-type overloads (pLoader and loader config params)
     * Default loader is XHRLoader (see utils)
     * @param {object} context
     * @returns {XHRLoader} or other compatible configured overload
     */
    value: function createInternalLoader(context) {
      var config = this.hls.config;
      var PLoader = config.pLoader;
      var Loader = config.loader;
      var InternalLoader = PLoader || Loader;

      var loader = new InternalLoader(config);

      context.loader = loader;
      this.loaders[context.type] = loader;

      return loader;
    }
  }, {
    key: 'getInternalLoader',
    value: function getInternalLoader(context) {
      return this.loaders[context.type];
    }
  }, {
    key: 'resetInternalLoader',
    value: function resetInternalLoader(contextType) {
      if (this.loaders[contextType]) {
        delete this.loaders[contextType];
      }
    }

    /**
     * Call `destroy` on all internal loader instances mapped (one per context type)
     */

  }, {
    key: 'destroyInternalLoaders',
    value: function destroyInternalLoaders() {
      for (var contextType in this.loaders) {
        var loader = this.loaders[contextType];
        if (loader) {
          loader.destroy();
        }

        this.resetInternalLoader(contextType);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.destroyInternalLoaders();

      _get(PlaylistLoader.prototype.__proto__ || Object.getPrototypeOf(PlaylistLoader.prototype), 'destroy', this).call(this);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading(data) {
      this.load(data.url, { type: ContextType.MANIFEST, level: 0, id: null });
    }
  }, {
    key: 'onLevelLoading',
    value: function onLevelLoading(data) {
      this.load(data.url, { type: ContextType.LEVEL, level: data.levels, id: data.id });
    }
  }, {
    key: 'onAudioTrackLoading',
    value: function onAudioTrackLoading(data) {
      this.load(data.url, { type: ContextType.AUDIO_TRACK, level: null, id: data.id });
    }
  }, {
    key: 'onSubtitleTrackLoading',
    value: function onSubtitleTrackLoading(data) {
      this.load(data.url, { type: ContextType.SUBTITLE_TRACK, level: null, id: data.id });
    }
  }, {
    key: 'load',
    value: function load(url, context) {
      var config = this.hls.config;

      _logger.logger.debug('Loading playlist of type ' + context.type + ', level: ' + context.levels + ', id: ' + context.id);

      // Check if a loader for this context already exists
      var loader = this.getInternalLoader(context);
      if (loader) {
        var loaderContext = loader.context;
        if (loaderContext && loaderContext.url === url) {
          // same URL can't overlap
          _logger.logger.trace('playlist request ongoing');
          return false;
        } else {
          _logger.logger.warn('aborting previous loader for type: ' + context.type);
          loader.abort();
        }
      }

      var maxRetry = void 0,
          timeout = void 0,
          retryDelay = void 0,
          maxRetryDelay = void 0;

      // apply different configs for retries depending on
      // context (manifest, level, audio/subs playlist)
      switch (context.type) {
        case ContextType.MANIFEST:
          maxRetry = config.manifestLoadingMaxRetry;
          timeout = config.manifestLoadingTimeOut;
          retryDelay = config.manifestLoadingRetryDelay;
          maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
          break;
        case ContextType.LEVEL:
          // Disable internal loader retry logic, since we are managing retries in Level Controller
          maxRetry = 0;
          timeout = config.levelLoadingTimeOut;
          // TODO Introduce retry settings for audio-track and subtitle-track, it should not use level retry config
          break;
        default:
          maxRetry = config.levelLoadingMaxRetry;
          timeout = config.levelLoadingTimeOut;
          retryDelay = config.levelLoadingRetryDelay;
          maxRetryDelay = config.levelLoadingMaxRetryTimeout;
          break;
      }

      loader = this.createInternalLoader(context);

      context.url = url;
      context.responseType = context.responseType || ''; // FIXME: (should not be necessary to do this)

      var loaderConfig = {
        timeout: timeout,
        maxRetry: maxRetry,
        retryDelay: retryDelay,
        maxRetryDelay: maxRetryDelay
      };

      var loaderCallbacks = {
        onSuccess: this.loadsuccess.bind(this),
        onError: this.loaderror.bind(this),
        onTimeout: this.loadtimeout.bind(this)
      };

      _logger.logger.debug('Calling internal loader delegate for URL: ' + url);

      loader.load(context, loaderConfig, loaderCallbacks);

      return true;
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      if (context.isSidxRequest) {
        this._handleSidxRequest(response, context);
        this._handlePlaylistLoaded(response, stats, context, networkDetails);
        return;
      }

      this.resetInternalLoader(context.type);

      var string = response.data;

      stats.tload = performance.now();
      // stats.mtime = new Date(target.getResponseHeader('Last-Modified'));

      // Validate if it is an M3U8 at all
      if (string.indexOf('#EXTM3U') !== 0) {
        this._handleManifestParsingError(response, context, 'no EXTM3U delimiter', networkDetails);
        return;
      }

      // Check if chunk-list or master. handle empty chunk list case (first EXTINF not signaled, but TARGETDURATION present)
      if (string.indexOf('#EXTINF:') > 0 || string.indexOf('#EXT-X-TARGETDURATION:') > 0) {
        this._handleTrackOrLevelPlaylist(response, stats, context, networkDetails);
      } else {
        this._handleMasterPlaylist(response, stats, context, networkDetails);
      }
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      this._handleNetworkError(context, networkDetails, false, response);
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      this._handleNetworkError(context, networkDetails, true);
    }
  }, {
    key: '_handleMasterPlaylist',
    value: function _handleMasterPlaylist(response, stats, context, networkDetails) {
      var hls = this.hls;
      var string = response.data;

      var url = PlaylistLoader.getResponseUrl(response, context);

      var levels = _m3u8Parser2.default.parseMasterPlaylist(string, url);
      if (!levels.length) {
        this._handleManifestParsingError(response, context, 'no level found in manifest', networkDetails);
        return;
      }

      // multi level playlist, parse level info

      var audioGroups = levels.map(function (level) {
        return {
          id: level.attrs.AUDIO,
          codec: level.audioCodec
        };
      });

      var audioTracks = _m3u8Parser2.default.parseMasterPlaylistMedia(string, url, 'AUDIO', audioGroups);
      var subtitles = _m3u8Parser2.default.parseMasterPlaylistMedia(string, url, 'SUBTITLES');

      if (audioTracks.length) {
        // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
        var embeddedAudioFound = false;
        audioTracks.forEach(function (audioTrack) {
          if (!audioTrack.url) {
            embeddedAudioFound = true;
          }
        });

        // if no embedded audio track defined, but audio codec signaled in quality level,
        // we need to signal this main audio track this could happen with playlists with
        // alt audio rendition in which quality levels (main)
        // contains both audio+video. but with mixed audio track not signaled
        if (embeddedAudioFound === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
          _logger.logger.log('audio codec signaled in quality level, but no embedded audio track signaled, create one');
          audioTracks.unshift({
            type: 'main',
            name: 'main'
          });
        }
      }

      hls.trigger(_events2.default.MANIFEST_LOADED, {
        levels: levels,
        audioTracks: audioTracks,
        subtitles: subtitles,
        url: url,
        stats: stats,
        networkDetails: networkDetails
      });
    }
  }, {
    key: '_handleTrackOrLevelPlaylist',
    value: function _handleTrackOrLevelPlaylist(response, stats, context, networkDetails) {
      var hls = this.hls;

      var id = context.id,
          level = context.level,
          type = context.type;


      var url = PlaylistLoader.getResponseUrl(response, context);

      var levelUrlId = Number.isFinite(id) ? id : 0;
      var levelId = Number.isFinite(level) ? level : levelUrlId;
      var levelType = PlaylistLoader.mapContextToLevelType(context);

      var levelDetails = _m3u8Parser2.default.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId);

      // set stats on level structure
      levelDetails.tload = stats.tload;

      // We have done our first request (Manifest-type) and receive
      // not a master playlist but a chunk-list (track/level)
      // We fire the manifest-loaded event anyway with the parsed level-details
      // by creating a single-level structure for it.
      if (type === ContextType.MANIFEST) {
        var singleLevel = {
          url: url,
          details: levelDetails
        };

        hls.trigger(_events2.default.MANIFEST_LOADED, {
          levels: [singleLevel],
          audioTracks: [],
          url: url,
          stats: stats,
          networkDetails: networkDetails
        });
      }

      // save parsing time
      stats.tparsed = performance.now();

      // in case we need SIDX ranges
      // return early after calling load for
      // the SIDX box.
      if (levelDetails.needSidxRanges) {
        var sidxUrl = levelDetails.initSegment.url;
        this.load(sidxUrl, {
          isSidxRequest: true,
          type: type,
          level: level,
          levelDetails: levelDetails,
          id: id,
          rangeStart: 0,
          rangeEnd: 2048,
          responseType: 'arraybuffer'
        });
        return;
      }

      // extend the context with the new levelDetails property
      context.levelDetails = levelDetails;

      this._handlePlaylistLoaded(response, stats, context, networkDetails);
    }
  }, {
    key: '_handleSidxRequest',
    value: function _handleSidxRequest(response, context) {
      var sidxInfo = _mp4demuxer2.default.parseSegmentIndex(new Uint8Array(response.data));
      // if provided fragment does not contain sidx, early return
      if (!sidxInfo) {
        return;
      }
      var sidxReferences = sidxInfo.references;
      var levelDetails = context.levelDetails;
      sidxReferences.forEach(function (segmentRef, index) {
        var segRefInfo = segmentRef.info;
        var frag = levelDetails.fragments[index];

        if (frag.byteRange.length === 0) {
          frag.rawByteRange = String(1 + segRefInfo.end - segRefInfo.start) + '@' + String(segRefInfo.start);
        }
      });
      levelDetails.initSegment.rawByteRange = String(sidxInfo.moovEndOffset) + '@0';
    }
  }, {
    key: '_handleManifestParsingError',
    value: function _handleManifestParsingError(response, context, reason, networkDetails) {
      this.hls.trigger(_events2.default.ERROR, {
        type: _errors.ErrorTypes.NETWORK_ERROR,
        details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR,
        fatal: true,
        url: response.url,
        reason: reason,
        networkDetails: networkDetails
      });
    }
  }, {
    key: '_handleNetworkError',
    value: function _handleNetworkError(context, networkDetails) {
      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var response = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      _logger.logger.info('A network error occured while loading a ' + context.type + '-type playlist');

      var details = void 0;
      var fatal = void 0;

      var loader = this.getInternalLoader(context);

      switch (context.type) {
        case ContextType.MANIFEST:
          details = timeout ? _errors.ErrorDetails.MANIFEST_LOAD_TIMEOUT : _errors.ErrorDetails.MANIFEST_LOAD_ERROR;
          fatal = true;
          break;
        case ContextType.LEVEL:
          details = timeout ? _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT : _errors.ErrorDetails.LEVEL_LOAD_ERROR;
          fatal = false;
          break;
        case ContextType.AUDIO_TRACK:
          details = timeout ? _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
          fatal = false;
          break;
        default:
          // details = ...?
          fatal = false;
      }

      if (loader) {
        loader.abort();
        this.resetInternalLoader(context.type);
      }

      var errorData = {
        type: _errors.ErrorTypes.NETWORK_ERROR,
        details: details,
        fatal: fatal,
        url: loader.url,
        loader: loader,
        context: context,
        networkDetails: networkDetails
      };

      if (response) {
        errorData.response = response;
      }

      this.hls.trigger(_events2.default.ERROR, errorData);
    }
  }, {
    key: '_handlePlaylistLoaded',
    value: function _handlePlaylistLoaded(response, stats, context, networkDetails) {
      var type = context.type,
          level = context.level,
          id = context.id,
          levelDetails = context.levelDetails;


      if (!levelDetails.targetduration) {
        this._handleManifestParsingError(response, context, 'invalid target duration', networkDetails);
        return;
      }

      var canHaveLevels = PlaylistLoader.canHaveQualityLevels(context.type);
      if (canHaveLevels) {
        this.hls.trigger(_events2.default.LEVEL_LOADED, {
          details: levelDetails,
          level: level || 0,
          id: id || 0,
          stats: stats,
          networkDetails: networkDetails
        });
      } else {
        switch (type) {
          case ContextType.AUDIO_TRACK:
            this.hls.trigger(_events2.default.AUDIO_TRACK_LOADED, {
              details: levelDetails,
              id: id,
              stats: stats,
              networkDetails: networkDetails
            });
            break;
          case ContextType.SUBTITLE_TRACK:
            this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADED, {
              details: levelDetails,
              id: id,
              stats: stats,
              networkDetails: networkDetails
            });
            break;
        }
      }
    }
  }], [{
    key: 'canHaveQualityLevels',


    /**
     * @param {ContextType} type
     * @returns {boolean}
     */
    value: function canHaveQualityLevels(type) {
      return type !== ContextType.AUDIO_TRACK && type !== ContextType.SUBTITLE_TRACK;
    }

    /**
     * Map context.type to LevelType
     * @param {{type: ContextType}} context
     * @returns {LevelType}
     */

  }, {
    key: 'mapContextToLevelType',
    value: function mapContextToLevelType(context) {
      var type = context.type;


      switch (type) {
        case ContextType.AUDIO_TRACK:
          return LevelType.AUDIO;
        case ContextType.SUBTITLE_TRACK:
          return LevelType.SUBTITLE;
        default:
          return LevelType.MAIN;
      }
    }
  }, {
    key: 'getResponseUrl',
    value: function getResponseUrl(response, context) {
      var url = response.url;
      // responseURL not supported on some browsers (it is used to detect URL redirection)
      // data-uri mode also not supported (but no need to detect redirection)
      if (url === undefined || url.indexOf('data:') === 0) {
        // fallback to initial URL
        url = context.url;
      }
      return url;
    }
  }, {
    key: 'ContextType',
    get: function get() {
      return ContextType;
    }
  }, {
    key: 'LevelType',
    get: function get() {
      return LevelType;
    }
  }]);

  return PlaylistLoader;
}(_eventHandler2.default);

exports.default = PlaylistLoader;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/observer.js":
/*!********************************!*\
  !*** ./src/hls.js/observer.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Observer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventemitter = __webpack_require__(/*! eventemitter3 */ "../../node_modules/eventemitter3/index.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class
 *
 * Simple adapter sub-class of Nodejs-like EventEmitter.
 *
 * We simply want to pass along the event-name itself
 * in every call to a handler, which is the purpose of our `trigger` method
 * extending the standard API.
 *
 */
var Observer = exports.Observer = function (_EventEmitter) {
  _inherits(Observer, _EventEmitter);

  function Observer() {
    _classCallCheck(this, Observer);

    return _possibleConstructorReturn(this, (Observer.__proto__ || Object.getPrototypeOf(Observer)).apply(this, arguments));
  }

  _createClass(Observer, [{
    key: 'trigger',

    /**
     *
     * @param {string} event
     * @param {any} data
     */
    value: function trigger(event) {
      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      this.emit.apply(this, [event, event].concat(data));
    }
  }]);

  return Observer;
}(_eventemitter.EventEmitter);

/***/ }),

/***/ "./src/hls.js/remux/aac-helper.js":
/*!****************************************!*\
  !*** ./src/hls.js/remux/aac-helper.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  AAC helper
 */

var AAC = function () {
  function AAC() {
    _classCallCheck(this, AAC);
  }

  _createClass(AAC, null, [{
    key: 'getSilentFrame',
    value: function getSilentFrame(codec, channelCount) {
      switch (codec) {
        case 'mp4a.40.2':
          if (channelCount === 1) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
          } else if (channelCount === 2) {
            return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
          } else if (channelCount === 3) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
          } else if (channelCount === 4) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
          } else if (channelCount === 5) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
          } else if (channelCount === 6) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
          }

          break;
        // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
        default:
          if (channelCount === 1) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          } else if (channelCount === 2) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          } else if (channelCount === 3) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          }
          break;
      }
      return null;
    }
  }]);

  return AAC;
}();

exports.default = AAC;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/remux/mp4-generator.js":
/*!*******************************************!*\
  !*** ./src/hls.js/remux/mp4-generator.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generate MP4 Box
*/

var UINT32_MAX = Math.pow(2, 32) - 1;

var MP4 = function () {
  function MP4() {
    _classCallCheck(this, MP4);
  }

  _createClass(MP4, null, [{
    key: 'init',
    value: function init() {
      MP4.types = {
        avc1: [], // codingname
        avcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        '.mp3': [],
        mvex: [],
        mvhd: [],
        pasp: [],
        sdtp: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        tfdt: [],
        tfhd: [],
        traf: [],
        trak: [],
        trun: [],
        trex: [],
        tkhd: [],
        vmhd: [],
        smhd: []
      };

      var i = void 0;
      for (i in MP4.types) {
        if (MP4.types.hasOwnProperty(i)) {
          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
        }
      }

      var videoHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
      ]);

      var audioHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
      ]);

      MP4.HDLR_TYPES = {
        'video': videoHdlr,
        'audio': audioHdlr
      };

      var dref = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01, // entry_count
      0x00, 0x00, 0x00, 0x0c, // entry_size
      0x75, 0x72, 0x6c, 0x20, // 'url' type
      0x00, // version 0
      0x00, 0x00, 0x01 // entry_flags
      ]);

      var stco = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00 // entry_count
      ]);

      MP4.STTS = MP4.STSC = MP4.STCO = stco;

      MP4.STSZ = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // sample_size
      0x00, 0x00, 0x00, 0x00 // sample_count
      ]);
      MP4.VMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x01, // flags
      0x00, 0x00, // graphicsmode
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
      ]);
      MP4.SMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, // balance
      0x00, 0x00 // reserved
      ]);

      MP4.STSD = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01]); // entry_count

      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
      var minorVersion = new Uint8Array([0, 0, 0, 1]);

      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
    }
  }, {
    key: 'box',
    value: function box(type) {
      var payload = Array.prototype.slice.call(arguments, 1),
          size = 8,
          i = payload.length,
          len = i,
          result = void 0;
      // calculate the total size we need to allocate
      while (i--) {
        size += payload[i].byteLength;
      }

      result = new Uint8Array(size);
      result[0] = size >> 24 & 0xff;
      result[1] = size >> 16 & 0xff;
      result[2] = size >> 8 & 0xff;
      result[3] = size & 0xff;
      result.set(type, 4);
      // copy the payload into the result
      for (i = 0, size = 8; i < len; i++) {
        // copy payload[i] array @ offset size
        result.set(payload[i], size);
        size += payload[i].byteLength;
      }
      return result;
    }
  }, {
    key: 'hdlr',
    value: function hdlr(type) {
      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
    }
  }, {
    key: 'mdat',
    value: function mdat(data) {
      return MP4.box(MP4.types.mdat, data);
    }
  }, {
    key: 'mdhd',
    value: function mdhd(timescale, duration) {
      duration *= timescale;
      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return MP4.box(MP4.types.mdhd, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x55, 0xc4, // 'und' language (undetermined)
      0x00, 0x00]));
    }
  }, {
    key: 'mdia',
    value: function mdia(track) {
      return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
    }
  }, {
    key: 'mfhd',
    value: function mfhd(sequenceNumber) {
      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
      sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF // sequence_number
      ]));
    }
  }, {
    key: 'minf',
    value: function minf(track) {
      if (track.type === 'audio') {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
      } else {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
      }
    }
  }, {
    key: 'moof',
    value: function moof(sn, baseMediaDecodeTime, track) {
      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
    }
    /**
    * @param tracks... (optional) {array} the tracks associated with this movie
    */

  }, {
    key: 'moov',
    value: function moov(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trak(tracks[i]);
      }

      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
    }
  }, {
    key: 'mvex',
    value: function mvex(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trex(tracks[i]);
      }

      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
    }
  }, {
    key: 'mvhd',
    value: function mvhd(timescale, duration) {
      duration *= timescale;
      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      var bytes = new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x01, 0x00, 0x00, // 1.0 rate
      0x01, 0x00, // 1.0 volume
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      0xff, 0xff, 0xff, 0xff // next_track_ID
      ]);
      return MP4.box(MP4.types.mvhd, bytes);
    }
  }, {
    key: 'sdtp',
    value: function sdtp(track) {
      var samples = track.samples || [],
          bytes = new Uint8Array(4 + samples.length),
          flags = void 0,
          i = void 0;
      // leave the full box header (4 bytes) all zero
      // write the sample table
      for (i = 0; i < samples.length; i++) {
        flags = samples[i].flags;
        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
      }

      return MP4.box(MP4.types.sdtp, bytes);
    }
  }, {
    key: 'stbl',
    value: function stbl(track) {
      return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
    }
  }, {
    key: 'avc1',
    value: function avc1(track) {
      var sps = [],
          pps = [],
          i = void 0,
          data = void 0,
          len = void 0;
      // assemble the SPSs

      for (i = 0; i < track.sps.length; i++) {
        data = track.sps[i];
        len = data.byteLength;
        sps.push(len >>> 8 & 0xFF);
        sps.push(len & 0xFF);

        // SPS
        sps = sps.concat(Array.prototype.slice.call(data));
      }

      // assemble the PPSs
      for (i = 0; i < track.pps.length; i++) {
        data = track.pps[i];
        len = data.byteLength;
        pps.push(len >>> 8 & 0xFF);
        pps.push(len & 0xFF);

        pps = pps.concat(Array.prototype.slice.call(data));
      }

      var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version
      sps[3], // profile
      sps[4], // profile compat
      sps[5], // level
      0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes
      0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
      ].concat(sps).concat([track.pps.length // numOfPictureParameterSets
      ]).concat(pps))),
          // "PPS"
      width = track.width,
          height = track.height,
          hSpacing = track.pixelRatio[0],
          vSpacing = track.pixelRatio[1];

      return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, // pre_defined
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      width >> 8 & 0xFF, width & 0xff, // width
      height >> 8 & 0xFF, height & 0xff, // height
      0x00, 0x48, 0x00, 0x00, // horizresolution
      0x00, 0x48, 0x00, 0x00, // vertresolution
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // frame_count
      0x12, 0x64, 0x61, 0x69, 0x6C, // dailymotion/hls.js
      0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname
      0x00, 0x18, // depth = 24
      0x11, 0x11]), // pre_defined = -1
      avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB
      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate
      0x00, 0x2d, 0xc6, 0xc0])), // avgBitrate
      MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24, // hSpacing
      hSpacing >> 16 & 0xFF, hSpacing >> 8 & 0xFF, hSpacing & 0xFF, vSpacing >> 24, // vSpacing
      vSpacing >> 16 & 0xFF, vSpacing >> 8 & 0xFF, vSpacing & 0xFF])));
    }
  }, {
    key: 'esds',
    value: function esds(track) {
      var configlen = track.config.length;
      return new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags

      0x03, // descriptor_type
      0x17 + configlen, // length
      0x00, 0x01, // es_id
      0x00, // stream_priority

      0x04, // descriptor_type
      0x0f + configlen, // length
      0x40, // codec : mpeg4_audio
      0x15, // stream_type
      0x00, 0x00, 0x00, // buffer_size
      0x00, 0x00, 0x00, 0x00, // maxBitrate
      0x00, 0x00, 0x00, 0x00, // avgBitrate

      0x05 // descriptor_type
      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
    }
  }, {
    key: 'mp4a',
    value: function mp4a(track) {
      var samplerate = track.samplerate;
      return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      samplerate >> 8 & 0xFF, samplerate & 0xff, //
      0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
    }
  }, {
    key: 'mp3',
    value: function mp3(track) {
      var samplerate = track.samplerate;
      return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      samplerate >> 8 & 0xFF, samplerate & 0xff, //
      0x00, 0x00]));
    }
  }, {
    key: 'stsd',
    value: function stsd(track) {
      if (track.type === 'audio') {
        if (!track.isAAC && track.codec === 'mp3') {
          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
        }

        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
      } else {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
      }
    }
  }, {
    key: 'tkhd',
    value: function tkhd(track) {
      var id = track.id,
          duration = track.duration * track.timescale,
          width = track.width,
          height = track.height,
          upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)),
          lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return MP4.box(MP4.types.tkhd, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x07, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x00, // reserved
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, // layer
      0x00, 0x00, // alternate_group
      0x00, 0x00, // non-audio track volume
      0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width
      height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height
      ]));
    }
  }, {
    key: 'traf',
    value: function traf(track, baseMediaDecodeTime) {
      var sampleDependencyTable = MP4.sdtp(track),
          id = track.id,
          upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)),
          lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF]) // track_ID
      ), MP4.box(MP4.types.tfdt, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0XFF, upperWordBaseMediaDecodeTime >> 8 & 0XFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0XFF, lowerWordBaseMediaDecodeTime >> 8 & 0XFF, lowerWordBaseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
      20 + // tfdt
      8 + // traf header
      16 + // mfhd
      8 + // moof header
      8), // mdat header
      sampleDependencyTable);
    }

    /**
     * Generate a track box.
     * @param track {object} a track definition
     * @return {Uint8Array} the track box
     */

  }, {
    key: 'trak',
    value: function trak(track) {
      track.duration = track.duration || 0xffffffff;
      return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
    }
  }, {
    key: 'trex',
    value: function trex(track) {
      var id = track.id;
      return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x01, // default_sample_description_index
      0x00, 0x00, 0x00, 0x00, // default_sample_duration
      0x00, 0x00, 0x00, 0x00, // default_sample_size
      0x00, 0x01, 0x00, 0x01 // default_sample_flags
      ]));
    }
  }, {
    key: 'trun',
    value: function trun(track, offset) {
      var samples = track.samples || [],
          len = samples.length,
          arraylen = 12 + 16 * len,
          array = new Uint8Array(arraylen),
          i = void 0,
          sample = void 0,
          duration = void 0,
          size = void 0,
          flags = void 0,
          cts = void 0;
      offset += 8 + arraylen;
      array.set([0x00, // version 0
      0x00, 0x0f, 0x01, // flags
      len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count
      offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset
      ], 0);
      for (i = 0; i < len; i++) {
        sample = samples[i];
        duration = sample.duration;
        size = sample.size;
        flags = sample.flags;
        cts = sample.cts;
        array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration
        size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size
        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags
        cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset
        ], 12 + 16 * i);
      }
      return MP4.box(MP4.types.trun, array);
    }
  }, {
    key: 'initSegment',
    value: function initSegment(tracks) {
      if (!MP4.types) {
        MP4.init();
      }

      var movie = MP4.moov(tracks),
          result = void 0;
      result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
      result.set(MP4.FTYP);
      result.set(movie, MP4.FTYP.byteLength);
      return result;
    }
  }]);

  return MP4;
}();

exports.default = MP4;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/remux/mp4-remuxer.js":
/*!*****************************************!*\
  !*** ./src/hls.js/remux/mp4-remuxer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * fMP4 remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _aacHelper = __webpack_require__(/*! ./aac-helper */ "./src/hls.js/remux/aac-helper.js");

var _aacHelper2 = _interopRequireDefault(_aacHelper);

var _mp4Generator = __webpack_require__(/*! ./mp4-generator */ "./src/hls.js/remux/mp4-generator.js");

var _mp4Generator2 = _interopRequireDefault(_mp4Generator);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 10 seconds
var MAX_SILENT_FRAME_DURATION = 10 * 1000;

var MP4Remuxer = function () {
  function MP4Remuxer(observer, config, typeSupported, vendor) {
    _classCallCheck(this, MP4Remuxer);

    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    var userAgent = navigator.userAgent;
    this.isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');
    this.ISGenerated = false;
  }

  _createClass(MP4Remuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp(defaultTimeStamp) {
      this._initPTS = this._initDTS = defaultTimeStamp;
    }
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment() {
      this.ISGenerated = false;
    }
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      // generate Init Segment if needed
      if (!this.ISGenerated) {
        this.generateIS(audioTrack, videoTrack, timeOffset);
      }

      if (this.ISGenerated) {
        var nbAudioSamples = audioTrack.samples.length;
        var nbVideoSamples = videoTrack.samples.length;
        var audioTimeOffset = timeOffset;
        var videoTimeOffset = timeOffset;
        if (nbAudioSamples && nbVideoSamples) {
          // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)
          // if first audio DTS is not aligned with first video DTS then we need to take that into account
          // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small
          // drift between audio and video streams
          var audiovideoDeltaDts = (audioTrack.samples[0].pts - videoTrack.samples[0].pts) / videoTrack.inputTimeScale;
          audioTimeOffset += Math.max(0, audiovideoDeltaDts);
          videoTimeOffset += Math.max(0, -audiovideoDeltaDts);
        }
        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is
        // calculated in remuxAudio.
        // logger.log('nb AAC samples:' + audioTrack.samples.length);
        if (nbAudioSamples) {
          // if initSegment was generated without video samples, regenerate it again
          if (!audioTrack.timescale) {
            _logger.logger.warn('regenerate InitSegment as audio detected');
            this.generateIS(audioTrack, videoTrack, timeOffset);
          }
          var audioData = this.remuxAudio(audioTrack, audioTimeOffset, contiguous, accurateTimeOffset);
          // logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (nbVideoSamples) {
            var audioTrackLength = void 0;
            if (audioData) {
              audioTrackLength = audioData.endPTS - audioData.startPTS;
            }

            // if initSegment was generated without video samples, regenerate it again
            if (!videoTrack.timescale) {
              _logger.logger.warn('regenerate InitSegment as video detected');
              this.generateIS(audioTrack, videoTrack, timeOffset);
            }
            this.remuxVideo(videoTrack, videoTimeOffset, contiguous, audioTrackLength, accurateTimeOffset);
          }
        } else {
          // logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (nbVideoSamples) {
            var videoData = this.remuxVideo(videoTrack, videoTimeOffset, contiguous, 0, accurateTimeOffset);
            if (videoData && audioTrack.codec) {
              this.remuxEmptyAudio(audioTrack, audioTimeOffset, contiguous, videoData);
            }
          }
        }
      }
      // logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (id3Track.samples.length) {
        this.remuxID3(id3Track, timeOffset);
      }

      // logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (textTrack.samples.length) {
        this.remuxText(textTrack, timeOffset);
      }

      // notify end of parsing
      this.observer.trigger(_events2.default.FRAG_PARSED);
    }
  }, {
    key: 'generateIS',
    value: function generateIS(audioTrack, videoTrack, timeOffset) {
      var observer = this.observer,
          audioSamples = audioTrack.samples,
          videoSamples = videoTrack.samples,
          typeSupported = this.typeSupported,
          container = 'audio/mp4',
          tracks = {},
          data = { tracks: tracks },
          computePTSDTS = this._initPTS === undefined,
          initPTS = void 0,
          initDTS = void 0;

      if (computePTSDTS) {
        initPTS = initDTS = Infinity;
      }

      if (audioTrack.config && audioSamples.length) {
        // let's use audio sampling rate as MP4 time scale.
        // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)
        // using audio sampling rate here helps having an integer MP4 frame duration
        // this avoids potential rounding issue and AV sync issue
        audioTrack.timescale = audioTrack.samplerate;
        _logger.logger.log('audio sampling rate : ' + audioTrack.samplerate);
        if (!audioTrack.isAAC) {
          if (typeSupported.mpeg) {
            // Chrome and Safari
            container = 'audio/mpeg';
            audioTrack.codec = '';
          } else if (typeSupported.mp3) {
            // Firefox
            audioTrack.codec = 'mp3';
          }
        }
        tracks.audio = {
          container: container,
          codec: audioTrack.codec,
          initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : _mp4Generator2.default.initSegment([audioTrack]),
          metadata: {
            channelCount: audioTrack.channelCount
          }
        };
        if (computePTSDTS) {
          // remember first PTS of this demuxing context. for audio, PTS = DTS
          initPTS = initDTS = audioSamples[0].pts - audioTrack.inputTimeScale * timeOffset;
        }
      }

      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
        // let's use input time scale as MP4 video timescale
        // we use input time scale straight away to avoid rounding issues on frame duration / cts computation
        var inputTimeScale = videoTrack.inputTimeScale;
        videoTrack.timescale = inputTimeScale;
        tracks.video = {
          container: 'video/mp4',
          codec: videoTrack.codec,
          initSegment: _mp4Generator2.default.initSegment([videoTrack]),
          metadata: {
            width: videoTrack.width,
            height: videoTrack.height
          }
        };
        if (computePTSDTS) {
          initPTS = Math.min(initPTS, videoSamples[0].pts - inputTimeScale * timeOffset);
          initDTS = Math.min(initDTS, videoSamples[0].dts - inputTimeScale * timeOffset);
          this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });
        }
      }

      if (Object.keys(tracks).length) {
        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
        this.ISGenerated = true;
        if (computePTSDTS) {
          this._initPTS = initPTS;
          this._initDTS = initDTS;
        }
      } else {
        observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });
      }
    }
  }, {
    key: 'remuxVideo',
    value: function remuxVideo(track, timeOffset, contiguous, audioTrackLength, accurateTimeOffset) {
      var offset = 8;
      var mp4SampleDuration = void 0;
      var mdat = void 0;
      var moof = void 0;
      var firstPTS = void 0;
      var firstDTS = void 0;
      var lastPTS = void 0;
      var lastDTS = void 0;
      var timeScale = track.timescale;
      var inputSamples = track.samples;
      var outputSamples = [];
      var nbSamples = inputSamples.length;
      var ptsNormalize = this._PTSNormalize;
      var initPTS = this._initPTS;

      // if parsed fragment is contiguous with last one, let's use last DTS value as reference
      var nextAvcDts = this.nextAvcDts;

      var isSafari = this.isSafari;

      if (nbSamples === 0) {
        return;
      }

      // Safari does not like overlapping DTS on consecutive fragments. let's use nextAvcDts to overcome this if fragments are consecutive
      if (isSafari) {
        // also consider consecutive fragments as being contiguous (even if a level switch occurs),
        // for sake of clarity:
        // consecutive fragments are frags with
        //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
        //  - less than 200 ms PTS gaps (timeScale/5)
        contiguous |= inputSamples.length && nextAvcDts && (accurateTimeOffset && Math.abs(timeOffset - nextAvcDts / timeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAvcDts - initPTS) < timeScale / 5);
      }

      if (!contiguous) {
        // if not contiguous, let's use target timeOffset
        nextAvcDts = timeOffset * timeScale;
      }

      // PTS is coded on 33bits, and can loop from -2^32 to 2^32
      // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
      inputSamples.forEach(function (sample) {
        sample.pts = ptsNormalize(sample.pts - initPTS, nextAvcDts);
        sample.dts = ptsNormalize(sample.dts - initPTS, nextAvcDts);
      });

      // sort video samples by DTS then PTS then demux id order
      inputSamples.sort(function (a, b) {
        var deltadts = a.dts - b.dts;
        var deltapts = a.pts - b.pts;
        return deltadts || deltapts || a.id - b.id;
      });

      // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)
      var PTSDTSshift = inputSamples.reduce(function (prev, curr) {
        return Math.max(Math.min(prev, curr.pts - curr.dts), -18000);
      }, 0);
      if (PTSDTSshift < 0) {
        _logger.logger.warn('PTS < DTS detected in video samples, shifting DTS by ' + Math.round(PTSDTSshift / 90) + ' ms to overcome this issue');
        for (var i = 0; i < inputSamples.length; i++) {
          inputSamples[i].dts += PTSDTSshift;
        }
      }

      // compute first DTS and last DTS, normalize them against reference value
      var sample = inputSamples[0];
      firstDTS = Math.max(sample.dts, 0);
      firstPTS = Math.max(sample.pts, 0);

      // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)
      var delta = Math.round((firstDTS - nextAvcDts) / 90);
      // if fragment are contiguous, detect hole/overlapping between fragments
      if (contiguous) {
        if (delta) {
          if (delta > 1) {
            _logger.logger.log('AVC:' + delta + ' ms hole between fragments detected,filling it');
          } else if (delta < -1) {
            _logger.logger.log('AVC:' + -delta + ' ms overlapping between fragments detected');
          }

          // remove hole/gap : set DTS to next expected DTS
          firstDTS = nextAvcDts;
          inputSamples[0].dts = firstDTS;
          // offset PTS as well, ensure that PTS is smaller or equal than new DTS
          firstPTS = Math.max(firstPTS - delta, nextAvcDts);
          inputSamples[0].pts = firstPTS;
          _logger.logger.log('Video/PTS/DTS adjusted: ' + Math.round(firstPTS / 90) + '/' + Math.round(firstDTS / 90) + ',delta:' + delta + ' ms');
        }
      }

      // compute lastPTS/lastDTS
      sample = inputSamples[inputSamples.length - 1];
      lastDTS = Math.max(sample.dts, 0);
      lastPTS = Math.max(sample.pts, 0, lastDTS);

      // on Safari let's signal the same sample duration for all samples
      // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
      // set this constant duration as being the avg delta between consecutive DTS.
      if (isSafari) {
        mp4SampleDuration = Math.round((lastDTS - firstDTS) / (inputSamples.length - 1));
      }

      var nbNalu = 0,
          naluLen = 0;
      for (var _i = 0; _i < nbSamples; _i++) {
        // compute total/avc sample length and nb of NAL units
        var _sample = inputSamples[_i],
            units = _sample.units,
            nbUnits = units.length,
            sampleLen = 0;
        for (var j = 0; j < nbUnits; j++) {
          sampleLen += units[j].data.length;
        }

        naluLen += sampleLen;
        nbNalu += nbUnits;
        _sample.length = sampleLen;

        // normalize PTS/DTS
        if (isSafari) {
          // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
          _sample.dts = firstDTS + _i * mp4SampleDuration;
        } else {
          // ensure sample monotonic DTS
          _sample.dts = Math.max(_sample.dts, firstDTS);
        }
        // ensure that computed value is greater or equal than sample DTS
        _sample.pts = Math.max(_sample.pts, _sample.dts);
      }

      /* concatenate the video data and construct the mdat in place
        (need 8 more bytes to fill length and mpdat type) */
      var mdatSize = naluLen + 4 * nbNalu + 8;
      try {
        mdat = new Uint8Array(mdatSize);
      } catch (err) {
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating video mdat ' + mdatSize });
        return;
      }
      var view = new DataView(mdat.buffer);
      view.setUint32(0, mdatSize);
      mdat.set(_mp4Generator2.default.types.mdat, 4);

      for (var _i2 = 0; _i2 < nbSamples; _i2++) {
        var avcSample = inputSamples[_i2],
            avcSampleUnits = avcSample.units,
            mp4SampleLength = 0,
            compositionTimeOffset = void 0;
        // convert NALU bitstream to MP4 format (prepend NALU with size field)
        for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {
          var unit = avcSampleUnits[_j],
              unitData = unit.data,
              unitDataLen = unit.data.byteLength;
          view.setUint32(offset, unitDataLen);
          offset += 4;
          mdat.set(unitData, offset);
          offset += unitDataLen;
          mp4SampleLength += 4 + unitDataLen;
        }

        if (!isSafari) {
          // expected sample duration is the Decoding Timestamp diff of consecutive samples
          if (_i2 < nbSamples - 1) {
            mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;
          } else {
            var config = this.config,
                lastFrameDuration = avcSample.dts - inputSamples[_i2 > 0 ? _i2 - 1 : _i2].dts;
            if (config.stretchShortVideoTrack) {
              // In some cases, a segment's audio track duration may exceed the video track duration.
              // Since we've already remuxed audio, and we know how long the audio track is, we look to
              // see if the delta to the next segment is longer than maxBufferHole.
              // If so, playback would potentially get stuck, so we artificially inflate
              // the duration of the last frame to minimize any potential gap between segments.
              var maxBufferHole = config.maxBufferHole,
                  gapTolerance = Math.floor(maxBufferHole * timeScale),
                  deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;
              if (deltaToFrameEnd > gapTolerance) {
                // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
                // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.
                mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                if (mp4SampleDuration < 0) {
                  mp4SampleDuration = lastFrameDuration;
                }

                _logger.logger.log('It is approximately ' + deltaToFrameEnd / 90 + ' ms to the next segment; using duration ' + mp4SampleDuration / 90 + ' ms for the last video frame.');
              } else {
                mp4SampleDuration = lastFrameDuration;
              }
            } else {
              mp4SampleDuration = lastFrameDuration;
            }
          }
          compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);
        } else {
          compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / mp4SampleDuration));
        }

        // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');
        // console.log(`avcSample.dts: ${avcSample.dts / 90}, avcSample.pts: ${avcSample.pts / 90}, mp4SampleDuration: ${mp4SampleDuration / 90}`, avcSample)
        outputSamples.push({
          size: mp4SampleLength,
          // constant duration
          duration: mp4SampleDuration,
          cts: compositionTimeOffset,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: avcSample.key ? 2 : 1,
            isNonSync: avcSample.key ? 0 : 1
          }
        });
      }
      // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
      this.nextAvcDts = lastDTS + mp4SampleDuration;
      var dropped = track.dropped;
      track.len = 0;
      track.nbNalu = 0;
      track.dropped = 0;
      if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
        var flags = outputSamples[0].flags;
        // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
        // https://code.google.com/p/chromium/issues/detail?id=229412
        flags.dependsOn = 2;
        flags.isNonSync = 0;
      }
      track.samples = outputSamples;
      moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS, track);
      track.samples = [];

      var data = {
        data1: moof,
        data2: mdat,
        startPTS: firstPTS / timeScale,
        endPTS: (lastPTS + mp4SampleDuration) / timeScale,
        startDTS: firstDTS / timeScale,
        endDTS: this.nextAvcDts / timeScale,
        type: 'video',
        hasAudio: false,
        hasVideo: true,
        nb: outputSamples.length,
        dropped: dropped
      };
      this.observer.trigger(_events2.default.FRAG_PARSING_DATA, data);
      return data;
    }
  }, {
    key: 'remuxAudio',
    value: function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset) {
      var inputTimeScale = track.inputTimeScale;
      var mp4timeScale = track.timescale;
      var scaleFactor = inputTimeScale / mp4timeScale;
      var mp4SampleDuration = track.isAAC ? 1024 : 1152;
      var inputSampleDuration = mp4SampleDuration * scaleFactor;
      var ptsNormalize = this._PTSNormalize;
      var initPTS = this._initPTS;
      var rawMPEG = !track.isAAC && this.typeSupported.mpeg;

      var offset = void 0,
          mp4Sample = void 0,
          fillFrame = void 0,
          mdat = void 0,
          moof = void 0,
          firstPTS = void 0,
          lastPTS = void 0,
          inputSamples = track.samples,
          outputSamples = [],
          nextAudioPts = this.nextAudioPts;

      // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
      // for sake of clarity:
      // consecutive fragments are frags with
      //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
      //  - less than 20 audio frames distance
      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
      // this helps ensuring audio continuity
      // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame
      contiguous |= inputSamples.length && nextAudioPts && (accurateTimeOffset && Math.abs(timeOffset - nextAudioPts / inputTimeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAudioPts - initPTS) < 20 * inputSampleDuration);

      // compute normalized PTS
      inputSamples.forEach(function (sample) {
        sample.pts = sample.dts = ptsNormalize(sample.pts - initPTS, timeOffset * inputTimeScale);
      });

      // filter out sample with negative PTS that are not playable anyway
      // if we don't remove these negative samples, they will shift all audio samples forward.
      // leading to audio overlap between current / next fragment
      inputSamples = inputSamples.filter(function (sample) {
        return sample.pts >= 0;
      });

      // in case all samples have negative PTS, and have been filtered out, return now
      if (inputSamples.length === 0) {
        return;
      }

      if (!contiguous) {
        if (!accurateTimeOffset) {
          // if frag are mot contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS
          nextAudioPts = inputSamples[0].pts;
        } else {
          // if timeOffset is accurate, let's use it as predicted next audio PTS
          nextAudioPts = timeOffset * inputTimeScale;
        }
      }

      // If the audio track is missing samples, the frames seem to get "left-shifted" within the
      // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
      // In an effort to prevent this from happening, we inject frames here where there are gaps.
      // When possible, we inject a silent frame; when that's not possible, we duplicate the last
      // frame.

      if (track.isAAC) {
        var maxAudioFramesDrift = this.config.maxAudioFramesDrift;
        for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length;) {
          // First, let's see how far off this frame is from where we expect it to be
          var sample = inputSamples[i],
              delta;
          var pts = sample.pts;
          delta = pts - nextPts;

          var duration = Math.abs(1000 * delta / inputTimeScale);

          // If we're overlapping by more than a duration, drop this sample
          if (delta <= -maxAudioFramesDrift * inputSampleDuration) {
            _logger.logger.warn('Dropping 1 audio frame @ ' + (nextPts / inputTimeScale).toFixed(3) + 's due to ' + Math.round(duration) + ' ms overlap.');
            inputSamples.splice(i, 1);
            track.len -= sample.unit.length;
            // Don't touch nextPtsNorm or i
          } // eslint-disable-line brace-style

          // Insert missing frames if:
          // 1: We're more than maxAudioFramesDrift frame away
          // 2: Not more than MAX_SILENT_FRAME_DURATION away
          // 3: currentTime (aka nextPtsNorm) is not 0
          else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && nextPts) {
              var missing = Math.round(delta / inputSampleDuration);
              _logger.logger.warn('Injecting ' + missing + ' audio frame @ ' + (nextPts / inputTimeScale).toFixed(3) + 's due to ' + Math.round(1000 * delta / inputTimeScale) + ' ms gap.');
              for (var j = 0; j < missing; j++) {
                var newStamp = Math.max(nextPts, 0);
                fillFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                if (!fillFrame) {
                  _logger.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');
                  fillFrame = sample.unit.subarray();
                }
                inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });
                track.len += fillFrame.length;
                nextPts += inputSampleDuration;
                i++;
              }

              // Adjust sample to next expected pts
              sample.pts = sample.dts = nextPts;
              nextPts += inputSampleDuration;
              i++;
            } else {
              // Otherwise, just adjust pts
              if (Math.abs(delta) > 0.1 * inputSampleDuration) {
                // logger.log(`Invalid frame delta ${Math.round(delta + inputSampleDuration)} at PTS ${Math.round(pts / 90)} (should be ${Math.round(inputSampleDuration)}).`);
              }
              sample.pts = sample.dts = nextPts;
              nextPts += inputSampleDuration;
              i++;
            }
        }
      }

      for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {
        var audioSample = inputSamples[_j2];
        var unit = audioSample.unit;
        var _pts = audioSample.pts;
        // logger.log(`Audio/PTS:${Math.round(pts/90)}`);
        // if not first sample
        if (lastPTS !== undefined) {
          mp4Sample.duration = Math.round((_pts - lastPTS) / scaleFactor);
        } else {
          var _delta = Math.round(1000 * (_pts - nextAudioPts) / inputTimeScale),
              numMissingFrames = 0;
          // if fragment are contiguous, detect hole/overlapping between fragments
          // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
          if (contiguous && track.isAAC) {
            // log delta
            if (_delta) {
              if (_delta > 0 && _delta < MAX_SILENT_FRAME_DURATION) {
                numMissingFrames = Math.round((_pts - nextAudioPts) / inputSampleDuration);
                _logger.logger.log(_delta + ' ms hole between AAC samples detected,filling it');
                if (numMissingFrames > 0) {
                  fillFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                  if (!fillFrame) {
                    fillFrame = unit.subarray();
                  }

                  track.len += numMissingFrames * fillFrame.length;
                }
                // if we have frame overlap, overlapping for more than half a frame duraion
              } else if (_delta < -12) {
                // drop overlapping audio frames... browser will deal with it
                _logger.logger.log('drop overlapping AAC sample, expected/parsed/delta:' + (nextAudioPts / inputTimeScale).toFixed(3) + 's/' + (_pts / inputTimeScale).toFixed(3) + 's/' + -_delta + 'ms');
                track.len -= unit.byteLength;
                continue;
              }
              // set PTS/DTS to expected PTS/DTS
              _pts = nextAudioPts;
            }
          }
          // remember first PTS of our audioSamples
          firstPTS = _pts;
          if (track.len > 0) {
            /* concatenate the audio data and construct the mdat in place
              (need 8 more bytes to fill length and mdat type) */
            var mdatSize = rawMPEG ? track.len : track.len + 8;
            offset = rawMPEG ? 0 : 8;
            try {
              mdat = new Uint8Array(mdatSize);
            } catch (err) {
              this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating audio mdat ' + mdatSize });
              return;
            }
            if (!rawMPEG) {
              var view = new DataView(mdat.buffer);
              view.setUint32(0, mdatSize);
              mdat.set(_mp4Generator2.default.types.mdat, 4);
            }
          } else {
            // no audio samples
            return;
          }
          for (var _i3 = 0; _i3 < numMissingFrames; _i3++) {
            fillFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
            if (!fillFrame) {
              _logger.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');
              fillFrame = unit.subarray();
            }
            mdat.set(fillFrame, offset);
            offset += fillFrame.byteLength;
            mp4Sample = {
              size: fillFrame.byteLength,
              cts: 0,
              duration: 1024,
              flags: {
                isLeading: 0,
                isDependedOn: 0,
                hasRedundancy: 0,
                degradPrio: 0,
                dependsOn: 1
              }
            };
            outputSamples.push(mp4Sample);
          }
        }
        mdat.set(unit, offset);
        var unitLen = unit.byteLength;
        offset += unitLen;
        // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');
        mp4Sample = {
          size: unitLen,
          cts: 0,
          duration: 0,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: 1
          }
        };
        outputSamples.push(mp4Sample);
        lastPTS = _pts;
      }
      var lastSampleDuration = 0;
      var nbSamples = outputSamples.length;
      // set last sample duration as being identical to previous sample
      if (nbSamples >= 2) {
        lastSampleDuration = outputSamples[nbSamples - 2].duration;
        mp4Sample.duration = lastSampleDuration;
      }
      if (nbSamples) {
        // next audio sample PTS should be equal to last sample PTS + duration
        this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSampleDuration;
        // logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));
        track.len = 0;
        track.samples = outputSamples;
        if (rawMPEG) {
          moof = new Uint8Array();
        } else {
          moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstPTS / scaleFactor, track);
        }

        track.samples = [];
        var start = firstPTS / inputTimeScale;
        var end = nextAudioPts / inputTimeScale;
        var audioData = {
          data1: moof,
          data2: mdat,
          startPTS: start,
          endPTS: end,
          startDTS: start,
          endDTS: end,
          type: 'audio',
          hasAudio: true,
          hasVideo: false,
          nb: nbSamples
        };
        this.observer.trigger(_events2.default.FRAG_PARSING_DATA, audioData);
        return audioData;
      }
      return null;
    }
  }, {
    key: 'remuxEmptyAudio',
    value: function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
      var inputTimeScale = track.inputTimeScale,
          mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale,
          scaleFactor = inputTimeScale / mp4timeScale,
          nextAudioPts = this.nextAudioPts,


      // sync with video's timestamp
      startDTS = (nextAudioPts !== undefined ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS,
          endDTS = videoData.endDTS * inputTimeScale + this._initDTS,

      // one sample's duration value
      sampleDuration = 1024,
          frameDuration = scaleFactor * sampleDuration,


      // samples count of this segment's duration
      nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),


      // silent frame
      silentFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);

      _logger.logger.warn('remux empty Audio');
      // Can't remux if we can't generate a silent frame...
      if (!silentFrame) {
        _logger.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');
        return;
      }

      var samples = [];
      for (var i = 0; i < nbSamples; i++) {
        var stamp = startDTS + i * frameDuration;
        samples.push({ unit: silentFrame, pts: stamp, dts: stamp });
        track.len += silentFrame.length;
      }
      track.samples = samples;

      this.remuxAudio(track, timeOffset, contiguous);
    }
  }, {
    key: 'remuxID3',
    value: function remuxID3(track) {
      var length = track.samples.length,
          sample = void 0;
      var inputTimeScale = track.inputTimeScale;
      var initPTS = this._initPTS;
      var initDTS = this._initDTS;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting id3 pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - initPTS) / inputTimeScale;
          sample.dts = (sample.dts - initDTS) / inputTimeScale;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_METADATA, {
          samples: track.samples
        });
      }

      track.samples = [];
    }
  }, {
    key: 'remuxText',
    value: function remuxText(track) {
      track.samples.sort(function (a, b) {
        return a.pts - b.pts;
      });

      var length = track.samples.length,
          sample = void 0;
      var inputTimeScale = track.inputTimeScale;
      var initPTS = this._initPTS;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting text pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - initPTS) / inputTimeScale;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_USERDATA, {
          samples: track.samples
        });
      }

      track.samples = [];
    }
  }, {
    key: '_PTSNormalize',
    value: function _PTSNormalize(value, reference) {
      var offset = void 0;
      if (reference === undefined) {
        return value;
      }

      if (reference < value) {
        // - 2^33
        offset = -8589934592;
      } else {
        // + 2^33
        offset = 8589934592;
      }
      /* PTS is 33bit (from 0 to 2^33 -1)
        if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
        PTS looping occured. fill the gap */
      while (Math.abs(value - reference) > 4294967296) {
        value += offset;
      }

      return value;
    }
  }]);

  return MP4Remuxer;
}();

exports.default = MP4Remuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/remux/passthrough-remuxer.js":
/*!*************************************************!*\
  !*** ./src/hls.js/remux/passthrough-remuxer.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * passthrough remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */


var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PassThroughRemuxer = function () {
  function PassThroughRemuxer(observer) {
    _classCallCheck(this, PassThroughRemuxer);

    this.observer = observer;
  }

  _createClass(PassThroughRemuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment() {}
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset, rawData) {
      var observer = this.observer;
      var streamType = '';
      if (audioTrack) {
        streamType += 'audio';
      }

      if (videoTrack) {
        streamType += 'video';
      }

      observer.trigger(_events2.default.FRAG_PARSING_DATA, {
        data1: rawData,
        startPTS: timeOffset,
        startDTS: timeOffset,
        type: streamType,
        hasAudio: !!audioTrack,
        hasVideo: !!videoTrack,
        nb: 1,
        dropped: 0
      });
      // notify end of parsing
      observer.trigger(_events2.default.FRAG_PARSED);
    }
  }]);

  return PassThroughRemuxer;
}();

exports.default = PassThroughRemuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/task-loop.js":
/*!*********************************!*\
  !*** ./src/hls.js/task-loop.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventHandler = __webpack_require__(/*! ./event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Sub-class specialization of EventHandler base class.
 *
 * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,
 * scheduled asynchroneously, avoiding recursive calls in the same tick.
 *
 * The task itself is implemented in `doTick`. It can be requested and called for single execution
 * using the `tick` method.
 *
 * It will be assured that the task execution method (`tick`) only gets called once per main loop "tick",
 * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.
 *
 * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,
 * and cancelled with `clearNextTick`.
 *
 * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).
 *
 * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.
 *
 * Further explanations:
 *
 * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously
 * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.
 *
 * When the task execution (`tick` method) is called in re-entrant way this is detected and
 * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further
 * task processing on the next main loop iteration (also known as "next tick" in the Node/JS runtime lingo).
 */

var TaskLoop = function (_EventHandler) {
  _inherits(TaskLoop, _EventHandler);

  function TaskLoop(hls) {
    var _ref;

    _classCallCheck(this, TaskLoop);

    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      events[_key - 1] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = TaskLoop.__proto__ || Object.getPrototypeOf(TaskLoop)).call.apply(_ref, [this, hls].concat(events)));

    _this._tickInterval = null;
    _this._tickTimer = null;
    _this._tickCallCount = 0;
    _this._boundTick = _this.tick.bind(_this);
    return _this;
  }

  /**
   * @override
   */


  _createClass(TaskLoop, [{
    key: 'onHandlerDestroying',
    value: function onHandlerDestroying() {
      // clear all timers before unregistering from event bus
      this.clearNextTick();
      this.clearInterval();
    }

    /**
     * @returns {boolean}
     */

  }, {
    key: 'hasInterval',
    value: function hasInterval() {
      return !!this._tickInterval;
    }

    /**
     * @returns {boolean}
     */

  }, {
    key: 'hasNextTick',
    value: function hasNextTick() {
      return !!this._tickTimer;
    }

    /**
     * @param {number} millis Interval time (ms)
     * @returns {boolean} True when interval has been scheduled, false when already scheduled (no effect)
     */

  }, {
    key: 'setInterval',
    value: function (_setInterval) {
      function setInterval(_x) {
        return _setInterval.apply(this, arguments);
      }

      setInterval.toString = function () {
        return _setInterval.toString();
      };

      return setInterval;
    }(function (millis) {
      if (!this._tickInterval) {
        this._tickInterval = setInterval(this._boundTick, millis);
        return true;
      }
      return false;
    })

    /**
     * @returns {boolean} True when interval was cleared, false when none was set (no effect)
     */

  }, {
    key: 'clearInterval',
    value: function (_clearInterval) {
      function clearInterval() {
        return _clearInterval.apply(this, arguments);
      }

      clearInterval.toString = function () {
        return _clearInterval.toString();
      };

      return clearInterval;
    }(function () {
      if (this._tickInterval) {
        clearInterval(this._tickInterval);
        this._tickInterval = null;
        return true;
      }
      return false;
    })

    /**
     * @returns {boolean} True when timeout was cleared, false when none was set (no effect)
     */

  }, {
    key: 'clearNextTick',
    value: function clearNextTick() {
      if (this._tickTimer) {
        clearTimeout(this._tickTimer);
        this._tickTimer = null;
        return true;
      }
      return false;
    }

    /**
     * Will call the subclass doTick implementation in this main loop tick
     * or in the next one (via setTimeout(,0)) in case it has already been called
     * in this tick (in case this is a re-entrant call).
     */

  }, {
    key: 'tick',
    value: function tick() {
      this._tickCallCount++;
      if (this._tickCallCount === 1) {
        this.doTick();
        // re-entrant call to tick from previous doTick call stack
        // -> schedule a call on the next main loop iteration to process this task processing request
        if (this._tickCallCount > 1) {
          // make sure only one timer exists at any time at max
          this.clearNextTick();
          this._tickTimer = setTimeout(this._boundTick, 0);
        }
        this._tickCallCount = 0;
      }
    }

    /**
     * For subclass to implement task logic
     * @abstract
     */

  }, {
    key: 'doTick',
    value: function doTick() {}
  }]);

  return TaskLoop;
}(_eventHandler2.default);

exports.default = TaskLoop;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/attr-list.js":
/*!***************************************!*\
  !*** ./src/hls.js/utils/attr-list.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/; // eslint-disable-line no-useless-escape
var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g; // eslint-disable-line no-useless-escape

// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js

var AttrList = function () {
  function AttrList(attrs) {
    _classCallCheck(this, AttrList);

    if (typeof attrs === 'string') {
      attrs = AttrList.parseAttrList(attrs);
    }

    for (var attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        this[attr] = attrs[attr];
      }
    }
  }

  _createClass(AttrList, [{
    key: 'decimalInteger',
    value: function decimalInteger(attrName) {
      var intValue = parseInt(this[attrName], 10);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }

      return intValue;
    }
  }, {
    key: 'hexadecimalInteger',
    value: function hexadecimalInteger(attrName) {
      if (this[attrName]) {
        var stringValue = (this[attrName] || '0x').slice(2);
        stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;

        var value = new Uint8Array(stringValue.length / 2);
        for (var i = 0; i < stringValue.length / 2; i++) {
          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
        }

        return value;
      } else {
        return null;
      }
    }
  }, {
    key: 'hexadecimalIntegerAsNumber',
    value: function hexadecimalIntegerAsNumber(attrName) {
      var intValue = parseInt(this[attrName], 16);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }

      return intValue;
    }
  }, {
    key: 'decimalFloatingPoint',
    value: function decimalFloatingPoint(attrName) {
      return parseFloat(this[attrName]);
    }
  }, {
    key: 'enumeratedString',
    value: function enumeratedString(attrName) {
      return this[attrName];
    }
  }, {
    key: 'decimalResolution',
    value: function decimalResolution(attrName) {
      var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
      if (res === null) {
        return undefined;
      }

      return {
        width: parseInt(res[1], 10),
        height: parseInt(res[2], 10)
      };
    }
  }], [{
    key: 'parseAttrList',
    value: function parseAttrList(input) {
      var match = void 0,
          attrs = {};
      ATTR_LIST_REGEX.lastIndex = 0;
      while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
        var value = match[2],
            quote = '"';

        if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
          value = value.slice(1, -1);
        }

        attrs[match[1]] = value;
      }
      return attrs;
    }
  }]);

  return AttrList;
}();

exports.default = AttrList;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/binary-search.js":
/*!*******************************************!*\
  !*** ./src/hls.js/utils/binary-search.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var BinarySearch = {
  /**
     * Searches for an item in an array which matches a certain condition.
     * This requires the condition to only match one item in the array,
     * and for the array to be ordered.
     *
     * @param {Array} list The array to search.
     * @param {Function} comparisonFunction
     *      Called and provided a candidate item as the first argument.
     *      Should return:
     *          > -1 if the item should be located at a lower index than the provided item.
     *          > 1 if the item should be located at a higher index than the provided item.
     *          > 0 if the item is the item you're looking for.
     *
     * @return {*} The object if it is found or null otherwise.
     */
  search: function search(list, comparisonFunction) {
    var minIndex = 0;
    var maxIndex = list.length - 1;
    var currentIndex = null;
    var currentElement = null;

    while (minIndex <= maxIndex) {
      currentIndex = (minIndex + maxIndex) / 2 | 0;
      currentElement = list[currentIndex];

      var comparisonResult = comparisonFunction(currentElement);
      if (comparisonResult > 0) {
        minIndex = currentIndex + 1;
      } else if (comparisonResult < 0) {
        maxIndex = currentIndex - 1;
      } else {
        return currentElement;
      }
    }

    return null;
  }
};

exports.default = BinarySearch;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/utils/buffer-helper.js":
/*!*******************************************!*\
  !*** ./src/hls.js/utils/buffer-helper.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module BufferHelper
 *
 * Providing methods dealing with buffer length retrieval for example.
 *
 * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.
 *
 * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered
*/

var BufferHelper = exports.BufferHelper = function () {
  function BufferHelper() {
    _classCallCheck(this, BufferHelper);
  }

  _createClass(BufferHelper, null, [{
    key: "isBuffered",

    /**
     * Return true if `media`'s buffered include `position`
     * @param {HTMLMediaElement|SourceBuffer} media
     * @param {number} position
     * @returns {boolean}
     */
    value: function isBuffered(media, position) {
      try {
        if (media) {
          var buffered = media.buffered;
          for (var i = 0; i < buffered.length; i++) {
            if (position >= buffered.start(i) && position <= buffered.end(i)) {
              return true;
            }
          }
        }
      } catch (error) {
        // this is to catch
        // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
        // This SourceBuffer has been removed from the parent media source
      }
      return false;
    }
  }, {
    key: "bufferInfo",
    value: function bufferInfo(media, pos, maxHoleDuration) {
      try {
        if (media) {
          var vbuffered = media.buffered,
              buffered = [],
              i = void 0;
          for (i = 0; i < vbuffered.length; i++) {
            buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });
          }

          return this.bufferedInfo(buffered, pos, maxHoleDuration);
        }
      } catch (error) {
        // this is to catch
        // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
        // This SourceBuffer has been removed from the parent media source
      }
      return { len: 0, start: pos, end: pos, nextStart: undefined };
    }
  }, {
    key: "bufferedInfo",
    value: function bufferedInfo(buffered, pos, maxHoleDuration) {
      var buffered2 = [],

      // bufferStart and bufferEnd are buffer boundaries around current video position
      bufferLen = void 0,
          bufferStart = void 0,
          bufferEnd = void 0,
          bufferStartNext = void 0,
          i = void 0;
      // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
      buffered.sort(function (a, b) {
        var diff = a.start - b.start;
        if (diff) {
          return diff;
        } else {
          return b.end - a.end;
        }
      });
      // there might be some small holes between buffer time range
      // consider that holes smaller than maxHoleDuration are irrelevant and build another
      // buffer time range representations that discards those holes
      for (i = 0; i < buffered.length; i++) {
        var buf2len = buffered2.length;
        if (buf2len) {
          var buf2end = buffered2[buf2len - 1].end;
          // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
          if (buffered[i].start - buf2end < maxHoleDuration) {
            // merge overlapping time ranges
            // update lastRange.end only if smaller than item.end
            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
            if (buffered[i].end > buf2end) {
              buffered2[buf2len - 1].end = buffered[i].end;
            }
          } else {
            // big hole
            buffered2.push(buffered[i]);
          }
        } else {
          // first value
          buffered2.push(buffered[i]);
        }
      }
      for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {
        var start = buffered2[i].start,
            end = buffered2[i].end;
        // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
        if (pos + maxHoleDuration >= start && pos < end) {
          // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
          bufferStart = start;
          bufferEnd = end;
          bufferLen = bufferEnd - pos;
        } else if (pos + maxHoleDuration < start) {
          bufferStartNext = start;
          break;
        }
      }
      return { len: bufferLen, start: bufferStart, end: bufferEnd, nextStart: bufferStartNext };
    }
  }]);

  return BufferHelper;
}();

/***/ }),

/***/ "./src/hls.js/utils/cea-608-parser.js":
/*!********************************************!*\
  !*** ./src/hls.js/utils/cea-608-parser.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *
 * This code was ported from the dash.js project at:
 *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
 *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
 *
 * The original copyright appears below:
 *
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2015-2016, DASH Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  1. Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  2. Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
     *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
     */

var specialCea608CharsCodes = {
  0x2a: 0xe1, // lowercase a, acute accent
  0x5c: 0xe9, // lowercase e, acute accent
  0x5e: 0xed, // lowercase i, acute accent
  0x5f: 0xf3, // lowercase o, acute accent
  0x60: 0xfa, // lowercase u, acute accent
  0x7b: 0xe7, // lowercase c with cedilla
  0x7c: 0xf7, // division symbol
  0x7d: 0xd1, // uppercase N tilde
  0x7e: 0xf1, // lowercase n tilde
  0x7f: 0x2588, // Full block
  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
  // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
  0x80: 0xae, // Registered symbol (R)
  0x81: 0xb0, // degree sign
  0x82: 0xbd, // 1/2 symbol
  0x83: 0xbf, // Inverted (open) question mark
  0x84: 0x2122, // Trademark symbol (TM)
  0x85: 0xa2, // Cents symbol
  0x86: 0xa3, // Pounds sterling
  0x87: 0x266a, // Music 8'th note
  0x88: 0xe0, // lowercase a, grave accent
  0x89: 0x20, // transparent space (regular)
  0x8a: 0xe8, // lowercase e, grave accent
  0x8b: 0xe2, // lowercase a, circumflex accent
  0x8c: 0xea, // lowercase e, circumflex accent
  0x8d: 0xee, // lowercase i, circumflex accent
  0x8e: 0xf4, // lowercase o, circumflex accent
  0x8f: 0xfb, // lowercase u, circumflex accent
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
  0x90: 0xc1, // capital letter A with acute
  0x91: 0xc9, // capital letter E with acute
  0x92: 0xd3, // capital letter O with acute
  0x93: 0xda, // capital letter U with acute
  0x94: 0xdc, // capital letter U with diaresis
  0x95: 0xfc, // lowercase letter U with diaeresis
  0x96: 0x2018, // opening single quote
  0x97: 0xa1, // inverted exclamation mark
  0x98: 0x2a, // asterisk
  0x99: 0x2019, // closing single quote
  0x9a: 0x2501, // box drawings heavy horizontal
  0x9b: 0xa9, // copyright sign
  0x9c: 0x2120, // Service mark
  0x9d: 0x2022, // (round) bullet
  0x9e: 0x201c, // Left double quotation mark
  0x9f: 0x201d, // Right double quotation mark
  0xa0: 0xc0, // uppercase A, grave accent
  0xa1: 0xc2, // uppercase A, circumflex
  0xa2: 0xc7, // uppercase C with cedilla
  0xa3: 0xc8, // uppercase E, grave accent
  0xa4: 0xca, // uppercase E, circumflex
  0xa5: 0xcb, // capital letter E with diaresis
  0xa6: 0xeb, // lowercase letter e with diaresis
  0xa7: 0xce, // uppercase I, circumflex
  0xa8: 0xcf, // uppercase I, with diaresis
  0xa9: 0xef, // lowercase i, with diaresis
  0xaa: 0xd4, // uppercase O, circumflex
  0xab: 0xd9, // uppercase U, grave accent
  0xac: 0xf9, // lowercase u, grave accent
  0xad: 0xdb, // uppercase U, circumflex
  0xae: 0xab, // left-pointing double angle quotation mark
  0xaf: 0xbb, // right-pointing double angle quotation mark
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
  0xb0: 0xc3, // Uppercase A, tilde
  0xb1: 0xe3, // Lowercase a, tilde
  0xb2: 0xcd, // Uppercase I, acute accent
  0xb3: 0xcc, // Uppercase I, grave accent
  0xb4: 0xec, // Lowercase i, grave accent
  0xb5: 0xd2, // Uppercase O, grave accent
  0xb6: 0xf2, // Lowercase o, grave accent
  0xb7: 0xd5, // Uppercase O, tilde
  0xb8: 0xf5, // Lowercase o, tilde
  0xb9: 0x7b, // Open curly brace
  0xba: 0x7d, // Closing curly brace
  0xbb: 0x5c, // Backslash
  0xbc: 0x5e, // Caret
  0xbd: 0x5f, // Underscore
  0xbe: 0x7c, // Pipe (vertical line)
  0xbf: 0x223c, // Tilde operator
  0xc0: 0xc4, // Uppercase A, umlaut
  0xc1: 0xe4, // Lowercase A, umlaut
  0xc2: 0xd6, // Uppercase O, umlaut
  0xc3: 0xf6, // Lowercase o, umlaut
  0xc4: 0xdf, // Esszett (sharp S)
  0xc5: 0xa5, // Yen symbol
  0xc6: 0xa4, // Generic currency sign
  0xc7: 0x2503, // Box drawings heavy vertical
  0xc8: 0xc5, // Uppercase A, ring
  0xc9: 0xe5, // Lowercase A, ring
  0xca: 0xd8, // Uppercase O, stroke
  0xcb: 0xf8, // Lowercase o, strok
  0xcc: 0x250f, // Box drawings heavy down and right
  0xcd: 0x2513, // Box drawings heavy down and left
  0xce: 0x2517, // Box drawings heavy up and right
  0xcf: 0x251b // Box drawings heavy up and left
};

/**
 * Utils
 */
var getCharForByte = function getCharForByte(byte) {
  var charCode = byte;
  if (specialCea608CharsCodes.hasOwnProperty(byte)) {
    charCode = specialCea608CharsCodes[byte];
  }

  return String.fromCharCode(charCode);
};

var NR_ROWS = 15,
    NR_COLS = 100;
// Tables to look up row from PAC data
var rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };
var rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };
var rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };
var rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };

var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];

/**
 * Simple logger class to be able to write with time-stamps and filter on level.
 */
var logger = {
  verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },
  time: null,
  verboseLevel: 0, // Only write errors
  setTime: function setTime(newTime) {
    this.time = newTime;
  },
  log: function log(severity, msg) {
    var minLevel = this.verboseFilter[severity];
    if (this.verboseLevel >= minLevel) {
      // console.log(this.time + ' [' + severity + '] ' + msg);
    }
  }
};

var numArrayToHexArray = function numArrayToHexArray(numArray) {
  var hexArray = [];
  for (var j = 0; j < numArray.length; j++) {
    hexArray.push(numArray[j].toString(16));
  }

  return hexArray;
};

var PenState = function () {
  function PenState(foreground, underline, italics, background, flash) {
    _classCallCheck(this, PenState);

    this.foreground = foreground || 'white';
    this.underline = underline || false;
    this.italics = italics || false;
    this.background = background || 'black';
    this.flash = flash || false;
  }

  _createClass(PenState, [{
    key: 'reset',
    value: function reset() {
      this.foreground = 'white';
      this.underline = false;
      this.italics = false;
      this.background = 'black';
      this.flash = false;
    }
  }, {
    key: 'setStyles',
    value: function setStyles(styles) {
      var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];
      for (var i = 0; i < attribs.length; i++) {
        var style = attribs[i];
        if (styles.hasOwnProperty(style)) {
          this[style] = styles[style];
        }
      }
    }
  }, {
    key: 'isDefault',
    value: function isDefault() {
      return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;
    }
  }, {
    key: 'equals',
    value: function equals(other) {
      return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
    }
  }, {
    key: 'copy',
    value: function copy(newPenState) {
      this.foreground = newPenState.foreground;
      this.underline = newPenState.underline;
      this.italics = newPenState.italics;
      this.background = newPenState.background;
      this.flash = newPenState.flash;
    }
  }, {
    key: 'toString',
    value: function toString() {
      return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;
    }
  }]);

  return PenState;
}();

/**
 * Unicode character with styling and background.
 * @constructor
 */


var StyledUnicodeChar = function () {
  function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
    _classCallCheck(this, StyledUnicodeChar);

    this.uchar = uchar || ' '; // unicode character
    this.penState = new PenState(foreground, underline, italics, background, flash);
  }

  _createClass(StyledUnicodeChar, [{
    key: 'reset',
    value: function reset() {
      this.uchar = ' ';
      this.penState.reset();
    }
  }, {
    key: 'setChar',
    value: function setChar(uchar, newPenState) {
      this.uchar = uchar;
      this.penState.copy(newPenState);
    }
  }, {
    key: 'setPenState',
    value: function setPenState(newPenState) {
      this.penState.copy(newPenState);
    }
  }, {
    key: 'equals',
    value: function equals(other) {
      return this.uchar === other.uchar && this.penState.equals(other.penState);
    }
  }, {
    key: 'copy',
    value: function copy(newChar) {
      this.uchar = newChar.uchar;
      this.penState.copy(newChar.penState);
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      return this.uchar === ' ' && this.penState.isDefault();
    }
  }]);

  return StyledUnicodeChar;
}();

/**
 * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
 * @constructor
 */


var Row = function () {
  function Row() {
    _classCallCheck(this, Row);

    this.chars = [];
    for (var i = 0; i < NR_COLS; i++) {
      this.chars.push(new StyledUnicodeChar());
    }

    this.pos = 0;
    this.currPenState = new PenState();
  }

  _createClass(Row, [{
    key: 'equals',
    value: function equals(other) {
      var equal = true;
      for (var i = 0; i < NR_COLS; i++) {
        if (!this.chars[i].equals(other.chars[i])) {
          equal = false;
          break;
        }
      }
      return equal;
    }
  }, {
    key: 'copy',
    value: function copy(other) {
      for (var i = 0; i < NR_COLS; i++) {
        this.chars[i].copy(other.chars[i]);
      }
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      var empty = true;
      for (var i = 0; i < NR_COLS; i++) {
        if (!this.chars[i].isEmpty()) {
          empty = false;
          break;
        }
      }
      return empty;
    }

    /**
       *  Set the cursor to a valid column.
       */

  }, {
    key: 'setCursor',
    value: function setCursor(absPos) {
      if (this.pos !== absPos) {
        this.pos = absPos;
      }

      if (this.pos < 0) {
        logger.log('ERROR', 'Negative cursor position ' + this.pos);
        this.pos = 0;
      } else if (this.pos > NR_COLS) {
        logger.log('ERROR', 'Too large cursor position ' + this.pos);
        this.pos = NR_COLS;
      }
    }

    /**
       * Move the cursor relative to current position.
       */

  }, {
    key: 'moveCursor',
    value: function moveCursor(relPos) {
      var newPos = this.pos + relPos;
      if (relPos > 1) {
        for (var i = this.pos + 1; i < newPos + 1; i++) {
          this.chars[i].setPenState(this.currPenState);
        }
      }
      this.setCursor(newPos);
    }

    /**
       * Backspace, move one step back and clear character.
       */

  }, {
    key: 'backSpace',
    value: function backSpace() {
      this.moveCursor(-1);
      this.chars[this.pos].setChar(' ', this.currPenState);
    }
  }, {
    key: 'insertChar',
    value: function insertChar(byte) {
      if (byte >= 0x90) {
        // Extended char
        this.backSpace();
      }
      var char = getCharForByte(byte);
      if (this.pos >= NR_COLS) {
        logger.log('ERROR', 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');
        return;
      }
      this.chars[this.pos].setChar(char, this.currPenState);
      this.moveCursor(1);
    }
  }, {
    key: 'clearFromPos',
    value: function clearFromPos(startPos) {
      var i = void 0;
      for (i = startPos; i < NR_COLS; i++) {
        this.chars[i].reset();
      }
    }
  }, {
    key: 'clear',
    value: function clear() {
      this.clearFromPos(0);
      this.pos = 0;
      this.currPenState.reset();
    }
  }, {
    key: 'clearToEndOfRow',
    value: function clearToEndOfRow() {
      this.clearFromPos(this.pos);
    }
  }, {
    key: 'getTextString',
    value: function getTextString() {
      var chars = [];
      var empty = true;
      for (var i = 0; i < NR_COLS; i++) {
        var char = this.chars[i].uchar;
        if (char !== ' ') {
          empty = false;
        }

        chars.push(char);
      }
      if (empty) {
        return '';
      } else {
        return chars.join('');
      }
    }
  }, {
    key: 'setPenStyles',
    value: function setPenStyles(styles) {
      this.currPenState.setStyles(styles);
      var currChar = this.chars[this.pos];
      currChar.setPenState(this.currPenState);
    }
  }]);

  return Row;
}();

/**
 * Keep a CEA-608 screen of 32x15 styled characters
 * @constructor
*/


var CaptionScreen = function () {
  function CaptionScreen() {
    _classCallCheck(this, CaptionScreen);

    this.rows = [];
    for (var i = 0; i < NR_ROWS; i++) {
      this.rows.push(new Row());
    } // Note that we use zero-based numbering (0-14)

    this.currRow = NR_ROWS - 1;
    this.nrRollUpRows = null;
    this.reset();
  }

  _createClass(CaptionScreen, [{
    key: 'reset',
    value: function reset() {
      for (var i = 0; i < NR_ROWS; i++) {
        this.rows[i].clear();
      }

      this.currRow = NR_ROWS - 1;
    }
  }, {
    key: 'equals',
    value: function equals(other) {
      var equal = true;
      for (var i = 0; i < NR_ROWS; i++) {
        if (!this.rows[i].equals(other.rows[i])) {
          equal = false;
          break;
        }
      }
      return equal;
    }
  }, {
    key: 'copy',
    value: function copy(other) {
      for (var i = 0; i < NR_ROWS; i++) {
        this.rows[i].copy(other.rows[i]);
      }
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      var empty = true;
      for (var i = 0; i < NR_ROWS; i++) {
        if (!this.rows[i].isEmpty()) {
          empty = false;
          break;
        }
      }
      return empty;
    }
  }, {
    key: 'backSpace',
    value: function backSpace() {
      var row = this.rows[this.currRow];
      row.backSpace();
    }
  }, {
    key: 'clearToEndOfRow',
    value: function clearToEndOfRow() {
      var row = this.rows[this.currRow];
      row.clearToEndOfRow();
    }

    /**
       * Insert a character (without styling) in the current row.
       */

  }, {
    key: 'insertChar',
    value: function insertChar(char) {
      var row = this.rows[this.currRow];
      row.insertChar(char);
    }
  }, {
    key: 'setPen',
    value: function setPen(styles) {
      var row = this.rows[this.currRow];
      row.setPenStyles(styles);
    }
  }, {
    key: 'moveCursor',
    value: function moveCursor(relPos) {
      var row = this.rows[this.currRow];
      row.moveCursor(relPos);
    }
  }, {
    key: 'setCursor',
    value: function setCursor(absPos) {
      logger.log('INFO', 'setCursor: ' + absPos);
      var row = this.rows[this.currRow];
      row.setCursor(absPos);
    }
  }, {
    key: 'setPAC',
    value: function setPAC(pacData) {
      logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));
      var newRow = pacData.row - 1;
      if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
        newRow = this.nrRollUpRows - 1;
      }

      // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows
      if (this.nrRollUpRows && this.currRow !== newRow) {
        // clear all rows first
        for (var i = 0; i < NR_ROWS; i++) {
          this.rows[i].clear();
        }

        // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location
        // topRowIndex - the start of rows to copy (inclusive index)
        var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
        // We only copy if the last position was already shown.
        // We use the cueStartTime value to check this.
        var lastOutputScreen = this.lastOutputScreen;
        if (lastOutputScreen) {
          var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
          if (prevLineTime && prevLineTime < logger.time) {
            for (var _i = 0; _i < this.nrRollUpRows; _i++) {
              this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);
            }
          }
        }
      }

      this.currRow = newRow;
      var row = this.rows[this.currRow];
      if (pacData.indent !== null) {
        var indent = pacData.indent;
        var prevPos = Math.max(indent - 1, 0);
        row.setCursor(pacData.indent);
        pacData.color = row.chars[prevPos].penState.foreground;
      }
      var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };
      this.setPen(styles);
    }

    /**
       * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
       */

  }, {
    key: 'setBkgData',
    value: function setBkgData(bkgData) {
      logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));
      this.backSpace();
      this.setPen(bkgData);
      this.insertChar(0x20); // Space
    }
  }, {
    key: 'setRollUpRows',
    value: function setRollUpRows(nrRows) {
      this.nrRollUpRows = nrRows;
    }
  }, {
    key: 'rollUp',
    value: function rollUp() {
      if (this.nrRollUpRows === null) {
        logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');
        return; // Not properly setup
      }
      logger.log('TEXT', this.getDisplayText());
      var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
      var topRow = this.rows.splice(topRowIndex, 1)[0];
      topRow.clear();
      this.rows.splice(this.currRow, 0, topRow);
      logger.log('INFO', 'Rolling up');
      // logger.log('TEXT', this.get_display_text())
    }

    /**
      * Get all non-empty rows with as unicode text.
      */

  }, {
    key: 'getDisplayText',
    value: function getDisplayText(asOneRow) {
      asOneRow = asOneRow || false;
      var displayText = [];
      var text = '';
      var rowNr = -1;
      for (var i = 0; i < NR_ROWS; i++) {
        var rowText = this.rows[i].getTextString();
        if (rowText) {
          rowNr = i + 1;
          if (asOneRow) {
            displayText.push('Row ' + rowNr + ': \'' + rowText + '\'');
          } else {
            displayText.push(rowText.trim());
          }
        }
      }
      if (displayText.length > 0) {
        if (asOneRow) {
          text = '[' + displayText.join(' | ') + ']';
        } else {
          text = displayText.join('\n');
        }
      }
      return text;
    }
  }, {
    key: 'getTextAndFormat',
    value: function getTextAndFormat() {
      return this.rows;
    }
  }]);

  return CaptionScreen;
}();

// var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];

var Cea608Channel = function () {
  function Cea608Channel(channelNumber, outputFilter) {
    _classCallCheck(this, Cea608Channel);

    this.chNr = channelNumber;
    this.outputFilter = outputFilter;
    this.mode = null;
    this.verbose = 0;
    this.displayedMemory = new CaptionScreen();
    this.nonDisplayedMemory = new CaptionScreen();
    this.lastOutputScreen = new CaptionScreen();
    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
    this.writeScreen = this.displayedMemory;
    this.mode = null;
    this.cueStartTime = null; // Keeps track of where a cue started.
  }

  _createClass(Cea608Channel, [{
    key: 'reset',
    value: function reset() {
      this.mode = null;
      this.displayedMemory.reset();
      this.nonDisplayedMemory.reset();
      this.lastOutputScreen.reset();
      this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
      this.writeScreen = this.displayedMemory;
      this.mode = null;
      this.cueStartTime = null;
      this.lastCueEndTime = null;
    }
  }, {
    key: 'getHandler',
    value: function getHandler() {
      return this.outputFilter;
    }
  }, {
    key: 'setHandler',
    value: function setHandler(newHandler) {
      this.outputFilter = newHandler;
    }
  }, {
    key: 'setPAC',
    value: function setPAC(pacData) {
      this.writeScreen.setPAC(pacData);
    }
  }, {
    key: 'setBkgData',
    value: function setBkgData(bkgData) {
      this.writeScreen.setBkgData(bkgData);
    }
  }, {
    key: 'setMode',
    value: function setMode(newMode) {
      if (newMode === this.mode) {
        return;
      }

      this.mode = newMode;
      logger.log('INFO', 'MODE=' + newMode);
      if (this.mode === 'MODE_POP-ON') {
        this.writeScreen = this.nonDisplayedMemory;
      } else {
        this.writeScreen = this.displayedMemory;
        this.writeScreen.reset();
      }
      if (this.mode !== 'MODE_ROLL-UP') {
        this.displayedMemory.nrRollUpRows = null;
        this.nonDisplayedMemory.nrRollUpRows = null;
      }
      this.mode = newMode;
    }
  }, {
    key: 'insertChars',
    value: function insertChars(chars) {
      for (var i = 0; i < chars.length; i++) {
        this.writeScreen.insertChar(chars[i]);
      }

      var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
      logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));
      if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
        logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
        this.outputDataUpdate();
      }
    }
  }, {
    key: 'ccRCL',
    value: function ccRCL() {
      // Resume Caption Loading (switch mode to Pop On)
      logger.log('INFO', 'RCL - Resume Caption Loading');
      this.setMode('MODE_POP-ON');
    }
  }, {
    key: 'ccBS',
    value: function ccBS() {
      // BackSpace
      logger.log('INFO', 'BS - BackSpace');
      if (this.mode === 'MODE_TEXT') {
        return;
      }

      this.writeScreen.backSpace();
      if (this.writeScreen === this.displayedMemory) {
        this.outputDataUpdate();
      }
    }
  }, {
    key: 'ccAOF',
    value: function ccAOF() {// Reserved (formerly Alarm Off)

    }
  }, {
    key: 'ccAON',
    value: function ccAON() {// Reserved (formerly Alarm On)

    }
  }, {
    key: 'ccDER',
    value: function ccDER() {
      // Delete to End of Row
      logger.log('INFO', 'DER- Delete to End of Row');
      this.writeScreen.clearToEndOfRow();
      this.outputDataUpdate();
    }
  }, {
    key: 'ccRU',
    value: function ccRU(nrRows) {
      // Roll-Up Captions-2,3,or 4 Rows
      logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');
      this.writeScreen = this.displayedMemory;
      this.setMode('MODE_ROLL-UP');
      this.writeScreen.setRollUpRows(nrRows);
    }
  }, {
    key: 'ccFON',
    value: function ccFON() {
      // Flash On
      logger.log('INFO', 'FON - Flash On');
      this.writeScreen.setPen({ flash: true });
    }
  }, {
    key: 'ccRDC',
    value: function ccRDC() {
      // Resume Direct Captioning (switch mode to PaintOn)
      logger.log('INFO', 'RDC - Resume Direct Captioning');
      this.setMode('MODE_PAINT-ON');
    }
  }, {
    key: 'ccTR',
    value: function ccTR() {
      // Text Restart in text mode (not supported, however)
      logger.log('INFO', 'TR');
      this.setMode('MODE_TEXT');
    }
  }, {
    key: 'ccRTD',
    value: function ccRTD() {
      // Resume Text Display in Text mode (not supported, however)
      logger.log('INFO', 'RTD');
      this.setMode('MODE_TEXT');
    }
  }, {
    key: 'ccEDM',
    value: function ccEDM() {
      // Erase Displayed Memory
      logger.log('INFO', 'EDM - Erase Displayed Memory');
      this.displayedMemory.reset();
      this.outputDataUpdate(true);
    }
  }, {
    key: 'ccCR',
    value: function ccCR() {
      // Carriage Return
      logger.log('CR - Carriage Return');
      this.writeScreen.rollUp();
      this.outputDataUpdate(true);
    }
  }, {
    key: 'ccENM',
    value: function ccENM() {
      // Erase Non-Displayed Memory
      logger.log('INFO', 'ENM - Erase Non-displayed Memory');
      this.nonDisplayedMemory.reset();
    }
  }, {
    key: 'ccEOC',
    value: function ccEOC() {
      // End of Caption (Flip Memories)
      logger.log('INFO', 'EOC - End Of Caption');
      if (this.mode === 'MODE_POP-ON') {
        var tmp = this.displayedMemory;
        this.displayedMemory = this.nonDisplayedMemory;
        this.nonDisplayedMemory = tmp;
        this.writeScreen = this.nonDisplayedMemory;
        logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());
      }
      this.outputDataUpdate(true);
    }
  }, {
    key: 'ccTO',
    value: function ccTO(nrCols) {
      // Tab Offset 1,2, or 3 columns
      logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');
      this.writeScreen.moveCursor(nrCols);
    }
  }, {
    key: 'ccMIDROW',
    value: function ccMIDROW(secondByte) {
      // Parse MIDROW command
      var styles = { flash: false };
      styles.underline = secondByte % 2 === 1;
      styles.italics = secondByte >= 0x2e;
      if (!styles.italics) {
        var colorIndex = Math.floor(secondByte / 2) - 0x10;
        var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
        styles.foreground = colors[colorIndex];
      } else {
        styles.foreground = 'white';
      }
      logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));
      this.writeScreen.setPen(styles);
    }
  }, {
    key: 'outputDataUpdate',
    value: function outputDataUpdate() {
      var dispatch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var t = logger.time;
      if (t === null) {
        return;
      }

      if (this.outputFilter) {
        if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
          // Start of a new cue
          this.cueStartTime = t;
        } else {
          if (!this.displayedMemory.equals(this.lastOutputScreen)) {
            if (this.outputFilter.newCue) {
              this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);
              if (dispatch === true && this.outputFilter.dispatchCue) {
                this.outputFilter.dispatchCue();
              }
            }
            this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;
          }
        }
        this.lastOutputScreen.copy(this.displayedMemory);
      }
    }
  }, {
    key: 'cueSplitAtTime',
    value: function cueSplitAtTime(t) {
      if (this.outputFilter) {
        if (!this.displayedMemory.isEmpty()) {
          if (this.outputFilter.newCue) {
            this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
          }

          this.cueStartTime = t;
        }
      }
    }
  }]);

  return Cea608Channel;
}();

var Cea608Parser = function () {
  function Cea608Parser(field, out1, out2) {
    _classCallCheck(this, Cea608Parser);

    this.field = field || 1;
    this.outputs = [out1, out2];
    this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];
    this.currChNr = -1; // Will be 1 or 2
    this.lastCmdA = null; // First byte of last command
    this.lastCmdB = null; // Second byte of last command
    this.bufferedData = [];
    this.startTime = null;
    this.lastTime = null;
    this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };
  }

  _createClass(Cea608Parser, [{
    key: 'getHandler',
    value: function getHandler(index) {
      return this.channels[index].getHandler();
    }
  }, {
    key: 'setHandler',
    value: function setHandler(index, newHandler) {
      this.channels[index].setHandler(newHandler);
    }

    /**
       * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
       */

  }, {
    key: 'addData',
    value: function addData(t, byteList) {
      var cmdFound = void 0,
          a = void 0,
          b = void 0,
          charsFound = false;

      this.lastTime = t;
      logger.setTime(t);

      for (var i = 0; i < byteList.length; i += 2) {
        a = byteList[i] & 0x7f;
        b = byteList[i + 1] & 0x7f;
        if (a === 0 && b === 0) {
          this.dataCounters.padding += 2;
          continue;
        } else {
          logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
        }
        cmdFound = this.parseCmd(a, b);
        if (!cmdFound) {
          cmdFound = this.parseMidrow(a, b);
        }

        if (!cmdFound) {
          cmdFound = this.parsePAC(a, b);
        }

        if (!cmdFound) {
          cmdFound = this.parseBackgroundAttributes(a, b);
        }

        if (!cmdFound) {
          charsFound = this.parseChars(a, b);
          if (charsFound) {
            if (this.currChNr && this.currChNr >= 0) {
              var channel = this.channels[this.currChNr - 1];
              channel.insertChars(charsFound);
            } else {
              logger.log('WARNING', 'No channel found yet. TEXT-MODE?');
            }
          }
        }
        if (cmdFound) {
          this.dataCounters.cmd += 2;
        } else if (charsFound) {
          this.dataCounters.char += 2;
        } else {
          this.dataCounters.other += 2;
          logger.log('WARNING', 'Couldn\'t parse cleaned data ' + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
        }
      }
    }

    /**
       * Parse Command.
       * @returns {Boolean} Tells if a command was found
       */

  }, {
    key: 'parseCmd',
    value: function parseCmd(a, b) {
      var chNr = null;

      var cond1 = (a === 0x14 || a === 0x1C) && b >= 0x20 && b <= 0x2F;
      var cond2 = (a === 0x17 || a === 0x1F) && b >= 0x21 && b <= 0x23;
      if (!(cond1 || cond2)) {
        return false;
      }

      if (a === this.lastCmdA && b === this.lastCmdB) {
        this.lastCmdA = null;
        this.lastCmdB = null; // Repeated commands are dropped (once)
        logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
        return true;
      }

      if (a === 0x14 || a === 0x17) {
        chNr = 1;
      } else {
        chNr = 2;
      } // (a === 0x1C || a=== 0x1f)

      var channel = this.channels[chNr - 1];

      if (a === 0x14 || a === 0x1C) {
        if (b === 0x20) {
          channel.ccRCL();
        } else if (b === 0x21) {
          channel.ccBS();
        } else if (b === 0x22) {
          channel.ccAOF();
        } else if (b === 0x23) {
          channel.ccAON();
        } else if (b === 0x24) {
          channel.ccDER();
        } else if (b === 0x25) {
          channel.ccRU(2);
        } else if (b === 0x26) {
          channel.ccRU(3);
        } else if (b === 0x27) {
          channel.ccRU(4);
        } else if (b === 0x28) {
          channel.ccFON();
        } else if (b === 0x29) {
          channel.ccRDC();
        } else if (b === 0x2A) {
          channel.ccTR();
        } else if (b === 0x2B) {
          channel.ccRTD();
        } else if (b === 0x2C) {
          channel.ccEDM();
        } else if (b === 0x2D) {
          channel.ccCR();
        } else if (b === 0x2E) {
          channel.ccENM();
        } else if (b === 0x2F) {
          channel.ccEOC();
        }
      } else {
        // a == 0x17 || a == 0x1F
        channel.ccTO(b - 0x20);
      }
      this.lastCmdA = a;
      this.lastCmdB = b;
      this.currChNr = chNr;
      return true;
    }

    /**
       * Parse midrow styling command
       * @returns {Boolean}
       */

  }, {
    key: 'parseMidrow',
    value: function parseMidrow(a, b) {
      var chNr = null;

      if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {
        if (a === 0x11) {
          chNr = 1;
        } else {
          chNr = 2;
        }

        if (chNr !== this.currChNr) {
          logger.log('ERROR', 'Mismatch channel in midrow parsing');
          return false;
        }
        var channel = this.channels[chNr - 1];
        channel.ccMIDROW(b);
        logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
        return true;
      }
      return false;
    }
    /**
       * Parse Preable Access Codes (Table 53).
       * @returns {Boolean} Tells if PAC found
       */

  }, {
    key: 'parsePAC',
    value: function parsePAC(a, b) {
      var chNr = null;
      var row = null;

      var case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1F) && b >= 0x40 && b <= 0x7F;
      var case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5F;
      if (!(case1 || case2)) {
        return false;
      }

      if (a === this.lastCmdA && b === this.lastCmdB) {
        this.lastCmdA = null;
        this.lastCmdB = null;
        return true; // Repeated commands are dropped (once)
      }

      chNr = a <= 0x17 ? 1 : 2;

      if (b >= 0x40 && b <= 0x5F) {
        row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
      } else {
        // 0x60 <= b <= 0x7F
        row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
      }
      var pacData = this.interpretPAC(row, b);
      var channel = this.channels[chNr - 1];
      channel.setPAC(pacData);
      this.lastCmdA = a;
      this.lastCmdB = b;
      this.currChNr = chNr;
      return true;
    }

    /**
       * Interpret the second byte of the pac, and return the information.
       * @returns {Object} pacData with style parameters.
       */

  }, {
    key: 'interpretPAC',
    value: function interpretPAC(row, byte) {
      var pacIndex = byte;
      var pacData = { color: null, italics: false, indent: null, underline: false, row: row };

      if (byte > 0x5F) {
        pacIndex = byte - 0x60;
      } else {
        pacIndex = byte - 0x40;
      }

      pacData.underline = (pacIndex & 1) === 1;
      if (pacIndex <= 0xd) {
        pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
      } else if (pacIndex <= 0xf) {
        pacData.italics = true;
        pacData.color = 'white';
      } else {
        pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;
      }
      return pacData; // Note that row has zero offset. The spec uses 1.
    }

    /**
       * Parse characters.
       * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
       */

  }, {
    key: 'parseChars',
    value: function parseChars(a, b) {
      var channelNr = null,
          charCodes = null,
          charCode1 = null;

      if (a >= 0x19) {
        channelNr = 2;
        charCode1 = a - 8;
      } else {
        channelNr = 1;
        charCode1 = a;
      }
      if (charCode1 >= 0x11 && charCode1 <= 0x13) {
        // Special character
        var oneCode = b;
        if (charCode1 === 0x11) {
          oneCode = b + 0x50;
        } else if (charCode1 === 0x12) {
          oneCode = b + 0x70;
        } else {
          oneCode = b + 0x90;
        }

        logger.log('INFO', 'Special char \'' + getCharForByte(oneCode) + '\' in channel ' + channelNr);
        charCodes = [oneCode];
      } else if (a >= 0x20 && a <= 0x7f) {
        charCodes = b === 0 ? [a] : [a, b];
      }
      if (charCodes) {
        var hexCodes = numArrayToHexArray(charCodes);
        logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));
        this.lastCmdA = null;
        this.lastCmdB = null;
      }
      return charCodes;
    }

    /**
      * Parse extended background attributes as well as new foreground color black.
      * @returns{Boolean} Tells if background attributes are found
      */

  }, {
    key: 'parseBackgroundAttributes',
    value: function parseBackgroundAttributes(a, b) {
      var bkgData = void 0,
          index = void 0,
          chNr = void 0,
          channel = void 0;

      var case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;
      var case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;
      if (!(case1 || case2)) {
        return false;
      }

      bkgData = {};
      if (a === 0x10 || a === 0x18) {
        index = Math.floor((b - 0x20) / 2);
        bkgData.background = backgroundColors[index];
        if (b % 2 === 1) {
          bkgData.background = bkgData.background + '_semi';
        }
      } else if (b === 0x2d) {
        bkgData.background = 'transparent';
      } else {
        bkgData.foreground = 'black';
        if (b === 0x2f) {
          bkgData.underline = true;
        }
      }
      chNr = a < 0x18 ? 1 : 2;
      channel = this.channels[chNr - 1];
      channel.setBkgData(bkgData);
      this.lastCmdA = null;
      this.lastCmdB = null;
      return true;
    }

    /**
       * Reset state of parser and its channels.
       */

  }, {
    key: 'reset',
    value: function reset() {
      for (var i = 0; i < this.channels.length; i++) {
        if (this.channels[i]) {
          this.channels[i].reset();
        }
      }
      this.lastCmdA = null;
      this.lastCmdB = null;
    }

    /**
       * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
       */

  }, {
    key: 'cueSplitAtTime',
    value: function cueSplitAtTime(t) {
      for (var i = 0; i < this.channels.length; i++) {
        if (this.channels[i]) {
          this.channels[i].cueSplitAtTime(t);
        }
      }
    }
  }]);

  return Cea608Parser;
}();

exports.default = Cea608Parser;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/codecs.js":
/*!************************************!*\
  !*** ./src/hls.js/utils/codecs.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// from http://mp4ra.org/codecs.html
var sampleEntryCodesISO = {
  audio: {
    'a3ds': true,
    'ac-3': true,
    'ac-4': true,
    'alac': true,
    'alaw': true,
    'dra1': true,
    'dts+': true,
    'dts-': true,
    'dtsc': true,
    'dtse': true,
    'dtsh': true,
    'ec-3': true,
    'enca': true,
    'g719': true,
    'g726': true,
    'm4ae': true,
    'mha1': true,
    'mha2': true,
    'mhm1': true,
    'mhm2': true,
    'mlpa': true,
    'mp4a': true,
    'raw ': true,
    'Opus': true,
    'samr': true,
    'sawb': true,
    'sawp': true,
    'sevc': true,
    'sqcp': true,
    'ssmv': true,
    'twos': true,
    'ulaw': true
  },
  video: {
    'avc1': true,
    'avc2': true,
    'avc3': true,
    'avc4': true,
    'avcp': true,
    'drac': true,
    'dvav': true,
    'dvhe': true,
    'encv': true,
    'hev1': true,
    'hvc1': true,
    'mjp2': true,
    'mp4v': true,
    'mvc1': true,
    'mvc2': true,
    'mvc3': true,
    'mvc4': true,
    'resv': true,
    'rv60': true,
    's263': true,
    'svc1': true,
    'svc2': true,
    'vc-1': true,
    'vp08': true,
    'vp09': true
  }
};

function isCodecType(codec, type) {
  var typeCodes = sampleEntryCodesISO[type];
  return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;
}

function isCodecSupportedInMp4(codec, type) {
  return window.MediaSource.isTypeSupported((type || 'video') + '/mp4;codecs="' + codec + '"');
}

exports.isCodecType = isCodecType;
exports.isCodecSupportedInMp4 = isCodecSupportedInMp4;

/***/ }),

/***/ "./src/hls.js/utils/cues.js":
/*!**********************************!*\
  !*** ./src/hls.js/utils/cues.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.newCue = newCue;

var _vttparser = __webpack_require__(/*! ./vttparser */ "./src/hls.js/utils/vttparser.js");

function newCue(track, startTime, endTime, captionScreen) {
  var row = void 0;
  var cue = void 0;
  var indenting = void 0;
  var indent = void 0;
  var text = void 0;
  var VTTCue = window.VTTCue || window.TextTrackCue;

  for (var r = 0; r < captionScreen.rows.length; r++) {
    row = captionScreen.rows[r];
    indenting = true;
    indent = 0;
    text = '';

    if (!row.isEmpty()) {
      for (var c = 0; c < row.chars.length; c++) {
        if (row.chars[c].uchar.match(/\s/) && indenting) {
          indent++;
        } else {
          text += row.chars[c].uchar;
          indenting = false;
        }
      }
      // To be used for cleaning-up orphaned roll-up captions
      row.cueStartTime = startTime;

      // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
      if (startTime === endTime) {
        endTime += 0.0001;
      }

      cue = new VTTCue(startTime, endTime, (0, _vttparser.fixLineBreaks)(text.trim()));

      if (indent >= 16) {
        indent--;
      } else {
        indent++;
      }

      // VTTCue.line get's flakey when using controls, so let's now include line 13&14
      // also, drop line 1 since it's to close to the top
      if (navigator.userAgent.match(/Firefox\//)) {
        cue.line = r + 1;
      } else {
        cue.line = r > 7 ? r - 2 : r + 1;
      }

      cue.align = 'left';
      // Clamp the position between 0 and 100 - if out of these bounds, Firefox throws an exception and captions break
      cue.position = Math.max(0, Math.min(100, 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0)));
      track.addCue(cue);
    }
  }
}

/***/ }),

/***/ "./src/hls.js/utils/discontinuities.js":
/*!*********************************************!*\
  !*** ./src/hls.js/utils/discontinuities.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findFirstFragWithCC = findFirstFragWithCC;
exports.findFragWithCC = findFragWithCC;
exports.shouldAlignOnDiscontinuities = shouldAlignOnDiscontinuities;
exports.findDiscontinuousReferenceFrag = findDiscontinuousReferenceFrag;
exports.adjustPts = adjustPts;
exports.alignStream = alignStream;
exports.alignDiscontinuities = alignDiscontinuities;
exports.alignPDT = alignPDT;

var _binarySearch = __webpack_require__(/*! ./binary-search */ "./src/hls.js/utils/binary-search.js");

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function findFirstFragWithCC(fragments, cc) {
  var firstFrag = null;

  for (var i = 0; i < fragments.length; i += 1) {
    var currentFrag = fragments[i];
    if (currentFrag && currentFrag.cc === cc) {
      firstFrag = currentFrag;
      break;
    }
  }

  return firstFrag;
}

function findFragWithCC(fragments, CC) {
  return _binarySearch2.default.search(fragments, function (candidate) {
    if (candidate.cc < CC) {
      return 1;
    } else if (candidate.cc > CC) {
      return -1;
    } else {
      return 0;
    }
  });
}

function shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {
  var shouldAlign = false;
  if (lastLevel && lastLevel.details && details) {
    if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {
      shouldAlign = true;
    }
  }
  return shouldAlign;
}

// Find the first frag in the previous level which matches the CC of the first frag of the new level
function findDiscontinuousReferenceFrag(prevDetails, curDetails) {
  var prevFrags = prevDetails.fragments;
  var curFrags = curDetails.fragments;

  if (!curFrags.length || !prevFrags.length) {
    _logger.logger.log('No fragments to align');
    return;
  }

  var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);

  if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {
    _logger.logger.log('No frag in previous level to align on');
    return;
  }

  return prevStartFrag;
}

function adjustPts(sliding, details) {
  details.fragments.forEach(function (frag) {
    if (frag) {
      var start = frag.start + sliding;
      frag.start = frag.startPTS = start;
      frag.endPTS = start + frag.duration;
    }
  });
  details.PTSKnown = true;
}

/**
 * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a
 * contiguous stream with the last fragments.
 * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to
 * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time
 * and an extra download.
 * @param lastFrag
 * @param lastLevel
 * @param details
 */
function alignStream(lastFrag, lastLevel, details) {
  alignDiscontinuities(lastFrag, details, lastLevel);
  if (!details.PTSKnown && lastLevel) {
    // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.
    // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same
    // discontinuity sequence.
    alignPDT(details, lastLevel.details);
  }
}

/**
 * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same
 * discontinuity sequence.
 * @param lastLevel - The details of the last loaded level
 * @param details - The details of the new level
 */
function alignDiscontinuities(lastFrag, details, lastLevel) {
  if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {
    var referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);
    if (referenceFrag) {
      _logger.logger.log('Adjusting PTS using last level due to CC increase within current level');
      adjustPts(referenceFrag.start, details);
    }
  }
}

/**
 * Computes the PTS of a new level's fragments using the difference in Program Date Time from the last level.
 * @param details - The details of the new level
 * @param lastDetails - The details of the last loaded level
 */
function alignPDT(details, lastDetails) {
  if (lastDetails && lastDetails.fragments.length) {
    if (!details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {
      return;
    }
    // if last level sliding is 1000 and its first frag PROGRAM-DATE-TIME is 2017-08-20 1:10:00 AM
    // and if new details first frag PROGRAM DATE-TIME is 2017-08-20 1:10:08 AM
    // then we can deduce that playlist B sliding is 1000+8 = 1008s
    var lastPDT = lastDetails.fragments[0].programDateTime;
    var newPDT = details.fragments[0].programDateTime;
    // date diff is in ms. frag.start is in seconds
    var sliding = (newPDT - lastPDT) / 1000 + lastDetails.fragments[0].start;
    if (Number.isFinite(sliding)) {
      _logger.logger.log('adjusting PTS using programDateTime delta, sliding:' + sliding.toFixed(3));
      adjustPts(sliding, details);
    }
  }
}

/***/ }),

/***/ "./src/hls.js/utils/ewma-bandwidth-estimator.js":
/*!******************************************************!*\
  !*** ./src/hls.js/utils/ewma-bandwidth-estimator.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EWMA Bandwidth Estimator
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  - heavily inspired from shaka-player
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Tracks bandwidth samples and estimates available bandwidth.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Based on the minimum of two exponentially-weighted moving averages with
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * different half-lives.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _ewma = __webpack_require__(/*! ../utils/ewma */ "./src/hls.js/utils/ewma.js");

var _ewma2 = _interopRequireDefault(_ewma);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EwmaBandWidthEstimator = function () {
  function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {
    _classCallCheck(this, EwmaBandWidthEstimator);

    this.hls = hls;
    this.defaultEstimate_ = defaultEstimate;
    this.minWeight_ = 0.001;
    this.minDelayMs_ = 50;
    this.slow_ = new _ewma2.default(slow);
    this.fast_ = new _ewma2.default(fast);
  }

  _createClass(EwmaBandWidthEstimator, [{
    key: 'sample',
    value: function sample(durationMs, numBytes) {
      durationMs = Math.max(durationMs, this.minDelayMs_);
      var bandwidth = 8000 * numBytes / durationMs,

      // console.log('instant bw:'+ Math.round(bandwidth));
      // we weight sample using loading duration....
      weight = durationMs / 1000;
      this.fast_.sample(weight, bandwidth);
      this.slow_.sample(weight, bandwidth);
    }
  }, {
    key: 'canEstimate',
    value: function canEstimate() {
      var fast = this.fast_;
      return fast && fast.getTotalWeight() >= this.minWeight_;
    }
  }, {
    key: 'getEstimate',
    value: function getEstimate() {
      if (this.canEstimate()) {
        // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
        // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
        // Take the minimum of these two estimates.  This should have the effect of
        // adapting down quickly, but up more slowly.
        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
      } else {
        return this.defaultEstimate_;
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }]);

  return EwmaBandWidthEstimator;
}();

exports.default = EwmaBandWidthEstimator;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/ewma.js":
/*!**********************************!*\
  !*** ./src/hls.js/utils/ewma.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * compute an Exponential Weighted moving average
 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
 *  - heavily inspired from shaka-player
 */

var EWMA = function () {
  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  function EWMA(halfLife) {
    _classCallCheck(this, EWMA);

    // Larger values of alpha expire historical data more slowly.
    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
    this.estimate_ = 0;
    this.totalWeight_ = 0;
  }

  _createClass(EWMA, [{
    key: "sample",
    value: function sample(weight, value) {
      var adjAlpha = Math.pow(this.alpha_, weight);
      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
      this.totalWeight_ += weight;
    }
  }, {
    key: "getTotalWeight",
    value: function getTotalWeight() {
      return this.totalWeight_;
    }
  }, {
    key: "getEstimate",
    value: function getEstimate() {
      if (this.alpha_) {
        var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
        return this.estimate_ / zeroFactor;
      } else {
        return this.estimate_;
      }
    }
  }]);

  return EWMA;
}();

exports.default = EWMA;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/utils/get-self-scope.js":
/*!********************************************!*\
  !*** ./src/hls.js/utils/get-self-scope.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSelfScope = getSelfScope;
function getSelfScope() {
  // see https://stackoverflow.com/a/11237259/589493
  if (typeof window === 'undefined') {
    /* eslint-disable-next-line no-undef */
    return self;
  } else {
    return window;
  }
}

/***/ }),

/***/ "./src/hls.js/utils/logger.js":
/*!************************************!*\
  !*** ./src/hls.js/utils/logger.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logger = exports.enableLogs = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _getSelfScope = __webpack_require__(/*! ./get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

function noop() {}

var fakeLogger = {
  trace: noop,
  debug: noop,
  log: noop,
  warn: noop,
  info: noop,
  error: noop
};

var exportedLogger = fakeLogger;

// let lastCallTime;
// function formatMsgWithTimeInfo(type, msg) {
//   const now = Date.now();
//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
//   lastCallTime = now;
//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
//   return msg;
// }

function formatMsg(type, msg) {
  msg = '[' + type + '] > ' + msg;
  return msg;
}

var global = (0, _getSelfScope.getSelfScope)();

function consolePrintFn(type) {
  var func = global.console[type];
  if (func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args[0]) {
        args[0] = formatMsg(type, args[0]);
      }

      func.apply(global.console, args);
    };
  }
  return noop;
}

function exportLoggerFunctions(debugConfig) {
  for (var _len2 = arguments.length, functions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    functions[_key2 - 1] = arguments[_key2];
  }

  functions.forEach(function (type) {
    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
  });
}

var enableLogs = exports.enableLogs = function enableLogs(debugConfig) {
  if (debugConfig === true || (typeof debugConfig === 'undefined' ? 'undefined' : _typeof(debugConfig)) === 'object') {
    exportLoggerFunctions(debugConfig,
    // Remove out from list here to hard-disable a log-level
    // 'trace',
    'debug', 'log', 'info', 'warn', 'error');
    // Some browsers don't allow to use bind on console object anyway
    // fallback to default if needed
    try {
      exportedLogger.log();
    } catch (e) {
      exportedLogger = fakeLogger;
    }
  } else {
    exportedLogger = fakeLogger;
  }
};

var logger = exports.logger = exportedLogger;

/***/ }),

/***/ "./src/hls.js/utils/mediakeys-helper.js":
/*!**********************************************!*\
  !*** ./src/hls.js/utils/mediakeys-helper.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var requestMediaKeySystemAccess = function () {
  if (typeof window !== 'undefined' && window.navigator && window.navigator.requestMediaKeySystemAccess) {
    return window.navigator.requestMediaKeySystemAccess.bind(window.navigator);
  } else {
    return null;
  }
}();

exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess;

/***/ }),

/***/ "./src/hls.js/utils/mediasource-helper.js":
/*!************************************************!*\
  !*** ./src/hls.js/utils/mediasource-helper.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMediaSource = getMediaSource;
/**
 * MediaSource helper
 */

function getMediaSource() {
  if (typeof window !== 'undefined') {
    return window.MediaSource || window.WebKitMediaSource;
  }
}

/***/ }),

/***/ "./src/hls.js/utils/output-filter.js":
/*!*******************************************!*\
  !*** ./src/hls.js/utils/output-filter.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var OutputFilter = function () {
  function OutputFilter(timelineController, trackName) {
    _classCallCheck(this, OutputFilter);

    this.timelineController = timelineController;
    this.trackName = trackName;
    this.startTime = null;
    this.endTime = null;
    this.screen = null;
  }

  _createClass(OutputFilter, [{
    key: "dispatchCue",
    value: function dispatchCue() {
      if (this.startTime === null) {
        return;
      }

      this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen);
      this.startTime = null;
    }
  }, {
    key: "newCue",
    value: function newCue(startTime, endTime, screen) {
      if (this.startTime === null || this.startTime > startTime) {
        this.startTime = startTime;
      }

      this.endTime = endTime;
      this.screen = screen;
      this.timelineController.createCaptionsTrack(this.trackName);
    }
  }]);

  return OutputFilter;
}();

exports.default = OutputFilter;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/utils/texttrack-utils.js":
/*!*********************************************!*\
  !*** ./src/hls.js/utils/texttrack-utils.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sendAddTrackEvent = sendAddTrackEvent;
exports.clearCurrentCues = clearCurrentCues;
function sendAddTrackEvent(track, videoEl) {
  var event = null;
  try {
    event = new window.Event('addtrack');
  } catch (err) {
    // for IE11
    event = document.createEvent('Event');
    event.initEvent('addtrack', false, false);
  }
  event.track = track;
  videoEl.dispatchEvent(event);
}

function clearCurrentCues(track) {
  if (track && track.cues) {
    while (track.cues.length > 0) {
      track.removeCue(track.cues[0]);
    }
  }
}

/***/ }),

/***/ "./src/hls.js/utils/time-ranges.js":
/*!*****************************************!*\
  !*** ./src/hls.js/utils/time-ranges.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 *  TimeRanges to string helper
 */

var TimeRanges = {
  toString: function toString(r) {
    var log = '',
        len = r.length;
    for (var i = 0; i < len; i++) {
      log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';
    }

    return log;
  }
};

exports.default = TimeRanges;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/vttcue.js":
/*!************************************!*\
  !*** ./src/hls.js/utils/vttcue.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

exports.default = function () {
  if (typeof window !== 'undefined' && window.VTTCue) {
    return window.VTTCue;
  }

  var autoKeyword = 'auto';
  var directionSetting = {
    '': true,
    lr: true,
    rl: true
  };
  var alignSetting = {
    start: true,
    middle: true,
    end: true,
    left: true,
    right: true
  };

  function findDirectionSetting(value) {
    if (typeof value !== 'string') {
      return false;
    }

    var dir = directionSetting[value.toLowerCase()];
    return dir ? value.toLowerCase() : false;
  }

  function findAlignSetting(value) {
    if (typeof value !== 'string') {
      return false;
    }

    var align = alignSetting[value.toLowerCase()];
    return align ? value.toLowerCase() : false;
  }

  function extend(obj) {
    var i = 1;
    for (; i < arguments.length; i++) {
      var cobj = arguments[i];
      for (var p in cobj) {
        obj[p] = cobj[p];
      }
    }

    return obj;
  }

  function VTTCue(startTime, endTime, text) {
    var cue = this;
    var isIE8 = function () {
      if (typeof navigator === 'undefined') {
        return;
      }

      return (/MSIE\s8\.0/.test(navigator.userAgent)
      );
    }();
    var baseObj = {};

    if (isIE8) {
      cue = document.createElement('custom');
    } else {
      baseObj.enumerable = true;
    }

    /**
     * Shim implementation specific properties. These properties are not in
     * the spec.
     */

    // Lets us know when the VTTCue's data has changed in such a way that we need
    // to recompute its display state. This lets us compute its display state
    // lazily.
    cue.hasBeenReset = false;

    /**
     * VTTCue and TextTrackCue properties
     * http://dev.w3.org/html5/webvtt/#vttcue-interface
     */

    var _id = '';
    var _pauseOnExit = false;
    var _startTime = startTime;
    var _endTime = endTime;
    var _text = text;
    var _region = null;
    var _vertical = '';
    var _snapToLines = true;
    var _line = 'auto';
    var _lineAlign = 'start';
    var _position = 50;
    var _positionAlign = 'middle';
    var _size = 50;
    var _align = 'middle';

    Object.defineProperty(cue, 'id', extend({}, baseObj, {
      get: function get() {
        return _id;
      },
      set: function set(value) {
        _id = '' + value;
      }
    }));

    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {
      get: function get() {
        return _pauseOnExit;
      },
      set: function set(value) {
        _pauseOnExit = !!value;
      }
    }));

    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {
      get: function get() {
        return _startTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('Start time must be set to a number.');
        }

        _startTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {
      get: function get() {
        return _endTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('End time must be set to a number.');
        }

        _endTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'text', extend({}, baseObj, {
      get: function get() {
        return _text;
      },
      set: function set(value) {
        _text = '' + value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'region', extend({}, baseObj, {
      get: function get() {
        return _region;
      },
      set: function set(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {
      get: function get() {
        return _vertical;
      },
      set: function set(value) {
        var setting = findDirectionSetting(value);
        // Have to check for false because the setting an be an empty string.
        if (setting === false) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _vertical = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {
      get: function get() {
        return _snapToLines;
      },
      set: function set(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'line', extend({}, baseObj, {
      get: function get() {
        return _line;
      },
      set: function set(value) {
        if (typeof value !== 'number' && value !== autoKeyword) {
          throw new SyntaxError('An invalid number or illegal string was specified.');
        }

        _line = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {
      get: function get() {
        return _lineAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'position', extend({}, baseObj, {
      get: function get() {
        return _position;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Position must be between 0 and 100.');
        }

        _position = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {
      get: function get() {
        return _positionAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _positionAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'size', extend({}, baseObj, {
      get: function get() {
        return _size;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Size must be between 0 and 100.');
        }

        _size = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'align', extend({}, baseObj, {
      get: function get() {
        return _align;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _align = setting;
        this.hasBeenReset = true;
      }
    }));

    /**
     * Other <track> spec defined properties
     */

    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
    cue.displayState = undefined;

    if (isIE8) {
      return cue;
    }
  }

  /**
   * VTTCue methods
   */

  VTTCue.prototype.getCueAsHTML = function () {
    // Assume WebVTT.convertCueToDOMTree is on the global.
    var WebVTT = window.WebVTT;
    return WebVTT.convertCueToDOMTree(window, this.text);
  };

  return VTTCue;
}();

module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/vttparser.js":
/*!***************************************!*\
  !*** ./src/hls.js/utils/vttparser.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fixLineBreaks = undefined;

var _vttcue = __webpack_require__(/*! ./vttcue */ "./src/hls.js/utils/vttcue.js");

var _vttcue2 = _interopRequireDefault(_vttcue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StringDecoder = function StringDecoder() {
  return {
    decode: function decode(data) {
      if (!data) {
        return '';
      }

      if (typeof data !== 'string') {
        throw new Error('Error - expected string data.');
      }

      return decodeURIComponent(encodeURIComponent(data));
    }
  };
}; /*
    * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js#L1716
    */

function VTTParser() {
  this.window = window;
  this.state = 'INITIAL';
  this.buffer = '';
  this.decoder = new StringDecoder();
  this.regionList = [];
}

// Try to parse input as a time stamp.
function parseTimeStamp(input) {
  function computeSeconds(h, m, s, f) {
    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
  }

  var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
  if (!m) {
    return null;
  }

  if (m[3]) {
    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
    return computeSeconds(m[1], m[2], m[3].replace(':', ''), m[4]);
  } else if (m[1] > 59) {
    // Timestamp takes the form of [hours]:[minutes].[milliseconds]
    // First position is hours as it's over 59.
    return computeSeconds(m[1], m[2], 0, m[4]);
  } else {
    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
    return computeSeconds(0, m[1], m[2], m[4]);
  }
}

// A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.
function Settings() {
  this.values = Object.create(null);
}

Settings.prototype = {
  // Only accept the first assignment to any key.
  set: function set(k, v) {
    if (!this.get(k) && v !== '') {
      this.values[k] = v;
    }
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function get(k, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k) ? this.values[k] : dflt[defaultKey];
    }

    return this.has(k) ? this.values[k] : dflt;
  },
  // Check whether we have a value for a key.
  has: function has(k) {
    return k in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function alt(k, v, a) {
    for (var n = 0; n < a.length; ++n) {
      if (v === a[n]) {
        this.set(k, v);
        break;
      }
    }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function integer(k, v) {
    if (/^-?\d+$/.test(v)) {
      // integer
      this.set(k, parseInt(v, 10));
    }
  },
  // Accept a setting if its a valid percentage.
  percent: function percent(k, v) {
    var m = void 0;
    if (m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
      v = parseFloat(v);
      if (v >= 0 && v <= 100) {
        this.set(k, v);
        return true;
      }
    }
    return false;
  }
};

// Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.
function parseOptions(input, callback, keyValueDelim, groupDelim) {
  var groups = groupDelim ? input.split(groupDelim) : [input];
  for (var i in groups) {
    if (typeof groups[i] !== 'string') {
      continue;
    }

    var kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) {
      continue;
    }

    var k = kv[0];
    var v = kv[1];
    callback(k, v);
  }
}

var defaults = new _vttcue2.default(0, 0, 0);
// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244
//  Safari doesn't yet support this change, but FF and Chrome do.
var center = defaults.align === 'middle' ? 'middle' : 'center';

function parseCue(input, cue, regionList) {
  // Remember the original input if we need to throw an error.
  var oInput = input;
  // 4.1 WebVTT timestamp
  function consumeTimeStamp() {
    var ts = parseTimeStamp(input);
    if (ts === null) {
      throw new Error('Malformed timestamp: ' + oInput);
    }

    // Remove time stamp from input.
    input = input.replace(/^[^\sa-zA-Z-]+/, '');
    return ts;
  }

  // 4.4.2 WebVTT cue settings
  function consumeCueSettings(input, cue) {
    var settings = new Settings();

    parseOptions(input, function (k, v) {
      switch (k) {
        case 'region':
          // Find the last region we parsed with the same region id.
          for (var i = regionList.length - 1; i >= 0; i--) {
            if (regionList[i].id === v) {
              settings.set(k, regionList[i].region);
              break;
            }
          }
          break;
        case 'vertical':
          settings.alt(k, v, ['rl', 'lr']);
          break;
        case 'line':
          var vals = v.split(','),
              vals0 = vals[0];
          settings.integer(k, vals0);
          if (settings.percent(k, vals0)) {
            settings.set('snapToLines', false);
          }

          settings.alt(k, vals0, ['auto']);
          if (vals.length === 2) {
            settings.alt('lineAlign', vals[1], ['start', center, 'end']);
          }

          break;
        case 'position':
          vals = v.split(',');
          settings.percent(k, vals[0]);
          if (vals.length === 2) {
            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);
          }

          break;
        case 'size':
          settings.percent(k, v);
          break;
        case 'align':
          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);
          break;
      }
    }, /:/, /\s/);

    // Apply default values for any missing fields.
    cue.region = settings.get('region', null);
    cue.vertical = settings.get('vertical', '');
    var line = settings.get('line', 'auto');
    if (line === 'auto' && defaults.line === -1) {
      // set numeric line number for Safari
      line = -1;
    }
    cue.line = line;
    cue.lineAlign = settings.get('lineAlign', 'start');
    cue.snapToLines = settings.get('snapToLines', true);
    cue.size = settings.get('size', 100);
    cue.align = settings.get('align', center);
    var position = settings.get('position', 'auto');
    if (position === 'auto' && defaults.position === 50) {
      // set numeric position for Safari
      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;
    }
    cue.position = position;
  }

  function skipWhitespace() {
    input = input.replace(/^\s+/, '');
  }

  // 4.1 WebVTT cue timings.
  skipWhitespace();
  cue.startTime = consumeTimeStamp(); // (1) collect cue start time
  skipWhitespace();
  if (input.substr(0, 3) !== '-->') {
    // (3) next characters must match '-->'
    throw new Error('Malformed time stamp (time stamps must be separated by \'-->\'): ' + oInput);
  }
  input = input.substr(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp(); // (5) collect cue end time

  // 4.1 WebVTT cue settings list.
  skipWhitespace();
  consumeCueSettings(input, cue);
}

function fixLineBreaks(input) {
  return input.replace(/<br(?: \/)?>/gi, '\n');
}

VTTParser.prototype = {
  parse: function parse(data) {
    var self = this;

    // If there is no data then we won't decode it, but will just try to parse
    // whatever is in buffer already. This may occur in circumstances, for
    // example when flush() is called.
    if (data) {
      // Try to decode the data that we received.
      self.buffer += self.decoder.decode(data, { stream: true });
    }

    function collectNextLine() {
      var buffer = self.buffer;
      var pos = 0;

      buffer = fixLineBreaks(buffer);

      while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
        ++pos;
      }

      var line = buffer.substr(0, pos);
      // Advance the buffer early in case we fail below.
      if (buffer[pos] === '\r') {
        ++pos;
      }

      if (buffer[pos] === '\n') {
        ++pos;
      }

      self.buffer = buffer.substr(pos);
      return line;
    }

    // 3.2 WebVTT metadata header syntax
    function parseHeader(input) {
      parseOptions(input, function (k, v) {
        switch (k) {
          case 'Region':
            // 3.3 WebVTT region metadata header syntax
            // console.log('parse region', v);
            // parseRegion(v);
            break;
        }
      }, /:/);
    }

    // 5.1 WebVTT file parsing.
    try {
      var line = void 0;
      if (self.state === 'INITIAL') {
        // We can't start parsing until we have the first line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        line = collectNextLine();
        // strip of UTF-8 BOM if any
        // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8
        var m = line.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
        if (!m || !m[0]) {
          throw new Error('Malformed WebVTT signature.');
        }

        self.state = 'HEADER';
      }

      var alreadyCollectedLine = false;
      while (self.buffer) {
        // We can't parse a line until we have the full line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        if (!alreadyCollectedLine) {
          line = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }

        switch (self.state) {
          case 'HEADER':
            // 13-18 - Allow a header (metadata) under the WEBVTT line.
            if (/:/.test(line)) {
              parseHeader(line);
            } else if (!line) {
              // An empty line terminates the header and starts the body (cues).
              self.state = 'ID';
            }
            continue;
          case 'NOTE':
            // Ignore NOTE blocks.
            if (!line) {
              self.state = 'ID';
            }

            continue;
          case 'ID':
            // Check for the start of NOTE blocks.
            if (/^NOTE($|[ \t])/.test(line)) {
              self.state = 'NOTE';
              break;
            }
            // 19-29 - Allow any number of line terminators, then initialize new cue values.
            if (!line) {
              continue;
            }

            self.cue = new _vttcue2.default(0, 0, '');
            self.state = 'CUE';
            // 30-39 - Check if self line contains an optional identifier or timing data.
            if (line.indexOf('-->') === -1) {
              self.cue.id = line;
              continue;
            }
          // Process line as start of a cue.
          /* falls through */
          case 'CUE':
            // 40 - Collect cue timings and settings.
            try {
              parseCue(line, self.cue, self.regionList);
            } catch (e) {
              // In case of an error ignore rest of the cue.
              self.cue = null;
              self.state = 'BADCUE';
              continue;
            }
            self.state = 'CUETEXT';
            continue;
          case 'CUETEXT':
            var hasSubstring = line.indexOf('-->') !== -1;
            // 34 - If we have an empty line then report the cue.
            // 35 - If we have the special substring '-->' then report the cue,
            // but do not collect the line as we need to process the current
            // one as a new cue.
            if (!line || hasSubstring && (alreadyCollectedLine = true)) {
              // We are done parsing self cue.
              if (self.oncue) {
                self.oncue(self.cue);
              }

              self.cue = null;
              self.state = 'ID';
              continue;
            }
            if (self.cue.text) {
              self.cue.text += '\n';
            }

            self.cue.text += line;
            continue;
          case 'BADCUE':
            // BADCUE
            // 54-62 - Collect and discard the remaining cue.
            if (!line) {
              self.state = 'ID';
            }

            continue;
        }
      }
    } catch (e) {
      // If we are currently parsing a cue, report what we have.
      if (self.state === 'CUETEXT' && self.cue && self.oncue) {
        self.oncue(self.cue);
      }

      self.cue = null;
      // Enter BADWEBVTT state if header was not parsed correctly otherwise
      // another exception occurred so enter BADCUE state.
      self.state = self.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';
    }
    return this;
  },
  flush: function flush() {
    var self = this;
    try {
      // Finish decoding the stream.
      self.buffer += self.decoder.decode();
      // Synthesize the end of the current cue or region.
      if (self.cue || self.state === 'HEADER') {
        self.buffer += '\n\n';
        self.parse();
      }
      // If we've flushed, parsed, and we're still on the INITIAL state then
      // that means we don't have enough of the stream to parse the first
      // line.
      if (self.state === 'INITIAL') {
        throw new Error('Malformed WebVTT signature.');
      }
    } catch (e) {
      throw e;
    }
    if (self.onflush) {
      self.onflush();
    }

    return this;
  }
};

exports.fixLineBreaks = fixLineBreaks;
exports.default = VTTParser;

/***/ }),

/***/ "./src/hls.js/utils/webvtt-parser.js":
/*!*******************************************!*\
  !*** ./src/hls.js/utils/webvtt-parser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vttparser = __webpack_require__(/*! ./vttparser */ "./src/hls.js/utils/vttparser.js");

var _vttparser2 = _interopRequireDefault(_vttparser);

var _id = __webpack_require__(/*! ../demux/id3 */ "./src/hls.js/demux/id3.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// String.prototype.startsWith is not supported in IE11
var startsWith = function startsWith(inputString, searchString, position) {
  return inputString.substr(position || 0, searchString.length) === searchString;
};

var cueString2millis = function cueString2millis(timeString) {
  var ts = parseInt(timeString.substr(-3));
  var secs = parseInt(timeString.substr(-6, 2));
  var mins = parseInt(timeString.substr(-9, 2));
  var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(':'))) : 0;

  if (!Number.isFinite(ts) || !Number.isFinite(secs) || !Number.isFinite(mins) || !Number.isFinite(hours)) {
    return -1;
  }

  ts += 1000 * secs;
  ts += 60 * 1000 * mins;
  ts += 60 * 60 * 1000 * hours;

  return ts;
};

// From https://github.com/darkskyapp/string-hash
var hash = function hash(text) {
  var hash = 5381;
  var i = text.length;
  while (i) {
    hash = hash * 33 ^ text.charCodeAt(--i);
  }

  return (hash >>> 0).toString();
};

var calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {
  var currCC = vttCCs[cc];
  var prevCC = vttCCs[currCC.prevCC];

  // This is the first discontinuity or cues have been processed since the last discontinuity
  // Offset = current discontinuity time
  if (!prevCC || !prevCC.new && currCC.new) {
    vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
    currCC.new = false;
    return;
  }

  // There have been discontinuities since cues were last parsed.
  // Offset = time elapsed
  while (prevCC && prevCC.new) {
    vttCCs.ccOffset += currCC.start - prevCC.start;
    currCC.new = false;
    currCC = prevCC;
    prevCC = vttCCs[currCC.prevCC];
  }

  vttCCs.presentationOffset = presentationTime;
};

var WebVTTParser = {
  parse: function parse(vttByteArray, syncPTS, vttCCs, cc, callBack, errorCallBack) {
    // Convert byteArray into string, replacing any somewhat exotic linefeeds with "\n", then split on that character.
    var re = /\r\n|\n\r|\n|\r/g;
    // Uint8Array.prototype.reduce is not implemented in IE11
    var vttLines = (0, _id.utf8ArrayToStr)(new Uint8Array(vttByteArray)).trim().replace(re, '\n').split('\n');

    var cueTime = '00:00.000';
    var mpegTs = 0;
    var localTime = 0;
    var presentationTime = 0;
    var cues = [];
    var parsingError = void 0;
    var inHeader = true;
    // let VTTCue = VTTCue || window.TextTrackCue;

    // Create parser object using VTTCue with TextTrackCue fallback on certain browsers.
    var parser = new _vttparser2.default();

    parser.oncue = function (cue) {
      // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.
      var currCC = vttCCs[cc];
      var cueOffset = vttCCs.ccOffset;

      // Update offsets for new discontinuities
      if (currCC && currCC.new) {
        if (localTime !== undefined) {
          // When local time is provided, offset = discontinuity start time - local time
          cueOffset = vttCCs.ccOffset = currCC.start;
        } else {
          calculateOffset(vttCCs, cc, presentationTime);
        }
      }

      if (presentationTime) {
        // If we have MPEGTS, offset = presentation time + discontinuity offset
        cueOffset = presentationTime - vttCCs.presentationOffset;
      }

      cue.startTime += cueOffset - localTime;
      cue.endTime += cueOffset - localTime;

      // Create a unique hash id for a cue based on start/end times and text.
      // This helps timeline-controller to avoid showing repeated captions.
      cue.id = hash(cue.startTime.toString()) + hash(cue.endTime.toString()) + hash(cue.text);

      // Fix encoding of special characters. TODO: Test with all sorts of weird characters.
      cue.text = decodeURIComponent(encodeURIComponent(cue.text));
      if (cue.endTime > 0) {
        cues.push(cue);
      }
    };

    parser.onparsingerror = function (e) {
      parsingError = e;
    };

    parser.onflush = function () {
      if (parsingError && errorCallBack) {
        errorCallBack(parsingError);
        return;
      }
      callBack(cues);
    };

    // Go through contents line by line.
    vttLines.forEach(function (line) {
      if (inHeader) {
        // Look for X-TIMESTAMP-MAP in header.
        if (startsWith(line, 'X-TIMESTAMP-MAP=')) {
          // Once found, no more are allowed anyway, so stop searching.
          inHeader = false;
          // Extract LOCAL and MPEGTS.
          line.substr(16).split(',').forEach(function (timestamp) {
            if (startsWith(timestamp, 'LOCAL:')) {
              cueTime = timestamp.substr(6);
            } else if (startsWith(timestamp, 'MPEGTS:')) {
              mpegTs = parseInt(timestamp.substr(7));
            }
          });
          try {
            // Calculate subtitle offset in milliseconds.
            if (syncPTS + (vttCCs[cc].start * 90000 || 0) < 0) {
              syncPTS += 8589934592;
            }
            // Adjust MPEGTS by sync PTS.
            mpegTs -= syncPTS;
            // Convert cue time to seconds
            localTime = cueString2millis(cueTime) / 1000;
            // Convert MPEGTS to seconds from 90kHz.
            presentationTime = mpegTs / 90000;

            if (localTime === -1) {
              parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
            }
          } catch (e) {
            parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
          }
          // Return without parsing X-TIMESTAMP-MAP line.
          return;
        } else if (line === '') {
          inHeader = false;
        }
      }
      // Parse line by default.
      parser.parse(line + '\n');
    });

    parser.flush();
  }
};

exports.default = WebVTTParser;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/xhr-loader.js":
/*!****************************************!*\
  !*** ./src/hls.js/utils/xhr-loader.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * XHR based logger
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _window = window,
    performance = _window.performance,
    XMLHttpRequest = _window.XMLHttpRequest;

var XhrLoader = function () {
  function XhrLoader(config) {
    _classCallCheck(this, XhrLoader);

    if (config && config.xhrSetup) {
      this.xhrSetup = config.xhrSetup;
    }
  }

  _createClass(XhrLoader, [{
    key: 'destroy',
    value: function destroy() {
      this.abort();
      this.loader = null;
    }
  }, {
    key: 'abort',
    value: function abort() {
      var loader = this.loader;
      if (loader && loader.readyState !== 4) {
        this.stats.aborted = true;
        loader.abort();
      }

      window.clearTimeout(this.requestTimeout);
      this.requestTimeout = null;
      window.clearTimeout(this.retryTimeout);
      this.retryTimeout = null;
    }
  }, {
    key: 'load',
    value: function load(context, config, callbacks) {
      this.context = context;
      this.config = config;
      this.callbacks = callbacks;
      this.stats = { trequest: performance.now(), retry: 0 };
      this.retryDelay = config.retryDelay;
      this.loadInternal();
    }
  }, {
    key: 'loadInternal',
    value: function loadInternal() {
      var xhr = void 0,
          context = this.context;
      xhr = this.loader = new XMLHttpRequest();

      var stats = this.stats;
      stats.tfirst = 0;
      stats.loaded = 0;
      var xhrSetup = this.xhrSetup;

      try {
        if (xhrSetup) {
          try {
            xhrSetup(xhr, context.url);
          } catch (e) {
            // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader("Content-Language", "test");}
            // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN
            xhr.open('GET', context.url, true);
            xhrSetup(xhr, context.url);
          }
        }
        if (!xhr.readyState) {
          xhr.open('GET', context.url, true);
        }
      } catch (e) {
        // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
        this.callbacks.onError({ code: xhr.status, text: e.message }, context, xhr);
        return;
      }

      if (context.rangeEnd) {
        xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
      }

      xhr.onreadystatechange = this.readystatechange.bind(this);
      xhr.onprogress = this.loadprogress.bind(this);
      xhr.responseType = context.responseType;

      // setup timeout before we perform request
      this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
      xhr.send();
    }
  }, {
    key: 'readystatechange',
    value: function readystatechange(event) {
      var xhr = event.currentTarget,
          readyState = xhr.readyState,
          stats = this.stats,
          context = this.context,
          config = this.config;

      // don't proceed if xhr has been aborted
      if (stats.aborted) {
        return;
      }

      // >= HEADERS_RECEIVED
      if (readyState >= 2) {
        // clear xhr timeout and rearm it if readyState less than 4
        window.clearTimeout(this.requestTimeout);
        if (stats.tfirst === 0) {
          stats.tfirst = Math.max(performance.now(), stats.trequest);
        }

        if (readyState === 4) {
          var status = xhr.status;
          // http status between 200 to 299 are all successful
          if (status >= 200 && status < 300) {
            stats.tload = Math.max(stats.tfirst, performance.now());
            var data = void 0,
                len = void 0;
            if (context.responseType === 'arraybuffer') {
              data = xhr.response;
              len = data.byteLength;
            } else {
              data = xhr.responseText;
              len = data.length;
            }
            stats.loaded = stats.total = len;
            var response = { url: xhr.responseURL, data: data };
            this.callbacks.onSuccess(response, stats, context, xhr);
          } else {
            // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
            if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {
              _logger.logger.error(status + ' while loading ' + context.url);
              this.callbacks.onError({ code: status, text: xhr.statusText }, context, xhr);
            } else {
              // retry
              _logger.logger.warn(status + ' while loading ' + context.url + ', retrying in ' + this.retryDelay + '...');
              // aborts and resets internal state
              this.destroy();
              // schedule retry
              this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
              // set exponential backoff
              this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
              stats.retry++;
            }
          }
        } else {
          // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet
          this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout);
        }
      }
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout() {
      _logger.logger.warn('timeout while loading ' + this.context.url);
      this.callbacks.onTimeout(this.stats, this.context, null);
    }
  }, {
    key: 'loadprogress',
    value: function loadprogress(event) {
      var xhr = event.currentTarget,
          stats = this.stats;

      stats.loaded = event.loaded;
      if (event.lengthComputable) {
        stats.total = event.total;
      }

      var onProgress = this.callbacks.onProgress;
      if (onProgress) {
        // third arg is to provide on progress data
        onProgress(stats, this.context, null, xhr);
      }
    }
  }]);

  return XhrLoader;
}();

exports.default = XhrLoader;
module.exports = exports['default'];

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _xgplayer = __webpack_require__(/*! xgplayer */ "xgplayer");

var _xgplayer2 = _interopRequireDefault(_xgplayer);

var _hls = __webpack_require__(/*! ./hls.js/hls */ "./src/hls.js/hls.js");

var _hls2 = _interopRequireDefault(_hls);

var _utils = __webpack_require__(/*! ./utils */ "./src/utils/index.js");

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HlsJsPlayer = function (_Player) {
  _inherits(HlsJsPlayer, _Player);

  function HlsJsPlayer(options) {
    _classCallCheck(this, HlsJsPlayer);

    var _this = _possibleConstructorReturn(this, (HlsJsPlayer.__proto__ || Object.getPrototypeOf(HlsJsPlayer)).call(this, options));

    _this.hlsOpts = options.hlsOpts || {};
    var util = _xgplayer2.default.util;
    var player = _this;
    _this.browser = _utils2.default.getBrowserVersion();
    if (player.config.useHls === undefined) {
      if (_xgplayer2.default.sniffer.device === 'mobile' && navigator.platform !== 'MacIntel' && navigator.platform !== 'Win32' || _this.browser.indexOf('Safari') > -1) {
        return _possibleConstructorReturn(_this);
      }
    } else if (!player.config.useHls) {
      return _possibleConstructorReturn(_this);
    }
    Number.isFinite = Number.isFinite || function (value) {
      return typeof value === "number" && isFinite(value);
    };

    var hls = void 0;
    hls = new _hls2.default(_this.hlsOpts);
    _this.hls = hls;

    Object.defineProperty(player, 'src', {
      get: function get() {
        return player.currentSrc;
      },
      set: function set(url) {
        util.removeClass(player.root, 'xgplayer-is-live');
        var liveDom = document.querySelector('.xgplayer-live');
        if (liveDom) {
          liveDom.parentNode.removeChild(liveDom);
        }
        // player.config.url = url
        var paused = player.paused;
        player.hls.stopLoad();
        player.hls.detachMedia();
        player.hls.destroy();
        player.hls = new _hls2.default(player.hlsOpts);
        player.register(url);
        if (!paused) {
          player.pause();
          player.once('pause', function () {
            player.hls.loadSource(url);
          });
          player.once('canplay', function () {
            player.play().catch(function (err) {});
          });
        } else {
          player.hls.loadSource(url);
        }
        player.hls.attachMedia(player.video);
        player.once('canplay', function () {
          player.currentTime = 0;
        });
      },

      configurable: true
    });
    _this.register(_this.config.url);
    _this.once('complete', function () {
      hls.attachMedia(player.video);
      player.once('canplay', function () {
        if (player.config.autoplay) {
          player.play().catch(function (err) {});
        }
      });
      if (player.config.isLive) {
        util.addClass(player.root, 'xgplayer-is-live');
        if (!util.findDom(player.root, '.xgplayer-live')) {
          var live = util.createDom('xg-live', '正在直播', {}, 'xgplayer-live');
          player.controls.appendChild(live);
        }
      }
    });
    _this.once('destroy', function () {
      hls.stopLoad();
    });
    return _this;
  }

  _createClass(HlsJsPlayer, [{
    key: 'register',
    value: function register(url) {
      var hls = this.hls;
      var util = _xgplayer2.default.util;
      var player = this;
      hls.on(_hls2.default.Events.MEDIA_ATTACHED, function () {
        hls.loadSource(url);
      });

      hls.on(_hls2.default.Events.LEVEL_LOADED, function (name, e) {
        if (!hls.inited) {
          hls.inited = true;
          if (e && e.details && e.details.live) {
            util.addClass(player.root, 'xgplayer-is-live');
            if (!util.findDom(player.root, '.xgplayer-live')) {
              var live = util.createDom('xg-live', '正在直播', {}, 'xgplayer-live');
              player.controls.appendChild(live);
            }
          }
        }
      });
      hls.on(_hls2.default.Events.ERROR, function (event, data) {
        player.emit('HLS_ERROR', {
          errorType: data.type,
          errorDetails: data.details,
          errorFatal: data.fatal
        });
        if (data.fatal) {
          switch (data.type) {
            case _hls2.default.ErrorTypes.NETWORK_ERROR:
              hls.startLoad();
              break;
            case _hls2.default.ErrorTypes.MEDIA_ERROR:
              hls.recoverMediaError();
              break;
            default:
              player.emit('error', data);
          }
        }
      });
      this._statistics();
    }
  }, {
    key: '_statistics',
    value: function _statistics() {
      var statsInfo = {
        speed: 0,
        playerType: "HlsPlayer"
      };

      var mediainfo = {
        videoDataRate: 0,
        audioDataRate: 0
      };
      var hls = this.hls;
      var player = this;

      hls.on(_hls2.default.Events.FRAG_LOAD_PROGRESS, function (flag, payload) {
        statsInfo.speed = payload.stats.loaded / 1000;
      });
      hls.on(_hls2.default.Events.FRAG_PARSING_DATA, function (flag, payload) {
        if (payload.type === 'video') {
          mediainfo.fps = parseInt(payload.nb / (payload.endPTS - payload.startPTS));
        }
      });

      hls.on(_hls2.default.Events.FRAG_PARSING_INIT_SEGMENT, function (flag, payload) {
        mediainfo.hasAudio = payload.tracks && payload.tracks.audio ? true : false;
        mediainfo.hasVideo = payload.tracks && payload.tracks.audio ? true : false;

        if (mediainfo.hasAudio) {
          var track = payload.tracks.audio;
          mediainfo.audioChannelCount = track.metadata && track.metadata.channelCount ? track.metadata.channelCount : 0;
          mediainfo.audioCodec = track.codec;
        }

        if (mediainfo.hasVideo) {
          var _track = payload.tracks.video;
          mediainfo.videoCodec = _track.codec;
          mediainfo.width = _track.metadata && _track.metadata.width ? _track.metadata.width : 0;
          mediainfo.height = _track.metadata && _track.metadata.height ? _track.metadata.height : 0;
        }
        mediainfo.duration = payload.frag && payload.frag.duration ? payload.frag.duration : 0;
        mediainfo.level = payload.frag && payload.frag.levels ? payload.frag.levels : 0;
        if (mediainfo.videoCodec || mediainfo.audioCodec) {
          mediainfo.mimeType = 'video/hls; codecs="' + mediainfo.videoCodec + ';' + mediainfo.audioCodec + '"';
        }

        player.mediainfo = mediainfo;
        player.emit("media_info", mediainfo);
      });

      this._statisticsTimmer = setInterval(function () {
        player.emit("statistics_info", statsInfo);
        statsInfo.speed = 0;
      }, 1000);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _get(HlsJsPlayer.prototype.__proto__ || Object.getPrototypeOf(HlsJsPlayer.prototype), 'destroy', this).call(this);
      clearInterval(this._statisticsTimmer);
    }
  }]);

  return HlsJsPlayer;
}(_xgplayer2.default);

HlsJsPlayer.isSupported = _hls2.default.isSupported;

exports.default = HlsJsPlayer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/utils/index.js":
/*!****************************!*\
  !*** ./src/utils/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var util = {};

util.getBrowserVersion = function () {
  var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串
  if (userAgent.toLowerCase().indexOf("mobile") > -1) {
    return "Unknown";
  }
  if (userAgent.indexOf("Firefox") > -1) {
    var version = userAgent.match(/firefox\/[\d.]+/gi)[0].match(/[\d]+/)[0];
    return "Firefox " + version;
  } else if (userAgent.indexOf("Edge") > -1) {
    var _version = userAgent.match(/edge\/[\d.]+/gi)[0].match(/[\d]+/)[0];
    return "Edge " + _version;
  } else if (userAgent.indexOf("rv:11") > -1) {
    return "IE 11";
  } else if (userAgent.indexOf("Opera") > -1 || userAgent.indexOf("OPR") > -1) {
    if (userAgent.indexOf("Opera") > -1) {
      var _version2 = userAgent.match(/opera\/[\d.]+/gi)[0].match(/[\d]+/)[0];
      return "Opera " + _version2;
    }
    if (userAgent.indexOf("OPR") > -1) {
      var _version3 = userAgent.match(/opr\/[\d.]+/gi)[0].match(/[\d]+/)[0];
      return "Opera " + _version3;
    }
  } else if (userAgent.indexOf("Chrome") > -1) {
    var _version4 = userAgent.match(/chrome\/[\d.]+/gi)[0].match(/[\d]+/)[0];
    return "Chrome " + _version4;
  } else if (userAgent.indexOf("Safari") > -1) {
    var _version5 = userAgent.match(/safari\/[\d.]+/gi)[0].match(/[\d]+/)[0];
    return "Safari " + _version5;
  } else if (userAgent.indexOf("MSIE") > -1 || userAgent.indexOf("Trident") > -1) {
    if (userAgent.indexOf("MSIE") > -1) {
      var _version6 = userAgent.match(/msie [\d.]+/gi)[0].match(/[\d]+/)[0];
      return "IE " + _version6;
    }
    if (userAgent.indexOf("Trident") > -1) {
      var versionTrident = userAgent.match(/trident\/[\d.]+/gi)[0].match(/[\d]+/)[0];
      var _version7 = parseInt(versionTrident) + 4;
      return "IE " + _version7;
    }
  } else {
    return "Unknown";
  }
};

exports.default = util;
module.exports = exports["default"];

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./src/index.js */"./src/index.js");


/***/ }),

/***/ "xgplayer":
/*!*************************!*\
  !*** external "Player" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = window["Player"]; }());

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9IbHNKc1BsYXllci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8vVXNlcnMvbGVvbmFyZG8vRG9jdW1lbnRzL2Zyb250LWVuZC9wbGF5ZXIveGdwbGF5ZXIvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvL1VzZXJzL2xlb25hcmRvL0RvY3VtZW50cy9mcm9udC1lbmQvcGxheWVyL3hncGxheWVyL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy9Vc2Vycy9sZW9uYXJkby9Eb2N1bWVudHMvZnJvbnQtZW5kL3BsYXllci94Z3BsYXllci9ub2RlX21vZHVsZXMvdXJsLXRvb2xraXQvc3JjL3VybC10b29sa2l0LmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy9Vc2Vycy9sZW9uYXJkby9Eb2N1bWVudHMvZnJvbnQtZW5kL3BsYXllci94Z3BsYXllci9ub2RlX21vZHVsZXMvd2Vid29ya2lmeS13ZWJwYWNrL2luZGV4LmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb25maWcuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9iYXNlLXN0cmVhbS1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2ZyYWdtZW50LWZpbmRlcnMuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9nYXAtY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9pZDMtdHJhY2stY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2xldmVsLWhlbHBlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9zdHJlYW0tY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9zdWJ0aXRsZS10cmFjay1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL3RpbWVsaW5lLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NyeXB0L2Flcy1jcnlwdG8uanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NyeXB0L2Flcy1kZWNyeXB0b3IuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NyeXB0L2RlY3J5cHRlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY3J5cHQvZmFzdC1hZXMta2V5LmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9kZW11eC9hYWNkZW11eGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9kZW11eC9hZHRzLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9kZW11eC9kZW11eGVyLWlubGluZS5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvZGVtdXgvZGVtdXhlci13b3JrZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2RlbXV4L2RlbXV4ZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2RlbXV4L2V4cC1nb2xvbWIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2RlbXV4L2lkMy5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvZGVtdXgvbXAzZGVtdXhlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvZGVtdXgvbXA0ZGVtdXhlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvZGVtdXgvbXBlZ2F1ZGlvLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9kZW11eC9zYW1wbGUtYWVzLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9kZW11eC90c2RlbXV4ZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvZXZlbnQtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvZXZlbnRzLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9obHMuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2lzLXN1cHBvcnRlZC5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvbG9hZGVyL2ZyYWdtZW50LWxvYWRlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvbG9hZGVyL2ZyYWdtZW50LmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9sb2FkZXIva2V5LWxvYWRlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvbG9hZGVyL2xldmVsLWtleS5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvbG9hZGVyL2xldmVsLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9sb2FkZXIvbTN1OC1wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2xvYWRlci9wbGF5bGlzdC1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL29ic2VydmVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9yZW11eC9hYWMtaGVscGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9yZW11eC9tcDQtZ2VuZXJhdG9yLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9yZW11eC9tcDQtcmVtdXhlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvdGFzay1sb29wLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy9hdHRyLWxpc3QuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL2JpbmFyeS1zZWFyY2guanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL2J1ZmZlci1oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL2NlYS02MDgtcGFyc2VyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy9jb2RlY3MuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL2N1ZXMuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL2Rpc2NvbnRpbnVpdGllcy5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvdXRpbHMvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy9ld21hLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy9nZXQtc2VsZi1zY29wZS5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvdXRpbHMvbG9nZ2VyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy9tZWRpYWtleXMtaGVscGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL291dHB1dC1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL3RleHR0cmFjay11dGlscy5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvdXRpbHMvdGltZS1yYW5nZXMuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL3Z0dGN1ZS5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvdXRpbHMvdnR0cGFyc2VyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy93ZWJ2dHQtcGFyc2VyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy94aHItbG9hZGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL3V0aWxzL2luZGV4LmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyL2V4dGVybmFsIFwiUGxheWVyXCIiXSwibmFtZXMiOlsiQ3VlcyIsImhsc0RlZmF1bHRDb25maWciLCJhdXRvU3RhcnRMb2FkIiwic3RhcnRQb3NpdGlvbiIsImRlZmF1bHRBdWRpb0NvZGVjIiwidW5kZWZpbmVkIiwiZGVidWciLCJjYXBMZXZlbE9uRlBTRHJvcCIsImNhcExldmVsVG9QbGF5ZXJTaXplIiwiaW5pdGlhbExpdmVNYW5pZmVzdFNpemUiLCJtYXhCdWZmZXJMZW5ndGgiLCJtYXhCdWZmZXJTaXplIiwibWF4QnVmZmVySG9sZSIsImxvd0J1ZmZlcldhdGNoZG9nUGVyaW9kIiwiaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kIiwibnVkZ2VPZmZzZXQiLCJudWRnZU1heFJldHJ5IiwibWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSIsImxpdmVTeW5jRHVyYXRpb25Db3VudCIsImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCIsIkluZmluaXR5IiwibGl2ZVN5bmNEdXJhdGlvbiIsImxpdmVNYXhMYXRlbmN5RHVyYXRpb24iLCJsaXZlRHVyYXRpb25JbmZpbml0eSIsImxpdmVCYWNrQnVmZmVyTGVuZ3RoIiwibWF4TWF4QnVmZmVyTGVuZ3RoIiwiZW5hYmxlV29ya2VyIiwiZW5hYmxlU29mdHdhcmVBRVMiLCJtYW5pZmVzdExvYWRpbmdUaW1lT3V0IiwibWFuaWZlc3RMb2FkaW5nTWF4UmV0cnkiLCJtYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5IiwibWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0Iiwic3RhcnRMZXZlbCIsImxldmVsTG9hZGluZ1RpbWVPdXQiLCJsZXZlbExvYWRpbmdNYXhSZXRyeSIsImxldmVsTG9hZGluZ1JldHJ5RGVsYXkiLCJsZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQiLCJmcmFnTG9hZGluZ1RpbWVPdXQiLCJmcmFnTG9hZGluZ01heFJldHJ5IiwiZnJhZ0xvYWRpbmdSZXRyeURlbGF5IiwiZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQiLCJzdGFydEZyYWdQcmVmZXRjaCIsImZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kIiwiZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQiLCJhcHBlbmRFcnJvck1heFJldHJ5IiwibG9hZGVyIiwiWGhyTG9hZGVyIiwiZkxvYWRlciIsInBMb2FkZXIiLCJ4aHJTZXR1cCIsImxpY2Vuc2VYaHJTZXR1cCIsImFickNvbnRyb2xsZXIiLCJBYnJDb250cm9sbGVyIiwiYnVmZmVyQ29udHJvbGxlciIsIkJ1ZmZlckNvbnRyb2xsZXIiLCJjYXBMZXZlbENvbnRyb2xsZXIiLCJDYXBMZXZlbENvbnRyb2xsZXIiLCJmcHNDb250cm9sbGVyIiwiRlBTQ29udHJvbGxlciIsInN0cmV0Y2hTaG9ydFZpZGVvVHJhY2siLCJtYXhBdWRpb0ZyYW1lc0RyaWZ0IiwiZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eSIsImFickV3bWFGYXN0TGl2ZSIsImFickV3bWFTbG93TGl2ZSIsImFickV3bWFGYXN0Vm9EIiwiYWJyRXdtYVNsb3dWb0QiLCJhYnJFd21hRGVmYXVsdEVzdGltYXRlIiwiYWJyQmFuZFdpZHRoRmFjdG9yIiwiYWJyQmFuZFdpZHRoVXBGYWN0b3IiLCJhYnJNYXhXaXRoUmVhbEJpdHJhdGUiLCJtYXhTdGFydmF0aW9uRGVsYXkiLCJtYXhMb2FkaW5nRGVsYXkiLCJtaW5BdXRvQml0cmF0ZSIsImVtZUVuYWJsZWQiLCJ3aWRldmluZUxpY2Vuc2VVcmwiLCJyZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jIiwicmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIiwic3VidGl0bGVTdHJlYW1Db250cm9sbGVyIiwiU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIiwic3VidGl0bGVUcmFja0NvbnRyb2xsZXIiLCJTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciIsInRpbWVsaW5lQ29udHJvbGxlciIsIlRpbWVsaW5lQ29udHJvbGxlciIsImN1ZUhhbmRsZXIiLCJlbmFibGVDRUE3MDhDYXB0aW9ucyIsImVuYWJsZVdlYlZUVCIsImNhcHRpb25zVGV4dFRyYWNrMUxhYmVsIiwiY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlIiwiY2FwdGlvbnNUZXh0VHJhY2syTGFiZWwiLCJjYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGUiLCJhdWRpb1N0cmVhbUNvbnRyb2xsZXIiLCJBdWRpb1N0cmVhbUNvbnRyb2xsZXIiLCJhdWRpb1RyYWNrQ29udHJvbGxlciIsIkF1ZGlvVHJhY2tDb250cm9sbGVyIiwiZW1lQ29udHJvbGxlciIsIkVNRUNvbnRyb2xsZXIiLCJ3aW5kb3ciLCJwZXJmb3JtYW5jZSIsImhscyIsIkV2ZW50IiwiRlJBR19MT0FESU5HIiwiRlJBR19MT0FERUQiLCJGUkFHX0JVRkZFUkVEIiwiRVJST1IiLCJsYXN0TG9hZGVkRnJhZ0xldmVsIiwiX25leHRBdXRvTGV2ZWwiLCJ0aW1lciIsIl9id0VzdGltYXRvciIsIm9uQ2hlY2siLCJfYWJhbmRvblJ1bGVzQ2hlY2siLCJiaW5kIiwiY2xlYXJUaW1lciIsIkV2ZW50SGFuZGxlciIsInByb3RvdHlwZSIsImRlc3Ryb3kiLCJjYWxsIiwiZGF0YSIsImZyYWciLCJ0eXBlIiwiZnJhZ0N1cnJlbnQiLCJzZXRJbnRlcnZhbCIsImNvbmZpZyIsImxldmVsIiwibGV2ZWxzIiwiaXNMaXZlIiwiZGV0YWlscyIsImxpdmUiLCJld21hRmFzdCIsImV3bWFTbG93IiwiRXdtYUJhbmRXaWR0aEVzdGltYXRvciIsInZpZGVvIiwibWVkaWEiLCJtaW5BdXRvTGV2ZWwiLCJzdGF0cyIsImFib3J0ZWQiLCJsb2dnZXIiLCJ3YXJuIiwicGF1c2VkIiwicGxheWJhY2tSYXRlIiwicmVhZHlTdGF0ZSIsImF1dG9MZXZlbCIsInJlcXVlc3REZWxheSIsIm5vdyIsInRyZXF1ZXN0IiwiTWF0aCIsImFicyIsImR1cmF0aW9uIiwibG9hZFJhdGUiLCJtYXgiLCJidyIsImxvYWRlZCIsImxldmVsQml0cmF0ZSIsInJlYWxCaXRyYXRlIiwiYml0cmF0ZSIsImV4cGVjdGVkTGVuIiwidG90YWwiLCJyb3VuZCIsInBvcyIsImN1cnJlbnRUaW1lIiwiZnJhZ0xvYWRlZERlbGF5IiwiYnVmZmVyU3RhcnZhdGlvbkRlbGF5IiwiQnVmZmVySGVscGVyIiwiYnVmZmVySW5mbyIsImVuZCIsImZyYWdMZXZlbE5leHRMb2FkZWREZWxheSIsIm5leHRMb2FkTGV2ZWwiLCJsZXZlbE5leHRCaXRyYXRlIiwidG9GaXhlZCIsInNhbXBsZSIsImFib3J0IiwidHJpZ2dlciIsIkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCIsIk51bWJlciIsImlzRmluaXRlIiwic24iLCJsb2FkZWRCeXRlcyIsImJ5dGVzIiwibG9hZGVkRHVyYXRpb24iLCJiaXRyYXRlVGVzdCIsInRwYXJzZWQiLCJ0YnVmZmVyZWQiLCJ0bG9hZCIsIm9uRnJhZ0J1ZmZlcmVkIiwiZnJhZ0xvYWRpbmdQcm9jZXNzaW5nTXMiLCJsb2ciLCJ0Zmlyc3QiLCJid0VzdGltYXRlIiwiZ2V0RXN0aW1hdGUiLCJiaXRyYXRlVGVzdERlbGF5IiwiRXJyb3JEZXRhaWxzIiwiRlJBR19MT0FEX0VSUk9SIiwiRlJBR19MT0FEX1RJTUVPVVQiLCJjbGVhckludGVydmFsIiwiY3VycmVudExldmVsIiwiY3VycmVudEZyYWdEdXJhdGlvbiIsImN1cnJlbnRCdyIsIm1heEF1dG9MZXZlbCIsIm1heEZldGNoRHVyYXRpb24iLCJid0ZhY3RvciIsImJ3VXBGYWN0b3IiLCJpIiwibGV2ZWxJbmZvIiwibGV2ZWxEZXRhaWxzIiwiYXZnRHVyYXRpb24iLCJ0b3RhbGR1cmF0aW9uIiwiZnJhZ21lbnRzIiwibGVuZ3RoIiwiYWRqdXN0ZWRidyIsImZldGNoRHVyYXRpb24iLCJ0cmFjZSIsImZvcmNlZEF1dG9MZXZlbCIsImJ3RXN0aW1hdG9yIiwiY2FuRXN0aW1hdGUiLCJuZXh0QUJSQXV0b0xldmVsIiwiX25leHRBQlJBdXRvTGV2ZWwiLCJtaW4iLCJuZXh0TGV2ZWwiLCJhdmdidyIsImJlc3RMZXZlbCIsIl9maW5kQmVzdExldmVsIiwiTGV2ZWxIZWxwZXIiLCJUSUNLX0lOVEVSVkFMIiwiZnJhZ21lbnRUcmFja2VyIiwiTUVESUFfQVRUQUNIRUQiLCJNRURJQV9ERVRBQ0hJTkciLCJBVURJT19UUkFDS1NfVVBEQVRFRCIsIkFVRElPX1RSQUNLX1NXSVRDSElORyIsIkFVRElPX1RSQUNLX0xPQURFRCIsIktFWV9MT0FERUQiLCJGUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UIiwiRlJBR19QQVJTSU5HX0RBVEEiLCJGUkFHX1BBUlNFRCIsIkJVRkZFUl9SRVNFVCIsIkJVRkZFUl9DUkVBVEVEIiwiQlVGRkVSX0FQUEVOREVEIiwiQlVGRkVSX0ZMVVNIRUQiLCJJTklUX1BUU19GT1VORCIsImF1ZGlvQ29kZWNTd2FwIiwiX3N0YXRlIiwiU3RhdGUiLCJTVE9QUEVEIiwiaW5pdFBUUyIsIndhaXRpbmdGcmFnbWVudCIsInZpZGVvVHJhY2tDQyIsImRlbXV4ZXJJZCIsImlkIiwiY2MiLCJzdGF0ZSIsIldBSVRJTkdfSU5JVF9QVFMiLCJ0aWNrIiwidHJhY2tzIiwibGFzdEN1cnJlbnRUaW1lIiwic3RvcExvYWQiLCJmcmFnTG9hZEVycm9yIiwiSURMRSIsIlNUQVJUSU5HIiwibmV4dExvYWRQb3NpdGlvbiIsInRyYWNrIiwidHJhY2tEZXRhaWxzIiwiUEFVU0VEIiwiQlVGRkVSX0ZMVVNISU5HIiwiV0FJVElOR19UUkFDSyIsImxvYWRlZG1ldGFkYXRhIiwic3RhcnRGcmFnUmVxdWVzdGVkIiwibWVkaWFCdWZmZXIiLCJ2aWRlb0J1ZmZlciIsIm1haW5CdWZmZXJJbmZvIiwiYnVmZmVyTGVuIiwibGVuIiwiYnVmZmVyRW5kIiwiZnJhZ1ByZXZpb3VzIiwibWF4Q29uZmlnQnVmZmVyIiwibWF4QnVmTGVuIiwiYXVkaW9Td2l0Y2giLCJ0cmFja0lkIiwiX3N0cmVhbUVuZGVkIiwiQlVGRkVSX0VPUyIsIkVOREVEIiwiZnJhZ0xlbiIsInN0YXJ0IiwiUFRTS25vd24iLCJuZXh0U3RhcnQiLCJpbml0U2VnbWVudCIsImxvYWRJZHgiLCJmcmFnTG9hZElkeCIsIm5leHRCdWZmZXJlZCIsImZvdW5kRnJhZyIsImZyYWdOZXh0IiwiZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0IiwiY2FuZGlkYXRlIiwiY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlIiwiQmluYXJ5U2VhcmNoIiwic2VhcmNoIiwiZW5kU04iLCJzdGFydFNOIiwiZW5jcnlwdGVkIiwiS0VZX0xPQURJTkciLCJnZXRTdGF0ZSIsIkZyYWdtZW50U3RhdGUiLCJOT1RfTE9BREVEIiwiRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkiLCJyZXRyeURhdGUiLCJpc1NlZWtpbmciLCJzZWVraW5nIiwid2FpdGluZ0ZyYWciLCJ3YWl0aW5nRnJhZ0NDIiwib25GcmFnTG9hZGVkIiwiUEFSU0lORyIsIlBBUlNFRCIsIm9udnNlZWtpbmciLCJvbk1lZGlhU2Vla2luZyIsIm9udmVuZGVkIiwib25NZWRpYUVuZGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsInN0YXJ0TG9hZCIsImVuZGVkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9udnNlZWtlZCIsImF1ZGlvVHJhY2tzIiwiYWx0QXVkaW8iLCJ1cmwiLCJkZW11eGVyIiwibmV3RGV0YWlscyIsInNsaWRpbmciLCJjdXJEZXRhaWxzIiwibWVyZ2VEZXRhaWxzIiwic3RhcnRUaW1lT2Zmc2V0IiwiZnJhZ0xvYWRlZCIsImF1ZGlvQ29kZWMiLCJwYXlsb2FkIiwiYXBwZW5kZWQiLCJEZW11eGVyIiwiaW5pdFNlZ21lbnREYXRhIiwicGVuZGluZ0J1ZmZlcmluZyIsImFjY3VyYXRlVGltZU9mZnNldCIsInB1c2giLCJmcmFnTmV3IiwiYXVkaW8iLCJsZXZlbENvZGVjIiwiY29kZWMiLCJCVUZGRVJfQ09ERUNTIiwiY29udGFpbmVyIiwiYXBwZW5kT2JqIiwicGFyZW50IiwiY29udGVudCIsInBlbmRpbmdEYXRhIiwiQlVGRkVSX0FQUEVORElORyIsImVuZFBUUyIsInN0YXJ0UFRTIiwiZW5kRFRTIiwic3RhcnREVFMiLCJhZGRFbGVtZW50YXJ5U3RyZWFtIiwiRnJhZ21lbnQiLCJFbGVtZW50YXJ5U3RyZWFtVHlwZXMiLCJBVURJTyIsIm5iIiwidXBkYXRlRnJhZ1BUU0RUUyIsImFwcGVuZE9uQnVmZmVyRmx1c2giLCJzdGFydE9mZnNldCIsImVuZE9mZnNldCIsIlBPU0lUSVZFX0lORklOSVRZIiwiQVVESU9fVFJBQ0tfU1dJVENIRUQiLCJFcnJvclR5cGVzIiwiTUVESUFfRVJST1IiLCJmYXRhbCIsImRhdGExIiwiZGF0YTIiLCJmb3JFYWNoIiwiYnVmZmVyIiwiX2NoZWNrQXBwZW5kZWRQYXJzZWQiLCJhdWRpb1RyYWNrIiwicGVuZGluZyIsIlRpbWVSYW5nZXMiLCJ0b1N0cmluZyIsImJ1ZmZlcmVkIiwibG9hZEVycm9yIiwiZGVsYXkiLCJwb3ciLCJlcnJvciIsIkFVRElPX1RSQUNLX0xPQURfRVJST1IiLCJBVURJT19UUkFDS19MT0FEX1RJTUVPVVQiLCJLRVlfTE9BRF9FUlJPUiIsIktFWV9MT0FEX1RJTUVPVVQiLCJCVUZGRVJfRlVMTF9FUlJPUiIsIm1lZGlhQnVmZmVyZWQiLCJpc0J1ZmZlcmVkIiwibmV4dFN0YXRlIiwicHJldmlvdXNTdGF0ZSIsIkJhc2VTdHJlYW1Db250cm9sbGVyIiwiTUFOSUZFU1RfTE9BRElORyIsIk1BTklGRVNUX1BBUlNFRCIsIkxFVkVMX0xPQURFRCIsIl90cmFja0lkIiwiX3NlbGVjdERlZmF1bHRUcmFjayIsInRyYWNrSWRCbGFja2xpc3QiLCJPYmplY3QiLCJjcmVhdGUiLCJhdWRpb0dyb3VwSWQiLCJoYXNJbnRlcnZhbCIsInVwZGF0ZVBlcmlvZE1zIiwidGFyZ2V0ZHVyYXRpb24iLCJncm91cElkIiwiYXVkaW9Hcm91cElkcyIsInVybElkIiwiX3NlbGVjdEluaXRpYWxBdWRpb1RyYWNrIiwiTkVUV09SS19FUlJPUiIsImNvbnRleHQiLCJfaGFuZGxlTG9hZEVycm9yIiwibmV3SWQiLCJfbG9hZFRyYWNrRGV0YWlsc0lmTmVlZGVkIiwiX3VwZGF0ZVRyYWNrIiwiY3VycmVudEF1ZGlvVHJhY2siLCJuYW1lIiwiZGVmYXVsdFRyYWNrcyIsImZpbHRlciIsImRlZmF1bHQiLCJ0cmFja0ZvdW5kIiwidHJhdmVyc2VUcmFja3MiLCJfc2V0QXVkaW9UcmFjayIsIl9uZWVkc1RyYWNrTG9hZGluZyIsIkFVRElPX1RSQUNLX0xPQURJTkciLCJwcmV2aW91c0lkIiwibGFuZ3VhZ2UiLCJuZXdUcmFjayIsIlRhc2tMb29wIiwiV0FJVElOR19MRVZFTCIsInJlbW92ZUZyYWdtZW50IiwiY2xlYXJOZXh0VGljayIsImJhY2t0cmFja2VkIiwiZnJhZ1N0YXRlIiwiUEFSVElBTCIsIk9LIiwidG9sZXJhbmNlIiwiZnJhZ1N0YXJ0T2Zmc2V0IiwiZnJhZ0VuZE9mZnNldCIsIk1lZGlhU291cmNlIiwiTUVESUFfQVRUQUNISU5HIiwiTEVWRUxfUFRTX1VQREFURUQiLCJMRVZFTF9VUERBVEVEIiwiX21zRHVyYXRpb24iLCJfbGV2ZWxEdXJhdGlvbiIsIl9sZXZlbFRhcmdldER1cmF0aW9uIiwiX2xpdmUiLCJfb2JqZWN0VXJsIiwiYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCIsIm9uc2J1ZSIsIm9uU0JVcGRhdGVFbmQiLCJvbnNiZSIsIm9uU0JVcGRhdGVFcnJvciIsInBlbmRpbmdUcmFja3MiLCJhdWRpb0J1ZmZlciIsInNvdXJjZUJ1ZmZlciIsImRlbHRhIiwidGltZXN0YW1wT2Zmc2V0IiwidXBkYXRpbmciLCJlcnIiLCJhdWRpb1RpbWVzdGFtcE9mZnNldCIsIm1zIiwibWVkaWFTb3VyY2UiLCJvbm1zbyIsIm9uTWVkaWFTb3VyY2VPcGVuIiwib25tc2UiLCJvbk1lZGlhU291cmNlRW5kZWQiLCJvbm1zYyIsIm9uTWVkaWFTb3VyY2VDbG9zZSIsInNyYyIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImVuZE9mU3RyZWFtIiwibWVzc2FnZSIsInJldm9rZU9iamVjdFVSTCIsInJlbW92ZUF0dHJpYnV0ZSIsImxvYWQiLCJmbHVzaFJhbmdlIiwic2VnbWVudHMiLCJNRURJQV9ERVRBQ0hFRCIsImNoZWNrUGVuZGluZ1RyYWNrcyIsInBlbmRpbmdUcmFja3NDb3VudCIsImtleXMiLCJjcmVhdGVTb3VyY2VCdWZmZXJzIiwiZG9BcHBlbmRpbmciLCJfbmVlZHNGbHVzaCIsImRvRmx1c2giLCJfbmVlZHNFb3MiLCJjaGVja0VvcyIsImFwcGVuZGluZyIsInJlZHVjZSIsImNvdW50ZXIiLCJzZWdtZW50IiwidGltZVJhbmdlcyIsInN0cmVhbVR5cGUiLCJfcGF1c2VkIiwic3RhcnRUaW1lIiwicGxheSIsImVuZFRpbWUiLCJ1cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbiIsImZsdXNoTGl2ZUJhY2tCdWZmZXIiLCJldmVudCIsIkJVRkZFUl9BUFBFTkRJTkdfRVJST1IiLCJzYiIsInJlbW92ZVNvdXJjZUJ1ZmZlciIsInRyYWNrTmFtZSIsIm1pbWVUeXBlIiwiYWRkU291cmNlQnVmZmVyIiwiY29kZSIsIkJVRkZFUl9BRERfQ09ERUNfRVJST1IiLCJkYXRhVHlwZSIsInNib2JqIiwiZSIsImZsdXNoQnVmZmVyQ291bnRlciIsImJ1ZmZlclR5cGVzIiwidGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uIiwiaW5kZXgiLCJidWZmZXJUeXBlIiwicmVtb3ZlQnVmZmVyUmFuZ2UiLCJhdmVyYWdldGFyZ2V0ZHVyYXRpb24iLCJyYW5nZSIsImZsdXNoQnVmZmVyIiwic2hpZnQiLCJjb25zb2xlIiwiYXBwZW5kQnVmZmVyIiwiYXBwZW5kRXJyb3IiLCJ1bnNoaWZ0IiwiQlVGRkVSX0FQUEVORF9FUlJPUiIsInR5cGVJbiIsImJ1ZlN0YXJ0IiwiYnVmRW5kIiwicmVtb3ZlU3RhcnQiLCJyZW1vdmVFbmQiLCJyZW1vdmUiLCJGUFNfRFJPUF9MRVZFTF9DQVBQSU5HIiwiYXV0b0xldmVsQ2FwcGluZyIsImZpcnN0TGV2ZWwiLCJyZXN0cmljdGVkTGV2ZWxzIiwiX3N0b3BDYXBwaW5nIiwiaXNMZXZlbEFsbG93ZWQiLCJkcm9wcGVkTGV2ZWwiLCJIVE1MVmlkZW9FbGVtZW50IiwiX3N0YXJ0Q2FwcGluZyIsImxldmVsc0xlbmd0aCIsImdldE1heExldmVsIiwic3RyZWFtQ29udHJvbGxlciIsIm5leHRMZXZlbFN3aXRjaCIsImNhcExldmVsSW5kZXgiLCJ2YWxpZExldmVscyIsImdldE1heExldmVsQnlNZWRpYVNpemUiLCJtZWRpYVdpZHRoIiwibWVkaWFIZWlnaHQiLCJkZXRlY3RQbGF5ZXJTaXplIiwid2lkdGgiLCJjbGllbnRXaWR0aCIsIm9mZnNldFdpZHRoIiwiY29udGVudFNjYWxlRmFjdG9yIiwiaGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwiaW5kZXhPZiIsImF0R3JlYXRlc3RCYW5kaXdkdGgiLCJjdXJMZXZlbCIsIm1heExldmVsSW5kZXgiLCJwaXhlbFJhdGlvIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIlhNTEh0dHBSZXF1ZXN0IiwiTUFYX0xJQ0VOU0VfUkVRVUVTVF9GQUlMVVJFUyIsIktleVN5c3RlbXMiLCJXSURFVklORSIsIlBMQVlSRUFEWSIsImNyZWF0ZVdpZGV2aW5lTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyIsImF1ZGlvQ29kZWNzIiwidmlkZW9Db2RlY3MiLCJkcm1TeXN0ZW1PcHRpb25zIiwiYmFzZUNvbmZpZyIsInZpZGVvQ2FwYWJpbGl0aWVzIiwiY29udGVudFR5cGUiLCJnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zIiwia2V5U3lzdGVtIiwiRXJyb3IiLCJfd2lkZXZpbmVMaWNlbnNlVXJsIiwiX2xpY2Vuc2VYaHJTZXR1cCIsIl9lbWVFbmFibGVkIiwiX3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyIsIl9tZWRpYUtleXNMaXN0IiwiX21lZGlhIiwiX2hhc1NldE1lZGlhS2V5cyIsIl9pc01lZGlhRW5jcnlwdGVkIiwiX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50IiwiS0VZX1NZU1RFTV9FUlJPUiIsIktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCIsIm1lZGlhS2V5U3lzdGVtQ29uZmlncyIsInRoZW4iLCJtZWRpYUtleVN5c3RlbUFjY2VzcyIsIl9vbk1lZGlhS2V5U3lzdGVtQWNjZXNzT2J0YWluZWQiLCJjYXRjaCIsIm1lZGlhS2V5c0xpc3RJdGVtIiwibWVkaWFLZXlzIiwibWVkaWFLZXlzU2Vzc2lvbiIsIm1lZGlhS2V5c1Nlc3Npb25Jbml0aWFsaXplZCIsIm1lZGlhS2V5U3lzdGVtRG9tYWluIiwiY3JlYXRlTWVkaWFLZXlzIiwiX29uTWVkaWFLZXlzQ3JlYXRlZCIsImNyZWF0ZVNlc3Npb24iLCJfb25OZXdNZWRpYUtleVNlc3Npb24iLCJrZXlTZXNzaW9uIiwic2Vzc2lvbklkIiwiX29uS2V5U2Vzc2lvbk1lc3NhZ2UiLCJfcmVxdWVzdExpY2Vuc2UiLCJ1cGRhdGUiLCJpbml0RGF0YVR5cGUiLCJpbml0RGF0YSIsIl9tZWRpYUVuY3J5cHRpb25Jbml0RGF0YVR5cGUiLCJfbWVkaWFFbmNyeXB0aW9uSW5pdERhdGEiLCJfYXR0ZW1wdFNldE1lZGlhS2V5cyIsIl9nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbiIsImtleXNMaXN0SXRlbSIsIktFWV9TWVNURU1fTk9fS0VZUyIsInNldE1lZGlhS2V5cyIsIktFWV9TWVNURU1fTk9fQUNDRVNTIiwiS0VZX1NZU1RFTV9OT19TRVNTSU9OIiwiZ2VuZXJhdGVSZXF1ZXN0Iiwia2V5TWVzc2FnZSIsImNhbGxiYWNrIiwieGhyIiwib3BlbiIsInJlc3BvbnNlVHlwZSIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsIl9vbkxpY2Vuc2VSZXF1ZXN0UmVhZHlTdGFnZUNoYW5nZSIsInN0YXR1cyIsInJlc3BvbnNlIiwic3RhdHVzVGV4dCIsImF0dGVtcHRzTGVmdCIsImNoYWxsZW5nZSIsImdldExpY2Vuc2VTZXJ2ZXJVcmwiLCJfY3JlYXRlTGljZW5zZVhociIsInNlbmQiLCJfZ2VuZXJhdGVMaWNlbnNlUmVxdWVzdENoYWxsZW5nZSIsIl9vbk1lZGlhRW5jcnlwdGVkIiwibWFwIiwidmlkZW9Db2RlYyIsIl9hdHRlbXB0S2V5U3lzdGVtQWNjZXNzIiwiaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSIsImdldFZpZGVvUGxheWJhY2tRdWFsaXR5IiwiY2hlY2tGUFNJbnRlcnZhbCIsImRlY29kZWRGcmFtZXMiLCJkcm9wcGVkRnJhbWVzIiwibGFzdFRpbWUiLCJjdXJyZW50UGVyaW9kIiwiY3VycmVudERyb3BwZWQiLCJsYXN0RHJvcHBlZEZyYW1lcyIsImN1cnJlbnREZWNvZGVkIiwibGFzdERlY29kZWRGcmFtZXMiLCJkcm9wcGVkRlBTIiwiRlBTX0RST1AiLCJ0b3RhbERyb3BwZWRGcmFtZXMiLCJ2aWRlb1BsYXliYWNrUXVhbGl0eSIsImNoZWNrRlBTIiwidG90YWxWaWRlb0ZyYW1lcyIsImRyb3BwZWRWaWRlb0ZyYW1lcyIsIndlYmtpdERlY29kZWRGcmFtZUNvdW50Iiwid2Via2l0RHJvcHBlZEZyYW1lQ291bnQiLCJmaW5kRnJhZ21lbnRCeVBEVCIsImZpbmRGcmFnbWVudEJ5UFRTIiwicGR0V2l0aGluVG9sZXJhbmNlVGVzdCIsIlBEVFZhbHVlIiwiQXJyYXkiLCJpc0FycmF5IiwicHJvZ3JhbURhdGVUaW1lIiwiZW5kUHJvZ3JhbURhdGVUaW1lIiwic2VnIiwiZGVsdGFQVFMiLCJwZHRCdWZmZXJFbmQiLCJBUFBFTkRJTkciLCJGcmFnbWVudFRyYWNrZXIiLCJidWZmZXJQYWRkaW5nIiwicG9zaXRpb24iLCJsZXZlbFR5cGUiLCJidWZmZXJlZEZyYWdzIiwiZnJhZ21lbnRFbnRpdHkiLCJrZXkiLCJib2R5IiwiYnVmZmVyZWRGcmFnS2V5IiwicG9wIiwiZWxlbWVudGFyeVN0cmVhbSIsInRpbWVSYW5nZSIsImZyYWdtZW50VGltZXMiLCJ0aW1lIiwiZXNEYXRhIiwiaXNUaW1lQnVmZmVyZWQiLCJmcmFnbWVudCIsImZyYWdLZXkiLCJnZXRGcmFnbWVudEtleSIsImhhc0VsZW1lbnRhcnlTdHJlYW0iLCJnZXRCdWZmZXJlZFRpbWVzIiwiZnJhZ21lbnRQYXJ0aWFsIiwicGFydGlhbCIsInRpbWVQYWRkaW5nIiwiYmVzdEZyYWdtZW50IiwiYmVzdE92ZXJsYXAiLCJpc1BhcnRpYWwiLCJkZXRlY3RFdmljdGVkRnJhZ21lbnRzIiwiZGV0ZWN0UGFydGlhbEZyYWdtZW50cyIsInN0YWxsRGVib3VuY2VJbnRlcnZhbCIsImp1bXBUaHJlc2hvbGQiLCJHYXBDb250cm9sbGVyIiwic3RhbGxSZXBvcnRlZCIsInRub3ciLCJzdGFsbGVkIiwibnVkZ2VSZXRyeSIsInN0YWxsZWREdXJhdGlvbiIsIl9yZXBvcnRTdGFsbCIsIl90cnlGaXhCdWZmZXJTdGFsbCIsImdldFBhcnRpYWxGcmFnbWVudCIsIl90cnlTa2lwQnVmZmVySG9sZSIsIl90cnlOdWRnZUJ1ZmZlciIsIkJVRkZFUl9TVEFMTEVEX0VSUk9SIiwibGFzdEVuZFRpbWUiLCJCVUZGRVJfU0VFS19PVkVSX0hPTEUiLCJyZWFzb24iLCJ0YXJnZXRUaW1lIiwiQlVGRkVSX05VREdFX09OX1NUQUxMIiwiSUQzVHJhY2tDb250cm9sbGVyIiwiRlJBR19QQVJTSU5HX01FVEFEQVRBIiwiaWQzVHJhY2siLCJ0ZXh0VHJhY2tzIiwidGV4dFRyYWNrIiwia2luZCIsImxhYmVsIiwiYWRkVGV4dFRyYWNrIiwic2FtcGxlcyIsImdldElEM1RyYWNrIiwibW9kZSIsIkN1ZSIsIldlYktpdERhdGFDdWUiLCJWVFRDdWUiLCJUZXh0VHJhY2tDdWUiLCJmcmFtZXMiLCJJRDMiLCJnZXRJRDNGcmFtZXMiLCJwdHMiLCJqIiwiZnJhbWUiLCJpc1RpbWVTdGFtcEZyYW1lIiwiY3VlIiwidmFsdWUiLCJhZGRDdWUiLCJjaHJvbWVPckZpcmVmb3giLCJMZXZlbENvbnRyb2xsZXIiLCJNQU5JRkVTVF9MT0FERUQiLCJjYW5sb2FkIiwiY3VycmVudExldmVsSW5kZXgiLCJtYW51YWxMZXZlbEluZGV4IiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInRvTG93ZXJDYXNlIiwiY2xlYXJUaW1lb3V0IiwiX2xldmVscyIsImxldmVsUmV0cnlDb3VudCIsImxvYWRMZXZlbCIsImJpdHJhdGVTdGFydCIsImxldmVsU2V0IiwibGV2ZWxGcm9tU2V0IiwidmlkZW9Db2RlY0ZvdW5kIiwiYXVkaW9Db2RlY0ZvdW5kIiwiYXR0cmlidXRlcyIsImF0dHJzIiwiZnJhZ21lbnRFcnJvciIsIlNVQlRJVExFUyIsInNvcnQiLCJhIiwiYiIsIl9maXJzdExldmVsIiwic29tZSIsInQiLCJNQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SIiwibmV3TGV2ZWwiLCJsZXZlbFByb3BlcnRpZXMiLCJMRVZFTF9TV0lUQ0hJTkciLCJMRVZFTF9MT0FESU5HIiwiT1RIRVJfRVJST1IiLCJMRVZFTF9TV0lUQ0hfRVJST1IiLCJsZXZlbEVycm9yIiwibGV2ZWxJbmRleCIsIkxFVkVMX0xPQURfRVJST1IiLCJMRVZFTF9MT0FEX1RJTUVPVVQiLCJSRU1VWF9BTExPQ19FUlJPUiIsInJlY292ZXJMZXZlbCIsImVycm9yRXZlbnQiLCJlcnJvckRldGFpbHMiLCJyZWR1bmRhbnRMZXZlbHMiLCJzZXRUaW1lb3V0IiwibGV2ZWxSZXRyeSIsIm5leHRBdXRvTGV2ZWwiLCJyZWxvYWRJbnRlcnZhbCIsImxldmVsT2JqZWN0Iiwic2V0TGV2ZWxJbnRlcm5hbCIsIl9zdGFydExldmVsIiwiY29uZmlnU3RhcnRMZXZlbCIsImFkZEdyb3VwSWQiLCJ1cGRhdGVQVFMiLCJtZXJnZVN1YnRpdGxlUGxheWxpc3RzIiwibWFwRnJhZ21lbnRJbnRlcnNlY3Rpb24iLCJhZGp1c3RTbGlkaW5nIiwiY29tcHV0ZVJlbG9hZEludGVydmFsIiwidGV4dEdyb3VwSWRzIiwiZnJvbUlkeCIsInRvSWR4IiwiZnJhZ0Zyb20iLCJmcmFnVG8iLCJmcmFnVG9QVFMiLCJtYXhTdGFydFBUUyIsImRyaWZ0IiwiZnJhZ0lkeCIsIm9sZERldGFpbHMiLCJjY09mZnNldCIsIlBUU0ZyYWciLCJvbGRGcmFnIiwibmV3RnJhZyIsImRyb3BwZWQiLCJuZXdGcmFnbWVudHMiLCJvbGRQbGF5bGlzdCIsIm5ld1BsYXlsaXN0IiwicmVmZXJlbmNlU3RhcnQiLCJsYXN0SW5kZXgiLCJmcmFncyIsImludGVyc2VjdGlvbkZuIiwib2xkRnJhZ21lbnRzIiwiY3VycmVudFBsYXlsaXN0IiwibGFzdFJlcXVlc3RUaW1lIiwibWluUmVsb2FkSW50ZXJ2YWwiLCJTdHJlYW1Db250cm9sbGVyIiwiZ2FwQ29udHJvbGxlciIsImZvcmNlU3RhcnRMb2FkIiwiX2RvVGlja0lkbGUiLCJfY2hlY2tCdWZmZXIiLCJfY2hlY2tGcmFnbWVudENoYW5nZWQiLCJsZXZlbExhc3RMb2FkZWQiLCJfZmV0Y2hQYXlsb2FkT3JFb3MiLCJfZW5zdXJlRnJhZ21lbnRBdExpdmVQb2ludCIsIl9maW5kRnJhZ21lbnQiLCJfbG9hZEtleSIsIl9sb2FkRnJhZ21lbnQiLCJtYXhMYXRlbmN5IiwibGl2ZVN5bmNQb3NpdGlvbiIsImNvbXB1dGVMaXZlUG9zaXRpb24iLCJoYXNQcm9ncmFtRGF0ZVRpbWUiLCJ0YXJnZXRTTiIsImxvb2t1cFRvbGVyYW5jZSIsImN1clNOSWR4Iiwic2FtZUxldmVsIiwicHJldkZyYWciLCJuZXh0RnJhZyIsImF1dG9MZXZlbEVuYWJsZWQiLCJfcmVkdWNlTWF4QnVmZmVyTGVuZ3RoIiwiZ2V0QnVmZmVyZWRGcmFnIiwiUGxheWxpc3RMb2FkZXIiLCJMZXZlbFR5cGUiLCJNQUlOIiwiZnJhZ1BsYXlpbmdDdXJyZW50IiwiZnJhZ1BsYXlpbmciLCJGUkFHX0NIQU5HRUQiLCJmcmFnUGxheWluZ0xldmVsIiwiTEVWRUxfU1dJVENIRUQiLCJpbW1lZGlhdGVTd2l0Y2giLCJwcmV2aW91c2x5UGF1c2VkIiwicGF1c2UiLCJmbHVzaE1haW5CdWZmZXIiLCJmZXRjaGRlbGF5IiwibmV4dEJ1ZmZlcmVkRnJhZyIsIm5leHRMZXZlbElkIiwiZnJhZ0xhc3RLYnBzIiwiZm9sbG93aW5nQnVmZmVyZWRGcmFnIiwiZmx1c2hTY29wZSIsIm9uTWVkaWFTZWVrZWQiLCJyZW1vdmVBbGxGcmFnbWVudHMiLCJhYWMiLCJoZWFhYyIsImF1ZGlvQ29kZWNTd2l0Y2giLCJuZXdMZXZlbElkIiwibGFzdExldmVsIiwiX2dldEF1ZGlvQ29kZWMiLCJ1YSIsIm1ldGFkYXRhIiwiY2hhbm5lbENvdW50IiwiaGFzQXVkaW8iLCJoYXNWaWRlbyIsIlZJREVPIiwibWVkaWFUcmFjayIsImFsdGVybmF0ZSIsIm1pbkxlbmd0aCIsIl9zZWVrVG9TdGFydFBvcyIsImltbWVkaWF0ZUxldmVsU3dpdGNoRW5kIiwicG9sbCIsInRhcmdldExhdGVuY3kiLCJTVFJFQU1fU1RBVEVfVFJBTlNJVElPTiIsIl9saXZlU3luY1Bvc2l0aW9uIiwiU1VCVElUTEVfVFJBQ0tTX1VQREFURUQiLCJTVUJUSVRMRV9UUkFDS19TV0lUQ0giLCJTVUJUSVRMRV9UUkFDS19MT0FERUQiLCJTVUJUSVRMRV9GUkFHX1BST0NFU1NFRCIsInRyYWNrc0J1ZmZlcmVkIiwiY3VycmVudFRyYWNrSWQiLCJkZWNyeXB0ZXIiLCJEZWNyeXB0ZXIiLCJsYXN0QVZTdGFydCIsIl9vbk1lZGlhU2Vla2luZyIsInN1Y2Nlc3MiLCJmcmFnU3RhcnQiLCJmcmFnRW5kIiwic3VidGl0bGVUcmFja3MiLCJjdXJyZW50VHJhY2siLCJkZWNyeXB0RGF0YSIsImRlY3J5cHRkYXRhIiwiYnl0ZUxlbmd0aCIsIm1ldGhvZCIsImRlY3J5cHQiLCJpdiIsImRlY3J5cHRlZERhdGEiLCJGUkFHX0RFQ1JZUFRFRCIsInRzdGFydCIsInRkZWNyeXB0IiwiYnVmZmVyZWRJbmZvIiwiX2dldEJ1ZmZlcmVkIiwic3RvcHBlZCIsInN1YnRpdGxlRGlzcGxheSIsInF1ZXVlZERlZmF1bHRUcmFjayIsInN1YnRpdGxlVHJhY2siLCJ0cmFja0NoYW5nZUxpc3RlbmVyIiwiX29uVGV4dFRyYWNrc0NoYW5nZWQiLCJ1c2VUZXh0VHJhY2tQb2xsaW5nIiwic3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwiLCJzdWJ0aXRsZXMiLCJfY2xlYXJSZWxvYWRUaW1lciIsIl9sb2FkQ3VycmVudFRyYWNrIiwiU1VCVElUTEVfVFJBQ0tfTE9BRElORyIsImZpbHRlclN1YnRpdGxlVHJhY2tzIiwic2xpY2UiLCJvbGRUcmFjayIsIm5leHRUcmFjayIsInN1YnRpdGxlVHJhY2tJZCIsIl90b2dnbGVUcmFja01vZGVzIiwiX3NldFN1YnRpdGxlVHJhY2tJbnRlcm5hbCIsInRleHRUcmFja0xpc3QiLCJjYW5SZXVzZVZ0dFRleHRUcmFjayIsImluVXNlVHJhY2siLCJtYW5pZmVzdFRyYWNrIiwidGV4dFRyYWNrMSIsInRleHRUcmFjazIiLCJpbnRlcnNlY3Rpb24iLCJ4MSIsIngyIiwieTEiLCJ5MiIsIkZSQUdfUEFSU0lOR19VU0VSREFUQSIsImVuYWJsZWQiLCJ1bnBhcnNlZFZ0dEZyYWdzIiwiY3VlUmFuZ2VzIiwiY2FwdGlvbnNUcmFja3MiLCJjYXB0aW9uc1Byb3BlcnRpZXMiLCJsYW5ndWFnZUNvZGUiLCJjaGFubmVsMSIsIk91dHB1dEZpbHRlciIsImNoYW5uZWwyIiwiY2VhNjA4UGFyc2VyIiwiQ2VhNjA4UGFyc2VyIiwic2NyZWVuIiwicmFuZ2VzIiwibWVyZ2VkIiwiY3VlUmFuZ2UiLCJvdmVybGFwIiwibmV3Q3VlIiwiZXhpc3RpbmdUcmFjayIsImdldEV4aXN0aW5nVHJhY2siLCJjcmVhdGVUZXh0VHJhY2siLCJsYW5nIiwiX2NsZWFuVHJhY2tzIiwibGFzdFNuIiwicHJldkNDIiwidnR0Q0NzIiwicHJlc2VudGF0aW9uT2Zmc2V0IiwibmV3IiwiaW5Vc2VUcmFja3MiLCJjbG9zZWRDYXB0aW9ucyIsInJlc2V0IiwiX3BhcnNlVlRUcyIsIldlYlZUVFBhcnNlciIsInBhcnNlIiwiY3VlcyIsImdldEN1ZUJ5SWQiLCJ0ZXh0VHJhY2tDdWUiLCJ0ZXh0IiwiY2NkYXRhcyIsImV4dHJhY3RDZWE2MDhEYXRhIiwiYWRkRGF0YSIsImJ5dGVBcnJheSIsImNvdW50IiwidG1wQnl0ZSIsImNjYnl0ZTEiLCJjY2J5dGUyIiwiY2NWYWxpZCIsImNjVHlwZSIsImFjdHVhbENDQnl0ZXMiLCJBRVNDcnlwdG8iLCJzdWJ0bGUiLCJhZXNJViIsInJlbW92ZVBhZGRpbmciLCJvdXRwdXRCeXRlcyIsInBhZGRpbmdCeXRlcyIsIkRhdGFWaWV3IiwiZ2V0VWludDgiLCJBRVNEZWNyeXB0b3IiLCJyY29uIiwic3ViTWl4IiwiVWludDMyQXJyYXkiLCJpbnZTdWJNaXgiLCJzQm94IiwiaW52U0JveCIsImluaXRUYWJsZSIsImFycmF5QnVmZmVyIiwidmlldyIsIm5ld0FycmF5IiwiZ2V0VWludDMyIiwic3ViTWl4MCIsInN1Yk1peDEiLCJzdWJNaXgyIiwic3ViTWl4MyIsImludlN1Yk1peDAiLCJpbnZTdWJNaXgxIiwiaW52U3ViTWl4MiIsImludlN1Yk1peDMiLCJkIiwieCIsInhpIiwic3giLCJ4NCIsIng4Iiwia2V5QnVmZmVyIiwidWludDhBcnJheVRvVWludDMyQXJyYXlfIiwic2FtZUtleSIsIm9mZnNldCIsImtleVNpemUiLCJrc1Jvd3MiLCJrc1JvdyIsImludktzUm93Iiwia2V5U2NoZWR1bGUiLCJpbnZLZXlTY2hlZHVsZSIsInNib3giLCJwcmV2Iiwid29yZCIsImlucHV0QXJyYXlCdWZmZXIiLCJyZW1vdmVQS0NTN1BhZGRpbmciLCJuUm91bmRzIiwiaW52U0JPWCIsImluaXRWZWN0b3IiLCJpbml0VmVjdG9yMCIsImluaXRWZWN0b3IxIiwiaW5pdFZlY3RvcjIiLCJpbml0VmVjdG9yMyIsImlucHV0SW50MzIiLCJJbnQzMkFycmF5Iiwib3V0cHV0SW50MzIiLCJ0MCIsInQxIiwidDIiLCJ0MyIsInMwIiwiczEiLCJzMiIsInMzIiwiaW5wdXRXb3JkczAiLCJpbnB1dFdvcmRzMSIsImlucHV0V29yZHMyIiwiaW5wdXRXb3JkczMiLCJzd2FwV29yZCIsIm5ldHdvcmtUb0hvc3RPcmRlclN3YXAiLCJnbG9iYWwiLCJvYnNlcnZlciIsImxvZ0VuYWJsZWQiLCJicm93c2VyQ3J5cHRvIiwiY3J5cHRvIiwid2Via2l0U3VidGxlIiwiZGlzYWJsZVdlYkNyeXB0byIsImRlY3J5cHRvciIsImV4cGFuZEtleSIsImZhc3RBZXNLZXkiLCJGYXN0QUVTS2V5IiwiYWVzS2V5Iiwib25XZWJDcnlwdG9FcnJvciIsInJlc3VsdCIsIkZSQUdfREVDUllQVF9FUlJPUiIsImltcG9ydEtleSIsIkFEVFMiLCJBQUNEZW11eGVyIiwicmVtdXhlciIsIl9hdWRpb1RyYWNrIiwic2VxdWVuY2VOdW1iZXIiLCJpc0FBQyIsIm1hbmlmZXN0Q29kZWMiLCJpbnB1dFRpbWVTY2FsZSIsInRpbWVPZmZzZXQiLCJjb250aWd1b3VzIiwiaWQzRGF0YSIsImdldElEM0RhdGEiLCJ0aW1lc3RhbXAiLCJnZXRUaW1lU3RhbXAiLCJmcmFtZUluZGV4Iiwic3RhbXAiLCJpZDNTYW1wbGVzIiwiZHRzIiwiaXNIZWFkZXIiLCJpbml0VHJhY2tDb25maWciLCJhcHBlbmRGcmFtZSIsInJlbXV4IiwicHJvYmUiLCJnZXRBdWRpb0NvbmZpZyIsImlzSGVhZGVyUGF0dGVybiIsImdldEhlYWRlckxlbmd0aCIsImdldEZ1bGxGcmFtZUxlbmd0aCIsImdldEZyYW1lRHVyYXRpb24iLCJwYXJzZUZyYW1lSGVhZGVyIiwiYWR0c09iamVjdFR5cGUiLCJhZHRzU2FtcGxlaW5nSW5kZXgiLCJhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXgiLCJhZHRzQ2hhbmVsQ29uZmlnIiwiYWR0c1NhbXBsZWluZ1JhdGVzIiwiRlJBR19QQVJTSU5HX0VSUk9SIiwic2FtcGxlcmF0ZSIsImhlYWRlckxlbmd0aCIsImZyYW1lTGVuZ3RoIiwibmV3T2Zmc2V0IiwiZnJhbWVEdXJhdGlvbiIsImhlYWRlciIsImFhY1NhbXBsZSIsInVuaXQiLCJzdWJhcnJheSIsIkRhdGUiLCJEZW11eGVySW5saW5lIiwidHlwZVN1cHBvcnRlZCIsInZlbmRvciIsImRpc2NvbnRpbnVpdHkiLCJ0cmFja1N3aXRjaCIsImRlZmF1bHRJbml0UFRTIiwicHVzaERlY3J5cHRlZCIsIlVpbnQ4QXJyYXkiLCJtdXhDb25maWciLCJkZW11eCIsIlRTRGVtdXhlciIsIk1QNFJlbXV4ZXIiLCJNUDREZW11eGVyIiwiUGFzc1Rocm91Z2hSZW11eGVyIiwiTVAzRGVtdXhlciIsIm11eCIsInJlc2V0SW5pdFNlZ21lbnQiLCJyZXNldFRpbWVTdGFtcCIsInNldERlY3J5cHREYXRhIiwiYXBwZW5kIiwiRGVtdXhlcldvcmtlciIsInNlbGYiLCJFdmVudEVtaXR0ZXIiLCJlbWl0Iiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJmb3J3YXJkTWVzc2FnZSIsImV2IiwicG9zdE1lc3NhZ2UiLCJjbWQiLCJKU09OIiwib24iLCJ0cmFuc2ZlcmFibGUiLCJ3b3JrIiwiT2JzZXJ2ZXIiLCJtcDQiLCJpc1R5cGVTdXBwb3J0ZWQiLCJtcGVnIiwibXAzIiwiV29ya2VyIiwidyIsInJlcXVpcmUiLCJvbndtc2ciLCJvbldvcmtlck1lc3NhZ2UiLCJvbmVycm9yIiwiSU5URVJOQUxfRVhDRVBUSU9OIiwiZmlsZW5hbWUiLCJsaW5lbm8iLCJzdHJpbmdpZnkiLCJvYmplY3RVUkwiLCJ0ZXJtaW5hdGUiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJsYXN0RnJhZyIsIm5leHRTTiIsIkFycmF5QnVmZmVyIiwiRXhwR29sb21iIiwiYnl0ZXNBdmFpbGFibGUiLCJiaXRzQXZhaWxhYmxlIiwid29ya2luZ0J5dGVzIiwiYXZhaWxhYmxlQnl0ZXMiLCJzZXQiLCJza2lwQnl0ZXMiLCJsb2FkV29yZCIsInNpemUiLCJiaXRzIiwidmFsdSIsInJlYWRCaXRzIiwibGVhZGluZ1plcm9Db3VudCIsInNraXBMWiIsInNraXBCaXRzIiwiY2x6IiwicmVhZFVFRyIsImxhc3RTY2FsZSIsIm5leHRTY2FsZSIsImRlbHRhU2NhbGUiLCJyZWFkRUciLCJmcmFtZUNyb3BMZWZ0T2Zmc2V0IiwiZnJhbWVDcm9wUmlnaHRPZmZzZXQiLCJmcmFtZUNyb3BUb3BPZmZzZXQiLCJmcmFtZUNyb3BCb3R0b21PZmZzZXQiLCJwcm9maWxlSWRjIiwicHJvZmlsZUNvbXBhdCIsImxldmVsSWRjIiwibnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlIiwicGljV2lkdGhJbk1ic01pbnVzMSIsInBpY0hlaWdodEluTWFwVW5pdHNNaW51czEiLCJmcmFtZU1ic09ubHlGbGFnIiwic2NhbGluZ0xpc3RDb3VudCIsInJlYWRVQnl0ZSIsInJlYWRCb29sZWFuIiwic2tpcEVHIiwic2tpcFVFRyIsInNraXBTY2FsaW5nTGlzdCIsImNocm9tYUZvcm1hdElkYyIsInBpY09yZGVyQ250VHlwZSIsImFzcGVjdFJhdGlvSWRjIiwiY2VpbCIsImZyb250IiwiX3JlYWRTaXplIiwiaXNGb290ZXIiLCJfcmVhZFRpbWVTdGFtcCIsImluZm8iLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJmcmFtZURhdGEiLCJfZ2V0RnJhbWVEYXRhIiwiX2RlY29kZUZyYW1lIiwiX2RlY29kZVByaXZGcmFtZSIsIl9kZWNvZGVUZXh0RnJhbWUiLCJfZGVjb2RlVVJMRnJhbWUiLCJ0aW1lU3RhbXBGcmFtZSIsInB0czMzQml0Iiwib3duZXIiLCJfdXRmOEFycmF5VG9TdHIiLCJwcml2YXRlRGF0YSIsImRlc2NyaXB0aW9uIiwiYXJyYXkiLCJleGl0T25OdWxsIiwiYyIsImNoYXIyIiwiY2hhcjMiLCJvdXQiLCJ1dGY4QXJyYXlUb1N0ciIsIk1wZWdBdWRpbyIsIlVJTlQzMl9NQVgiLCJwYXJzZUluaXRTZWdtZW50IiwiYXVkaW92aWRlbyIsImdldFN0YXJ0RFRTIiwib2Zmc2V0U3RhcnREVFMiLCJmaW5kQm94IiwiYXBwbHkiLCJ2YWwiLCJwYXRoIiwicmVzdWx0cyIsInN1YnJlc3VsdHMiLCJlbmRib3giLCJyZWFkVWludDMyIiwiYmluMnN0ciIsImNvbmNhdCIsIm1vb3YiLCJtb292RW5kT2Zmc2V0Iiwic2lkeCIsInJlZmVyZW5jZXMiLCJ2ZXJzaW9uIiwidGltZXNjYWxlIiwiZWFybGllc3RQcmVzZW50YXRpb25UaW1lIiwiZmlyc3RPZmZzZXQiLCJzdGFydEJ5dGUiLCJyZWZlcmVuY2VzQ291bnQiLCJyZWFkVWludDE2IiwicmVmZXJlbmNlSW5kZXgiLCJyZWZlcmVuY2VJbmZvIiwicmVmZXJlbmNlU2l6ZSIsInJlZmVyZW5jZVR5cGUiLCJzdWJzZWdtZW50RHVyYXRpb24iLCJ0cmFrcyIsInRraGQiLCJ0cmFrIiwibWRoZCIsImhkbHIiLCJoZGxyVHlwZSIsImNvZGVjQm94IiwiY29kZWNUeXBlIiwidHJhZnMiLCJiYXNlVGltZXMiLCJ0cmFmIiwidGZoZCIsInNjYWxlIiwiYmFzZVRpbWUiLCJ0ZmR0IiwiYmFzZU1lZGlhRGVjb2RlVGltZSIsIndyaXRlVWludDMyIiwidXBwZXIiLCJmbG9vciIsImxvd2VyIiwiQml0cmF0ZXNNYXAiLCJTYW1wbGluZ1JhdGVNYXAiLCJTYW1wbGVzQ29lZmZpY2llbnRzIiwiQnl0ZXNJblNsb3QiLCJwYXJzZUhlYWRlciIsInNhbXBsZXNQZXJGcmFtZSIsInNhbXBsZVJhdGUiLCJoZWFkZXJCIiwiaGVhZGVyQyIsImhlYWRlckUiLCJoZWFkZXJGIiwiaGVhZGVyRyIsImNvbHVtbkluQml0cmF0ZXMiLCJiaXRSYXRlIiwiY29sdW1uSW5TYW1wbGVSYXRlcyIsInNhbXBsZUNvZWZmaWNpZW50IiwiYnl0ZXNJblNsb3QiLCJwYXJzZUludCIsIlNhbXBsZUFlc0RlY3J5cHRlciIsImRpc2NhcmRFUEIiLCJlbmNyeXB0ZWREYXRhIiwic2FtcGxlSW5kZXgiLCJzeW5jIiwiY3VyVW5pdCIsImVuY3J5cHRlZEJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJsb2NhbHRoaXMiLCJkZWNyeXB0QnVmZmVyIiwiZGVjcnlwdEFhY1NhbXBsZXMiLCJpc1N5bmMiLCJkZWNyeXB0QWFjU2FtcGxlIiwiZGVjb2RlZERhdGEiLCJlbmNyeXB0ZWREYXRhTGVuIiwiSW50OEFycmF5Iiwib3V0cHV0UG9zIiwiaW5wdXRQb3MiLCJ1bml0SW5kZXgiLCJnZXRBdmNFbmNyeXB0ZWREYXRhIiwiZ2V0QXZjRGVjcnlwdGVkVW5pdCIsImRlY3J5cHRBdmNTYW1wbGVzIiwiY3VyVW5pdHMiLCJ1bml0cyIsImRlY3J5cHRBdmNTYW1wbGUiLCJSZW11eGVyVHJhY2tJZENvbmZpZyIsImlkMyIsInNhbXBsZUFlcyIsInBtdFBhcnNlZCIsIl9wbXRJZCIsIl9hdmNUcmFjayIsImNyZWF0ZVRyYWNrIiwiX2lkM1RyYWNrIiwiX3R4dFRyYWNrIiwiYWFjT3ZlckZsb3ciLCJhYWNMYXN0UFRTIiwiYXZjU2FtcGxlIiwiX2R1cmF0aW9uIiwic3R0IiwicGlkIiwiYXRmIiwicGVzIiwidW5rbm93blBJRHMiLCJhdmNUcmFjayIsImF2Y0lkIiwiYXVkaW9JZCIsImlkM0lkIiwicG10SWQiLCJhdmNEYXRhIiwicGVzRGF0YSIsImF1ZGlvRGF0YSIsInBhcnNlUEFUIiwiX3BhcnNlUEFUIiwicGFyc2VQTVQiLCJfcGFyc2VQTVQiLCJwYXJzZVBFUyIsIl9wYXJzZVBFUyIsInBhcnNlQVZDUEVTIiwiX3BhcnNlQVZDUEVTIiwicGFyc2VBQUNQRVMiLCJfcGFyc2VBQUNQRVMiLCJwYXJzZU1QRUdQRVMiLCJfcGFyc2VNUEVHUEVTIiwicGFyc2VJRDNQRVMiLCJfcGFyc2VJRDNQRVMiLCJzeW5jT2Zmc2V0IiwiX3N5bmNPZmZzZXQiLCJwYXJzZWRQSURzIiwiYXZjIiwiZGVjcnlwdEFuZFJlbXV4IiwidmlkZW9UcmFjayIsImRlY3J5cHRBbmRSZW11eEF2YyIsIl9pbml0UFRTIiwiX2luaXREVFMiLCJtcGVnU3VwcG9ydGVkIiwiaXNTYW1wbGVBZXMiLCJzZWN0aW9uTGVuZ3RoIiwidGFibGVFbmQiLCJwcm9ncmFtSW5mb0xlbmd0aCIsInN0cmVhbSIsInBlc0ZsYWdzIiwicGVzUHJlZml4IiwicGVzTGVuIiwicGVzSGRyTGVuIiwicGVzUHRzIiwicGVzRHRzIiwicGF5bG9hZFN0YXJ0T2Zmc2V0IiwibmV3RGF0YSIsInNwbGljZSIsImRhdGFMZW4iLCJuYlNhbXBsZXMiLCJzcHMiLCJsYXN0IiwiX3BhcnNlQVZDTkFMdSIsImV4cEdvbG9tYkRlY29kZXIiLCJzcHNmb3VuZCIsInB1c2hBY2Nlc1VuaXQiLCJjcmVhdGVBVkNTYW1wbGUiLCJhdWRGb3VuZCIsInNsaWNlVHlwZSIsInJlYWRTbGljZVR5cGUiLCJwYXlsb2FkVHlwZSIsInBheWxvYWRTaXplIiwiZW5kT2ZDYXB0aW9ucyIsImNvdW50cnlDb2RlIiwicHJvdmlkZXJDb2RlIiwicmVhZFVTaG9ydCIsInVzZXJTdHJ1Y3R1cmUiLCJyZWFkVUludCIsInVzZXJEYXRhVHlwZSIsImZpcnN0Qnl0ZSIsInNlY29uZEJ5dGUiLCJ0b3RhbENDcyIsIl9pbnNlcnRTYW1wbGVJbk9yZGVyIiwicmVhZFNQUyIsImNvZGVjYXJyYXkiLCJjb2RlY3N0cmluZyIsImgiLCJwcHMiLCJhcnIiLCJsYXN0VW5pdCIsIm92ZXJmbG93IiwibmFsdVN0YXRlIiwibGFzdFN0YXRlIiwidW5pdFR5cGUiLCJsYXN0VW5pdFN0YXJ0IiwibGFzdFVuaXRUeXBlIiwiX2dldExhc3ROYWxVbml0IiwidG1wIiwiRVBCUG9zaXRpb25zIiwibmV3TGVuZ3RoIiwic291cmNlSW5kZXgiLCJuZXdQVFMiLCJzY2Fud2luZG93IiwiTVVYX0VSUk9SIiwiTUFOSUZFU1RfTE9BRF9FUlJPUiIsIk1BTklGRVNUX0xPQURfVElNRU9VVCIsIk1BTklGRVNUX1BBUlNJTkdfRVJST1IiLCJGT1JCSURERU5fRVZFTlRfTkFNRVMiLCJvbkV2ZW50IiwiZXZlbnRzIiwiaGFuZGxlZEV2ZW50cyIsInVzZUdlbmVyaWNIYW5kbGVyIiwicmVnaXN0ZXJMaXN0ZW5lcnMiLCJvbkhhbmRsZXJEZXN0cm95aW5nIiwidW5yZWdpc3Rlckxpc3RlbmVycyIsIm9uSGFuZGxlckRlc3Ryb3llZCIsImlzRXZlbnRIYW5kbGVyIiwib25FdmVudEdlbmVyaWMiLCJldmVudFRvRnVuY3Rpb24iLCJmdW5jTmFtZSIsInJlcGxhY2UiLCJjb25zdHJ1Y3RvciIsIkhsc0V2ZW50cyIsIkZSQUdfTE9BRF9QUk9HUkVTUyIsIkRFU1RST1lJTkciLCJVUkxUb29sa2l0IiwiSGxzIiwiX19WRVJTSU9OX18iLCJkZWZhdWx0Q29uZmlnIiwiRGVmYXVsdENvbmZpZyIsInByb3AiLCJfYXV0b0xldmVsQ2FwcGluZyIsInBsYXlMaXN0TG9hZGVyIiwiZnJhZ21lbnRMb2FkZXIiLCJGcmFnbWVudExvYWRlciIsImtleUxvYWRlciIsIktleUxvYWRlciIsImlkM1RyYWNrQ29udHJvbGxlciIsImxldmVsQ29udHJvbGxlciIsIm5ldHdvcmtDb250cm9sbGVycyIsIkNvbnRyb2xsZXIiLCJjb3JlQ29tcG9uZW50cyIsImRldGFjaE1lZGlhIiwiY29tcG9uZW50IiwiYnVpbGRBYnNvbHV0ZVVSTCIsImxvY2F0aW9uIiwiaHJlZiIsImFsd2F5c05vcm1hbGl6ZSIsImNvbnRyb2xsZXIiLCJzd2FwQXVkaW9Db2RlYyIsImF0dGFjaE1lZGlhIiwiaW1tZWRpYXRlTGV2ZWxTd2l0Y2giLCJtYW51YWxMZXZlbCIsImF1ZGlvVHJhY2tJZCIsImlzU3VwcG9ydGVkIiwiU291cmNlQnVmZmVyIiwiV2ViS2l0U291cmNlQnVmZmVyIiwic291cmNlQnVmZmVyVmFsaWRBUEkiLCJsb2FkZXJzIiwibG9hZGVyTmFtZSIsIkZyYWdtZW50SUxvYWRlciIsIkRlZmF1bHRJTG9hZGVyIiwibG9hZGVyQ29udGV4dCIsImxvYWRlckNvbmZpZyIsImxvYWRlckNhbGxiYWNrcyIsInByb2dyZXNzRGF0YSIsImJ5dGVSYW5nZVN0YXJ0T2Zmc2V0IiwiYnl0ZVJhbmdlRW5kT2Zmc2V0IiwicmFuZ2VTdGFydCIsInJhbmdlRW5kIiwidGltZW91dCIsIm1heFJldHJ5IiwicmV0cnlEZWxheSIsIm1heFJldHJ5RGVsYXkiLCJvblN1Y2Nlc3MiLCJsb2Fkc3VjY2VzcyIsIm9uRXJyb3IiLCJsb2FkZXJyb3IiLCJvblRpbWVvdXQiLCJsb2FkdGltZW91dCIsIm9uUHJvZ3Jlc3MiLCJsb2FkcHJvZ3Jlc3MiLCJuZXR3b3JrRGV0YWlscyIsIl91cmwiLCJfYnl0ZVJhbmdlIiwiX2RlY3J5cHRkYXRhIiwidGFnTGlzdCIsInJhd1Byb2dyYW1EYXRlVGltZSIsIl9lbGVtZW50YXJ5U3RyZWFtcyIsInNlZ21lbnROdW1iZXIiLCJ1aW50OFZpZXciLCJsZXZlbGtleSIsInVyaSIsIkxldmVsS2V5IiwiYmFzZXVyaSIsInJlbHVyaSIsImNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yIiwicmVsdXJsIiwiYmFzZXVybCIsInJhd0J5dGVSYW5nZSIsImJ5dGVSYW5nZSIsInBhcmFtcyIsInNwbGl0IiwibGFzdEJ5dGVSYW5nZUVuZE9mZnNldCIsImZyYWdtZW50RGVjcnlwdGRhdGFGcm9tTGV2ZWxrZXkiLCJkZWNyeXB0a2V5IiwiZGVjcnlwdHVybCIsIl91cmkiLCJMZXZlbCIsImJhc2VVcmwiLCJlbmRDQyIsIm5lZWRTaWR4UmFuZ2VzIiwic3RhcnRDQyIsIk1BU1RFUl9QTEFZTElTVF9SRUdFWCIsIk1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWCIsIkxFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QiLCJSZWdFeHAiLCJzb3VyY2UiLCJqb2luIiwiTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyIsIk1QNF9SRUdFWF9TVUZGSVgiLCJNM1U4UGFyc2VyIiwiZ3JvdXBzIiwibWVkaWFHcm91cElkIiwibWF0Y2hpbmdHcm91cCIsImdyb3VwIiwiYXZjZGF0YSIsInN1YnN0ciIsInN0cmluZyIsInNldENvZGVjcyIsImNvZGVjcyIsImZpbHRlcmVkIiwicHJlZmVycmVkIiwibGFzdEluZGV4T2YiLCJ1bmtub3duQ29kZWNzIiwiZXhlYyIsIkF0dHJMaXN0IiwicmVzb2x2ZSIsInJlc29sdXRpb24iLCJkZWNpbWFsUmVzb2x1dGlvbiIsImRlY2ltYWxJbnRlZ2VyIiwiTkFNRSIsIkNPREVDUyIsImNvbnZlcnRBVkMxVG9BVkNPVEkiLCJhdWRpb0dyb3VwcyIsIm1lZGlhcyIsIlRZUEUiLCJERUZBVUxUIiwiYXV0b3NlbGVjdCIsIkFVVE9TRUxFQ1QiLCJmb3JjZWQiLCJGT1JDRUQiLCJVUkkiLCJMQU5HVUFHRSIsImdyb3VwQ29kZWMiLCJmaW5kR3JvdXAiLCJsZXZlbFVybElkIiwiY3VycmVudFNOIiwiZmlyc3RQZHRJbmRleCIsInBhcnNlRmxvYXQiLCJ0aXRsZSIsImFzc2lnblByb2dyYW1EYXRlVGltZSIsIm1hdGNoIiwidmFsdWUxIiwidmFsdWUyIiwidG9VcHBlckNhc2UiLCJkZWNyeXB0cGFyYW1zIiwia2V5QXR0cnMiLCJkZWNyeXB0bWV0aG9kIiwiZW51bWVyYXRlZFN0cmluZyIsImRlY3J5cHR1cmkiLCJkZWNyeXB0aXYiLCJoZXhhZGVjaW1hbEludGVnZXIiLCJzdGFydFBhcmFtcyIsInN0YXJ0QXR0cnMiLCJkZWNpbWFsRmxvYXRpbmdQb2ludCIsIm1hcEF0dHJzIiwiQllURVJBTkdFIiwiZXZlcnkiLCJiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMiLCJzdGFydEluZGV4IiwiZnJhZ1ByZXYiLCJDb250ZXh0VHlwZSIsIk1BTklGRVNUIiwiTEVWRUwiLCJBVURJT19UUkFDSyIsIlNVQlRJVExFX1RSQUNLIiwiU1VCVElUTEUiLCJQTG9hZGVyIiwiTG9hZGVyIiwiSW50ZXJuYWxMb2FkZXIiLCJjb250ZXh0VHlwZSIsInJlc2V0SW50ZXJuYWxMb2FkZXIiLCJkZXN0cm95SW50ZXJuYWxMb2FkZXJzIiwiZ2V0SW50ZXJuYWxMb2FkZXIiLCJjcmVhdGVJbnRlcm5hbExvYWRlciIsImlzU2lkeFJlcXVlc3QiLCJfaGFuZGxlU2lkeFJlcXVlc3QiLCJfaGFuZGxlUGxheWxpc3RMb2FkZWQiLCJfaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IiLCJfaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QiLCJfaGFuZGxlTWFzdGVyUGxheWxpc3QiLCJfaGFuZGxlTmV0d29ya0Vycm9yIiwiZ2V0UmVzcG9uc2VVcmwiLCJwYXJzZU1hc3RlclBsYXlsaXN0IiwicGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhIiwiZW1iZWRkZWRBdWRpb0ZvdW5kIiwibGV2ZWxJZCIsIm1hcENvbnRleHRUb0xldmVsVHlwZSIsInBhcnNlTGV2ZWxQbGF5bGlzdCIsInNpbmdsZUxldmVsIiwic2lkeFVybCIsInNpZHhJbmZvIiwicGFyc2VTZWdtZW50SW5kZXgiLCJzaWR4UmVmZXJlbmNlcyIsInNlZ21lbnRSZWYiLCJzZWdSZWZJbmZvIiwiZXJyb3JEYXRhIiwiY2FuSGF2ZUxldmVscyIsImNhbkhhdmVRdWFsaXR5TGV2ZWxzIiwiQUFDIiwiTVA0IiwidHlwZXMiLCJhdmMxIiwiYXZjQyIsImJ0cnQiLCJkaW5mIiwiZHJlZiIsImVzZHMiLCJmdHlwIiwibWRhdCIsIm1kaWEiLCJtZmhkIiwibWluZiIsIm1vb2YiLCJtcDRhIiwibXZleCIsIm12aGQiLCJwYXNwIiwic2R0cCIsInN0YmwiLCJzdGNvIiwic3RzYyIsInN0c2QiLCJzdHN6Iiwic3R0cyIsInRydW4iLCJ0cmV4Iiwidm1oZCIsInNtaGQiLCJoYXNPd25Qcm9wZXJ0eSIsImNoYXJDb2RlQXQiLCJ2aWRlb0hkbHIiLCJhdWRpb0hkbHIiLCJIRExSX1RZUEVTIiwiU1RUUyIsIlNUU0MiLCJTVENPIiwiU1RTWiIsIlZNSEQiLCJTTUhEIiwiU1RTRCIsIm1ham9yQnJhbmQiLCJhdmMxQnJhbmQiLCJtaW5vclZlcnNpb24iLCJGVFlQIiwiYm94IiwiRElORiIsImFyZ3VtZW50cyIsInVwcGVyV29yZER1cmF0aW9uIiwibG93ZXJXb3JkRHVyYXRpb24iLCJib3hlcyIsImZsYWdzIiwiZGVwZW5kc09uIiwiaXNEZXBlbmRlZE9uIiwiaGFzUmVkdW5kYW5jeSIsImF2Y2MiLCJoU3BhY2luZyIsInZTcGFjaW5nIiwiY29uZmlnbGVuIiwic2FtcGxlRGVwZW5kZW5jeVRhYmxlIiwidXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSIsImxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUiLCJhcnJheWxlbiIsImN0cyIsImlzTGVhZGluZyIsInBhZGRpbmdWYWx1ZSIsImlzTm9uU3luYyIsImRlZ3JhZFByaW8iLCJpbml0IiwibW92aWUiLCJNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OIiwiaXNTYWZhcmkiLCJJU0dlbmVyYXRlZCIsImRlZmF1bHRUaW1lU3RhbXAiLCJnZW5lcmF0ZUlTIiwibmJBdWRpb1NhbXBsZXMiLCJuYlZpZGVvU2FtcGxlcyIsImF1ZGlvVGltZU9mZnNldCIsInZpZGVvVGltZU9mZnNldCIsImF1ZGlvdmlkZW9EZWx0YUR0cyIsInJlbXV4QXVkaW8iLCJhdWRpb1RyYWNrTGVuZ3RoIiwicmVtdXhWaWRlbyIsInZpZGVvRGF0YSIsInJlbXV4RW1wdHlBdWRpbyIsInJlbXV4SUQzIiwicmVtdXhUZXh0IiwiYXVkaW9TYW1wbGVzIiwidmlkZW9TYW1wbGVzIiwiY29tcHV0ZVBUU0RUUyIsImluaXREVFMiLCJtcDRTYW1wbGVEdXJhdGlvbiIsImZpcnN0UFRTIiwiZmlyc3REVFMiLCJsYXN0UFRTIiwibGFzdERUUyIsInRpbWVTY2FsZSIsImlucHV0U2FtcGxlcyIsIm91dHB1dFNhbXBsZXMiLCJwdHNOb3JtYWxpemUiLCJfUFRTTm9ybWFsaXplIiwibmV4dEF2Y0R0cyIsImRlbHRhZHRzIiwiZGVsdGFwdHMiLCJQVFNEVFNzaGlmdCIsImN1cnIiLCJuYk5hbHUiLCJuYWx1TGVuIiwibmJVbml0cyIsInNhbXBsZUxlbiIsIm1kYXRTaXplIiwic2V0VWludDMyIiwiYXZjU2FtcGxlVW5pdHMiLCJtcDRTYW1wbGVMZW5ndGgiLCJjb21wb3NpdGlvblRpbWVPZmZzZXQiLCJ1bml0RGF0YSIsInVuaXREYXRhTGVuIiwibGFzdEZyYW1lRHVyYXRpb24iLCJnYXBUb2xlcmFuY2UiLCJkZWx0YVRvRnJhbWVFbmQiLCJuZXh0QXVkaW9QdHMiLCJtcDR0aW1lU2NhbGUiLCJzY2FsZUZhY3RvciIsImlucHV0U2FtcGxlRHVyYXRpb24iLCJyYXdNUEVHIiwibXA0U2FtcGxlIiwiZmlsbEZyYW1lIiwibmV4dFB0cyIsIm1pc3NpbmciLCJuZXdTdGFtcCIsImdldFNpbGVudEZyYW1lIiwiYXVkaW9TYW1wbGUiLCJudW1NaXNzaW5nRnJhbWVzIiwidW5pdExlbiIsImxhc3RTYW1wbGVEdXJhdGlvbiIsInNhbXBsZUR1cmF0aW9uIiwic2lsZW50RnJhbWUiLCJyZWZlcmVuY2UiLCJyYXdEYXRhIiwiX3RpY2tJbnRlcnZhbCIsIl90aWNrVGltZXIiLCJfdGlja0NhbGxDb3VudCIsIl9ib3VuZFRpY2siLCJtaWxsaXMiLCJkb1RpY2siLCJERUNJTUFMX1JFU09MVVRJT05fUkVHRVgiLCJBVFRSX0xJU1RfUkVHRVgiLCJwYXJzZUF0dHJMaXN0IiwiYXR0ciIsImF0dHJOYW1lIiwiaW50VmFsdWUiLCJNQVhfU0FGRV9JTlRFR0VSIiwic3RyaW5nVmFsdWUiLCJyZXMiLCJpbnB1dCIsInF1b3RlIiwibGlzdCIsImNvbXBhcmlzb25GdW5jdGlvbiIsIm1pbkluZGV4IiwibWF4SW5kZXgiLCJjdXJyZW50SW5kZXgiLCJjdXJyZW50RWxlbWVudCIsImNvbXBhcmlzb25SZXN1bHQiLCJtYXhIb2xlRHVyYXRpb24iLCJ2YnVmZmVyZWQiLCJidWZmZXJlZDIiLCJidWZmZXJTdGFydCIsImJ1ZmZlclN0YXJ0TmV4dCIsImRpZmYiLCJidWYybGVuIiwiYnVmMmVuZCIsInNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzIiwiZ2V0Q2hhckZvckJ5dGUiLCJieXRlIiwiY2hhckNvZGUiLCJOUl9ST1dTIiwiTlJfQ09MUyIsInJvd3NMb3dDaDEiLCJyb3dzSGlnaENoMSIsInJvd3NMb3dDaDIiLCJyb3dzSGlnaENoMiIsImJhY2tncm91bmRDb2xvcnMiLCJ2ZXJib3NlRmlsdGVyIiwidmVyYm9zZUxldmVsIiwic2V0VGltZSIsIm5ld1RpbWUiLCJzZXZlcml0eSIsIm1zZyIsIm1pbkxldmVsIiwibnVtQXJyYXlUb0hleEFycmF5IiwibnVtQXJyYXkiLCJoZXhBcnJheSIsIlBlblN0YXRlIiwiZm9yZWdyb3VuZCIsInVuZGVybGluZSIsIml0YWxpY3MiLCJiYWNrZ3JvdW5kIiwiZmxhc2giLCJzdHlsZXMiLCJhdHRyaWJzIiwic3R5bGUiLCJvdGhlciIsIm5ld1BlblN0YXRlIiwiU3R5bGVkVW5pY29kZUNoYXIiLCJ1Y2hhciIsInBlblN0YXRlIiwiY29weSIsImVxdWFscyIsIm5ld0NoYXIiLCJpc0RlZmF1bHQiLCJSb3ciLCJjaGFycyIsImN1cnJQZW5TdGF0ZSIsImVxdWFsIiwiZW1wdHkiLCJpc0VtcHR5IiwiYWJzUG9zIiwicmVsUG9zIiwibmV3UG9zIiwic2V0UGVuU3RhdGUiLCJzZXRDdXJzb3IiLCJtb3ZlQ3Vyc29yIiwic2V0Q2hhciIsImJhY2tTcGFjZSIsImNoYXIiLCJzdGFydFBvcyIsImNsZWFyRnJvbVBvcyIsInNldFN0eWxlcyIsImN1cnJDaGFyIiwiQ2FwdGlvblNjcmVlbiIsInJvd3MiLCJjdXJyUm93IiwibnJSb2xsVXBSb3dzIiwiY2xlYXIiLCJyb3ciLCJjbGVhclRvRW5kT2ZSb3ciLCJpbnNlcnRDaGFyIiwic2V0UGVuU3R5bGVzIiwicGFjRGF0YSIsIm5ld1JvdyIsInRvcFJvd0luZGV4IiwibGFzdE91dHB1dFNjcmVlbiIsInByZXZMaW5lVGltZSIsImN1ZVN0YXJ0VGltZSIsImluZGVudCIsInByZXZQb3MiLCJjb2xvciIsInNldFBlbiIsImJrZ0RhdGEiLCJuclJvd3MiLCJnZXREaXNwbGF5VGV4dCIsInRvcFJvdyIsImFzT25lUm93IiwiZGlzcGxheVRleHQiLCJyb3dOciIsInJvd1RleHQiLCJnZXRUZXh0U3RyaW5nIiwidHJpbSIsIkNlYTYwOENoYW5uZWwiLCJjaGFubmVsTnVtYmVyIiwib3V0cHV0RmlsdGVyIiwiY2hOciIsInZlcmJvc2UiLCJkaXNwbGF5ZWRNZW1vcnkiLCJub25EaXNwbGF5ZWRNZW1vcnkiLCJjdXJyUm9sbFVwUm93Iiwid3JpdGVTY3JlZW4iLCJsYXN0Q3VlRW5kVGltZSIsIm5ld0hhbmRsZXIiLCJzZXRQQUMiLCJzZXRCa2dEYXRhIiwibmV3TW9kZSIsIm91dHB1dERhdGFVcGRhdGUiLCJzZXRNb2RlIiwic2V0Um9sbFVwUm93cyIsInJvbGxVcCIsIm5yQ29scyIsImNvbG9ySW5kZXgiLCJjb2xvcnMiLCJkaXNwYXRjaCIsImRpc3BhdGNoQ3VlIiwiZmllbGQiLCJvdXQxIiwib3V0MiIsIm91dHB1dHMiLCJjaGFubmVscyIsImN1cnJDaE5yIiwibGFzdENtZEEiLCJsYXN0Q21kQiIsImJ1ZmZlcmVkRGF0YSIsImRhdGFDb3VudGVycyIsImdldEhhbmRsZXIiLCJzZXRIYW5kbGVyIiwiYnl0ZUxpc3QiLCJjbWRGb3VuZCIsImNoYXJzRm91bmQiLCJwYWRkaW5nIiwicGFyc2VDbWQiLCJwYXJzZU1pZHJvdyIsInBhcnNlUEFDIiwicGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyIsInBhcnNlQ2hhcnMiLCJjaGFubmVsIiwiaW5zZXJ0Q2hhcnMiLCJjb25kMSIsImNvbmQyIiwiY2NSQ0wiLCJjY0JTIiwiY2NBT0YiLCJjY0FPTiIsImNjREVSIiwiY2NSVSIsImNjRk9OIiwiY2NSREMiLCJjY1RSIiwiY2NSVEQiLCJjY0VETSIsImNjQ1IiLCJjY0VOTSIsImNjRU9DIiwiY2NUTyIsImNjTUlEUk9XIiwiY2FzZTEiLCJjYXNlMiIsImludGVycHJldFBBQyIsInBhY0luZGV4IiwiY2hhbm5lbE5yIiwiY2hhckNvZGVzIiwiY2hhckNvZGUxIiwib25lQ29kZSIsImhleENvZGVzIiwiY3VlU3BsaXRBdFRpbWUiLCJzYW1wbGVFbnRyeUNvZGVzSVNPIiwiaXNDb2RlY1R5cGUiLCJ0eXBlQ29kZXMiLCJpc0NvZGVjU3VwcG9ydGVkSW5NcDQiLCJjYXB0aW9uU2NyZWVuIiwiaW5kZW50aW5nIiwiciIsImxpbmUiLCJhbGlnbiIsImZpbmRGaXJzdEZyYWdXaXRoQ0MiLCJmaW5kRnJhZ1dpdGhDQyIsInNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMiLCJmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWciLCJhZGp1c3RQdHMiLCJhbGlnblN0cmVhbSIsImFsaWduRGlzY29udGludWl0aWVzIiwiYWxpZ25QRFQiLCJmaXJzdEZyYWciLCJjdXJyZW50RnJhZyIsIkNDIiwic2hvdWxkQWxpZ24iLCJwcmV2RGV0YWlscyIsInByZXZGcmFncyIsImN1ckZyYWdzIiwicHJldlN0YXJ0RnJhZyIsInJlZmVyZW5jZUZyYWciLCJsYXN0RGV0YWlscyIsImxhc3RQRFQiLCJuZXdQRFQiLCJzbG93IiwiZmFzdCIsImRlZmF1bHRFc3RpbWF0ZSIsImRlZmF1bHRFc3RpbWF0ZV8iLCJtaW5XZWlnaHRfIiwibWluRGVsYXlNc18iLCJzbG93XyIsIkVXTUEiLCJmYXN0XyIsImR1cmF0aW9uTXMiLCJudW1CeXRlcyIsImJhbmR3aWR0aCIsIndlaWdodCIsImdldFRvdGFsV2VpZ2h0IiwiaGFsZkxpZmUiLCJhbHBoYV8iLCJleHAiLCJlc3RpbWF0ZV8iLCJ0b3RhbFdlaWdodF8iLCJhZGpBbHBoYSIsInplcm9GYWN0b3IiLCJnZXRTZWxmU2NvcGUiLCJub29wIiwiZmFrZUxvZ2dlciIsImV4cG9ydGVkTG9nZ2VyIiwiZm9ybWF0TXNnIiwiY29uc29sZVByaW50Rm4iLCJmdW5jIiwiYXJncyIsImV4cG9ydExvZ2dlckZ1bmN0aW9ucyIsImRlYnVnQ29uZmlnIiwiZnVuY3Rpb25zIiwiZW5hYmxlTG9ncyIsImdldE1lZGlhU291cmNlIiwiV2ViS2l0TWVkaWFTb3VyY2UiLCJhZGRDdWVzIiwiY3JlYXRlQ2FwdGlvbnNUcmFjayIsInNlbmRBZGRUcmFja0V2ZW50IiwiY2xlYXJDdXJyZW50Q3VlcyIsInZpZGVvRWwiLCJkb2N1bWVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsInJlbW92ZUN1ZSIsImF1dG9LZXl3b3JkIiwiZGlyZWN0aW9uU2V0dGluZyIsImxyIiwicmwiLCJhbGlnblNldHRpbmciLCJtaWRkbGUiLCJsZWZ0IiwicmlnaHQiLCJmaW5kRGlyZWN0aW9uU2V0dGluZyIsImRpciIsImZpbmRBbGlnblNldHRpbmciLCJleHRlbmQiLCJvYmoiLCJjb2JqIiwicCIsImlzSUU4IiwiYmFzZU9iaiIsImNyZWF0ZUVsZW1lbnQiLCJlbnVtZXJhYmxlIiwiaGFzQmVlblJlc2V0IiwiX2lkIiwiX3BhdXNlT25FeGl0IiwiX3N0YXJ0VGltZSIsIl9lbmRUaW1lIiwiX3RleHQiLCJfcmVnaW9uIiwiX3ZlcnRpY2FsIiwiX3NuYXBUb0xpbmVzIiwiX2xpbmUiLCJfbGluZUFsaWduIiwiX3Bvc2l0aW9uIiwiX3Bvc2l0aW9uQWxpZ24iLCJfc2l6ZSIsIl9hbGlnbiIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiVHlwZUVycm9yIiwic2V0dGluZyIsIlN5bnRheEVycm9yIiwiZGlzcGxheVN0YXRlIiwiZ2V0Q3VlQXNIVE1MIiwiV2ViVlRUIiwiY29udmVydEN1ZVRvRE9NVHJlZSIsIlN0cmluZ0RlY29kZXIiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJWVFRQYXJzZXIiLCJkZWNvZGVyIiwicmVnaW9uTGlzdCIsInBhcnNlVGltZVN0YW1wIiwiY29tcHV0ZVNlY29uZHMiLCJtIiwicyIsImYiLCJTZXR0aW5ncyIsInZhbHVlcyIsImsiLCJ2IiwiZGZsdCIsImRlZmF1bHRLZXkiLCJoYXMiLCJhbHQiLCJuIiwiaW50ZWdlciIsInBlcmNlbnQiLCJwYXJzZU9wdGlvbnMiLCJrZXlWYWx1ZURlbGltIiwiZ3JvdXBEZWxpbSIsImt2IiwiZGVmYXVsdHMiLCJjZW50ZXIiLCJwYXJzZUN1ZSIsIm9JbnB1dCIsImNvbnN1bWVUaW1lU3RhbXAiLCJ0cyIsImNvbnN1bWVDdWVTZXR0aW5ncyIsInNldHRpbmdzIiwicmVnaW9uIiwidmFscyIsInZhbHMwIiwidmVydGljYWwiLCJsaW5lQWxpZ24iLCJzbmFwVG9MaW5lcyIsInNraXBXaGl0ZXNwYWNlIiwiZml4TGluZUJyZWFrcyIsImNvbGxlY3ROZXh0TGluZSIsImFscmVhZHlDb2xsZWN0ZWRMaW5lIiwiaGFzU3Vic3RyaW5nIiwib25jdWUiLCJmbHVzaCIsIm9uZmx1c2giLCJzdGFydHNXaXRoIiwiaW5wdXRTdHJpbmciLCJzZWFyY2hTdHJpbmciLCJjdWVTdHJpbmcybWlsbGlzIiwidGltZVN0cmluZyIsInNlY3MiLCJtaW5zIiwiaG91cnMiLCJoYXNoIiwiY2FsY3VsYXRlT2Zmc2V0IiwicHJlc2VudGF0aW9uVGltZSIsImN1cnJDQyIsInZ0dEJ5dGVBcnJheSIsInN5bmNQVFMiLCJjYWxsQmFjayIsImVycm9yQ2FsbEJhY2siLCJyZSIsInZ0dExpbmVzIiwiY3VlVGltZSIsIm1wZWdUcyIsImxvY2FsVGltZSIsInBhcnNpbmdFcnJvciIsImluSGVhZGVyIiwicGFyc2VyIiwiY3VlT2Zmc2V0Iiwib25wYXJzaW5nZXJyb3IiLCJyZXF1ZXN0VGltZW91dCIsInJldHJ5VGltZW91dCIsImNhbGxiYWNrcyIsInJldHJ5IiwibG9hZEludGVybmFsIiwic2V0UmVxdWVzdEhlYWRlciIsInJlYWR5c3RhdGVjaGFuZ2UiLCJvbnByb2dyZXNzIiwiY3VycmVudFRhcmdldCIsInJlc3BvbnNlVGV4dCIsInJlc3BvbnNlVVJMIiwibGVuZ3RoQ29tcHV0YWJsZSIsIkhsc0pzUGxheWVyIiwib3B0aW9ucyIsImhsc09wdHMiLCJ1dGlsIiwiUGxheWVyIiwicGxheWVyIiwiYnJvd3NlciIsInV0aWxzIiwiZ2V0QnJvd3NlclZlcnNpb24iLCJ1c2VIbHMiLCJzbmlmZmVyIiwiZGV2aWNlIiwicGxhdGZvcm0iLCJjdXJyZW50U3JjIiwicmVtb3ZlQ2xhc3MiLCJyb290IiwibGl2ZURvbSIsInF1ZXJ5U2VsZWN0b3IiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJyZWdpc3RlciIsIm9uY2UiLCJsb2FkU291cmNlIiwiY29uZmlndXJhYmxlIiwiYXV0b3BsYXkiLCJhZGRDbGFzcyIsImZpbmREb20iLCJjcmVhdGVEb20iLCJjb250cm9scyIsImFwcGVuZENoaWxkIiwiRXZlbnRzIiwiaW5pdGVkIiwiZXJyb3JUeXBlIiwiZXJyb3JGYXRhbCIsInJlY292ZXJNZWRpYUVycm9yIiwiX3N0YXRpc3RpY3MiLCJzdGF0c0luZm8iLCJzcGVlZCIsInBsYXllclR5cGUiLCJtZWRpYWluZm8iLCJ2aWRlb0RhdGFSYXRlIiwiYXVkaW9EYXRhUmF0ZSIsImZsYWciLCJmcHMiLCJhdWRpb0NoYW5uZWxDb3VudCIsIl9zdGF0aXN0aWNzVGltbWVyIiwidmVyc2lvblRyaWRlbnQiXSwibWFwcGluZ3MiOiI7O1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtB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QVFPLGNBQVI7QUFDQSxpQkFBSyxDQUFMO0FBQVE5cEIsMkJBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFiLENBQXFCO0FBQzdCLGlCQUFLLENBQUw7QUFBUUEsMkJBQWEsQ0FBQyxFQUFELEVBQUssRUFBTCxDQUFiLENBQXVCO0FBQy9CLGlCQUFLLENBQUw7QUFBUUEsMkJBQWEsQ0FBQyxFQUFELEVBQUssRUFBTCxDQUFiLENBQXVCO0FBQy9CLGlCQUFLLENBQUw7QUFBUUEsMkJBQWEsQ0FBQyxFQUFELEVBQUssRUFBTCxDQUFiLENBQXVCO0FBQy9CLGlCQUFLLENBQUw7QUFBUUEsMkJBQWEsQ0FBQyxFQUFELEVBQUssRUFBTCxDQUFiLENBQXVCO0FBQy9CLGlCQUFLLENBQUw7QUFBUUEsMkJBQWEsQ0FBQyxFQUFELEVBQUssRUFBTCxDQUFiLENBQXVCO0FBQy9CLGlCQUFLLENBQUw7QUFBUUEsMkJBQWEsQ0FBQyxFQUFELEVBQUssRUFBTCxDQUFiLENBQXVCO0FBQy9CLGlCQUFLLENBQUw7QUFBUUEsMkJBQWEsQ0FBQyxFQUFELEVBQUssRUFBTCxDQUFiLENBQXVCO0FBQy9CLGlCQUFLLENBQUw7QUFBUUEsMkJBQWEsQ0FBQyxFQUFELEVBQUssRUFBTCxDQUFiLENBQXVCO0FBQy9CLGlCQUFLLEVBQUw7QUFBU0EsMkJBQWEsQ0FBQyxFQUFELEVBQUssRUFBTCxDQUFiLENBQXVCO0FBQ2hDLGlCQUFLLEVBQUw7QUFBU0EsMkJBQWEsQ0FBQyxFQUFELEVBQUssRUFBTCxDQUFiLENBQXVCO0FBQ2hDLGlCQUFLLEVBQUw7QUFBU0EsMkJBQWEsQ0FBQyxFQUFELEVBQUssRUFBTCxDQUFiLENBQXVCO0FBQ2hDLGlCQUFLLEVBQUw7QUFBU0EsMkJBQWEsQ0FBQyxHQUFELEVBQU0sRUFBTixDQUFiLENBQXdCO0FBQ2pDLGlCQUFLLEVBQUw7QUFBU0EsMkJBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFiLENBQXFCO0FBQzlCLGlCQUFLLEVBQUw7QUFBU0EsMkJBQWEsQ0FBQyxDQUFELEVBQUksQ0FBSixD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eDlCLFNBQWI7QUFDRDtBQUNGLEdBVk0sTUFVQTtBQUNMLFdBQU8sU0FBUDtBQUNEO0FBQ0YsQ0F6Q0Q7O2tCQTJDZTY2QixJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3Q2YsYUFBYSxtQ0FBbUMsRUFBRSxJIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4iLCIvLyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzE4MDhcblxuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuKGZ1bmN0aW9uKHJvb3QpIHsgXG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4gIHZhciBVUkxfUkVHRVggPSAvXigoPzpbYS16QS1aMC05K1xcLS5dKzopPykoXFwvXFwvW15cXC8/I10qKT8oKD86W15cXC9cXD8jXSpcXC8pKi4qPyk/Pyg7Lio/KT8oXFw/Lio/KT8oIy4qPyk/JC87XG4gIHZhciBGSVJTVF9TRUdNRU5UX1JFR0VYID0gL14oW15cXC8/I10qKSguKikkLztcbiAgdmFyIFNMQVNIX0RPVF9SRUdFWCA9IC8oPzpcXC98XilcXC4oPz1cXC8pL2c7XG4gIHZhciBTTEFTSF9ET1RfRE9UX1JFR0VYID0gLyg/OlxcL3xeKVxcLlxcLlxcLyg/IVxcLlxcLlxcLykuKj8oPz1cXC8pL2c7XG5cbiAgdmFyIFVSTFRvb2xraXQgPSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIC8vIElmIG9wdHMuYWx3YXlzTm9ybWFsaXplIGlzIHRydWUgdGhlbiB0aGUgcGF0aCB3aWxsIGFsd2F5cyBiZSBub3JtYWxpemVkIGV2ZW4gd2hlbiBpdCBzdGFydHMgd2l0aCAvIG9yIC8vXG4gICAgLy8gRS5nXG4gICAgLy8gV2l0aCBvcHRzLmFsd2F5c05vcm1hbGl6ZSA9IGZhbHNlIChkZWZhdWx0LCBzcGVjIGNvbXBsaWFudClcbiAgICAvLyBodHRwOi8vYS5jb20vYi9jZCArIC9lL2YvLi4vZyA9PiBodHRwOi8vYS5jb20vZS9mLy4uL2dcbiAgICAvLyBXaXRoIG9wdHMuYWx3YXlzTm9ybWFsaXplID0gdHJ1ZSAobm90IHNwZWMgY29tcGxpYW50KVxuICAgIC8vIGh0dHA6Ly9hLmNvbS9iL2NkICsgL2UvZi8uLi9nID0+IGh0dHA6Ly9hLmNvbS9lL2dcbiAgICBidWlsZEFic29sdXRlVVJMOiBmdW5jdGlvbihiYXNlVVJMLCByZWxhdGl2ZVVSTCwgb3B0cykge1xuICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAvLyByZW1vdmUgYW55IHJlbWFpbmluZyBzcGFjZSBhbmQgQ1JMRlxuICAgICAgYmFzZVVSTCA9IGJhc2VVUkwudHJpbSgpO1xuICAgICAgcmVsYXRpdmVVUkwgPSByZWxhdGl2ZVVSTC50cmltKCk7XG4gICAgICBpZiAoIXJlbGF0aXZlVVJMKSB7XG4gICAgICAgIC8vIDJhKSBJZiB0aGUgZW1iZWRkZWQgVVJMIGlzIGVudGlyZWx5IGVtcHR5LCBpdCBpbmhlcml0cyB0aGVcbiAgICAgICAgLy8gZW50aXJlIGJhc2UgVVJMIChpLmUuLCBpcyBzZXQgZXF1YWwgdG8gdGhlIGJhc2UgVVJMKVxuICAgICAgICAvLyBhbmQgd2UgYXJlIGRvbmUuXG4gICAgICAgIGlmICghb3B0cy5hbHdheXNOb3JtYWxpemUpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZVVSTDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFzZVBhcnRzRm9yTm9ybWFsaXNlID0gVVJMVG9vbGtpdC5wYXJzZVVSTChiYXNlVVJMKTtcbiAgICAgICAgaWYgKCFiYXNlUGFydHNGb3JOb3JtYWxpc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC4nKTtcbiAgICAgICAgfVxuICAgICAgICBiYXNlUGFydHNGb3JOb3JtYWxpc2UucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChiYXNlUGFydHNGb3JOb3JtYWxpc2UucGF0aCk7XG4gICAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKGJhc2VQYXJ0c0Zvck5vcm1hbGlzZSk7XG4gICAgICB9XG4gICAgICB2YXIgcmVsYXRpdmVQYXJ0cyA9IFVSTFRvb2xraXQucGFyc2VVUkwocmVsYXRpdmVVUkwpO1xuICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIHJlbGF0aXZlIFVSTC4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnNjaGVtZSkge1xuICAgICAgICAvLyAyYikgSWYgdGhlIGVtYmVkZGVkIFVSTCBzdGFydHMgd2l0aCBhIHNjaGVtZSBuYW1lLCBpdCBpc1xuICAgICAgICAvLyBpbnRlcnByZXRlZCBhcyBhbiBhYnNvbHV0ZSBVUkwgYW5kIHdlIGFyZSBkb25lLlxuICAgICAgICBpZiAoIW9wdHMuYWx3YXlzTm9ybWFsaXplKSB7XG4gICAgICAgICAgcmV0dXJuIHJlbGF0aXZlVVJMO1xuICAgICAgICB9XG4gICAgICAgIHJlbGF0aXZlUGFydHMucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChyZWxhdGl2ZVBhcnRzLnBhdGgpO1xuICAgICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhyZWxhdGl2ZVBhcnRzKTtcbiAgICAgIH1cbiAgICAgIHZhciBiYXNlUGFydHMgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xuICAgICAgaWYgKCFiYXNlUGFydHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWJhc2VQYXJ0cy5uZXRMb2MgJiYgYmFzZVBhcnRzLnBhdGggJiYgYmFzZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xuICAgICAgICAvLyBJZiBuZXRMb2MgbWlzc2luZyBhbmQgcGF0aCBkb2Vzbid0IHN0YXJ0IHdpdGggJy8nLCBhc3N1bWUgZXZlcnRoaW5nIGJlZm9yZSB0aGUgZmlyc3QgJy8nIGlzIHRoZSBuZXRMb2NcbiAgICAgICAgLy8gVGhpcyBjYXVzZXMgJ2V4YW1wbGUuY29tL2EnIHRvIGJlIGhhbmRsZWQgYXMgJy8vZXhhbXBsZS5jb20vYScgaW5zdGVhZCBvZiAnL2V4YW1wbGUuY29tL2EnXG4gICAgICAgIHZhciBwYXRoUGFydHMgPSBGSVJTVF9TRUdNRU5UX1JFR0VYLmV4ZWMoYmFzZVBhcnRzLnBhdGgpO1xuICAgICAgICBiYXNlUGFydHMubmV0TG9jID0gcGF0aFBhcnRzWzFdO1xuICAgICAgICBiYXNlUGFydHMucGF0aCA9IHBhdGhQYXJ0c1syXTtcbiAgICAgIH1cbiAgICAgIGlmIChiYXNlUGFydHMubmV0TG9jICYmICFiYXNlUGFydHMucGF0aCkge1xuICAgICAgICBiYXNlUGFydHMucGF0aCA9ICcvJztcbiAgICAgIH1cbiAgICAgIHZhciBidWlsdFBhcnRzID0ge1xuICAgICAgICAvLyAyYykgT3RoZXJ3aXNlLCB0aGUgZW1iZWRkZWQgVVJMIGluaGVyaXRzIHRoZSBzY2hlbWUgb2ZcbiAgICAgICAgLy8gdGhlIGJhc2UgVVJMLlxuICAgICAgICBzY2hlbWU6IGJhc2VQYXJ0cy5zY2hlbWUsXG4gICAgICAgIG5ldExvYzogcmVsYXRpdmVQYXJ0cy5uZXRMb2MsXG4gICAgICAgIHBhdGg6IG51bGwsXG4gICAgICAgIHBhcmFtczogcmVsYXRpdmVQYXJ0cy5wYXJhbXMsXG4gICAgICAgIHF1ZXJ5OiByZWxhdGl2ZVBhcnRzLnF1ZXJ5LFxuICAgICAgICBmcmFnbWVudDogcmVsYXRpdmVQYXJ0cy5mcmFnbWVudFxuICAgICAgfTtcbiAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5uZXRMb2MpIHtcbiAgICAgICAgLy8gMykgSWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxuZXRfbG9jPiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cbiAgICAgICAgLy8gU3RlcCA3LiAgT3RoZXJ3aXNlLCB0aGUgZW1iZWRkZWQgVVJMIGluaGVyaXRzIHRoZSA8bmV0X2xvYz5cbiAgICAgICAgLy8gKGlmIGFueSkgb2YgdGhlIGJhc2UgVVJMLlxuICAgICAgICBidWlsdFBhcnRzLm5ldExvYyA9IGJhc2VQYXJ0cy5uZXRMb2M7XG4gICAgICAgIC8vIDQpIElmIHRoZSBlbWJlZGRlZCBVUkwgcGF0aCBpcyBwcmVjZWRlZCBieSBhIHNsYXNoIFwiL1wiLCB0aGVcbiAgICAgICAgLy8gcGF0aCBpcyBub3QgcmVsYXRpdmUgYW5kIHdlIHNraXAgdG8gU3RlcCA3LlxuICAgICAgICBpZiAocmVsYXRpdmVQYXJ0cy5wYXRoWzBdICE9PSAnLycpIHtcbiAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucGF0aCkge1xuICAgICAgICAgICAgLy8gNSkgSWYgdGhlIGVtYmVkZGVkIFVSTCBwYXRoIGlzIGVtcHR5IChhbmQgbm90IHByZWNlZGVkIGJ5IGFcbiAgICAgICAgICAgIC8vIHNsYXNoKSwgdGhlbiB0aGUgZW1iZWRkZWQgVVJMIGluaGVyaXRzIHRoZSBiYXNlIFVSTCBwYXRoXG4gICAgICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBiYXNlUGFydHMucGF0aDtcbiAgICAgICAgICAgIC8vIDVhKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHBhcmFtcz4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG4gICAgICAgICAgICAvLyBzdGVwIDc7IG90aGVyd2lzZSwgaXQgaW5oZXJpdHMgdGhlIDxwYXJhbXM+IG9mIHRoZSBiYXNlXG4gICAgICAgICAgICAvLyBVUkwgKGlmIGFueSkgYW5kXG4gICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucGFyYW1zKSB7XG4gICAgICAgICAgICAgIGJ1aWx0UGFydHMucGFyYW1zID0gYmFzZVBhcnRzLnBhcmFtcztcbiAgICAgICAgICAgICAgLy8gNWIpIGlmIHRoZSBlbWJlZGRlZCBVUkwncyA8cXVlcnk+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuICAgICAgICAgICAgICAvLyBzdGVwIDc7IG90aGVyd2lzZSwgaXQgaW5oZXJpdHMgdGhlIDxxdWVyeT4gb2YgdGhlIGJhc2VcbiAgICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZCB3ZSBza2lwIHRvIHN0ZXAgNy5cbiAgICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5xdWVyeSA9IGJhc2VQYXJ0cy5xdWVyeTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyA2KSBUaGUgbGFzdCBzZWdtZW50IG9mIHRoZSBiYXNlIFVSTCdzIHBhdGggKGFueXRoaW5nXG4gICAgICAgICAgICAvLyBmb2xsb3dpbmcgdGhlIHJpZ2h0bW9zdCBzbGFzaCBcIi9cIiwgb3IgdGhlIGVudGlyZSBwYXRoIGlmIG5vXG4gICAgICAgICAgICAvLyBzbGFzaCBpcyBwcmVzZW50KSBpcyByZW1vdmVkIGFuZCB0aGUgZW1iZWRkZWQgVVJMJ3MgcGF0aCBpc1xuICAgICAgICAgICAgLy8gYXBwZW5kZWQgaW4gaXRzIHBsYWNlLlxuICAgICAgICAgICAgdmFyIGJhc2VVUkxQYXRoID0gYmFzZVBhcnRzLnBhdGg7XG4gICAgICAgICAgICB2YXIgbmV3UGF0aCA9IGJhc2VVUkxQYXRoLnN1YnN0cmluZygwLCBiYXNlVVJMUGF0aC5sYXN0SW5kZXhPZignLycpICsgMSkgKyByZWxhdGl2ZVBhcnRzLnBhdGg7XG4gICAgICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgobmV3UGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYnVpbHRQYXJ0cy5wYXRoID09PSBudWxsKSB7XG4gICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IG9wdHMuYWx3YXlzTm9ybWFsaXplID8gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKHJlbGF0aXZlUGFydHMucGF0aCkgOiByZWxhdGl2ZVBhcnRzLnBhdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhidWlsdFBhcnRzKTtcbiAgICB9LFxuICAgIHBhcnNlVVJMOiBmdW5jdGlvbih1cmwpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFVSTF9SRUdFWC5leGVjKHVybCk7XG4gICAgICBpZiAoIXBhcnRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NoZW1lOiBwYXJ0c1sxXSB8fCAnJyxcbiAgICAgICAgbmV0TG9jOiBwYXJ0c1syXSB8fCAnJyxcbiAgICAgICAgcGF0aDogcGFydHNbM10gfHwgJycsXG4gICAgICAgIHBhcmFtczogcGFydHNbNF0gfHwgJycsXG4gICAgICAgIHF1ZXJ5OiBwYXJ0c1s1XSB8fCAnJyxcbiAgICAgICAgZnJhZ21lbnQ6IHBhcnRzWzZdIHx8ICcnXG4gICAgICB9O1xuICAgIH0sXG4gICAgbm9ybWFsaXplUGF0aDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgLy8gVGhlIGZvbGxvd2luZyBvcGVyYXRpb25zIGFyZVxuICAgICAgLy8gdGhlbiBhcHBsaWVkLCBpbiBvcmRlciwgdG8gdGhlIG5ldyBwYXRoOlxuICAgICAgLy8gNmEpIEFsbCBvY2N1cnJlbmNlcyBvZiBcIi4vXCIsIHdoZXJlIFwiLlwiIGlzIGEgY29tcGxldGUgcGF0aFxuICAgICAgLy8gc2VnbWVudCwgYXJlIHJlbW92ZWQuXG4gICAgICAvLyA2YikgSWYgdGhlIHBhdGggZW5kcyB3aXRoIFwiLlwiIGFzIGEgY29tcGxldGUgcGF0aCBzZWdtZW50LFxuICAgICAgLy8gdGhhdCBcIi5cIiBpcyByZW1vdmVkLlxuICAgICAgcGF0aCA9IHBhdGguc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKS5yZXBsYWNlKFNMQVNIX0RPVF9SRUdFWCwgJycpO1xuICAgICAgLy8gNmMpIEFsbCBvY2N1cnJlbmNlcyBvZiBcIjxzZWdtZW50Pi8uLi9cIiwgd2hlcmUgPHNlZ21lbnQ+IGlzIGFcbiAgICAgIC8vIGNvbXBsZXRlIHBhdGggc2VnbWVudCBub3QgZXF1YWwgdG8gXCIuLlwiLCBhcmUgcmVtb3ZlZC5cbiAgICAgIC8vIFJlbW92YWwgb2YgdGhlc2UgcGF0aCBzZWdtZW50cyBpcyBwZXJmb3JtZWQgaXRlcmF0aXZlbHksXG4gICAgICAvLyByZW1vdmluZyB0aGUgbGVmdG1vc3QgbWF0Y2hpbmcgcGF0dGVybiBvbiBlYWNoIGl0ZXJhdGlvbixcbiAgICAgIC8vIHVudGlsIG5vIG1hdGNoaW5nIHBhdHRlcm4gcmVtYWlucy5cbiAgICAgIC8vIDZkKSBJZiB0aGUgcGF0aCBlbmRzIHdpdGggXCI8c2VnbWVudD4vLi5cIiwgd2hlcmUgPHNlZ21lbnQ+IGlzIGFcbiAgICAgIC8vIGNvbXBsZXRlIHBhdGggc2VnbWVudCBub3QgZXF1YWwgdG8gXCIuLlwiLCB0aGF0XG4gICAgICAvLyBcIjxzZWdtZW50Pi8uLlwiIGlzIHJlbW92ZWQuXG4gICAgICB3aGlsZSAocGF0aC5sZW5ndGggIT09IChwYXRoID0gcGF0aC5yZXBsYWNlKFNMQVNIX0RPVF9ET1RfUkVHRVgsICcnKSkubGVuZ3RoKSB7fSAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgIHJldHVybiBwYXRoLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7XG4gICAgfSxcbiAgICBidWlsZFVSTEZyb21QYXJ0czogZnVuY3Rpb24ocGFydHMpIHtcbiAgICAgIHJldHVybiBwYXJ0cy5zY2hlbWUgKyBwYXJ0cy5uZXRMb2MgKyBwYXJ0cy5wYXRoICsgcGFydHMucGFyYW1zICsgcGFydHMucXVlcnkgKyBwYXJ0cy5mcmFnbWVudDtcbiAgICB9XG4gIH07XG5cbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuICAgIG1vZHVsZS5leHBvcnRzID0gVVJMVG9vbGtpdDtcbiAgZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIFVSTFRvb2xraXQ7IH0pO1xuICBlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JylcbiAgICBleHBvcnRzW1wiVVJMVG9vbGtpdFwiXSA9IFVSTFRvb2xraXQ7XG4gIGVsc2VcbiAgICByb290W1wiVVJMVG9vbGtpdFwiXSA9IFVSTFRvb2xraXQ7XG59KSh0aGlzKTtcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG4iLCJmdW5jdGlvbiB3ZWJwYWNrQm9vdHN0cmFwRnVuYyAobW9kdWxlcykge1xuLyoqKioqKi8gIC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovICB2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyAgLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovICBmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovICAgIC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gICAgaWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyAgICAgIHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyAgICAvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gICAgdmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gICAgICBpOiBtb2R1bGVJZCxcbi8qKioqKiovICAgICAgbDogZmFsc2UsXG4vKioqKioqLyAgICAgIGV4cG9ydHM6IHt9XG4vKioqKioqLyAgICB9O1xuXG4vKioqKioqLyAgICAvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovICAgIG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyAgICAvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyAgICBtb2R1bGUubCA9IHRydWU7XG5cbi8qKioqKiovICAgIC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyAgfVxuXG4vKioqKioqLyAgLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyAgLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyAgLy8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuLyoqKioqKi8gIC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gICAgaWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovICAgICAgICBnZXQ6IGdldHRlclxuLyoqKioqKi8gICAgICB9KTtcbi8qKioqKiovICAgIH1cbi8qKioqKiovICB9O1xuXG4vKioqKioqLyAgLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyAgfTtcblxuLyoqKioqKi8gIC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyAgICB2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovICAgICAgZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovICAgICAgZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovICAgIF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovICAgIHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyAgfTtcblxuLyoqKioqKi8gIC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuLyoqKioqKi8gIC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvXCI7XG5cbi8qKioqKiovICAvLyBvbiBlcnJvciBmdW5jdGlvbiBmb3IgYXN5bmMgbG9hZGluZ1xuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ub2UgPSBmdW5jdGlvbihlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB0aHJvdyBlcnI7IH07XG5cbiAgdmFyIGYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IEVOVFJZX01PRFVMRSlcbiAgcmV0dXJuIGYuZGVmYXVsdCB8fCBmIC8vIHRyeSB0byBjYWxsIGRlZmF1bHQgaWYgZGVmaW5lZCB0byBhbHNvIHN1cHBvcnQgYmFiZWwgZXNtb2R1bGUgZXhwb3J0c1xufVxuXG52YXIgbW9kdWxlTmFtZVJlcUV4cCA9ICdbXFxcXC58XFxcXC18XFxcXCt8XFxcXHd8XFwvfEBdKydcbnZhciBkZXBlbmRlbmN5UmVnRXhwID0gJ1xcXFwoXFxcXHMqKFxcL1xcXFwqLio/XFxcXCpcXC8pP1xcXFxzKi4qPygnICsgbW9kdWxlTmFtZVJlcUV4cCArICcpLio/XFxcXCknIC8vIGFkZGl0aW9uYWwgY2hhcnMgd2hlbiBvdXRwdXQucGF0aGluZm8gaXMgdHJ1ZVxuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNTkzNjYxLzEzMDQ0MlxuZnVuY3Rpb24gcXVvdGVSZWdFeHAgKHN0cikge1xuICByZXR1cm4gKHN0ciArICcnKS5yZXBsYWNlKC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2csICdcXFxcJCYnKVxufVxuXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gIWlzTmFOKDEgKiBuKTsgLy8gMSAqIG4gY29udmVydHMgaW50ZWdlcnMsIGludGVnZXJzIGFzIHN0cmluZyAoXCIxMjNcIiksIDFlMyBhbmQgXCIxZTNcIiB0byBpbnRlZ2VycyBhbmQgc3RyaW5ncyB0byBOYU5cbn1cblxuZnVuY3Rpb24gZ2V0TW9kdWxlRGVwZW5kZW5jaWVzIChzb3VyY2VzLCBtb2R1bGUsIHF1ZXVlTmFtZSkge1xuICB2YXIgcmV0dmFsID0ge31cbiAgcmV0dmFsW3F1ZXVlTmFtZV0gPSBbXVxuXG4gIHZhciBmblN0cmluZyA9IG1vZHVsZS50b1N0cmluZygpXG4gIHZhciB3cmFwcGVyU2lnbmF0dXJlID0gZm5TdHJpbmcubWF0Y2goL15mdW5jdGlvblxccz9cXHcqXFwoXFx3KyxcXHMqXFx3KyxcXHMqKFxcdyspXFwpLylcbiAgaWYgKCF3cmFwcGVyU2lnbmF0dXJlKSByZXR1cm4gcmV0dmFsXG4gIHZhciB3ZWJwYWNrUmVxdWlyZU5hbWUgPSB3cmFwcGVyU2lnbmF0dXJlWzFdXG5cbiAgLy8gbWFpbiBidW5kbGUgZGVwc1xuICB2YXIgcmUgPSBuZXcgUmVnRXhwKCcoXFxcXFxcXFxufFxcXFxXKScgKyBxdW90ZVJlZ0V4cCh3ZWJwYWNrUmVxdWlyZU5hbWUpICsgZGVwZW5kZW5jeVJlZ0V4cCwgJ2cnKVxuICB2YXIgbWF0Y2hcbiAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoZm5TdHJpbmcpKSkge1xuICAgIGlmIChtYXRjaFszXSA9PT0gJ2RsbC1yZWZlcmVuY2UnKSBjb250aW51ZVxuICAgIHJldHZhbFtxdWV1ZU5hbWVdLnB1c2gobWF0Y2hbM10pXG4gIH1cblxuICAvLyBkbGwgZGVwc1xuICByZSA9IG5ldyBSZWdFeHAoJ1xcXFwoJyArIHF1b3RlUmVnRXhwKHdlYnBhY2tSZXF1aXJlTmFtZSkgKyAnXFxcXChcIihkbGwtcmVmZXJlbmNlXFxcXHMoJyArIG1vZHVsZU5hbWVSZXFFeHAgKyAnKSlcIlxcXFwpXFxcXCknICsgZGVwZW5kZW5jeVJlZ0V4cCwgJ2cnKVxuICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhmblN0cmluZykpKSB7XG4gICAgaWYgKCFzb3VyY2VzW21hdGNoWzJdXSkge1xuICAgICAgcmV0dmFsW3F1ZXVlTmFtZV0ucHVzaChtYXRjaFsxXSlcbiAgICAgIHNvdXJjZXNbbWF0Y2hbMl1dID0gX193ZWJwYWNrX3JlcXVpcmVfXyhtYXRjaFsxXSkubVxuICAgIH1cbiAgICByZXR2YWxbbWF0Y2hbMl1dID0gcmV0dmFsW21hdGNoWzJdXSB8fCBbXVxuICAgIHJldHZhbFttYXRjaFsyXV0ucHVzaChtYXRjaFs0XSlcbiAgfVxuXG4gIC8vIGNvbnZlcnQgMWUzIGJhY2sgdG8gMTAwMCAtIHRoaXMgY2FuIGJlIGltcG9ydGFudCBhZnRlciB1Z2xpZnktanMgY29udmVydGVkIDEwMDAgdG8gMWUzXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmV0dmFsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXR2YWxba2V5c1tpXV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChpc051bWVyaWMocmV0dmFsW2tleXNbaV1dW2pdKSkge1xuICAgICAgICByZXR2YWxba2V5c1tpXV1bal0gPSAxICogcmV0dmFsW2tleXNbaV1dW2pdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXR2YWxcbn1cblxuZnVuY3Rpb24gaGFzVmFsdWVzSW5RdWV1ZXMgKHF1ZXVlcykge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHF1ZXVlcylcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChoYXNWYWx1ZXMsIGtleSkge1xuICAgIHJldHVybiBoYXNWYWx1ZXMgfHwgcXVldWVzW2tleV0ubGVuZ3RoID4gMFxuICB9LCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gZ2V0UmVxdWlyZWRNb2R1bGVzIChzb3VyY2VzLCBtb2R1bGVJZCkge1xuICB2YXIgbW9kdWxlc1F1ZXVlID0ge1xuICAgIG1haW46IFttb2R1bGVJZF1cbiAgfVxuICB2YXIgcmVxdWlyZWRNb2R1bGVzID0ge1xuICAgIG1haW46IFtdXG4gIH1cbiAgdmFyIHNlZW5Nb2R1bGVzID0ge1xuICAgIG1haW46IHt9XG4gIH1cblxuICB3aGlsZSAoaGFzVmFsdWVzSW5RdWV1ZXMobW9kdWxlc1F1ZXVlKSkge1xuICAgIHZhciBxdWV1ZXMgPSBPYmplY3Qua2V5cyhtb2R1bGVzUXVldWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBxdWV1ZU5hbWUgPSBxdWV1ZXNbaV1cbiAgICAgIHZhciBxdWV1ZSA9IG1vZHVsZXNRdWV1ZVtxdWV1ZU5hbWVdXG4gICAgICB2YXIgbW9kdWxlVG9DaGVjayA9IHF1ZXVlLnBvcCgpXG4gICAgICBzZWVuTW9kdWxlc1txdWV1ZU5hbWVdID0gc2Vlbk1vZHVsZXNbcXVldWVOYW1lXSB8fCB7fVxuICAgICAgaWYgKHNlZW5Nb2R1bGVzW3F1ZXVlTmFtZV1bbW9kdWxlVG9DaGVja10gfHwgIXNvdXJjZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSkgY29udGludWVcbiAgICAgIHNlZW5Nb2R1bGVzW3F1ZXVlTmFtZV1bbW9kdWxlVG9DaGVja10gPSB0cnVlXG4gICAgICByZXF1aXJlZE1vZHVsZXNbcXVldWVOYW1lXSA9IHJlcXVpcmVkTW9kdWxlc1txdWV1ZU5hbWVdIHx8IFtdXG4gICAgICByZXF1aXJlZE1vZHVsZXNbcXVldWVOYW1lXS5wdXNoKG1vZHVsZVRvQ2hlY2spXG4gICAgICB2YXIgbmV3TW9kdWxlcyA9IGdldE1vZHVsZURlcGVuZGVuY2llcyhzb3VyY2VzLCBzb3VyY2VzW3F1ZXVlTmFtZV1bbW9kdWxlVG9DaGVja10sIHF1ZXVlTmFtZSlcbiAgICAgIHZhciBuZXdNb2R1bGVzS2V5cyA9IE9iamVjdC5rZXlzKG5ld01vZHVsZXMpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5ld01vZHVsZXNLZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0gPSBtb2R1bGVzUXVldWVbbmV3TW9kdWxlc0tleXNbal1dIHx8IFtdXG4gICAgICAgIG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0gPSBtb2R1bGVzUXVldWVbbmV3TW9kdWxlc0tleXNbal1dLmNvbmNhdChuZXdNb2R1bGVzW25ld01vZHVsZXNLZXlzW2pdXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZWRNb2R1bGVzXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1vZHVsZUlkLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBzb3VyY2VzID0ge1xuICAgIG1haW46IF9fd2VicGFja19tb2R1bGVzX19cbiAgfVxuXG4gIHZhciByZXF1aXJlZE1vZHVsZXMgPSBvcHRpb25zLmFsbCA/IHsgbWFpbjogT2JqZWN0LmtleXMoc291cmNlcy5tYWluKSB9IDogZ2V0UmVxdWlyZWRNb2R1bGVzKHNvdXJjZXMsIG1vZHVsZUlkKVxuXG4gIHZhciBzcmMgPSAnJ1xuXG4gIE9iamVjdC5rZXlzKHJlcXVpcmVkTW9kdWxlcykuZmlsdGVyKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtICE9PSAnbWFpbicgfSkuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgdmFyIGVudHJ5TW9kdWxlID0gMFxuICAgIHdoaWxlIChyZXF1aXJlZE1vZHVsZXNbbW9kdWxlXVtlbnRyeU1vZHVsZV0pIHtcbiAgICAgIGVudHJ5TW9kdWxlKytcbiAgICB9XG4gICAgcmVxdWlyZWRNb2R1bGVzW21vZHVsZV0ucHVzaChlbnRyeU1vZHVsZSlcbiAgICBzb3VyY2VzW21vZHVsZV1bZW50cnlNb2R1bGVdID0gJyhmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fOyB9KSdcbiAgICBzcmMgPSBzcmMgKyAndmFyICcgKyBtb2R1bGUgKyAnID0gKCcgKyB3ZWJwYWNrQm9vdHN0cmFwRnVuYy50b1N0cmluZygpLnJlcGxhY2UoJ0VOVFJZX01PRFVMRScsIEpTT04uc3RyaW5naWZ5KGVudHJ5TW9kdWxlKSkgKyAnKSh7JyArIHJlcXVpcmVkTW9kdWxlc1ttb2R1bGVdLm1hcChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuICcnICsgSlNPTi5zdHJpbmdpZnkoaWQpICsgJzogJyArIHNvdXJjZXNbbW9kdWxlXVtpZF0udG9TdHJpbmcoKSB9KS5qb2luKCcsJykgKyAnfSk7XFxuJ1xuICB9KVxuXG4gIHNyYyA9IHNyYyArICduZXcgKCgnICsgd2VicGFja0Jvb3RzdHJhcEZ1bmMudG9TdHJpbmcoKS5yZXBsYWNlKCdFTlRSWV9NT0RVTEUnLCBKU09OLnN0cmluZ2lmeShtb2R1bGVJZCkpICsgJykoeycgKyByZXF1aXJlZE1vZHVsZXMubWFpbi5tYXAoZnVuY3Rpb24gKGlkKSB7IHJldHVybiAnJyArIEpTT04uc3RyaW5naWZ5KGlkKSArICc6ICcgKyBzb3VyY2VzLm1haW5baWRdLnRvU3RyaW5nKCkgfSkuam9pbignLCcpICsgJ30pKShzZWxmKTsnXG5cbiAgdmFyIGJsb2IgPSBuZXcgd2luZG93LkJsb2IoW3NyY10sIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSlcbiAgaWYgKG9wdGlvbnMuYmFyZSkgeyByZXR1cm4gYmxvYiB9XG5cbiAgdmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCB8fCB3aW5kb3cubW96VVJMIHx8IHdpbmRvdy5tc1VSTFxuXG4gIHZhciB3b3JrZXJVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gIHZhciB3b3JrZXIgPSBuZXcgd2luZG93Lldvcmtlcih3b3JrZXJVcmwpXG4gIHdvcmtlci5vYmplY3RVUkwgPSB3b3JrZXJVcmxcblxuICByZXR1cm4gd29ya2VyXG59XG4iLCIvKipcbiAqIEhMUyBjb25maWdcbiAqL1xuXG5pbXBvcnQgQWJyQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXInO1xuaW1wb3J0IEJ1ZmZlckNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyJztcbmltcG9ydCBDYXBMZXZlbENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyJztcbmltcG9ydCBGUFNDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9mcHMtY29udHJvbGxlcic7XG5pbXBvcnQgWGhyTG9hZGVyIGZyb20gJy4vdXRpbHMveGhyLWxvYWRlcic7XG4vLyBpbXBvcnQgRmV0Y2hMb2FkZXIgZnJvbSAnLi91dGlscy9mZXRjaC1sb2FkZXInO1xuXG5pbXBvcnQgQXVkaW9UcmFja0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXInO1xuaW1wb3J0IEF1ZGlvU3RyZWFtQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXInO1xuXG5pbXBvcnQgKiBhcyBDdWVzIGZyb20gJy4vdXRpbHMvY3Vlcyc7XG5pbXBvcnQgVGltZWxpbmVDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyJztcbmltcG9ydCBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlcic7XG5pbXBvcnQgeyBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIgfSBmcm9tICcuL2NvbnRyb2xsZXIvc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXInO1xuaW1wb3J0IEVNRUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyJztcblxuaW1wb3J0IHsgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIH0gZnJvbSAnLi91dGlscy9tZWRpYWtleXMtaGVscGVyJztcblxuZXhwb3J0IHZhciBobHNEZWZhdWx0Q29uZmlnID0ge1xuICBhdXRvU3RhcnRMb2FkOiB0cnVlLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIHN0YXJ0UG9zaXRpb246IC0xLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGRlZmF1bHRBdWRpb0NvZGVjOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZGVidWc6IGZhbHNlLCAvLyB1c2VkIGJ5IGxvZ2dlclxuICBjYXBMZXZlbE9uRlBTRHJvcDogZmFsc2UsIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgY2FwTGV2ZWxUb1BsYXllclNpemU6IGZhbHNlLCAvLyB1c2VkIGJ5IGNhcC1sZXZlbC1jb250cm9sbGVyXG4gIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplOiAxLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEJ1ZmZlckxlbmd0aDogMzAsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4QnVmZmVyU2l6ZTogNjAgKiAxMDAwICogMTAwMCwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhCdWZmZXJIb2xlOiAwLjUsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcblxuICBsb3dCdWZmZXJXYXRjaGRvZ1BlcmlvZDogMC41LCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZDogMywgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBudWRnZU9mZnNldDogMC4xLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG51ZGdlTWF4UmV0cnk6IDMsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTogMC4yNSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBsaXZlU3luY0R1cmF0aW9uQ291bnQ6IDMsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50OiBJbmZpbml0eSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBsaXZlU3luY0R1cmF0aW9uOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbjogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGxpdmVEdXJhdGlvbkluZmluaXR5OiBmYWxzZSwgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICBsaXZlQmFja0J1ZmZlckxlbmd0aDogSW5maW5pdHksIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgbWF4TWF4QnVmZmVyTGVuZ3RoOiA2MDAsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZW5hYmxlV29ya2VyOiB0cnVlLCAvLyB1c2VkIGJ5IGRlbXV4ZXJcbiAgZW5hYmxlU29mdHdhcmVBRVM6IHRydWUsIC8vIHVzZWQgYnkgZGVjcnlwdGVyXG4gIG1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ6IDEwMDAwLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeTogMSwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgbWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTogMTAwMCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgc3RhcnRMZXZlbDogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IGxldmVsLWNvbnRyb2xsZXJcbiAgbGV2ZWxMb2FkaW5nVGltZU91dDogMTAwMDAsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIGxldmVsTG9hZGluZ01heFJldHJ5OiA0LCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBsZXZlbExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBsZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBmcmFnTG9hZGluZ1RpbWVPdXQ6IDIwMDAwLCAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBmcmFnTG9hZGluZ01heFJldHJ5OiA2LCAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBmcmFnTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gIGZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCwgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgc3RhcnRGcmFnUHJlZmV0Y2g6IGZhbHNlLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kOiA1MDAwLCAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkOiAwLjIsIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgYXBwZW5kRXJyb3JNYXhSZXRyeTogMywgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICBsb2FkZXI6IFhockxvYWRlcixcbiAgLy8gbG9hZGVyOiBGZXRjaExvYWRlcixcbiAgZkxvYWRlcjogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBwTG9hZGVyOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIHhoclNldHVwOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgeGhyLWxvYWRlclxuICBsaWNlbnNlWGhyU2V0dXA6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICAvLyBmZXRjaFNldHVwOiB1bmRlZmluZWQsXG4gIGFickNvbnRyb2xsZXI6IEFickNvbnRyb2xsZXIsXG4gIGJ1ZmZlckNvbnRyb2xsZXI6IEJ1ZmZlckNvbnRyb2xsZXIsXG4gIGNhcExldmVsQ29udHJvbGxlcjogQ2FwTGV2ZWxDb250cm9sbGVyLFxuICBmcHNDb250cm9sbGVyOiBGUFNDb250cm9sbGVyLFxuICBzdHJldGNoU2hvcnRWaWRlb1RyYWNrOiBmYWxzZSwgLy8gdXNlZCBieSBtcDQtcmVtdXhlclxuICBtYXhBdWRpb0ZyYW1lc0RyaWZ0OiAxLCAvLyB1c2VkIGJ5IG1wNC1yZW11eGVyXG4gIGZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHk6IHRydWUsIC8vIHVzZWQgYnkgdHMtZGVtdXhlclxuICBhYnJFd21hRmFzdExpdmU6IDMsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYVNsb3dMaXZlOiA5LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFGYXN0Vm9EOiAzLCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFTbG93Vm9EOiA5LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFEZWZhdWx0RXN0aW1hdGU6IDVlNSwgLy8gNTAwIGticHMgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyQmFuZFdpZHRoRmFjdG9yOiAwLjk1LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickJhbmRXaWR0aFVwRmFjdG9yOiAwLjcsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyTWF4V2l0aFJlYWxCaXRyYXRlOiBmYWxzZSwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBtYXhTdGFydmF0aW9uRGVsYXk6IDQsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgbWF4TG9hZGluZ0RlbGF5OiA0LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIG1pbkF1dG9CaXRyYXRlOiAwLCAvLyB1c2VkIGJ5IGhsc1xuICBlbWVFbmFibGVkOiBmYWxzZSwgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICB3aWRldmluZUxpY2Vuc2VVcmw6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jOlxuICAgICAgICAgICAgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbn07XG5cblxuICBobHNEZWZhdWx0Q29uZmlnLnN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciA9IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjtcbiAgaGxzRGVmYXVsdENvbmZpZy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICBobHNEZWZhdWx0Q29uZmlnLnRpbWVsaW5lQ29udHJvbGxlciA9IFRpbWVsaW5lQ29udHJvbGxlcjtcbiAgaGxzRGVmYXVsdENvbmZpZy5jdWVIYW5kbGVyID0gQ3VlczsgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gIGhsc0RlZmF1bHRDb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMgPSB0cnVlOyAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgaGxzRGVmYXVsdENvbmZpZy5lbmFibGVXZWJWVFQgPSB0cnVlOyAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgaGxzRGVmYXVsdENvbmZpZy5jYXB0aW9uc1RleHRUcmFjazFMYWJlbCA9ICdFbmdsaXNoJzsgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gIGhsc0RlZmF1bHRDb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlID0gJ2VuJzsgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gIGhsc0RlZmF1bHRDb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFiZWwgPSAnU3BhbmlzaCc7IC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICBobHNEZWZhdWx0Q29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhbmd1YWdlQ29kZSA9ICdlcyc7IC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuXG5cbiAgaGxzRGVmYXVsdENvbmZpZy5hdWRpb1N0cmVhbUNvbnRyb2xsZXIgPSBBdWRpb1N0cmVhbUNvbnRyb2xsZXI7XG4gIGhsc0RlZmF1bHRDb25maWcuYXVkaW9UcmFja0NvbnRyb2xsZXIgPSBBdWRpb1RyYWNrQ29udHJvbGxlcjtcblxuXG4gIGhsc0RlZmF1bHRDb25maWcuZW1lQ29udHJvbGxlciA9IEVNRUNvbnRyb2xsZXI7XG5cbiIsIi8qXG4gKiBzaW1wbGUgQUJSIENvbnRyb2xsZXJcbiAqICAtIGNvbXB1dGUgbmV4dCBsZXZlbCBiYXNlZCBvbiBsYXN0IGZyYWdtZW50IGJ3IGhldXJpc3RpY3NcbiAqICAtIGltcGxlbWVudCBhbiBhYmFuZG9uIHJ1bGVzIHRyaWdnZXJlZCBpZiB3ZSBoYXZlIGxlc3MgdGhhbiAyIGZyYWcgYnVmZmVyZWQgYW5kIGlmIGNvbXB1dGVkIGJ3IHNob3dzIHRoYXQgd2UgcmlzayBidWZmZXIgc3RhbGxpbmdcbiAqL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgeyBCdWZmZXJIZWxwZXIgfSBmcm9tICcuLi91dGlscy9idWZmZXItaGVscGVyJztcbmltcG9ydCB7IEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IgZnJvbSAnLi4vdXRpbHMvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yJztcblxuY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gd2luZG93O1xuXG5jbGFzcyBBYnJDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuRlJBR19MT0FESU5HLFxuICAgICAgRXZlbnQuRlJBR19MT0FERUQsXG4gICAgICBFdmVudC5GUkFHX0JVRkZFUkVELFxuICAgICAgRXZlbnQuRVJST1IpO1xuICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IDA7XG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2J3RXN0aW1hdG9yID0gbnVsbDtcbiAgICB0aGlzLm9uQ2hlY2sgPSB0aGlzLl9hYmFuZG9uUnVsZXNDaGVjay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbkZyYWdMb2FkaW5nIChkYXRhKSB7XG4gICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICBpZiAoZnJhZy50eXBlID09PSAnbWFpbicpIHtcbiAgICAgIGlmICghdGhpcy50aW1lcikge1xuICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMub25DaGVjaywgMTAwKTtcbiAgICAgIH1cblxuICAgICAgLy8gbGF6eSBpbml0IG9mIEJ3RXN0aW1hdG9yLCByYXRpb25hbGUgaXMgdGhhdCB3ZSB1c2UgZGlmZmVyZW50IHBhcmFtcyBmb3IgTGl2ZS9Wb0RcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gd2FpdCBmb3Igc3RyZWFtIG1hbmlmZXN0IC8gcGxheWxpc3QgdHlwZSB0byBpbnN0YW50aWF0ZSBpdC5cbiAgICAgIGlmICghdGhpcy5fYndFc3RpbWF0b3IpIHtcbiAgICAgICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgICAgIGNvbnN0IGxldmVsID0gZnJhZy5sZXZlbHM7XG4gICAgICAgIGNvbnN0IGlzTGl2ZSA9IGhscy5sZXZlbHNbbGV2ZWxdLmRldGFpbHMubGl2ZTtcblxuICAgICAgICBsZXQgZXdtYUZhc3QsIGV3bWFTbG93O1xuICAgICAgICBpZiAoaXNMaXZlKSB7XG4gICAgICAgICAgZXdtYUZhc3QgPSBjb25maWcuYWJyRXdtYUZhc3RMaXZlO1xuICAgICAgICAgIGV3bWFTbG93ID0gY29uZmlnLmFickV3bWFTbG93TGl2ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBld21hRmFzdCA9IGNvbmZpZy5hYnJFd21hRmFzdFZvRDtcbiAgICAgICAgICBld21hU2xvdyA9IGNvbmZpZy5hYnJFd21hU2xvd1ZvRDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9id0VzdGltYXRvciA9IG5ldyBFd21hQmFuZFdpZHRoRXN0aW1hdG9yKGhscywgZXdtYVNsb3csIGV3bWFGYXN0LCBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2FiYW5kb25SdWxlc0NoZWNrICgpIHtcbiAgICAvKlxuICAgICAgbW9uaXRvciBmcmFnbWVudCByZXRyaWV2YWwgdGltZS4uLlxuICAgICAgd2UgY29tcHV0ZSBleHBlY3RlZCB0aW1lIG9mIGFycml2YWwgb2YgdGhlIGNvbXBsZXRlIGZyYWdtZW50LlxuICAgICAgd2UgY29tcGFyZSBpdCB0byBleHBlY3RlZCB0aW1lIG9mIGJ1ZmZlciBzdGFydmF0aW9uXG4gICAgKi9cbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCB2aWRlbyA9IGhscy5tZWRpYTtcbiAgICBjb25zdCBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcblxuICAgIGlmICghZnJhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGxvYWRlciA9IGZyYWcubG9hZGVyO1xuICAgIGNvbnN0IG1pbkF1dG9MZXZlbCA9IGhscy5taW5BdXRvTGV2ZWw7XG5cbiAgICAvLyBpZiBsb2FkZXIgaGFzIGJlZW4gZGVzdHJveWVkIG9yIGxvYWRpbmcgaGFzIGJlZW4gYWJvcnRlZCwgc3RvcCB0aW1lciBhbmQgcmV0dXJuXG4gICAgaWYgKCFsb2FkZXIgfHwgKGxvYWRlci5zdGF0cyAmJiBsb2FkZXIuc3RhdHMuYWJvcnRlZCkpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdmcmFnIGxvYWRlciBkZXN0cm95IG9yIGFib3J0ZWQsIGRpc2FybSBhYmFuZG9uUnVsZXMnKTtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgLy8gcmVzZXQgZm9yY2VkIGF1dG8gbGV2ZWwgdmFsdWUgc28gdGhhdCBuZXh0IGxldmVsIHdpbGwgYmUgc2VsZWN0ZWRcbiAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHN0YXRzID0gbG9hZGVyLnN0YXRzO1xuICAgIC8qIG9ubHkgbW9uaXRvciBmcmFnIHJldHJpZXZhbCB0aW1lIGlmXG4gICAgKHZpZGVvIG5vdCBwYXVzZWQgT1IgZmlyc3QgZnJhZ21lbnQgYmVpbmcgbG9hZGVkKHJlYWR5IHN0YXRlID09PSBIQVZFX05PVEhJTkcgPSAwKSkgQU5EIGF1dG9zd2l0Y2hpbmcgZW5hYmxlZCBBTkQgbm90IGxvd2VzdCBsZXZlbCAoPT4gbWVhbnMgdGhhdCB3ZSBoYXZlIHNldmVyYWwgbGV2ZWxzKSAqL1xuICAgIGlmICh2aWRlbyAmJiBzdGF0cyAmJiAoKCF2aWRlby5wYXVzZWQgJiYgKHZpZGVvLnBsYXliYWNrUmF0ZSAhPT0gMCkpIHx8ICF2aWRlby5yZWFkeVN0YXRlKSAmJiBmcmFnLmF1dG9MZXZlbCAmJiBmcmFnLmxldmVscykge1xuICAgICAgbGV0IHJlcXVlc3REZWxheSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhdHMudHJlcXVlc3QsXG4gICAgICAgIHBsYXliYWNrUmF0ZSA9IE1hdGguYWJzKHZpZGVvLnBsYXliYWNrUmF0ZSk7XG4gICAgICAvLyBtb25pdG9yIGZyYWdtZW50IGxvYWQgcHJvZ3Jlc3MgYWZ0ZXIgaGFsZiBvZiBleHBlY3RlZCBmcmFnbWVudCBkdXJhdGlvbix0byBzdGFiaWxpemUgYml0cmF0ZVxuICAgICAgaWYgKHJlcXVlc3REZWxheSA+ICg1MDAgKiBmcmFnLmR1cmF0aW9uIC8gcGxheWJhY2tSYXRlKSkge1xuICAgICAgICBsZXQgbGV2ZWxzID0gaGxzLmxldmVscyxcbiAgICAgICAgICBsb2FkUmF0ZSA9IE1hdGgubWF4KDEsIHN0YXRzLmJ3ID8gc3RhdHMuYncgLyA4IDogc3RhdHMubG9hZGVkICogMTAwMCAvIHJlcXVlc3REZWxheSksIC8vIGJ5dGUvczsgYXQgbGVhc3QgMSBieXRlL3MgdG8gYXZvaWQgZGl2aXNpb24gYnkgemVyb1xuICAgICAgICAgIC8vIGNvbXB1dGUgZXhwZWN0ZWQgZnJhZ21lbnQgbGVuZ3RoIHVzaW5nIGZyYWcgZHVyYXRpb24gYW5kIGxldmVsIGJpdHJhdGUuIGFsc28gZW5zdXJlIHRoYXQgZXhwZWN0ZWQgbGVuIGlzIGd0ZSB0aGFuIGFscmVhZHkgbG9hZGVkIHNpemVcbiAgICAgICAgICBsZXZlbCA9IGxldmVsc1tmcmFnLmxldmVsc10sXG4gICAgICAgICAgbGV2ZWxCaXRyYXRlID0gbGV2ZWwucmVhbEJpdHJhdGUgPyBNYXRoLm1heChsZXZlbC5yZWFsQml0cmF0ZSwgbGV2ZWwuYml0cmF0ZSkgOiBsZXZlbC5iaXRyYXRlLFxuICAgICAgICAgIGV4cGVjdGVkTGVuID0gc3RhdHMudG90YWwgPyBzdGF0cy50b3RhbCA6IE1hdGgubWF4KHN0YXRzLmxvYWRlZCwgTWF0aC5yb3VuZChmcmFnLmR1cmF0aW9uICogbGV2ZWxCaXRyYXRlIC8gOCkpLFxuICAgICAgICAgIHBvcyA9IHZpZGVvLmN1cnJlbnRUaW1lLFxuICAgICAgICAgIGZyYWdMb2FkZWREZWxheSA9IChleHBlY3RlZExlbiAtIHN0YXRzLmxvYWRlZCkgLyBsb2FkUmF0ZSxcbiAgICAgICAgICBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSAoQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odmlkZW8sIHBvcywgaGxzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKS5lbmQgLSBwb3MpIC8gcGxheWJhY2tSYXRlO1xuICAgICAgICAvLyBjb25zaWRlciBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb25seSBpZiB3ZSBoYXZlIGxlc3MgdGhhbiAyIGZyYWcgYnVmZmVyZWQgQU5EXG4gICAgICAgIC8vIHRpbWUgdG8gZmluaXNoIGxvYWRpbmcgY3VycmVudCBmcmFnbWVudCBpcyBiaWdnZXIgdGhhbiBidWZmZXIgc3RhcnZhdGlvbiBkZWxheVxuICAgICAgICAvLyBpZSBpZiB3ZSByaXNrIGJ1ZmZlciBzdGFydmF0aW9uIGlmIGJ3IGRvZXMgbm90IGluY3JlYXNlIHF1aWNrbHlcbiAgICAgICAgaWYgKChidWZmZXJTdGFydmF0aW9uRGVsYXkgPCAoMiAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpKSAmJiAoZnJhZ0xvYWRlZERlbGF5ID4gYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSkge1xuICAgICAgICAgIGxldCBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXksIG5leHRMb2FkTGV2ZWw7XG4gICAgICAgICAgLy8gbGV0cyBpdGVyYXRlIHRocm91Z2ggbG93ZXIgbGV2ZWwgYW5kIHRyeSB0byBmaW5kIHRoZSBiaWdnZXN0IG9uZSB0aGF0IGNvdWxkIGF2b2lkIHJlYnVmZmVyaW5nXG4gICAgICAgICAgLy8gd2Ugc3RhcnQgZnJvbSBjdXJyZW50IGxldmVsIC0gMSBhbmQgd2Ugc3RlcCBkb3duICwgdW50aWwgd2UgZmluZCBhIG1hdGNoaW5nIGxldmVsXG4gICAgICAgICAgZm9yIChuZXh0TG9hZExldmVsID0gZnJhZy5sZXZlbHMgLSAxOyBuZXh0TG9hZExldmVsID4gbWluQXV0b0xldmVsOyBuZXh0TG9hZExldmVsLS0pIHtcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgdGltZSB0byBsb2FkIG5leHQgZnJhZ21lbnQgYXQgbG93ZXIgbGV2ZWxcbiAgICAgICAgICAgIC8vIDAuOCA6IGNvbnNpZGVyIG9ubHkgODAlIG9mIGN1cnJlbnQgYncgdG8gYmUgY29uc2VydmF0aXZlXG4gICAgICAgICAgICAvLyA4ID0gYml0cyBwZXIgYnl0ZSAoYnBzL0JwcylcbiAgICAgICAgICAgIGxldCBsZXZlbE5leHRCaXRyYXRlID0gbGV2ZWxzW25leHRMb2FkTGV2ZWxdLnJlYWxCaXRyYXRlID8gTWF0aC5tYXgobGV2ZWxzW25leHRMb2FkTGV2ZWxdLnJlYWxCaXRyYXRlLCBsZXZlbHNbbmV4dExvYWRMZXZlbF0uYml0cmF0ZSkgOiBsZXZlbHNbbmV4dExvYWRMZXZlbF0uYml0cmF0ZTtcbiAgICAgICAgICAgIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA9IGZyYWcuZHVyYXRpb24gKiBsZXZlbE5leHRCaXRyYXRlIC8gKDggKiAwLjggKiBsb2FkUmF0ZSk7XG4gICAgICAgICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5IDwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICAgICAgICAgIC8vIHdlIGZvdW5kIGEgbG93ZXIgbGV2ZWwgdGhhdCBiZSByZWJ1ZmZlcmluZyBmcmVlIHdpdGggY3VycmVudCBlc3RpbWF0ZWQgYncgIVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb25seSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gaWYgaXQgdGFrZXMgbGVzcyB0aW1lIHRvIGxvYWQgbmV3IGZyYWdtZW50IGF0IGxvd2VzdCBsZXZlbCBpbnN0ZWFkXG4gICAgICAgICAgLy8gb2YgZmluaXNoaW5nIGxvYWRpbmcgY3VycmVudCBvbmUgLi4uXG4gICAgICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA8IGZyYWdMb2FkZWREZWxheSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYGxvYWRpbmcgdG9vIHNsb3csIGFib3J0IGZyYWdtZW50IGxvYWRpbmcgYW5kIHN3aXRjaCB0byBsZXZlbCAke25leHRMb2FkTGV2ZWx9OmZyYWdMb2FkZWREZWxheVske25leHRMb2FkTGV2ZWx9XTxmcmFnTG9hZGVkRGVsYXlbJHtmcmFnLmxldmVscyAtIDF9XTtidWZmZXJTdGFydmF0aW9uRGVsYXk6JHtmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkudG9GaXhlZCgxKX08JHtmcmFnTG9hZGVkRGVsYXkudG9GaXhlZCgxKX06JHtidWZmZXJTdGFydmF0aW9uRGVsYXkudG9GaXhlZCgxKX1gKTtcbiAgICAgICAgICAgIC8vIGZvcmNlIG5leHQgbG9hZCBsZXZlbCBpbiBhdXRvIG1vZGVcbiAgICAgICAgICAgIGhscy5uZXh0TG9hZExldmVsID0gbmV4dExvYWRMZXZlbDtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBidyBlc3RpbWF0ZSBmb3IgdGhpcyBmcmFnbWVudCBiZWZvcmUgY2FuY2VsbGluZyBsb2FkICh0aGlzIHdpbGwgaGVscCByZWR1Y2luZyB0aGUgYncpXG4gICAgICAgICAgICB0aGlzLl9id0VzdGltYXRvci5zYW1wbGUocmVxdWVzdERlbGF5LCBzdGF0cy5sb2FkZWQpO1xuICAgICAgICAgICAgLy8gYWJvcnQgZnJhZ21lbnQgbG9hZGluZ1xuICAgICAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgICAvLyBzdG9wIGFiYW5kb24gcnVsZXMgdGltZXJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB7IGZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0cyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkZyYWdMb2FkZWQgKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIGlmIChmcmFnLnR5cGUgPT09ICdtYWluJyAmJiBOdW1iZXIuaXNGaW5pdGUoZnJhZy5zbikpIHtcbiAgICAgIC8vIHN0b3AgbW9uaXRvcmluZyBidyBvbmNlIGZyYWcgbG9hZGVkXG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIC8vIHN0b3JlIGxldmVsIGlkIGFmdGVyIHN1Y2Nlc3NmdWwgZnJhZ21lbnQgbG9hZFxuICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gZnJhZy5sZXZlbHM7XG4gICAgICAvLyByZXNldCBmb3JjZWQgYXV0byBsZXZlbCB2YWx1ZSBzbyB0aGF0IG5leHQgbGV2ZWwgd2lsbCBiZSBzZWxlY3RlZFxuICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuXG4gICAgICAvLyBjb21wdXRlIGxldmVsIGF2ZXJhZ2UgYml0cmF0ZVxuICAgICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5hYnJNYXhXaXRoUmVhbEJpdHJhdGUpIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZnJhZy5sZXZlbHNdO1xuICAgICAgICBsZXQgbG9hZGVkQnl0ZXMgPSAobGV2ZWwubG9hZGVkID8gbGV2ZWwubG9hZGVkLmJ5dGVzIDogMCkgKyBkYXRhLnN0YXRzLmxvYWRlZDtcbiAgICAgICAgbGV0IGxvYWRlZER1cmF0aW9uID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5kdXJhdGlvbiA6IDApICsgZGF0YS5mcmFnLmR1cmF0aW9uO1xuICAgICAgICBsZXZlbC5sb2FkZWQgPSB7IGJ5dGVzOiBsb2FkZWRCeXRlcywgZHVyYXRpb246IGxvYWRlZER1cmF0aW9uIH07XG4gICAgICAgIGxldmVsLnJlYWxCaXRyYXRlID0gTWF0aC5yb3VuZCg4ICogbG9hZGVkQnl0ZXMgLyBsb2FkZWREdXJhdGlvbik7XG4gICAgICB9XG4gICAgICAvLyBpZiBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdCxcbiAgICAgIGlmIChkYXRhLmZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgICAgbGV0IHN0YXRzID0gZGF0YS5zdGF0cztcbiAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHN0YXRzLnRsb2FkO1xuICAgICAgICB0aGlzLm9uRnJhZ0J1ZmZlcmVkKGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0J1ZmZlcmVkIChkYXRhKSB7XG4gICAgY29uc3Qgc3RhdHMgPSBkYXRhLnN0YXRzO1xuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgLy8gb25seSB1cGRhdGUgc3RhdHMgb24gZmlyc3QgZnJhZyBidWZmZXJpbmdcbiAgICAvLyBpZiBzYW1lIGZyYWcgaXMgbG9hZGVkIG11bHRpcGxlIHRpbWVzLCBpdCBtaWdodCBiZSBpbiBicm93c2VyIGNhY2hlLCBhbmQgbG9hZGVkIHF1aWNrbHlcbiAgICAvLyBhbmQgbGVhZGluZyB0byB3cm9uZyBidyBlc3RpbWF0aW9uXG4gICAgLy8gb24gYml0cmF0ZSB0ZXN0LCBhbHNvIG9ubHkgdXBkYXRlIHN0YXRzIG9uY2UgKGlmIHRsb2FkID0gdGJ1ZmZlcmVkID09IG9uIEZSQUdfTE9BREVEKVxuICAgIGlmIChzdGF0cy5hYm9ydGVkICE9PSB0cnVlICYmIGZyYWcudHlwZSA9PT0gJ21haW4nICYmIE51bWJlci5pc0Zpbml0ZShmcmFnLnNuKSAmJiAoKCFmcmFnLmJpdHJhdGVUZXN0IHx8IHN0YXRzLnRsb2FkID09PSBzdGF0cy50YnVmZmVyZWQpKSkge1xuICAgICAgLy8gdXNlIHRwYXJzZWQtdHJlcXVlc3QgaW5zdGVhZCBvZiB0YnVmZmVyZWQtdHJlcXVlc3QgdG8gY29tcHV0ZSBmcmFnTG9hZGluZ1Byb2Nlc3Npbmc7IHJhdGlvbmFsZSBpcyB0aGF0ICBidWZmZXIgYXBwZW5kaW5nIG9ubHkgaGFwcGVucyBvbmNlIG1lZGlhIGlzIGF0dGFjaGVkXG4gICAgICAvLyBpbiBjYXNlIHdlIHVzZSBjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2ggd2hpbGUgbWVkaWEgaXMgbm90IGF0dGFjaGVkIHlldCwgZnJhZ21lbnQgbWlnaHQgYmUgcGFyc2VkIHdoaWxlIG1lZGlhIG5vdCBhdHRhY2hlZCB5ZXQsIGJ1dCBpdCB3aWxsIG9ubHkgYmUgYnVmZmVyZWQgb24gbWVkaWEgYXR0YWNoZWRcbiAgICAgIC8vIGFzIGEgY29uc2VxdWVuY2UgaXQgY291bGQgaGFwcGVuIHJlYWxseSBsYXRlIGluIHRoZSBwcm9jZXNzLiBtZWFuaW5nIHRoYXQgYXBwZW5kaW5nIGR1cmF0aW9uIG1pZ2h0IGFwcGVhcnMgaHVnZSAuLi4gbGVhZGluZyB0byB1bmRlcmVzdGltYXRlZCB0aHJvdWdocHV0IGVzdGltYXRpb25cbiAgICAgIGxldCBmcmFnTG9hZGluZ1Byb2Nlc3NpbmdNcyA9IHN0YXRzLnRwYXJzZWQgLSBzdGF0cy50cmVxdWVzdDtcbiAgICAgIGxvZ2dlci5sb2coYGxhdGVuY3kvbG9hZGluZy9wYXJzaW5nL2FwcGVuZC9rYnBzOiR7TWF0aC5yb3VuZChzdGF0cy50Zmlyc3QgLSBzdGF0cy50cmVxdWVzdCl9LyR7TWF0aC5yb3VuZChzdGF0cy50bG9hZCAtIHN0YXRzLnRmaXJzdCl9LyR7TWF0aC5yb3VuZChzdGF0cy50cGFyc2VkIC0gc3RhdHMudGxvYWQpfS8ke01hdGgucm91bmQoc3RhdHMudGJ1ZmZlcmVkIC0gc3RhdHMudHBhcnNlZCl9LyR7TWF0aC5yb3VuZCg4ICogc3RhdHMubG9hZGVkIC8gKHN0YXRzLnRidWZmZXJlZCAtIHN0YXRzLnRyZXF1ZXN0KSl9YCk7XG4gICAgICB0aGlzLl9id0VzdGltYXRvci5zYW1wbGUoZnJhZ0xvYWRpbmdQcm9jZXNzaW5nTXMsIHN0YXRzLmxvYWRlZCk7XG4gICAgICBzdGF0cy5id0VzdGltYXRlID0gdGhpcy5fYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKTtcbiAgICAgIC8vIGlmIGZyYWdtZW50IGhhcyBiZWVuIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0LCAoaGxzLnN0YXJ0TGV2ZWwgPSAtMSksIHN0b3JlIGJpdHJhdGUgdGVzdCBkZWxheSBkdXJhdGlvblxuICAgICAgaWYgKGZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gZnJhZ0xvYWRpbmdQcm9jZXNzaW5nTXMgLyAxMDAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkVycm9yIChkYXRhKSB7XG4gICAgLy8gc3RvcCB0aW1lciBpbiBjYXNlIG9mIGZyYWcgbG9hZGluZyBlcnJvclxuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgY2xlYXJUaW1lciAoKSB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgfVxuXG4gIC8vIHJldHVybiBuZXh0IGF1dG8gbGV2ZWxcbiAgZ2V0IG5leHRBdXRvTGV2ZWwgKCkge1xuICAgIGNvbnN0IGZvcmNlZEF1dG9MZXZlbCA9IHRoaXMuX25leHRBdXRvTGV2ZWw7XG4gICAgY29uc3QgYndFc3RpbWF0b3IgPSB0aGlzLl9id0VzdGltYXRvcjtcbiAgICAvLyBpbiBjYXNlIG5leHQgYXV0byBsZXZlbCBoYXMgYmVlbiBmb3JjZWQsIGFuZCBidyBub3QgYXZhaWxhYmxlIG9yIG5vdCByZWxpYWJsZSwgcmV0dXJuIGZvcmNlZCB2YWx1ZVxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xICYmICghYndFc3RpbWF0b3IgfHwgIWJ3RXN0aW1hdG9yLmNhbkVzdGltYXRlKCkpKSB7XG4gICAgICByZXR1cm4gZm9yY2VkQXV0b0xldmVsO1xuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgbmV4dCBsZXZlbCB1c2luZyBBQlIgbG9naWNcbiAgICBsZXQgbmV4dEFCUkF1dG9MZXZlbCA9IHRoaXMuX25leHRBQlJBdXRvTGV2ZWw7XG4gICAgLy8gaWYgZm9yY2VkIGF1dG8gbGV2ZWwgaGFzIGJlZW4gZGVmaW5lZCwgdXNlIGl0IHRvIGNhcCBBQlIgY29tcHV0ZWQgcXVhbGl0eSBsZXZlbFxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICBuZXh0QUJSQXV0b0xldmVsID0gTWF0aC5taW4oZm9yY2VkQXV0b0xldmVsLCBuZXh0QUJSQXV0b0xldmVsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dEFCUkF1dG9MZXZlbDtcbiAgfVxuICBnZXQgX25leHRBQlJBdXRvTGV2ZWwgKCkge1xuICAgIGxldCBobHMgPSB0aGlzLmhscywgbWF4QXV0b0xldmVsID0gaGxzLm1heEF1dG9MZXZlbCwgbGV2ZWxzID0gaGxzLmxldmVscywgY29uZmlnID0gaGxzLmNvbmZpZywgbWluQXV0b0xldmVsID0gaGxzLm1pbkF1dG9MZXZlbDtcbiAgICBjb25zdCB2aWRlbyA9IGhscy5tZWRpYSxcbiAgICAgIGN1cnJlbnRMZXZlbCA9IHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCxcbiAgICAgIGN1cnJlbnRGcmFnRHVyYXRpb24gPSB0aGlzLmZyYWdDdXJyZW50ID8gdGhpcy5mcmFnQ3VycmVudC5kdXJhdGlvbiA6IDAsXG4gICAgICBwb3MgPSAodmlkZW8gPyB2aWRlby5jdXJyZW50VGltZSA6IDApLFxuICAgICAgLy8gcGxheWJhY2tSYXRlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgcGxheWJhY2sgcmF0ZTsgaWYgdmlkZW8ucGxheWJhY2tSYXRlIGlzIDAsIHdlIHVzZSAxIHRvIGxvYWQgYXNcbiAgICAgIC8vIGlmIHdlJ3JlIHBsYXlpbmcgYmFjayBhdCB0aGUgbm9ybWFsIHJhdGUuXG4gICAgICBwbGF5YmFja1JhdGUgPSAoKHZpZGVvICYmICh2aWRlby5wbGF5YmFja1JhdGUgIT09IDApKSA/IE1hdGguYWJzKHZpZGVvLnBsYXliYWNrUmF0ZSkgOiAxLjApLFxuICAgICAgYXZnYncgPSB0aGlzLl9id0VzdGltYXRvciA/IHRoaXMuX2J3RXN0aW1hdG9yLmdldEVzdGltYXRlKCkgOiBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSxcbiAgICAgIC8vIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSBpcyB0aGUgd2FsbC1jbG9jayB0aW1lIGxlZnQgdW50aWwgdGhlIHBsYXliYWNrIGJ1ZmZlciBpcyBleGhhdXN0ZWQuXG4gICAgICBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSAoQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odmlkZW8sIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLmVuZCAtIHBvcykgLyBwbGF5YmFja1JhdGU7XG5cbiAgICAvLyBGaXJzdCwgbG9vayB0byBzZWUgaWYgd2UgY2FuIGZpbmQgYSBsZXZlbCBtYXRjaGluZyB3aXRoIG91ciBhdmcgYmFuZHdpZHRoIEFORCB0aGF0IGNvdWxkIGFsc28gZ3VhcmFudGVlIG5vIHJlYnVmZmVyaW5nIGF0IGFsbFxuICAgIGxldCBiZXN0TGV2ZWwgPSB0aGlzLl9maW5kQmVzdExldmVsKGN1cnJlbnRMZXZlbCwgY3VycmVudEZyYWdEdXJhdGlvbiwgYXZnYncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBidWZmZXJTdGFydmF0aW9uRGVsYXksIGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3IsIGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvciwgbGV2ZWxzKTtcbiAgICBpZiAoYmVzdExldmVsID49IDApIHtcbiAgICAgIHJldHVybiBiZXN0TGV2ZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci50cmFjZSgncmVidWZmZXJpbmcgZXhwZWN0ZWQgdG8gaGFwcGVuLCBsZXRzIHRyeSB0byBmaW5kIGEgcXVhbGl0eSBsZXZlbCBtaW5pbWl6aW5nIHRoZSByZWJ1ZmZlcmluZycpO1xuICAgICAgLy8gbm90IHBvc3NpYmxlIHRvIGdldCByaWQgb2YgcmVidWZmZXJpbmcgLi4uIGxldCdzIHRyeSB0byBmaW5kIGxldmVsIHRoYXQgd2lsbCBndWFyYW50ZWUgbGVzcyB0aGFuIG1heFN0YXJ2YXRpb25EZWxheSBvZiByZWJ1ZmZlcmluZ1xuICAgICAgLy8gaWYgbm8gbWF0Y2hpbmcgbGV2ZWwgZm91bmQsIGxvZ2ljIHdpbGwgcmV0dXJuIDBcbiAgICAgIGxldCBtYXhTdGFydmF0aW9uRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbiwgY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheSkgOiBjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5LFxuICAgICAgICBid0ZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3IsXG4gICAgICAgIGJ3VXBGYWN0b3IgPSBjb25maWcuYWJyQmFuZFdpZHRoVXBGYWN0b3I7XG4gICAgICBpZiAoYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID09PSAwKSB7XG4gICAgICAgIC8vIGluIGNhc2UgYnVmZmVyIGlzIGVtcHR5LCBsZXQncyBjaGVjayBpZiBwcmV2aW91cyBmcmFnbWVudCB3YXMgbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3RcbiAgICAgICAgbGV0IGJpdHJhdGVUZXN0RGVsYXkgPSB0aGlzLmJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICAgIGlmIChiaXRyYXRlVGVzdERlbGF5KSB7XG4gICAgICAgICAgLy8gaWYgaXQgaXMgdGhlIGNhc2UsIHRoZW4gd2UgbmVlZCB0byBhZGp1c3Qgb3VyIG1heCBzdGFydmF0aW9uIGRlbGF5IHVzaW5nIG1heExvYWRpbmdEZWxheSBjb25maWcgdmFsdWVcbiAgICAgICAgICAvLyBtYXggdmlkZW8gbG9hZGluZyBkZWxheSB1c2VkIGluICBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uIDpcbiAgICAgICAgICAvLyBpbiB0aGF0IG1vZGUgQUJSIGNvbnRyb2xsZXIgd2lsbCBlbnN1cmUgdGhhdCB2aWRlbyBsb2FkaW5nIHRpbWUgKGllIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmaXJzdCBmcmFnbWVudCBhdCBsb3dlc3QgcXVhbGl0eSBsZXZlbCArXG4gICAgICAgICAgLy8gdGhlIHRpbWUgdG8gZmV0Y2ggdGhlIGZyYWdtZW50IGF0IHRoZSBhcHByb3ByaWF0ZSBxdWFsaXR5IGxldmVsIGlzIGxlc3MgdGhhbiBgYGBtYXhMb2FkaW5nRGVsYXlgYGAgKVxuICAgICAgICAgIC8vIGNhcCBtYXhMb2FkaW5nRGVsYXkgYW5kIGVuc3VyZSBpdCBpcyBub3QgYmlnZ2VyICd0aGFuIGJpdHJhdGUgdGVzdCcgZnJhZyBkdXJhdGlvblxuICAgICAgICAgIGNvbnN0IG1heExvYWRpbmdEZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb24gPyBNYXRoLm1pbihjdXJyZW50RnJhZ0R1cmF0aW9uLCBjb25maWcubWF4TG9hZGluZ0RlbGF5KSA6IGNvbmZpZy5tYXhMb2FkaW5nRGVsYXk7XG4gICAgICAgICAgbWF4U3RhcnZhdGlvbkRlbGF5ID0gbWF4TG9hZGluZ0RlbGF5IC0gYml0cmF0ZVRlc3REZWxheTtcbiAgICAgICAgICBsb2dnZXIudHJhY2UoYGJpdHJhdGUgdGVzdCB0b29rICR7TWF0aC5yb3VuZCgxMDAwICogYml0cmF0ZVRlc3REZWxheSl9bXMsIHNldCBmaXJzdCBmcmFnbWVudCBtYXggZmV0Y2hEdXJhdGlvbiB0byAke01hdGgucm91bmQoMTAwMCAqIG1heFN0YXJ2YXRpb25EZWxheSl9IG1zYCk7XG4gICAgICAgICAgLy8gZG9uJ3QgdXNlIGNvbnNlcnZhdGl2ZSBmYWN0b3Igb24gYml0cmF0ZSB0ZXN0XG4gICAgICAgICAgYndGYWN0b3IgPSBid1VwRmFjdG9yID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmVzdExldmVsID0gdGhpcy5fZmluZEJlc3RMZXZlbChjdXJyZW50TGV2ZWwsIGN1cnJlbnRGcmFnRHVyYXRpb24sIGF2Z2J3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ICsgbWF4U3RhcnZhdGlvbkRlbGF5LCBid0ZhY3RvciwgYndVcEZhY3RvciwgbGV2ZWxzKTtcbiAgICAgIHJldHVybiBNYXRoLm1heChiZXN0TGV2ZWwsIDApO1xuICAgIH1cbiAgfVxuXG4gIF9maW5kQmVzdExldmVsIChjdXJyZW50TGV2ZWwsIGN1cnJlbnRGcmFnRHVyYXRpb24sIGN1cnJlbnRCdywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIG1heEZldGNoRHVyYXRpb24sIGJ3RmFjdG9yLCBid1VwRmFjdG9yLCBsZXZlbHMpIHtcbiAgICBmb3IgKGxldCBpID0gbWF4QXV0b0xldmVsOyBpID49IG1pbkF1dG9MZXZlbDsgaS0tKSB7XG4gICAgICBsZXQgbGV2ZWxJbmZvID0gbGV2ZWxzW2ldO1xuXG4gICAgICBpZiAoIWxldmVsSW5mbykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGxldmVsRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzLFxuICAgICAgICBhdmdEdXJhdGlvbiA9IGxldmVsRGV0YWlscyA/IGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uIC8gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggOiBjdXJyZW50RnJhZ0R1cmF0aW9uLFxuICAgICAgICBsaXZlID0gbGV2ZWxEZXRhaWxzID8gbGV2ZWxEZXRhaWxzLmxpdmUgOiBmYWxzZSxcbiAgICAgICAgYWRqdXN0ZWRidztcbiAgICAgIC8vIGZvbGxvdyBhbGdvcml0aG0gY2FwdHVyZWQgZnJvbSBzdGFnZWZyaWdodCA6XG4gICAgICAvLyBodHRwczovL2FuZHJvaWQuZ29vZ2xlc291cmNlLmNvbS9wbGF0Zm9ybS9mcmFtZXdvcmtzL2F2LysvbWFzdGVyL21lZGlhL2xpYnN0YWdlZnJpZ2h0L2h0dHBsaXZlL0xpdmVTZXNzaW9uLmNwcFxuICAgICAgLy8gUGljayB0aGUgaGlnaGVzdCBiYW5kd2lkdGggc3RyZWFtIGJlbG93IG9yIGVxdWFsIHRvIGVzdGltYXRlZCBiYW5kd2lkdGguXG4gICAgICAvLyBjb25zaWRlciBvbmx5IDgwJSBvZiB0aGUgYXZhaWxhYmxlIGJhbmR3aWR0aCwgYnV0IGlmIHdlIGFyZSBzd2l0Y2hpbmcgdXAsXG4gICAgICAvLyBiZSBldmVuIG1vcmUgY29uc2VydmF0aXZlICg3MCUpIHRvIGF2b2lkIG92ZXJlc3RpbWF0aW5nIGFuZCBpbW1lZGlhdGVseVxuICAgICAgLy8gc3dpdGNoaW5nIGJhY2suXG4gICAgICBpZiAoaSA8PSBjdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgYWRqdXN0ZWRidyA9IGJ3RmFjdG9yICogY3VycmVudEJ3O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRqdXN0ZWRidyA9IGJ3VXBGYWN0b3IgKiBjdXJyZW50Qnc7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJpdHJhdGUgPSBsZXZlbHNbaV0ucmVhbEJpdHJhdGUgPyBNYXRoLm1heChsZXZlbHNbaV0ucmVhbEJpdHJhdGUsIGxldmVsc1tpXS5iaXRyYXRlKSA6IGxldmVsc1tpXS5iaXRyYXRlLFxuICAgICAgICBmZXRjaER1cmF0aW9uID0gYml0cmF0ZSAqIGF2Z0R1cmF0aW9uIC8gYWRqdXN0ZWRidztcblxuICAgICAgbG9nZ2VyLnRyYWNlKGBsZXZlbC9hZGp1c3RlZGJ3L2JpdHJhdGUvYXZnRHVyYXRpb24vbWF4RmV0Y2hEdXJhdGlvbi9mZXRjaER1cmF0aW9uOiAke2l9LyR7TWF0aC5yb3VuZChhZGp1c3RlZGJ3KX0vJHtiaXRyYXRlfS8ke2F2Z0R1cmF0aW9ufS8ke21heEZldGNoRHVyYXRpb259LyR7ZmV0Y2hEdXJhdGlvbn1gKTtcbiAgICAgIC8vIGlmIGFkanVzdGVkIGJ3IGlzIGdyZWF0ZXIgdGhhbiBsZXZlbCBiaXRyYXRlIEFORFxuICAgICAgaWYgKGFkanVzdGVkYncgPiBiaXRyYXRlICYmXG4gICAgICAvLyBmcmFnbWVudCBmZXRjaER1cmF0aW9uIHVua25vd24gT1IgbGl2ZSBzdHJlYW0gT1IgZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiBsZXNzIHRoYW4gbWF4IGFsbG93ZWQgZmV0Y2ggZHVyYXRpb24sIHRoZW4gdGhpcyBsZXZlbCBtYXRjaGVzXG4gICAgICAvLyB3ZSBkb24ndCBhY2NvdW50IGZvciBtYXggRmV0Y2ggRHVyYXRpb24gZm9yIGxpdmUgc3RyZWFtcywgdGhpcyBpcyB0byBhdm9pZCBzd2l0Y2hpbmcgZG93biB3aGVuIG5lYXIgdGhlIGVkZ2Ugb2YgbGl2ZSBzbGlkaW5nIHdpbmRvdyAuLi5cbiAgICAgIC8vIHNwZWNpYWwgY2FzZSB0byBzdXBwb3J0IHN0YXJ0TGV2ZWwgPSAtMSAoYml0cmF0ZVRlc3QpIG9uIGxpdmUgc3RyZWFtcyA6IGluIHRoYXQgY2FzZSB3ZSBzaG91bGQgbm90IGV4aXQgbG9vcCBzbyB0aGF0IF9maW5kQmVzdExldmVsIHdpbGwgcmV0dXJuIC0xXG4gICAgICAgICghZmV0Y2hEdXJhdGlvbiB8fMKgKGxpdmUgJiYgIXRoaXMuYml0cmF0ZVRlc3REZWxheSkgfHwgZmV0Y2hEdXJhdGlvbiA8IG1heEZldGNoRHVyYXRpb24pKSB7XG4gICAgICAgIC8vIGFzIHdlIGFyZSBsb29waW5nIGZyb20gaGlnaGVzdCB0byBsb3dlc3QsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGJlc3QgYWNoaWV2YWJsZSBxdWFsaXR5IGxldmVsXG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBub3QgZW5vdWdoIHRpbWUgYnVkZ2V0IGV2ZW4gd2l0aCBxdWFsaXR5IGxldmVsIDAgLi4uIHJlYnVmZmVyaW5nIG1pZ2h0IGhhcHBlblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHNldCBuZXh0QXV0b0xldmVsIChuZXh0TGV2ZWwpIHtcbiAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gbmV4dExldmVsO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFickNvbnRyb2xsZXI7XG4iLCIvKlxuICogQXVkaW8gU3RyZWFtIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBCaW5hcnlTZWFyY2ggZnJvbSAnLi4vdXRpbHMvYmluYXJ5LXNlYXJjaCc7XG5pbXBvcnQgeyBCdWZmZXJIZWxwZXIgfSBmcm9tICcuLi91dGlscy9idWZmZXItaGVscGVyJztcbmltcG9ydCBEZW11eGVyIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXInO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgKiBhcyBMZXZlbEhlbHBlciBmcm9tICcuL2xldmVsLWhlbHBlcic7XG5pbXBvcnQgVGltZVJhbmdlcyBmcm9tICcuLi91dGlscy90aW1lLXJhbmdlcyc7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IGZpbmRGcmFnV2l0aENDIH0gZnJvbSAnLi4vdXRpbHMvZGlzY29udGludWl0aWVzJztcbmltcG9ydCB7IEZyYWdtZW50U3RhdGUgfSBmcm9tICcuL2ZyYWdtZW50LXRyYWNrZXInO1xuaW1wb3J0IEZyYWdtZW50IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgQmFzZVN0cmVhbUNvbnRyb2xsZXIsIHsgU3RhdGUgfSBmcm9tICcuL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXInO1xuY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gd2luZG93O1xuXG5jb25zdCBUSUNLX0lOVEVSVkFMID0gMTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuXG5jbGFzcyBBdWRpb1N0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlU3RyZWFtQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMsIGZyYWdtZW50VHJhY2tlcikge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSEVELFxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tTX1VQREFURUQsXG4gICAgICBFdmVudC5BVURJT19UUkFDS19TV0lUQ0hJTkcsXG4gICAgICBFdmVudC5BVURJT19UUkFDS19MT0FERUQsXG4gICAgICBFdmVudC5LRVlfTE9BREVELFxuICAgICAgRXZlbnQuRlJBR19MT0FERUQsXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULFxuICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsXG4gICAgICBFdmVudC5GUkFHX1BBUlNFRCxcbiAgICAgIEV2ZW50LkVSUk9SLFxuICAgICAgRXZlbnQuQlVGRkVSX1JFU0VULFxuICAgICAgRXZlbnQuQlVGRkVSX0NSRUFURUQsXG4gICAgICBFdmVudC5CVUZGRVJfQVBQRU5ERUQsXG4gICAgICBFdmVudC5CVUZGRVJfRkxVU0hFRCxcbiAgICAgIEV2ZW50LklOSVRfUFRTX0ZPVU5EKTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IGZyYWdtZW50VHJhY2tlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMuX3N0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IG51bGw7XG4gICAgdGhpcy52aWRlb1RyYWNrQ0MgPSBudWxsO1xuICB9XG5cbiAgLy8gU2lnbmFsIHRoYXQgdmlkZW8gUFRTIHdhcyBmb3VuZFxuICBvbkluaXRQdHNGb3VuZCAoZGF0YSkge1xuICAgIGxldCBkZW11eGVySWQgPSBkYXRhLmlkLCBjYyA9IGRhdGEuZnJhZy5jYywgaW5pdFBUUyA9IGRhdGEuaW5pdFBUUztcbiAgICBpZiAoZGVtdXhlcklkID09PSAnbWFpbicpIHtcbiAgICAgIC8vIEFsd2F5cyB1cGRhdGUgdGhlIG5ldyBJTklUIFBUU1xuICAgICAgLy8gQ2FuIGNoYW5nZSBkdWUgbGV2ZWwgc3dpdGNoXG4gICAgICB0aGlzLmluaXRQVFNbY2NdID0gaW5pdFBUUztcbiAgICAgIHRoaXMudmlkZW9UcmFja0NDID0gY2M7XG4gICAgICBsb2dnZXIubG9nKGBJbml0UFRTIGZvciBjYzogJHtjY30gZm91bmQgZnJvbSB2aWRlbyB0cmFjazogJHtpbml0UFRTfWApO1xuXG4gICAgICAvLyBJZiB3ZSBhcmUgd2FpdGluZyB3ZSBuZWVkIHRvIGRlbXV4L3JlbXV4IHRoZSB3YWl0aW5nIGZyYWdcbiAgICAgIC8vIFdpdGggdGhlIG5ldyBpbml0UFRTXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19JTklUX1BUUykge1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGFydExvYWQgKHN0YXJ0UG9zaXRpb24pIHtcbiAgICBpZiAodGhpcy50cmFja3MpIHtcbiAgICAgIGxldCBsYXN0Q3VycmVudFRpbWUgPSB0aGlzLmxhc3RDdXJyZW50VGltZTtcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgYXVkaW86b3ZlcnJpZGUgc3RhcnRQb3NpdGlvbiB3aXRoIGxhc3RDdXJyZW50VGltZSBAJHtsYXN0Q3VycmVudFRpbWUudG9GaXhlZCgzKX1gKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMuc3RhcnRQb3NpdGlvbiA/IHRoaXMuc3RhcnRQb3NpdGlvbiA6IHN0YXJ0UG9zaXRpb247XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVEFSVElORztcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB9XG4gIH1cblxuICBzZXQgc3RhdGUgKG5leHRTdGF0ZSkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBuZXh0U3RhdGUpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgdGhpcy5fc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICBsb2dnZXIubG9nKGBhdWRpbyBzdHJlYW06JHtwcmV2aW91c1N0YXRlfS0+JHtuZXh0U3RhdGV9YCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cblxuICBkb1RpY2sgKCkge1xuICAgIGxldCBwb3MsIHRyYWNrLCB0cmFja0RldGFpbHMsIGhscyA9IHRoaXMuaGxzLCBjb25maWcgPSBobHMuY29uZmlnO1xuICAgIC8vIGxvZ2dlci5sb2coJ2F1ZGlvU3RyZWFtOicgKyB0aGlzLnN0YXRlKTtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICBjYXNlIFN0YXRlLkVSUk9SOlxuICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgaW4gZXJyb3Igc3RhdGUgdG8gYXZvaWQgYnJlYWtpbmcgZnVydGhlciAuLi5cbiAgICBjYXNlIFN0YXRlLlBBVVNFRDpcbiAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGluIHBhdXNlZCBzdGF0ZSBlaXRoZXIgLi4uXG4gICAgY2FzZSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFN0YXRlLlNUQVJUSU5HOlxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfVFJBQ0s7XG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFN0YXRlLklETEU6XG4gICAgICBjb25zdCB0cmFja3MgPSB0aGlzLnRyYWNrcztcbiAgICAgIC8vIGF1ZGlvIHRyYWNrcyBub3QgcmVjZWl2ZWQgPT4gZXhpdCBsb29wXG4gICAgICBpZiAoIXRyYWNrcykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORFxuICAgICAgLy8gc3RhcnQgZnJhZ21lbnQgYWxyZWFkeSByZXF1ZXN0ZWQgT1Igc3RhcnQgZnJhZyBwcmVmZXRjaCBkaXNhYmxlXG4gICAgICAvLyBleGl0IGxvb3BcbiAgICAgIC8vID0+IGlmIG1lZGlhIG5vdCBhdHRhY2hlZCBidXQgc3RhcnQgZnJhZyBwcmVmZXRjaCBpcyBlbmFibGVkIGFuZCBzdGFydCBmcmFnIG5vdCByZXF1ZXN0ZWQgeWV0LCB3ZSB3aWxsIG5vdCBleGl0IGxvb3BcbiAgICAgIGlmICghdGhpcy5tZWRpYSAmJlxuICAgICAgICAgICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCB8fCAhY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gZGV0ZXJtaW5lIG5leHQgY2FuZGlkYXRlIGZyYWdtZW50IHRvIGJlIGxvYWRlZCwgYmFzZWQgb24gY3VycmVudCBwb3NpdGlvbiBhbmRcbiAgICAgIC8vICBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG4gICAgICAvLyBpZiB3ZSBoYXZlIG5vdCB5ZXQgbG9hZGVkIGFueSBmcmFnbWVudCwgc3RhcnQgbG9hZGluZyBmcm9tIHN0YXJ0IHBvc2l0aW9uXG4gICAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgICBwb3MgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gdGhpcy5uZXh0TG9hZFBvc2l0aW9uO1xuICAgICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhLFxuICAgICAgICB2aWRlb0J1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXIgPyB0aGlzLnZpZGVvQnVmZmVyIDogdGhpcy5tZWRpYSxcbiAgICAgICAgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBwb3MsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKSxcbiAgICAgICAgbWFpbkJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh2aWRlb0J1ZmZlciwgcG9zLCBjb25maWcubWF4QnVmZmVySG9sZSksXG4gICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuLFxuICAgICAgICBidWZmZXJFbmQgPSBidWZmZXJJbmZvLmVuZCxcbiAgICAgICAgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXMsXG4gICAgICAgIC8vIGVuc3VyZSB3ZSBidWZmZXIgYXQgbGVhc3QgY29uZmlnLm1heEJ1ZmZlckxlbmd0aCAoZGVmYXVsdCAzMHMpIG9yIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggKGRlZmF1bHQ6IDYwMHMpXG4gICAgICAgIC8vIHdoaWNoZXZlciBpcyBzbWFsbGVyLlxuICAgICAgICAvLyBvbmNlIHdlIHJlYWNoIHRoYXQgdGhyZXNob2xkLCBkb24ndCBidWZmZXIgbW9yZSB0aGFuIHZpZGVvIChtYWluQnVmZmVySW5mby5sZW4pXG4gICAgICAgIG1heENvbmZpZ0J1ZmZlciA9IE1hdGgubWluKGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgsIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgpLFxuICAgICAgICBtYXhCdWZMZW4gPSBNYXRoLm1heChtYXhDb25maWdCdWZmZXIsIG1haW5CdWZmZXJJbmZvLmxlbiksXG4gICAgICAgIGF1ZGlvU3dpdGNoID0gdGhpcy5hdWRpb1N3aXRjaCxcbiAgICAgICAgdHJhY2tJZCA9IHRoaXMudHJhY2tJZDtcblxuICAgICAgICAvLyBpZiBidWZmZXIgbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhCdWZMZW4gdHJ5IHRvIGxvYWQgYSBuZXcgZnJhZ21lbnRcbiAgICAgIGlmICgoYnVmZmVyTGVuIDwgbWF4QnVmTGVuIHx8IGF1ZGlvU3dpdGNoKSAmJiB0cmFja0lkIDwgdHJhY2tzLmxlbmd0aCkge1xuICAgICAgICB0cmFja0RldGFpbHMgPSB0cmFja3NbdHJhY2tJZF0uZGV0YWlscztcbiAgICAgICAgLy8gaWYgdHJhY2sgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciB0cmFjayByZXRyaWV2YWxcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFja0RldGFpbHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfVFJBQ0s7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWF1ZGlvU3dpdGNoICYmIHRoaXMuX3N0cmVhbUVuZGVkKGJ1ZmZlckluZm8sIHRyYWNrRGV0YWlscykpIHtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9FT1MsIHsgdHlwZTogJ2F1ZGlvJyB9KTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRU5ERUQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAgICAgbGV0IGZyYWdtZW50cyA9IHRyYWNrRGV0YWlscy5mcmFnbWVudHMsXG4gICAgICAgICAgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgc3RhcnQgPSBmcmFnbWVudHNbMF0uc3RhcnQsXG4gICAgICAgICAgZW5kID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXS5zdGFydCArIGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uZHVyYXRpb24sXG4gICAgICAgICAgZnJhZztcblxuICAgICAgICAgIC8vIFdoZW4gc3dpdGNoaW5nIGF1ZGlvIHRyYWNrLCByZWxvYWQgYXVkaW8gYXMgY2xvc2UgYXMgcG9zc2libGUgdG8gY3VycmVudFRpbWVcbiAgICAgICAgaWYgKGF1ZGlvU3dpdGNoKSB7XG4gICAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5saXZlICYmICF0cmFja0RldGFpbHMuUFRTS25vd24pIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ3N3aXRjaGluZyBhdWRpb3RyYWNrLCBsaXZlIHN0cmVhbSwgdW5rbm93biBQVFMsbG9hZCBmaXJzdCBmcmFnbWVudCcpO1xuICAgICAgICAgICAgYnVmZmVyRW5kID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyRW5kID0gcG9zO1xuICAgICAgICAgICAgLy8gaWYgY3VycmVudFRpbWUgKHBvcykgaXMgbGVzcyB0aGFuIGFsdCBhdWRpbyBwbGF5bGlzdCBzdGFydCB0aW1lLCBpdCBtZWFucyB0aGF0IGFsdCBhdWRpbyBpcyBhaGVhZCBvZiBjdXJyZW50VGltZVxuICAgICAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5QVFNLbm93biAmJiBwb3MgPCBzdGFydCkge1xuICAgICAgICAgICAgICAvLyBpZiBldmVyeXRoaW5nIGlzIGJ1ZmZlcmVkIGZyb20gcG9zIHRvIHN0YXJ0IG9yIGlmIGF1ZGlvIGJ1ZmZlciB1cGZyb250LCBsZXQncyBzZWVrIHRvIHN0YXJ0XG4gICAgICAgICAgICAgIGlmIChidWZmZXJJbmZvLmVuZCA+IHN0YXJ0IHx8IGJ1ZmZlckluZm8ubmV4dFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnYWx0IGF1ZGlvIHRyYWNrIGFoZWFkIG9mIG1haW4gdHJhY2ssIHNlZWsgdG8gc3RhcnQgb2YgYWx0IGF1ZGlvIHRyYWNrJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0ICsgMC4wNTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5pbml0U2VnbWVudCAmJiAhdHJhY2tEZXRhaWxzLmluaXRTZWdtZW50LmRhdGEpIHtcbiAgICAgICAgICBmcmFnID0gdHJhY2tEZXRhaWxzLmluaXRTZWdtZW50O1xuICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYnJhY2Utc3R5bGVcbiAgICAgICAgLy8gaWYgYnVmZmVyRW5kIGJlZm9yZSBzdGFydCBvZiBwbGF5bGlzdCwgbG9hZCBmaXJzdCBmcmFnbWVudFxuICAgICAgICBlbHNlIGlmIChidWZmZXJFbmQgPD0gc3RhcnQpIHtcbiAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICAgIGlmICh0aGlzLnZpZGVvVHJhY2tDQyAhPT0gbnVsbCAmJiBmcmFnLmNjICE9PSB0aGlzLnZpZGVvVHJhY2tDQykge1xuICAgICAgICAgICAgLy8gRW5zdXJlIHdlIGZpbmQgYSBmcmFnbWVudCB3aGljaCBtYXRjaGVzIHRoZSBjb250aW51aXR5IG9mIHRoZSB2aWRlbyB0cmFja1xuICAgICAgICAgICAgZnJhZyA9IGZpbmRGcmFnV2l0aENDKGZyYWdtZW50cywgdGhpcy52aWRlb1RyYWNrQ0MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHJhY2tEZXRhaWxzLmxpdmUgJiYgZnJhZy5sb2FkSWR4ICYmIGZyYWcubG9hZElkeCA9PT0gdGhpcy5mcmFnTG9hZElkeCkge1xuICAgICAgICAgICAgLy8gd2UganVzdCBsb2FkZWQgdGhpcyBmaXJzdCBmcmFnbWVudCwgYW5kIHdlIGFyZSBzdGlsbCBsYWdnaW5nIGJlaGluZCB0aGUgc3RhcnQgb2YgdGhlIGxpdmUgcGxheWxpc3RcbiAgICAgICAgICAgIC8vIGxldCdzIGZvcmNlIHNlZWsgdG8gc3RhcnRcbiAgICAgICAgICAgIGNvbnN0IG5leHRCdWZmZXJlZCA9IGJ1ZmZlckluZm8ubmV4dFN0YXJ0ID8gYnVmZmVySW5mby5uZXh0U3RhcnQgOiBzdGFydDtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYG5vIGFsdCBhdWRpbyBhdmFpbGFibGUgQGN1cnJlbnRUaW1lOiR7dGhpcy5tZWRpYS5jdXJyZW50VGltZX0sIHNlZWtpbmcgQCR7bmV4dEJ1ZmZlcmVkICsgMC4wNX1gKTtcbiAgICAgICAgICAgIHRoaXMubWVkaWEuY3VycmVudFRpbWUgPSBuZXh0QnVmZmVyZWQgKyAwLjA1O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgZm91bmRGcmFnO1xuICAgICAgICAgIGxldCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICAgICAgY29uc3QgZnJhZ05leHQgPSBmcmFnUHJldmlvdXMgPyBmcmFnbWVudHNbZnJhZ1ByZXZpb3VzLnNuIC0gZnJhZ21lbnRzWzBdLnNuICsgMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgbGV0IGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdCA9IChjYW5kaWRhdGUpID0+IHtcbiAgICAgICAgICAgIC8vIG9mZnNldCBzaG91bGQgYmUgd2l0aGluIGZyYWdtZW50IGJvdW5kYXJ5IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2VcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gY29wZSB3aXRoIHNpdHVhdGlvbnMgbGlrZVxuICAgICAgICAgICAgLy8gYnVmZmVyRW5kID0gOS45OTFcbiAgICAgICAgICAgIC8vIGZyYWdbw5hdIDogWzAsMTBdXG4gICAgICAgICAgICAvLyBmcmFnWzFdIDogWzEwLDIwXVxuICAgICAgICAgICAgLy8gYnVmZmVyRW5kIGlzIHdpdGhpbiBmcmFnWzBdIHJhbmdlIC4uLiBhbHRob3VnaCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgaXMgdG8gcmV0dXJuIGZyYWdbMV0gaGVyZVxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgIGZyYWcgc3RhcnQgICAgICAgICAgICAgICBmcmFnIHN0YXJ0K2R1cmF0aW9uXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICA8LS0tPiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tPlxuICAgICAgICAgICAgLy8gIC4uLi0tLS0tLS0tPjwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT48LS0tLS0tLS0tLi4uLlxuICAgICAgICAgICAgLy8gcHJldmlvdXMgZnJhZyAgICAgICAgIG1hdGNoaW5nIGZyYWdtZW50ICAgICAgICAgbmV4dCBmcmFnXG4gICAgICAgICAgICAvLyAgcmV0dXJuIC0xICAgICAgICAgICAgIHJldHVybiAwICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZyhgbGV2ZWwvc24vc3RhcnQvZW5kL2J1ZkVuZDoke2xldmVsfS8ke2NhbmRpZGF0ZS5zbn0vJHtjYW5kaWRhdGUuc3RhcnR9LyR7KGNhbmRpZGF0ZS5zdGFydCtjYW5kaWRhdGUuZHVyYXRpb24pfS8ke2J1ZmZlckVuZH1gKTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgbG9va3VwIHRvbGVyYW5jZSB0byBiZSBzbWFsbCBlbm91Z2ggdG8gZGV0ZWN0IHRoZSBjdXJyZW50IHNlZ21lbnQgLSBlbnN1cmVzIHdlIGRvbid0IHNraXAgb3ZlciB2ZXJ5IHNtYWxsIHNlZ21lbnRzXG4gICAgICAgICAgICBsZXQgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmICgoY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlKSA8PSBidWZmZXJFbmQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5zdGFydCAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IGJ1ZmZlckVuZCAmJiBjYW5kaWRhdGUuc3RhcnQpIHtcbiAgICAgICAgICAgICAgLy8gaWYgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB3aWxsIGhhdmUgbmVnYXRpdmUgdmFsdWUgdGhlbiBkb24ndCByZXR1cm4gLTEgZm9yIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGJ1ZmZlckVuZCA8IGVuZCkge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlckVuZCA+IGVuZCAtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByZWZlciB0aGUgbmV4dCBmcmFnbWVudCBpZiBpdCdzIHdpdGhpbiB0b2xlcmFuY2VcbiAgICAgICAgICAgIGlmIChmcmFnTmV4dCAmJiAhZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGZyYWdOZXh0KSkge1xuICAgICAgICAgICAgICBmb3VuZEZyYWcgPSBmcmFnTmV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvdW5kRnJhZyA9IEJpbmFyeVNlYXJjaC5zZWFyY2goZnJhZ21lbnRzLCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByZWFjaCBlbmQgb2YgcGxheWxpc3RcbiAgICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmb3VuZEZyYWcpIHtcbiAgICAgICAgICAgIGZyYWcgPSBmb3VuZEZyYWc7XG4gICAgICAgICAgICBzdGFydCA9IGZvdW5kRnJhZy5zdGFydDtcbiAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2ZpbmQgU04gbWF0Y2hpbmcgd2l0aCBwb3M6JyArICBidWZmZXJFbmQgKyAnOicgKyBmcmFnLnNuKTtcbiAgICAgICAgICAgIGlmIChmcmFnUHJldmlvdXMgJiYgZnJhZy5sZXZlbHMgPT09IGZyYWdQcmV2aW91cy5sZXZlbHMgJiYgZnJhZy5zbiA9PT0gZnJhZ1ByZXZpb3VzLnNuKSB7XG4gICAgICAgICAgICAgIGlmIChmcmFnLnNuIDwgdHJhY2tEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgICAgICAgZnJhZyA9IGZyYWdtZW50c1tmcmFnLnNuICsgMSAtIHRyYWNrRGV0YWlscy5zdGFydFNOXTtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBTTiBqdXN0IGxvYWRlZCwgbG9hZCBuZXh0IG9uZTogJHtmcmFnLnNufWApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyYWcgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnICAgICAgbG9hZGluZyBmcmFnICcgKyBpICsnLHBvcy9idWZFbmQ6JyArIHBvcy50b0ZpeGVkKDMpICsgJy8nICsgYnVmZmVyRW5kLnRvRml4ZWQoMykpO1xuICAgICAgICAgIGlmIChmcmFnLmVuY3J5cHRlZCkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgTG9hZGluZyBrZXkgZm9yICR7ZnJhZy5zbn0gb2YgWyR7dHJhY2tEZXRhaWxzLnN0YXJ0U059ICwke3RyYWNrRGV0YWlscy5lbmRTTn1dLHRyYWNrICR7dHJhY2tJZH1gKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FESU5HLCB7IGZyYWc6IGZyYWcgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYExvYWRpbmcgJHtmcmFnLnNufSwgY2M6ICR7ZnJhZy5jY30gb2YgWyR7dHJhY2tEZXRhaWxzLnN0YXJ0U059ICwke3RyYWNrRGV0YWlscy5lbmRTTn1dLHRyYWNrICR7dHJhY2tJZH0sIGN1cnJlbnRUaW1lOiR7cG9zfSxidWZmZXJFbmQ6JHtidWZmZXJFbmQudG9GaXhlZCgzKX1gKTtcbiAgICAgICAgICAgIC8vIG9ubHkgbG9hZCBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkIG9yIGlmIGluIGF1ZGlvIHN3aXRjaFxuICAgICAgICAgICAgLy8gd2UgZm9yY2UgYSBmcmFnIGxvYWRpbmcgaW4gYXVkaW8gc3dpdGNoIGFzIGZyYWdtZW50IHRyYWNrZXIgbWlnaHQgbm90IGhhdmUgZXZpY3RlZCBwcmV2aW91cyBmcmFncyBpbiBjYXNlIG9mIHF1aWNrIGF1ZGlvIHN3aXRjaFxuICAgICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgICAgICAgICBpZiAoYXVkaW9Td2l0Y2ggfHwgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZykgPT09IEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZnJhZy5zbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnLnN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRElORywgeyBmcmFnIH0pO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTdGF0ZS5XQUlUSU5HX1RSQUNLOlxuICAgICAgdHJhY2sgPSB0aGlzLnRyYWNrc1t0aGlzLnRyYWNrSWRdO1xuICAgICAgLy8gY2hlY2sgaWYgcGxheWxpc3QgaXMgYWxyZWFkeSBsb2FkZWRcbiAgICAgIGlmICh0cmFjayAmJiB0cmFjay5kZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdmFyIHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlO1xuICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgdmFyIGlzU2Vla2luZyA9IG1lZGlhICYmIG1lZGlhLnNlZWtpbmc7XG4gICAgICAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgaWYgKCFyZXRyeURhdGUgfHwgKG5vdyA+PSByZXRyeURhdGUpIHx8IGlzU2Vla2luZykge1xuICAgICAgICBsb2dnZXIubG9nKCdhdWRpb1N0cmVhbUNvbnRyb2xsZXI6IHJldHJ5RGF0ZSByZWFjaGVkLCBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTOlxuICAgICAgY29uc3QgdmlkZW9UcmFja0NDID0gdGhpcy52aWRlb1RyYWNrQ0M7XG4gICAgICBpZiAodGhpcy5pbml0UFRTW3ZpZGVvVHJhY2tDQ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gRW5zdXJlIHdlIGRvbid0IGdldCBzdHVjayBpbiB0aGUgV0FJVElOR19JTklUX1BUUyBzdGF0ZSBpZiB0aGUgd2FpdGluZyBmcmFnIENDIGRvZXNuJ3QgbWF0Y2ggYW55IGluaXRQVFNcbiAgICAgIGNvbnN0IHdhaXRpbmdGcmFnID0gdGhpcy53YWl0aW5nRnJhZ21lbnQ7XG4gICAgICBpZiAod2FpdGluZ0ZyYWcpIHtcbiAgICAgICAgY29uc3Qgd2FpdGluZ0ZyYWdDQyA9IHdhaXRpbmdGcmFnLmZyYWcuY2M7XG4gICAgICAgIGlmICh2aWRlb1RyYWNrQ0MgIT09IHdhaXRpbmdGcmFnQ0MpIHtcbiAgICAgICAgICB0cmFjayA9IHRoaXMudHJhY2tzW3RoaXMudHJhY2tJZF07XG4gICAgICAgICAgaWYgKHRyYWNrLmRldGFpbHMgJiYgdHJhY2suZGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgV2FpdGluZyBmcmFnbWVudCBDQyAoJHt3YWl0aW5nRnJhZ0NDfSkgZG9lcyBub3QgbWF0Y2ggdmlkZW8gdHJhY2sgQ0MgKCR7dmlkZW9UcmFja0NDfSlgKTtcbiAgICAgICAgICAgIHRoaXMud2FpdGluZ0ZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICAgIHRoaXMub25GcmFnTG9hZGVkKHRoaXMud2FpdGluZ0ZyYWdtZW50KTtcbiAgICAgICAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICBjYXNlIFN0YXRlLlNUT1BQRUQ6XG4gICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkc6XG4gICAgY2FzZSBTdGF0ZS5QQVJTSU5HOlxuICAgIGNhc2UgU3RhdGUuUEFSU0VEOlxuICAgIGNhc2UgU3RhdGUuRU5ERUQ6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgb25NZWRpYUF0dGFjaGVkIChkYXRhKSB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub25NZWRpYVNlZWtpbmcuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9udmVuZGVkID0gdGhpcy5vbk1lZGlhRW5kZWQuYmluZCh0aGlzKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAodGhpcy50cmFja3MgJiYgY29uZmlnLmF1dG9TdGFydExvYWQpIHtcbiAgICAgIHRoaXMuc3RhcnRMb2FkKGNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICBvbk1lZGlhRGV0YWNoaW5nICgpIHtcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSAmJiBtZWRpYS5lbmRlZCkge1xuICAgICAgbG9nZ2VyLmxvZygnTVNFIGRldGFjaGluZyBhbmQgdmlkZW8gZW5kZWQsIHJlc2V0IHN0YXJ0UG9zaXRpb24nKTtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdmlkZW8gbGlzdGVuZXJzXG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9udnNlZWtlZCA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gIH1cblxuICBvbkF1ZGlvVHJhY2tzVXBkYXRlZCAoZGF0YSkge1xuICAgIGxvZ2dlci5sb2coJ2F1ZGlvIHRyYWNrcyB1cGRhdGVkJyk7XG4gICAgdGhpcy50cmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzO1xuICB9XG5cbiAgb25BdWRpb1RyYWNrU3dpdGNoaW5nIChkYXRhKSB7XG4gICAgLy8gaWYgYW55IFVSTCBmb3VuZCBvbiBuZXcgYXVkaW8gdHJhY2ssIGl0IGlzIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgIGxldCBhbHRBdWRpbyA9ICEhZGF0YS51cmw7XG4gICAgdGhpcy50cmFja0lkID0gZGF0YS5pZDtcblxuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVVTRUQ7XG4gICAgdGhpcy53YWl0aW5nRnJhZ21lbnQgPSBudWxsO1xuICAgIC8vIGRlc3Ryb3kgdXNlbGVzcyBkZW11eGVyIHdoZW4gc3dpdGNoaW5nIGF1ZGlvIHRvIG1haW5cbiAgICBpZiAoIWFsdEF1ZGlvKSB7XG4gICAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZGVtdXhlciA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN3aXRjaGluZyB0byBhdWRpbyB0cmFjaywgc3RhcnQgdGltZXIgaWYgbm90IGFscmVhZHkgc3RhcnRlZFxuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICB9XG5cbiAgICAvLyBzaG91bGQgd2Ugc3dpdGNoIHRyYWNrcyA/XG4gICAgaWYgKGFsdEF1ZGlvKSB7XG4gICAgICB0aGlzLmF1ZGlvU3dpdGNoID0gdHJ1ZTtcbiAgICAgIC8vIG1haW4gYXVkaW8gdHJhY2sgYXJlIGhhbmRsZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXIsIGp1c3QgZG8gc29tZXRoaW5nIGlmIHN3aXRjaGluZyB0byBhbHQgYXVkaW8gdHJhY2tcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uQXVkaW9UcmFja0xvYWRlZCAoZGF0YSkge1xuICAgIGxldCBuZXdEZXRhaWxzID0gZGF0YS5kZXRhaWxzLFxuICAgICAgdHJhY2tJZCA9IGRhdGEuaWQsXG4gICAgICB0cmFjayA9IHRoaXMudHJhY2tzW3RyYWNrSWRdLFxuICAgICAgZHVyYXRpb24gPSBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb24sXG4gICAgICBzbGlkaW5nID0gMDtcblxuICAgIGxvZ2dlci5sb2coYHRyYWNrICR7dHJhY2tJZH0gbG9hZGVkIFske25ld0RldGFpbHMuc3RhcnRTTn0sJHtuZXdEZXRhaWxzLmVuZFNOfV0sZHVyYXRpb246JHtkdXJhdGlvbn1gKTtcblxuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgIGxldCBjdXJEZXRhaWxzID0gdHJhY2suZGV0YWlscztcbiAgICAgIGlmIChjdXJEZXRhaWxzICYmIG5ld0RldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gd2UgYWxyZWFkeSBoYXZlIGRldGFpbHMgZm9yIHRoYXQgbGV2ZWwsIG1lcmdlIHRoZW1cbiAgICAgICAgTGV2ZWxIZWxwZXIubWVyZ2VEZXRhaWxzKGN1ckRldGFpbHMsIG5ld0RldGFpbHMpO1xuICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gdGhpcy5saXZlU3luY1Bvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHNsaWRpbmcsIGN1ckRldGFpbHMpO1xuICAgICAgICBpZiAobmV3RGV0YWlscy5QVFNLbm93bikge1xuICAgICAgICAgIGxvZ2dlci5sb2coYGxpdmUgYXVkaW8gcGxheWxpc3Qgc2xpZGluZzoke3NsaWRpbmcudG9GaXhlZCgzKX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdsaXZlIGF1ZGlvIHBsYXlsaXN0IC0gb3V0ZGF0ZWQgUFRTLCB1bmtub3duIHNsaWRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IGZhbHNlO1xuICAgICAgICBsb2dnZXIubG9nKCdsaXZlIGF1ZGlvIHBsYXlsaXN0IC0gZmlyc3QgbG9hZCwgdW5rbm93biBzbGlkaW5nJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcbiAgICB9XG4gICAgdHJhY2suZGV0YWlscyA9IG5ld0RldGFpbHM7XG5cbiAgICAvLyBjb21wdXRlIHN0YXJ0IHBvc2l0aW9uXG4gICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb24gaWYgc2V0IHRvIC0xLiB1c2UgaXQgc3RyYWlnaHQgYXdheSBpZiB2YWx1ZSBpcyBkZWZpbmVkXG4gICAgICBpZiAodGhpcy5zdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICAvLyBmaXJzdCwgY2hlY2sgaWYgc3RhcnQgdGltZSBvZmZzZXQgaGFzIGJlZW4gc2V0IGluIHBsYXlsaXN0LCBpZiB5ZXMsIHVzZSB0aGlzIHZhbHVlXG4gICAgICAgIGxldCBzdGFydFRpbWVPZmZzZXQgPSBuZXdEZXRhaWxzLnN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShzdGFydFRpbWVPZmZzZXQpKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgc3RhcnQgdGltZSBvZmZzZXQgZm91bmQgaW4gcGxheWxpc3QsIGFkanVzdCBzdGFydFBvc2l0aW9uIHRvICR7c3RhcnRUaW1lT2Zmc2V0fWApO1xuICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgfVxuICAgIC8vIG9ubHkgc3dpdGNoIGJhdGNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciB0cmFjayB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX1RSQUNLKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBvbktleUxvYWRlZCAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLktFWV9MT0FESU5HKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0xvYWRlZCAoZGF0YSkge1xuICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQsXG4gICAgICBmcmFnTG9hZGVkID0gZGF0YS5mcmFnO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcgJiZcbiAgICAgICAgZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZnJhZ0xvYWRlZC50eXBlID09PSAnYXVkaW8nICYmXG4gICAgICAgIGZyYWdMb2FkZWQubGV2ZWxzID09PSBmcmFnQ3VycmVudC5sZXZlbHMgJiZcbiAgICAgICAgZnJhZ0xvYWRlZC5zbiA9PT0gZnJhZ0N1cnJlbnQuc24pIHtcbiAgICAgIGxldCB0cmFjayA9IHRoaXMudHJhY2tzW3RoaXMudHJhY2tJZF0sXG4gICAgICAgIGRldGFpbHMgPSB0cmFjay5kZXRhaWxzLFxuICAgICAgICBkdXJhdGlvbiA9IGRldGFpbHMudG90YWxkdXJhdGlvbixcbiAgICAgICAgdHJhY2tJZCA9IGZyYWdDdXJyZW50LmxldmVscyxcbiAgICAgICAgc24gPSBmcmFnQ3VycmVudC5zbixcbiAgICAgICAgY2MgPSBmcmFnQ3VycmVudC5jYyxcbiAgICAgICAgYXVkaW9Db2RlYyA9IHRoaXMuY29uZmlnLmRlZmF1bHRBdWRpb0NvZGVjIHx8IHRyYWNrLmF1ZGlvQ29kZWMgfHwgJ21wNGEuNDAuMicsXG4gICAgICAgIHN0YXRzID0gdGhpcy5zdGF0cyA9IGRhdGEuc3RhdHM7XG4gICAgICBpZiAoc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG5cbiAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBkZXRhaWxzLmluaXRTZWdtZW50LmRhdGEgPSBkYXRhLnBheWxvYWQ7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19CVUZGRVJFRCwgeyBzdGF0czogc3RhdHMsIGZyYWc6IGZyYWdDdXJyZW50LCBpZDogJ2F1ZGlvJyB9KTtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICAgICAgLy8gdHJhbnNtdXggdGhlIE1QRUctVFMgZGF0YSB0byBJU08tQk1GRiBzZWdtZW50c1xuICAgICAgICB0aGlzLmFwcGVuZGVkID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5kZW11eGVyKSB7XG4gICAgICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXIodGhpcy5obHMsICdhdWRpbycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB2aWRlbyBpbml0UFRTXG4gICAgICAgIC8vIElmIG5vdCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGl0XG4gICAgICAgIGxldCBpbml0UFRTID0gdGhpcy5pbml0UFRTW2NjXTtcbiAgICAgICAgbGV0IGluaXRTZWdtZW50RGF0YSA9IGRldGFpbHMuaW5pdFNlZ21lbnQgPyBkZXRhaWxzLmluaXRTZWdtZW50LmRhdGEgOiBbXTtcbiAgICAgICAgaWYgKGRldGFpbHMuaW5pdFNlZ21lbnQgfHwgaW5pdFBUUyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICBsb2dnZXIubG9nKGBEZW11eGluZyAke3NufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgICAgICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpXG4gICAgICAgICAgbGV0IGFjY3VyYXRlVGltZU9mZnNldCA9IGZhbHNlOyAvLyBkZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmU7XG4gICAgICAgICAgdGhpcy5kZW11eGVyLnB1c2goZGF0YS5wYXlsb2FkLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIG51bGwsIGZyYWdDdXJyZW50LCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBpbml0UFRTKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGB1bmtub3duIHZpZGVvIFBUUyBmb3IgY29udGludWl0eSBjb3VudGVyICR7Y2N9LCB3YWl0aW5nIGZvciB2aWRlbyBQVFMgYmVmb3JlIGRlbXV4aW5nIGF1ZGlvIGZyYWcgJHtzbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfWApO1xuICAgICAgICAgIHRoaXMud2FpdGluZ0ZyYWdtZW50ID0gZGF0YTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19JTklUX1BUUztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICB9XG5cbiAgb25GcmFnUGFyc2luZ0luaXRTZWdtZW50IChkYXRhKSB7XG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdhdWRpbycgJiZcbiAgICAgICAgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgZnJhZ05ldy5sZXZlbHMgPT09IGZyYWdDdXJyZW50LmxldmVscyAmJlxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICBsZXQgdHJhY2tzID0gZGF0YS50cmFja3MsIHRyYWNrO1xuXG4gICAgICAvLyBkZWxldGUgYW55IHZpZGVvIHRyYWNrIGZvdW5kIG9uIGF1ZGlvIGRlbXV4ZXJcbiAgICAgIGlmICh0cmFja3MudmlkZW8pIHtcbiAgICAgICAgZGVsZXRlIHRyYWNrcy52aWRlbztcbiAgICAgIH1cblxuICAgICAgLy8gaW5jbHVkZSBsZXZlbENvZGVjIGluIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3NcbiAgICAgIHRyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgIHRyYWNrLmxldmVsQ29kZWMgPSB0cmFjay5jb2RlYztcbiAgICAgICAgdHJhY2suaWQgPSBkYXRhLmlkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9DT0RFQ1MsIHRyYWNrcyk7XG4gICAgICAgIGxvZ2dlci5sb2coYGF1ZGlvIHRyYWNrOmF1ZGlvLGNvbnRhaW5lcjoke3RyYWNrLmNvbnRhaW5lcn0sY29kZWNzW2xldmVsL3BhcnNlZF09WyR7dHJhY2subGV2ZWxDb2RlY30vJHt0cmFjay5jb2RlY31dYCk7XG4gICAgICAgIGxldCBpbml0U2VnbWVudCA9IHRyYWNrLmluaXRTZWdtZW50O1xuICAgICAgICBpZiAoaW5pdFNlZ21lbnQpIHtcbiAgICAgICAgICBsZXQgYXBwZW5kT2JqID0geyB0eXBlOiAnYXVkaW8nLCBkYXRhOiBpbml0U2VnbWVudCwgcGFyZW50OiAnYXVkaW8nLCBjb250ZW50OiAnaW5pdFNlZ21lbnQnIH07XG4gICAgICAgICAgaWYgKHRoaXMuYXVkaW9Td2l0Y2gpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RhdGEgPSBbYXBwZW5kT2JqXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICAvLyBhcm0gcGVuZGluZyBCdWZmZXJpbmcgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIGEgc2VnbWVudFxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywgYXBwZW5kT2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nRGF0YSAoZGF0YSkge1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBjb25zdCBmcmFnTmV3ID0gZGF0YS5mcmFnO1xuICAgIGlmIChmcmFnQ3VycmVudCAmJlxuICAgICAgICBkYXRhLmlkID09PSAnYXVkaW8nICYmXG4gICAgICAgIGRhdGEudHlwZSA9PT0gJ2F1ZGlvJyAmJlxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBmcmFnTmV3LmxldmVscyA9PT0gZnJhZ0N1cnJlbnQubGV2ZWxzICYmXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIGxldCB0cmFja0lkID0gdGhpcy50cmFja0lkLFxuICAgICAgICB0cmFjayA9IHRoaXMudHJhY2tzW3RyYWNrSWRdLFxuICAgICAgICBobHMgPSB0aGlzLmhscztcblxuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZGF0YS5lbmRQVFMpKSB7XG4gICAgICAgIGRhdGEuZW5kUFRTID0gZGF0YS5zdGFydFBUUyArIGZyYWdDdXJyZW50LmR1cmF0aW9uO1xuICAgICAgICBkYXRhLmVuZERUUyA9IGRhdGEuc3RhcnREVFMgKyBmcmFnQ3VycmVudC5kdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgZnJhZ0N1cnJlbnQuYWRkRWxlbWVudGFyeVN0cmVhbShGcmFnbWVudC5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8pO1xuXG4gICAgICBsb2dnZXIubG9nKGBwYXJzZWQgJHtkYXRhLnR5cGV9LFBUUzpbJHtkYXRhLnN0YXJ0UFRTLnRvRml4ZWQoMyl9LCR7ZGF0YS5lbmRQVFMudG9GaXhlZCgzKX1dLERUUzpbJHtkYXRhLnN0YXJ0RFRTLnRvRml4ZWQoMyl9LyR7ZGF0YS5lbmREVFMudG9GaXhlZCgzKX1dLG5iOiR7ZGF0YS5uYn1gKTtcbiAgICAgIExldmVsSGVscGVyLnVwZGF0ZUZyYWdQVFNEVFModHJhY2suZGV0YWlscywgZnJhZ0N1cnJlbnQsIGRhdGEuc3RhcnRQVFMsIGRhdGEuZW5kUFRTKTtcblxuICAgICAgbGV0IGF1ZGlvU3dpdGNoID0gdGhpcy5hdWRpb1N3aXRjaCwgbWVkaWEgPSB0aGlzLm1lZGlhLCBhcHBlbmRPbkJ1ZmZlckZsdXNoID0gZmFsc2U7XG4gICAgICAvLyBPbmx5IGZsdXNoIGF1ZGlvIGZyb20gb2xkIGF1ZGlvIHRyYWNrcyB3aGVuIFBUUyBpcyBrbm93biBvbiBuZXcgYXVkaW8gdHJhY2tcbiAgICAgIGlmIChhdWRpb1N3aXRjaCAmJiBtZWRpYSkge1xuICAgICAgICBpZiAobWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgICAgIGxldCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3N3aXRjaGluZyBhdWRpbyB0cmFjayA6IGN1cnJlbnRUaW1lOicgKyBjdXJyZW50VGltZSk7XG4gICAgICAgICAgaWYgKGN1cnJlbnRUaW1lID49IGRhdGEuc3RhcnRQVFMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ3N3aXRjaGluZyBhdWRpbyB0cmFjayA6IGZsdXNoaW5nIGFsbCBhdWRpbycpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJVRkZFUl9GTFVTSElORztcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9GTFVTSElORywgeyBzdGFydE9mZnNldDogMCwgZW5kT2Zmc2V0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHR5cGU6ICdhdWRpbycgfSk7XG4gICAgICAgICAgICBhcHBlbmRPbkJ1ZmZlckZsdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIExldHMgYW5ub3VuY2UgdGhhdCB0aGUgaW5pdGlhbCBhdWRpbyB0cmFjayBzd2l0Y2ggZmx1c2ggb2NjdXJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELCB7IGlkOiB0cmFja0lkIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBMZXRzIGFubm91bmNlIHRoYXQgdGhlIGluaXRpYWwgYXVkaW8gdHJhY2sgc3dpdGNoIGZsdXNoIG9jY3VyXG4gICAgICAgICAgdGhpcy5hdWRpb1N3aXRjaCA9IGZhbHNlO1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELCB7IGlkOiB0cmFja0lkIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBwZW5kaW5nRGF0YSA9IHRoaXMucGVuZGluZ0RhdGE7XG5cbiAgICAgIGlmICghcGVuZGluZ0RhdGEpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ0FwcGFyZW50bHkgYXR0ZW1wdCB0byBlbnF1ZXVlIG1lZGlhIHBheWxvYWQgd2l0aG91dCBjb2RlYyBpbml0aWFsaXphdGlvbiBkYXRhIHVwZnJvbnQnKTtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogbnVsbCwgZmF0YWw6IHRydWUgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmF1ZGlvU3dpdGNoKSB7XG4gICAgICAgIFtkYXRhLmRhdGExLCBkYXRhLmRhdGEyXS5mb3JFYWNoKGJ1ZmZlciA9PiB7XG4gICAgICAgICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBwZW5kaW5nRGF0YS5wdXNoKHsgdHlwZTogZGF0YS50eXBlLCBkYXRhOiBidWZmZXIsIHBhcmVudDogJ2F1ZGlvJywgY29udGVudDogJ2RhdGEnIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghYXBwZW5kT25CdWZmZXJGbHVzaCAmJiBwZW5kaW5nRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBwZW5kaW5nRGF0YS5mb3JFYWNoKGFwcGVuZE9iaiA9PiB7XG4gICAgICAgICAgICAvLyBvbmx5IGFwcGVuZCBpbiBQQVJTSU5HIHN0YXRlIChyYXRpb25hbGUgaXMgdGhhdCBhbiBhcHBlbmRpbmcgZXJyb3IgY291bGQgaGFwcGVuIHN5bmNocm9ub3VzbHkgb24gZmlyc3Qgc2VnbWVudCBhcHBlbmRpbmcpXG4gICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgaXQgaXMgdXNlbGVzcyB0byBhcHBlbmQgZm9sbG93aW5nIHNlZ21lbnRzXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICAgICAgICAvLyBhcm0gcGVuZGluZyBCdWZmZXJpbmcgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIGEgc2VnbWVudFxuICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsIGFwcGVuZE9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nRGF0YSA9IFtdO1xuICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdQYXJzZWQgKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgY29uc3QgZnJhZ05ldyA9IGRhdGEuZnJhZztcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5pZCA9PT0gJ2F1ZGlvJyAmJlxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBmcmFnTmV3LmxldmVscyA9PT0gZnJhZ0N1cnJlbnQubGV2ZWxzICYmXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIHRoaXMuc3RhdHMudHBhcnNlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcbiAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcbiAgICB9XG4gIH1cblxuICBvbkJ1ZmZlclJlc2V0ICgpIHtcbiAgICAvLyByZXNldCByZWZlcmVuY2UgdG8gc291cmNlYnVmZmVyc1xuICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gIH1cblxuICBvbkJ1ZmZlckNyZWF0ZWQgKGRhdGEpIHtcbiAgICBsZXQgYXVkaW9UcmFjayA9IGRhdGEudHJhY2tzLmF1ZGlvO1xuICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gYXVkaW9UcmFjay5idWZmZXI7XG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGRhdGEudHJhY2tzLnZpZGVvKSB7XG4gICAgICB0aGlzLnZpZGVvQnVmZmVyID0gZGF0YS50cmFja3MudmlkZW8uYnVmZmVyO1xuICAgIH1cbiAgfVxuXG4gIG9uQnVmZmVyQXBwZW5kZWQgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdhdWRpbycpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIGlmIChzdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fCBzdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiBhcHBlbmRlZFxuICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSAoZGF0YS5wZW5kaW5nID4gMCk7XG4gICAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY2hlY2tBcHBlbmRlZFBhcnNlZCAoKSB7XG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQgJiYgKCF0aGlzLmFwcGVuZGVkIHx8ICF0aGlzLnBlbmRpbmdCdWZmZXJpbmcpKSB7XG4gICAgICBsZXQgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQsIHN0YXRzID0gdGhpcy5zdGF0cywgaGxzID0gdGhpcy5obHM7XG4gICAgICBpZiAoZnJhZykge1xuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICAgIHN0YXRzLnRidWZmZXJlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7IHN0YXRzOiBzdGF0cywgZnJhZzogZnJhZywgaWQ6ICdhdWRpbycgfSk7XG4gICAgICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgYXVkaW8gYnVmZmVyZWQgOiAke1RpbWVSYW5nZXMudG9TdHJpbmcobWVkaWEuYnVmZmVyZWQpfWApO1xuICAgICAgICBpZiAodGhpcy5hdWRpb1N3aXRjaCAmJiB0aGlzLmFwcGVuZGVkKSB7XG4gICAgICAgICAgdGhpcy5hdWRpb1N3aXRjaCA9IGZhbHNlO1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELCB7IGlkOiB0aGlzLnRyYWNrSWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkVycm9yIChkYXRhKSB7XG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgLy8gZG9uJ3QgaGFuZGxlIGZyYWcgZXJyb3Igbm90IHJlbGF0ZWQgdG8gYXVkaW8gZnJhZ21lbnRcbiAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09ICdhdWRpbycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgICAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBhdWRpbyBmcmFnbWVudFxuICAgICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSAnYXVkaW8nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEuZmF0YWwpIHtcbiAgICAgICAgbGV0IGxvYWRFcnJvciA9IHRoaXMuZnJhZ0xvYWRFcnJvcjtcbiAgICAgICAgaWYgKGxvYWRFcnJvcikge1xuICAgICAgICAgIGxvYWRFcnJvcisrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvYWRFcnJvciA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgaWYgKGxvYWRFcnJvciA8PSBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSkge1xuICAgICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IGxvYWRFcnJvcjtcbiAgICAgICAgICAvLyBleHBvbmVudGlhbCBiYWNrb2ZmIGNhcHBlZCB0byBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXRcbiAgICAgICAgICBjb25zdCBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsIGxvYWRFcnJvciAtIDEpICogY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSwgY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0KTtcbiAgICAgICAgICBsb2dnZXIud2FybihgQXVkaW9TdHJlYW1Db250cm9sbGVyOiBmcmFnIGxvYWRpbmcgZmFpbGVkLCByZXRyeSBpbiAke2RlbGF5fSBtc2ApO1xuICAgICAgICAgIHRoaXMucmV0cnlEYXRlID0gcGVyZm9ybWFuY2Uubm93KCkgKyBkZWxheTtcbiAgICAgICAgICAvLyByZXRyeSBsb2FkaW5nIHN0YXRlXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihgQXVkaW9TdHJlYW1Db250cm9sbGVyOiAke2RhdGEuZGV0YWlsc30gcmVhY2hlcyBtYXggcmV0cnksIHJlZGlzcGF0Y2ggYXMgZmF0YWwgLi4uYCk7XG4gICAgICAgICAgLy8gc3dpdGNoIGVycm9yIHRvIGZhdGFsXG4gICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVDpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgLy8gIHdoZW4gaW4gRVJST1Igc3RhdGUsIGRvbid0IHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgaW4gY2FzZSBhIG5vbi1mYXRhbCBlcnJvciBpcyByZWNlaXZlZFxuICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgIC8vIGlmIGZhdGFsIGVycm9yLCBzdG9wIHByb2Nlc3NpbmcsIG90aGVyd2lzZSBtb3ZlIHRvIElETEUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgICB0aGlzLnN0YXRlID0gZGF0YS5mYXRhbCA/IFN0YXRlLkVSUk9SIDogU3RhdGUuSURMRTtcbiAgICAgICAgbG9nZ2VyLndhcm4oYEF1ZGlvU3RyZWFtQ29udHJvbGxlcjogJHtkYXRhLmRldGFpbHN9IHdoaWxlIGxvYWRpbmcgZnJhZywgbm93IHN3aXRjaGluZyB0byAke3RoaXMuc3RhdGV9IHN0YXRlIC4uLmApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAvLyBpZiBpbiBhcHBlbmRpbmcgc3RhdGVcbiAgICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ2F1ZGlvJyAmJiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fMKgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSkge1xuICAgICAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIsXG4gICAgICAgICAgY3VycmVudFRpbWUgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lLFxuICAgICAgICAgIG1lZGlhQnVmZmVyZWQgPSBtZWRpYSAmJiBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSwgY3VycmVudFRpbWUpICYmIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLCBjdXJyZW50VGltZSArIDAuNSk7XG4gICAgICAgICAgLy8gcmVkdWNlIG1heCBidWYgbGVuIGlmIGN1cnJlbnQgcG9zaXRpb24gaXMgYnVmZmVyZWRcbiAgICAgICAgaWYgKG1lZGlhQnVmZmVyZWQpIHtcbiAgICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICBpZiAoY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCA+PSBjb25maWcubWF4QnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggYXMgaXQgbWlnaHQgYmUgdG9vIGhpZ2guIHdlIGRvIHRoaXMgdG8gYXZvaWQgbG9vcCBmbHVzaGluZyAuLi5cbiAgICAgICAgICAgIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggLz0gMjtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBBdWRpb1N0cmVhbUNvbnRyb2xsZXI6IHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCB0byAke2NvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGh9c2ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCwgYnV0IGJyb3dzZXIgaXMgc3RpbGwgY29tcGxhaW5pbmcgYWJvdXQgYnVmZmVyIGZ1bGwgZXJyb3JcbiAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgb24gSUUvRWRnZSwgcmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvcHVsbC83MDhcbiAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgZmx1c2ggdGhlIHdob2xlIGF1ZGlvIGJ1ZmZlciB0byByZWNvdmVyXG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ0F1ZGlvU3RyZWFtQ29udHJvbGxlcjogYnVmZmVyIGZ1bGwgZXJyb3IgYWxzbyBtZWRpYS5jdXJyZW50VGltZSBpcyBub3QgYnVmZmVyZWQsIGZsdXNoIGF1ZGlvIGJ1ZmZlcicpO1xuICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIC8vIGZsdXNoIGV2ZXJ5dGhpbmdcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuQlVGRkVSX0ZMVVNISU5HO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNISU5HLCB7IHN0YXJ0T2Zmc2V0OiAwLCBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgdHlwZTogJ2F1ZGlvJyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIG9uQnVmZmVyRmx1c2hlZCAoKSB7XG4gICAgbGV0IHBlbmRpbmdEYXRhID0gdGhpcy5wZW5kaW5nRGF0YTtcbiAgICBpZiAocGVuZGluZ0RhdGEgJiYgcGVuZGluZ0RhdGEubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIubG9nKCdBdWRpb1N0cmVhbUNvbnRyb2xsZXI6IGFwcGVuZGluZyBwZW5kaW5nIGF1ZGlvIGRhdGEgYWZ0ZXIgYnVmZmVyIGZsdXNoZWQnKTtcbiAgICAgIHBlbmRpbmdEYXRhLmZvckVhY2goYXBwZW5kT2JqID0+IHtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCBhcHBlbmRPYmopO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucGVuZGluZ0RhdGEgPSBbXTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTRUQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG1vdmUgdG8gSURMRSBvbmNlIGZsdXNoIGNvbXBsZXRlLiB0aGlzIHNob3VsZCB0cmlnZ2VyIG5ldyBmcmFnbWVudCBsb2FkaW5nXG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIC8vIHJlc2V0IHJlZmVyZW5jZSB0byBmcmFnXG4gICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcbiIsImltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IFRhc2tMb29wIGZyb20gJy4uL3Rhc2stbG9vcCc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcblxuLyoqXG4gKiBAY2xhc3MgQXVkaW9UcmFja0NvbnRyb2xsZXJcbiAqIEBpbXBsZW1lbnRzIHtFdmVudEhhbmRsZXJ9XG4gKlxuICogSGFuZGxlcyBtYWluIG1hbmlmZXN0IGFuZCBhdWRpby10cmFjayBtZXRhZGF0YSBsb2FkZWQsXG4gKiBvd25zIGFuZCBleHBvc2VzIHRoZSBzZWxlY3RhYmxlIGF1ZGlvLXRyYWNrcyBkYXRhLW1vZGVscy5cbiAqXG4gKiBFeHBvc2VzIGludGVybmFsIGludGVyZmFjZSB0byBzZWxlY3QgYXZhaWxhYmxlIGF1ZGlvLXRyYWNrcy5cbiAqXG4gKiBIYW5kbGVzIGVycm9ycyBvbiBsb2FkaW5nIGF1ZGlvLXRyYWNrIHBsYXlsaXN0cy4gTWFuYWdlcyBmYWxsYmFjayBtZWNoYW5pc21cbiAqIHdpdGggcmVkdW5kYW50cyB0cmFja3MgKGdyb3VwLUlEcykuXG4gKlxuICogSGFuZGxlcyBsZXZlbC1sb2FkaW5nIGFuZCBncm91cC1JRCBzd2l0Y2hlcyBmb3IgdmlkZW8gKGZhbGxiYWNrIG9uIHZpZGVvIGxldmVscyksXG4gKiBhbmQgZXZlbnR1YWxseSBhZGFwdHMgdGhlIGF1ZGlvLXRyYWNrIGdyb3VwLUlEIHRvIG1hdGNoLlxuICpcbiAqIEBmaXJlcyBBVURJT19UUkFDS19MT0FESU5HXG4gKiBAZmlyZXMgQVVESU9fVFJBQ0tfU1dJVENISU5HXG4gKiBAZmlyZXMgQVVESU9fVFJBQ0tTX1VQREFURURcbiAqIEBmaXJlcyBFUlJPUlxuICpcbiAqL1xuY2xhc3MgQXVkaW9UcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBUYXNrTG9vcCB7XG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FESU5HLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfUEFSU0VELFxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfTE9BREVELFxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENIRUQsXG4gICAgICBFdmVudC5MRVZFTF9MT0FERUQsXG4gICAgICBFdmVudC5FUlJPUlxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEN1cnJlbnRseSBzZWxlY3RlZCBpbmRleCBpbiBgdHJhY2tzYFxuICAgICAqIEBtZW1iZXIge251bWJlcn0gdHJhY2tJZFxuICAgICAqL1xuICAgIHRoaXMuX3RyYWNrSWQgPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogSWYgc2hvdWxkIHNlbGVjdCB0cmFja3MgYWNjb3JkaW5nIHRvIGRlZmF1bHQgdHJhY2sgYXR0cmlidXRlXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gX3NlbGVjdERlZmF1bHRUcmFja1xuICAgICAqL1xuICAgIHRoaXMuX3NlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQWxsIHRyYWNrcyBhdmFpbGFibGVcbiAgICAgKiBAbWVtYmVyIHtBdWRpb1RyYWNrW119XG4gICAgICovXG4gICAgdGhpcy50cmFja3MgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBMaXN0IG9mIGJsYWNrbGlzdGVkIGF1ZGlvIHRyYWNrIElEcyAodGhhdCBoYXZlIGNhdXNlZCBmYWlsdXJlKVxuICAgICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgICAqL1xuICAgIHRoaXMudHJhY2tJZEJsYWNrbGlzdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogVGhlIGN1cnJlbnRseSBydW5uaW5nIGdyb3VwIElEIGZvciBhdWRpb1xuICAgICAqICh3ZSBncmFiIHRoaXMgb24gbWFuaWZlc3QtcGFyc2VkIGFuZCBuZXcgbGV2ZWwtbG9hZGVkKVxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmF1ZGlvR3JvdXBJZCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgYXVkaW8gdHJhY2tzIG9uIG5ldyBtYW5pZmVzdCBsb2FkaW5nLlxuICAgKi9cbiAgb25NYW5pZmVzdExvYWRpbmcgKCkge1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5fdHJhY2tJZCA9IC0xO1xuICAgIHRoaXMuX3NlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU3RvcmUgdHJhY2tzIGRhdGEgZnJvbSBtYW5pZmVzdCBwYXJzZWQgZGF0YS5cbiAgICpcbiAgICogVHJpZ2dlciBBVURJT19UUkFDS1NfVVBEQVRFRCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAqL1xuICBvbk1hbmlmZXN0UGFyc2VkIChkYXRhKSB7XG4gICAgY29uc3QgdHJhY2tzID0gdGhpcy50cmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzIHx8IFtdO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tTX1VQREFURUQsIHsgYXVkaW9UcmFja3M6IHRyYWNrcyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZSB0cmFjayBkZXRhaWxzIG9mIGxvYWRlZCB0cmFjayBpbiBvdXIgZGF0YS1tb2RlbC5cbiAgICpcbiAgICogU2V0LXVwIG1ldGFkYXRhIHVwZGF0ZSBpbnRlcnZhbCB0YXNrIGZvciBsaXZlLW1vZGUgc3RyZWFtcy5cbiAgICpcbiAgICogQHBhcmFtIHt9IGRhdGFcbiAgICovXG4gIG9uQXVkaW9UcmFja0xvYWRlZCAoZGF0YSkge1xuICAgIGlmIChkYXRhLmlkID49IHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLndhcm4oJ0ludmFsaWQgYXVkaW8gdHJhY2sgaWQ6JywgZGF0YS5pZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9nZ2VyLmxvZyhgYXVkaW9UcmFjayAke2RhdGEuaWR9IGxvYWRlZGApO1xuXG4gICAgdGhpcy50cmFja3NbZGF0YS5pZF0uZGV0YWlscyA9IGRhdGEuZGV0YWlscztcblxuICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0XG4gICAgLy8gYW5kIGlmIHdlIGhhdmUgYWxyZWFkeSBvdXIgcmVsb2FkIGludGVydmFsIHNldHVwXG4gICAgaWYgKGRhdGEuZGV0YWlscy5saXZlICYmICF0aGlzLmhhc0ludGVydmFsKCkpIHtcbiAgICAgIC8vIGlmIGxpdmUgcGxheWxpc3Qgd2Ugd2lsbCBoYXZlIHRvIHJlbG9hZCBpdCBwZXJpb2RpY2FsbHlcbiAgICAgIC8vIHNldCByZWxvYWQgcGVyaW9kIHRvIHBsYXlsaXN0IHRhcmdldCBkdXJhdGlvblxuICAgICAgY29uc3QgdXBkYXRlUGVyaW9kTXMgPSBkYXRhLmRldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAxMDAwO1xuICAgICAgdGhpcy5zZXRJbnRlcnZhbCh1cGRhdGVQZXJpb2RNcyk7XG4gICAgfVxuXG4gICAgaWYgKCFkYXRhLmRldGFpbHMubGl2ZSAmJiB0aGlzLmhhc0ludGVydmFsKCkpIHtcbiAgICAgIC8vIHBsYXlsaXN0IGlzIG5vdCBsaXZlIGFuZCB0aW1lciBpcyBzY2hlZHVsZWQ6IGNhbmNlbCBpdFxuICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgaW50ZXJuYWwgZ3JvdXAgSUQgdG8gYW55IGF1ZGlvLXRyYWNrIHdlIG1heSBoYXZlIHNldCBtYW51YWxseVxuICAgKiBvciBiZWNhdXNlIG9mIGEgZmFpbHVyZS1oYW5kbGluZyBmYWxsYmFjay5cbiAgICpcbiAgICogUXVhbGl0eS1sZXZlbHMgc2hvdWxkIHVwZGF0ZSB0byB0aGF0IGdyb3VwIElEIGluIHRoaXMgY2FzZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAqL1xuICBvbkF1ZGlvVHJhY2tTd2l0Y2hlZCAoZGF0YSkge1xuICAgIGNvbnN0IGF1ZGlvR3JvdXBJZCA9IHRoaXMudHJhY2tzW2RhdGEuaWRdLmdyb3VwSWQ7XG4gICAgaWYgKGF1ZGlvR3JvdXBJZCAmJiAodGhpcy5hdWRpb0dyb3VwSWQgIT09IGF1ZGlvR3JvdXBJZCkpIHtcbiAgICAgIHRoaXMuYXVkaW9Hcm91cElkID0gYXVkaW9Hcm91cElkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGEgbGV2ZWwgZ2V0cyBsb2FkZWQsIGlmIGl0IGhhcyByZWR1bmRhbnQgYXVkaW9Hcm91cElkcyAoaW4gdGhlIHNhbWUgb3JkaW5hbGl0eSBhcyBpdCdzIHJlZHVuZGFudCBVUkxzKVxuICAgKiB3ZSBhcmUgc2V0dGluZyBvdXIgYXVkaW8tZ3JvdXAgSUQgaW50ZXJuYWxseSB0byB0aGUgb25lIHNldCwgaWYgaXQgaXMgZGlmZmVyZW50IGZyb20gdGhlIGdyb3VwIElEIGN1cnJlbnRseSBzZXQuXG4gICAqXG4gICAqIElmIGdyb3VwLUlEIGdvdCB1cGRhdGUsIHdlIHJlLXNlbGVjdCB0aGUgYXBwcm9wcmlhdGUgYXVkaW8tdHJhY2sgd2l0aCB0aGlzIGdyb3VwLUlEIG1hdGNoaW5nIHRoZSBjdXJyZW50bHlcbiAgICogc2VsZWN0ZWQgb25lIChiYXNlZCBvbiBOQU1FIHByb3BlcnR5KS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAqL1xuICBvbkxldmVsTG9hZGVkIChkYXRhKSB7XG4gICAgLy8gRklYTUU6IGNyYXNoZXMgYmVjYXVzZSBjdXJyZW50TGV2ZWwgaXMgdW5kZWZpbmVkXG4gICAgLy8gY29uc3QgbGV2ZWxJbmZvID0gdGhpcy5obHMubGV2ZWxzW3RoaXMuaGxzLmN1cnJlbnRMZXZlbF07XG5cbiAgICBjb25zdCBsZXZlbEluZm8gPSB0aGlzLmhscy5sZXZlbHNbZGF0YS5sZXZlbHNdO1xuXG4gICAgaWYgKCFsZXZlbEluZm8uYXVkaW9Hcm91cElkcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGF1ZGlvR3JvdXBJZCA9IGxldmVsSW5mby5hdWRpb0dyb3VwSWRzW2xldmVsSW5mby51cmxJZF07XG4gICAgaWYgKHRoaXMuYXVkaW9Hcm91cElkICE9PSBhdWRpb0dyb3VwSWQpIHtcbiAgICAgIHRoaXMuYXVkaW9Hcm91cElkID0gYXVkaW9Hcm91cElkO1xuICAgICAgdGhpcy5fc2VsZWN0SW5pdGlhbEF1ZGlvVHJhY2soKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIG5ldHdvcmsgZXJyb3JzIGxvYWRpbmcgYXVkaW8gdHJhY2sgbWFuaWZlc3RzXG4gICAqIGFuZCBhbHNvIHBhdXNpbmcgb24gYW55IG5ldHdvayBlcnJvcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXJyb3JFdmVudERhdGF9IGRhdGFcbiAgICovXG4gIG9uRXJyb3IgKGRhdGEpIHtcbiAgICAvLyBPbmx5IGhhbmRsZSBuZXR3b3JrIGVycm9yc1xuICAgIGlmIChkYXRhLnR5cGUgIT09IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIGZhdGFsIG5ldHdvcmsgZXJyb3IsIGNhbmNlbCB1cGRhdGUgdGFza1xuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICB9XG5cbiAgICAvLyBJZiBub3QgYW4gYXVkaW8tdHJhY2sgbG9hZGluZyBlcnJvciBkb24ndCBoYW5kbGUgZnVydGhlclxuICAgIGlmIChkYXRhLmRldGFpbHMgIT09IEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9nZ2VyLndhcm4oJ05ldHdvcmsgZmFpbHVyZSBvbiBhdWRpby10cmFjayBpZDonLCBkYXRhLmNvbnRleHQuaWQpO1xuICAgIHRoaXMuX2hhbmRsZUxvYWRFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtBdWRpb1RyYWNrW119IEF1ZGlvLXRyYWNrIGxpc3Qgd2Ugb3duXG4gICAqL1xuICBnZXQgYXVkaW9UcmFja3MgKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfSBJbmRleCBpbnRvIGF1ZGlvLXRyYWNrcyBsaXN0IG9mIGN1cnJlbnRseSBzZWxlY3RlZCB0cmFjay5cbiAgICovXG4gIGdldCBhdWRpb1RyYWNrICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhY2tJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3QgY3VycmVudCB0cmFjayBieSBpbmRleFxuICAgKi9cbiAgc2V0IGF1ZGlvVHJhY2sgKG5ld0lkKSB7XG4gICAgdGhpcy5fc2V0QXVkaW9UcmFjayhuZXdJZCk7XG4gICAgLy8gSWYgYXVkaW8gdHJhY2sgaXMgc2VsZWN0ZWQgZnJvbSBBUEkgdGhlbiBkb24ndCBjaG9vc2UgZnJvbSB0aGUgbWFuaWZlc3QgZGVmYXVsdCB0cmFja1xuICAgIHRoaXMuX3NlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdJZFxuICAgKi9cbiAgX3NldEF1ZGlvVHJhY2sgKG5ld0lkKSB7XG4gICAgLy8gbm9vcCBvbiBzYW1lIGF1ZGlvIHRyYWNrIGlkIGFzIGFscmVhZHkgc2V0XG4gICAgaWYgKHRoaXMuX3RyYWNrSWQgPT09IG5ld0lkICYmIHRoaXMudHJhY2tzW3RoaXMuX3RyYWNrSWRdLmRldGFpbHMpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnU2FtZSBpZCBhcyBjdXJyZW50IGF1ZGlvLXRyYWNrIHBhc3NlZCwgYW5kIHRyYWNrIGRldGFpbHMgYXZhaWxhYmxlIC0+IG5vLW9wJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgaWYgKG5ld0lkIDwgMCB8fCBuZXdJZCA+PSB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdJbnZhbGlkIGlkIHBhc3NlZCB0byBhdWRpby10cmFjayBjb250cm9sbGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXVkaW9UcmFjayA9IHRoaXMudHJhY2tzW25ld0lkXTtcblxuICAgIGxvZ2dlci5sb2coYE5vdyBzd2l0Y2hpbmcgdG8gYXVkaW8tdHJhY2sgaW5kZXggJHtuZXdJZH1gKTtcblxuICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgIHRoaXMuX3RyYWNrSWQgPSBuZXdJZDtcblxuICAgIGNvbnN0IHsgdXJsLCB0eXBlLCBpZCB9ID0gYXVkaW9UcmFjaztcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSElORywgeyBpZCwgdHlwZSwgdXJsIH0pO1xuICAgIHRoaXMuX2xvYWRUcmFja0RldGFpbHNJZk5lZWRlZChhdWRpb1RyYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGRvVGljayAoKSB7XG4gICAgdGhpcy5fdXBkYXRlVHJhY2sodGhpcy5fdHJhY2tJZCk7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGluaXRpYWwgdHJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZWxlY3RJbml0aWFsQXVkaW9UcmFjayAoKSB7XG4gICAgbGV0IHRyYWNrcyA9IHRoaXMudHJhY2tzO1xuICAgIGlmICghdHJhY2tzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRBdWRpb1RyYWNrID0gdGhpcy50cmFja3NbdGhpcy5fdHJhY2tJZF07XG5cbiAgICBsZXQgbmFtZSA9IG51bGw7XG4gICAgaWYgKGN1cnJlbnRBdWRpb1RyYWNrKSB7XG4gICAgICBuYW1lID0gY3VycmVudEF1ZGlvVHJhY2submFtZTtcbiAgICB9XG5cbiAgICAvLyBQcmUtc2VsZWN0IGRlZmF1bHQgdHJhY2tzIGlmIHRoZXJlIGFyZSBhbnlcbiAgICBpZiAodGhpcy5fc2VsZWN0RGVmYXVsdFRyYWNrKSB7XG4gICAgICBjb25zdCBkZWZhdWx0VHJhY2tzID0gdHJhY2tzLmZpbHRlcigodHJhY2spID0+IHRyYWNrLmRlZmF1bHQpO1xuICAgICAgaWYgKGRlZmF1bHRUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgIHRyYWNrcyA9IGRlZmF1bHRUcmFja3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybignTm8gZGVmYXVsdCBhdWRpbyB0cmFja3MgZGVmaW5lZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB0cmFja0ZvdW5kID0gZmFsc2U7XG5cbiAgICBjb25zdCB0cmF2ZXJzZVRyYWNrcyA9ICgpID0+IHtcbiAgICAgIC8vIFNlbGVjdCB0cmFjayB3aXRoIHJpZ2h0IGdyb3VwIElEXG4gICAgICB0cmFja3MuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgaWYgKHRyYWNrRm91bmQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgbmVlZCB0byBtYXRjaCB0aGUgKHByZS0pc2VsZWN0ZWQgZ3JvdXAgSURcbiAgICAgICAgLy8gYW5kIHRoZSBOQU1FIG9mIHRoZSBjdXJyZW50IHRyYWNrLlxuICAgICAgICBpZiAoKCF0aGlzLmF1ZGlvR3JvdXBJZCB8fCB0cmFjay5ncm91cElkID09PSB0aGlzLmF1ZGlvR3JvdXBJZCkgJiZcbiAgICAgICAgICAoIW5hbWUgfHwgbmFtZSA9PT0gdHJhY2submFtZSkpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwcmV2aW91cyB0cmFjayB0cnkgdG8gc3RheSB3aXRoIHRoZSBzYW1lIGBOQU1FYC5cbiAgICAgICAgICAvLyBJdCBzaG91bGQgYmUgdW5pcXVlIGFjcm9zcyB0cmFja3Mgb2Ygc2FtZSBncm91cCwgYW5kIGNvbnNpc3RlbnQgdGhyb3VnaCByZWR1bmRhbnQgdHJhY2sgZ3JvdXBzLlxuICAgICAgICAgIHRoaXMuX3NldEF1ZGlvVHJhY2sodHJhY2suaWQpO1xuICAgICAgICAgIHRyYWNrRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdHJhdmVyc2VUcmFja3MoKTtcblxuICAgIGlmICghdHJhY2tGb3VuZCkge1xuICAgICAgbmFtZSA9IG51bGw7XG4gICAgICB0cmF2ZXJzZVRyYWNrcygpO1xuICAgIH1cblxuICAgIGlmICghdHJhY2tGb3VuZCkge1xuICAgICAgbG9nZ2VyLmVycm9yKGBObyB0cmFjayBmb3VuZCBmb3IgcnVubmluZyBhdWRpbyBncm91cC1JRDogJHt0aGlzLmF1ZGlvR3JvdXBJZH1gKTtcblxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUixcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0F1ZGlvVHJhY2t9IGF1ZGlvVHJhY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBfbmVlZHNUcmFja0xvYWRpbmcgKGF1ZGlvVHJhY2spIHtcbiAgICBjb25zdCB7IGRldGFpbHMsIHVybCB9ID0gYXVkaW9UcmFjaztcblxuICAgIGlmICghZGV0YWlscyB8fCBkZXRhaWxzLmxpdmUpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGZhY2UgYW4gYXVkaW8gdHJhY2sgZW1iZWRkZWQgaW4gbWFpbiBwbGF5bGlzdCAoYXVkaW8gdHJhY2sgd2l0aG91dCBVUkkgYXR0cmlidXRlKVxuICAgICAgcmV0dXJuICEhdXJsO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0F1ZGlvVHJhY2t9IGF1ZGlvVHJhY2tcbiAgICovXG4gIF9sb2FkVHJhY2tEZXRhaWxzSWZOZWVkZWQgKGF1ZGlvVHJhY2spIHtcbiAgICBpZiAodGhpcy5fbmVlZHNUcmFja0xvYWRpbmcoYXVkaW9UcmFjaykpIHtcbiAgICAgIGNvbnN0IHsgdXJsLCBpZCB9ID0gYXVkaW9UcmFjaztcbiAgICAgIC8vIHRyYWNrIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgIGxvZ2dlci5sb2coYGxvYWRpbmcgYXVkaW8tdHJhY2sgcGxheWxpc3QgZm9yIGlkOiAke2lkfWApO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19MT0FESU5HLCB7IHVybCwgaWQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdJZFxuICAgKi9cbiAgX3VwZGF0ZVRyYWNrIChuZXdJZCkge1xuICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgIGlmIChuZXdJZCA8IDAgfHwgbmV3SWQgPj0gdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgdGhpcy5fdHJhY2tJZCA9IG5ld0lkO1xuICAgIGxvZ2dlci5sb2coYHRyeWluZyB0byB1cGRhdGUgYXVkaW8tdHJhY2sgJHtuZXdJZH1gKTtcbiAgICBjb25zdCBhdWRpb1RyYWNrID0gdGhpcy50cmFja3NbbmV3SWRdO1xuICAgIHRoaXMuX2xvYWRUcmFja0RldGFpbHNJZk5lZWRlZChhdWRpb1RyYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhbmRsZUxvYWRFcnJvciAoKSB7XG4gICAgLy8gRmlyc3QsIGxldCdzIGJsYWNrIGxpc3QgY3VycmVudCB0cmFjayBpZFxuICAgIHRoaXMudHJhY2tJZEJsYWNrbGlzdFt0aGlzLl90cmFja0lkXSA9IHRydWU7XG5cbiAgICAvLyBMZXQncyB0cnkgdG8gZmFsbCBiYWNrIG9uIGEgZnVuY3Rpb25hbCBhdWRpby10cmFjayB3aXRoIHRoZSBzYW1lIGdyb3VwIElEXG4gICAgY29uc3QgcHJldmlvdXNJZCA9IHRoaXMuX3RyYWNrSWQ7XG4gICAgY29uc3QgeyBuYW1lLCBsYW5ndWFnZSwgZ3JvdXBJZCB9ID0gdGhpcy50cmFja3NbcHJldmlvdXNJZF07XG5cbiAgICBsb2dnZXIud2FybihgTG9hZGluZyBmYWlsZWQgb24gYXVkaW8gdHJhY2sgaWQ6ICR7cHJldmlvdXNJZH0sIGdyb3VwLWlkOiAke2dyb3VwSWR9LCBuYW1lL2xhbmd1YWdlOiBcIiR7bmFtZX1cIiAvIFwiJHtsYW5ndWFnZX1cImApO1xuXG4gICAgLy8gRmluZCBhIG5vbi1ibGFja2xpc3RlZCB0cmFjayBJRCB3aXRoIHRoZSBzYW1lIE5BTUVcbiAgICAvLyBBdCBsZWFzdCBhIHRyYWNrIHRoYXQgaXMgbm90IGJsYWNrbGlzdGVkLCB0aHVzIG9uIGFub3RoZXIgZ3JvdXAtSUQuXG4gICAgbGV0IG5ld0lkID0gcHJldmlvdXNJZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy50cmFja0lkQmxhY2tsaXN0W2ldKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3VHJhY2sgPSB0aGlzLnRyYWNrc1tpXTtcbiAgICAgIGlmIChuZXdUcmFjay5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIG5ld0lkID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5ld0lkID09PSBwcmV2aW91c0lkKSB7XG4gICAgICBsb2dnZXIud2FybihgTm8gZmFsbGJhY2sgYXVkaW8tdHJhY2sgZm91bmQgZm9yIG5hbWUvbGFuZ3VhZ2U6IFwiJHtuYW1lfVwiIC8gXCIke2xhbmd1YWdlfVwiYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9nZ2VyLmxvZygnQXR0ZW1wdGluZyBhdWRpby10cmFjayBmYWxsYmFjayBpZDonLCBuZXdJZCwgJ2dyb3VwLWlkOicsIHRoaXMudHJhY2tzW25ld0lkXS5ncm91cElkKTtcblxuICAgIHRoaXMuX3NldEF1ZGlvVHJhY2sobmV3SWQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEF1ZGlvVHJhY2tDb250cm9sbGVyO1xuIiwiaW1wb3J0IFRhc2tMb29wIGZyb20gJy4uL3Rhc2stbG9vcCc7XG5pbXBvcnQgeyBGcmFnbWVudFN0YXRlIH0gZnJvbSAnLi9mcmFnbWVudC10cmFja2VyJztcbmltcG9ydCB7IEJ1ZmZlckhlbHBlciB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuZXhwb3J0IGNvbnN0IFN0YXRlID0ge1xuICBTVE9QUEVEOiAnU1RPUFBFRCcsXG4gIFNUQVJUSU5HOiAnU1RBUlRJTkcnLFxuICBJRExFOiAnSURMRScsXG4gIFBBVVNFRDogJ1BBVVNFRCcsXG4gIEtFWV9MT0FESU5HOiAnS0VZX0xPQURJTkcnLFxuICBGUkFHX0xPQURJTkc6ICdGUkFHX0xPQURJTkcnLFxuICBGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTogJ0ZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZJyxcbiAgV0FJVElOR19UUkFDSzogJ1dBSVRJTkdfVFJBQ0snLFxuICBQQVJTSU5HOiAnUEFSU0lORycsXG4gIFBBUlNFRDogJ1BBUlNFRCcsXG4gIEJVRkZFUl9GTFVTSElORzogJ0JVRkZFUl9GTFVTSElORycsXG4gIEVOREVEOiAnRU5ERUQnLFxuICBFUlJPUjogJ0VSUk9SJyxcbiAgV0FJVElOR19JTklUX1BUUzogJ1dBSVRJTkdfSU5JVF9QVFMnLFxuICBXQUlUSU5HX0xFVkVMOiAnV0FJVElOR19MRVZFTCdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VTdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgVGFza0xvb3Age1xuICBkb1RpY2sgKCkge31cblxuICBzdGFydExvYWQgKCkge31cblxuICBzdG9wTG9hZCAoKSB7XG4gICAgbGV0IGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGlmIChmcmFnKSB7XG4gICAgICBpZiAoZnJhZy5sb2FkZXIpIHtcbiAgICAgICAgZnJhZy5sb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICB9XG5cbiAgX3N0cmVhbUVuZGVkIChidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpIHtcbiAgICBjb25zdCB7IGZyYWdDdXJyZW50LCBmcmFnbWVudFRyYWNrZXIgfSA9IHRoaXM7XG4gICAgLy8gd2UganVzdCBnb3QgZG9uZSBsb2FkaW5nIHRoZSBmaW5hbCBmcmFnbWVudCBhbmQgdGhlcmUgaXMgbm8gb3RoZXIgYnVmZmVyZWQgcmFuZ2UgYWZ0ZXIgLi4uXG4gICAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgaW4gY2FzZSB0aGVyZSBhcmUgYW55IGJ1ZmZlcmVkIHJhbmdlcyBhZnRlciwgaXQgbWVhbnMgdGhhdCB0aGVyZSBhcmUgdW5idWZmZXJlZCBwb3J0aW9uIGluIGJldHdlZW5cbiAgICAvLyBzbyB3ZSBzaG91bGQgbm90IHN3aXRjaCB0byBFTkRFRCBpbiB0aGF0IGNhc2UsIHRvIGJlIGFibGUgdG8gYnVmZmVyIHRoZW1cbiAgICAvLyBkb250IHN3aXRjaCB0byBFTkRFRCBpZiB3ZSBuZWVkIHRvIGJhY2t0cmFjayBsYXN0IGZyYWdtZW50XG4gICAgaWYgKCFsZXZlbERldGFpbHMubGl2ZSAmJiBmcmFnQ3VycmVudCAmJiAhZnJhZ0N1cnJlbnQuYmFja3RyYWNrZWQgJiYgZnJhZ0N1cnJlbnQuc24gPT09IGxldmVsRGV0YWlscy5lbmRTTiAmJiAhYnVmZmVySW5mby5uZXh0U3RhcnQpIHtcbiAgICAgIGNvbnN0IGZyYWdTdGF0ZSA9IGZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnQ3VycmVudCk7XG4gICAgICByZXR1cm4gZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwgfHwgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLk9LO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBvbk1lZGlhU2Vla2luZyAoKSB7XG4gICAgY29uc3QgeyBjb25maWcsIG1lZGlhLCBtZWRpYUJ1ZmZlciwgc3RhdGUgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogbnVsbDtcbiAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWFCdWZmZXIgfHwgbWVkaWEsIGN1cnJlbnRUaW1lLCB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcblxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoY3VycmVudFRpbWUpKSB7XG4gICAgICBsb2dnZXIubG9nKGBtZWRpYSBzZWVraW5nIHRvICR7Y3VycmVudFRpbWUudG9GaXhlZCgzKX1gKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORykge1xuICAgICAgbGV0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBzZWVraW5nIHRvIGEgdW5idWZmZXJlZCBhcmVhIEFORCBpZiBmcmFnIGxvYWRpbmcgaXMgaW4gcHJvZ3Jlc3NcbiAgICAgIGlmIChidWZmZXJJbmZvLmxlbiA9PT0gMCAmJiBmcmFnQ3VycmVudCkge1xuICAgICAgICBjb25zdCB0b2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICAgICAgY29uc3QgZnJhZ1N0YXJ0T2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgLSB0b2xlcmFuY2U7XG4gICAgICAgIGNvbnN0IGZyYWdFbmRPZmZzZXQgPSBmcmFnQ3VycmVudC5zdGFydCArIGZyYWdDdXJyZW50LmR1cmF0aW9uICsgdG9sZXJhbmNlO1xuICAgICAgICAvLyBjaGVjayBpZiB3ZSBzZWVrIHBvc2l0aW9uIHdpbGwgYmUgb3V0IG9mIGN1cnJlbnRseSBsb2FkZWQgZnJhZyByYW5nZSA6IGlmIG91dCBjYW5jZWwgZnJhZyBsb2FkLCBpZiBpbiwgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgZnJhZ1N0YXJ0T2Zmc2V0IHx8IGN1cnJlbnRUaW1lID4gZnJhZ0VuZE9mZnNldCkge1xuICAgICAgICAgIGlmIChmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ3NlZWtpbmcgb3V0c2lkZSBvZiBidWZmZXIgd2hpbGUgZnJhZ21lbnQgbG9hZCBpbiBwcm9ncmVzcywgY2FuY2VsIGZyYWdtZW50IGxvYWQnKTtcbiAgICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdzZWVraW5nIG91dHNpZGUgb2YgYnVmZmVyIGJ1dCB3aXRoaW4gY3VycmVudGx5IGxvYWRlZCBmcmFnbWVudCByYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcbiAgICAgIC8vIGlmIHNlZWtpbmcgdG8gdW5idWZmZXJlZCBhcmVhLCBjbGVhbiB1cCBmcmFnUHJldmlvdXNcbiAgICAgIGlmIChidWZmZXJJbmZvLmxlbiA9PT0gMCkge1xuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBjaGVjayBmb3IgcG90ZW50aWFsIG5ldyBmcmFnbWVudFxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICAgIGlmIChtZWRpYSkge1xuICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9XG5cbiAgICAvLyBpbiBjYXNlIHNlZWtpbmcgb2NjdXJzIGFsdGhvdWdoIG5vIG1lZGlhIGJ1ZmZlcmVkLCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiBhbmQgbmV4dExvYWRQb3NpdGlvbiB0byBzZWVrIHRhcmdldFxuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gY3VycmVudFRpbWU7XG4gICAgfVxuXG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBwcm9jZXNzaW5nXG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBvbk1lZGlhRW5kZWQgKCkge1xuICAgIC8vIHJlc2V0IHN0YXJ0UG9zaXRpb24gYW5kIGxhc3RDdXJyZW50VGltZSB0byByZXN0YXJ0IHBsYXliYWNrIEAgc3RyZWFtIGJlZ2lubmluZ1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgfVxuXG4gIG9uSGFuZGxlckRlc3Ryb3lpbmcgKCkge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICBzdXBlci5vbkhhbmRsZXJEZXN0cm95aW5nKCk7XG4gIH1cblxuICBvbkhhbmRsZXJEZXN0cm95ZWQgKCkge1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gbnVsbDtcbiAgfVxufVxuIiwiLypcbiAqIEJ1ZmZlciBDb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGdldE1lZGlhU291cmNlIH0gZnJvbSAnLi4vdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyJztcblxuY29uc3QgTWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSgpO1xuXG5jbGFzcyBCdWZmZXJDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscykge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSElORyxcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX1BBUlNFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9SRVNFVCxcbiAgICAgIEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsXG4gICAgICBFdmVudC5CVUZGRVJfQ09ERUNTLFxuICAgICAgRXZlbnQuQlVGRkVSX0VPUyxcbiAgICAgIEV2ZW50LkJVRkZFUl9GTFVTSElORyxcbiAgICAgIEV2ZW50LkxFVkVMX1BUU19VUERBVEVELFxuICAgICAgRXZlbnQuTEVWRUxfVVBEQVRFRCk7XG5cbiAgICAvLyB0aGUgdmFsdWUgdGhhdCB3ZSBoYXZlIHNldCBtZWRpYXNvdXJjZS5kdXJhdGlvbiB0b1xuICAgIC8vICh0aGUgYWN0dWFsIGR1cmF0aW9uIG1heSBiZSB0d2Vha2VkIHNsaWdobHkgYnkgdGhlIGJyb3dzZXIpXG4gICAgdGhpcy5fbXNEdXJhdGlvbiA9IG51bGw7XG4gICAgLy8gdGhlIHZhbHVlIHRoYXQgd2Ugd2FudCB0byBzZXQgbWVkaWFTb3VyY2UuZHVyYXRpb24gdG9cbiAgICB0aGlzLl9sZXZlbER1cmF0aW9uID0gbnVsbDtcbiAgICAvLyB0aGUgdGFyZ2V0IGR1cmF0aW9uIG9mIHRoZSBjdXJyZW50IG1lZGlhIHBsYXlsaXN0XG4gICAgdGhpcy5fbGV2ZWxUYXJnZXREdXJhdGlvbiA9IDEwO1xuICAgIC8vIGN1cnJlbnQgc3RyZWFtIHN0YXRlOiB0cnVlIC0gZm9yIGxpdmUgYnJvYWRjYXN0LCBmYWxzZSAtIGZvciBWb0QgY29udGVudFxuICAgIHRoaXMuX2xpdmUgPSBudWxsO1xuICAgIC8vIGNhY2hlIHRoZSBzZWxmIGdlbmVyYXRlZCBvYmplY3QgdXJsIHRvIGRldGVjdCBoaWphY2sgb2YgdmlkZW8gdGFnXG4gICAgdGhpcy5fb2JqZWN0VXJsID0gbnVsbDtcbiAgICAvLyBUaGUgbnVtYmVyIG9mIEJVRkZFUl9DT0RFQyBldmVudHMgcmVjZWl2ZWQgYmVmb3JlIGFueSBzb3VyY2VCdWZmZXJzIGFyZSBjcmVhdGVkXG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gMDtcblxuICAgIC8vIFNvdXJjZSBCdWZmZXIgbGlzdGVuZXJzXG4gICAgdGhpcy5vbnNidWUgPSB0aGlzLm9uU0JVcGRhdGVFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uc2JlID0gdGhpcy5vblNCVXBkYXRlRXJyb3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbkxldmVsUHRzVXBkYXRlZCAoZGF0YSkge1xuICAgIGxldCB0eXBlID0gZGF0YS50eXBlO1xuICAgIGxldCBhdWRpb1RyYWNrID0gdGhpcy50cmFja3MuYXVkaW87XG5cbiAgICAvLyBBZGp1c3RpbmcgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgIChkZXNpcmVkIHBvaW50IGluIHRoZSB0aW1lbGluZSB3aGVyZSB0aGUgbmV4dCBmcmFtZXMgc2hvdWxkIGJlIGFwcGVuZGVkKVxuICAgIC8vIGluIENocm9tZSBicm93c2VyIHdoZW4gd2UgZGV0ZWN0IE1QRUcgYXVkaW8gY29udGFpbmVyIGFuZCB0aW1lIGRlbHRhIGJldHdlZW4gbGV2ZWwgUFRTIGFuZCBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGBcbiAgICAvLyBpcyBncmVhdGVyIHRoYW4gMTAwbXMgKHRoaXMgaXMgZW5vdWdoIHRvIGhhbmRsZSBzZWVrIGZvciBWT0Qgb3IgbGV2ZWwgY2hhbmdlIGZvciBMSVZFIHZpZGVvcykuIEF0IHRoZSB0aW1lIG9mIGNoYW5nZSB3ZSBpc3N1ZVxuICAgIC8vIGBTb3VyY2VCdWZmZXIuYWJvcnQoKWAgYW5kIGFkanVzdGluZyBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGAgaWYgYFNvdXJjZUJ1ZmZlci51cGRhdGluZ2AgaXMgZmFsc2Ugb3IgYXdhaXRpbmcgYHVwZGF0ZWVuZGBcbiAgICAvLyBldmVudCBpZiBTQiBpcyBpbiB1cGRhdGluZyBzdGF0ZS5cbiAgICAvLyBNb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzMzMiNpc3N1ZWNvbW1lbnQtMjU3OTg2NDg2XG5cbiAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiBhdWRpb1RyYWNrICYmIGF1ZGlvVHJhY2suY29udGFpbmVyID09PSAnYXVkaW8vbXBlZycpIHsgLy8gQ2hyb21lIGF1ZGlvIG1wMyB0cmFja1xuICAgICAgbGV0IGF1ZGlvQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIuYXVkaW87XG4gICAgICBsZXQgZGVsdGEgPSBNYXRoLmFicyhhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgLSBkYXRhLnN0YXJ0KTtcblxuICAgICAgLy8gYWRqdXN0IHRpbWVzdGFtcCBvZmZzZXQgaWYgdGltZSBkZWx0YSBpcyBncmVhdGVyIHRoYW4gMTAwbXNcbiAgICAgIGlmIChkZWx0YSA+IDAuMSkge1xuICAgICAgICBsZXQgdXBkYXRpbmcgPSBhdWRpb0J1ZmZlci51cGRhdGluZztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF1ZGlvQnVmZmVyLmFib3J0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKCdjYW4gbm90IGFib3J0IGF1ZGlvIGJ1ZmZlcjogJyArIGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVwZGF0aW5nKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ2NoYW5nZSBtcGVnIGF1ZGlvIHRpbWVzdGFtcCBvZmZzZXQgZnJvbSAnICsgYXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0ICsgJyB0byAnICsgZGF0YS5zdGFydCk7XG4gICAgICAgICAgYXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0ID0gZGF0YS5zdGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0ID0gZGF0YS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uTWFuaWZlc3RQYXJzZWQgKGRhdGEpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGFsdCBhdWRpbyAyIEJVRkZFUl9DT0RFQ1MgZXZlbnRzIHdpbGwgYmUgdHJpZ2dlcmVkLCBvbmUgcGVyIHN0cmVhbSBjb250cm9sbGVyXG4gICAgLy8gc291cmNlYnVmZmVycyB3aWxsIGJlIGNyZWF0ZWQgYWxsIGF0IG9uY2Ugd2hlbiB0aGUgZXhwZWN0ZWQgbmIgb2YgdHJhY2tzIHdpbGwgYmUgcmVhY2hlZFxuICAgIC8vIGluIGNhc2UgYWx0IGF1ZGlvIGlzIG5vdCB1c2VkLCBvbmx5IG9uZSBCVUZGRVJfQ09ERUMgZXZlbnQgd2lsbCBiZSBmaXJlZCBmcm9tIG1haW4gc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAvLyBpdCB3aWxsIGNvbnRhaW4gdGhlIGV4cGVjdGVkIG5iIG9mIHNvdXJjZSBidWZmZXJzLCBubyBuZWVkIHRvIGNvbXB1dGUgaXRcbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSBkYXRhLmFsdEF1ZGlvID8gMiA6IDE7XG4gICAgbG9nZ2VyLmxvZyhgJHt0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWR9IGJ1ZmZlckNvZGVjIGV2ZW50KHMpIGV4cGVjdGVkYCk7XG4gIH1cblxuICBvbk1lZGlhQXR0YWNoaW5nIChkYXRhKSB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAvLyBzZXR1cCB0aGUgbWVkaWEgc291cmNlXG4gICAgICBsZXQgbXMgPSB0aGlzLm1lZGlhU291cmNlID0gbmV3IE1lZGlhU291cmNlKCk7XG4gICAgICAvLyBNZWRpYSBTb3VyY2UgbGlzdGVuZXJzXG4gICAgICB0aGlzLm9ubXNvID0gdGhpcy5vbk1lZGlhU291cmNlT3Blbi5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5vbm1zZSA9IHRoaXMub25NZWRpYVNvdXJjZUVuZGVkLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLm9ubXNjID0gdGhpcy5vbk1lZGlhU291cmNlQ2xvc2UuYmluZCh0aGlzKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLm9ubXNvKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5vbm1zZSk7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMub25tc2MpO1xuICAgICAgLy8gbGluayB2aWRlbyBhbmQgbWVkaWEgU291cmNlXG4gICAgICBtZWRpYS5zcmMgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChtcyk7XG4gICAgICAvLyBjYWNoZSB0aGUgbG9jYWxseSBnZW5lcmF0ZWQgb2JqZWN0IHVybFxuICAgICAgdGhpcy5fb2JqZWN0VXJsID0gbWVkaWEuc3JjO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcgKCkge1xuICAgIGxvZ2dlci5sb2coJ21lZGlhIHNvdXJjZSBkZXRhY2hpbmcnKTtcbiAgICBsZXQgbXMgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIGlmIChtcykge1xuICAgICAgaWYgKG1zLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIGVuZE9mU3RyZWFtIGNvdWxkIHRyaWdnZXIgZXhjZXB0aW9uIGlmIGFueSBzb3VyY2VidWZmZXIgaXMgaW4gdXBkYXRpbmcgc3RhdGVcbiAgICAgICAgICAvLyB3ZSBkb24ndCByZWFsbHkgY2FyZSBhYm91dCBjaGVja2luZyBzb3VyY2VidWZmZXIgc3RhdGUgaGVyZSxcbiAgICAgICAgICAvLyBhcyB3ZSBhcmUgYW55d2F5IGRldGFjaGluZyB0aGUgTWVkaWFTb3VyY2VcbiAgICAgICAgICAvLyBsZXQncyBqdXN0IGF2b2lkIHRoaXMgZXhjZXB0aW9uIHRvIHByb3BhZ2F0ZVxuICAgICAgICAgIG1zLmVuZE9mU3RyZWFtKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBvbk1lZGlhRGV0YWNoaW5nOiR7ZXJyLm1lc3NhZ2V9IHdoaWxlIGNhbGxpbmcgZW5kT2ZTdHJlYW1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMub25tc28pO1xuICAgICAgbXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlZW5kZWQnLCB0aGlzLm9ubXNlKTtcbiAgICAgIG1zLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5vbm1zYyk7XG5cbiAgICAgIC8vIERldGFjaCBwcm9wZXJseSB0aGUgTWVkaWFTb3VyY2UgZnJvbSB0aGUgSFRNTE1lZGlhRWxlbWVudCBhc1xuICAgICAgLy8gc3VnZ2VzdGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvbWVkaWEtc291cmNlL2lzc3Vlcy81My5cbiAgICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMuX29iamVjdFVybCk7XG5cbiAgICAgICAgLy8gY2xlYW4gdXAgdmlkZW8gdGFnIHNyYyBvbmx5IGlmIGl0J3Mgb3VyIG93biB1cmwuIHNvbWUgZXh0ZXJuYWwgbGlicmFyaWVzIG1pZ2h0XG4gICAgICAgIC8vIGhpamFjayB0aGUgdmlkZW8gdGFnIGFuZCBjaGFuZ2UgaXRzICdzcmMnIHdpdGhvdXQgZGVzdHJveWluZyB0aGUgSGxzIGluc3RhbmNlIGZpcnN0XG4gICAgICAgIGlmICh0aGlzLm1lZGlhLnNyYyA9PT0gdGhpcy5fb2JqZWN0VXJsKSB7XG4gICAgICAgICAgdGhpcy5tZWRpYS5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgIHRoaXMubWVkaWEubG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci53YXJuKCdtZWRpYS5zcmMgd2FzIGNoYW5nZWQgYnkgYSB0aGlyZCBwYXJ0eSAtIHNraXAgY2xlYW51cCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWVkaWFTb3VyY2UgPSBudWxsO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICB0aGlzLl9vYmplY3RVcmwgPSBudWxsO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICAgICAgdGhpcy5zb3VyY2VCdWZmZXIgPSB7fTtcbiAgICAgIHRoaXMuZmx1c2hSYW5nZSA9IFtdO1xuICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgICAgdGhpcy5hcHBlbmRlZCA9IDA7XG4gICAgfVxuICAgIHRoaXMub25tc28gPSB0aGlzLm9ubXNlID0gdGhpcy5vbm1zYyA9IG51bGw7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5NRURJQV9ERVRBQ0hFRCk7XG4gIH1cblxuICBvbk1lZGlhU291cmNlT3BlbiAoKSB7XG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIG9wZW5lZCcpO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTUVESUFfQVRUQUNIRUQsIHsgbWVkaWE6IHRoaXMubWVkaWEgfSk7XG4gICAgbGV0IG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICBpZiAobWVkaWFTb3VyY2UpIHtcbiAgICAgIC8vIG9uY2UgcmVjZWl2ZWQsIGRvbid0IGxpc3RlbiBhbnltb3JlIHRvIHNvdXJjZW9wZW4gZXZlbnRcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLm9ubXNvKTtcbiAgICB9XG4gICAgdGhpcy5jaGVja1BlbmRpbmdUcmFja3MoKTtcbiAgfVxuXG4gIGNoZWNrUGVuZGluZ1RyYWNrcyAoKSB7XG4gICAgbGV0IHsgYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCwgcGVuZGluZ1RyYWNrcyB9ID0gdGhpcztcbiAgICAvLyBDaGVjayBpZiB3ZSd2ZSByZWNlaXZlZCBhbGwgb2YgdGhlIGV4cGVjdGVkIGJ1ZmZlckNvZGVjIGV2ZW50cy4gV2hlbiBub25lIHJlbWFpbiwgY3JlYXRlIGFsbCB0aGUgc291cmNlQnVmZmVycyBhdCBvbmNlLlxuICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIE1TRSBzcGVjIGFsbG93cyBpbXBsZW1lbnRhdGlvbnMgdG8gdGhyb3cgUXVvdGFFeGNlZWRlZEVycm9ycyBpZiBjcmVhdGluZyBuZXcgc291cmNlQnVmZmVycyBhZnRlclxuICAgIC8vIGRhdGEgaGFzIGJlZW4gYXBwZW5kZWQgdG8gZXhpc3Rpbmcgb25lcy5cbiAgICAvLyAyIHRyYWNrcyBpcyB0aGUgbWF4IChvbmUgZm9yIGF1ZGlvLCBvbmUgZm9yIHZpZGVvKS4gSWYgd2UndmUgcmVhY2ggdGhpcyBtYXggZ28gYWhlYWQgYW5kIGNyZWF0ZSB0aGUgYnVmZmVycy5cblxuICAgIGNvbnN0IHBlbmRpbmdUcmFja3NDb3VudCA9IE9iamVjdC5rZXlzKHBlbmRpbmdUcmFja3MpLmxlbmd0aDtcbiAgICBpZiAoKHBlbmRpbmdUcmFja3NDb3VudCAmJiAhYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCkgfHwgcGVuZGluZ1RyYWNrc0NvdW50ID09PSAyKSB7XG4gICAgICAvLyBvaywgbGV0J3MgY3JlYXRlIHRoZW0gbm93ICFcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlQnVmZmVycyhwZW5kaW5nVHJhY2tzKTtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgICAgLy8gYXBwZW5kIGFueSBwZW5kaW5nIHNlZ21lbnRzIG5vdyAhXG4gICAgICB0aGlzLmRvQXBwZW5kaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgb25NZWRpYVNvdXJjZUNsb3NlICgpIHtcbiAgICBsb2dnZXIubG9nKCdtZWRpYSBzb3VyY2UgY2xvc2VkJyk7XG4gIH1cblxuICBvbk1lZGlhU291cmNlRW5kZWQgKCkge1xuICAgIGxvZ2dlci5sb2coJ21lZGlhIHNvdXJjZSBlbmRlZCcpO1xuICB9XG5cbiAgb25TQlVwZGF0ZUVuZCAoKSB7XG4gICAgLy8gdXBkYXRlIHRpbWVzdGFtcE9mZnNldFxuICAgIGlmICh0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0KSB7XG4gICAgICBsZXQgYXVkaW9CdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlci5hdWRpbztcbiAgICAgIGxvZ2dlci53YXJuKGBjaGFuZ2UgbXBlZyBhdWRpbyB0aW1lc3RhbXAgb2Zmc2V0IGZyb20gJHthdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXR9IHRvICR7dGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldH1gKTtcbiAgICAgIGF1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldCA9IHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQ7XG4gICAgICBkZWxldGUgdGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbmVlZHNGbHVzaCkge1xuICAgICAgdGhpcy5kb0ZsdXNoKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX25lZWRzRW9zKSB7XG4gICAgICB0aGlzLmNoZWNrRW9zKCk7XG4gICAgfVxuXG4gICAgdGhpcy5hcHBlbmRpbmcgPSBmYWxzZTtcbiAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgLy8gY291bnQgbmIgb2YgcGVuZGluZyBzZWdtZW50cyB3YWl0aW5nIGZvciBhcHBlbmRpbmcgb24gdGhpcyBzb3VyY2VidWZmZXJcbiAgICBsZXQgcGVuZGluZyA9IHRoaXMuc2VnbWVudHMucmVkdWNlKChjb3VudGVyLCBzZWdtZW50KSA9PiAoc2VnbWVudC5wYXJlbnQgPT09IHBhcmVudCkgPyBjb3VudGVyICsgMSA6IGNvdW50ZXIsIDApO1xuXG4gICAgLy8gdGhpcy5zb3VyY2VCdWZmZXIgaXMgYmV0dGVyIHRvIHVzZSB0aGFuIG1lZGlhLmJ1ZmZlcmVkIGFzIGl0IGlzIGNsb3NlciB0byB0aGUgUFRTIGRhdGEgZnJvbSB0aGUgZnJhZ21lbnRzXG4gICAgbGV0IHRpbWVSYW5nZXMgPSB7fTtcbiAgICBjb25zdCBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICBmb3IgKGxldCBzdHJlYW1UeXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgdGltZVJhbmdlc1tzdHJlYW1UeXBlXSA9IHNvdXJjZUJ1ZmZlcltzdHJlYW1UeXBlXS5idWZmZXJlZDtcbiAgICB9XG5cbiAgICAvLyDlr7vmib7lj6/mkq3mlL7nmoTotbflp4vngrnjgILlpoLmnpzmsqHmnInoh6rliqjmkq3mlL7vvIzpnIDopoHmiYvliqhTZWVrXG4gICAgaWYodGhpcy5fcGF1c2VkID09PSBmYWxzZVxuICAgICAgJiYgdGltZVJhbmdlc1tcInZpZGVvXCJdICYmIHRpbWVSYW5nZXNbXCJ2aWRlb1wiXS5sZW5ndGggPiAwXG4gICAgICAmJiB0aW1lUmFuZ2VzW1wiYXVkaW9cIl0gJiYgdGltZVJhbmdlc1tcImF1ZGlvXCJdLmxlbmd0aCA+IDApIHtcblxuICAgICAgaWYodGltZVJhbmdlc1tcInZpZGVvXCJdLmVuZCgwKSAtIHRpbWVSYW5nZXNbXCJ2aWRlb1wiXS5zdGFydCgwKSA+IDFcbiAgICAgICYmIHRpbWVSYW5nZXNbXCJhdWRpb1wiXS5lbmQoMCkgLSB0aW1lUmFuZ2VzW1wiYXVkaW9cIl0uc3RhcnQoMCkgPiAxKSB7XG4gICAgICAgIC8vIFNlZWsgdG8gdGhlIHBvaW50IHRoYXQgY2FuIHBsYXk7XG4gICAgICAgIGxldCBzdGFydFRpbWUgPSBNYXRoLm1heCh0aW1lUmFuZ2VzW1widmlkZW9cIl0uc3RhcnQoMCksdGltZVJhbmdlc1tcImF1ZGlvXCJdLnN0YXJ0KDApKVxuICAgICAgICB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLm1lZGlhLnBsYXkoKTtcbiAgICAgICAgZGVsZXRlIHRoaXNbXCJfcGF1c2VkXCJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHJ5IHRvIHNlZWsgbW9yZVxuICAgICAgICBsZXQgZW5kVGltZSA9IE1hdGgubWF4KHRpbWVSYW5nZXNbXCJ2aWRlb1wiXS5lbmQoMCksdGltZVJhbmdlc1tcImF1ZGlvXCJdLmVuZCgwKSlcbiAgICAgICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IGVuZFRpbWU7XG4gICAgICAgIHRoaXMubWVkaWEucGxheSgpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ERUQsIHsgcGFyZW50LCBwZW5kaW5nLCB0aW1lUmFuZ2VzIH0pO1xuICAgIC8vIGRvbid0IGFwcGVuZCBpbiBmbHVzaGluZyBtb2RlXG4gICAgaWYgKCF0aGlzLl9uZWVkc0ZsdXNoKSB7XG4gICAgICB0aGlzLmRvQXBwZW5kaW5nKCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuXG4gICAgLy8gYXBwZW5kaW5nIGdvZXMgZmlyc3RcbiAgICBpZiAocGVuZGluZyA9PT0gMCkge1xuICAgICAgdGhpcy5mbHVzaExpdmVCYWNrQnVmZmVyKCk7XG4gICAgfVxuICB9XG5cbiAgb25TQlVwZGF0ZUVycm9yIChldmVudCkge1xuICAgIGxvZ2dlci5lcnJvcignc291cmNlQnVmZmVyIGVycm9yOicsIGV2ZW50KTtcbiAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtc291cmNlLyNzb3VyY2VidWZmZXItYXBwZW5kLWVycm9yXG4gICAgLy8gdGhpcyBlcnJvciBtaWdodCBub3QgYWx3YXlzIGJlIGZhdGFsIChpdCBpcyBmYXRhbCBpZiBkZWNvZGUgZXJyb3IgaXMgc2V0LCBpbiB0aGF0IGNhc2VcbiAgICAvLyBpdCB3aWxsIGJlIGZvbGxvd2VkIGJ5IGEgbWVkaWFFbGVtZW50IGVycm9yIC4uLilcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5ESU5HX0VSUk9SLCBmYXRhbDogZmFsc2UgfSk7XG4gICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBkbyBtb3JlIHRoYW4gdGhhdCwgYXMgYWNjb3JkaW4gdG8gdGhlIHNwZWMsIHVwZGF0ZWVuZCB3aWxsIGJlIGZpcmVkIGp1c3QgYWZ0ZXJcbiAgfVxuXG4gIG9uQnVmZmVyUmVzZXQgKCkge1xuICAgIGxldCBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICBmb3IgKGxldCB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgbGV0IHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5tZWRpYVNvdXJjZS5yZW1vdmVTb3VyY2VCdWZmZXIoc2IpO1xuICAgICAgICBzYi5yZW1vdmVFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCB0aGlzLm9uc2J1ZSk7XG4gICAgICAgIHNiLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5vbnNiZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zb3VyY2VCdWZmZXIgPSB7fTtcbiAgICB0aGlzLmZsdXNoUmFuZ2UgPSBbXTtcbiAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgdGhpcy5hcHBlbmRlZCA9IDA7XG4gIH1cblxuICBvbkJ1ZmZlckNvZGVjcyAodHJhY2tzKSB7XG4gICAgLy8gaWYgc291cmNlIGJ1ZmZlcihzKSBub3QgY3JlYXRlZCB5ZXQsIGFwcGVuZGVkIGJ1ZmZlciB0cmFja3MgaW4gdGhpcy5wZW5kaW5nVHJhY2tzXG4gICAgLy8gaWYgc291cmNlYnVmZmVycyBhbHJlYWR5IGNyZWF0ZWQsIGRvIG5vdGhpbmcgLi4uXG4gICAgLyoqIOmcgOimgeaUvui/h3RyYWNrcywg5pyJ5paw55qEdHJhY2vpnIDopoHph43mlrDliqBidWZmZXIg5L2/5b6X55S76Z2i5Yiw6L6+5pe277yM5Y+v5Lul5pKt5pS+55S76Z2iXG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVyKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9Ki9cblxuICAgIE9iamVjdC5rZXlzKHRyYWNrcykuZm9yRWFjaCh0cmFja05hbWUgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzW3RyYWNrTmFtZV0gPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICB9KTtcbiAgICBjb25zdCB7IG1lZGlhU291cmNlIH0gPSB0aGlzO1xuICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IE1hdGgubWF4KHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCAtIDEsIDApO1xuICAgIGlmIChtZWRpYVNvdXJjZSAmJiBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlU291cmNlQnVmZmVycyAodHJhY2tzKSB7XG4gICAgbGV0IHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLCBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgZm9yIChsZXQgdHJhY2tOYW1lIGluIHRyYWNrcykge1xuICAgICAgaWYgKCFzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSkge1xuICAgICAgICBsZXQgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgLy8gdXNlIGxldmVsQ29kZWMgYXMgZmlyc3QgcHJpb3JpdHlcbiAgICAgICAgbGV0IGNvZGVjID0gdHJhY2subGV2ZWxDb2RlYyB8fCB0cmFjay5jb2RlYztcbiAgICAgICAgbGV0IG1pbWVUeXBlID0gYCR7dHJhY2suY29udGFpbmVyfTtjb2RlY3M9JHtjb2RlY31gO1xuICAgICAgICBsb2dnZXIubG9nKGBjcmVhdGluZyBzb3VyY2VCdWZmZXIoJHttaW1lVHlwZX0pYCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHNiID0gc291cmNlQnVmZmVyW3RyYWNrTmFtZV0gPSBtZWRpYVNvdXJjZS5hZGRTb3VyY2VCdWZmZXIobWltZVR5cGUpO1xuICAgICAgICAgIHNiLmFkZEV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIHRoaXMub25zYnVlKTtcbiAgICAgICAgICBzYi5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMub25zYmUpO1xuICAgICAgICAgIHRoaXMudHJhY2tzW3RyYWNrTmFtZV0gPSB7IGNvZGVjOiBjb2RlYywgY29udGFpbmVyOiB0cmFjay5jb250YWluZXIgfTtcbiAgICAgICAgICB0cmFjay5idWZmZXIgPSBzYjtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYoZXJyLmNvZGUgPT0gMjIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJGb3VuZCBuZXcgdHJhY2ssIHRyeSB0byByZWJ1aWxkXCIpO1xuICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBzZXR1cCB0aGUgbWVkaWEgc291cmNlXG4gICAgICAgICAgICBsZXQgbXMgPSB0aGlzLm1lZGlhU291cmNlID0gbmV3IE1lZGlhU291cmNlKCk7XG4gICAgICAgICAgICAvLyBNZWRpYSBTb3VyY2UgbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLm9ubXNvID0gdGhpcy5vbk1lZGlhU291cmNlT3Blbi5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbm1zZSA9IHRoaXMub25NZWRpYVNvdXJjZUVuZGVkLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9ubXNjID0gdGhpcy5vbk1lZGlhU291cmNlQ2xvc2UuYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgZm9yKGxldCBpPTA7aTxPYmplY3Qua2V5cyh0aGlzLnRyYWNrcykubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgICBsZXQgdHJhY2sgPSB0aGlzLnRyYWNrc1tPYmplY3Qua2V5cyh0aGlzLnRyYWNrcylbaV1dO1xuICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUcmFja3NbT2JqZWN0LmtleXModGhpcy50cmFja3MpW2ldXSA9IHRyYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFja3MgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlQnVmZmVyID0ge307XG4gICAgICAgICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5vbm1zbyk7XG4gICAgICAgICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMub25tc2UpO1xuICAgICAgICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLm9ubXNjKTtcbiAgICAgICAgICAgIC8vIGxpbmsgdmlkZW8gYW5kIG1lZGlhIFNvdXJjZVxuICAgICAgICAgICAgdGhpcy5tZWRpYS5zcmMgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChtcyk7XG4gICAgICAgICAgICAvLyBjYWNoZSB0aGUgbG9jYWxseSBnZW5lcmF0ZWQgb2JqZWN0IHVybFxuICAgICAgICAgICAgdGhpcy5fb2JqZWN0VXJsID0gbWVkaWEuc3JjO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYGVycm9yIHdoaWxlIHRyeWluZyB0byBhZGQgc291cmNlQnVmZmVyOiR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SLCBmYXRhbDogZmFsc2UsIGVycjogZXJyLCBtaW1lVHlwZTogbWltZVR5cGUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQ1JFQVRFRCwgeyB0cmFja3M6IHRyYWNrcyB9KTtcbiAgfVxuXG4gIG9uQnVmZmVyQXBwZW5kaW5nIChkYXRhKSB7XG4gICAgaWYgKCF0aGlzLl9uZWVkc0ZsdXNoKSB7XG4gICAgICBpZiAoIXRoaXMuc2VnbWVudHMpIHtcbiAgICAgICAgdGhpcy5zZWdtZW50cyA9IFsgZGF0YSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKGRhdGEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRvQXBwZW5kaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgb25CdWZmZXJBcHBlbmRGYWlsIChkYXRhKSB7XG4gICAgbG9nZ2VyLmVycm9yKCdzb3VyY2VCdWZmZXIgZXJyb3I6JywgZGF0YS5ldmVudCk7XG4gICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jc291cmNlYnVmZmVyLWFwcGVuZC1lcnJvclxuICAgIC8vIHRoaXMgZXJyb3IgbWlnaHQgbm90IGFsd2F5cyBiZSBmYXRhbCAoaXQgaXMgZmF0YWwgaWYgZGVjb2RlIGVycm9yIGlzIHNldCwgaW4gdGhhdCBjYXNlXG4gICAgLy8gaXQgd2lsbCBiZSBmb2xsb3dlZCBieSBhIG1lZGlhRWxlbWVudCBlcnJvciAuLi4pXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUiwgZmF0YWw6IGZhbHNlIH0pO1xuICB9XG5cbiAgLy8gb24gQlVGRkVSX0VPUyBtYXJrIG1hdGNoaW5nIHNvdXJjZWJ1ZmZlcihzKSBhcyBlbmRlZCBhbmQgdHJpZ2dlciBjaGVja0VvcygpXG4gIG9uQnVmZmVyRW9zIChkYXRhKSB7XG4gICAgbGV0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgbGV0IGRhdGFUeXBlID0gZGF0YS50eXBlO1xuICAgIGZvciAobGV0IHR5cGUgaW4gc2IpIHtcbiAgICAgIGlmICghZGF0YVR5cGUgfHwgdHlwZSA9PT0gZGF0YVR5cGUpIHtcbiAgICAgICAgaWYgKCFzYlt0eXBlXS5lbmRlZCkge1xuICAgICAgICAgIHNiW3R5cGVdLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICBsb2dnZXIubG9nKGAke3R5cGV9IHNvdXJjZUJ1ZmZlciBub3cgRU9TYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jaGVja0VvcygpO1xuICB9XG5cbiAgLy8gaWYgYWxsIHNvdXJjZSBidWZmZXJzIGFyZSBtYXJrZWQgYXMgZW5kZWQsIHNpZ25hbCBlbmRPZlN0cmVhbSgpIHRvIE1lZGlhU291cmNlLlxuICBjaGVja0VvcyAoKSB7XG4gICAgbGV0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXIsIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICBpZiAoIW1lZGlhU291cmNlIHx8IG1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgdGhpcy5fbmVlZHNFb3MgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgdHlwZSBpbiBzYikge1xuICAgICAgbGV0IHNib2JqID0gc2JbdHlwZV07XG4gICAgICBpZiAoIXNib2JqLmVuZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNib2JqLnVwZGF0aW5nKSB7XG4gICAgICAgIHRoaXMuX25lZWRzRW9zID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2dnZXIubG9nKCdhbGwgbWVkaWEgZGF0YSBhcmUgYXZhaWxhYmxlLCBzaWduYWwgZW5kT2ZTdHJlYW0oKSB0byBNZWRpYVNvdXJjZSBhbmQgc3RvcCBsb2FkaW5nIGZyYWdtZW50Jyk7XG4gICAgLy8gTm90aWZ5IHRoZSBtZWRpYSBlbGVtZW50IHRoYXQgaXQgbm93IGhhcyBhbGwgb2YgdGhlIG1lZGlhIGRhdGFcbiAgICB0cnkge1xuICAgICAgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIud2FybignZXhjZXB0aW9uIHdoaWxlIGNhbGxpbmcgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKScpO1xuICAgIH1cbiAgICB0aGlzLl9uZWVkc0VvcyA9IGZhbHNlO1xuICB9XG5cbiAgb25CdWZmZXJGbHVzaGluZyAoZGF0YSkge1xuICAgIHRoaXMuZmx1c2hSYW5nZS5wdXNoKHsgc3RhcnQ6IGRhdGEuc3RhcnRPZmZzZXQsIGVuZDogZGF0YS5lbmRPZmZzZXQsIHR5cGU6IGRhdGEudHlwZSB9KTtcbiAgICAvLyBhdHRlbXB0IGZsdXNoIGltbWVkaWF0ZWx5XG4gICAgdGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIgPSAwO1xuICAgIHRoaXMuZG9GbHVzaCgpO1xuICB9XG5cbiAgZmx1c2hMaXZlQmFja0J1ZmZlciAoKSB7XG4gICAgLy8gY2xlYXIgYmFjayBidWZmZXIgZm9yIGxpdmUgb25seVxuICAgIGlmICghdGhpcy5fbGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGxpdmVCYWNrQnVmZmVyTGVuZ3RoID0gdGhpcy5obHMuY29uZmlnLmxpdmVCYWNrQnVmZmVyTGVuZ3RoO1xuICAgIGlmICghaXNGaW5pdGUobGl2ZUJhY2tCdWZmZXJMZW5ndGgpIHx8IGxpdmVCYWNrQnVmZmVyTGVuZ3RoIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYS5jdXJyZW50VGltZTtcbiAgICBjb25zdCBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICBjb25zdCBidWZmZXJUeXBlcyA9IE9iamVjdC5rZXlzKHNvdXJjZUJ1ZmZlcik7XG4gICAgY29uc3QgdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uID0gY3VycmVudFRpbWUgLSBNYXRoLm1heChsaXZlQmFja0J1ZmZlckxlbmd0aCwgdGhpcy5fbGV2ZWxUYXJnZXREdXJhdGlvbik7XG5cbiAgICBmb3IgKGxldCBpbmRleCA9IGJ1ZmZlclR5cGVzLmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgIGNvbnN0IGJ1ZmZlclR5cGUgPSBidWZmZXJUeXBlc1tpbmRleF0sIGJ1ZmZlcmVkID0gc291cmNlQnVmZmVyW2J1ZmZlclR5cGVdLmJ1ZmZlcmVkO1xuXG4gICAgICAvLyB3aGVuIHRhcmdldCBidWZmZXIgc3RhcnQgZXhjZWVkcyBhY3R1YWwgYnVmZmVyIHN0YXJ0XG4gICAgICBpZiAoYnVmZmVyZWQubGVuZ3RoID4gMCAmJiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24gPiBidWZmZXJlZC5zdGFydCgwKSkge1xuICAgICAgICAvLyByZW1vdmUgYnVmZmVyIHVwIHVudGlsIGN1cnJlbnQgdGltZSBtaW51cyBtaW5pbXVtIGJhY2sgYnVmZmVyIGxlbmd0aCAocmVtb3ZpbmcgYnVmZmVyIHRvbyBjbG9zZSB0byBjdXJyZW50XG4gICAgICAgIC8vIHRpbWUgd2lsbCBsZWFkIHRvIHBsYXliYWNrIGZyZWV6aW5nKVxuICAgICAgICAvLyBjcmVkaXRzIGZvciBsZXZlbCB0YXJnZXQgZHVyYXRpb24gLSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy9odHRwLXN0cmVhbWluZy9ibG9iLzMxMzI5MzNiNmFhOTlkZGVmYWIyOWMxMDQ0NzYyNGVmZDZmZDZlNTIvc3JjL3NlZ21lbnQtbG9hZGVyLmpzI0w5MVxuICAgICAgICB0aGlzLnJlbW92ZUJ1ZmZlclJhbmdlKGJ1ZmZlclR5cGUsIHNvdXJjZUJ1ZmZlcltidWZmZXJUeXBlXSwgMCwgdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkxldmVsVXBkYXRlZCAoeyBkZXRhaWxzIH0pIHtcbiAgICBpZiAoZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fbGV2ZWxEdXJhdGlvbiA9IGRldGFpbHMudG90YWxkdXJhdGlvbiArIGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgdGhpcy5fbGV2ZWxUYXJnZXREdXJhdGlvbiA9IGRldGFpbHMuYXZlcmFnZXRhcmdldGR1cmF0aW9uIHx8IGRldGFpbHMudGFyZ2V0ZHVyYXRpb24gfHwgMTA7XG4gICAgICB0aGlzLl9saXZlID0gZGV0YWlscy5saXZlO1xuICAgICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgTWVkaWEgU291cmNlIGR1cmF0aW9uIHRvIGN1cnJlbnQgbGV2ZWwgZHVyYXRpb24gb3Igb3ZlcnJpZGUgdG8gSW5maW5pdHkgaWYgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJcbiAgICogJ2xpdmVEdXJhdGlvbkluZmluaXR5YCBpcyBzZXQgdG8gYHRydWVgXG4gICAqIE1vcmUgZGV0YWlsczogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzM1NVxuICAgKi9cbiAgdXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24gKCkge1xuICAgIGxldCB7IGNvbmZpZyB9ID0gdGhpcy5obHM7XG4gICAgbGV0IGR1cmF0aW9uO1xuXG4gICAgaWYgKHRoaXMuX2xldmVsRHVyYXRpb24gPT09IG51bGwgfHxcbiAgICAgICF0aGlzLm1lZGlhIHx8XG4gICAgICAhdGhpcy5tZWRpYVNvdXJjZSB8fFxuICAgICAgIXRoaXMuc291cmNlQnVmZmVyIHx8XG4gICAgICB0aGlzLm1lZGlhLnJlYWR5U3RhdGUgPT09IDAgfHxcbiAgICAgIHRoaXMubWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChsZXQgdHlwZSBpbiB0aGlzLnNvdXJjZUJ1ZmZlcikge1xuICAgICAgaWYgKHRoaXMuc291cmNlQnVmZmVyW3R5cGVdLnVwZGF0aW5nID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGNhbid0IHNldCBkdXJhdGlvbiB3aGlsc3QgYSBidWZmZXIgaXMgdXBkYXRpbmdcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGR1cmF0aW9uID0gdGhpcy5tZWRpYS5kdXJhdGlvbjtcbiAgICAvLyBpbml0aWFsaXNlIHRvIHRoZSB2YWx1ZSB0aGF0IHRoZSBtZWRpYSBzb3VyY2UgaXMgcmVwb3J0aW5nXG4gICAgaWYgKHRoaXMuX21zRHVyYXRpb24gPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX21zRHVyYXRpb24gPSB0aGlzLm1lZGlhU291cmNlLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9saXZlID09PSB0cnVlICYmIGNvbmZpZy5saXZlRHVyYXRpb25JbmZpbml0eSA9PT0gdHJ1ZSkge1xuICAgICAgLy8gT3ZlcnJpZGUgZHVyYXRpb24gdG8gSW5maW5pdHlcbiAgICAgIGxvZ2dlci5sb2coJ01lZGlhIFNvdXJjZSBkdXJhdGlvbiBpcyBzZXQgdG8gSW5maW5pdHknKTtcbiAgICAgIHRoaXMuX21zRHVyYXRpb24gPSB0aGlzLm1lZGlhU291cmNlLmR1cmF0aW9uID0gSW5maW5pdHk7XG4gICAgfSBlbHNlIGlmICgodGhpcy5fbGV2ZWxEdXJhdGlvbiA+IHRoaXMuX21zRHVyYXRpb24gJiYgdGhpcy5fbGV2ZWxEdXJhdGlvbiA+IGR1cmF0aW9uKSB8fCAhTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uKSkge1xuICAgICAgLy8gbGV2ZWxEdXJhdGlvbiB3YXMgdGhlIGxhc3QgdmFsdWUgd2Ugc2V0LlxuICAgICAgLy8gbm90IHVzaW5nIG1lZGlhU291cmNlLmR1cmF0aW9uIGFzIHRoZSBicm93c2VyIG1heSB0d2VhayB0aGlzIHZhbHVlXG4gICAgICAvLyBvbmx5IHVwZGF0ZSBNZWRpYSBTb3VyY2UgZHVyYXRpb24gaWYgaXRzIHZhbHVlIGluY3JlYXNlLCB0aGlzIGlzIHRvIGF2b2lkXG4gICAgICAvLyBmbHVzaGluZyBhbHJlYWR5IGJ1ZmZlcmVkIHBvcnRpb24gd2hlbiBzd2l0Y2hpbmcgYmV0d2VlbiBxdWFsaXR5IGxldmVsXG4gICAgICBsb2dnZXIubG9nKGBVcGRhdGluZyBNZWRpYSBTb3VyY2UgZHVyYXRpb24gdG8gJHt0aGlzLl9sZXZlbER1cmF0aW9uLnRvRml4ZWQoMyl9YCk7XG4gICAgICB0aGlzLl9tc0R1cmF0aW9uID0gdGhpcy5tZWRpYVNvdXJjZS5kdXJhdGlvbiA9IHRoaXMuX2xldmVsRHVyYXRpb247XG4gICAgfVxuICB9XG5cbiAgZG9GbHVzaCAoKSB7XG4gICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBidWZmZXIgcmFuZ2VzIHRvIGZsdXNoXG4gICAgd2hpbGUgKHRoaXMuZmx1c2hSYW5nZS5sZW5ndGgpIHtcbiAgICAgIGxldCByYW5nZSA9IHRoaXMuZmx1c2hSYW5nZVswXTtcbiAgICAgIC8vIGZsdXNoQnVmZmVyIHdpbGwgYWJvcnQgYW55IGJ1ZmZlciBhcHBlbmQgaW4gcHJvZ3Jlc3MgYW5kIGZsdXNoIEF1ZGlvL1ZpZGVvIEJ1ZmZlclxuICAgICAgaWYgKHRoaXMuZmx1c2hCdWZmZXIocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgcmFuZ2UudHlwZSkpIHtcbiAgICAgICAgLy8gcmFuZ2UgZmx1c2hlZCwgcmVtb3ZlIGZyb20gZmx1c2ggYXJyYXlcbiAgICAgICAgdGhpcy5mbHVzaFJhbmdlLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX25lZWRzRmx1c2ggPSB0cnVlO1xuICAgICAgICAvLyBhdm9pZCBsb29waW5nLCB3YWl0IGZvciBTQiB1cGRhdGUgZW5kIHRvIHJldHJpZ2dlciBhIGZsdXNoXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZmx1c2hSYW5nZS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGV2ZXJ5dGhpbmcgZmx1c2hlZFxuICAgICAgdGhpcy5fbmVlZHNGbHVzaCA9IGZhbHNlO1xuXG4gICAgICAvLyBsZXQncyByZWNvbXB1dGUgdGhpcy5hcHBlbmRlZCwgd2hpY2ggaXMgdXNlZCB0byBhdm9pZCBmbHVzaCBsb29waW5nXG4gICAgICBsZXQgYXBwZW5kZWQgPSAwO1xuICAgICAgbGV0IHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgICAgICBhcHBlbmRlZCArPSBzb3VyY2VCdWZmZXJbdHlwZV0uYnVmZmVyZWQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBlcnJvciBjb3VsZCBiZSB0aHJvd24gd2hpbGUgYWNjZXNzaW5nIGJ1ZmZlcmVkLCBpbiBjYXNlIHNvdXJjZWJ1ZmZlciBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZnJvbSBNZWRpYVNvdXJjZVxuICAgICAgICAvLyB0aGlzIGlzIGhhcm1lc3MgYXQgdGhpcyBzdGFnZSwgY2F0Y2ggdGhpcyB0byBhdm9pZCByZXBvcnRpbmcgYW4gaW50ZXJuYWwgZXhjZXB0aW9uXG4gICAgICAgIGxvZ2dlci5lcnJvcignZXJyb3Igd2hpbGUgYWNjZXNzaW5nIHNvdXJjZUJ1ZmZlci5idWZmZXJlZCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmRlZCA9IGFwcGVuZGVkO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hFRCk7XG4gICAgfVxuICB9XG5cbiAgZG9BcHBlbmRpbmcgKCkge1xuXG4gICAgbGV0IHsgaGxzLCBzZWdtZW50cywgc291cmNlQnVmZmVyIH0gPSB0aGlzO1xuICAgIGlmIChPYmplY3Qua2V5cyhzb3VyY2VCdWZmZXIpLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMubWVkaWEuZXJyb3IpIHtcbiAgICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ3RyeWluZyB0byBhcHBlbmQgYWx0aG91Z2ggYSBtZWRpYSBlcnJvciBvY2N1cmVkLCBmbHVzaCBzZWdtZW50IGFuZCBhYm9ydCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hcHBlbmRpbmcpIHtcbiAgICAgICAgLy8gbG9nZ2VyLmxvZyhgc2IgYXBwZW5kaW5nIGluIHByb2dyZXNzYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzZWdtZW50cyAmJiBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHNlZ21lbnQgPSBzZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCB0eXBlID0gc2VnbWVudC50eXBlLCBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICAgIGlmICghc2IudXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgLy8gcmVzZXQgc291cmNlQnVmZmVyIGVuZGVkIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBzZWdtZW50XG4gICAgICAgICAgICAgIHNiLmVuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coYGFwcGVuZGluZyAke3NlZ21lbnQuY29udGVudH0gJHt0eXBlfSBTQiwgc2l6ZToke3NlZ21lbnQuZGF0YS5sZW5ndGh9LCAke3NlZ21lbnQucGFyZW50fWApO1xuICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IHNlZ21lbnQucGFyZW50O1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnYXBwZW5kIGJ1ZmZlciAnLCBzZWdtZW50KVxuICAgICAgICAgICAgICBzYi5hcHBlbmRCdWZmZXIoc2VnbWVudC5kYXRhKTtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvciA9IDA7XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kZWQrKztcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VnbWVudHMudW5zaGlmdChzZWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSBkb24ndCBoYXZlIGFueSBzb3VyY2UgYnVmZmVyIG1hdGNoaW5nIHdpdGggdGhpcyBzZWdtZW50IHR5cGUsXG4gICAgICAgICAgICAvLyBpdCBtZWFucyB0aGF0IE1lZGlhc291cmNlIGZhaWxzIHRvIGNyZWF0ZSBzb3VyY2VidWZmZXJcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgdGhpcyBzZWdtZW50LCBhbmQgdHJpZ2dlciB1cGRhdGUgZW5kXG4gICAgICAgICAgICB0aGlzLm9uU0JVcGRhdGVFbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIGluIGNhc2UgYW55IGVycm9yIG9jY3VyZWQgd2hpbGUgYXBwZW5kaW5nLCBwdXQgYmFjayBzZWdtZW50IGluIHNlZ21lbnRzIHRhYmxlXG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGBlcnJvciB3aGlsZSB0cnlpbmcgdG8gYXBwZW5kIGJ1ZmZlcjoke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgIHNlZ21lbnRzLnVuc2hpZnQoc2VnbWVudCk7XG4gICAgICAgICAgbGV0IGV2ZW50ID0geyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBwYXJlbnQ6IHNlZ21lbnQucGFyZW50IH07XG4gICAgICAgICAgaWYgKGVyci5jb2RlICE9PSAyMikge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kRXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcisrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvciA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjtcbiAgICAgICAgICAgIC8qIHdpdGggVUhEIGNvbnRlbnQsIHdlIGNvdWxkIGdldCBsb29wIG9mIHF1b3RhIGV4Y2VlZGVkIGVycm9yIHVudGlsXG4gICAgICAgICAgICAgIGJyb3dzZXIgaXMgYWJsZSB0byBldmljdCBzb21lIGRhdGEgZnJvbSBzb3VyY2VidWZmZXIuIHJldHJ5aW5nIGhlbHAgcmVjb3ZlcmluZyB0aGlzXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBwZW5kRXJyb3IgPiBobHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnkpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgZmFpbCAke2hscy5jb25maWcuYXBwZW5kRXJyb3JNYXhSZXRyeX0gdGltZXMgdG8gYXBwZW5kIHNlZ21lbnQgaW4gc291cmNlQnVmZmVyYCk7XG4gICAgICAgICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgZXZlbnQuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwgZXZlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXZlbnQuZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUXVvdGFFeGNlZWRlZEVycm9yOiBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI3F1b3RhZXhjZWVkZWRlcnJvclxuICAgICAgICAgICAgLy8gbGV0J3Mgc3RvcCBhcHBlbmRpbmcgYW55IHNlZ21lbnRzLCBhbmQgcmVwb3J0IEJVRkZFUl9GVUxMX0VSUk9SIGVycm9yXG4gICAgICAgICAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgICAgICAgICBldmVudC5kZXRhaWxzID0gRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SO1xuICAgICAgICAgICAgZXZlbnQuZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICBmbHVzaCBzcGVjaWZpZWQgYnVmZmVyZWQgcmFuZ2UsXG4gICAgcmV0dXJuIHRydWUgb25jZSByYW5nZSBoYXMgYmVlbiBmbHVzaGVkLlxuICAgIGFzIHNvdXJjZUJ1ZmZlci5yZW1vdmUoKSBpcyBhc3luY2hyb25vdXMsIGZsdXNoQnVmZmVyIHdpbGwgYmUgcmV0cmlnZ2VyZWQgb24gc291cmNlQnVmZmVyIHVwZGF0ZSBlbmRcbiAgKi9cbiAgZmx1c2hCdWZmZXIgKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHR5cGVJbikge1xuICAgIGxldCBzYjtcbiAgICBjb25zdCBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICBpZiAoT2JqZWN0LmtleXMoc291cmNlQnVmZmVyKS5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci5sb2coYGZsdXNoQnVmZmVyLHBvcy9zdGFydC9lbmQ6ICR7dGhpcy5tZWRpYS5jdXJyZW50VGltZS50b0ZpeGVkKDMpfS8ke3N0YXJ0T2Zmc2V0fS8ke2VuZE9mZnNldH1gKTtcbiAgICAgIC8vIHNhZmVndWFyZCB0byBhdm9pZCBpbmZpbml0ZSBsb29waW5nIDogZG9uJ3QgdHJ5IHRvIGZsdXNoIG1vcmUgdGhhbiB0aGUgbmIgb2YgYXBwZW5kZWQgc2VnbWVudHNcbiAgICAgIGlmICh0aGlzLmZsdXNoQnVmZmVyQ291bnRlciA8IHRoaXMuYXBwZW5kZWQpIHtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgICAgICAvLyBjaGVjayBpZiBzb3VyY2VidWZmZXIgdHlwZSBpcyBkZWZpbmVkICh0eXBlSW4pOiBpZiB5ZXMsIGxldCdzIG9ubHkgZmx1c2ggdGhpcyBvbmVcbiAgICAgICAgICAvLyBpZiBubywgbGV0J3MgZmx1c2ggYWxsIHNvdXJjZWJ1ZmZlcnNcbiAgICAgICAgICBpZiAodHlwZUluICYmIHR5cGUgIT09IHR5cGVJbikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgICAgLy8gd2UgYXJlIGdvaW5nIHRvIGZsdXNoIGJ1ZmZlciwgbWFyayBzb3VyY2UgYnVmZmVyIGFzICdub3QgZW5kZWQnXG4gICAgICAgICAgc2IuZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIXNiLnVwZGF0aW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZW1vdmVCdWZmZXJSYW5nZSh0eXBlLCBzYiwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlckNvdW50ZXIrKztcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybignY2Fubm90IGZsdXNoLCBzYiB1cGRhdGluZyBpbiBwcm9ncmVzcycpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ2Fib3J0IGZsdXNoaW5nIHRvbyBtYW55IHJldHJpZXMnKTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci5sb2coJ2J1ZmZlciBmbHVzaGVkJyk7XG4gICAgfVxuICAgIC8vIGV2ZXJ5dGhpbmcgZmx1c2hlZCAhXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBmaXJzdCBidWZmZXJlZCByYW5nZSBmcm9tIHByb3ZpZGVkIHNvdXJjZSBidWZmZXIgdGhhdCBsaWVzIHdpdGhpbiBnaXZlbiBzdGFydCBhbmQgZW5kIG9mZnNldHMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIFR5cGUgb2YgdGhlIHNvdXJjZSBidWZmZXIsIGxvZ2dpbmcgcHVycG9zZXMgb25seS5cbiAgICogQHBhcmFtIHNiIFRhcmdldCBTb3VyY2VCdWZmZXIgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBzdGFydE9mZnNldFxuICAgKiBAcGFyYW0gZW5kT2Zmc2V0XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIHdoZW4gc291cmNlIGJ1ZmZlciByZW1vdmUgcmVxdWVzdGVkLlxuICAgKi9cbiAgcmVtb3ZlQnVmZmVyUmFuZ2UgKHR5cGUsIHNiLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2IuYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGJ1ZlN0YXJ0ID0gc2IuYnVmZmVyZWQuc3RhcnQoaSk7XG4gICAgICAgIGxldCBidWZFbmQgPSBzYi5idWZmZXJlZC5lbmQoaSk7XG4gICAgICAgIGxldCByZW1vdmVTdGFydCA9IE1hdGgubWF4KGJ1ZlN0YXJ0LCBzdGFydE9mZnNldCk7XG4gICAgICAgIGxldCByZW1vdmVFbmQgPSBNYXRoLm1pbihidWZFbmQsIGVuZE9mZnNldCk7XG5cbiAgICAgICAgLyogc29tZXRpbWVzIHNvdXJjZWJ1ZmZlci5yZW1vdmUoKSBkb2VzIG5vdCBmbHVzaFxuICAgICAgICAgIHRoZSBleGFjdCBleHBlY3RlZCB0aW1lIHJhbmdlLlxuICAgICAgICAgIHRvIGF2b2lkIHJvdW5kaW5nIGlzc3Vlcy9pbmZpbml0ZSBsb29wLFxuICAgICAgICAgIG9ubHkgZmx1c2ggYnVmZmVyIHJhbmdlIG9mIGxlbmd0aCBncmVhdGVyIHRoYW4gNTAwbXMuXG4gICAgICAgICovXG4gICAgICAgIGlmIChNYXRoLm1pbihyZW1vdmVFbmQsIGJ1ZkVuZCkgLSByZW1vdmVTdGFydCA+IDAuNSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coYHNiIHJlbW92ZSAke3R5cGV9IFske3JlbW92ZVN0YXJ0fSwke3JlbW92ZUVuZH1dLCBvZiBbJHtidWZTdGFydH0sJHtidWZFbmR9XSwgcG9zOiR7dGhpcy5tZWRpYS5jdXJyZW50VGltZX1gKTtcbiAgICAgICAgICBzYi5yZW1vdmUocmVtb3ZlU3RhcnQsIHJlbW92ZUVuZCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLndhcm4oJ3JlbW92ZUJ1ZmZlclJhbmdlIGZhaWxlZCcsIGVycm9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnVmZmVyQ29udHJvbGxlcjtcbiIsIi8qXG4gKiBjYXAgc3RyZWFtIGxldmVsIHRvIG1lZGlhIHNpemUgZGltZW5zaW9uIGNvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcblxuY2xhc3MgQ2FwTGV2ZWxDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscykge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50LkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hJTkcsXG4gICAgICBFdmVudC5NQU5JRkVTVF9QQVJTRUQsXG4gICAgICBFdmVudC5CVUZGRVJfQ09ERUNTLFxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HKTtcblxuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSBudWxsO1xuICAgIHRoaXMubGV2ZWxzID0gW107XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgdGhpcy50aW1lciA9IG51bGw7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBpZiAodGhpcy5obHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMuX3N0b3BDYXBwaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcHNEcm9wTGV2ZWxDYXBwaW5nIChkYXRhKSB7XG4gICAgLy8gRG9uJ3QgYWRkIGEgcmVzdHJpY3RlZCBsZXZlbCBtb3JlIHRoYW4gb25jZVxuICAgIGlmIChDYXBMZXZlbENvbnRyb2xsZXIuaXNMZXZlbEFsbG93ZWQoZGF0YS5kcm9wcGVkTGV2ZWwsIHRoaXMucmVzdHJpY3RlZExldmVscykpIHtcbiAgICAgIHRoaXMucmVzdHJpY3RlZExldmVscy5wdXNoKGRhdGEuZHJvcHBlZExldmVsKTtcbiAgICB9XG4gIH1cblxuICBvbk1lZGlhQXR0YWNoaW5nIChkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xuICB9XG5cbiAgb25NYW5pZmVzdFBhcnNlZCAoZGF0YSkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gICAgdGhpcy5maXJzdExldmVsID0gZGF0YS5maXJzdExldmVsO1xuICAgIGlmIChobHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplICYmIGRhdGEudmlkZW8pIHtcbiAgICAgIC8vIFN0YXJ0IGNhcHBpbmcgaW1tZWRpYXRlbHkgaWYgdGhlIG1hbmlmZXN0IGhhcyBzaWduYWxlZCB2aWRlbyBjb2RlY3NcbiAgICAgIHRoaXMuX3N0YXJ0Q2FwcGluZygpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE9ubHkgYWN0aXZhdGUgY2FwcGluZyB3aGVuIHBsYXlpbmcgYSB2aWRlbyBzdHJlYW07IG90aGVyd2lzZSwgbXVsdGktYml0cmF0ZSBhdWRpby1vbmx5IHN0cmVhbXMgd2lsbCBiZSByZXN0cmljdGVkXG4gIC8vIHRvIHRoZSBmaXJzdCBsZXZlbFxuICBvbkJ1ZmZlckNvZGVjcyAoZGF0YSkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGlmIChobHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplICYmIGRhdGEudmlkZW8pIHtcbiAgICAgIC8vIElmIHRoZSBtYW5pZmVzdCBkaWQgbm90IHNpZ25hbCBhIHZpZGVvIGNvZGVjIGNhcHBpbmcgaGFzIGJlZW4gZGVmZXJyZWQgdW50aWwgd2UncmUgY2VydGFpbiB2aWRlbyBpcyBwcmVzZW50XG4gICAgICB0aGlzLl9zdGFydENhcHBpbmcoKTtcbiAgICB9XG4gIH1cblxuICBvbkxldmVsc1VwZGF0ZWQgKGRhdGEpIHtcbiAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICB9XG5cbiAgb25NZWRpYURldGFjaGluZyAoKSB7XG4gICAgdGhpcy5fc3RvcENhcHBpbmcoKTtcbiAgfVxuXG4gIGRldGVjdFBsYXllclNpemUgKCkge1xuICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICBsZXQgbGV2ZWxzTGVuZ3RoID0gdGhpcy5sZXZlbHMgPyB0aGlzLmxldmVscy5sZW5ndGggOiAwO1xuICAgICAgaWYgKGxldmVsc0xlbmd0aCkge1xuICAgICAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAgICAgaGxzLmF1dG9MZXZlbENhcHBpbmcgPSB0aGlzLmdldE1heExldmVsKGxldmVsc0xlbmd0aCAtIDEpO1xuICAgICAgICBpZiAoaGxzLmF1dG9MZXZlbENhcHBpbmcgPiB0aGlzLmF1dG9MZXZlbENhcHBpbmcpIHtcbiAgICAgICAgICAvLyBpZiBhdXRvIGxldmVsIGNhcHBpbmcgaGFzIGEgaGlnaGVyIHZhbHVlIGZvciB0aGUgcHJldmlvdXMgb25lLCBmbHVzaCB0aGUgYnVmZmVyIHVzaW5nIG5leHRMZXZlbFN3aXRjaFxuICAgICAgICAgIC8vIHVzdWFsbHkgaGFwcGVuIHdoZW4gdGhlIHVzZXIgZ28gdG8gdGhlIGZ1bGxzY3JlZW4gbW9kZS5cbiAgICAgICAgICBobHMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBobHMuYXV0b0xldmVsQ2FwcGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICAqIHJldHVybnMgbGV2ZWwgc2hvdWxkIGJlIHRoZSBvbmUgd2l0aCB0aGUgZGltZW5zaW9ucyBlcXVhbCBvciBncmVhdGVyIHRoYW4gdGhlIG1lZGlhIChwbGF5ZXIpIGRpbWVuc2lvbnMgKHNvIHRoZSB2aWRlbyB3aWxsIGJlIGRvd25zY2FsZWQpXG4gICovXG4gIGdldE1heExldmVsIChjYXBMZXZlbEluZGV4KSB7XG4gICAgaWYgKCF0aGlzLmxldmVscykge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkTGV2ZWxzID0gdGhpcy5sZXZlbHMuZmlsdGVyKChsZXZlbCwgaW5kZXgpID0+XG4gICAgICBDYXBMZXZlbENvbnRyb2xsZXIuaXNMZXZlbEFsbG93ZWQoaW5kZXgsIHRoaXMucmVzdHJpY3RlZExldmVscykgJiYgaW5kZXggPD0gY2FwTGV2ZWxJbmRleFxuICAgICk7XG5cbiAgICByZXR1cm4gQ2FwTGV2ZWxDb250cm9sbGVyLmdldE1heExldmVsQnlNZWRpYVNpemUodmFsaWRMZXZlbHMsIHRoaXMubWVkaWFXaWR0aCwgdGhpcy5tZWRpYUhlaWdodCk7XG4gIH1cblxuICBfc3RhcnRDYXBwaW5nICgpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgLy8gRG9uJ3QgcmVzZXQgY2FwcGluZyBpZiBzdGFydGVkIHR3aWNlOyB0aGlzIGNhbiBoYXBwZW4gaWYgdGhlIG1hbmlmZXN0IHNpZ25hbHMgYSB2aWRlbyBjb2RlY1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdGhpcy5obHMuZmlyc3RMZXZlbCA9IHRoaXMuZ2V0TWF4TGV2ZWwodGhpcy5maXJzdExldmVsKTtcbiAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLmRldGVjdFBsYXllclNpemUuYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgdGhpcy5kZXRlY3RQbGF5ZXJTaXplKCk7XG4gIH1cblxuICBfc3RvcENhcHBpbmcgKCkge1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IG51bGw7XG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICB0aGlzLnRpbWVyID0gY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGdldCBtZWRpYVdpZHRoICgpIHtcbiAgICBsZXQgd2lkdGg7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgd2lkdGggPSBtZWRpYS53aWR0aCB8fCBtZWRpYS5jbGllbnRXaWR0aCB8fCBtZWRpYS5vZmZzZXRXaWR0aDtcbiAgICAgIHdpZHRoICo9IENhcExldmVsQ29udHJvbGxlci5jb250ZW50U2NhbGVGYWN0b3I7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aDtcbiAgfVxuXG4gIGdldCBtZWRpYUhlaWdodCAoKSB7XG4gICAgbGV0IGhlaWdodDtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBoZWlnaHQgPSBtZWRpYS5oZWlnaHQgfHwgbWVkaWEuY2xpZW50SGVpZ2h0IHx8IG1lZGlhLm9mZnNldEhlaWdodDtcbiAgICAgIGhlaWdodCAqPSBDYXBMZXZlbENvbnRyb2xsZXIuY29udGVudFNjYWxlRmFjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gaGVpZ2h0O1xuICB9XG5cbiAgc3RhdGljIGdldCBjb250ZW50U2NhbGVGYWN0b3IgKCkge1xuICAgIGxldCBwaXhlbFJhdGlvID0gMTtcbiAgICB0cnkge1xuICAgICAgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIHBpeGVsUmF0aW87XG4gIH1cblxuICBzdGF0aWMgaXNMZXZlbEFsbG93ZWQgKGxldmVsLCByZXN0cmljdGVkTGV2ZWxzID0gW10pIHtcbiAgICByZXR1cm4gcmVzdHJpY3RlZExldmVscy5pbmRleE9mKGxldmVsKSA9PT0gLTE7XG4gIH1cblxuICBzdGF0aWMgZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZSAobGV2ZWxzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFsZXZlbHMgfHwgKGxldmVscyAmJiAhbGV2ZWxzLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyBMZXZlbHMgY2FuIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucyBidXQgZGlmZmVyaW5nIGJhbmR3aWR0aHMgLSBzaW5jZSBsZXZlbHMgYXJlIG9yZGVyZWQsIHdlIGNhbiBsb29rIHRvIHRoZSBuZXh0XG4gICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2UndmUgY2hvc2VuIHRoZSBncmVhdGVzdCBiYW5kd2lkdGggZm9yIHRoZSBtZWRpYSdzIGRpbWVuc2lvbnNcbiAgICBjb25zdCBhdEdyZWF0ZXN0QmFuZGl3ZHRoID0gKGN1ckxldmVsLCBuZXh0TGV2ZWwpID0+IHtcbiAgICAgIGlmICghbmV4dExldmVsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3VyTGV2ZWwud2lkdGggIT09IG5leHRMZXZlbC53aWR0aCB8fCBjdXJMZXZlbC5oZWlnaHQgIT09IG5leHRMZXZlbC5oZWlnaHQ7XG4gICAgfTtcblxuICAgIC8vIElmIHdlIHJ1biB0aHJvdWdoIHRoZSBsb29wIHdpdGhvdXQgYnJlYWtpbmcsIHRoZSBtZWRpYSdzIGRpbWVuc2lvbnMgYXJlIGdyZWF0ZXIgdGhhbiBldmVyeSBsZXZlbCwgc28gZGVmYXVsdCB0b1xuICAgIC8vIHRoZSBtYXggbGV2ZWxcbiAgICBsZXQgbWF4TGV2ZWxJbmRleCA9IGxldmVscy5sZW5ndGggLSAxO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW2ldO1xuICAgICAgaWYgKChsZXZlbC53aWR0aCA+PSB3aWR0aCB8fCBsZXZlbC5oZWlnaHQgPj0gaGVpZ2h0KSAmJiBhdEdyZWF0ZXN0QmFuZGl3ZHRoKGxldmVsLCBsZXZlbHNbaSArIDFdKSkge1xuICAgICAgICBtYXhMZXZlbEluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heExldmVsSW5kZXg7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FwTGV2ZWxDb250cm9sbGVyO1xuIiwiLyoqXG4gKiBAYXV0aG9yIFN0ZXBoYW4gSGVzc2UgPGRpc3BhcmF0QGdtYWlsLmNvbT4gfCA8dGNoYWthYmFtQGdtYWlsLmNvbT5cbiAqXG4gKiBEUk0gc3VwcG9ydCBmb3IgSGxzLmpzXG4gKi9cblxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY29uc3QgeyBYTUxIdHRwUmVxdWVzdCB9ID0gd2luZG93O1xuXG5jb25zdCBNQVhfTElDRU5TRV9SRVFVRVNUX0ZBSUxVUkVTID0gMztcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9OYXZpZ2F0b3IvcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzXG4gKi9cbmNvbnN0IEtleVN5c3RlbXMgPSB7XG4gIFdJREVWSU5FOiAnY29tLndpZGV2aW5lLmFscGhhJyxcbiAgUExBWVJFQURZOiAnY29tLm1pY3Jvc29mdC5wbGF5cmVhZHknXG59O1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvblxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhdWRpb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIGF1ZGlvIGNvZGVjcyB0byBzdXBwb3J0XG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHZpZGVvQ29kZWNzIExpc3Qgb2YgcmVxdWlyZWQgdmlkZW8gY29kZWNzIHRvIHN1cHBvcnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBkcm1TeXN0ZW1PcHRpb25zIE9wdGlvbmFsIHBhcmFtZXRlcnMvcmVxdWlyZW1lbnRzIGZvciB0aGUga2V5LXN5c3RlbVxuICogQHJldHVybnMge0FycmF5PE1lZGlhU3lzdGVtQ29uZmlndXJhdGlvbj59IEFuIGFycmF5IG9mIHN1cHBvcnRlZCBjb25maWd1cmF0aW9uc1xuICovXG5cbmNvbnN0IGNyZWF0ZVdpZGV2aW5lTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyA9IGZ1bmN0aW9uIChhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIGRybVN5c3RlbU9wdGlvbnMpIHsgLyoganNoaW50IGlnbm9yZTpsaW5lICovXG4gIGNvbnN0IGJhc2VDb25maWcgPSB7XG4gICAgLy8gaW5pdERhdGFUeXBlczogWydrZXlpZHMnLCAnbXA0J10sXG4gICAgLy8gbGFiZWw6IFwiXCIsXG4gICAgLy8gcGVyc2lzdGVudFN0YXRlOiBcIm5vdC1hbGxvd2VkXCIsIC8vIG9yIFwicmVxdWlyZWRcIiA/XG4gICAgLy8gZGlzdGluY3RpdmVJZGVudGlmaWVyOiBcIm5vdC1hbGxvd2VkXCIsIC8vIG9yIFwicmVxdWlyZWRcIiA/XG4gICAgLy8gc2Vzc2lvblR5cGVzOiBbJ3RlbXBvcmFyeSddLFxuICAgIHZpZGVvQ2FwYWJpbGl0aWVzOiBbXG4gICAgICAvLyB7IGNvbnRlbnRUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJhdmMxLjQyRTAxRVwiJyB9XG4gICAgXVxuICB9O1xuXG4gIHZpZGVvQ29kZWNzLmZvckVhY2goKGNvZGVjKSA9PiB7XG4gICAgYmFzZUNvbmZpZy52aWRlb0NhcGFiaWxpdGllcy5wdXNoKHtcbiAgICAgIGNvbnRlbnRUeXBlOiBgdmlkZW8vbXA0OyBjb2RlY3M9XCIke2NvZGVjfVwiYFxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gW1xuICAgIGJhc2VDb25maWdcbiAgXTtcbn07XG5cbi8qKlxuICogVGhlIGlkZWEgaGVyZSBpcyB0byBoYW5kbGUga2V5LXN5c3RlbSAoYW5kIHRoZWlyIHJlc3BlY3RpdmUgcGxhdGZvcm1zKSBzcGVjaWZpYyBjb25maWd1cmF0aW9uIGRpZmZlcmVuY2VzXG4gKiBpbiBvcmRlciB0byB3b3JrIHdpdGggdGhlIGxvY2FsIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyBtZXRob2QuXG4gKlxuICogV2UgY2FuIGFsc28gcnVsZS1vdXQgcGxhdGZvcm0tcmVsYXRlZCBrZXktc3lzdGVtIHN1cHBvcnQgYXQgdGhpcyBwb2ludCBieSB0aHJvd2luZyBhbiBlcnJvciBvciByZXR1cm5pbmcgbnVsbC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5U3lzdGVtIElkZW50aWZpZXIgZm9yIHRoZSBrZXktc3lzdGVtLCBzZWUgYEtleVN5c3RlbXNgIGVudW1cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXVkaW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCBhdWRpbyBjb2RlY3MgdG8gc3VwcG9ydFxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB2aWRlb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIHZpZGVvIGNvZGVjcyB0byBzdXBwb3J0XG4gKiBAcmV0dXJucyB7QXJyYXk8TWVkaWFTeXN0ZW1Db25maWd1cmF0aW9uPiB8IG51bGx9IEEgbm9uLWVtcHR5IEFycmF5IG9mIE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbiBvYmplY3RzIG9yIGBudWxsYFxuICovXG5jb25zdCBnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zID0gZnVuY3Rpb24gKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKSB7XG4gIHN3aXRjaCAoa2V5U3lzdGVtKSB7XG4gIGNhc2UgS2V5U3lzdGVtcy5XSURFVklORTpcbiAgICByZXR1cm4gY3JlYXRlV2lkZXZpbmVNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcyk7XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgRXJyb3IoJ1Vua25vd24ga2V5LXN5c3RlbTogJyArIGtleVN5c3RlbSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ29udHJvbGxlciB0byBkZWFsIHdpdGggZW5jcnlwdGVkIG1lZGlhIGV4dGVuc2lvbnMgKEVNRSlcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VuY3J5cHRlZF9NZWRpYV9FeHRlbnNpb25zX0FQSVxuICpcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEVNRUNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICAvKipcbiAgICAgKiBAY29uc3RydWN0c1xuICAgICAqIEBwYXJhbSB7SGxzfSBobHMgT3VyIEhscy5qcyBpbnN0YW5jZVxuICAgICAqL1xuICBjb25zdHJ1Y3RvciAoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNIRUQsXG4gICAgICBFdmVudC5NQU5JRkVTVF9QQVJTRURcbiAgICApO1xuXG4gICAgdGhpcy5fd2lkZXZpbmVMaWNlbnNlVXJsID0gaGxzLmNvbmZpZy53aWRldmluZUxpY2Vuc2VVcmw7XG4gICAgdGhpcy5fbGljZW5zZVhoclNldHVwID0gaGxzLmNvbmZpZy5saWNlbnNlWGhyU2V0dXA7XG4gICAgdGhpcy5fZW1lRW5hYmxlZCA9IGhscy5jb25maWcuZW1lRW5hYmxlZDtcblxuICAgIHRoaXMuX3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyA9IGhscy5jb25maWcucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYztcblxuICAgIHRoaXMuX21lZGlhS2V5c0xpc3QgPSBbXTtcbiAgICB0aGlzLl9tZWRpYSA9IG51bGw7XG5cbiAgICB0aGlzLl9oYXNTZXRNZWRpYUtleXMgPSBmYWxzZTtcbiAgICB0aGlzLl9pc01lZGlhRW5jcnlwdGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDA7XG4gIH1cblxuICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlTeXN0ZW0gSWRlbnRpZmllciBmb3IgdGhlIGtleS1zeXN0ZW0sIHNlZSBgS2V5U3lzdGVtc2AgZW51bVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IExpY2Vuc2Ugc2VydmVyIFVSTCBmb3Iga2V5LXN5c3RlbSAoaWYgYW55IGNvbmZpZ3VyZWQsIG90aGVyd2lzZSBjYXVzZXMgZXJyb3IpXG4gICAgICovXG4gIGdldExpY2Vuc2VTZXJ2ZXJVcmwgKGtleVN5c3RlbSkge1xuICAgIGxldCB1cmw7XG4gICAgc3dpdGNoIChrZXlTeXN0ZW0pIHtcbiAgICBjYXNlIEtleVN5c3RlbXMuV0lERVZJTkU6XG4gICAgICB1cmwgPSB0aGlzLl93aWRldmluZUxpY2Vuc2VVcmw7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdXJsID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICghdXJsKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoYE5vIGxpY2Vuc2Ugc2VydmVyIFVSTCBjb25maWd1cmVkIGZvciBrZXktc3lzdGVtIFwiJHtrZXlTeXN0ZW19XCJgKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9MSUNFTlNFX1JFUVVFU1RfRkFJTEVELFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFJlcXVlc3RzIGFjY2VzcyBvYmplY3QgYW5kIGFkZHMgaXQgdG8gb3VyIGxpc3QgdXBvbiBzdWNjZXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5U3lzdGVtIFN5c3RlbSBJRCAoc2VlIGBLZXlTeXN0ZW1zYClcbiAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGF1ZGlvQ29kZWNzIExpc3Qgb2YgcmVxdWlyZWQgYXVkaW8gY29kZWNzIHRvIHN1cHBvcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHZpZGVvQ29kZWNzIExpc3Qgb2YgcmVxdWlyZWQgdmlkZW8gY29kZWNzIHRvIHN1cHBvcnRcbiAgICAgKi9cbiAgX2F0dGVtcHRLZXlTeXN0ZW1BY2Nlc3MgKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKSB7XG4gICAgLy8gVE9ETzogYWRkIG90aGVyIERSTSBcIm9wdGlvbnNcIlxuXG4gICAgY29uc3QgbWVkaWFLZXlTeXN0ZW1Db25maWdzID0gZ2V0U3VwcG9ydGVkTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhrZXlTeXN0ZW0sIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcyk7XG5cbiAgICBpZiAoIW1lZGlhS2V5U3lzdGVtQ29uZmlncykge1xuICAgICAgbG9nZ2VyLndhcm4oJ0NhbiBub3QgY3JlYXRlIGNvbmZpZyBmb3Iga2V5LXN5c3RlbSAobWF5YmUgYmVjYXVzZSBwbGF0Zm9ybSBpcyBub3Qgc3VwcG9ydGVkKTonLCBrZXlTeXN0ZW0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvZ2dlci5sb2coJ1JlcXVlc3RpbmcgZW5jcnlwdGVkIG1lZGlhIGtleS1zeXN0ZW0gYWNjZXNzJyk7XG5cbiAgICAvLyBleHBlY3RpbmcgaW50ZXJmYWNlIGxpa2Ugd2luZG93Lm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NcbiAgICB0aGlzLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyhrZXlTeXN0ZW0sIG1lZGlhS2V5U3lzdGVtQ29uZmlncylcbiAgICAgIC50aGVuKChtZWRpYUtleVN5c3RlbUFjY2VzcykgPT4ge1xuICAgICAgICB0aGlzLl9vbk1lZGlhS2V5U3lzdGVtQWNjZXNzT2J0YWluZWQoa2V5U3lzdGVtLCBtZWRpYUtleVN5c3RlbUFjY2Vzcyk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gb2J0YWluIGtleS1zeXN0ZW0gXCIke2tleVN5c3RlbX1cIiBhY2Nlc3M6YCwgZXJyKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgZ2V0IHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyAoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIGZ1bmN0aW9uIGNvbmZpZ3VyZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzO1xuICB9XG5cbiAgLyoqXG4gICAgICogSGFuZGxlcyBvYnRhaW5pbmcgYWNjZXNzIHRvIGEga2V5LXN5c3RlbVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVN5c3RlbVxuICAgICAqIEBwYXJhbSB7TWVkaWFLZXlTeXN0ZW1BY2Nlc3N9IG1lZGlhS2V5U3lzdGVtQWNjZXNzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYUtleVN5c3RlbUFjY2Vzc1xuICAgICAqL1xuICBfb25NZWRpYUtleVN5c3RlbUFjY2Vzc09idGFpbmVkIChrZXlTeXN0ZW0sIG1lZGlhS2V5U3lzdGVtQWNjZXNzKSB7XG4gICAgbG9nZ2VyLmxvZyhgQWNjZXNzIGZvciBrZXktc3lzdGVtIFwiJHtrZXlTeXN0ZW19XCIgb2J0YWluZWRgKTtcblxuICAgIGNvbnN0IG1lZGlhS2V5c0xpc3RJdGVtID0ge1xuICAgICAgbWVkaWFLZXlzOiBudWxsLFxuICAgICAgbWVkaWFLZXlzU2Vzc2lvbjogbnVsbCxcbiAgICAgIG1lZGlhS2V5c1Nlc3Npb25Jbml0aWFsaXplZDogZmFsc2UsXG4gICAgICBtZWRpYUtleVN5c3RlbUFjY2VzczogbWVkaWFLZXlTeXN0ZW1BY2Nlc3MsXG4gICAgICBtZWRpYUtleVN5c3RlbURvbWFpbjoga2V5U3lzdGVtXG4gICAgfTtcblxuICAgIHRoaXMuX21lZGlhS2V5c0xpc3QucHVzaChtZWRpYUtleXNMaXN0SXRlbSk7XG5cbiAgICBtZWRpYUtleVN5c3RlbUFjY2Vzcy5jcmVhdGVNZWRpYUtleXMoKVxuICAgICAgLnRoZW4oKG1lZGlhS2V5cykgPT4ge1xuICAgICAgICBtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXMgPSBtZWRpYUtleXM7XG5cbiAgICAgICAgbG9nZ2VyLmxvZyhgTWVkaWEta2V5cyBjcmVhdGVkIGZvciBrZXktc3lzdGVtIFwiJHtrZXlTeXN0ZW19XCJgKTtcblxuICAgICAgICB0aGlzLl9vbk1lZGlhS2V5c0NyZWF0ZWQoKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgbWVkaWEta2V5czonLCBlcnIpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICAgKiBIYW5kbGVzIGtleS1jcmVhdGlvbiAocmVwcmVzZW50cyBhY2Nlc3MgdG8gQ0RNKS4gV2UgYXJlIGdvaW5nIHRvIGNyZWF0ZSBrZXktc2Vzc2lvbnMgdXBvbiB0aGlzXG4gICAgICogZm9yIGFsbCBleGlzdGluZyBrZXlzIHdoZXJlIG5vIHNlc3Npb24gZXhpc3RzIHlldC5cbiAgICAgKi9cbiAgX29uTWVkaWFLZXlzQ3JlYXRlZCAoKSB7XG4gICAgLy8gY2hlY2sgZm9yIGFsbCBrZXktbGlzdCBpdGVtcyBpZiBhIHNlc3Npb24gZXhpc3RzLCBvdGhlcndpc2UsIGNyZWF0ZSBvbmVcbiAgICB0aGlzLl9tZWRpYUtleXNMaXN0LmZvckVhY2goKG1lZGlhS2V5c0xpc3RJdGVtKSA9PiB7XG4gICAgICBpZiAoIW1lZGlhS2V5c0xpc3RJdGVtLm1lZGlhS2V5c1Nlc3Npb24pIHtcbiAgICAgICAgbWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbiA9IG1lZGlhS2V5c0xpc3RJdGVtLm1lZGlhS2V5cy5jcmVhdGVTZXNzaW9uKCk7XG4gICAgICAgIHRoaXMuX29uTmV3TWVkaWFLZXlTZXNzaW9uKG1lZGlhS2V5c0xpc3RJdGVtLm1lZGlhS2V5c1Nlc3Npb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGtleVNlc3Npb25cbiAgICAgKi9cbiAgX29uTmV3TWVkaWFLZXlTZXNzaW9uIChrZXlTZXNzaW9uKSB7XG4gICAgbG9nZ2VyLmxvZyhgTmV3IGtleS1zeXN0ZW0gc2Vzc2lvbiAke2tleVNlc3Npb24uc2Vzc2lvbklkfWApO1xuXG4gICAga2V5U2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLl9vbktleVNlc3Npb25NZXNzYWdlKGtleVNlc3Npb24sIGV2ZW50Lm1lc3NhZ2UpO1xuICAgIH0sIGZhbHNlKTtcbiAgfVxuXG4gIF9vbktleVNlc3Npb25NZXNzYWdlIChrZXlTZXNzaW9uLCBtZXNzYWdlKSB7XG4gICAgbG9nZ2VyLmxvZygnR290IEVNRSBtZXNzYWdlIGV2ZW50LCBjcmVhdGluZyBsaWNlbnNlIHJlcXVlc3QnKTtcblxuICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlKG1lc3NhZ2UsIChkYXRhKSA9PiB7XG4gICAgICBsb2dnZXIubG9nKCdSZWNlaXZlZCBsaWNlbnNlIGRhdGEsIHVwZGF0aW5nIGtleS1zZXNzaW9uJyk7XG4gICAgICBrZXlTZXNzaW9uLnVwZGF0ZShkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9vbk1lZGlhRW5jcnlwdGVkIChpbml0RGF0YVR5cGUsIGluaXREYXRhKSB7XG4gICAgbG9nZ2VyLmxvZyhgTWVkaWEgaXMgZW5jcnlwdGVkIHVzaW5nIFwiJHtpbml0RGF0YVR5cGV9XCIgaW5pdCBkYXRhIHR5cGVgKTtcblxuICAgIHRoaXMuX2lzTWVkaWFFbmNyeXB0ZWQgPSB0cnVlO1xuICAgIHRoaXMuX21lZGlhRW5jcnlwdGlvbkluaXREYXRhVHlwZSA9IGluaXREYXRhVHlwZTtcbiAgICB0aGlzLl9tZWRpYUVuY3J5cHRpb25Jbml0RGF0YSA9IGluaXREYXRhO1xuXG4gICAgdGhpcy5fYXR0ZW1wdFNldE1lZGlhS2V5cygpO1xuICAgIHRoaXMuX2dlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKCk7XG4gIH1cblxuICBfYXR0ZW1wdFNldE1lZGlhS2V5cyAoKSB7XG4gICAgaWYgKCF0aGlzLl9oYXNTZXRNZWRpYUtleXMpIHtcbiAgICAgIC8vIEZJWE1FOiBzZWUgaWYgd2UgY2FuL3dhbnQvbmVlZC10byByZWFsbHkgdG8gZGVhbCB3aXRoIHNldmVyYWwgcG90ZW50aWFsIGtleS1zZXNzaW9ucz9cbiAgICAgIGNvbnN0IGtleXNMaXN0SXRlbSA9IHRoaXMuX21lZGlhS2V5c0xpc3RbMF07XG4gICAgICBpZiAoIWtleXNMaXN0SXRlbSB8fCAha2V5c0xpc3RJdGVtLm1lZGlhS2V5cykge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZhdGFsOiBNZWRpYSBpcyBlbmNyeXB0ZWQgYnV0IG5vIENETSBhY2Nlc3Mgb3Igbm8ga2V5cyBoYXZlIGJlZW4gb2J0YWluZWQgeWV0Jyk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fS0VZUyxcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsb2dnZXIubG9nKCdTZXR0aW5nIGtleXMgZm9yIGVuY3J5cHRlZCBtZWRpYScpO1xuXG4gICAgICB0aGlzLl9tZWRpYS5zZXRNZWRpYUtleXMoa2V5c0xpc3RJdGVtLm1lZGlhS2V5cyk7XG4gICAgICB0aGlzLl9oYXNTZXRNZWRpYUtleXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIF9nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbiAoKSB7XG4gICAgLy8gRklYTUU6IHNlZSBpZiB3ZSBjYW4vd2FudC9uZWVkLXRvIHJlYWxseSB0byBkZWFsIHdpdGggc2V2ZXJhbCBwb3RlbnRpYWwga2V5LXNlc3Npb25zP1xuICAgIGNvbnN0IGtleXNMaXN0SXRlbSA9IHRoaXMuX21lZGlhS2V5c0xpc3RbMF07XG4gICAgaWYgKCFrZXlzTGlzdEl0ZW0pIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmF0YWw6IE1lZGlhIGlzIGVuY3J5cHRlZCBidXQgbm90IGFueSBrZXktc3lzdGVtIGFjY2VzcyBoYXMgYmVlbiBvYnRhaW5lZCB5ZXQnKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19BQ0NFU1MsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5c0xpc3RJdGVtLm1lZGlhS2V5c1Nlc3Npb25Jbml0aWFsaXplZCkge1xuICAgICAgbG9nZ2VyLndhcm4oJ0tleS1TZXNzaW9uIGFscmVhZHkgaW5pdGlhbGl6ZWQgYnV0IHJlcXVlc3RlZCBhZ2FpbicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGtleVNlc3Npb24gPSBrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbjtcbiAgICBpZiAoIWtleVNlc3Npb24pIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmF0YWw6IE1lZGlhIGlzIGVuY3J5cHRlZCBidXQgbm8ga2V5LXNlc3Npb24gZXhpc3RpbmcnKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19TRVNTSU9OLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5pdERhdGFUeXBlID0gdGhpcy5fbWVkaWFFbmNyeXB0aW9uSW5pdERhdGFUeXBlO1xuICAgIGNvbnN0IGluaXREYXRhID0gdGhpcy5fbWVkaWFFbmNyeXB0aW9uSW5pdERhdGE7XG5cbiAgICBsb2dnZXIubG9nKGBHZW5lcmF0aW5nIGtleS1zZXNzaW9uIHJlcXVlc3QgZm9yIFwiJHtpbml0RGF0YVR5cGV9XCIgaW5pdCBkYXRhIHR5cGVgKTtcblxuICAgIGtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAga2V5U2Vzc2lvbi5nZW5lcmF0ZVJlcXVlc3QoaW5pdERhdGFUeXBlLCBpbml0RGF0YSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdLZXktc2Vzc2lvbiBnZW5lcmF0aW9uIHN1Y2NlZWRlZCcpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBrZXktc2Vzc2lvbiByZXF1ZXN0OicsIGVycik7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fU0VTU0lPTixcbiAgICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgTGljZW5zZSBzZXJ2ZXIgVVJMXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0ga2V5TWVzc2FnZSBNZXNzYWdlIGRhdGEgaXNzdWVkIGJ5IGtleS1zeXN0ZW1cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgd2hlbiBYSFIgaGFzIHN1Y2NlZWRlZFxuICAgICAqIEByZXR1cm5zIHtYTUxIdHRwUmVxdWVzdH0gVW5zZW50IChidXQgb3BlbmVkIHN0YXRlKSBYSFIgb2JqZWN0XG4gICAgICovXG4gIF9jcmVhdGVMaWNlbnNlWGhyICh1cmwsIGtleU1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgY29uc3QgbGljZW5zZVhoclNldHVwID0gdGhpcy5fbGljZW5zZVhoclNldHVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChsaWNlbnNlWGhyU2V0dXApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsaWNlbnNlWGhyU2V0dXAoeGhyLCB1cmwpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gbGV0J3MgdHJ5IHRvIG9wZW4gYmVmb3JlIHJ1bm5pbmcgc2V0dXBcbiAgICAgICAgICB4aHIub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgICAgbGljZW5zZVhoclNldHVwKHhociwgdXJsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaWYgbGljZW5zZVhoclNldHVwIGRpZCBub3QgeWV0IGNhbGwgb3BlbiwgbGV0J3MgZG8gaXQgbm93XG4gICAgICBpZiAoIXhoci5yZWFkeVN0YXRlKSB7XG4gICAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJRTExIHRocm93cyBhbiBleGNlcHRpb24gb24geGhyLm9wZW4gaWYgYXR0ZW1wdGluZyB0byBhY2Nlc3MgYW4gSFRUUCByZXNvdXJjZSBvdmVyIEhUVFBTXG4gICAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIHNldHRpbmcgdXAga2V5LXN5c3RlbSBsaWNlbnNlIFhIUicsIGUpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID1cbiAgICAgICAgdGhpcy5fb25MaWNlbnNlUmVxdWVzdFJlYWR5U3RhZ2VDaGFuZ2UuYmluZCh0aGlzLCB4aHIsIHVybCwga2V5TWVzc2FnZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiB4aHI7XG4gIH1cblxuICAvKipcbiAgICAgKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0fSB4aHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIExpY2Vuc2Ugc2VydmVyIFVSTFxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGtleU1lc3NhZ2UgTWVzc2FnZSBkYXRhIGlzc3VlZCBieSBrZXktc3lzdGVtXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIHdoZW4gWEhSIGhhcyBzdWNjZWVkZWRcbiAgICAgKlxuICAgICAqL1xuICBfb25MaWNlbnNlUmVxdWVzdFJlYWR5U3RhZ2VDaGFuZ2UgKHhociwgdXJsLCBrZXlNZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIHN3aXRjaCAoeGhyLnJlYWR5U3RhdGUpIHtcbiAgICBjYXNlIDQ6XG4gICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID0gMDtcbiAgICAgICAgbG9nZ2VyLmxvZygnTGljZW5zZSByZXF1ZXN0IHN1Y2NlZWRlZCcpO1xuICAgICAgICBjYWxsYmFjayh4aHIucmVzcG9uc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBMaWNlbnNlIFJlcXVlc3QgWEhSIGZhaWxlZCAoJHt1cmx9KS4gU3RhdHVzOiAke3hoci5zdGF0dXN9ICgke3hoci5zdGF0dXNUZXh0fSlgKTtcblxuICAgICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCsrO1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgPD0gTUFYX0xJQ0VOU0VfUkVRVUVTVF9GQUlMVVJFUykge1xuICAgICAgICAgIGNvbnN0IGF0dGVtcHRzTGVmdCA9IE1BWF9MSUNFTlNFX1JFUVVFU1RfRkFJTFVSRVMgLSB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCArIDE7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYFJldHJ5aW5nIGxpY2Vuc2UgcmVxdWVzdCwgJHthdHRlbXB0c0xlZnR9IGF0dGVtcHRzIGxlZnRgKTtcbiAgICAgICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZShrZXlNZXNzYWdlLCBjYWxsYmFjayk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9MSUNFTlNFX1JFUVVFU1RfRkFJTEVELFxuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGtleXNMaXN0SXRlbVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGtleU1lc3NhZ2VcbiAgICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IENoYWxsZW5nZSBkYXRhIHBvc3RlZCB0byBsaWNlbnNlIHNlcnZlclxuICAgICAqL1xuICBfZ2VuZXJhdGVMaWNlbnNlUmVxdWVzdENoYWxsZW5nZSAoa2V5c0xpc3RJdGVtLCBrZXlNZXNzYWdlKSB7XG4gICAgbGV0IGNoYWxsZW5nZTtcblxuICAgIGlmIChrZXlzTGlzdEl0ZW0ubWVkaWFLZXlTeXN0ZW1Eb21haW4gPT09IEtleVN5c3RlbXMuUExBWVJFQURZKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ1BsYXlSZWFkeSBpcyBub3Qgc3VwcG9ydGVkICh5ZXQpJyk7XG5cbiAgICAgIC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdEVkZ2UvRGVtb3MvYmxvYi9tYXN0ZXIvZW1lL3NjcmlwdHMvZGVtby5qc1xuICAgICAgLypcbiAgICAgICAgaWYgKHRoaXMubGljZW5zZVR5cGUgIT09IHRoaXMuTElDRU5TRV9UWVBFX1dJREVWSU5FKSB7XG4gICAgICAgICAgICAvLyBGb3IgUGxheVJlYWR5IENETXMsIHdlIG5lZWQgdG8gZGlnIHRoZSBDaGFsbGVuZ2Ugb3V0IG9mIHRoZSBYTUwuXG4gICAgICAgICAgICB2YXIga2V5TWVzc2FnZVhtbCA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDE2QXJyYXkoa2V5TWVzc2FnZSkpLCAnYXBwbGljYXRpb24veG1sJyk7XG4gICAgICAgICAgICBpZiAoa2V5TWVzc2FnZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnQ2hhbGxlbmdlJylbMF0pIHtcbiAgICAgICAgICAgICAgICBjaGFsbGVuZ2UgPSBhdG9iKGtleU1lc3NhZ2VYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0NoYWxsZW5nZScpWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0Nhbm5vdCBmaW5kIDxDaGFsbGVuZ2U+IGluIGtleSBtZXNzYWdlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoZWFkZXJOYW1lcyA9IGtleU1lc3NhZ2VYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ25hbWUnKTtcbiAgICAgICAgICAgIHZhciBoZWFkZXJWYWx1ZXMgPSBrZXlNZXNzYWdlWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd2YWx1ZScpO1xuICAgICAgICAgICAgaWYgKGhlYWRlck5hbWVzLmxlbmd0aCAhPT0gaGVhZGVyVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdNaXNtYXRjaGVkIGhlYWRlciA8bmFtZT4vPHZhbHVlPiBwYWlyIGluIGtleSBtZXNzYWdlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lc1tpXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSwgaGVhZGVyVmFsdWVzW2ldLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgIH0gZWxzZSBpZiAoa2V5c0xpc3RJdGVtLm1lZGlhS2V5U3lzdGVtRG9tYWluID09PSBLZXlTeXN0ZW1zLldJREVWSU5FKSB7XG4gICAgICAvLyBGb3IgV2lkZXZpbmUgQ0RNcywgdGhlIGNoYWxsZW5nZSBpcyB0aGUga2V5TWVzc2FnZS5cbiAgICAgIGNoYWxsZW5nZSA9IGtleU1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5lcnJvcignVW5zdXBwb3J0ZWQga2V5LXN5c3RlbTonLCBrZXlzTGlzdEl0ZW0ubWVkaWFLZXlTeXN0ZW1Eb21haW4pO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFsbGVuZ2U7XG4gIH1cblxuICBfcmVxdWVzdExpY2Vuc2UgKGtleU1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgbG9nZ2VyLmxvZygnUmVxdWVzdGluZyBjb250ZW50IGxpY2Vuc2UgZm9yIGtleS1zeXN0ZW0nKTtcblxuICAgIGNvbnN0IGtleXNMaXN0SXRlbSA9IHRoaXMuX21lZGlhS2V5c0xpc3RbMF07XG4gICAgaWYgKCFrZXlzTGlzdEl0ZW0pIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmF0YWwgZXJyb3I6IE1lZGlhIGlzIGVuY3J5cHRlZCBidXQgbm8ga2V5LXN5c3RlbSBhY2Nlc3MgaGFzIGJlZW4gb2J0YWluZWQgeWV0Jyk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fQUNDRVNTLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdXJsID0gdGhpcy5nZXRMaWNlbnNlU2VydmVyVXJsKGtleXNMaXN0SXRlbS5tZWRpYUtleVN5c3RlbURvbWFpbik7XG4gICAgY29uc3QgeGhyID0gdGhpcy5fY3JlYXRlTGljZW5zZVhocih1cmwsIGtleU1lc3NhZ2UsIGNhbGxiYWNrKTtcblxuICAgIGxvZ2dlci5sb2coYFNlbmRpbmcgbGljZW5zZSByZXF1ZXN0IHRvIFVSTDogJHt1cmx9YCk7XG5cbiAgICB4aHIuc2VuZCh0aGlzLl9nZW5lcmF0ZUxpY2Vuc2VSZXF1ZXN0Q2hhbGxlbmdlKGtleXNMaXN0SXRlbSwga2V5TWVzc2FnZSkpO1xuICB9XG5cbiAgb25NZWRpYUF0dGFjaGVkIChkYXRhKSB7XG4gICAgaWYgKCF0aGlzLl9lbWVFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWVkaWEgPSBkYXRhLm1lZGlhO1xuXG4gICAgLy8ga2VlcCByZWZlcmVuY2Ugb2YgbWVkaWFcbiAgICB0aGlzLl9tZWRpYSA9IG1lZGlhO1xuXG4gICAgLy8gRklYTUU6IGFsc28gaGFuZGxlIGRldGFjaGluZyBtZWRpYSAhXG5cbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmNyeXB0ZWQnLCAoZSkgPT4ge1xuICAgICAgdGhpcy5fb25NZWRpYUVuY3J5cHRlZChlLmluaXREYXRhVHlwZSwgZS5pbml0RGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICBvbk1hbmlmZXN0UGFyc2VkIChkYXRhKSB7XG4gICAgaWYgKCF0aGlzLl9lbWVFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXVkaW9Db2RlY3MgPSBkYXRhLmxldmVscy5tYXAoKGxldmVsKSA9PiBsZXZlbC5hdWRpb0NvZGVjKTtcbiAgICBjb25zdCB2aWRlb0NvZGVjcyA9IGRhdGEubGV2ZWxzLm1hcCgobGV2ZWwpID0+IGxldmVsLnZpZGVvQ29kZWMpO1xuXG4gICAgdGhpcy5fYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyhLZXlTeXN0ZW1zLldJREVWSU5FLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVNRUNvbnRyb2xsZXI7XG4iLCIvKlxuICogRlBTIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNvbnN0IHsgcGVyZm9ybWFuY2UgfSA9IHdpbmRvdztcblxuY2xhc3MgRlBTQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsIEV2ZW50Lk1FRElBX0FUVEFDSElORyk7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSBmYWxzZTtcbiAgfVxuXG4gIG9uTWVkaWFBdHRhY2hpbmcgKGRhdGEpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgaWYgKGNvbmZpZy5jYXBMZXZlbE9uRlBTRHJvcCkge1xuICAgICAgY29uc3QgdmlkZW8gPSB0aGlzLnZpZGVvID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XG4gICAgICBpZiAodHlwZW9mIHZpZGVvLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5jaGVja0ZQU0ludGVydmFsLmJpbmQodGhpcyksIGNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZCk7XG4gICAgfVxuICB9XG5cbiAgY2hlY2tGUFMgKHZpZGVvLCBkZWNvZGVkRnJhbWVzLCBkcm9wcGVkRnJhbWVzKSB7XG4gICAgbGV0IGN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKGRlY29kZWRGcmFtZXMpIHtcbiAgICAgIGlmICh0aGlzLmxhc3RUaW1lKSB7XG4gICAgICAgIGxldCBjdXJyZW50UGVyaW9kID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUaW1lLFxuICAgICAgICAgIGN1cnJlbnREcm9wcGVkID0gZHJvcHBlZEZyYW1lcyAtIHRoaXMubGFzdERyb3BwZWRGcmFtZXMsXG4gICAgICAgICAgY3VycmVudERlY29kZWQgPSBkZWNvZGVkRnJhbWVzIC0gdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyxcbiAgICAgICAgICBkcm9wcGVkRlBTID0gMTAwMCAqIGN1cnJlbnREcm9wcGVkIC8gY3VycmVudFBlcmlvZCxcbiAgICAgICAgICBobHMgPSB0aGlzLmhscztcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlBTX0RST1AsIHsgY3VycmVudERyb3BwZWQ6IGN1cnJlbnREcm9wcGVkLCBjdXJyZW50RGVjb2RlZDogY3VycmVudERlY29kZWQsIHRvdGFsRHJvcHBlZEZyYW1lczogZHJvcHBlZEZyYW1lcyB9KTtcbiAgICAgICAgaWYgKGRyb3BwZWRGUFMgPiAwKSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnY2hlY2tGUFMgOiBkcm9wcGVkRlBTL2RlY29kZWRGUFM6JyArIGRyb3BwZWRGUFMvKDEwMDAgKiBjdXJyZW50RGVjb2RlZCAvIGN1cnJlbnRQZXJpb2QpKTtcbiAgICAgICAgICBpZiAoY3VycmVudERyb3BwZWQgPiBobHMuY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkICogY3VycmVudERlY29kZWQpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSBobHMuY3VycmVudExldmVsO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2Ryb3AgRlBTIHJhdGlvIGdyZWF0ZXIgdGhhbiBtYXggYWxsb3dlZCB2YWx1ZSBmb3IgY3VycmVudExldmVsOiAnICsgY3VycmVudExldmVsKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TGV2ZWwgPiAwICYmIChobHMuYXV0b0xldmVsQ2FwcGluZyA9PT0gLTEgfHwgaGxzLmF1dG9MZXZlbENhcHBpbmcgPj0gY3VycmVudExldmVsKSkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWwgLSAxO1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB7IGxldmVsOiBjdXJyZW50TGV2ZWwsIGRyb3BwZWRMZXZlbDogaGxzLmN1cnJlbnRMZXZlbCB9KTtcbiAgICAgICAgICAgICAgaGxzLmF1dG9MZXZlbENhcHBpbmcgPSBjdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICAgIGhscy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyA9IGRyb3BwZWRGcmFtZXM7XG4gICAgICB0aGlzLmxhc3REZWNvZGVkRnJhbWVzID0gZGVjb2RlZEZyYW1lcztcbiAgICB9XG4gIH1cblxuICBjaGVja0ZQU0ludGVydmFsICgpIHtcbiAgICBjb25zdCB2aWRlbyA9IHRoaXMudmlkZW87XG4gICAgaWYgKHZpZGVvKSB7XG4gICAgICBpZiAodGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlKSB7XG4gICAgICAgIGxldCB2aWRlb1BsYXliYWNrUXVhbGl0eSA9IHZpZGVvLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCk7XG4gICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXMsIHZpZGVvUGxheWJhY2tRdWFsaXR5LmRyb3BwZWRWaWRlb0ZyYW1lcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNoZWNrRlBTKHZpZGVvLCB2aWRlby53ZWJraXREZWNvZGVkRnJhbWVDb3VudCwgdmlkZW8ud2Via2l0RHJvcHBlZEZyYW1lQ291bnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGUFNDb250cm9sbGVyO1xuIiwiaW1wb3J0IEJpbmFyeVNlYXJjaCBmcm9tICcuLi91dGlscy9iaW5hcnktc2VhcmNoJztcblxuLyoqXG4gKiBSZXR1cm5zIGZpcnN0IGZyYWdtZW50IHdob3NlIGVuZFBkdCB2YWx1ZSBleGNlZWRzIHRoZSBnaXZlbiBQRFQuXG4gKiBAcGFyYW0ge0FycmF5PEZyYWdtZW50Pn0gZnJhZ21lbnRzIC0gVGhlIGFycmF5IG9mIGNhbmRpZGF0ZSBmcmFnbWVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfG51bGx9IFtQRFRWYWx1ZSA9IG51bGxdIC0gVGhlIFBEVCB2YWx1ZSB3aGljaCBtdXN0IGJlIGV4Y2VlZGVkXG4gKiBAcGFyYW0ge251bWJlcn0gW21heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwXSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydC9lbmQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHsqfG51bGx9IGZyYWdtZW50IC0gVGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGcmFnbWVudEJ5UERUIChmcmFnbWVudHMsIFBEVFZhbHVlLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmcmFnbWVudHMpIHx8ICFmcmFnbWVudHMubGVuZ3RoIHx8ICFOdW1iZXIuaXNGaW5pdGUoUERUVmFsdWUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBpZiBsZXNzIHRoYW4gc3RhcnRcbiAgaWYgKFBEVFZhbHVlIDwgZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKFBEVFZhbHVlID49IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0uZW5kUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB8fCAwO1xuICBmb3IgKGxldCBzZWcgPSAwOyBzZWcgPCBmcmFnbWVudHMubGVuZ3RoOyArK3NlZykge1xuICAgIGxldCBmcmFnID0gZnJhZ21lbnRzW3NlZ107XG4gICAgaWYgKHBkdFdpdGhpblRvbGVyYW5jZVRlc3QoUERUVmFsdWUsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWcpKSB7XG4gICAgICByZXR1cm4gZnJhZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBGaW5kcyBhIGZyYWdtZW50IGJhc2VkIG9uIHRoZSBTTiBvZiB0aGUgcHJldmlvdXMgZnJhZ21lbnQ7IG9yIGJhc2VkIG9uIHRoZSBuZWVkcyBvZiB0aGUgY3VycmVudCBidWZmZXIuXG4gKiBUaGlzIG1ldGhvZCBjb21wZW5zYXRlcyBmb3Igc21hbGwgYnVmZmVyIGdhcHMgYnkgYXBwbHlpbmcgYSB0b2xlcmFuY2UgdG8gdGhlIHN0YXJ0IG9mIGFueSBjYW5kaWRhdGUgZnJhZ21lbnQsIHRodXNcbiAqIGJyZWFraW5nIGFueSB0cmFwcyB3aGljaCB3b3VsZCBjYXVzZSB0aGUgc2FtZSBmcmFnbWVudCB0byBiZSBjb250aW51b3VzbHkgc2VsZWN0ZWQgd2l0aGluIGEgc21hbGwgcmFuZ2UuXG4gKiBAcGFyYW0geyp9IGZyYWdQcmV2aW91cyAtIFRoZSBsYXN0IGZyYWcgc3VjY2Vzc2Z1bGx5IGFwcGVuZGVkXG4gKiBAcGFyYW0ge0FycmF5PEZyYWdtZW50Pn0gZnJhZ21lbnRzIC0gVGhlIGFycmF5IG9mIGNhbmRpZGF0ZSBmcmFnbWVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYnVmZmVyRW5kID0gMF0gLSBUaGUgZW5kIG9mIHRoZSBjb250aWd1b3VzIGJ1ZmZlcmVkIHJhbmdlIHRoZSBwbGF5aGVhZCBpcyBjdXJyZW50bHkgd2l0aGluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydC9lbmQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHsqfSBmb3VuZEZyYWcgLSBUaGUgYmVzdCBtYXRjaGluZyBmcmFnbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEZyYWdtZW50QnlQVFMgKGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBidWZmZXJFbmQgPSAwLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMCkge1xuICBjb25zdCBmcmFnTmV4dCA9IGZyYWdQcmV2aW91cyA/IGZyYWdtZW50c1tmcmFnUHJldmlvdXMuc24gLSBmcmFnbWVudHNbMF0uc24gKyAxXSA6IG51bGw7XG4gIC8vIFByZWZlciB0aGUgbmV4dCBmcmFnbWVudCBpZiBpdCdzIHdpdGhpbiB0b2xlcmFuY2VcbiAgaWYgKGZyYWdOZXh0ICYmICFmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QoYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnTmV4dCkpIHtcbiAgICByZXR1cm4gZnJhZ05leHQ7XG4gIH1cbiAgcmV0dXJuIEJpbmFyeVNlYXJjaC5zZWFyY2goZnJhZ21lbnRzLCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QuYmluZChudWxsLCBidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpKTtcbn1cblxuLyoqXG4gKiBUaGUgdGVzdCBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBmaW5kRnJhZ21lbnRCeVNuJ3MgQmluYXJ5U2VhcmNoIHRvIGxvb2sgZm9yIHRoZSBiZXN0IG1hdGNoIHRvIHRoZSBjdXJyZW50IGJ1ZmZlciBjb25kaXRpb25zLlxuICogQHBhcmFtIHsqfSBjYW5kaWRhdGUgLSBUaGUgZnJhZ21lbnQgdG8gdGVzdFxuICogQHBhcmFtIHtudW1iZXJ9IFtidWZmZXJFbmQgPSAwXSAtIFRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyZWQgcmFuZ2UgdGhlIHBsYXloZWFkIGlzIGN1cnJlbnRseSB3aXRoaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0IGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIDAgaWYgaXQgbWF0Y2hlcywgMSBpZiB0b28gbG93LCAtMSBpZiB0b28gaGlnaFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0IChidWZmZXJFbmQgPSAwLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMCwgY2FuZGlkYXRlKSB7XG4gIC8vIG9mZnNldCBzaG91bGQgYmUgd2l0aGluIGZyYWdtZW50IGJvdW5kYXJ5IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2VcbiAgLy8gdGhpcyBpcyB0byBjb3BlIHdpdGggc2l0dWF0aW9ucyBsaWtlXG4gIC8vIGJ1ZmZlckVuZCA9IDkuOTkxXG4gIC8vIGZyYWdbw5hdIDogWzAsMTBdXG4gIC8vIGZyYWdbMV0gOiBbMTAsMjBdXG4gIC8vIGJ1ZmZlckVuZCBpcyB3aXRoaW4gZnJhZ1swXSByYW5nZSAuLi4gYWx0aG91Z2ggd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIGlzIHRvIHJldHVybiBmcmFnWzFdIGhlcmVcbiAgLy8gICAgICAgICAgICAgIGZyYWcgc3RhcnQgICAgICAgICAgICAgICBmcmFnIHN0YXJ0K2R1cmF0aW9uXG4gIC8vICAgICAgICAgICAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAvLyAgICAgICAgICAgICAgPC0tLT4gICAgICAgICAgICAgICAgICAgICAgICAgPC0tLT5cbiAgLy8gIC4uLi0tLS0tLS0tPjwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT48LS0tLS0tLS0tLi4uLlxuICAvLyBwcmV2aW91cyBmcmFnICAgICAgICAgbWF0Y2hpbmcgZnJhZ21lbnQgICAgICAgICBuZXh0IGZyYWdcbiAgLy8gIHJldHVybiAtMSAgICAgICAgICAgICByZXR1cm4gMCAgICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgLy8gbG9nZ2VyLmxvZyhgbGV2ZWwvc24vc3RhcnQvZW5kL2J1ZkVuZDoke2xldmVsfS8ke2NhbmRpZGF0ZS5zbn0vJHtjYW5kaWRhdGUuc3RhcnR9LyR7KGNhbmRpZGF0ZS5zdGFydCtjYW5kaWRhdGUuZHVyYXRpb24pfS8ke2J1ZmZlckVuZH1gKTtcbiAgLy8gU2V0IHRoZSBsb29rdXAgdG9sZXJhbmNlIHRvIGJlIHNtYWxsIGVub3VnaCB0byBkZXRlY3QgdGhlIGN1cnJlbnQgc2VnbWVudCAtIGVuc3VyZXMgd2UgZG9uJ3Qgc2tpcCBvdmVyIHZlcnkgc21hbGwgc2VnbWVudHNcbiAgbGV0IGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA9IE1hdGgubWluKG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZS5kdXJhdGlvbiArIChjYW5kaWRhdGUuZGVsdGFQVFMgPyBjYW5kaWRhdGUuZGVsdGFQVFMgOiAwKSk7XG4gIGlmIChjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPD0gYnVmZmVyRW5kKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoY2FuZGlkYXRlLnN0YXJ0IC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gYnVmZmVyRW5kICYmIGNhbmRpZGF0ZS5zdGFydCkge1xuICAgIC8vIGlmIG1heEZyYWdMb29rVXBUb2xlcmFuY2Ugd2lsbCBoYXZlIG5lZ2F0aXZlIHZhbHVlIHRoZW4gZG9uJ3QgcmV0dXJuIC0xIGZvciBmaXJzdCBlbGVtZW50XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogVGhlIHRlc3QgZnVuY3Rpb24gdXNlZCBieSB0aGUgZmluZEZyYWdtZW50QnlQZHQncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXG4gKiBUaGlzIGZ1bmN0aW9uIHRlc3RzIHRoZSBjYW5kaWRhdGUncyBwcm9ncmFtIGRhdGUgdGltZSB2YWx1ZXMsIGFzIHJlcHJlc2VudGVkIGluIFVuaXggdGltZVxuICogQHBhcmFtIHsqfSBjYW5kaWRhdGUgLSBUaGUgZnJhZ21lbnQgdG8gdGVzdFxuICogQHBhcmFtIHtudW1iZXJ9IFtwZHRCdWZmZXJFbmQgPSAwXSAtIFRoZSBVbml4IHRpbWUgcmVwcmVzZW50aW5nIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyZWQgcmFuZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0IGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBjb250aWd1b3VzLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBkdFdpdGhpblRvbGVyYW5jZVRlc3QgKHBkdEJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlKSB7XG4gIGxldCBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24gKyAoY2FuZGlkYXRlLmRlbHRhUFRTID8gY2FuZGlkYXRlLmRlbHRhUFRTIDogMCkpICogMTAwMDtcbiAgcmV0dXJuIGNhbmRpZGF0ZS5lbmRQcm9ncmFtRGF0ZVRpbWUgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBwZHRCdWZmZXJFbmQ7XG59XG4iLCJpbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5cbmV4cG9ydCBjb25zdCBGcmFnbWVudFN0YXRlID0ge1xuICBOT1RfTE9BREVEOiAnTk9UX0xPQURFRCcsXG4gIEFQUEVORElORzogJ0FQUEVORElORycsXG4gIFBBUlRJQUw6ICdQQVJUSUFMJyxcbiAgT0s6ICdPSydcbn07XG5cbmV4cG9ydCBjbGFzcyBGcmFnbWVudFRyYWNrZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuQlVGRkVSX0FQUEVOREVELFxuICAgICAgRXZlbnQuRlJBR19CVUZGRVJFRCxcbiAgICAgIEV2ZW50LkZSQUdfTE9BREVEXG4gICAgKTtcblxuICAgIHRoaXMuYnVmZmVyUGFkZGluZyA9IDAuMjtcblxuICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnRpbWVSYW5nZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5mcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMudGltZVJhbmdlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5jb25maWcgPSBudWxsO1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBGcmFnbWVudCB0aGF0IG1hdGNoIHRoZSBwb3NpdGlvbiBhbmQgbGV2ZWxUeXBlLlxuICAgKiBJZiBub3QgZm91bmQgYW55IEZyYWdtZW50LCByZXR1cm4gbnVsbFxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25cbiAgICogQHBhcmFtIHtMZXZlbFR5cGV9IGxldmVsVHlwZVxuICAgKiBAcmV0dXJucyB7RnJhZ21lbnR8bnVsbH1cbiAgICovXG4gIGdldEJ1ZmZlcmVkRnJhZyAocG9zaXRpb24sIGxldmVsVHlwZSkge1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzO1xuICAgIGNvbnN0IGJ1ZmZlcmVkRnJhZ3MgPSBPYmplY3Qua2V5cyhmcmFnbWVudHMpLmZpbHRlcihrZXkgPT4ge1xuICAgICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSBmcmFnbWVudHNba2V5XTtcbiAgICAgIGlmIChmcmFnbWVudEVudGl0eS5ib2R5LnR5cGUgIT09IGxldmVsVHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmcmFnID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcbiAgICAgIHJldHVybiBmcmFnLnN0YXJ0UFRTIDw9IHBvc2l0aW9uICYmIHBvc2l0aW9uIDw9IGZyYWcuZW5kUFRTO1xuICAgIH0pO1xuICAgIGlmIChidWZmZXJlZEZyYWdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL3B1bGwvMTU0NSNkaXNjdXNzaW9uX3IxNjYyMjk1NjZcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkRnJhZ0tleSA9IGJ1ZmZlcmVkRnJhZ3MucG9wKCk7XG4gICAgICByZXR1cm4gZnJhZ21lbnRzW2J1ZmZlcmVkRnJhZ0tleV0uYm9keTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFydGlhbCBmcmFnbWVudHMgZWZmZWN0ZWQgYnkgY29kZWQgZnJhbWUgZXZpY3Rpb24gd2lsbCBiZSByZW1vdmVkXG4gICAqIFRoZSBicm93c2VyIHdpbGwgdW5sb2FkIHBhcnRzIG9mIHRoZSBidWZmZXIgdG8gZnJlZSB1cCBtZW1vcnkgZm9yIG5ldyBidWZmZXIgZGF0YVxuICAgKiBGcmFnbWVudHMgd2lsbCBuZWVkIHRvIGJlIHJlbG9hZGVkIHdoZW4gdGhlIGJ1ZmZlciBpcyBmcmVlZCB1cCwgcmVtb3ZpbmcgcGFydGlhbCBmcmFnbWVudHMgd2lsbCBhbGxvdyB0aGVtIHRvIHJlbG9hZChzaW5jZSB0aGVyZSBtaWdodCBiZSBwYXJ0cyB0aGF0IGFyZSBzdGlsbCBwbGF5YWJsZSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVsZW1lbnRhcnlTdHJlYW0gVGhlIGVsZW1lbnRhcnlTdHJlYW0gb2YgbWVkaWEgdGhpcyBpcyAoZWcuIHZpZGVvL2F1ZGlvKVxuICAgKiBAcGFyYW0ge1RpbWVSYW5nZXN9IHRpbWVSYW5nZSBUaW1lUmFuZ2Ugb2JqZWN0IGZyb20gYSBzb3VyY2VCdWZmZXJcbiAgICovXG4gIGRldGVjdEV2aWN0ZWRGcmFnbWVudHMgKGVsZW1lbnRhcnlTdHJlYW0sIHRpbWVSYW5nZSkge1xuICAgIGxldCBmcmFnbWVudFRpbWVzLCB0aW1lO1xuICAgIC8vIENoZWNrIGlmIGFueSBmbGFnZ2VkIGZyYWdtZW50cyBoYXZlIGJlZW4gdW5sb2FkZWRcbiAgICBPYmplY3Qua2V5cyh0aGlzLmZyYWdtZW50cykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1trZXldO1xuICAgICAgaWYgKGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGVzRGF0YSA9IGZyYWdtZW50RW50aXR5LnJhbmdlW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgICBpZiAoZXNEYXRhKSB7XG4gICAgICAgICAgZnJhZ21lbnRUaW1lcyA9IGVzRGF0YS50aW1lO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhZ21lbnRUaW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGltZSA9IGZyYWdtZW50VGltZXNbaV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzVGltZUJ1ZmZlcmVkKHRpbWUuc3RhcnRQVFMsIHRpbWUuZW5kUFRTLCB0aW1lUmFuZ2UpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAvLyBVbnJlZ2lzdGVyIHBhcnRpYWwgZnJhZ21lbnQgYXMgaXQgbmVlZHMgdG8gbG9hZCBhZ2FpbiB0byBiZSByZXVzZWRcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBmcmFnbWVudCBwYXNzZWQgaW4gaXMgbG9hZGVkIGluIHRoZSBidWZmZXIgcHJvcGVybHlcbiAgICogUGFydGlhbGx5IGxvYWRlZCBmcmFnbWVudHMgd2lsbCBiZSByZWdpc3RlcmVkIGFzIGEgcGFydGlhbCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZnJhZ21lbnQgQ2hlY2sgdGhlIGZyYWdtZW50IGFnYWluc3QgYWxsIHNvdXJjZUJ1ZmZlcnMgbG9hZGVkXG4gICAqL1xuICBkZXRlY3RQYXJ0aWFsRnJhZ21lbnRzIChmcmFnbWVudCkge1xuICAgIGxldCBmcmFnS2V5ID0gdGhpcy5nZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgbGV0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgaWYgKGZyYWdtZW50RW50aXR5KSB7XG4gICAgICBmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9IHRydWU7XG5cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMudGltZVJhbmdlcykuZm9yRWFjaChlbGVtZW50YXJ5U3RyZWFtID0+IHtcbiAgICAgICAgaWYgKGZyYWdtZW50Lmhhc0VsZW1lbnRhcnlTdHJlYW0oZWxlbWVudGFyeVN0cmVhbSkpIHtcbiAgICAgICAgICBsZXQgdGltZVJhbmdlID0gdGhpcy50aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgICAgIC8vIENoZWNrIGZvciBtYWxmb3JtZWQgZnJhZ21lbnRzXG4gICAgICAgICAgLy8gR2FwcyBuZWVkIHRvIGJlIGNhbGN1bGF0ZWQgZm9yIGVhY2ggZWxlbWVudGFyeVN0cmVhbVxuICAgICAgICAgIGZyYWdtZW50RW50aXR5LnJhbmdlW2VsZW1lbnRhcnlTdHJlYW1dID0gdGhpcy5nZXRCdWZmZXJlZFRpbWVzKGZyYWdtZW50LnN0YXJ0UFRTLCBmcmFnbWVudC5lbmRQVFMsIHRpbWVSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGdldEJ1ZmZlcmVkVGltZXMgKHN0YXJ0UFRTLCBlbmRQVFMsIHRpbWVSYW5nZSkge1xuICAgIGxldCBmcmFnbWVudFRpbWVzID0gW107XG4gICAgbGV0IHN0YXJ0VGltZSwgZW5kVGltZTtcbiAgICBsZXQgZnJhZ21lbnRQYXJ0aWFsID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lUmFuZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YXJ0VGltZSA9IHRpbWVSYW5nZS5zdGFydChpKSAtIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGVuZFRpbWUgPSB0aW1lUmFuZ2UuZW5kKGkpICsgdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgaWYgKHN0YXJ0UFRTID49IHN0YXJ0VGltZSAmJiBlbmRQVFMgPD0gZW5kVGltZSkge1xuICAgICAgICAvLyBGcmFnbWVudCBpcyBlbnRpcmVseSBjb250YWluZWQgaW4gYnVmZmVyXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIG90aGVyIHRpbWVSYW5nZSB0aW1lcyBzaW5jZSBpdCdzIGNvbXBsZXRlbHkgcGxheWFibGVcbiAgICAgICAgZnJhZ21lbnRUaW1lcy5wdXNoKHtcbiAgICAgICAgICBzdGFydFBUUzogTWF0aC5tYXgoc3RhcnRQVFMsIHRpbWVSYW5nZS5zdGFydChpKSksXG4gICAgICAgICAgZW5kUFRTOiBNYXRoLm1pbihlbmRQVFMsIHRpbWVSYW5nZS5lbmQoaSkpXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRQVFMgPCBlbmRUaW1lICYmIGVuZFBUUyA+IHN0YXJ0VGltZSkge1xuICAgICAgICAvLyBDaGVjayBmb3IgaW50ZXJzZWN0aW9uIHdpdGggYnVmZmVyXG4gICAgICAgIC8vIEdldCBwbGF5YWJsZSBzZWN0aW9ucyBvZiB0aGUgZnJhZ21lbnRcbiAgICAgICAgZnJhZ21lbnRUaW1lcy5wdXNoKHtcbiAgICAgICAgICBzdGFydFBUUzogTWF0aC5tYXgoc3RhcnRQVFMsIHRpbWVSYW5nZS5zdGFydChpKSksXG4gICAgICAgICAgZW5kUFRTOiBNYXRoLm1pbihlbmRQVFMsIHRpbWVSYW5nZS5lbmQoaSkpXG4gICAgICAgIH0pO1xuICAgICAgICBmcmFnbWVudFBhcnRpYWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbmRQVFMgPD0gc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIHJlc3Qgb2YgdGhlIHRpbWVSYW5nZSBhcyBpdCBpcyBpbiBvcmRlclxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGltZTogZnJhZ21lbnRUaW1lcyxcbiAgICAgIHBhcnRpYWw6IGZyYWdtZW50UGFydGlhbFxuICAgIH07XG4gIH1cblxuICBnZXRGcmFnbWVudEtleSAoZnJhZ21lbnQpIHtcbiAgICByZXR1cm4gYCR7ZnJhZ21lbnQudHlwZX1fJHtmcmFnbWVudC5sZXZlbHN9XyR7ZnJhZ21lbnQudXJsSWR9XyR7ZnJhZ21lbnQuc259YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwYXJ0aWFsIGZyYWdtZW50IGZvciBhIGNlcnRhaW4gdGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBmcmFnbWVudCBSZXR1cm5zIGEgcGFydGlhbCBmcmFnbWVudCBhdCBhIHRpbWUgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBwYXJ0aWFsIGZyYWdtZW50XG4gICAqL1xuICBnZXRQYXJ0aWFsRnJhZ21lbnQgKHRpbWUpIHtcbiAgICBsZXQgdGltZVBhZGRpbmcsIHN0YXJ0VGltZSwgZW5kVGltZTtcbiAgICBsZXQgYmVzdEZyYWdtZW50ID0gbnVsbDtcbiAgICBsZXQgYmVzdE92ZXJsYXAgPSAwO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuZnJhZ21lbnRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2tleV07XG4gICAgICBpZiAodGhpcy5pc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpKSB7XG4gICAgICAgIHN0YXJ0VGltZSA9IGZyYWdtZW50RW50aXR5LmJvZHkuc3RhcnRQVFMgLSB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICAgIGVuZFRpbWUgPSBmcmFnbWVudEVudGl0eS5ib2R5LmVuZFBUUyArIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgICAgaWYgKHRpbWUgPj0gc3RhcnRUaW1lICYmIHRpbWUgPD0gZW5kVGltZSkge1xuICAgICAgICAgIC8vIFVzZSB0aGUgZnJhZ21lbnQgdGhhdCBoYXMgdGhlIG1vc3QgcGFkZGluZyBmcm9tIHN0YXJ0IGFuZCBlbmQgdGltZVxuICAgICAgICAgIHRpbWVQYWRkaW5nID0gTWF0aC5taW4odGltZSAtIHN0YXJ0VGltZSwgZW5kVGltZSAtIHRpbWUpO1xuICAgICAgICAgIGlmIChiZXN0T3ZlcmxhcCA8PSB0aW1lUGFkZGluZykge1xuICAgICAgICAgICAgYmVzdEZyYWdtZW50ID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcbiAgICAgICAgICAgIGJlc3RPdmVybGFwID0gdGltZVBhZGRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGJlc3RGcmFnbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZnJhZ21lbnQgVGhlIGZyYWdtZW50IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFJldHVybnMgdGhlIGZyYWdtZW50IHN0YXRlIHdoZW4gYSBmcmFnbWVudCBuZXZlciBsb2FkZWQgb3IgaWYgaXQgcGFydGlhbGx5IGxvYWRlZFxuICAgKi9cbiAgZ2V0U3RhdGUgKGZyYWdtZW50KSB7XG4gICAgbGV0IGZyYWdLZXkgPSB0aGlzLmdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICBsZXQgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICBsZXQgc3RhdGUgPSBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQ7XG5cbiAgICBpZiAoZnJhZ21lbnRFbnRpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICBzdGF0ZSA9IEZyYWdtZW50U3RhdGUuQVBQRU5ESU5HO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzUGFydGlhbChmcmFnbWVudEVudGl0eSkgPT09IHRydWUpIHtcbiAgICAgICAgc3RhdGUgPSBGcmFnbWVudFN0YXRlLlBBUlRJQUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IEZyYWdtZW50U3RhdGUuT0s7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgaXNQYXJ0aWFsIChmcmFnbWVudEVudGl0eSkge1xuICAgIHJldHVybiBmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9PT0gdHJ1ZSAmJlxuICAgICAgKChmcmFnbWVudEVudGl0eS5yYW5nZS52aWRlbyAhPT0gdW5kZWZpbmVkICYmIGZyYWdtZW50RW50aXR5LnJhbmdlLnZpZGVvLnBhcnRpYWwgPT09IHRydWUpIHx8XG4gICAgICAgIChmcmFnbWVudEVudGl0eS5yYW5nZS5hdWRpbyAhPT0gdW5kZWZpbmVkICYmIGZyYWdtZW50RW50aXR5LnJhbmdlLmF1ZGlvLnBhcnRpYWwgPT09IHRydWUpKTtcbiAgfVxuXG4gIGlzVGltZUJ1ZmZlcmVkIChzdGFydFBUUywgZW5kUFRTLCB0aW1lUmFuZ2UpIHtcbiAgICBsZXQgc3RhcnRUaW1lLCBlbmRUaW1lO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGFydFRpbWUgPSB0aW1lUmFuZ2Uuc3RhcnQoaSkgLSB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBlbmRUaW1lID0gdGltZVJhbmdlLmVuZChpKSArIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGlmIChzdGFydFBUUyA+PSBzdGFydFRpbWUgJiYgZW5kUFRTIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRQVFMgPD0gc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIHJlc3Qgb2YgdGhlIHRpbWVSYW5nZSBhcyBpdCBpcyBpbiBvcmRlclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIGNvbXBsZXRlZFxuICAgKi9cbiAgb25GcmFnTG9hZGVkIChlKSB7XG4gICAgY29uc3QgZnJhZ21lbnQgPSBlLmZyYWc7XG4gICAgLy8gZG9uJ3QgdHJhY2sgaW5pdHNlZ21lbnQgKGZvciB3aGljaCBzbiBpcyBub3QgYSBudW1iZXIpXG4gICAgLy8gZG9uJ3QgdHJhY2sgZnJhZ3MgdXNlZCBmb3IgYml0cmF0ZVRlc3QsIHRoZXkncmUgaXJyZWxldmFudC5cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcmFnbWVudC5zbikgfHwgZnJhZ21lbnQuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmZyYWdtZW50c1t0aGlzLmdldEZyYWdtZW50S2V5KGZyYWdtZW50KV0gPSB7XG4gICAgICBib2R5OiBmcmFnbWVudCxcbiAgICAgIHJhbmdlOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgYnVmZmVyZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIHRoZSBidWZmZXIgaXMgdXBkYXRlZFxuICAgKi9cbiAgb25CdWZmZXJBcHBlbmRlZCAoZSkge1xuICAgIC8vIFN0b3JlIHRoZSBsYXRlc3QgdGltZVJhbmdlcyBsb2FkZWQgaW4gdGhlIGJ1ZmZlclxuICAgIHRoaXMudGltZVJhbmdlcyA9IGUudGltZVJhbmdlcztcbiAgICBPYmplY3Qua2V5cyh0aGlzLnRpbWVSYW5nZXMpLmZvckVhY2goZWxlbWVudGFyeVN0cmVhbSA9PiB7XG4gICAgICBsZXQgdGltZVJhbmdlID0gdGhpcy50aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgdGhpcy5kZXRlY3RFdmljdGVkRnJhZ21lbnRzKGVsZW1lbnRhcnlTdHJlYW0sIHRpbWVSYW5nZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgYWZ0ZXIgYSBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgc291cmNlIGJ1ZmZlclxuICAgKi9cbiAgb25GcmFnQnVmZmVyZWQgKGUpIHtcbiAgICB0aGlzLmRldGVjdFBhcnRpYWxGcmFnbWVudHMoZS5mcmFnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiBmcmFnbWVudCB0cmFja2VyIGhhcyB0aGUgZnJhZ21lbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmcmFnbWVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0ZyYWdtZW50IChmcmFnbWVudCkge1xuICAgIGNvbnN0IGZyYWdLZXkgPSB0aGlzLmdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV0gIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmcmFnbWVudCBmcm9tIGZyYWdtZW50IHRyYWNrZXIgdW50aWwgaXQgaXMgbG9hZGVkIGFnYWluXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmcmFnbWVudCBUaGUgZnJhZ21lbnQgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVGcmFnbWVudCAoZnJhZ21lbnQpIHtcbiAgICBsZXQgZnJhZ0tleSA9IHRoaXMuZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgIGRlbGV0ZSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGZyYWdtZW50cyBmcm9tIGZyYWdtZW50IHRyYWNrZXIuXG4gICAqL1xuICByZW1vdmVBbGxGcmFnbWVudHMgKCkge1xuICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQnVmZmVySGVscGVyIH0gZnJvbSAnLi4vdXRpbHMvYnVmZmVyLWhlbHBlcic7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jb25zdCBzdGFsbERlYm91bmNlSW50ZXJ2YWwgPSAxMDAwO1xuY29uc3QganVtcFRocmVzaG9sZCA9IDAuNTsgLy8gdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgcmFuZ2UgZW5kXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhcENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnLCBtZWRpYSwgZnJhZ21lbnRUcmFja2VyLCBobHMpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwbGF5aGVhZCBpcyBzdHVjayB3aXRoaW4gYSBnYXAsIGFuZCBpZiBzbywgYXR0ZW1wdHMgdG8gZnJlZSBpdC5cbiAgICogQSBnYXAgaXMgYW4gdW5idWZmZXJlZCByYW5nZSBiZXR3ZWVuIHR3byBidWZmZXJlZCByYW5nZXMgKG9yIHRoZSBzdGFydCBhbmQgdGhlIGZpcnN0IGJ1ZmZlcmVkIHJhbmdlKS5cbiAgICogQHBhcmFtIGxhc3RDdXJyZW50VGltZVxuICAgKiBAcGFyYW0gYnVmZmVyZWRcbiAgICovXG4gIHBvbGwgKGxhc3RDdXJyZW50VGltZSwgYnVmZmVyZWQpIHtcbiAgICBjb25zdCB7IGNvbmZpZywgbWVkaWEgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBjb25zdCB0bm93ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgaWYgKGN1cnJlbnRUaW1lICE9PSBsYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgIC8vIFRoZSBwbGF5aGVhZCBpcyBub3cgbW92aW5nLCBidXQgd2FzIHByZXZpb3VzbHkgc3RhbGxlZFxuICAgICAgaWYgKHRoaXMuc3RhbGxSZXBvcnRlZCkge1xuICAgICAgICBsb2dnZXIud2FybihgcGxheWJhY2sgbm90IHN0dWNrIGFueW1vcmUgQCR7Y3VycmVudFRpbWV9LCBhZnRlciAke01hdGgucm91bmQodG5vdyAtIHRoaXMuc3RhbGxlZCl9bXNgKTtcbiAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgdGhpcy5udWRnZVJldHJ5ID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWVkaWEuZW5kZWQgfHwgIW1lZGlhLmJ1ZmZlcmVkLmxlbmd0aCB8fCBtZWRpYS5yZWFkeVN0YXRlID4gMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtZWRpYS5zZWVraW5nICYmIEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLCBjdXJyZW50VGltZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGUgcGxheWhlYWQgaXNuJ3QgbW92aW5nIGJ1dCBpdCBzaG91bGQgYmVcbiAgICAvLyBBbGxvdyBzb21lIHNsYWNrIHRpbWUgdG8gZm9yIHNtYWxsIHN0YWxscyB0byByZXNvbHZlIHRoZW1zZWx2ZXNcbiAgICBjb25zdCBzdGFsbGVkRHVyYXRpb24gPSB0bm93IC0gdGhpcy5zdGFsbGVkO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICBpZiAoIXRoaXMuc3RhbGxlZCkge1xuICAgICAgdGhpcy5zdGFsbGVkID0gdG5vdztcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHN0YWxsZWREdXJhdGlvbiA+PSBzdGFsbERlYm91bmNlSW50ZXJ2YWwpIHtcbiAgICAgIC8vIFJlcG9ydCBzdGFsbGluZyBhZnRlciB0cnlpbmcgdG8gZml4XG4gICAgICB0aGlzLl9yZXBvcnRTdGFsbChidWZmZXJJbmZvLmxlbik7XG4gICAgfVxuXG4gICAgdGhpcy5fdHJ5Rml4QnVmZmVyU3RhbGwoYnVmZmVySW5mbywgc3RhbGxlZER1cmF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3RzIGFuZCBhdHRlbXB0cyB0byBmaXgga25vd24gYnVmZmVyIHN0YWxsaW5nIGlzc3Vlcy5cbiAgICogQHBhcmFtIGJ1ZmZlckluZm8gLSBUaGUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBidWZmZXIuXG4gICAqIEBwYXJhbSBzdGFsbGVkRHVyYXRpb24gLSBUaGUgYW1vdW50IG9mIHRpbWUgSGxzLmpzIGhhcyBiZWVuIHN0YWxsaW5nIGZvci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90cnlGaXhCdWZmZXJTdGFsbCAoYnVmZmVySW5mbywgc3RhbGxlZER1cmF0aW9uKSB7XG4gICAgY29uc3QgeyBjb25maWcsIGZyYWdtZW50VHJhY2tlciwgbWVkaWEgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcblxuICAgIGNvbnN0IHBhcnRpYWwgPSBmcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKTtcbiAgICBpZiAocGFydGlhbCkge1xuICAgICAgLy8gVHJ5IHRvIHNraXAgb3ZlciB0aGUgYnVmZmVyIGhvbGUgY2F1c2VkIGJ5IGEgcGFydGlhbCBmcmFnbWVudFxuICAgICAgLy8gVGhpcyBtZXRob2QgaXNuJ3QgbGltaXRlZCBieSB0aGUgc2l6ZSBvZiB0aGUgZ2FwIGJldHdlZW4gYnVmZmVyZWQgcmFuZ2VzXG4gICAgICB0aGlzLl90cnlTa2lwQnVmZmVySG9sZShwYXJ0aWFsKTtcbiAgICB9XG5cbiAgICBpZiAoYnVmZmVySW5mby5sZW4gPiBqdW1wVGhyZXNob2xkICYmIHN0YWxsZWREdXJhdGlvbiA+IGNvbmZpZy5oaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2QgKiAxMDAwKSB7XG4gICAgICAvLyBUcnkgdG8gbnVkZ2UgY3VycmVudFRpbWUgb3ZlciBhIGJ1ZmZlciBob2xlIGlmIHdlJ3ZlIGJlZW4gc3RhbGxpbmcgZm9yIHRoZSBjb25maWd1cmVkIGFtb3VudCBvZiBzZWNvbmRzXG4gICAgICAvLyBXZSBvbmx5IHRyeSB0byBqdW1wIHRoZSBob2xlIGlmIGl0J3MgdW5kZXIgdGhlIGNvbmZpZ3VyZWQgc2l6ZVxuICAgICAgLy8gUmVzZXQgc3RhbGxlZCBzbyB0byByZWFybSB3YXRjaGRvZyB0aW1lclxuICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgIHRoaXMuX3RyeU51ZGdlQnVmZmVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgQlVGRkVSX1NUQUxMRURfRVJST1IgZXZlbnQsIGJ1dCBvbmx5IG9uY2UgcGVyIHN0YWxsIHBlcmlvZC5cbiAgICogQHBhcmFtIGJ1ZmZlckxlbiAtIFRoZSBwbGF5aGVhZCBkaXN0YW5jZSBmcm9tIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyIHNlZ21lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVwb3J0U3RhbGwgKGJ1ZmZlckxlbikge1xuICAgIGNvbnN0IHsgaGxzLCBtZWRpYSwgc3RhbGxSZXBvcnRlZCB9ID0gdGhpcztcbiAgICBpZiAoIXN0YWxsUmVwb3J0ZWQpIHtcbiAgICAgIC8vIFJlcG9ydCBzdGFsbGVkIGVycm9yIG9uY2VcbiAgICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IHRydWU7XG4gICAgICBsb2dnZXIud2FybihgUGxheWJhY2sgc3RhbGxpbmcgYXQgQCR7bWVkaWEuY3VycmVudFRpbWV9IGR1ZSB0byBsb3cgYnVmZmVyYCk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgYnVmZmVyOiBidWZmZXJMZW5cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBmaXggYnVmZmVyIHN0YWxscyBieSBqdW1waW5nIG92ZXIga25vd24gZ2FwcyBjYXVzZWQgYnkgcGFydGlhbCBmcmFnbWVudHNcbiAgICogQHBhcmFtIHBhcnRpYWwgLSBUaGUgcGFydGlhbCBmcmFnbWVudCBmb3VuZCBhdCB0aGUgY3VycmVudCB0aW1lICh3aGVyZSBwbGF5YmFjayBpcyBzdGFsbGluZykuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdHJ5U2tpcEJ1ZmZlckhvbGUgKHBhcnRpYWwpIHtcbiAgICBjb25zdCB7IGhscywgbWVkaWEgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBsZXQgbGFzdEVuZFRpbWUgPSAwO1xuICAgIC8vIENoZWNrIGlmIGN1cnJlbnRUaW1lIGlzIGJldHdlZW4gdW5idWZmZXJlZCByZWdpb25zIG9mIHBhcnRpYWwgZnJhZ21lbnRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWRpYS5idWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHN0YXJ0VGltZSA9IG1lZGlhLmJ1ZmZlcmVkLnN0YXJ0KGkpO1xuICAgICAgaWYgKGN1cnJlbnRUaW1lID49IGxhc3RFbmRUaW1lICYmIGN1cnJlbnRUaW1lIDwgc3RhcnRUaW1lKSB7XG4gICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gTWF0aC5tYXgoc3RhcnRUaW1lLCBtZWRpYS5jdXJyZW50VGltZSArIDAuMSk7XG4gICAgICAgIGxvZ2dlci53YXJuKGBza2lwcGluZyBob2xlLCBhZGp1c3RpbmcgY3VycmVudFRpbWUgZnJvbSAke2N1cnJlbnRUaW1lfSB0byAke21lZGlhLmN1cnJlbnRUaW1lfWApO1xuICAgICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TRUVLX09WRVJfSE9MRSxcbiAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgcmVhc29uOiBgZnJhZ21lbnQgbG9hZGVkIHdpdGggYnVmZmVyIGhvbGVzLCBzZWVraW5nIGZyb20gJHtjdXJyZW50VGltZX0gdG8gJHttZWRpYS5jdXJyZW50VGltZX1gLFxuICAgICAgICAgIGZyYWc6IHBhcnRpYWxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxhc3RFbmRUaW1lID0gbWVkaWEuYnVmZmVyZWQuZW5kKGkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBmaXggYnVmZmVyIHN0YWxscyBieSBhZHZhbmNpbmcgdGhlIG1lZGlhRWxlbWVudCdzIGN1cnJlbnQgdGltZSBieSBhIHNtYWxsIGFtb3VudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90cnlOdWRnZUJ1ZmZlciAoKSB7XG4gICAgY29uc3QgeyBjb25maWcsIGhscywgbWVkaWEgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBjb25zdCBudWRnZVJldHJ5ID0gKHRoaXMubnVkZ2VSZXRyeSB8fCAwKSArIDE7XG4gICAgdGhpcy5udWRnZVJldHJ5ID0gbnVkZ2VSZXRyeTtcblxuICAgIGlmIChudWRnZVJldHJ5IDwgY29uZmlnLm51ZGdlTWF4UmV0cnkpIHtcbiAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBjdXJyZW50VGltZSArIG51ZGdlUmV0cnkgKiBjb25maWcubnVkZ2VPZmZzZXQ7XG4gICAgICBsb2dnZXIubG9nKGBhZGp1c3QgY3VycmVudFRpbWUgZnJvbSAke2N1cnJlbnRUaW1lfSB0byAke3RhcmdldFRpbWV9YCk7XG4gICAgICAvLyBwbGF5YmFjayBzdGFsbGVkIGluIGJ1ZmZlcmVkIGFyZWEgLi4uIGxldCdzIG51ZGdlIGN1cnJlbnRUaW1lIHRvIHRyeSB0byBvdmVyY29tZSB0aGlzXG4gICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHRhcmdldFRpbWU7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX05VREdFX09OX1NUQUxMLFxuICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZXJyb3IoYHN0aWxsIHN0dWNrIGluIGhpZ2ggYnVmZmVyIEAke2N1cnJlbnRUaW1lfSBhZnRlciAke2NvbmZpZy5udWRnZU1heFJldHJ5fSwgcmFpc2UgZmF0YWwgZXJyb3JgKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUixcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIGlkMyBtZXRhZGF0YSB0cmFjayBjb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgSUQzIGZyb20gJy4uL2RlbXV4L2lkMyc7XG5pbXBvcnQgeyBzZW5kQWRkVHJhY2tFdmVudCwgY2xlYXJDdXJyZW50Q3VlcyB9IGZyb20gJy4uL3V0aWxzL3RleHR0cmFjay11dGlscyc7XG5cbmNsYXNzIElEM1RyYWNrQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19NRVRBREFUQSk7XG4gICAgdGhpcy5pZDNUcmFjayA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1lZGlhID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICAvLyBBZGQgSUQzIG1ldGF0YWRhdGEgdGV4dCB0cmFjay5cbiAgb25NZWRpYUF0dGFjaGVkIChkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG5cbiAgICB9XG4gIH1cblxuICBvbk1lZGlhRGV0YWNoaW5nICgpIHtcbiAgICBjbGVhckN1cnJlbnRDdWVzKHRoaXMuaWQzVHJhY2spO1xuICAgIHRoaXMuaWQzVHJhY2sgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tZWRpYSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldElEM1RyYWNrICh0ZXh0VHJhY2tzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdGV4dFRyYWNrID0gdGV4dFRyYWNrc1tpXTtcbiAgICAgIGlmICh0ZXh0VHJhY2sua2luZCA9PT0gJ21ldGFkYXRhJyAmJiB0ZXh0VHJhY2subGFiZWwgPT09ICdpZDMnKSB7XG4gICAgICAgIC8vIHNlbmQgJ2FkZHRyYWNrJyB3aGVuIHJldXNpbmcgdGhlIHRleHRUcmFjayBmb3IgbWV0YWRhdGEsXG4gICAgICAgIC8vIHNhbWUgYXMgd2hhdCB3ZSBkbyBmb3IgY2FwdGlvbnNcbiAgICAgICAgc2VuZEFkZFRyYWNrRXZlbnQodGV4dFRyYWNrLCB0aGlzLm1lZGlhKTtcblxuICAgICAgICByZXR1cm4gdGV4dFRyYWNrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZWRpYS5hZGRUZXh0VHJhY2soJ21ldGFkYXRhJywgJ2lkMycpO1xuICB9XG5cbiAgb25GcmFnUGFyc2luZ01ldGFkYXRhIChkYXRhKSB7XG4gICAgY29uc3QgZnJhZ21lbnQgPSBkYXRhLmZyYWc7XG4gICAgY29uc3Qgc2FtcGxlcyA9IGRhdGEuc2FtcGxlcztcblxuICAgIC8vIGNyZWF0ZSB0cmFjayBkeW5hbWljYWxseVxuICAgIGlmICghdGhpcy5pZDNUcmFjaykge1xuICAgICAgdGhpcy5pZDNUcmFjayA9IHRoaXMuZ2V0SUQzVHJhY2sodGhpcy5tZWRpYS50ZXh0VHJhY2tzKTtcbiAgICAgIHRoaXMuaWQzVHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICAgIH1cblxuICAgIC8vIEF0dGVtcHQgdG8gcmVjcmVhdGUgU2FmYXJpIGZ1bmN0aW9uYWxpdHkgYnkgY3JlYXRpbmdcbiAgICAvLyBXZWJLaXREYXRhQ3VlIG9iamVjdHMgd2hlbiBhdmFpbGFibGUgYW5kIHN0b3JlIHRoZSBkZWNvZGVkXG4gICAgLy8gSUQzIGRhdGEgaW4gdGhlIHZhbHVlIHByb3BlcnR5IG9mIHRoZSBjdWVcbiAgICBsZXQgQ3VlID0gd2luZG93LldlYktpdERhdGFDdWUgfHwgd2luZG93LlZUVEN1ZSB8fCB3aW5kb3cuVGV4dFRyYWNrQ3VlO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBmcmFtZXMgPSBJRDMuZ2V0SUQzRnJhbWVzKHNhbXBsZXNbaV0uZGF0YSk7XG4gICAgICBpZiAoZnJhbWVzKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHNhbXBsZXNbaV0ucHRzO1xuICAgICAgICBsZXQgZW5kVGltZSA9IGkgPCBzYW1wbGVzLmxlbmd0aCAtIDEgPyBzYW1wbGVzW2kgKyAxXS5wdHMgOiBmcmFnbWVudC5lbmRQVFM7XG5cbiAgICAgICAgLy8gR2l2ZSBhIHNsaWdodCBidW1wIHRvIHRoZSBlbmRUaW1lIGlmIGl0J3MgZXF1YWwgdG8gc3RhcnRUaW1lIHRvIGF2b2lkIGEgU3ludGF4RXJyb3IgaW4gSUVcbiAgICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gZW5kVGltZSkge1xuICAgICAgICAgIGVuZFRpbWUgKz0gMC4wMDAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmcmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBmcmFtZSA9IGZyYW1lc1tqXTtcbiAgICAgICAgICAvLyBTYWZhcmkgZG9lc24ndCBwdXQgdGhlIHRpbWVzdGFtcCBmcmFtZSBpbiB0aGUgVGV4dFRyYWNrXG4gICAgICAgICAgaWYgKCFJRDMuaXNUaW1lU3RhbXBGcmFtZShmcmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1ZSA9IG5ldyBDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCAnJyk7XG4gICAgICAgICAgICBjdWUudmFsdWUgPSBmcmFtZTtcbiAgICAgICAgICAgIHRoaXMuaWQzVHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElEM1RyYWNrQ29udHJvbGxlcjtcbiIsIi8qXG4gKiBMZXZlbCBDb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGlzQ29kZWNTdXBwb3J0ZWRJbk1wNCB9IGZyb20gJy4uL3V0aWxzL2NvZGVjcyc7XG5pbXBvcnQgeyBhZGRHcm91cElkLCBjb21wdXRlUmVsb2FkSW50ZXJ2YWwgfSBmcm9tICcuL2xldmVsLWhlbHBlcic7XG5cbmNvbnN0IHsgcGVyZm9ybWFuY2UgfSA9IHdpbmRvdztcbmxldCBjaHJvbWVPckZpcmVmb3g7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExldmVsQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FERUQsXG4gICAgICBFdmVudC5MRVZFTF9MT0FERUQsXG4gICAgICBFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCxcbiAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxuICAgICAgRXZlbnQuRVJST1IpO1xuXG4gICAgdGhpcy5jYW5sb2FkID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IG51bGw7XG4gICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gLTE7XG4gICAgdGhpcy50aW1lciA9IG51bGw7XG5cbiAgICBjaHJvbWVPckZpcmVmb3ggPSAvY2hyb21lfGZpcmVmb3gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIG9uSGFuZGxlckRlc3Ryb3lpbmcgKCkge1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IC0xO1xuICB9XG5cbiAgY2xlYXJUaW1lciAoKSB7XG4gICAgaWYgKHRoaXMudGltZXIgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHN0YXJ0TG9hZCAoKSB7XG4gICAgbGV0IGxldmVscyA9IHRoaXMuX2xldmVscztcblxuICAgIHRoaXMuY2FubG9hZCA9IHRydWU7XG4gICAgdGhpcy5sZXZlbFJldHJ5Q291bnQgPSAwO1xuXG4gICAgLy8gY2xlYW4gdXAgbGl2ZSBsZXZlbCBkZXRhaWxzIHRvIGZvcmNlIHJlbG9hZCB0aGVtLCBhbmQgcmVzZXQgbG9hZCBlcnJvcnNcbiAgICBpZiAobGV2ZWxzKSB7XG4gICAgICBsZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICAgIGxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgICAgIGlmIChsZXZlbERldGFpbHMgJiYgbGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICBsZXZlbC5kZXRhaWxzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gc3BlZWQgdXAgbGl2ZSBwbGF5bGlzdCByZWZyZXNoIGlmIHRpbWVyIGV4aXN0c1xuICAgIGlmICh0aGlzLnRpbWVyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmxvYWRMZXZlbCgpO1xuICAgIH1cbiAgfVxuXG4gIHN0b3BMb2FkICgpIHtcbiAgICB0aGlzLmNhbmxvYWQgPSBmYWxzZTtcbiAgfVxuXG4gIG9uTWFuaWZlc3RMb2FkZWQgKGRhdGEpIHtcbiAgICBsZXQgbGV2ZWxzID0gW107XG4gICAgbGV0IGF1ZGlvVHJhY2tzID0gW107XG4gICAgbGV0IGJpdHJhdGVTdGFydDtcbiAgICBsZXQgbGV2ZWxTZXQgPSB7fTtcbiAgICBsZXQgbGV2ZWxGcm9tU2V0ID0gbnVsbDtcbiAgICBsZXQgdmlkZW9Db2RlY0ZvdW5kID0gZmFsc2U7XG4gICAgbGV0IGF1ZGlvQ29kZWNGb3VuZCA9IGZhbHNlO1xuXG4gICAgLy8gcmVncm91cCByZWR1bmRhbnQgbGV2ZWxzIHRvZ2V0aGVyXG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbGV2ZWwuYXR0cnM7XG4gICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IGZhbHNlO1xuXG4gICAgICB2aWRlb0NvZGVjRm91bmQgPSB2aWRlb0NvZGVjRm91bmQgfHwgISFsZXZlbC52aWRlb0NvZGVjO1xuICAgICAgYXVkaW9Db2RlY0ZvdW5kID0gYXVkaW9Db2RlY0ZvdW5kIHx8ICEhbGV2ZWwuYXVkaW9Db2RlYztcblxuICAgICAgLy8gZXJhc2UgYXVkaW8gY29kZWMgaW5mbyBpZiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbXA0YS40MC4zNC5cbiAgICAgIC8vIGRlbXV4ZXIgd2lsbCBhdXRvZGV0ZWN0IGNvZGVjIGFuZCBmYWxsYmFjayB0byBtcGVnL2F1ZGlvXG4gICAgICBpZiAoY2hyb21lT3JGaXJlZm94ICYmIGxldmVsLmF1ZGlvQ29kZWMgJiYgbGV2ZWwuYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjM0JykgIT09IC0xKSB7XG4gICAgICAgIGxldmVsLmF1ZGlvQ29kZWMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGxldmVsRnJvbVNldCA9IGxldmVsU2V0W2xldmVsLmJpdHJhdGVdOyAvLyBGSVhNRTogd2Ugd291bGQgYWxzbyBoYXZlIHRvIG1hdGNoIHRoZSByZXNvbHV0aW9uIGhlcmVcblxuICAgICAgaWYgKCFsZXZlbEZyb21TZXQpIHtcbiAgICAgICAgbGV2ZWwudXJsID0gW2xldmVsLnVybF07XG4gICAgICAgIGxldmVsLnVybElkID0gMDtcbiAgICAgICAgbGV2ZWxTZXRbbGV2ZWwuYml0cmF0ZV0gPSBsZXZlbDtcbiAgICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxGcm9tU2V0LnVybC5wdXNoKGxldmVsLnVybCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLkFVRElPKSB7XG4gICAgICAgICAgYXVkaW9Db2RlY0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBhZGRHcm91cElkKGxldmVsRnJvbVNldCB8fCBsZXZlbCwgJ2F1ZGlvJywgYXR0cmlidXRlcy5BVURJTyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMuU1VCVElUTEVTKSB7XG4gICAgICAgICAgYWRkR3JvdXBJZChsZXZlbEZyb21TZXQgfHwgbGV2ZWwsICd0ZXh0JywgYXR0cmlidXRlcy5TVUJUSVRMRVMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyByZW1vdmUgYXVkaW8tb25seSBsZXZlbCBpZiB3ZSBhbHNvIGhhdmUgbGV2ZWxzIHdpdGggYXVkaW8rdmlkZW8gY29kZWNzIHNpZ25hbGxlZFxuICAgIGlmICh2aWRlb0NvZGVjRm91bmQgJiYgYXVkaW9Db2RlY0ZvdW5kKSB7XG4gICAgICBsZXZlbHMgPSBsZXZlbHMuZmlsdGVyKCh7IHZpZGVvQ29kZWMgfSkgPT4gISF2aWRlb0NvZGVjKTtcbiAgICB9XG5cbiAgICAvLyBvbmx5IGtlZXAgbGV2ZWxzIHdpdGggc3VwcG9ydGVkIGF1ZGlvL3ZpZGVvIGNvZGVjc1xuICAgIGxldmVscyA9IGxldmVscy5maWx0ZXIoKHsgYXVkaW9Db2RlYywgdmlkZW9Db2RlYyB9KSA9PiB7XG4gICAgICByZXR1cm4gKCFhdWRpb0NvZGVjIHx8IGlzQ29kZWNTdXBwb3J0ZWRJbk1wNChhdWRpb0NvZGVjLCAnYXVkaW8nKSkgJiYgKCF2aWRlb0NvZGVjIHx8IGlzQ29kZWNTdXBwb3J0ZWRJbk1wNCh2aWRlb0NvZGVjLCAndmlkZW8nKSk7XG4gICAgfSk7XG5cbiAgICBpZiAoZGF0YS5hdWRpb1RyYWNrcykge1xuICAgICAgYXVkaW9UcmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzLmZpbHRlcih0cmFjayA9PiAhdHJhY2suYXVkaW9Db2RlYyB8fCBpc0NvZGVjU3VwcG9ydGVkSW5NcDQodHJhY2suYXVkaW9Db2RlYywgJ2F1ZGlvJykpO1xuICAgICAgLy8gUmVhc3NpZ24gaWQncyBhZnRlciBmaWx0ZXJpbmcgc2luY2UgdGhleSdyZSB1c2VkIGFzIGFycmF5IGluZGljZXNcbiAgICAgIGF1ZGlvVHJhY2tzLmZvckVhY2goKHRyYWNrLCBpbmRleCkgPT4ge1xuICAgICAgICB0cmFjay5pZCA9IGluZGV4O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGxldmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBzdGFydCBiaXRyYXRlIGlzIHRoZSBmaXJzdCBiaXRyYXRlIG9mIHRoZSBtYW5pZmVzdFxuICAgICAgYml0cmF0ZVN0YXJ0ID0gbGV2ZWxzWzBdLmJpdHJhdGU7XG4gICAgICAvLyBzb3J0IGxldmVsIG9uIGJpdHJhdGVcbiAgICAgIGxldmVscy5zb3J0KChhLCBiKSA9PiBhLmJpdHJhdGUgLSBiLmJpdHJhdGUpO1xuICAgICAgdGhpcy5fbGV2ZWxzID0gbGV2ZWxzO1xuICAgICAgLy8gZmluZCBpbmRleCBvZiBmaXJzdCBsZXZlbCBpbiBzb3J0ZWQgbGV2ZWxzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGV2ZWxzW2ldLmJpdHJhdGUgPT09IGJpdHJhdGVTdGFydCkge1xuICAgICAgICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBpO1xuICAgICAgICAgIGxvZ2dlci5sb2coYG1hbmlmZXN0IGxvYWRlZCwke2xldmVscy5sZW5ndGh9IGxldmVsKHMpIGZvdW5kLCBmaXJzdCBiaXRyYXRlOiR7Yml0cmF0ZVN0YXJ0fWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEF1ZGlvIGlzIG9ubHkgYWx0ZXJuYXRlIGlmIG1hbmlmZXN0IGluY2x1ZGUgYSBVUkkgYWxvbmcgd2l0aCB0aGUgYXVkaW8gZ3JvdXAgdGFnXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50Lk1BTklGRVNUX1BBUlNFRCwge1xuICAgICAgICBsZXZlbHMsXG4gICAgICAgIGF1ZGlvVHJhY2tzLFxuICAgICAgICBmaXJzdExldmVsOiB0aGlzLl9maXJzdExldmVsLFxuICAgICAgICBzdGF0czogZGF0YS5zdGF0cyxcbiAgICAgICAgYXVkaW86IGF1ZGlvQ29kZWNGb3VuZCxcbiAgICAgICAgdmlkZW86IHZpZGVvQ29kZWNGb3VuZCxcbiAgICAgICAgYWx0QXVkaW86IGF1ZGlvVHJhY2tzLnNvbWUodCA9PiAhIXQudXJsKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IsXG4gICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICB1cmw6IHRoaXMuaGxzLnVybCxcbiAgICAgICAgcmVhc29uOiAnbm8gbGV2ZWwgd2l0aCBjb21wYXRpYmxlIGNvZGVjcyBmb3VuZCBpbiBtYW5pZmVzdCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGdldCBsZXZlbHMgKCkge1xuICAgIHJldHVybiB0aGlzLl9sZXZlbHM7XG4gIH1cblxuICBnZXQgbGV2ZWwgKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICB9XG5cbiAgc2V0IGxldmVsIChuZXdMZXZlbCkge1xuICAgIGxldCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgaWYgKGxldmVscykge1xuICAgICAgbmV3TGV2ZWwgPSBNYXRoLm1pbihuZXdMZXZlbCwgbGV2ZWxzLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKHRoaXMuY3VycmVudExldmVsSW5kZXggIT09IG5ld0xldmVsIHx8ICFsZXZlbHNbbmV3TGV2ZWxdLmRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5zZXRMZXZlbEludGVybmFsKG5ld0xldmVsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXRMZXZlbEludGVybmFsIChuZXdMZXZlbCkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuX2xldmVscztcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICBpZiAobmV3TGV2ZWwgPj0gMCAmJiBuZXdMZXZlbCA8IGxldmVscy5sZW5ndGgpIHtcbiAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICBpZiAodGhpcy5jdXJyZW50TGV2ZWxJbmRleCAhPT0gbmV3TGV2ZWwpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgc3dpdGNoaW5nIHRvIGxldmVsICR7bmV3TGV2ZWx9YCk7XG4gICAgICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSBuZXdMZXZlbDtcbiAgICAgICAgY29uc3QgbGV2ZWxQcm9wZXJ0aWVzID0gbGV2ZWxzW25ld0xldmVsXTtcbiAgICAgICAgbGV2ZWxQcm9wZXJ0aWVzLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX1NXSVRDSElORywgbGV2ZWxQcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW25ld0xldmVsXTtcbiAgICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG5cbiAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBsZXZlbFxuICAgICAgaWYgKCFsZXZlbERldGFpbHMgfHwgbGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgLy8gbGV2ZWwgbm90IHJldHJpZXZlZCB5ZXQsIG9yIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byAocmUpbG9hZCBpdFxuICAgICAgICBsZXQgdXJsSWQgPSBsZXZlbC51cmxJZDtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfTE9BRElORywgeyB1cmw6IGxldmVsLnVybFt1cmxJZF0sIGxldmVsOiBuZXdMZXZlbCwgaWQ6IHVybElkIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbnZhbGlkIGxldmVsIGlkIGdpdmVuLCB0cmlnZ2VyIGVycm9yXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTEVWRUxfU1dJVENIX0VSUk9SLFxuICAgICAgICBsZXZlbDogbmV3TGV2ZWwsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgcmVhc29uOiAnaW52YWxpZCBsZXZlbCBpZHgnXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBnZXQgbWFudWFsTGV2ZWwgKCkge1xuICAgIHJldHVybiB0aGlzLm1hbnVhbExldmVsSW5kZXg7XG4gIH1cblxuICBzZXQgbWFudWFsTGV2ZWwgKG5ld0xldmVsKSB7XG4gICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gbmV3TGV2ZWw7XG4gICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cblxuICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcbiAgICAgIHRoaXMubGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gIH1cblxuICBnZXQgZmlyc3RMZXZlbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWw7XG4gIH1cblxuICBzZXQgZmlyc3RMZXZlbCAobmV3TGV2ZWwpIHtcbiAgICB0aGlzLl9maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICBnZXQgc3RhcnRMZXZlbCAoKSB7XG4gICAgLy8gaGxzLnN0YXJ0TGV2ZWwgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGNvbmZpZy5zdGFydExldmVsXG4gICAgLy8gaWYgbm9uZSBvZiB0aGVzZSB2YWx1ZXMgYXJlIGRlZmluZWQsIGZhbGxiYWNrIG9uIHRoaXMuX2ZpcnN0TGV2ZWwgKGZpcnN0IHF1YWxpdHkgbGV2ZWwgYXBwZWFyaW5nIGluIHZhcmlhbnQgbWFuaWZlc3QpXG4gICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IGNvbmZpZ1N0YXJ0TGV2ZWwgPSB0aGlzLmhscy5jb25maWcuc3RhcnRMZXZlbDtcbiAgICAgIGlmIChjb25maWdTdGFydExldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZ1N0YXJ0TGV2ZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0TGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgc2V0IHN0YXJ0TGV2ZWwgKG5ld0xldmVsKSB7XG4gICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgb25FcnJvciAoZGF0YSkge1xuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICBpZiAoZGF0YS50eXBlID09PSBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgbGV2ZWxFcnJvciA9IGZhbHNlLCBmcmFnbWVudEVycm9yID0gZmFsc2U7XG4gICAgbGV0IGxldmVsSW5kZXg7XG5cbiAgICAvLyB0cnkgdG8gcmVjb3ZlciBub3QgZmF0YWwgZXJyb3JzXG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgIGxldmVsSW5kZXggPSBkYXRhLmZyYWcubGV2ZWxzO1xuICAgICAgZnJhZ21lbnRFcnJvciA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgIGxldmVsSW5kZXggPSBkYXRhLmNvbnRleHQubGV2ZWxzO1xuICAgICAgbGV2ZWxFcnJvciA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUjpcbiAgICAgIGxldmVsSW5kZXggPSBkYXRhLmxldmVscztcbiAgICAgIGxldmVsRXJyb3IgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGxldmVsSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5yZWNvdmVyTGV2ZWwoZGF0YSwgbGV2ZWxJbmRleCwgbGV2ZWxFcnJvciwgZnJhZ21lbnRFcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN3aXRjaCB0byBhIHJlZHVuZGFudCBzdHJlYW0gaWYgYW55IGF2YWlsYWJsZS5cbiAgICogSWYgcmVkdW5kYW50IHN0cmVhbSBpcyBub3QgYXZhaWxhYmxlLCBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gaWYgQUJSIG1vZGUgaXMgZW5hYmxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVycm9yRXZlbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsSW5kZXggY3VycmVudCBsZXZlbCBpbmRleFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxldmVsRXJyb3JcbiAgICogQHBhcmFtIHtCb29sZWFufSBmcmFnbWVudEVycm9yXG4gICAqL1xuICAvLyBGSVhNRSBGaW5kIGEgYmV0dGVyIGFic3RyYWN0aW9uIHdoZXJlIGZyYWdtZW50L2xldmVsIHJldHJ5IG1hbmFnZW1lbnQgaXMgd2VsbCBkZWNvdXBsZWRcbiAgcmVjb3ZlckxldmVsIChlcnJvckV2ZW50LCBsZXZlbEluZGV4LCBsZXZlbEVycm9yLCBmcmFnbWVudEVycm9yKSB7XG4gICAgbGV0IHsgY29uZmlnIH0gPSB0aGlzLmhscztcbiAgICBsZXQgeyBkZXRhaWxzOiBlcnJvckRldGFpbHMgfSA9IGVycm9yRXZlbnQ7XG4gICAgbGV0IGxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIGxldCByZWR1bmRhbnRMZXZlbHMsIGRlbGF5LCBuZXh0TGV2ZWw7XG5cbiAgICBsZXZlbC5sb2FkRXJyb3IrKztcbiAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gZnJhZ21lbnRFcnJvcjtcblxuICAgIGlmIChsZXZlbEVycm9yKSB7XG4gICAgICBpZiAoKHRoaXMubGV2ZWxSZXRyeUNvdW50ICsgMSkgPD0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5KSB7XG4gICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIG1heCByZXRyeSB0aW1lb3V0XG4gICAgICAgIGRlbGF5ID0gTWF0aC5taW4oTWF0aC5wb3coMiwgdGhpcy5sZXZlbFJldHJ5Q291bnQpICogY29uZmlnLmxldmVsTG9hZGluZ1JldHJ5RGVsYXksIGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQpO1xuICAgICAgICAvLyBTY2hlZHVsZSBsZXZlbCByZWxvYWRcbiAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5sb2FkTGV2ZWwoKSwgZGVsYXkpO1xuICAgICAgICAvLyBib29sZWFuIHVzZWQgdG8gaW5mb3JtIHN0cmVhbSBjb250cm9sbGVyIG5vdCB0byBzd2l0Y2ggYmFjayB0byBJRExFIG9uIG5vbiBmYXRhbCBlcnJvclxuICAgICAgICBlcnJvckV2ZW50LmxldmVsUmV0cnkgPSB0cnVlO1xuICAgICAgICB0aGlzLmxldmVsUmV0cnlDb3VudCsrO1xuICAgICAgICBsb2dnZXIud2FybihgbGV2ZWwgY29udHJvbGxlciwgJHtlcnJvckRldGFpbHN9LCByZXRyeSBpbiAke2RlbGF5fSBtcywgY3VycmVudCByZXRyeSBjb3VudCBpcyAke3RoaXMubGV2ZWxSZXRyeUNvdW50fWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBsZXZlbCBjb250cm9sbGVyLCBjYW5ub3QgcmVjb3ZlciBmcm9tICR7ZXJyb3JEZXRhaWxzfSBlcnJvcmApO1xuICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gbnVsbDtcbiAgICAgICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICAvLyBzd2l0Y2ggZXJyb3IgdG8gZmF0YWxcbiAgICAgICAgZXJyb3JFdmVudC5mYXRhbCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcnkgYW55IHJlZHVuZGFudCBzdHJlYW1zIGlmIGF2YWlsYWJsZSBmb3IgYm90aCBlcnJvcnM6IGxldmVsIGFuZCBmcmFnbWVudFxuICAgIC8vIElmIGxldmVsLmxvYWRFcnJvciByZWFjaGVzIHJlZHVuZGFudExldmVscyBpdCBtZWFucyB0aGF0IHdlIHRyaWVkIHRoZW0gYWxsLCBubyBob3BlICA9PiBsZXQncyBzd2l0Y2ggZG93blxuICAgIGlmIChsZXZlbEVycm9yIHx8IGZyYWdtZW50RXJyb3IpIHtcbiAgICAgIHJlZHVuZGFudExldmVscyA9IGxldmVsLnVybC5sZW5ndGg7XG5cbiAgICAgIGlmIChyZWR1bmRhbnRMZXZlbHMgPiAxICYmIGxldmVsLmxvYWRFcnJvciA8IHJlZHVuZGFudExldmVscykge1xuICAgICAgICBsZXZlbC51cmxJZCA9IChsZXZlbC51cmxJZCArIDEpICUgcmVkdW5kYW50TGV2ZWxzO1xuICAgICAgICBsZXZlbC5kZXRhaWxzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbCBjb250cm9sbGVyLCAke2Vycm9yRGV0YWlsc30gZm9yIGxldmVsICR7bGV2ZWxJbmRleH06IHN3aXRjaGluZyB0byByZWR1bmRhbnQgVVJMLWlkICR7bGV2ZWwudXJsSWR9YCk7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0N1cnJlbnQgYXVkaW8gdHJhY2sgZ3JvdXAgSUQ6JywgdGhpcy5obHMuYXVkaW9UcmFja3NbdGhpcy5obHMuYXVkaW9UcmFja10uZ3JvdXBJZCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdOZXcgdmlkZW8gcXVhbGl0eSBsZXZlbCBhdWRpbyBncm91cCBpZDonLCBsZXZlbC5hdHRycy5BVURJTyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZWFyY2ggZm9yIGF2YWlsYWJsZSBsZXZlbFxuICAgICAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ID09PSAtMSkge1xuICAgICAgICAgIC8vIFdoZW4gbG93ZXN0IGxldmVsIGhhcyBiZWVuIHJlYWNoZWQsIGxldCdzIHN0YXJ0IGh1bnQgZnJvbSB0aGUgdG9wXG4gICAgICAgICAgbmV4dExldmVsID0gKGxldmVsSW5kZXggPT09IDApID8gdGhpcy5fbGV2ZWxzLmxlbmd0aCAtIDEgOiBsZXZlbEluZGV4IC0gMTtcbiAgICAgICAgICBsb2dnZXIud2FybihgbGV2ZWwgY29udHJvbGxlciwgJHtlcnJvckRldGFpbHN9OiBzd2l0Y2ggdG8gJHtuZXh0TGV2ZWx9YCk7XG4gICAgICAgICAgdGhpcy5obHMubmV4dEF1dG9MZXZlbCA9IHRoaXMuY3VycmVudExldmVsSW5kZXggPSBuZXh0TGV2ZWw7XG4gICAgICAgIH0gZWxzZSBpZiAoZnJhZ21lbnRFcnJvcikge1xuICAgICAgICAgIC8vIEFsbG93IGZyYWdtZW50IHJldHJ5IGFzIGxvbmcgYXMgY29uZmlndXJhdGlvbiBhbGxvd3MuXG4gICAgICAgICAgLy8gcmVzZXQgdGhpcy5fbGV2ZWwgc28gdGhhdCBhbm90aGVyIGNhbGwgdG8gc2V0IGxldmVsKCkgd2lsbCB0cmlnZ2VyIGFnYWluIGEgZnJhZyBsb2FkXG4gICAgICAgICAgbG9nZ2VyLndhcm4oYGxldmVsIGNvbnRyb2xsZXIsICR7ZXJyb3JEZXRhaWxzfTogcmVsb2FkIGEgZnJhZ21lbnRgKTtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHJlc2V0IGVycm9ycyBvbiB0aGUgc3VjY2Vzc2Z1bCBsb2FkIG9mIGEgZnJhZ21lbnRcbiAgb25GcmFnTG9hZGVkICh7IGZyYWcgfSkge1xuICAgIGlmIChmcmFnICE9PSB1bmRlZmluZWQgJiYgZnJhZy50eXBlID09PSAnbWFpbicpIHtcbiAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5fbGV2ZWxzW2ZyYWcubGV2ZWxzXTtcbiAgICAgIGlmIChsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IgPSBmYWxzZTtcbiAgICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICAgICAgdGhpcy5sZXZlbFJldHJ5Q291bnQgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uTGV2ZWxMb2FkZWQgKGRhdGEpIHtcbiAgICBjb25zdCB7IGxldmVsLCBkZXRhaWxzIH0gPSBkYXRhO1xuICAgIC8vIG9ubHkgcHJvY2VzcyBsZXZlbCBsb2FkZWQgZXZlbnRzIG1hdGNoaW5nIHdpdGggZXhwZWN0ZWQgbGV2ZWxcbiAgICBpZiAobGV2ZWwgIT09IHRoaXMuY3VycmVudExldmVsSW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJMZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbF07XG4gICAgLy8gcmVzZXQgbGV2ZWwgbG9hZCBlcnJvciBjb3VudGVyIG9uIHN1Y2Nlc3NmdWwgbGV2ZWwgbG9hZGVkIG9ubHkgaWYgdGhlcmUgaXMgbm8gaXNzdWVzIHdpdGggZnJhZ21lbnRzXG4gICAgaWYgKCFjdXJMZXZlbC5mcmFnbWVudEVycm9yKSB7XG4gICAgICBjdXJMZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgdGhpcy5sZXZlbFJldHJ5Q291bnQgPSAwO1xuICAgIH1cbiAgICAvLyBpZiBjdXJyZW50IHBsYXlsaXN0IGlzIGEgbGl2ZSBwbGF5bGlzdCwgYXJtIGEgdGltZXIgdG8gcmVsb2FkIGl0XG4gICAgaWYgKGRldGFpbHMubGl2ZSkge1xuICAgICAgY29uc3QgcmVsb2FkSW50ZXJ2YWwgPSBjb21wdXRlUmVsb2FkSW50ZXJ2YWwoY3VyTGV2ZWwuZGV0YWlscywgZGV0YWlscywgZGF0YS5zdGF0cy50cmVxdWVzdCk7XG4gICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0LCByZWxvYWQgaW4gJHtNYXRoLnJvdW5kKHJlbG9hZEludGVydmFsKX0gbXNgKTtcbiAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMubG9hZExldmVsKCksIHJlbG9hZEludGVydmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgfVxuICB9XG5cbiAgb25BdWRpb1RyYWNrU3dpdGNoZWQgKGRhdGEpIHtcbiAgICBjb25zdCBhdWRpb0dyb3VwSWQgPSB0aGlzLmhscy5hdWRpb1RyYWNrc1tkYXRhLmlkXS5ncm91cElkO1xuXG4gICAgY29uc3QgY3VycmVudExldmVsID0gdGhpcy5obHMubGV2ZWxzW3RoaXMuY3VycmVudExldmVsSW5kZXhdO1xuICAgIGlmICghY3VycmVudExldmVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWRzKSB7XG4gICAgICBsZXQgdXJsSWQgPSAtMTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50TGV2ZWwuYXVkaW9Hcm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY3VycmVudExldmVsLmF1ZGlvR3JvdXBJZHNbaV0gPT09IGF1ZGlvR3JvdXBJZCkge1xuICAgICAgICAgIHVybElkID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodXJsSWQgIT09IGN1cnJlbnRMZXZlbC51cmxJZCkge1xuICAgICAgICBjdXJyZW50TGV2ZWwudXJsSWQgPSB1cmxJZDtcbiAgICAgICAgdGhpcy5zdGFydExvYWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsb2FkTGV2ZWwgKCkge1xuICAgIGxvZ2dlci5kZWJ1ZygnY2FsbCB0byBsb2FkTGV2ZWwnKTtcblxuICAgIGlmICh0aGlzLmN1cnJlbnRMZXZlbEluZGV4ICE9PSBudWxsICYmIHRoaXMuY2FubG9hZCkge1xuICAgICAgY29uc3QgbGV2ZWxPYmplY3QgPSB0aGlzLl9sZXZlbHNbdGhpcy5jdXJyZW50TGV2ZWxJbmRleF07XG5cbiAgICAgIGlmICh0eXBlb2YgbGV2ZWxPYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGxldmVsT2JqZWN0LnVybC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleDtcbiAgICAgICAgY29uc3QgaWQgPSBsZXZlbE9iamVjdC51cmxJZDtcbiAgICAgICAgY29uc3QgdXJsID0gbGV2ZWxPYmplY3QudXJsW2lkXTtcblxuICAgICAgICBsb2dnZXIubG9nKGBBdHRlbXB0IGxvYWRpbmcgbGV2ZWwgaW5kZXggJHtsZXZlbH0gd2l0aCBVUkwtaWQgJHtpZH1gKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnQ3VycmVudCBhdWRpbyB0cmFjayBncm91cCBJRDonLCB0aGlzLmhscy5hdWRpb1RyYWNrc1t0aGlzLmhscy5hdWRpb1RyYWNrXS5ncm91cElkKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ05ldyB2aWRlbyBxdWFsaXR5IGxldmVsIGF1ZGlvIGdyb3VwIGlkOicsIGxldmVsT2JqZWN0LmF0dHJzLkFVRElPLCBsZXZlbCk7XG5cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5MRVZFTF9MT0FESU5HLCB7IHVybCwgbGV2ZWwsIGlkIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBuZXh0TG9hZExldmVsICgpIHtcbiAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHRoaXMubWFudWFsTGV2ZWxJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgc2V0IG5leHRMb2FkTGV2ZWwgKG5leHRMZXZlbCkge1xuICAgIHRoaXMubGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgTGV2ZWxIZWxwZXJcbiAqXG4gKiBQcm92aWRpbmcgbWV0aG9kcyBkZWFsaW5nIHdpdGggcGxheWxpc3Qgc2xpZGluZyBhbmQgZHJpZnRcbiAqXG4gKiBUT0RPOiBDcmVhdGUgYW4gYWN0dWFsIGBMZXZlbGAgY2xhc3MvbW9kZWwgdGhhdCBkZWFscyB3aXRoIGFsbCB0aGlzIGxvZ2ljIGluIGFuIG9iamVjdC1vcmllbnRlZC1tYW5uZXIuXG4gKlxuICogKi9cblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEdyb3VwSWQgKGxldmVsLCB0eXBlLCBpZCkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgY2FzZSAnYXVkaW8nOlxuICAgIGlmICghbGV2ZWwuYXVkaW9Hcm91cElkcykge1xuICAgICAgbGV2ZWwuYXVkaW9Hcm91cElkcyA9IFtdO1xuICAgIH1cbiAgICBsZXZlbC5hdWRpb0dyb3VwSWRzLnB1c2goaWQpO1xuICAgIGJyZWFrO1xuICBjYXNlICd0ZXh0JzpcbiAgICBpZiAoIWxldmVsLnRleHRHcm91cElkcykge1xuICAgICAgbGV2ZWwudGV4dEdyb3VwSWRzID0gW107XG4gICAgfVxuICAgIGxldmVsLnRleHRHcm91cElkcy5wdXNoKGlkKTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlUFRTIChmcmFnbWVudHMsIGZyb21JZHgsIHRvSWR4KSB7XG4gIGxldCBmcmFnRnJvbSA9IGZyYWdtZW50c1tmcm9tSWR4XSwgZnJhZ1RvID0gZnJhZ21lbnRzW3RvSWR4XSwgZnJhZ1RvUFRTID0gZnJhZ1RvLnN0YXJ0UFRTO1xuICAvLyBpZiB3ZSBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICBpZiAoTnVtYmVyLmlzRmluaXRlKGZyYWdUb1BUUykpIHtcbiAgICAvLyB1cGRhdGUgZnJhZ21lbnQgZHVyYXRpb24uXG4gICAgLy8gaXQgaGVscHMgdG8gZml4IGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0IHJlcG9ydGVkIGR1cmF0aW9uIGFuZCBmcmFnbWVudCByZWFsIGR1cmF0aW9uXG4gICAgaWYgKHRvSWR4ID4gZnJvbUlkeCkge1xuICAgICAgZnJhZ0Zyb20uZHVyYXRpb24gPSBmcmFnVG9QVFMgLSBmcmFnRnJvbS5zdGFydDtcbiAgICAgIGlmIChmcmFnRnJvbS5kdXJhdGlvbiA8IDApIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYG5lZ2F0aXZlIGR1cmF0aW9uIGNvbXB1dGVkIGZvciBmcmFnICR7ZnJhZ0Zyb20uc259LGxldmVsICR7ZnJhZ0Zyb20ubGV2ZWxzfSwgdGhlcmUgc2hvdWxkIGJlIHNvbWUgZHVyYXRpb24gZHJpZnQgYmV0d2VlbiBwbGF5bGlzdCBhbmQgZnJhZ21lbnQhYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWdUby5kdXJhdGlvbiA9IGZyYWdGcm9tLnN0YXJ0IC0gZnJhZ1RvUFRTO1xuICAgICAgaWYgKGZyYWdUby5kdXJhdGlvbiA8IDApIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYG5lZ2F0aXZlIGR1cmF0aW9uIGNvbXB1dGVkIGZvciBmcmFnICR7ZnJhZ1RvLnNufSxsZXZlbCAke2ZyYWdUby5sZXZlbHN9LCB0aGVyZSBzaG91bGQgYmUgc29tZSBkdXJhdGlvbiBkcmlmdCBiZXR3ZWVuIHBsYXlsaXN0IGFuZCBmcmFnbWVudCFgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gd2UgZG9udCBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICAgIGlmICh0b0lkeCA+IGZyb21JZHgpIHtcbiAgICAgIGZyYWdUby5zdGFydCA9IGZyYWdGcm9tLnN0YXJ0ICsgZnJhZ0Zyb20uZHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWdUby5zdGFydCA9IE1hdGgubWF4KGZyYWdGcm9tLnN0YXJ0IC0gZnJhZ1RvLmR1cmF0aW9uLCAwKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUZyYWdQVFNEVFMgKGRldGFpbHMsIGZyYWcsIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpIHtcbiAgLy8gdXBkYXRlIGZyYWcgUFRTL0RUU1xuICBsZXQgbWF4U3RhcnRQVFMgPSBzdGFydFBUUztcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnLnN0YXJ0UFRTKSkge1xuICAgIC8vIGRlbHRhIFBUUyBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlb1xuICAgIGxldCBkZWx0YVBUUyA9IE1hdGguYWJzKGZyYWcuc3RhcnRQVFMgLSBzdGFydFBUUyk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJhZy5kZWx0YVBUUykpIHtcbiAgICAgIGZyYWcuZGVsdGFQVFMgPSBkZWx0YVBUUztcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZy5kZWx0YVBUUyA9IE1hdGgubWF4KGRlbHRhUFRTLCBmcmFnLmRlbHRhUFRTKTtcbiAgICB9XG5cbiAgICBtYXhTdGFydFBUUyA9IE1hdGgubWF4KHN0YXJ0UFRTLCBmcmFnLnN0YXJ0UFRTKTtcbiAgICBzdGFydFBUUyA9IE1hdGgubWluKHN0YXJ0UFRTLCBmcmFnLnN0YXJ0UFRTKTtcbiAgICBlbmRQVFMgPSBNYXRoLm1heChlbmRQVFMsIGZyYWcuZW5kUFRTKTtcbiAgICBzdGFydERUUyA9IE1hdGgubWluKHN0YXJ0RFRTLCBmcmFnLnN0YXJ0RFRTKTtcbiAgICBlbmREVFMgPSBNYXRoLm1heChlbmREVFMsIGZyYWcuZW5kRFRTKTtcbiAgfVxuXG4gIGNvbnN0IGRyaWZ0ID0gc3RhcnRQVFMgLSBmcmFnLnN0YXJ0O1xuICBmcmFnLnN0YXJ0ID0gZnJhZy5zdGFydFBUUyA9IHN0YXJ0UFRTO1xuICBmcmFnLm1heFN0YXJ0UFRTID0gbWF4U3RhcnRQVFM7XG4gIGZyYWcuZW5kUFRTID0gZW5kUFRTO1xuICBmcmFnLnN0YXJ0RFRTID0gc3RhcnREVFM7XG4gIGZyYWcuZW5kRFRTID0gZW5kRFRTO1xuICBmcmFnLmR1cmF0aW9uID0gZW5kUFRTIC0gc3RhcnRQVFM7XG5cbiAgY29uc3Qgc24gPSBmcmFnLnNuO1xuICAvLyBleGl0IGlmIHNuIG91dCBvZiByYW5nZVxuICBpZiAoIWRldGFpbHMgfHwgc24gPCBkZXRhaWxzLnN0YXJ0U04gfHwgc24gPiBkZXRhaWxzLmVuZFNOKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBsZXQgZnJhZ0lkeCwgZnJhZ21lbnRzLCBpO1xuICBmcmFnSWR4ID0gc24gLSBkZXRhaWxzLnN0YXJ0U047XG4gIGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAvLyB1cGRhdGUgZnJhZyByZWZlcmVuY2UgaW4gZnJhZ21lbnRzIGFycmF5XG4gIC8vIHJhdGlvbmFsZSBpcyB0aGF0IGZyYWdtZW50cyBhcnJheSBtaWdodCBub3QgY29udGFpbiB0aGlzIGZyYWcgb2JqZWN0LlxuICAvLyB0aGlzIHdpbGwgaGFwcGVuIGlmIHBsYXlsaXN0IGhhcyBiZWVuIHJlZnJlc2hlZCBiZXR3ZWVuIGZyYWcgbG9hZGluZyBhbmQgY2FsbCB0byB1cGRhdGVGcmFnUFRTRFRTKClcbiAgLy8gaWYgd2UgZG9uJ3QgdXBkYXRlIGZyYWcsIHdlIHdvbid0IGJlIGFibGUgdG8gcHJvcGFnYXRlIFBUUyBpbmZvIG9uIHRoZSBwbGF5bGlzdFxuICAvLyByZXN1bHRpbmcgaW4gaW52YWxpZCBzbGlkaW5nIGNvbXB1dGF0aW9uXG4gIGZyYWdtZW50c1tmcmFnSWR4XSA9IGZyYWc7XG4gIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0tMSB0byBmcmFnIDBcbiAgZm9yIChpID0gZnJhZ0lkeDsgaSA+IDA7IGktLSkge1xuICAgIHVwZGF0ZVBUUyhmcmFnbWVudHMsIGksIGkgLSAxKTtcbiAgfVxuXG4gIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0gdG8gbGFzdCBmcmFnXG4gIGZvciAoaSA9IGZyYWdJZHg7IGkgPCBmcmFnbWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdXBkYXRlUFRTKGZyYWdtZW50cywgaSwgaSArIDEpO1xuICB9XG5cbiAgZGV0YWlscy5QVFNLbm93biA9IHRydWU7XG4gIHJldHVybiBkcmlmdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGV0YWlscyAob2xkRGV0YWlscywgbmV3RGV0YWlscykge1xuICAvLyBwb3RlbnRpYWxseSByZXRyaWV2ZSBjYWNoZWQgaW5pdHNlZ21lbnRcbiAgaWYgKG5ld0RldGFpbHMuaW5pdFNlZ21lbnQgJiYgb2xkRGV0YWlscy5pbml0U2VnbWVudCkge1xuICAgIG5ld0RldGFpbHMuaW5pdFNlZ21lbnQgPSBvbGREZXRhaWxzLmluaXRTZWdtZW50O1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgb2xkL25ldyBwbGF5bGlzdHMgaGF2ZSBmcmFnbWVudHMgaW4gY29tbW9uXG4gIC8vIGxvb3AgdGhyb3VnaCBvdmVybGFwcGluZyBTTiBhbmQgdXBkYXRlIHN0YXJ0UFRTICwgY2MsIGFuZCBkdXJhdGlvbiBpZiBhbnkgZm91bmRcbiAgbGV0IGNjT2Zmc2V0ID0gMDtcbiAgbGV0IFBUU0ZyYWc7XG4gIG1hcEZyYWdtZW50SW50ZXJzZWN0aW9uKG9sZERldGFpbHMsIG5ld0RldGFpbHMsIChvbGRGcmFnLCBuZXdGcmFnKSA9PiB7XG4gICAgY2NPZmZzZXQgPSBvbGRGcmFnLmNjIC0gbmV3RnJhZy5jYztcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKG9sZEZyYWcuc3RhcnRQVFMpKSB7XG4gICAgICBuZXdGcmFnLnN0YXJ0ID0gbmV3RnJhZy5zdGFydFBUUyA9IG9sZEZyYWcuc3RhcnRQVFM7XG4gICAgICBuZXdGcmFnLmVuZFBUUyA9IG9sZEZyYWcuZW5kUFRTO1xuICAgICAgbmV3RnJhZy5kdXJhdGlvbiA9IG9sZEZyYWcuZHVyYXRpb247XG4gICAgICBuZXdGcmFnLmJhY2t0cmFja2VkID0gb2xkRnJhZy5iYWNrdHJhY2tlZDtcbiAgICAgIG5ld0ZyYWcuZHJvcHBlZCA9IG9sZEZyYWcuZHJvcHBlZDtcbiAgICAgIFBUU0ZyYWcgPSBuZXdGcmFnO1xuICAgIH1cbiAgICAvLyBQVFMgaXMga25vd24gd2hlbiB0aGVyZSBhcmUgb3ZlcmxhcHBpbmcgc2VnbWVudHNcbiAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gdHJ1ZTtcbiAgfSk7XG5cbiAgaWYgKCFuZXdEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNjT2Zmc2V0KSB7XG4gICAgbG9nZ2VyLmxvZygnZGlzY29udGludWl0eSBzbGlkaW5nIGZyb20gcGxheWxpc3QsIHRha2UgZHJpZnQgaW50byBhY2NvdW50Jyk7XG4gICAgY29uc3QgbmV3RnJhZ21lbnRzID0gbmV3RGV0YWlscy5mcmFnbWVudHM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdGcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld0ZyYWdtZW50c1tpXS5jYyArPSBjY09mZnNldDtcbiAgICB9XG4gIH1cblxuICAvLyBpZiBhdCBsZWFzdCBvbmUgZnJhZ21lbnQgY29udGFpbnMgUFRTIGluZm8sIHJlY29tcHV0ZSBQVFMgaW5mb3JtYXRpb24gZm9yIGFsbCBmcmFnbWVudHNcbiAgaWYgKFBUU0ZyYWcpIHtcbiAgICB1cGRhdGVGcmFnUFRTRFRTKG5ld0RldGFpbHMsIFBUU0ZyYWcsIFBUU0ZyYWcuc3RhcnRQVFMsIFBUU0ZyYWcuZW5kUFRTLCBQVFNGcmFnLnN0YXJ0RFRTLCBQVFNGcmFnLmVuZERUUyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZW5zdXJlIHRoYXQgZGVsdGEgaXMgd2l0aGluIG9sZEZyYWdtZW50cyByYW5nZVxuICAgIC8vIGFsc28gYWRqdXN0IHNsaWRpbmcgaW4gY2FzZSBkZWx0YSBpcyAwICh3ZSBjb3VsZCBoYXZlIG9sZD1bNTAtNjBdIGFuZCBuZXc9b2xkPVs1MC02MV0pXG4gICAgLy8gaW4gdGhhdCBjYXNlIHdlIGFsc28gbmVlZCB0byBhZGp1c3Qgc3RhcnQgb2Zmc2V0IG9mIGFsbCBmcmFnbWVudHNcbiAgICBhZGp1c3RTbGlkaW5nKG9sZERldGFpbHMsIG5ld0RldGFpbHMpO1xuICB9XG4gIC8vIGlmIHdlIGFyZSBoZXJlLCBpdCBtZWFucyB3ZSBoYXZlIGZyYWdtZW50cyBvdmVybGFwcGluZyBiZXR3ZWVuXG4gIC8vIG9sZCBhbmQgbmV3IGxldmVsLiByZWxpYWJsZSBQVFMgaW5mbyBpcyB0aHVzIHJlbHlpbmcgb24gb2xkIGxldmVsXG4gIG5ld0RldGFpbHMuUFRTS25vd24gPSBvbGREZXRhaWxzLlBUU0tub3duO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VTdWJ0aXRsZVBsYXlsaXN0cyAob2xkUGxheWxpc3QsIG5ld1BsYXlsaXN0LCByZWZlcmVuY2VTdGFydCA9IDApIHtcbiAgbGV0IGxhc3RJbmRleCA9IC0xO1xuICBtYXBGcmFnbWVudEludGVyc2VjdGlvbihvbGRQbGF5bGlzdCwgbmV3UGxheWxpc3QsIChvbGRGcmFnLCBuZXdGcmFnLCBpbmRleCkgPT4ge1xuICAgIG5ld0ZyYWcuc3RhcnQgPSBvbGRGcmFnLnN0YXJ0O1xuICAgIGxhc3RJbmRleCA9IGluZGV4O1xuICB9KTtcblxuICBjb25zdCBmcmFncyA9IG5ld1BsYXlsaXN0LmZyYWdtZW50cztcbiAgaWYgKGxhc3RJbmRleCA8IDApIHtcbiAgICBmcmFncy5mb3JFYWNoKGZyYWcgPT4ge1xuICAgICAgZnJhZy5zdGFydCArPSByZWZlcmVuY2VTdGFydDtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGxldCBpID0gbGFzdEluZGV4ICsgMTsgaSA8IGZyYWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgZnJhZ3NbaV0uc3RhcnQgPSAoZnJhZ3NbaSAtIDFdLnN0YXJ0ICsgZnJhZ3NbaSAtIDFdLmR1cmF0aW9uKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwRnJhZ21lbnRJbnRlcnNlY3Rpb24gKG9sZFBsYXlsaXN0LCBuZXdQbGF5bGlzdCwgaW50ZXJzZWN0aW9uRm4pIHtcbiAgaWYgKCFvbGRQbGF5bGlzdCB8fCAhbmV3UGxheWxpc3QpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KG9sZFBsYXlsaXN0LnN0YXJ0U04sIG5ld1BsYXlsaXN0LnN0YXJ0U04pIC0gbmV3UGxheWxpc3Quc3RhcnRTTjtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4ob2xkUGxheWxpc3QuZW5kU04sIG5ld1BsYXlsaXN0LmVuZFNOKSAtIG5ld1BsYXlsaXN0LnN0YXJ0U047XG4gIGNvbnN0IGRlbHRhID0gbmV3UGxheWxpc3Quc3RhcnRTTiAtIG9sZFBsYXlsaXN0LnN0YXJ0U047XG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgY29uc3Qgb2xkRnJhZyA9IG9sZFBsYXlsaXN0LmZyYWdtZW50c1tkZWx0YSArIGldO1xuICAgIGNvbnN0IG5ld0ZyYWcgPSBuZXdQbGF5bGlzdC5mcmFnbWVudHNbaV07XG4gICAgaWYgKCFvbGRGcmFnIHx8ICFuZXdGcmFnKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW50ZXJzZWN0aW9uRm4ob2xkRnJhZywgbmV3RnJhZywgaSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkanVzdFNsaWRpbmcgKG9sZFBsYXlsaXN0LCBuZXdQbGF5bGlzdCkge1xuICBjb25zdCBkZWx0YSA9IG5ld1BsYXlsaXN0LnN0YXJ0U04gLSBvbGRQbGF5bGlzdC5zdGFydFNOO1xuICBjb25zdCBvbGRGcmFnbWVudHMgPSBvbGRQbGF5bGlzdC5mcmFnbWVudHM7XG4gIGNvbnN0IG5ld0ZyYWdtZW50cyA9IG5ld1BsYXlsaXN0LmZyYWdtZW50cztcblxuICBpZiAoZGVsdGEgPCAwIHx8IGRlbHRhID4gb2xkRnJhZ21lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0ZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIG5ld0ZyYWdtZW50c1tpXS5zdGFydCArPSBvbGRGcmFnbWVudHNbZGVsdGFdLnN0YXJ0O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlUmVsb2FkSW50ZXJ2YWwgKGN1cnJlbnRQbGF5bGlzdCwgbmV3UGxheWxpc3QsIGxhc3RSZXF1ZXN0VGltZSkge1xuICBsZXQgcmVsb2FkSW50ZXJ2YWwgPSAxMDAwICogKG5ld1BsYXlsaXN0LmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA/IG5ld1BsYXlsaXN0LmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA6IG5ld1BsYXlsaXN0LnRhcmdldGR1cmF0aW9uKTtcbiAgY29uc3QgbWluUmVsb2FkSW50ZXJ2YWwgPSByZWxvYWRJbnRlcnZhbCAvIDI7XG4gIGlmIChjdXJyZW50UGxheWxpc3QgJiYgbmV3UGxheWxpc3QuZW5kU04gPT09IGN1cnJlbnRQbGF5bGlzdC5lbmRTTikge1xuICAgIC8vIGZvbGxvdyBITFMgU3BlYywgSWYgdGhlIGNsaWVudCByZWxvYWRzIGEgUGxheWxpc3QgZmlsZSBhbmQgZmluZHMgdGhhdCBpdCBoYXMgbm90XG4gICAgLy8gY2hhbmdlZCB0aGVuIGl0IE1VU1Qgd2FpdCBmb3IgYSBwZXJpb2Qgb2Ygb25lLWhhbGYgdGhlIHRhcmdldFxuICAgIC8vIGR1cmF0aW9uIGJlZm9yZSByZXRyeWluZy5cbiAgICByZWxvYWRJbnRlcnZhbCA9IG1pblJlbG9hZEludGVydmFsO1xuICB9XG5cbiAgaWYgKGxhc3RSZXF1ZXN0VGltZSkge1xuICAgIHJlbG9hZEludGVydmFsID0gTWF0aC5tYXgobWluUmVsb2FkSW50ZXJ2YWwsIHJlbG9hZEludGVydmFsIC0gKHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSAtIGxhc3RSZXF1ZXN0VGltZSkpO1xuICB9XG4gIC8vIGluIGFueSBjYXNlLCBkb24ndCByZWxvYWQgbW9yZSB0aGFuIGhhbGYgb2YgdGFyZ2V0IGR1cmF0aW9uXG4gIHJldHVybiBNYXRoLnJvdW5kKHJlbG9hZEludGVydmFsKTtcbn1cbiIsIi8qXG4gKiBTdHJlYW0gQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEJpbmFyeVNlYXJjaCBmcm9tICcuLi91dGlscy9iaW5hcnktc2VhcmNoJztcbmltcG9ydCB7IEJ1ZmZlckhlbHBlciB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IERlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvZGVtdXhlcic7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IEZyYWdtZW50U3RhdGUgfSBmcm9tICcuL2ZyYWdtZW50LXRyYWNrZXInO1xuaW1wb3J0IEZyYWdtZW50IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgUGxheWxpc3RMb2FkZXIgZnJvbSAnLi4vbG9hZGVyL3BsYXlsaXN0LWxvYWRlcic7XG5pbXBvcnQgKiBhcyBMZXZlbEhlbHBlciBmcm9tICcuL2xldmVsLWhlbHBlcic7XG5pbXBvcnQgVGltZVJhbmdlcyBmcm9tICcuLi91dGlscy90aW1lLXJhbmdlcyc7XG5pbXBvcnQgeyBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IGFsaWduU3RyZWFtIH0gZnJvbSAnLi4vdXRpbHMvZGlzY29udGludWl0aWVzJztcbmltcG9ydCB7IGZpbmRGcmFnbWVudEJ5UERULCBmaW5kRnJhZ21lbnRCeVBUUyB9IGZyb20gJy4vZnJhZ21lbnQtZmluZGVycyc7XG5pbXBvcnQgR2FwQ29udHJvbGxlciBmcm9tICcuL2dhcC1jb250cm9sbGVyJztcbmltcG9ydCBCYXNlU3RyZWFtQ29udHJvbGxlciwgeyBTdGF0ZSB9IGZyb20gJy4vYmFzZS1zdHJlYW0tY29udHJvbGxlcic7XG5cbmNvbnN0IFRJQ0tfSU5URVJWQUwgPSAxMDA7IC8vIGhvdyBvZnRlbiB0byB0aWNrIGluIG1zXG5cbmNsYXNzIFN0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlU3RyZWFtQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMsIGZyYWdtZW50VHJhY2tlcikge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSEVELFxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX1BBUlNFRCxcbiAgICAgIEV2ZW50LkxFVkVMX0xPQURFRCxcbiAgICAgIEV2ZW50LktFWV9MT0FERUQsXG4gICAgICBFdmVudC5GUkFHX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfREFUQSxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0VELFxuICAgICAgRXZlbnQuRVJST1IsXG4gICAgICBFdmVudC5BVURJT19UUkFDS19TV0lUQ0hJTkcsXG4gICAgICBFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9DUkVBVEVELFxuICAgICAgRXZlbnQuQlVGRkVSX0FQUEVOREVELFxuICAgICAgRXZlbnQuQlVGRkVSX0ZMVVNIRUQpO1xuXG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSBmYWxzZTtcbiAgICB0aGlzLl9zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5nYXBDb250cm9sbGVyID0gbnVsbDtcbiAgfVxuXG4gIHN0YXJ0TG9hZCAoc3RhcnRQb3NpdGlvbikge1xuICAgIGlmICh0aGlzLmxldmVscykge1xuICAgICAgbGV0IGxhc3RDdXJyZW50VGltZSA9IHRoaXMubGFzdEN1cnJlbnRUaW1lLCBobHMgPSB0aGlzLmhscztcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgICB0aGlzLmxldmVsID0gLTE7XG4gICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgICAvLyBkZXRlcm1pbmUgbG9hZCBsZXZlbFxuICAgICAgICBsZXQgc3RhcnRMZXZlbCA9IGhscy5zdGFydExldmVsO1xuICAgICAgICBpZiAoc3RhcnRMZXZlbCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyAtMSA6IGd1ZXNzIHN0YXJ0IExldmVsIGJ5IGRvaW5nIGEgYml0cmF0ZSB0ZXN0IGJ5IGxvYWRpbmcgZmlyc3QgZnJhZ21lbnQgb2YgbG93ZXN0IHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgICBzdGFydExldmVsID0gMDtcbiAgICAgICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgbmV3IGxldmVsIHRvIHBsYXlsaXN0IGxvYWRlciA6IHRoaXMgd2lsbCB0cmlnZ2VyIHN0YXJ0IGxldmVsIGxvYWRcbiAgICAgICAgLy8gaGxzLm5leHRMb2FkTGV2ZWwgcmVtYWlucyB1bnRpbCBpdCBpcyBzZXQgdG8gYSBuZXcgdmFsdWUgb3IgdW50aWwgYSBuZXcgZnJhZyBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkXG4gICAgICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IHN0YXJ0TGV2ZWw7XG4gICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHN0YXJ0UG9zaXRpb24gdW5kZWZpbmVkIGJ1dCBsYXN0Q3VycmVudFRpbWUgc2V0LCBzZXQgc3RhcnRQb3NpdGlvbiB0byBsYXN0IGN1cnJlbnRUaW1lXG4gICAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICBsb2dnZXIubG9nKGBvdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAke2xhc3RDdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gbGFzdEN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb3JjZVN0YXJ0TG9hZCA9IHRydWU7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB9XG4gIH1cblxuICBzdG9wTG9hZCAoKSB7XG4gICAgdGhpcy5mb3JjZVN0YXJ0TG9hZCA9IGZhbHNlO1xuICAgIHN1cGVyLnN0b3BMb2FkKCk7XG4gIH1cblxuICBkb1RpY2sgKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgIGNhc2UgU3RhdGUuQlVGRkVSX0ZMVVNISU5HOlxuICAgICAgLy8gaW4gYnVmZmVyIGZsdXNoaW5nIHN0YXRlLCByZXNldCBmcmFnTG9hZEVycm9yIGNvdW50ZXJcbiAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFN0YXRlLklETEU6XG4gICAgICB0aGlzLl9kb1RpY2tJZGxlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFN0YXRlLldBSVRJTkdfTEVWRUw6XG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXTtcbiAgICAgIC8vIGNoZWNrIGlmIHBsYXlsaXN0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICBpZiAobGV2ZWwgJiYgbGV2ZWwuZGV0YWlscykge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgIHZhciBub3cgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB2YXIgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7XG4gICAgICAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgaWYgKCFyZXRyeURhdGUgfHwgKG5vdyA+PSByZXRyeURhdGUpIHx8ICh0aGlzLm1lZGlhICYmIHRoaXMubWVkaWEuc2Vla2luZykpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnbWVkaWFDb250cm9sbGVyOiByZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZScpO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU3RhdGUuRVJST1I6XG4gICAgY2FzZSBTdGF0ZS5TVE9QUEVEOlxuICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HOlxuICAgIGNhc2UgU3RhdGUuUEFSU0lORzpcbiAgICBjYXNlIFN0YXRlLlBBUlNFRDpcbiAgICBjYXNlIFN0YXRlLkVOREVEOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBjaGVjayBidWZmZXJcbiAgICB0aGlzLl9jaGVja0J1ZmZlcigpO1xuICAgIC8vIGNoZWNrL3VwZGF0ZSBjdXJyZW50IGZyYWdtZW50XG4gICAgdGhpcy5fY2hlY2tGcmFnbWVudENoYW5nZWQoKTtcbiAgfVxuXG4gIC8vIElyb25pY2FsbHkgdGhlIFwiaWRsZVwiIHN0YXRlIGlzIHRoZSBvbiB3ZSBkbyB0aGUgbW9zdCBsb2dpYyBpbiBpdCBzZWVtcyAuLi4uXG4gIC8vIE5PVEU6IE1heWJlIHdlIGNvdWxkIHJhdGhlciBzY2hlZHVsZSBhIGNoZWNrIGZvciBidWZmZXIgbGVuZ3RoIGFmdGVyIGhhbGYgb2YgdGhlIGN1cnJlbnRseVxuICAvLyAgICAgICBwbGF5ZWQgc2VnbWVudCwgb3Igb24gcGF1c2UvcGxheS9zZWVrIGluc3RlYWQgb2YgbmFpdmVseSBjaGVja2luZyBldmVyeSAxMDBtcz9cbiAgX2RvVGlja0lkbGUgKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzLFxuICAgICAgY29uZmlnID0gaGxzLmNvbmZpZyxcbiAgICAgIG1lZGlhID0gdGhpcy5tZWRpYTtcblxuICAgIC8vIGlmIHN0YXJ0IGxldmVsIG5vdCBwYXJzZWQgeWV0IE9SXG4gICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORCBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIGRpc2FibGVcbiAgICAvLyBleGl0IGxvb3AsIGFzIHdlIGVpdGhlciBuZWVkIG1vcmUgaW5mbyAobGV2ZWwgbm90IHBhcnNlZCkgb3Igd2UgbmVlZCBtZWRpYSB0byBiZSBhdHRhY2hlZCB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgIGlmICh0aGlzLmxldmVsTGFzdExvYWRlZCA9PT0gdW5kZWZpbmVkIHx8IChcbiAgICAgICFtZWRpYSAmJiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxuICAgIGxldCBwb3M7XG4gICAgaWYgKHRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHBvcyA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSB0aGlzLm5leHRMb2FkUG9zaXRpb247XG4gICAgfVxuXG4gICAgLy8gZGV0ZXJtaW5lIG5leHQgbG9hZCBsZXZlbFxuICAgIGxldCBsZXZlbCA9IGhscy5uZXh0TG9hZExldmVsLFxuICAgICAgbGV2ZWxJbmZvID0gdGhpcy5sZXZlbHNbbGV2ZWxdO1xuXG4gICAgaWYgKCFsZXZlbEluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgbGV2ZWxCaXRyYXRlID0gbGV2ZWxJbmZvLmJpdHJhdGUsXG4gICAgICBtYXhCdWZMZW47XG5cbiAgICAvLyBjb21wdXRlIG1heCBCdWZmZXIgTGVuZ3RoIHRoYXQgd2UgY291bGQgZ2V0IGZyb20gdGhpcyBsb2FkIGxldmVsLCBiYXNlZCBvbiBsZXZlbCBiaXRyYXRlLiBkb24ndCBidWZmZXIgbW9yZSB0aGFuIDYwIE1CIGFuZCBtb3JlIHRoYW4gMzBzXG4gICAgaWYgKGxldmVsQml0cmF0ZSkge1xuICAgICAgbWF4QnVmTGVuID0gTWF0aC5tYXgoOCAqIGNvbmZpZy5tYXhCdWZmZXJTaXplIC8gbGV2ZWxCaXRyYXRlLCBjb25maWcubWF4QnVmZmVyTGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4QnVmTGVuID0gY29uZmlnLm1heEJ1ZmZlckxlbmd0aDtcbiAgICB9XG5cbiAgICBtYXhCdWZMZW4gPSBNYXRoLm1pbihtYXhCdWZMZW4sIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgpO1xuXG4gICAgLy8gZGV0ZXJtaW5lIG5leHQgY2FuZGlkYXRlIGZyYWdtZW50IHRvIGJlIGxvYWRlZCwgYmFzZWQgb24gY3VycmVudCBwb3NpdGlvbiBhbmQgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgIC8vIGVuc3VyZSB1cCB0byBgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aGAgb2YgYnVmZmVyIHVwZnJvbnRcblxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IG1lZGlhLCBwb3MsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKSxcbiAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuO1xuICAgIC8vIFN0YXkgaWRsZSBpZiB3ZSBhcmUgc3RpbGwgd2l0aCBidWZmZXIgbWFyZ2luc1xuICAgIGlmIChidWZmZXJMZW4gPj0gbWF4QnVmTGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuIHRyeSB0byBsb2FkIGEgbmV3IGZyYWdtZW50IC4uLlxuICAgIGxvZ2dlci50cmFjZShgYnVmZmVyIGxlbmd0aCBvZiAke2J1ZmZlckxlbi50b0ZpeGVkKDMpfSBpcyBiZWxvdyBtYXggb2YgJHttYXhCdWZMZW4udG9GaXhlZCgzKX0uIGNoZWNraW5nIGZvciBtb3JlIHBheWxvYWQgLi4uYCk7XG5cbiAgICAvLyBzZXQgbmV4dCBsb2FkIGxldmVsIDogdGhpcyB3aWxsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkIGlmIG5lZWRlZFxuICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IGxldmVsO1xuXG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgLy8gaWYgbGV2ZWwgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciBsZXZlbCByZXRyaWV2YWxcbiAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBlbnN1cmUgdGhhdCBuZXcgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIHRvIGF2b2lkIGxvYWRpbmcvdHJ5IHRvIGxvYWRcbiAgICAvLyBhIHVzZWxlc3MgYW5kIG91dGRhdGVkIGZyYWdtZW50ICh0aGF0IG1pZ2h0IGV2ZW4gaW50cm9kdWNlIGxvYWQgZXJyb3IgaWYgaXQgaXMgYWxyZWFkeSBvdXQgb2YgdGhlIGxpdmUgcGxheWxpc3QpXG4gICAgaWYgKCFsZXZlbERldGFpbHMgfHwgKGxldmVsRGV0YWlscy5saXZlICYmIHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBsZXZlbCkpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0xFVkVMO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpKSB7XG4gICAgICBjb25zdCBkYXRhID0ge307XG4gICAgICBpZiAodGhpcy5hbHRBdWRpbykge1xuICAgICAgICBkYXRhLnR5cGUgPSAndmlkZW8nO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9FT1MsIGRhdGEpO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVOREVEO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBoYXZlIHRoZSBsZXZlbERldGFpbHMgZm9yIHRoZSBzZWxlY3RlZCB2YXJpYW50LCBsZXRzIGNvbnRpbnVlIGVucmljaGVuIG91ciBzdHJlYW0gKGxvYWQga2V5cy9mcmFnbWVudHMgb3IgdHJpZ2dlciBFT1MsIGV0Yy4uKVxuICAgIHRoaXMuX2ZldGNoUGF5bG9hZE9yRW9zKHBvcywgYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzKTtcbiAgfVxuXG4gIF9mZXRjaFBheWxvYWRPckVvcyAocG9zLCBidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpIHtcbiAgICBjb25zdCBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cyxcbiAgICAgIGxldmVsID0gdGhpcy5sZXZlbCxcbiAgICAgIGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHMsXG4gICAgICBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcblxuICAgIC8vIGVtcHR5IHBsYXlsaXN0XG4gICAgaWYgKGZyYWdMZW4gPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBmaW5kIGZyYWdtZW50IGluZGV4LCBjb250aWd1b3VzIHdpdGggZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgIGxldCBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydCxcbiAgICAgIGVuZCA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uc3RhcnQgKyBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdLmR1cmF0aW9uLFxuICAgICAgYnVmZmVyRW5kID0gYnVmZmVySW5mby5lbmQsXG4gICAgICBmcmFnO1xuXG4gICAgaWYgKGxldmVsRGV0YWlscy5pbml0U2VnbWVudCAmJiAhbGV2ZWxEZXRhaWxzLmluaXRTZWdtZW50LmRhdGEpIHtcbiAgICAgIGZyYWcgPSBsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluIGNhc2Ugb2YgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHJlcXVlc3RlZCBwb3NpdGlvbiBpcyBub3QgbG9jYXRlZCBiZWZvcmUgcGxheWxpc3Qgc3RhcnRcbiAgICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgICBsZXQgaW5pdGlhbExpdmVNYW5pZmVzdFNpemUgPSB0aGlzLmNvbmZpZy5pbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTtcbiAgICAgICAgaWYgKGZyYWdMZW4gPCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBDYW4gbm90IHN0YXJ0IHBsYXliYWNrIG9mIGEgbGV2ZWwsIHJlYXNvbjogbm90IGVub3VnaCBmcmFnbWVudHMgJHtmcmFnTGVufSA8ICR7aW5pdGlhbExpdmVNYW5pZmVzdFNpemV9YCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhZyA9IHRoaXMuX2Vuc3VyZUZyYWdtZW50QXRMaXZlUG9pbnQobGV2ZWxEZXRhaWxzLCBidWZmZXJFbmQsIHN0YXJ0LCBlbmQsIGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBmcmFnTGVuKTtcbiAgICAgICAgLy8gaWYgaXQgZXhwbGljaXRlbHkgcmV0dXJucyBudWxsIGRvbid0IGxvYWQgYW55IGZyYWdtZW50IGFuZCBleGl0IGZ1bmN0aW9uIG5vd1xuICAgICAgICBpZiAoZnJhZyA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVm9EIHBsYXlsaXN0OiBpZiBidWZmZXJFbmQgYmVmb3JlIHN0YXJ0IG9mIHBsYXlsaXN0LCBsb2FkIGZpcnN0IGZyYWdtZW50XG4gICAgICAgIGlmIChidWZmZXJFbmQgPCBzdGFydCkge1xuICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICBmcmFnID0gdGhpcy5fZmluZEZyYWdtZW50KHN0YXJ0LCBmcmFnUHJldmlvdXMsIGZyYWdMZW4sIGZyYWdtZW50cywgYnVmZmVyRW5kLCBlbmQsIGxldmVsRGV0YWlscyk7XG4gICAgfVxuXG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIGlmIChmcmFnLmVuY3J5cHRlZCkge1xuICAgICAgICBsb2dnZXIubG9nKGBMb2FkaW5nIGtleSBmb3IgJHtmcmFnLnNufSBvZiBbJHtsZXZlbERldGFpbHMuc3RhcnRTTn0gLCR7bGV2ZWxEZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtsZXZlbH1gKTtcbiAgICAgICAgdGhpcy5fbG9hZEtleShmcmFnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5sb2coYExvYWRpbmcgJHtmcmFnLnNufSBvZiBbJHtsZXZlbERldGFpbHMuc3RhcnRTTn0gLCR7bGV2ZWxEZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtsZXZlbH0sIGN1cnJlbnRUaW1lOiR7cG9zLnRvRml4ZWQoMyl9LGJ1ZmZlckVuZDoke2J1ZmZlckVuZC50b0ZpeGVkKDMpfWApO1xuICAgICAgICB0aGlzLl9sb2FkRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2Vuc3VyZUZyYWdtZW50QXRMaXZlUG9pbnQgKGxldmVsRGV0YWlscywgYnVmZmVyRW5kLCBzdGFydCwgZW5kLCBmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgZnJhZ0xlbikge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZywgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgbGV0IGZyYWc7XG5cbiAgICAvLyBjaGVjayBpZiByZXF1ZXN0ZWQgcG9zaXRpb24gaXMgd2l0aGluIHNlZWthYmxlIGJvdW5kYXJpZXMgOlxuICAgIC8vIGxvZ2dlci5sb2coYHN0YXJ0L3Bvcy9idWZFbmQvc2Vla2luZzoke3N0YXJ0LnRvRml4ZWQoMyl9LyR7cG9zLnRvRml4ZWQoMyl9LyR7YnVmZmVyRW5kLnRvRml4ZWQoMyl9LyR7dGhpcy5tZWRpYS5zZWVraW5nfWApO1xuICAgIGxldCBtYXhMYXRlbmN5ID0gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDogY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcblxuICAgIGlmIChidWZmZXJFbmQgPCBNYXRoLm1heChzdGFydCAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBlbmQgLSBtYXhMYXRlbmN5KSkge1xuICAgICAgbGV0IGxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVMaXZlUG9zaXRpb24oc3RhcnQsIGxldmVsRGV0YWlscyk7XG4gICAgICBsb2dnZXIubG9nKGBidWZmZXIgZW5kOiAke2J1ZmZlckVuZC50b0ZpeGVkKDMpfSBpcyBsb2NhdGVkIHRvbyBmYXIgZnJvbSB0aGUgZW5kIG9mIGxpdmUgc2xpZGluZyBwbGF5bGlzdCwgcmVzZXQgY3VycmVudFRpbWUgdG8gOiAke2xpdmVTeW5jUG9zaXRpb24udG9GaXhlZCgzKX1gKTtcbiAgICAgIGJ1ZmZlckVuZCA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICBpZiAobWVkaWEgJiYgbWVkaWEucmVhZHlTdGF0ZSAmJiBtZWRpYS5kdXJhdGlvbiA+IGxpdmVTeW5jUG9zaXRpb24pIHtcbiAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgIH1cblxuICAgIC8vIGlmIGVuZCBvZiBidWZmZXIgZ3JlYXRlciB0aGFuIGxpdmUgZWRnZSwgZG9uJ3QgbG9hZCBhbnkgZnJhZ21lbnRcbiAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiBpZiBsaXZlIHBsYXlsaXN0IGludGVybWl0dGVudGx5IHNsaWRlcyBpbiB0aGUgcGFzdC5cbiAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTYxLDE4MjU4MDE2N11cbiAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTYyLDE4MjU4MDE2OV1cbiAgICAvLyBMb2FkaW5nIDE4MjU4MDE2OCBvZiBbMTgyNTgwMTYyICwxODI1ODAxNjldLGxldmVsIDEgLi5cbiAgICAvLyBMb2FkaW5nIDE4MjU4MDE2OSBvZiBbMTgyNTgwMTYyICwxODI1ODAxNjldLGxldmVsIDEgLi5cbiAgICAvLyBsZXZlbCAxIGxvYWRlZCBbMTgyNTgwMTYyLDE4MjU4MDE2OF0gPD09PT09PT09PT09PT0gaGVyZSB3ZSBzaG91bGQgaGF2ZSBidWZmZXJFbmQgPiBlbmQuIGluIHRoYXQgY2FzZSBicmVhayB0byBhdm9pZCByZWxvYWRpbmcgMTgyNTgwMTY4XG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2NCwxODI1ODAxNzFdXG4gICAgLy9cbiAgICAvLyBkb24ndCByZXR1cm4gbnVsbCBpbiBjYXNlIG1lZGlhIG5vdCBsb2FkZWQgeWV0IChyZWFkeXN0YXRlID09PSAwKVxuICAgIGlmIChsZXZlbERldGFpbHMuUFRTS25vd24gJiYgYnVmZmVyRW5kID4gZW5kICYmIG1lZGlhICYmIG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiAhbGV2ZWxEZXRhaWxzLlBUU0tub3duKSB7XG4gICAgICAvKiB3ZSBhcmUgc3dpdGNoaW5nIGxldmVsIG9uIGxpdmUgcGxheWxpc3QsIGJ1dCB3ZSBkb24ndCBoYXZlIGFueSBQVFMgaW5mbyBmb3IgdGhhdCBxdWFsaXR5IGxldmVsIC4uLlxuICAgICAgICAgdHJ5IHRvIGxvYWQgZnJhZyBtYXRjaGluZyB3aXRoIG5leHQgU04uXG4gICAgICAgICBldmVuIGlmIFNOIGFyZSBub3Qgc3luY2hyb25pemVkIGJldHdlZW4gcGxheWxpc3RzLCBsb2FkaW5nIHRoaXMgZnJhZyB3aWxsIGhlbHAgdXNcbiAgICAgICAgIGNvbXB1dGUgcGxheWxpc3Qgc2xpZGluZyBhbmQgZmluZCB0aGUgcmlnaHQgb25lIGFmdGVyIGluIGNhc2UgaXQgd2FzIG5vdCB0aGUgcmlnaHQgY29uc2VjdXRpdmUgb25lICovXG4gICAgICBpZiAoZnJhZ1ByZXZpb3VzKSB7XG4gICAgICAgIGlmIChsZXZlbERldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgICAgLy8gUmVsaWVzIG9uIFBEVCBpbiBvcmRlciB0byBzd2l0Y2ggYml0cmF0ZXMgKFN1cHBvcnQgRVhULVgtRElTQ09OVElOVUlUWSB3aXRob3V0IEVYVC1YLURJU0NPTlRJTlVJVFktU0VRVUVOQ0UpXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBzYW1lIFBEVDogJHtmcmFnUHJldmlvdXMucHJvZ3JhbURhdGVUaW1lfWApO1xuICAgICAgICAgIGZyYWcgPSBmaW5kRnJhZ21lbnRCeVBEVChmcmFnbWVudHMsIGZyYWdQcmV2aW91cy5lbmRQcm9ncmFtRGF0ZVRpbWUsIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBVc2VzIGJ1ZmZlciBhbmQgc2VxdWVuY2UgbnVtYmVyIHRvIGNhbGN1bGF0ZSBzd2l0Y2ggc2VnbWVudCAocmVxdWlyZWQgaWYgdXNpbmcgRVhULVgtRElTQ09OVElOVUlUWS1TRVFVRU5DRSlcbiAgICAgICAgICBjb25zdCB0YXJnZXRTTiA9IGZyYWdQcmV2aW91cy5zbiArIDE7XG4gICAgICAgICAgaWYgKHRhcmdldFNOID49IGxldmVsRGV0YWlscy5zdGFydFNOICYmIHRhcmdldFNOIDw9IGxldmVsRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgICAgY29uc3QgZnJhZ05leHQgPSBmcmFnbWVudHNbdGFyZ2V0U04gLSBsZXZlbERldGFpbHMuc3RhcnRTTl07XG4gICAgICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzLmNjID09PSBmcmFnTmV4dC5jYykge1xuICAgICAgICAgICAgICBmcmFnID0gZnJhZ05leHQ7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYGxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggbmV4dCBTTjogJHtmcmFnLnNufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBuZXh0IGZyYWcgU04gbm90IGF2YWlsYWJsZSAob3Igbm90IHdpdGggc2FtZSBjb250aW51aXR5IGNvdW50ZXIpXG4gICAgICAgICAgLy8gbG9vayBmb3IgYSBmcmFnIHNoYXJpbmcgdGhlIHNhbWUgQ0NcbiAgICAgICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgICAgIGZyYWcgPSBCaW5hcnlTZWFyY2guc2VhcmNoKGZyYWdtZW50cywgZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZyYWdQcmV2aW91cy5jYyAtIGZyYWcuY2M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYGxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggc2FtZSBDQzogJHtmcmFnLnNufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIC8qIHdlIGhhdmUgbm8gaWRlYSBhYm91dCB3aGljaCBmcmFnbWVudCBzaG91bGQgYmUgbG9hZGVkLlxuICAgICAgICAgICBzbyBsZXQncyBsb2FkIG1pZCBmcmFnbWVudC4gaXQgd2lsbCBoZWxwIGNvbXB1dGluZyBwbGF5bGlzdCBzbGlkaW5nIGFuZCBmaW5kIHRoZSByaWdodCBvbmVcbiAgICAgICAgKi9cbiAgICAgICAgZnJhZyA9IGZyYWdtZW50c1tNYXRoLm1pbihmcmFnTGVuIC0gMSwgTWF0aC5yb3VuZChmcmFnTGVuIC8gMikpXTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCB1bmtub3duLCBsb2FkIG1pZGRsZSBmcmFnIDogJHtmcmFnLnNufWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmcmFnO1xuICB9XG5cbiAgX2ZpbmRGcmFnbWVudCAoc3RhcnQsIGZyYWdQcmV2aW91cywgZnJhZ0xlbiwgZnJhZ21lbnRzLCBidWZmZXJFbmQsIGVuZCwgbGV2ZWxEZXRhaWxzKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGxldCBmcmFnO1xuXG4gICAgaWYgKGJ1ZmZlckVuZCA8IGVuZCkge1xuICAgICAgY29uc3QgbG9va3VwVG9sZXJhbmNlID0gKGJ1ZmZlckVuZCA+IGVuZCAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKSA/IDAgOiBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICAgIC8vIFJlbW92ZSB0aGUgdG9sZXJhbmNlIGlmIGl0IHdvdWxkIHB1dCB0aGUgYnVmZmVyRW5kIHBhc3QgdGhlIGFjdHVhbCBlbmQgb2Ygc3RyZWFtXG4gICAgICAvLyBVc2VzIGJ1ZmZlciBhbmQgc2VxdWVuY2UgbnVtYmVyIHRvIGNhbGN1bGF0ZSBzd2l0Y2ggc2VnbWVudCAocmVxdWlyZWQgaWYgdXNpbmcgRVhULVgtRElTQ09OVElOVUlUWS1TRVFVRU5DRSlcbiAgICAgIGZyYWcgPSBmaW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgYnVmZmVyRW5kLCBsb29rdXBUb2xlcmFuY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWFjaCBlbmQgb2YgcGxheWxpc3RcbiAgICAgIGZyYWcgPSBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdO1xuICAgIH1cbiAgICBpZiAoZnJhZykge1xuICAgICAgY29uc3QgY3VyU05JZHggPSBmcmFnLnNuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICBjb25zdCBzYW1lTGV2ZWwgPSBmcmFnUHJldmlvdXMgJiYgZnJhZy5sZXZlbHMgPT09IGZyYWdQcmV2aW91cy5sZXZlbHM7XG4gICAgICBjb25zdCBwcmV2RnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCAtIDFdO1xuICAgICAgY29uc3QgbmV4dEZyYWcgPSBmcmFnbWVudHNbY3VyU05JZHggKyAxXTtcbiAgICAgIC8vIGxvZ2dlci5sb2coJ2ZpbmQgU04gbWF0Y2hpbmcgd2l0aCBwb3M6JyArICBidWZmZXJFbmQgKyAnOicgKyBmcmFnLnNuKTtcbiAgICAgIGlmIChmcmFnUHJldmlvdXMgJiYgZnJhZy5zbiA9PT0gZnJhZ1ByZXZpb3VzLnNuKSB7XG4gICAgICAgIGlmIChzYW1lTGV2ZWwgJiYgIWZyYWcuYmFja3RyYWNrZWQpIHtcbiAgICAgICAgICBpZiAoZnJhZy5zbiA8IGxldmVsRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgICAgbGV0IGRlbHRhUFRTID0gZnJhZ1ByZXZpb3VzLmRlbHRhUFRTO1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBzaWduaWZpY2FudCBkZWx0YSBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbywgbGFyZ2VyIHRoYW4gbWF4IGFsbG93ZWQgaG9sZSxcbiAgICAgICAgICAgIC8vIGFuZCBpZiBwcmV2aW91cyByZW11eGVkIGZyYWdtZW50IGRpZCBub3Qgc3RhcnQgd2l0aCBhIGtleWZyYW1lLiAoZnJhZ1ByZXZpb3VzLmRyb3BwZWQpXG4gICAgICAgICAgICAvLyBsZXQncyB0cnkgdG8gbG9hZCBwcmV2aW91cyBmcmFnbWVudCBhZ2FpbiB0byBnZXQgbGFzdCBrZXlmcmFtZVxuICAgICAgICAgICAgLy8gdGhlbiB3ZSB3aWxsIHJlbG9hZCBhZ2FpbiBjdXJyZW50IGZyYWdtZW50ICh0aGF0IHdheSB3ZSBzaG91bGQgYmUgYWJsZSB0byBmaWxsIHRoZSBidWZmZXIgaG9sZSAuLi4pXG4gICAgICAgICAgICBpZiAoZGVsdGFQVFMgJiYgZGVsdGFQVFMgPiBjb25maWcubWF4QnVmZmVySG9sZSAmJiBmcmFnUHJldmlvdXMuZHJvcHBlZCAmJiBjdXJTTklkeCkge1xuICAgICAgICAgICAgICBmcmFnID0gcHJldkZyYWc7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdTTiBqdXN0IGxvYWRlZCwgd2l0aCBsYXJnZSBQVFMgZ2FwIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCBtYXliZSBmcmFnIGlzIG5vdCBzdGFydGluZyB3aXRoIGEga2V5ZnJhbWUgPyBsb2FkIHByZXZpb3VzIG9uZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpcycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnJhZyA9IG5leHRGcmFnO1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBTTiBqdXN0IGxvYWRlZCwgbG9hZCBuZXh0IG9uZTogJHtmcmFnLnNufWAsIGZyYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZnJhZy5iYWNrdHJhY2tlZCkge1xuICAgICAgICAgIC8vIE9ubHkgYmFja3RyYWNrIGEgbWF4IG9mIDEgY29uc2VjdXRpdmUgZnJhZ21lbnQgdG8gcHJldmVudCBzbGlkaW5nIGJhY2sgdG9vIGZhciB3aGVuIGxpdHRsZSBvciBubyBmcmFncyBzdGFydCB3aXRoIGtleWZyYW1lc1xuICAgICAgICAgIGlmIChuZXh0RnJhZyAmJiBuZXh0RnJhZy5iYWNrdHJhY2tlZCkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYEFscmVhZHkgYmFja3RyYWNrZWQgZnJvbSBmcmFnbWVudCAke25leHRGcmFnLnNufSwgd2lsbCBub3QgYmFja3RyYWNrIHRvIGZyYWdtZW50ICR7ZnJhZy5zbn0uIExvYWRpbmcgZnJhZ21lbnQgJHtuZXh0RnJhZy5zbn1gKTtcbiAgICAgICAgICAgIGZyYWcgPSBuZXh0RnJhZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgYSBmcmFnbWVudCBoYXMgZHJvcHBlZCBmcmFtZXMgYW5kIGl0J3MgaW4gYSBzYW1lIGxldmVsL3NlcXVlbmNlLCBsb2FkIHRoZSBwcmV2aW91cyBmcmFnbWVudCB0byB0cnkgYW5kIGZpbmQgdGhlIGtleWZyYW1lXG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgZHJvcHBlZCBjb3VudCBub3cgc2luY2UgaXQgd29uJ3QgYmUgcmVzZXQgdW50aWwgd2UgcGFyc2UgdGhlIGZyYWdtZW50IGFnYWluLCB3aGljaCBwcmV2ZW50cyBpbmZpbml0ZSBiYWNrdHJhY2tpbmcgb24gdGhlIHNhbWUgc2VnbWVudFxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ0xvYWRlZCBmcmFnbWVudCB3aXRoIGRyb3BwZWQgZnJhbWVzLCBiYWNrdHJhY2tpbmcgMSBzZWdtZW50IHRvIGZpbmQgYSBrZXlmcmFtZScpO1xuICAgICAgICAgICAgZnJhZy5kcm9wcGVkID0gMDtcbiAgICAgICAgICAgIGlmIChwcmV2RnJhZykge1xuICAgICAgICAgICAgICBmcmFnID0gcHJldkZyYWc7XG4gICAgICAgICAgICAgIGZyYWcuYmFja3RyYWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJTTklkeCkge1xuICAgICAgICAgICAgICAvLyBjYW4ndCBiYWNrdHJhY2sgb24gdmVyeSBmaXJzdCBmcmFnbWVudFxuICAgICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cblxuICBfbG9hZEtleSAoZnJhZykge1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FESU5HLCB7IGZyYWcgfSk7XG4gIH1cblxuICBfbG9hZEZyYWdtZW50IChmcmFnKSB7XG4gICAgLy8gQ2hlY2sgaWYgZnJhZ21lbnQgaXMgbm90IGxvYWRlZFxuICAgIGxldCBmcmFnU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcblxuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAvLyBEb24ndCB1cGRhdGUgbmV4dExvYWRQb3NpdGlvbiBmb3IgZnJhZ21lbnRzIHdoaWNoIGFyZSBub3QgYnVmZmVyZWRcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGZyYWcuc24pICYmICFmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnLnN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICAvLyBBbGxvdyBiYWNrdHJhY2tlZCBmcmFnbWVudHMgdG8gbG9hZFxuICAgIGlmIChmcmFnLmJhY2t0cmFja2VkIHx8IGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEIHx8IGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMKSB7XG4gICAgICBmcmFnLmF1dG9MZXZlbCA9IHRoaXMuaGxzLmF1dG9MZXZlbEVuYWJsZWQ7XG4gICAgICBmcmFnLmJpdHJhdGVUZXN0ID0gdGhpcy5iaXRyYXRlVGVzdDtcblxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURJTkcsIHsgZnJhZyB9KTtcbiAgICAgIC8vIGxhenkgZGVtdXhlciBpbml0LCBhcyB0aGlzIGNvdWxkIHRha2Ugc29tZSB0aW1lIC4uLiBkbyBpdCBkdXJpbmcgZnJhZyBsb2FkaW5nXG4gICAgICBpZiAoIXRoaXMuZGVtdXhlcikge1xuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcih0aGlzLmhscywgJ21haW4nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICB9IGVsc2UgaWYgKGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5BUFBFTkRJTkcpIHtcbiAgICAgIC8vIExvd2VyIHRoZSBidWZmZXIgc2l6ZSBhbmQgdHJ5IGFnYWluXG4gICAgICBpZiAodGhpcy5fcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKGZyYWcuZHVyYXRpb24pKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldCBzdGF0ZSAobmV4dFN0YXRlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IG5leHRTdGF0ZSkge1xuICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICB0aGlzLl9zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIGxvZ2dlci5sb2coYG1haW4gc3RyZWFtOiR7cHJldmlvdXNTdGF0ZX0tPiR7bmV4dFN0YXRlfWApO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVFJFQU1fU1RBVEVfVFJBTlNJVElPTiwgeyBwcmV2aW91c1N0YXRlLCBuZXh0U3RhdGUgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cblxuICBnZXRCdWZmZXJlZEZyYWcgKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgUGxheWxpc3RMb2FkZXIuTGV2ZWxUeXBlLk1BSU4pO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRMZXZlbCAoKSB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGNvbnN0IGZyYWcgPSB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSk7XG4gICAgICBpZiAoZnJhZykge1xuICAgICAgICByZXR1cm4gZnJhZy5sZXZlbHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGdldCBuZXh0QnVmZmVyZWRGcmFnICgpIHtcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgLy8gZmlyc3QgZ2V0IGVuZCByYW5nZSBvZiBjdXJyZW50IGZyYWdtZW50XG4gICAgICByZXR1cm4gdGhpcy5mb2xsb3dpbmdCdWZmZXJlZEZyYWcodGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgZm9sbG93aW5nQnVmZmVyZWRGcmFnIChmcmFnKSB7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIC8vIHRyeSB0byBnZXQgcmFuZ2Ugb2YgbmV4dCBmcmFnbWVudCAoNTAwbXMgYWZ0ZXIgdGhpcyByYW5nZSlcbiAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhmcmFnLmVuZFBUUyArIDAuNSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0IG5leHRMZXZlbCAoKSB7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMubmV4dEJ1ZmZlcmVkRnJhZztcbiAgICBpZiAoZnJhZykge1xuICAgICAgcmV0dXJuIGZyYWcubGV2ZWxzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG5cbiAgX2NoZWNrRnJhZ21lbnRDaGFuZ2VkICgpIHtcbiAgICBsZXQgZnJhZ1BsYXlpbmdDdXJyZW50LCBjdXJyZW50VGltZSwgdmlkZW8gPSB0aGlzLm1lZGlhO1xuICAgIGlmICh2aWRlbyAmJiB2aWRlby5yZWFkeVN0YXRlICYmIHZpZGVvLnNlZWtpbmcgPT09IGZhbHNlKSB7XG4gICAgICBjdXJyZW50VGltZSA9IHZpZGVvLmN1cnJlbnRUaW1lO1xuICAgICAgLyogaWYgdmlkZW8gZWxlbWVudCBpcyBpbiBzZWVrZWQgc3RhdGUsIGN1cnJlbnRUaW1lIGNhbiBvbmx5IGluY3JlYXNlLlxuICAgICAgICAoYXNzdW1pbmcgdGhhdCBwbGF5YmFjayByYXRlIGlzIHBvc2l0aXZlIC4uLilcbiAgICAgICAgQXMgc29tZXRpbWVzIGN1cnJlbnRUaW1lIGp1bXBzIGJhY2sgdG8gemVybyBhZnRlciBhXG4gICAgICAgIG1lZGlhIGRlY29kZSBlcnJvciwgY2hlY2sgdGhpcywgdG8gYXZvaWQgc2Vla2luZyBiYWNrIHRvXG4gICAgICAgIHdyb25nIHBvc2l0aW9uIGFmdGVyIGEgbWVkaWEgZGVjb2RlIGVycm9yXG4gICAgICAqL1xuICAgICAgaWYgKGN1cnJlbnRUaW1lID4gdGhpcy5sYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIH1cblxuICAgICAgaWYgKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvLCBjdXJyZW50VGltZSkpIHtcbiAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcoY3VycmVudFRpbWUpO1xuICAgICAgfSBlbHNlIGlmIChCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh2aWRlbywgY3VycmVudFRpbWUgKyAwLjEpKSB7XG4gICAgICAgIC8qIGVuc3VyZSB0aGF0IEZSQUdfQ0hBTkdFRCBldmVudCBpcyB0cmlnZ2VyZWQgYXQgc3RhcnR1cCxcbiAgICAgICAgICB3aGVuIGZpcnN0IHZpZGVvIGZyYW1lIGlzIGRpc3BsYXllZCBhbmQgcGxheWJhY2sgaXMgcGF1c2VkLlxuICAgICAgICAgIGFkZCBhIHRvbGVyYW5jZSBvZiAxMDBtcywgaW4gY2FzZSBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCxcbiAgICAgICAgICBjaGVjayBpZiBjdXJyZW50IHBvcysxMDBtcyBpcyBidWZmZXJlZCBhbmQgdXNlIHRoYXQgYnVmZmVyIHJhbmdlXG4gICAgICAgICAgZm9yIEZSQUdfQ0hBTkdFRCBldmVudCByZXBvcnRpbmcgKi9cbiAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcoY3VycmVudFRpbWUgKyAwLjEpO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWdQbGF5aW5nQ3VycmVudCkge1xuICAgICAgICBsZXQgZnJhZ1BsYXlpbmcgPSBmcmFnUGxheWluZ0N1cnJlbnQ7XG4gICAgICAgIGlmIChmcmFnUGxheWluZyAhPT0gdGhpcy5mcmFnUGxheWluZykge1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19DSEFOR0VELCB7IGZyYWc6IGZyYWdQbGF5aW5nIH0pO1xuICAgICAgICAgIGNvbnN0IGZyYWdQbGF5aW5nTGV2ZWwgPSBmcmFnUGxheWluZy5sZXZlbHM7XG4gICAgICAgICAgaWYgKCF0aGlzLmZyYWdQbGF5aW5nIHx8IHRoaXMuZnJhZ1BsYXlpbmcubGV2ZWxzICE9PSBmcmFnUGxheWluZ0xldmVsKSB7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX1NXSVRDSEVELCB7IGxldmVsOiBmcmFnUGxheWluZ0xldmVsIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBmcmFnUGxheWluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAgb24gaW1tZWRpYXRlIGxldmVsIHN3aXRjaCA6XG4gICAgIC0gcGF1c2UgcGxheWJhY2sgaWYgcGxheWluZ1xuICAgICAtIGNhbmNlbCBhbnkgcGVuZGluZyBsb2FkIHJlcXVlc3RcbiAgICAgLSBhbmQgdHJpZ2dlciBhIGJ1ZmZlciBmbHVzaFxuICAqL1xuICBpbW1lZGlhdGVMZXZlbFN3aXRjaCAoKSB7XG4gICAgbG9nZ2VyLmxvZygnaW1tZWRpYXRlTGV2ZWxTd2l0Y2gnKTtcbiAgICBpZiAoIXRoaXMuaW1tZWRpYXRlU3dpdGNoKSB7XG4gICAgICB0aGlzLmltbWVkaWF0ZVN3aXRjaCA9IHRydWU7XG4gICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhLCBwcmV2aW91c2x5UGF1c2VkO1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHByZXZpb3VzbHlQYXVzZWQgPSBtZWRpYS5wYXVzZWQ7XG4gICAgICAgIG1lZGlhLnBhdXNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkb24ndCByZXN0YXJ0IHBsYXliYWNrIGFmdGVyIGluc3RhbnQgbGV2ZWwgc3dpdGNoIGluIGNhc2UgbWVkaWEgbm90IGF0dGFjaGVkXG4gICAgICAgIHByZXZpb3VzbHlQYXVzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmV2aW91c2x5UGF1c2VkID0gcHJldmlvdXNseVBhdXNlZDtcbiAgICB9XG4gICAgbGV0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAvLyBmbHVzaCBldmVyeXRoaW5nXG4gICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBvbiBpbW1lZGlhdGUgbGV2ZWwgc3dpdGNoIGVuZCwgYWZ0ZXIgbmV3IGZyYWdtZW50IGhhcyBiZWVuIGJ1ZmZlcmVkOlxuICAgKiAtIG51ZGdlIHZpZGVvIGRlY29kZXIgYnkgc2xpZ2h0bHkgYWRqdXN0aW5nIHZpZGVvIGN1cnJlbnRUaW1lIChpZiBjdXJyZW50VGltZSBidWZmZXJlZClcbiAgICogLSByZXN1bWUgdGhlIHBsYXliYWNrIGlmIG5lZWRlZFxuICAgKi9cbiAgaW1tZWRpYXRlTGV2ZWxTd2l0Y2hFbmQgKCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEuYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLmltbWVkaWF0ZVN3aXRjaCA9IGZhbHNlO1xuICAgICAgaWYgKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLCBtZWRpYS5jdXJyZW50VGltZSkpIHtcbiAgICAgICAgLy8gb25seSBudWRnZSBpZiBjdXJyZW50VGltZSBpcyBidWZmZXJlZFxuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSAtPSAwLjAwMDE7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucHJldmlvdXNseVBhdXNlZCkge1xuICAgICAgICBtZWRpYS5wbGF5KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHRyeSB0byBzd2l0Y2ggQVNBUCB3aXRob3V0IGJyZWFraW5nIHZpZGVvIHBsYXliYWNrOlxuICAgKiBpbiBvcmRlciB0byBlbnN1cmUgc21vb3RoIGJ1dCBxdWljayBsZXZlbCBzd2l0Y2hpbmcsXG4gICAqIHdlIG5lZWQgdG8gZmluZCB0aGUgbmV4dCBmbHVzaGFibGUgYnVmZmVyIHJhbmdlXG4gICAqIHdlIHNob3VsZCB0YWtlIGludG8gYWNjb3VudCBuZXcgc2VnbWVudCBmZXRjaCB0aW1lXG4gICAqL1xuICBuZXh0TGV2ZWxTd2l0Y2ggKCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAvLyBlbnN1cmUgdGhhdCBtZWRpYSBpcyBkZWZpbmVkIGFuZCB0aGF0IG1ldGFkYXRhIGFyZSBhdmFpbGFibGUgKHRvIHJldHJpZXZlIGN1cnJlbnRUaW1lKVxuICAgIGlmIChtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICBsZXQgZmV0Y2hkZWxheSwgZnJhZ1BsYXlpbmdDdXJyZW50LCBuZXh0QnVmZmVyZWRGcmFnO1xuICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgaWYgKGZyYWdQbGF5aW5nQ3VycmVudCAmJiBmcmFnUGxheWluZ0N1cnJlbnQuc3RhcnRQVFMgPiAxKSB7XG4gICAgICAgIC8vIGZsdXNoIGJ1ZmZlciBwcmVjZWRpbmcgY3VycmVudCBmcmFnbWVudCAoZmx1c2ggdW50aWwgY3VycmVudCBmcmFnbWVudCBzdGFydCBvZmZzZXQpXG4gICAgICAgIC8vIG1pbnVzIDFzIHRvIGF2b2lkIHZpZGVvIGZyZWV6aW5nLCB0aGF0IGNvdWxkIGhhcHBlbiBpZiB3ZSBmbHVzaCBrZXlmcmFtZSBvZiBjdXJyZW50IHZpZGVvIC4uLlxuICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBmcmFnUGxheWluZ0N1cnJlbnQuc3RhcnRQVFMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWVkaWEucGF1c2VkKSB7XG4gICAgICAgIC8vIGFkZCBhIHNhZmV0eSBkZWxheSBvZiAxc1xuICAgICAgICBsZXQgbmV4dExldmVsSWQgPSB0aGlzLmhscy5uZXh0TG9hZExldmVsLCBuZXh0TGV2ZWwgPSB0aGlzLmxldmVsc1tuZXh0TGV2ZWxJZF0sIGZyYWdMYXN0S2JwcyA9IHRoaXMuZnJhZ0xhc3RLYnBzO1xuICAgICAgICBpZiAoZnJhZ0xhc3RLYnBzICYmIHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gdGhpcy5mcmFnQ3VycmVudC5kdXJhdGlvbiAqIG5leHRMZXZlbC5iaXRyYXRlIC8gKDEwMDAgKiBmcmFnTGFzdEticHMpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmV0Y2hkZWxheSA9IDA7XG4gICAgICB9XG4gICAgICAvLyBsb2dnZXIubG9nKCdmZXRjaGRlbGF5OicrZmV0Y2hkZWxheSk7XG4gICAgICAvLyBmaW5kIGJ1ZmZlciByYW5nZSB0aGF0IHdpbGwgYmUgcmVhY2hlZCBvbmNlIG5ldyBmcmFnbWVudCB3aWxsIGJlIGZldGNoZWRcbiAgICAgIG5leHRCdWZmZXJlZEZyYWcgPSB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSArIGZldGNoZGVsYXkpO1xuICAgICAgaWYgKG5leHRCdWZmZXJlZEZyYWcpIHtcbiAgICAgICAgLy8gd2UgY2FuIGZsdXNoIGJ1ZmZlciByYW5nZSBmb2xsb3dpbmcgdGhpcyBvbmUgd2l0aG91dCBzdGFsbGluZyBwbGF5YmFja1xuICAgICAgICBuZXh0QnVmZmVyZWRGcmFnID0gdGhpcy5mb2xsb3dpbmdCdWZmZXJlZEZyYWcobmV4dEJ1ZmZlcmVkRnJhZyk7XG4gICAgICAgIGlmIChuZXh0QnVmZmVyZWRGcmFnKSB7XG4gICAgICAgICAgLy8gaWYgd2UgYXJlIGhlcmUsIHdlIGNhbiBhbHNvIGNhbmNlbCBhbnkgbG9hZGluZy9kZW11eGluZyBpbiBwcm9ncmVzcywgYXMgdGhleSBhcmUgdXNlbGVzc1xuICAgICAgICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgICAgaWYgKGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgICAgLy8gc3RhcnQgZmx1c2ggcG9zaXRpb24gaXMgdGhlIHN0YXJ0IFBUUyBvZiBuZXh0IGJ1ZmZlcmVkIGZyYWcuXG4gICAgICAgICAgLy8gd2UgdXNlIGZyYWcubmF4U3RhcnRQVFMgd2hpY2ggaXMgbWF4KGF1ZGlvIHN0YXJ0UFRTLCB2aWRlbyBzdGFydFBUUykuXG4gICAgICAgICAgLy8gaW4gY2FzZSB0aGVyZSBpcyBhIHNtYWxsIFBUUyBEZWx0YSBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbywgdXNpbmcgbWF4U3RhcnRQVFMgYXZvaWRzIGZsdXNoaW5nIGxhc3Qgc2FtcGxlcyBmcm9tIGN1cnJlbnQgZnJhZ21lbnRcbiAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcihuZXh0QnVmZmVyZWRGcmFnLm1heFN0YXJ0UFRTLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZmx1c2hNYWluQnVmZmVyIChzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJVRkZFUl9GTFVTSElORztcbiAgICBsZXQgZmx1c2hTY29wZSA9IHsgc3RhcnRPZmZzZXQ6IHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQ6IGVuZE9mZnNldCB9O1xuICAgIC8vIGlmIGFsdGVybmF0ZSBhdWRpbyB0cmFja3MgYXJlIHVzZWQsIG9ubHkgZmx1c2ggdmlkZW8sIG90aGVyd2lzZSBmbHVzaCBldmVyeXRoaW5nXG4gICAgaWYgKHRoaXMuYWx0QXVkaW8pIHtcbiAgICAgIGZsdXNoU2NvcGUudHlwZSA9ICd2aWRlbyc7XG4gICAgfVxuXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRkxVU0hJTkcsIGZsdXNoU2NvcGUpO1xuICB9XG5cbiAgb25NZWRpYUF0dGFjaGVkIChkYXRhKSB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub25NZWRpYVNlZWtpbmcuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9udnNlZWtlZCA9IHRoaXMub25NZWRpYVNlZWtlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub252ZW5kZWQgPSB0aGlzLm9uTWVkaWFFbmRlZC5iaW5kKHRoaXMpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtlZCcsIHRoaXMub252c2Vla2VkKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAodGhpcy5sZXZlbHMgJiYgY29uZmlnLmF1dG9TdGFydExvYWQpIHtcbiAgICAgIHRoaXMuaGxzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuXG4gICAgdGhpcy5nYXBDb250cm9sbGVyID0gbmV3IEdhcENvbnRyb2xsZXIoY29uZmlnLCBtZWRpYSwgdGhpcy5mcmFnbWVudFRyYWNrZXIsIHRoaXMuaGxzKTtcbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcgKCkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhICYmIG1lZGlhLmVuZGVkKSB7XG4gICAgICBsb2dnZXIubG9nKCdNU0UgZGV0YWNoaW5nIGFuZCB2aWRlbyBlbmRlZCwgcmVzZXQgc3RhcnRQb3NpdGlvbicpO1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIH1cblxuICAgIC8vIHJlc2V0IGZyYWdtZW50IGJhY2t0cmFja2VkIGZsYWdcbiAgICBsZXQgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgaWYgKGxldmVscykge1xuICAgICAgbGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgICBpZiAobGV2ZWwuZGV0YWlscykge1xuICAgICAgICAgIGxldmVsLmRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnJhZ21lbnQgPT4ge1xuICAgICAgICAgICAgZnJhZ21lbnQuYmFja3RyYWNrZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyByZW1vdmUgdmlkZW8gbGlzdGVuZXJzXG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtlZCcsIHRoaXMub252c2Vla2VkKTtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9udnNlZWtlZCA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgfVxuXG4gIG9uTWVkaWFTZWVrZWQgKCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYSwgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogdW5kZWZpbmVkO1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoY3VycmVudFRpbWUpKSB7XG4gICAgICBsb2dnZXIubG9nKGBtZWRpYSBzZWVrZWQgdG8gJHtjdXJyZW50VGltZS50b0ZpeGVkKDMpfWApO1xuICAgIH1cblxuICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgRlJBR01FTlRfUExBWUlORyB0cmlnZ2VyaW5nXG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBvbk1hbmlmZXN0TG9hZGluZyAoKSB7XG4gICAgLy8gcmVzZXQgYnVmZmVyIG9uIG1hbmlmZXN0IGxvYWRpbmdcbiAgICBsb2dnZXIubG9nKCd0cmlnZ2VyIEJVRkZFUl9SRVNFVCcpO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX1JFU0VUKTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICB0aGlzLnN0YWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gIH1cblxuICBvbk1hbmlmZXN0UGFyc2VkIChkYXRhKSB7XG4gICAgbGV0IGFhYyA9IGZhbHNlLCBoZWFhYyA9IGZhbHNlLCBjb2RlYztcbiAgICBkYXRhLmxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgIC8vIGRldGVjdCBpZiB3ZSBoYXZlIGRpZmZlcmVudCBraW5kIG9mIGF1ZGlvIGNvZGVjcyB1c2VkIGFtb25nc3QgcGxheWxpc3RzXG4gICAgICBjb2RlYyA9IGxldmVsLmF1ZGlvQ29kZWM7XG4gICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMSkge1xuICAgICAgICAgIGFhYyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XG4gICAgICAgICAgaGVhYWMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dpdGNoID0gKGFhYyAmJiBoZWFhYyk7XG4gICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgbG9nZ2VyLmxvZygnYm90aCBBQUMvSEUtQUFDIGF1ZGlvIGZvdW5kIGluIGxldmVsczsgZGVjbGFyaW5nIGxldmVsIGNvZGVjIGFzIEhFLUFBQycpO1xuICAgIH1cblxuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYgKGNvbmZpZy5hdXRvU3RhcnRMb2FkIHx8IHRoaXMuZm9yY2VTdGFydExvYWQpIHtcbiAgICAgIHRoaXMuaGxzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgb25MZXZlbExvYWRlZCAoZGF0YSkge1xuICAgIGNvbnN0IG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgY29uc3QgbmV3TGV2ZWxJZCA9IGRhdGEubGV2ZWxzO1xuICAgIGNvbnN0IGxhc3RMZXZlbCA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxMYXN0TG9hZGVkXTtcbiAgICBjb25zdCBjdXJMZXZlbCA9IHRoaXMubGV2ZWxzW25ld0xldmVsSWRdO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uO1xuICAgIGxldCBzbGlkaW5nID0gMDtcblxuICAgIGxvZ2dlci5sb2coYGxldmVsICR7bmV3TGV2ZWxJZH0gbG9hZGVkIFske25ld0RldGFpbHMuc3RhcnRTTn0sJHtuZXdEZXRhaWxzLmVuZFNOfV0sZHVyYXRpb246JHtkdXJhdGlvbn1gKTtcblxuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgIGxldCBjdXJEZXRhaWxzID0gY3VyTGV2ZWwuZGV0YWlscztcbiAgICAgIGlmIChjdXJEZXRhaWxzICYmIG5ld0RldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gd2UgYWxyZWFkeSBoYXZlIGRldGFpbHMgZm9yIHRoYXQgbGV2ZWwsIG1lcmdlIHRoZW1cbiAgICAgICAgTGV2ZWxIZWxwZXIubWVyZ2VEZXRhaWxzKGN1ckRldGFpbHMsIG5ld0RldGFpbHMpO1xuICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICAgIHRoaXMubGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZUxpdmVQb3NpdGlvbihzbGlkaW5nLCBjdXJEZXRhaWxzKTtcbiAgICAgICAgaWYgKG5ld0RldGFpbHMuUFRTS25vd24gJiYgTnVtYmVyLmlzRmluaXRlKHNsaWRpbmcpKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCBzbGlkaW5nOiR7c2xpZGluZy50b0ZpeGVkKDMpfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QgLSBvdXRkYXRlZCBQVFMsIHVua25vd24gc2xpZGluZycpO1xuICAgICAgICAgIGFsaWduU3RyZWFtKHRoaXMuZnJhZ1ByZXZpb3VzLCBsYXN0TGV2ZWwsIG5ld0RldGFpbHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIubG9nKCdsaXZlIHBsYXlsaXN0IC0gZmlyc3QgbG9hZCwgdW5rbm93biBzbGlkaW5nJyk7XG4gICAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcbiAgICAgICAgYWxpZ25TdHJlYW0odGhpcy5mcmFnUHJldmlvdXMsIGxhc3RMZXZlbCwgbmV3RGV0YWlscyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gb3ZlcnJpZGUgbGV2ZWwgaW5mb1xuICAgIGN1ckxldmVsLmRldGFpbHMgPSBuZXdEZXRhaWxzO1xuICAgIHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gbmV3TGV2ZWxJZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX1VQREFURUQsIHsgZGV0YWlsczogbmV3RGV0YWlscywgbGV2ZWw6IG5ld0xldmVsSWQgfSk7XG5cbiAgICBpZiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPT09IGZhbHNlKSB7XG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICAgIGlmICh0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xIHx8IHRoaXMubGFzdEN1cnJlbnRUaW1lID09PSAtMSkge1xuICAgICAgICAvLyBmaXJzdCwgY2hlY2sgaWYgc3RhcnQgdGltZSBvZmZzZXQgaGFzIGJlZW4gc2V0IGluIHBsYXlsaXN0LCBpZiB5ZXMsIHVzZSB0aGlzIHZhbHVlXG4gICAgICAgIGxldCBzdGFydFRpbWVPZmZzZXQgPSBuZXdEZXRhaWxzLnN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShzdGFydFRpbWVPZmZzZXQpKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0VGltZU9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYG5lZ2F0aXZlIHN0YXJ0IHRpbWUgb2Zmc2V0ICR7c3RhcnRUaW1lT2Zmc2V0fSwgY291bnQgZnJvbSBlbmQgb2YgbGFzdCBmcmFnbWVudGApO1xuICAgICAgICAgICAgc3RhcnRUaW1lT2Zmc2V0ID0gc2xpZGluZyArIGR1cmF0aW9uICsgc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2dnZXIubG9nKGBzdGFydCB0aW1lIG9mZnNldCBmb3VuZCBpbiBwbGF5bGlzdCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gdG8gJHtzdGFydFRpbWVPZmZzZXR9YCk7XG4gICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIGxpdmUgcGxheWxpc3QsIHNldCBzdGFydCBwb3NpdGlvbiB0byBiZSBmcmFnbWVudCBOLXRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCAodXN1YWxseSAzKVxuICAgICAgICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZUxpdmVQb3NpdGlvbihzbGlkaW5nLCBuZXdEZXRhaWxzKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYGNvbmZpZ3VyZSBzdGFydFBvc2l0aW9uIHRvICR7dGhpcy5zdGFydFBvc2l0aW9ufWApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICB9XG4gICAgLy8gb25seSBzd2l0Y2ggYmF0Y2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIGxldmVsIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uS2V5TG9hZGVkICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuS0VZX0xPQURJTkcpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnTG9hZGVkIChkYXRhKSB7XG4gICAgY29uc3QgeyBmcmFnQ3VycmVudCwgaGxzLCBsZXZlbHMsIG1lZGlhIH0gPSB0aGlzO1xuICAgIGNvbnN0IGZyYWdMb2FkZWQgPSBkYXRhLmZyYWc7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyAmJlxuICAgICAgICBmcmFnQ3VycmVudCAmJlxuICAgICAgICBmcmFnTG9hZGVkLnR5cGUgPT09ICdtYWluJyAmJlxuICAgICAgICBmcmFnTG9hZGVkLmxldmVscyA9PT0gZnJhZ0N1cnJlbnQubGV2ZWxzICYmXG4gICAgICAgIGZyYWdMb2FkZWQuc24gPT09IGZyYWdDdXJyZW50LnNuKSB7XG4gICAgICBjb25zdCBzdGF0cyA9IGRhdGEuc3RhdHM7XG4gICAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSBsZXZlbHNbZnJhZ0N1cnJlbnQubGV2ZWxzXTtcbiAgICAgIGNvbnN0IGRldGFpbHMgPSBjdXJyZW50TGV2ZWwuZGV0YWlscztcbiAgICAgIC8vIHJlc2V0IGZyYWcgYml0cmF0ZSB0ZXN0IGluIGFueSBjYXNlIGFmdGVyIGZyYWcgbG9hZGVkIGV2ZW50XG4gICAgICAvLyBpZiB0aGlzIGZyYWcgd2FzIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0IEFORCBpZiBobHMubmV4dExvYWRMZXZlbCBpcyBncmVhdGVyIHRoYW4gMFxuICAgICAgLy8gdGhlbiB0aGlzIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIGJlIGFibGUgdG8gbG9hZCBhIGZyYWdtZW50IGF0IGEgaGlnaGVyIHF1YWxpdHkgbGV2ZWxcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RhdHMgPSBzdGF0cztcblxuICAgICAgbG9nZ2VyLmxvZyhgTG9hZGVkICR7ZnJhZ0N1cnJlbnQuc259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLGxldmVsICR7ZnJhZ0N1cnJlbnQubGV2ZWxzfWApO1xuICAgICAgaWYgKGZyYWdMb2FkZWQuYml0cmF0ZVRlc3QgJiYgaGxzLm5leHRMb2FkTGV2ZWwpIHtcbiAgICAgICAgLy8gc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSAuLi4gd2UganVzdCBsb2FkZWQgYSBmcmFnbWVudCB0byBkZXRlcm1pbmUgYWRlcXVhdGUgc3RhcnQgYml0cmF0ZSBhbmQgaW5pdGlhbGl6ZSBhdXRvc3dpdGNoIGFsZ29cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIHN0YXRzLnRwYXJzZWQgPSBzdGF0cy50YnVmZmVyZWQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZSQUdfQlVGRkVSRUQsIHsgc3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnQ3VycmVudCwgaWQ6ICdtYWluJyB9KTtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9IGVsc2UgaWYgKGZyYWdMb2FkZWQuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIHN0YXRzLnRwYXJzZWQgPSBzdGF0cy50YnVmZmVyZWQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGRldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSA9IGRhdGEucGF5bG9hZDtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19CVUZGRVJFRCwgeyBzdGF0czogc3RhdHMsIGZyYWc6IGZyYWdDdXJyZW50LCBpZDogJ21haW4nIH0pO1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5sb2coYFBhcnNpbmcgJHtmcmFnQ3VycmVudC5zbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtmcmFnQ3VycmVudC5sZXZlbHN9LCBjYyAke2ZyYWdDdXJyZW50LmNjfWApO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hcHBlbmRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEJpdHJhdGUgdGVzdCBmcmFncyBhcmUgbm90IHVzdWFsbHkgYnVmZmVyZWQgc28gdGhlIGZyYWdtZW50IHRyYWNrZXIgaWdub3JlcyB0aGVtLiBJZiBIbHMuanMgZGVjaWRlcyB0byBidWZmZXJcbiAgICAgICAgLy8gaXQgKGFuZCB0aGVyZWZvcmUgZW5kcyB1cCBhdCB0aGlzIGxpbmUpLCB0aGVuIHRoZSBmcmFnbWVudCB0cmFja2VyIG5lZWRzIHRvIGJlIG1hbnVhbGx5IGluZm9ybWVkLlxuICAgICAgICBpZiAoZnJhZ0xvYWRlZC5iaXRyYXRlVGVzdCkge1xuICAgICAgICAgIGZyYWdMb2FkZWQuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5vbkZyYWdMb2FkZWQoe1xuICAgICAgICAgICAgZnJhZzogZnJhZ0xvYWRlZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpIGFuZCBpZiBtZWRpYSBpcyBub3Qgc2Vla2luZyAodGhpcyBpcyB0byBvdmVyY29tZSBwb3RlbnRpYWwgdGltZXN0YW1wIGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0cyBhbmQgZnJhZ21lbnRzKVxuICAgICAgICBjb25zdCBhY2N1cmF0ZVRpbWVPZmZzZXQgPSAhKG1lZGlhICYmIG1lZGlhLnNlZWtpbmcpICYmIChkZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmUpO1xuICAgICAgICBjb25zdCBpbml0U2VnbWVudERhdGEgPSBkZXRhaWxzLmluaXRTZWdtZW50ID8gZGV0YWlscy5pbml0U2VnbWVudC5kYXRhIDogW107XG4gICAgICAgIGNvbnN0IGF1ZGlvQ29kZWMgPSB0aGlzLl9nZXRBdWRpb0NvZGVjKGN1cnJlbnRMZXZlbCk7XG5cbiAgICAgICAgLy8gdHJhbnNtdXggdGhlIE1QRUctVFMgZGF0YSB0byBJU08tQk1GRiBzZWdtZW50c1xuICAgICAgICBjb25zdCBkZW11eGVyID0gdGhpcy5kZW11eGVyID0gdGhpcy5kZW11eGVyIHx8IG5ldyBEZW11eGVyKHRoaXMuaGxzLCAnbWFpbicpO1xuICAgICAgICBkZW11eGVyLnB1c2goXG4gICAgICAgICAgZGF0YS5wYXlsb2FkLFxuICAgICAgICAgIGluaXRTZWdtZW50RGF0YSxcbiAgICAgICAgICBhdWRpb0NvZGVjLFxuICAgICAgICAgIGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjLFxuICAgICAgICAgIGZyYWdDdXJyZW50LFxuICAgICAgICAgIGRldGFpbHMudG90YWxkdXJhdGlvbixcbiAgICAgICAgICBhY2N1cmF0ZVRpbWVPZmZzZXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdJbml0U2VnbWVudCAoZGF0YSkge1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBjb25zdCBmcmFnTmV3ID0gZGF0YS5mcmFnO1xuXG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdtYWluJyAmJlxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBmcmFnTmV3LmxldmVscyA9PT0gZnJhZ0N1cnJlbnQubGV2ZWxzICYmXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIGxldCB0cmFja3MgPSBkYXRhLnRyYWNrcywgdHJhY2tOYW1lLCB0cmFjaztcblxuICAgICAgLy8gaWYgYXVkaW8gdHJhY2sgaXMgZXhwZWN0ZWQgdG8gY29tZSBmcm9tIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyLCBkaXNjYXJkIGFueSBjb21pbmcgZnJvbSBtYWluXG4gICAgICBpZiAodHJhY2tzLmF1ZGlvICYmIHRoaXMuYWx0QXVkaW8pIHtcbiAgICAgICAgZGVsZXRlIHRyYWNrcy5hdWRpbztcbiAgICAgIH1cblxuICAgICAgLy8gaW5jbHVkZSBsZXZlbENvZGVjIGluIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3NcbiAgICAgIHRyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgIGxldCBhdWRpb0NvZGVjID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF0uYXVkaW9Db2RlYyxcbiAgICAgICAgICB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGF1ZGlvQ29kZWMgJiYgdGhpcy5hdWRpb0NvZGVjU3dhcCkge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3N3YXBwaW5nIHBsYXlsaXN0IGF1ZGlvIGNvZGVjJyk7XG4gICAgICAgICAgaWYgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gY2FzZSBBQUMgYW5kIEhFLUFBQyBhdWRpbyBjb2RlY3MgYXJlIHNpZ25hbGxlZCBpbiBtYW5pZmVzdFxuICAgICAgICAvLyBmb3JjZSBIRS1BQUMgLCBhcyBpdCBzZWVtcyB0aGF0IG1vc3QgYnJvd3NlcnMgcHJlZmVycyB0aGF0IHdheSxcbiAgICAgICAgLy8gZXhjZXB0IGZvciBtb25vIHN0cmVhbXMgT1Igb24gRkZcbiAgICAgICAgLy8gdGhlc2UgY29uZGl0aW9ucyBtaWdodCBuZWVkIHRvIGJlIHJldmlld2VkIC4uLlxuICAgICAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dpdGNoKSB7XG4gICAgICAgICAgLy8gZG9uJ3QgZm9yY2UgSEUtQUFDIGlmIG1vbm8gc3RyZWFtXG4gICAgICAgICAgaWYgKHRyYWNrLm1ldGFkYXRhLmNoYW5uZWxDb3VudCAhPT0gMSAmJlxuICAgICAgICAgICAgLy8gZG9uJ3QgZm9yY2UgSEUtQUFDIGlmIGZpcmVmb3hcbiAgICAgICAgICAgIHVhLmluZGV4T2YoJ2ZpcmVmb3gnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSEUtQUFDIGlzIGJyb2tlbiBvbiBBbmRyb2lkLCBhbHdheXMgc2lnbmFsIGF1ZGlvIGNvZGVjIGFzIEFBQyBldmVuIGlmIHZhcmlhbnQgbWFuaWZlc3Qgc3RhdGVzIG90aGVyd2lzZVxuICAgICAgICBpZiAodWEuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSAmJiB0cmFjay5jb250YWluZXIgIT09ICdhdWRpby9tcGVnJykgeyAvLyBFeGNsdWRlIG1wZWcgYXVkaW9cbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgQW5kcm9pZDogZm9yY2UgYXVkaW8gY29kZWMgdG8gJHthdWRpb0NvZGVjfWApO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrLmxldmVsQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgICAgICB0cmFjay5pZCA9IGRhdGEuaWQ7XG4gICAgICB9XG4gICAgICB0cmFjayA9IHRyYWNrcy52aWRlbztcbiAgICAgIGlmICh0cmFjaykge1xuICAgICAgICB0cmFjay5sZXZlbENvZGVjID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF0udmlkZW9Db2RlYztcbiAgICAgICAgdHJhY2suaWQgPSBkYXRhLmlkO1xuICAgICAgfVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQ09ERUNTLCB0cmFja3MpO1xuICAgICAgLy8gbG9vcCB0aHJvdWdoIHRyYWNrcyB0aGF0IGFyZSBnb2luZyB0byBiZSBwcm92aWRlZCB0byBidWZmZXJDb250cm9sbGVyXG4gICAgICBmb3IgKHRyYWNrTmFtZSBpbiB0cmFja3MpIHtcbiAgICAgICAgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgbWFpbiB0cmFjazoke3RyYWNrTmFtZX0sY29udGFpbmVyOiR7dHJhY2suY29udGFpbmVyfSxjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bJHt0cmFjay5sZXZlbENvZGVjfS8ke3RyYWNrLmNvZGVjfV1gKTtcbiAgICAgICAgbGV0IGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG4gICAgICAgIGlmIChpbml0U2VnbWVudCkge1xuICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xuICAgICAgICAgIC8vIGFybSBwZW5kaW5nIEJ1ZmZlcmluZyBmbGFnIGJlZm9yZSBhcHBlbmRpbmcgYSBzZWdtZW50XG4gICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsIHsgdHlwZTogdHJhY2tOYW1lLCBkYXRhOiBpbml0U2VnbWVudCwgcGFyZW50OiAnbWFpbicsIGNvbnRlbnQ6ICdpbml0U2VnbWVudCcgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdEYXRhIChkYXRhKSB7XG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdtYWluJyAmJlxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBmcmFnTmV3LmxldmVscyA9PT0gZnJhZ0N1cnJlbnQubGV2ZWxzICYmXG4gICAgICAgICEoZGF0YS50eXBlID09PSAnYXVkaW8nICYmIHRoaXMuYWx0QXVkaW8pICYmIC8vIGZpbHRlciBvdXQgbWFpbiBhdWRpbyBpZiBhdWRpbyB0cmFjayBpcyBsb2FkZWQgdGhyb3VnaCBhdWRpbyBzdHJlYW0gY29udHJvbGxlclxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICBsZXQgbGV2ZWwgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXSxcbiAgICAgICAgZnJhZyA9IGZyYWdDdXJyZW50O1xuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZGF0YS5lbmRQVFMpKSB7XG4gICAgICAgIGRhdGEuZW5kUFRTID0gZGF0YS5zdGFydFBUUyArIGZyYWdDdXJyZW50LmR1cmF0aW9uO1xuICAgICAgICBkYXRhLmVuZERUUyA9IGRhdGEuc3RhcnREVFMgKyBmcmFnQ3VycmVudC5kdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuaGFzQXVkaW8gPT09IHRydWUpIHtcbiAgICAgICAgZnJhZy5hZGRFbGVtZW50YXJ5U3RyZWFtKEZyYWdtZW50LkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmhhc1ZpZGVvID09PSB0cnVlKSB7XG4gICAgICAgIGZyYWcuYWRkRWxlbWVudGFyeVN0cmVhbShGcmFnbWVudC5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8pO1xuICAgICAgfVxuXG4gICAgICBsb2dnZXIubG9nKGBQYXJzZWQgJHtkYXRhLnR5cGV9LFBUUzpbJHtkYXRhLnN0YXJ0UFRTLnRvRml4ZWQoMyl9LCR7ZGF0YS5lbmRQVFMudG9GaXhlZCgzKX1dLERUUzpbJHtkYXRhLnN0YXJ0RFRTLnRvRml4ZWQoMyl9LyR7ZGF0YS5lbmREVFMudG9GaXhlZCgzKX1dLG5iOiR7ZGF0YS5uYn0sZHJvcHBlZDoke2RhdGEuZHJvcHBlZCB8fCAwfWApO1xuXG4gICAgICAvLyBEZXRlY3QgZ2FwcyBpbiBhIGZyYWdtZW50ICBhbmQgdHJ5IHRvIGZpeCBpdCBieSBmaW5kaW5nIGEga2V5ZnJhbWUgaW4gdGhlIHByZXZpb3VzIGZyYWdtZW50IChzZWUgX2ZpbmRGcmFnbWVudHMpXG4gICAgICBpZiAoZGF0YS50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgIGZyYWcuZHJvcHBlZCA9IGRhdGEuZHJvcHBlZDtcbiAgICAgICAgaWYgKGZyYWcuZHJvcHBlZCkge1xuICAgICAgICAgIGlmICghZnJhZy5iYWNrdHJhY2tlZCkge1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICAgICAgICAgIGlmIChsZXZlbERldGFpbHMgJiYgZnJhZy5zbiA9PT0gbGV2ZWxEZXRhaWxzLnN0YXJ0U04pIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ21pc3NpbmcgdmlkZW8gZnJhbWUocykgb24gZmlyc3QgZnJhZywgYXBwZW5kaW5nIHdpdGggZ2FwJywgZnJhZy5zbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsb2dnZXIud2FybignbWlzc2luZyB2aWRlbyBmcmFtZShzKSwgYmFja3RyYWNraW5nIGZyYWdtZW50JywgZnJhZy5zbik7XG4gICAgICAgICAgICAgIC8vIFJldHVybiBiYWNrIHRvIHRoZSBJRExFIHN0YXRlIHdpdGhvdXQgYXBwZW5kaW5nIHRvIGJ1ZmZlclxuICAgICAgICAgICAgICAvLyBDYXVzZXMgZmluZEZyYWdtZW50cyB0byBiYWNrdHJhY2sgYSBzZWdtZW50IGFuZCBmaW5kIHRoZSBrZXlmcmFtZVxuICAgICAgICAgICAgICAvLyBBdWRpbyBmcmFnbWVudHMgYXJyaXZpbmcgYmVmb3JlIHZpZGVvIHNldHMgdGhlIG5leHRMb2FkUG9zaXRpb24sIGNhdXNpbmcgX2ZpbmRGcmFnbWVudHMgdG8gc2tpcCB0aGUgYmFja3RyYWNrZWQgZnJhZ21lbnRcbiAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgICAgICAgIGZyYWcuYmFja3RyYWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBkYXRhLnN0YXJ0UFRTO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybignQWxyZWFkeSBiYWNrdHJhY2tlZCBvbiB0aGlzIGZyYWdtZW50LCBhcHBlbmRpbmcgd2l0aCB0aGUgZ2FwJywgZnJhZy5zbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE9ubHkgcmVzZXQgdGhlIGJhY2t0cmFja2VkIGZsYWcgaWYgd2UndmUgbG9hZGVkIHRoZSBmcmFnIHdpdGhvdXQgYW55IGRyb3BwZWQgZnJhbWVzXG4gICAgICAgICAgZnJhZy5iYWNrdHJhY2tlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBkcmlmdCA9IExldmVsSGVscGVyLnVwZGF0ZUZyYWdQVFNEVFMobGV2ZWwuZGV0YWlscywgZnJhZywgZGF0YS5zdGFydFBUUywgZGF0YS5lbmRQVFMsIGRhdGEuc3RhcnREVFMsIGRhdGEuZW5kRFRTKSxcbiAgICAgICAgaGxzID0gdGhpcy5obHM7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5MRVZFTF9QVFNfVVBEQVRFRCwgeyBkZXRhaWxzOiBsZXZlbC5kZXRhaWxzLCBsZXZlbDogdGhpcy5sZXZlbCwgZHJpZnQ6IGRyaWZ0LCB0eXBlOiBkYXRhLnR5cGUsIHN0YXJ0OiBkYXRhLnN0YXJ0UFRTLCBlbmQ6IGRhdGEuZW5kUFRTIH0pO1xuICAgICAgLy8gaGFzIHJlbXV4ZXIgZHJvcHBlZCB2aWRlbyBmcmFtZXMgbG9jYXRlZCBiZWZvcmUgZmlyc3Qga2V5ZnJhbWUgP1xuICAgICAgW2RhdGEuZGF0YTEsIGRhdGEuZGF0YTJdLmZvckVhY2goYnVmZmVyID0+IHtcbiAgICAgICAgLy8gb25seSBhcHBlbmQgaW4gUEFSU0lORyBzdGF0ZSAocmF0aW9uYWxlIGlzIHRoYXQgYW4gYXBwZW5kaW5nIGVycm9yIGNvdWxkIGhhcHBlbiBzeW5jaHJvbm91c2x5IG9uIGZpcnN0IHNlZ21lbnQgYXBwZW5kaW5nKVxuICAgICAgICAvLyBpbiB0aGF0IGNhc2UgaXQgaXMgdXNlbGVzcyB0byBhcHBlbmQgZm9sbG93aW5nIHNlZ21lbnRzXG4gICAgICAgIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aCAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcbiAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsIHsgdHlwZTogZGF0YS50eXBlLCBkYXRhOiBidWZmZXIsIHBhcmVudDogJ21haW4nLCBjb250ZW50OiAnZGF0YScgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnUGFyc2VkIChkYXRhKSB7XG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdtYWluJyAmJlxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBmcmFnTmV3LmxldmVscyA9PT0gZnJhZ0N1cnJlbnQubGV2ZWxzICYmXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIHRoaXMuc3RhdHMudHBhcnNlZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTRUQ7XG4gICAgICB0aGlzLl9jaGVja0FwcGVuZGVkUGFyc2VkKCk7XG4gICAgfVxuICB9XG5cbiAgb25BdWRpb1RyYWNrU3dpdGNoaW5nIChkYXRhKSB7XG4gICAgLy8gaWYgYW55IFVSTCBmb3VuZCBvbiBuZXcgYXVkaW8gdHJhY2ssIGl0IGlzIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgIGxldCBhbHRBdWRpbyA9ICEhZGF0YS51cmwsXG4gICAgICB0cmFja0lkID0gZGF0YS5pZDtcbiAgICAvLyBpZiB3ZSBzd2l0Y2ggb24gbWFpbiBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIG1lZGlhLmJ1ZmZlcmVkXG4gICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgaWYgd2Ugc3dpdGNoIHRvIGFsdCBhdWRpbzogYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIgaXMgaGFuZGxpbmcgaXQuXG4gICAgLy8gd2Ugd2lsbCBqdXN0IGhhdmUgdG8gY2hhbmdlIGJ1ZmZlciBzY2hlZHVsaW5nIG9uIGF1ZGlvVHJhY2tTd2l0Y2hlZFxuICAgIGlmICghYWx0QXVkaW8pIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhQnVmZmVyICE9PSB0aGlzLm1lZGlhKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ3N3aXRjaGluZyBvbiBtYWluIGF1ZGlvLCB1c2UgbWVkaWEuYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nJyk7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgICAgICBsZXQgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlZmlsbCBhdWRpbyBidWZmZXIgZnJvbSBtYWluOiBjYW5jZWwgYW55IGZyYWcgbG9hZGluZyB0byBzcGVlZCB1cCBhdWRpbyBzd2l0Y2hcbiAgICAgICAgaWYgKGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3N3aXRjaGluZyB0byBtYWluIGF1ZGlvIHRyYWNrLCBjYW5jZWwgbWFpbiBmcmFnbWVudCBsb2FkJyk7XG4gICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgLy8gZGVzdHJveSBkZW11eGVyIHRvIGZvcmNlIGluaXQgc2VnbWVudCBnZW5lcmF0aW9uIChmb2xsb3dpbmcgYXVkaW8gc3dpdGNoKVxuICAgICAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGxvYWQgbmV3IGZyYWdtZW50XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgbGV0IGhscyA9IHRoaXMuaGxzO1xuICAgICAgLy8gc3dpdGNoaW5nIHRvIG1haW4gYXVkaW8sIGZsdXNoIGFsbCBhdWRpbyBhbmQgdHJpZ2dlciB0cmFjayBzd2l0Y2hlZFxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNISU5HLCB7IHN0YXJ0T2Zmc2V0OiAwLCBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgdHlwZTogJ2F1ZGlvJyB9KTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELCB7IGlkOiB0cmFja0lkIH0pO1xuICAgICAgdGhpcy5hbHRBdWRpbyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIG9uQXVkaW9UcmFja1N3aXRjaGVkIChkYXRhKSB7XG4gICAgbGV0IHRyYWNrSWQgPSBkYXRhLmlkLFxuICAgICAgYWx0QXVkaW8gPSAhIXRoaXMuaGxzLmF1ZGlvVHJhY2tzW3RyYWNrSWRdLnVybDtcbiAgICBpZiAoYWx0QXVkaW8pIHtcbiAgICAgIGxldCB2aWRlb0J1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXI7XG4gICAgICAvLyBpZiB3ZSBzd2l0Y2hlZCBvbiBhbHRlcm5hdGUgYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCB2aWRlbyBzb3VyY2VidWZmZXIgYnVmZmVyZWRcbiAgICAgIGlmICh2aWRlb0J1ZmZlciAmJiB0aGlzLm1lZGlhQnVmZmVyICE9PSB2aWRlb0J1ZmZlcikge1xuICAgICAgICBsb2dnZXIubG9nKCdzd2l0Y2hpbmcgb24gYWx0ZXJuYXRlIGF1ZGlvLCB1c2UgdmlkZW8uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nJyk7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB2aWRlb0J1ZmZlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hbHRBdWRpbyA9IGFsdEF1ZGlvO1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25CdWZmZXJDcmVhdGVkIChkYXRhKSB7XG4gICAgbGV0IHRyYWNrcyA9IGRhdGEudHJhY2tzLCBtZWRpYVRyYWNrLCBuYW1lLCBhbHRlcm5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCB0eXBlIGluIHRyYWNrcykge1xuICAgICAgbGV0IHRyYWNrID0gdHJhY2tzW3R5cGVdO1xuICAgICAgaWYgKHRyYWNrLmlkID09PSAnbWFpbicpIHtcbiAgICAgICAgbmFtZSA9IHR5cGU7XG4gICAgICAgIG1lZGlhVHJhY2sgPSB0cmFjaztcbiAgICAgICAgLy8ga2VlcCB2aWRlbyBzb3VyY2UgYnVmZmVyIHJlZmVyZW5jZVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSB0cmFja3NbdHlwZV0uYnVmZmVyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbHRlcm5hdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWx0ZXJuYXRlICYmIG1lZGlhVHJhY2spIHtcbiAgICAgIGxvZ2dlci5sb2coYGFsdGVybmF0ZSB0cmFjayBmb3VuZCwgdXNlICR7bmFtZX0uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nYCk7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gbWVkaWFUcmFjay5idWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgIH1cbiAgfVxuXG4gIG9uQnVmZmVyQXBwZW5kZWQgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdtYWluJykge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgaWYgKHN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8IHN0YXRlID09PSBTdGF0ZS5QQVJTRUQpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIGFwcGVuZGVkXG4gICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IChkYXRhLnBlbmRpbmcgPiAwKTtcbiAgICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jaGVja0FwcGVuZGVkUGFyc2VkICgpIHtcbiAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCAmJiAoIXRoaXMuYXBwZW5kZWQgfHwgIXRoaXMucGVuZGluZ0J1ZmZlcmluZykpIHtcbiAgICAgIGNvbnN0IGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgICAgIGxvZ2dlci5sb2coYG1haW4gYnVmZmVyZWQgOiAke1RpbWVSYW5nZXMudG9TdHJpbmcobWVkaWEuYnVmZmVyZWQpfWApO1xuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICAgIGNvbnN0IHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICAgICAgc3RhdHMudGJ1ZmZlcmVkID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAvLyB3ZSBzaG91bGQgZ2V0IHJpZCBvZiB0aGlzLmZyYWdMYXN0S2Jwc1xuICAgICAgICB0aGlzLmZyYWdMYXN0S2JwcyA9IE1hdGgucm91bmQoOCAqIHN0YXRzLnRvdGFsIC8gKHN0YXRzLnRidWZmZXJlZCAtIHN0YXRzLnRmaXJzdCkpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfQlVGRkVSRUQsIHsgc3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnLCBpZDogJ21haW4nIH0pO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGljaygpO1xuICAgIH1cbiAgfVxuXG4gIG9uRXJyb3IgKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZyB8fMKgdGhpcy5mcmFnQ3VycmVudDtcbiAgICAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBtYWluIGZyYWdtZW50XG4gICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSAnbWFpbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyAwLjUgOiB0b2xlcmFuY2UgbmVlZGVkIGFzIHNvbWUgYnJvd3NlcnMgc3RhbGxzIHBsYXliYWNrIGJlZm9yZSByZWFjaGluZyBidWZmZXJlZCBlbmRcbiAgICBsZXQgbWVkaWFCdWZmZXJlZCA9ICEhdGhpcy5tZWRpYSAmJiBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh0aGlzLm1lZGlhLCB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lKSAmJiBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh0aGlzLm1lZGlhLCB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lICsgMC41KTtcblxuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICBpZiAoIWRhdGEuZmF0YWwpIHtcbiAgICAgICAgLy8ga2VlcCByZXRyeWluZyB1bnRpbCB0aGUgbGltaXQgd2lsbCBiZSByZWFjaGVkXG4gICAgICAgIGlmICgodGhpcy5mcmFnTG9hZEVycm9yICsgMSkgPD0gdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSkge1xuICAgICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dFxuICAgICAgICAgIGxldCBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsIHRoaXMuZnJhZ0xvYWRFcnJvcikgKiB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0KTtcbiAgICAgICAgICBsb2dnZXIud2FybihgbWVkaWFDb250cm9sbGVyOiBmcmFnIGxvYWRpbmcgZmFpbGVkLCByZXRyeSBpbiAke2RlbGF5fSBtc2ApO1xuICAgICAgICAgIHRoaXMucmV0cnlEYXRlID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7XG4gICAgICAgICAgLy8gcmV0cnkgbG9hZGluZyBzdGF0ZVxuICAgICAgICAgIC8vIGlmIGxvYWRlZG1ldGFkYXRhIGlzIG5vdCBzZXQsIGl0IG1lYW5zIHRoYXQgd2UgYXJlIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBvbiBmaXJzdCBmcmFnXG4gICAgICAgICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xuICAgICAgICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5mcmFnTG9hZEVycm9yKys7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihgbWVkaWFDb250cm9sbGVyOiAke2RhdGEuZGV0YWlsc30gcmVhY2hlcyBtYXggcmV0cnksIHJlZGlzcGF0Y2ggYXMgZmF0YWwgLi4uYCk7XG4gICAgICAgICAgLy8gc3dpdGNoIGVycm9yIHRvIGZhdGFsXG4gICAgICAgICAgZGF0YS5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5FUlJPUikge1xuICAgICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICAgIC8vIGlmIGZhdGFsIGVycm9yLCBzdG9wIHByb2Nlc3NpbmdcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYHN0cmVhbUNvbnRyb2xsZXI6ICR7ZGF0YS5kZXRhaWxzfSxzd2l0Y2ggdG8gJHt0aGlzLnN0YXRlfSBzdGF0ZSAuLi5gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIG9mIG5vbiBmYXRhbCBlcnJvciB3aGlsZSBsb2FkaW5nIGxldmVsLCBpZiBsZXZlbCBjb250cm9sbGVyIGlzIG5vdCByZXRyeWluZyB0byBsb2FkIGxldmVsICwgc3dpdGNoIGJhY2sgdG8gSURMRVxuICAgICAgICAgIGlmICghZGF0YS5sZXZlbFJldHJ5ICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAvLyBpZiBpbiBhcHBlbmRpbmcgc3RhdGVcbiAgICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ21haW4nICYmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HIHx8wqB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQpKSB7XG4gICAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXG4gICAgICAgIGlmIChtZWRpYUJ1ZmZlcmVkKSB7XG4gICAgICAgICAgdGhpcy5fcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKHRoaXMuY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsIGJ1dCBicm93c2VyIGlzIHN0aWxsIGNvbXBsYWluaW5nIGFib3V0IGJ1ZmZlciBmdWxsIGVycm9yXG4gICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIG9uIElFL0VkZ2UsIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL3B1bGwvNzA4XG4gICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGZsdXNoIHRoZSB3aG9sZSBidWZmZXIgdG8gcmVjb3ZlclxuICAgICAgICAgIGxvZ2dlci53YXJuKCdidWZmZXIgZnVsbCBlcnJvciBhbHNvIG1lZGlhLmN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgZmx1c2ggZXZlcnl0aGluZycpO1xuICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIC8vIGZsdXNoIGV2ZXJ5dGhpbmdcbiAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgX3JlZHVjZU1heEJ1ZmZlckxlbmd0aCAobWluTGVuZ3RoKSB7XG4gICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmIChjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoID49IG1pbkxlbmd0aCkge1xuICAgICAgLy8gcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIGFzIGl0IG1pZ2h0IGJlIHRvbyBoaWdoLiB3ZSBkbyB0aGlzIHRvIGF2b2lkIGxvb3AgZmx1c2hpbmcgLi4uXG4gICAgICBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoIC89IDI7XG4gICAgICBsb2dnZXIud2FybihgbWFpbjpyZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gJHtjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RofXNgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHRoZSBoZWFsdGggb2YgdGhlIGJ1ZmZlciBhbmQgYXR0ZW1wdHMgdG8gcmVzb2x2ZSBwbGF5YmFjayBzdGFsbHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tCdWZmZXIgKCkge1xuICAgIGNvbnN0IHsgbWVkaWEgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSB8fCBtZWRpYS5yZWFkeVN0YXRlID09PSAwKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGRvbid0IGhhdmUgbWVkaWEgb3IgaWYgdGhlIG1lZGlhIGhhc24ndCBidWZmZXJkIGFueXRoaW5nIHlldCAocmVhZHlTdGF0ZSAwKVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiBtZWRpYTtcbiAgICBjb25zdCBidWZmZXJlZCA9IG1lZGlhQnVmZmVyLmJ1ZmZlcmVkO1xuXG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhICYmIGJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XG4gICAgICB0aGlzLl9zZWVrVG9TdGFydFBvcygpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pbW1lZGlhdGVTd2l0Y2gpIHtcbiAgICAgIHRoaXMuaW1tZWRpYXRlTGV2ZWxTd2l0Y2hFbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nYXBDb250cm9sbGVyLnBvbGwodGhpcy5sYXN0Q3VycmVudFRpbWUsIGJ1ZmZlcmVkKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCAoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9uIGZpcnN0IGZyYWdcbiAgICAvLyBpbiB0aGF0IGNhc2UsIHJlc2V0IHN0YXJ0RnJhZ1JlcXVlc3RlZCBmbGFnXG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uQnVmZmVyRmx1c2hlZCAoKSB7XG4gICAgLyogYWZ0ZXIgc3VjY2Vzc2Z1bCBidWZmZXIgZmx1c2hpbmcsIGZpbHRlciBmbHVzaGVkIGZyYWdtZW50cyBmcm9tIGJ1ZmZlcmVkRnJhZ3NcbiAgICAgIHVzZSBtZWRpYUJ1ZmZlcmVkIGluc3RlYWQgb2YgbWVkaWEgKHNvIHRoYXQgd2Ugd2lsbCBjaGVjayBhZ2FpbnN0IHZpZGVvLmJ1ZmZlcmVkIHJhbmdlcyBpbiBjYXNlIG9mIGFsdCBhdWRpbyB0cmFjaylcbiAgICAqL1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgLy8gZmlsdGVyIGZyYWdtZW50cyBwb3RlbnRpYWxseSBldmljdGVkIGZyb20gYnVmZmVyLiB0aGlzIGlzIHRvIGF2b2lkIG1lbWxlYWsgb24gbGl2ZSBzdHJlYW1zXG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5kZXRlY3RFdmljdGVkRnJhZ21lbnRzKEZyYWdtZW50LkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTywgbWVkaWEuYnVmZmVyZWQpO1xuICAgIH1cbiAgICAvLyBtb3ZlIHRvIElETEUgb25jZSBmbHVzaCBjb21wbGV0ZS4gdGhpcyBzaG91bGQgdHJpZ2dlciBuZXcgZnJhZ21lbnQgbG9hZGluZ1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIC8vIHJlc2V0IHJlZmVyZW5jZSB0byBmcmFnXG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICB9XG5cbiAgc3dhcEF1ZGlvQ29kZWMgKCkge1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3YXAgPSAhdGhpcy5hdWRpb0NvZGVjU3dhcDtcbiAgfVxuXG4gIGNvbXB1dGVMaXZlUG9zaXRpb24gKHNsaWRpbmcsIGxldmVsRGV0YWlscykge1xuICAgIGxldCB0YXJnZXRMYXRlbmN5ID0gdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy5jb25maWcubGl2ZVN5bmNEdXJhdGlvbiA6IHRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCAqIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgICByZXR1cm4gc2xpZGluZyArIE1hdGgubWF4KDAsIGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uIC0gdGFyZ2V0TGF0ZW5jeSk7XG4gIH1cblxuICAvKipcbiAgICogU2Vla3MgdG8gdGhlIHNldCBzdGFydFBvc2l0aW9uIGlmIG5vdCBlcXVhbCB0byB0aGUgbWVkaWFFbGVtZW50J3MgY3VycmVudCB0aW1lLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlZWtUb1N0YXJ0UG9zICgpIHtcbiAgICBjb25zdCB7IG1lZGlhIH0gPSB0aGlzO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgLy8gb25seSBhZGp1c3QgY3VycmVudFRpbWUgaWYgZGlmZmVyZW50IGZyb20gc3RhcnRQb3NpdGlvbiBvciBpZiBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZFxuICAgIC8vIGF0IHRoYXQgc3RhZ2UsIHRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBidWZmZXJlZCByYW5nZSwgYXMgd2UgcmVhY2ggdGhhdCBjb2RlIGFmdGVyIGZpcnN0IGZyYWdtZW50IGhhcyBiZWVuIGJ1ZmZlcmVkXG4gICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IG1lZGlhLnNlZWtpbmcgPyBjdXJyZW50VGltZSA6IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAvLyBpZiBjdXJyZW50VGltZSBub3QgbWF0Y2hpbmcgd2l0aCBleHBlY3RlZCBzdGFydFBvc2l0aW9uIG9yIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkIGJ1dCBjbG9zZSB0byBmaXJzdCBidWZmZXJlZFxuICAgIGlmIChjdXJyZW50VGltZSAhPT0gc3RhcnRQb3NpdGlvbikge1xuICAgICAgLy8gaWYgc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWQsIGxldCdzIHNlZWsgdG8gYnVmZmVyZWQuc3RhcnQoMClcbiAgICAgIGxvZ2dlci5sb2coYHRhcmdldCBzdGFydCBwb3NpdGlvbiBub3QgYnVmZmVyZWQsIHNlZWsgdG8gYnVmZmVyZWQuc3RhcnQoMCkgJHtzdGFydFBvc2l0aW9ufSBmcm9tIGN1cnJlbnQgdGltZSAke2N1cnJlbnRUaW1lfSBgKTtcbiAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICBfZ2V0QXVkaW9Db2RlYyAoY3VycmVudExldmVsKSB7XG4gICAgbGV0IGF1ZGlvQ29kZWMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcbiAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dhcCkge1xuICAgICAgbG9nZ2VyLmxvZygnc3dhcHBpbmcgcGxheWxpc3QgYXVkaW8gY29kZWMnKTtcbiAgICAgIGlmIChhdWRpb0NvZGVjKSB7XG4gICAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXVkaW9Db2RlYztcbiAgfVxuXG4gIGdldCBsaXZlU3luY1Bvc2l0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGl2ZVN5bmNQb3NpdGlvbjtcbiAgfVxuXG4gIHNldCBsaXZlU3luY1Bvc2l0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX2xpdmVTeW5jUG9zaXRpb24gPSB2YWx1ZTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgU3RyZWFtQ29udHJvbGxlcjtcbiIsIi8qKlxuICogQGNsYXNzIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlclxuICovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCBEZWNyeXB0ZXIgZnJvbSAnLi4vY3J5cHQvZGVjcnlwdGVyJztcbmltcG9ydCB7IEJ1ZmZlckhlbHBlciB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IHsgZmluZEZyYWdtZW50QnlQRFQsIGZpbmRGcmFnbWVudEJ5UFRTIH0gZnJvbSAnLi9mcmFnbWVudC1maW5kZXJzJztcbmltcG9ydCB7IEZyYWdtZW50U3RhdGUgfSBmcm9tICcuL2ZyYWdtZW50LXRyYWNrZXInO1xuaW1wb3J0IEJhc2VTdHJlYW1Db250cm9sbGVyLCB7IFN0YXRlIH0gZnJvbSAnLi9iYXNlLXN0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCB7IG1lcmdlU3VidGl0bGVQbGF5bGlzdHMgfSBmcm9tICcuL2xldmVsLWhlbHBlcic7XG5cbmNvbnN0IHsgcGVyZm9ybWFuY2UgfSA9IHdpbmRvdztcbmNvbnN0IFRJQ0tfSU5URVJWQUwgPSA1MDA7IC8vIGhvdyBvZnRlbiB0byB0aWNrIGluIG1zXG5cbmV4cG9ydCBjbGFzcyBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlU3RyZWFtQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMsIGZyYWdtZW50VHJhY2tlcikge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSEVELFxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxuICAgICAgRXZlbnQuRVJST1IsXG4gICAgICBFdmVudC5LRVlfTE9BREVELFxuICAgICAgRXZlbnQuRlJBR19MT0FERUQsXG4gICAgICBFdmVudC5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCxcbiAgICAgIEV2ZW50LlNVQlRJVExFX1RSQUNLX1NXSVRDSCxcbiAgICAgIEV2ZW50LlNVQlRJVExFX1RSQUNLX0xPQURFRCxcbiAgICAgIEV2ZW50LlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELFxuICAgICAgRXZlbnQuTEVWRUxfVVBEQVRFRCk7XG5cbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IGZyYWdtZW50VHJhY2tlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkID0gW107XG4gICAgdGhpcy5jdXJyZW50VHJhY2tJZCA9IC0xO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcihobHMsIGhscy5jb25maWcpO1xuICAgIC8vIGxhc3RBVlN0YXJ0IHN0b3JlcyB0aGUgdGltZSBpbiBzZWNvbmRzIGZvciB0aGUgc3RhcnQgdGltZSBvZiBhIGxldmVsIGxvYWRcbiAgICB0aGlzLmxhc3RBVlN0YXJ0ID0gMDtcbiAgICB0aGlzLl9vbk1lZGlhU2Vla2luZyA9IHRoaXMub25NZWRpYVNlZWtpbmcuYmluZCh0aGlzKTtcbiAgfVxuXG4gIG9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkIChkYXRhKSB7XG4gICAgY29uc3QgeyBmcmFnLCBzdWNjZXNzIH0gPSBkYXRhO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXJlZCA9IHRoaXMudHJhY2tzQnVmZmVyZWRbdGhpcy5jdXJyZW50VHJhY2tJZF07XG4gICAgaWYgKCFidWZmZXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZS91cGRhdGUgYSBidWZmZXJlZCBhcnJheSBtYXRjaGluZyB0aGUgaW50ZXJmYWNlIHVzZWQgYnkgQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mb1xuICAgIC8vIHNvIHdlIGNhbiByZS11c2UgdGhlIGxvZ2ljIHVzZWQgdG8gZGV0ZWN0IGhvdyBtdWNoIGhhdmUgYmVlbiBidWZmZXJlZFxuICAgIGxldCB0aW1lUmFuZ2U7XG4gICAgY29uc3QgZnJhZ1N0YXJ0ID0gZnJhZy5zdGFydDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZnJhZ1N0YXJ0ID49IGJ1ZmZlcmVkW2ldLnN0YXJ0ICYmIGZyYWdTdGFydCA8PSBidWZmZXJlZFtpXS5lbmQpIHtcbiAgICAgICAgdGltZVJhbmdlID0gYnVmZmVyZWRbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZyYWdFbmQgPSBmcmFnLnN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgICBpZiAodGltZVJhbmdlKSB7XG4gICAgICB0aW1lUmFuZ2UuZW5kID0gZnJhZ0VuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZVJhbmdlID0ge1xuICAgICAgICBzdGFydDogZnJhZ1N0YXJ0LFxuICAgICAgICBlbmQ6IGZyYWdFbmRcbiAgICAgIH07XG4gICAgICBidWZmZXJlZC5wdXNoKHRpbWVSYW5nZSk7XG4gICAgfVxuICB9XG5cbiAgb25NZWRpYUF0dGFjaGVkICh7IG1lZGlhIH0pIHtcbiAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMuX29uTWVkaWFTZWVraW5nKTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcgKCkge1xuICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMuX29uTWVkaWFTZWVraW5nKTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgfVxuXG4gIC8vIElmIHNvbWV0aGluZyBnb2VzIHdyb25nLCBwcm9jZWVkIHRvIG5leHQgZnJhZywgaWYgd2Ugd2VyZSBwcm9jZXNzaW5nIG9uZS5cbiAgb25FcnJvciAoZGF0YSkge1xuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIC8vIGRvbid0IGhhbmRsZSBlcnJvciBub3QgcmVsYXRlZCB0byBzdWJ0aXRsZSBmcmFnbWVudFxuICAgIGlmICghZnJhZyB8fCBmcmFnLnR5cGUgIT09ICdzdWJ0aXRsZScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gIH1cblxuICAvLyBHb3QgYWxsIG5ldyBzdWJ0aXRsZSB0cmFja3MuXG4gIG9uU3VidGl0bGVUcmFja3NVcGRhdGVkIChkYXRhKSB7XG4gICAgbG9nZ2VyLmxvZygnc3VidGl0bGUgdHJhY2tzIHVwZGF0ZWQnKTtcbiAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkID0gW107XG4gICAgdGhpcy50cmFja3MgPSBkYXRhLnN1YnRpdGxlVHJhY2tzO1xuICAgIHRoaXMudHJhY2tzLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkW3RyYWNrLmlkXSA9IFtdO1xuICAgIH0pO1xuICB9XG5cbiAgb25TdWJ0aXRsZVRyYWNrU3dpdGNoIChkYXRhKSB7XG4gICAgdGhpcy5jdXJyZW50VHJhY2tJZCA9IGRhdGEuaWQ7XG5cbiAgICBpZiAoIXRoaXMudHJhY2tzIHx8IHRoaXMuY3VycmVudFRyYWNrSWQgPT09IC0xKSB7XG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0cmFjayBoYXMgdGhlIG5lY2Vzc2FyeSBkZXRhaWxzIHRvIGxvYWQgZnJhZ21lbnRzXG4gICAgY29uc3QgY3VycmVudFRyYWNrID0gdGhpcy50cmFja3NbdGhpcy5jdXJyZW50VHJhY2tJZF07XG4gICAgaWYgKGN1cnJlbnRUcmFjayAmJiBjdXJyZW50VHJhY2suZGV0YWlscykge1xuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICB9XG4gIH1cblxuICAvLyBHb3QgYSBuZXcgc2V0IG9mIHN1YnRpdGxlIGZyYWdtZW50cy5cbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGVkIChkYXRhKSB7XG4gICAgY29uc3QgeyBpZCwgZGV0YWlscyB9ID0gZGF0YTtcbiAgICBjb25zdCB7IGN1cnJlbnRUcmFja0lkLCB0cmFja3MgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRyYWNrID0gdHJhY2tzW2N1cnJlbnRUcmFja0lkXTtcbiAgICBpZiAoaWQgPj0gdHJhY2tzLmxlbmd0aCB8fCBpZCAhPT0gY3VycmVudFRyYWNrSWQgfHwgIWN1cnJlbnRUcmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkZXRhaWxzLmxpdmUpIHtcbiAgICAgIG1lcmdlU3VidGl0bGVQbGF5bGlzdHMoY3VycmVudFRyYWNrLmRldGFpbHMsIGRldGFpbHMsIHRoaXMubGFzdEFWU3RhcnQpO1xuICAgIH1cbiAgICBjdXJyZW50VHJhY2suZGV0YWlscyA9IGRldGFpbHM7XG4gICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgfVxuXG4gIG9uS2V5TG9hZGVkICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuS0VZX0xPQURJTkcpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0xvYWRlZCAoZGF0YSkge1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBjb25zdCBkZWNyeXB0RGF0YSA9IGRhdGEuZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICBjb25zdCBmcmFnTG9hZGVkID0gZGF0YS5mcmFnO1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyAmJlxuICAgICAgICBmcmFnQ3VycmVudCAmJlxuICAgICAgICBkYXRhLmZyYWcudHlwZSA9PT0gJ3N1YnRpdGxlJyAmJlxuICAgICAgICBmcmFnQ3VycmVudC5zbiA9PT0gZGF0YS5mcmFnLnNuKSB7XG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHBheWxvYWQgbmVlZHMgdG8gYmUgZGVjcnlwdGVkXG4gICAgICBpZiAoZGF0YS5wYXlsb2FkLmJ5dGVMZW5ndGggPiAwICYmIChkZWNyeXB0RGF0YSAmJiBkZWNyeXB0RGF0YS5rZXkgJiYgZGVjcnlwdERhdGEubWV0aG9kID09PSAnQUVTLTEyOCcpKSB7XG4gICAgICAgIGxldCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgICAvLyBkZWNyeXB0IHRoZSBzdWJ0aXRsZXNcbiAgICAgICAgdGhpcy5kZWNyeXB0ZXIuZGVjcnlwdChkYXRhLnBheWxvYWQsIGRlY3J5cHREYXRhLmtleS5idWZmZXIsIGRlY3J5cHREYXRhLml2LmJ1ZmZlciwgZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICBsZXQgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZSQUdfREVDUllQVEVELCB7IGZyYWc6IGZyYWdMb2FkZWQsIHBheWxvYWQ6IGRlY3J5cHRlZERhdGEsIHN0YXRzOiB7IHRzdGFydDogc3RhcnRUaW1lLCB0ZGVjcnlwdDogZW5kVGltZSB9IH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkxldmVsVXBkYXRlZCAoeyBkZXRhaWxzIH0pIHtcbiAgICBjb25zdCBmcmFncyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAgIHRoaXMubGFzdEFWU3RhcnQgPSBmcmFncy5sZW5ndGggPyBmcmFnc1swXS5zdGFydCA6IDA7XG4gIH1cblxuICBkb1RpY2sgKCkge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgY2FzZSBTdGF0ZS5JRExFOiB7XG4gICAgICBjb25zdCB7IGNvbmZpZywgY3VycmVudFRyYWNrSWQsIGZyYWdtZW50VHJhY2tlciwgbWVkaWEsIHRyYWNrcyB9ID0gdGhpcztcbiAgICAgIGlmICghdHJhY2tzIHx8ICF0cmFja3NbY3VycmVudFRyYWNrSWRdIHx8ICF0cmFja3NbY3VycmVudFRyYWNrSWRdLmRldGFpbHMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgbWF4QnVmZmVySG9sZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB9ID0gY29uZmlnO1xuICAgICAgY29uc3QgbWF4Q29uZmlnQnVmZmVyID0gTWF0aC5taW4oY29uZmlnLm1heEJ1ZmZlckxlbmd0aCwgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCk7XG4gICAgICBjb25zdCBidWZmZXJlZEluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVyZWRJbmZvKHRoaXMuX2dldEJ1ZmZlcmVkKCksIG1lZGlhLmN1cnJlbnRUaW1lLCBtYXhCdWZmZXJIb2xlKTtcbiAgICAgIGNvbnN0IHsgZW5kOiBidWZmZXJFbmQsIGxlbjogYnVmZmVyTGVuIH0gPSBidWZmZXJlZEluZm87XG5cbiAgICAgIGNvbnN0IHRyYWNrRGV0YWlscyA9IHRyYWNrc1tjdXJyZW50VHJhY2tJZF0uZGV0YWlscztcbiAgICAgIGNvbnN0IGZyYWdtZW50cyA9IHRyYWNrRGV0YWlscy5mcmFnbWVudHM7XG4gICAgICBjb25zdCBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgIGNvbnN0IGVuZCA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uc3RhcnQgKyBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdLmR1cmF0aW9uO1xuXG4gICAgICBpZiAoYnVmZmVyTGVuID4gbWF4Q29uZmlnQnVmZmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGZvdW5kRnJhZztcbiAgICAgIGNvbnN0IGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuICAgICAgaWYgKGJ1ZmZlckVuZCA8IGVuZCkge1xuICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzICYmIHRyYWNrRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgICBmb3VuZEZyYWcgPSBmaW5kRnJhZ21lbnRCeVBEVChmcmFnbWVudHMsIGZyYWdQcmV2aW91cy5lbmRQcm9ncmFtRGF0ZVRpbWUsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm91bmRGcmFnKSB7XG4gICAgICAgICAgZm91bmRGcmFnID0gZmluZEZyYWdtZW50QnlQVFMoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZEZyYWcgJiYgZm91bmRGcmFnLmVuY3J5cHRlZCkge1xuICAgICAgICBsb2dnZXIubG9nKGBMb2FkaW5nIGtleSBmb3IgJHtmb3VuZEZyYWcuc259YCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5LRVlfTE9BRElORywgeyBmcmFnOiBmb3VuZEZyYWcgfSk7XG4gICAgICB9IGVsc2UgaWYgKGZvdW5kRnJhZyAmJiBmcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZm91bmRGcmFnKSA9PT0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEKSB7XG4gICAgICAgIC8vIG9ubHkgbG9hZCBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmb3VuZEZyYWc7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19MT0FESU5HLCB7IGZyYWc6IGZvdW5kRnJhZyB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RvcExvYWQgKCkge1xuICAgIHRoaXMubGFzdEFWU3RhcnQgPSAwO1xuICAgIHN1cGVyLnN0b3BMb2FkKCk7XG4gIH1cblxuICBfZ2V0QnVmZmVyZWQgKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrc0J1ZmZlcmVkW3RoaXMuY3VycmVudFRyYWNrSWRdIHx8IFtdO1xuICB9XG5cbiAgb25NZWRpYVNlZWtpbmcgKCkge1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgfVxufVxuIiwiaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IGNvbXB1dGVSZWxvYWRJbnRlcnZhbCB9IGZyb20gJy4vbGV2ZWwtaGVscGVyJztcblxuY2xhc3MgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNIRUQsXG4gICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FERUQsXG4gICAgICBFdmVudC5TVUJUSVRMRV9UUkFDS19MT0FERUQpO1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IHN1YnRpdGxlRGlzcGxheSBFbmFibGUvZGlzYWJsZSBzdWJ0aXRsZSBkaXNwbGF5IHJlbmRlcmluZ1xuICAgICAqL1xuICAgIHRoaXMuc3VidGl0bGVEaXNwbGF5ID0gdHJ1ZTtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLy8gTGlzdGVuIGZvciBzdWJ0aXRsZSB0cmFjayBjaGFuZ2UsIHRoZW4gZXh0cmFjdCB0aGUgY3VycmVudCB0cmFjayBJRC5cbiAgb25NZWRpYUF0dGFjaGVkIChkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucXVldWVkRGVmYXVsdFRyYWNrKSB7XG4gICAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjaztcbiAgICAgIGRlbGV0ZSB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjaztcbiAgICB9XG5cbiAgICB0aGlzLnRyYWNrQ2hhbmdlTGlzdGVuZXIgPSB0aGlzLl9vblRleHRUcmFja3NDaGFuZ2VkLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcgPSAhKHRoaXMubWVkaWEudGV4dFRyYWNrcyAmJiAnb25jaGFuZ2UnIGluIHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG4gICAgaWYgKHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xuICAgICAgdGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgdGhpcy50cmFja0NoYW5nZUxpc3RlbmVyKCk7XG4gICAgICB9LCA1MDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhLnRleHRUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy50cmFja0NoYW5nZUxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuICBvbk1lZGlhRGV0YWNoaW5nICgpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhLnRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy50cmFja0NoYW5nZUxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfVxuXG4gIC8vIEZpcmVkIHdoZW5ldmVyIGEgbmV3IG1hbmlmZXN0IGlzIGxvYWRlZC5cbiAgb25NYW5pZmVzdExvYWRlZCAoZGF0YSkge1xuICAgIGxldCB0cmFja3MgPSBkYXRhLnN1YnRpdGxlcyB8fCBbXTtcbiAgICB0aGlzLnRyYWNrcyA9IHRyYWNrcztcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB7IHN1YnRpdGxlVHJhY2tzOiB0cmFja3MgfSk7XG5cbiAgICAvLyBsb29wIHRocm91Z2ggYXZhaWxhYmxlIHN1YnRpdGxlIHRyYWNrcyBhbmQgYXV0b3NlbGVjdCBkZWZhdWx0IGlmIG5lZWRlZFxuICAgIC8vIFRPRE86IGltcHJvdmUgc2VsZWN0aW9uIGxvZ2ljIHRvIGhhbmRsZSBmb3JjZWQsIGV0Y1xuICAgIHRyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIGlmICh0cmFjay5kZWZhdWx0KSB7XG4gICAgICAgIC8vIHNldHRpbmcgdGhpcy5zdWJ0aXRsZVRyYWNrIHdpbGwgdHJpZ2dlciBpbnRlcm5hbCBsb2dpY1xuICAgICAgICAvLyBpZiBtZWRpYSBoYXMgbm90IGJlZW4gYXR0YWNoZWQgeWV0LCBpdCB3aWxsIGZhaWxcbiAgICAgICAgLy8gd2Uga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgZGVmYXVsdCB0cmFjayBpZFxuICAgICAgICAvLyBhbmQgd2UnbGwgc2V0IHN1YnRpdGxlVHJhY2sgd2hlbiBvbk1lZGlhQXR0YWNoZWQgaXMgdHJpZ2dlcmVkXG4gICAgICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdHJhY2suaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPSB0cmFjay5pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGVkIChkYXRhKSB7XG4gICAgY29uc3QgeyBpZCwgZGV0YWlscyB9ID0gZGF0YTtcbiAgICBjb25zdCB7IHRyYWNrSWQsIHRyYWNrcyB9ID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0cmFja3NbdHJhY2tJZF07XG4gICAgaWYgKGlkID49IHRyYWNrcy5sZW5ndGggfHwgaWQgIT09IHRyYWNrSWQgfHwgIWN1cnJlbnRUcmFjayB8fCB0aGlzLnN0b3BwZWQpIHtcbiAgICAgIHRoaXMuX2NsZWFyUmVsb2FkVGltZXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2dnZXIubG9nKGBzdWJ0aXRsZSB0cmFjayAke2lkfSBsb2FkZWRgKTtcbiAgICBpZiAoZGV0YWlscy5saXZlKSB7XG4gICAgICBjb25zdCByZWxvYWRJbnRlcnZhbCA9IGNvbXB1dGVSZWxvYWRJbnRlcnZhbChjdXJyZW50VHJhY2suZGV0YWlscywgZGV0YWlscywgZGF0YS5zdGF0cy50cmVxdWVzdCk7XG4gICAgICBsb2dnZXIubG9nKGBSZWxvYWRpbmcgbGl2ZSBzdWJ0aXRsZSBwbGF5bGlzdCBpbiAke3JlbG9hZEludGVydmFsfW1zYCk7XG4gICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xvYWRDdXJyZW50VHJhY2soKTtcbiAgICAgIH0sIHJlbG9hZEludGVydmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY2xlYXJSZWxvYWRUaW1lcigpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXJ0TG9hZCAoKSB7XG4gICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5fbG9hZEN1cnJlbnRUcmFjaygpO1xuICB9XG5cbiAgc3RvcExvYWQgKCkge1xuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgdGhpcy5fY2xlYXJSZWxvYWRUaW1lcigpO1xuICB9XG5cbiAgLyoqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdCAqKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2tzICgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3M7XG4gIH1cblxuICAvKiogZ2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpICoqL1xuICBnZXQgc3VidGl0bGVUcmFjayAoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tJZDtcbiAgfVxuXG4gIC8qKiBzZWxlY3QgYSBzdWJ0aXRsZSB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKiovXG4gIHNldCBzdWJ0aXRsZVRyYWNrIChzdWJ0aXRsZVRyYWNrSWQpIHtcbiAgICBpZiAodGhpcy50cmFja0lkICE9PSBzdWJ0aXRsZVRyYWNrSWQpIHtcbiAgICAgIHRoaXMuX3RvZ2dsZVRyYWNrTW9kZXMoc3VidGl0bGVUcmFja0lkKTtcbiAgICAgIHRoaXMuX3NldFN1YnRpdGxlVHJhY2tJbnRlcm5hbChzdWJ0aXRsZVRyYWNrSWQpO1xuICAgIH1cbiAgfVxuXG4gIF9jbGVhclJlbG9hZFRpbWVyICgpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgX2xvYWRDdXJyZW50VHJhY2sgKCkge1xuICAgIGNvbnN0IHsgdHJhY2tJZCwgdHJhY2tzLCBobHMgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRyYWNrID0gdHJhY2tzW3RyYWNrSWRdO1xuICAgIGlmICh0cmFja0lkIDwgMCB8fCAhY3VycmVudFRyYWNrIHx8IChjdXJyZW50VHJhY2suZGV0YWlscyAmJiAhY3VycmVudFRyYWNrLmRldGFpbHMubGl2ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyLmxvZyhgTG9hZGluZyBzdWJ0aXRsZSB0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfVFJBQ0tfTE9BRElORywgeyB1cmw6IGN1cnJlbnRUcmFjay51cmwsIGlkOiB0cmFja0lkIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBvbGQgc3VidGl0bGVUcmFjayBhbmQgc2V0cyBjdXJyZW50IG1vZGUgb24gdGhlIG5leHQgc3VidGl0bGVUcmFjay5cbiAgICogVGhpcyBvcGVyYXRlcyBvbiB0aGUgRE9NIHRleHRUcmFja3MuXG4gICAqIEEgdmFsdWUgb2YgLTEgd2lsbCBkaXNhYmxlIGFsbCBzdWJ0aXRsZSB0cmFja3MuXG4gICAqIEBwYXJhbSBuZXdJZCAtIFRoZSBpZCBvZiB0aGUgbmV4dCB0cmFjayB0byBlbmFibGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90b2dnbGVUcmFja01vZGVzIChuZXdJZCkge1xuICAgIGNvbnN0IHsgbWVkaWEsIHN1YnRpdGxlRGlzcGxheSwgdHJhY2tJZCB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dFRyYWNrcyA9IGZpbHRlclN1YnRpdGxlVHJhY2tzKG1lZGlhLnRleHRUcmFja3MpO1xuICAgIGlmIChuZXdJZCA9PT0gLTEpIHtcbiAgICAgIFtdLnNsaWNlLmNhbGwodGV4dFRyYWNrcykuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgIHRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9sZFRyYWNrID0gdGV4dFRyYWNrc1t0cmFja0lkXTtcbiAgICAgIGlmIChvbGRUcmFjaykge1xuICAgICAgICBvbGRUcmFjay5tb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBuZXh0VHJhY2sgPSB0ZXh0VHJhY2tzW25ld0lkXTtcbiAgICBpZiAobmV4dFRyYWNrKSB7XG4gICAgICBuZXh0VHJhY2subW9kZSA9IHN1YnRpdGxlRGlzcGxheSA/ICdzaG93aW5nJyA6ICdoaWRkZW4nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHJlc3BvbnNpYmxlIGZvciB2YWxpZGF0aW5nIHRoZSBzdWJ0aXRsZSBpbmRleCBhbmQgcGVyaW9kaWNhbGx5IHJlbG9hZGluZyBpZiBsaXZlLlxuICAgICAqIERpc3BhdGNoZXMgdGhlIFNVQlRJVExFX1RSQUNLX1NXSVRDSCBldmVudCwgd2hpY2ggaW5zdHJ1Y3RzIHRoZSBzdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlciB0byBsb2FkIHRoZSBzZWxlY3RlZCB0cmFjay5cbiAgICAgKiBAcGFyYW0gbmV3SWQgLSBUaGUgaWQgb2YgdGhlIHN1YnRpdGxlIHRyYWNrIHRvIGFjdGl2YXRlLlxuICAgICAqL1xuICBfc2V0U3VidGl0bGVUcmFja0ludGVybmFsIChuZXdJZCkge1xuICAgIGNvbnN0IHsgaGxzLCB0cmFja3MgfSA9IHRoaXM7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobmV3SWQpIHx8IG5ld0lkIDwgLTEgfHwgbmV3SWQgPj0gdHJhY2tzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudHJhY2tJZCA9IG5ld0lkO1xuICAgIGxvZ2dlci5sb2coYFN3aXRjaGluZyB0byBzdWJ0aXRsZSB0cmFjayAke25ld0lkfWApO1xuICAgIGhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX1RSQUNLX1NXSVRDSCwgeyBpZDogbmV3SWQgfSk7XG4gICAgdGhpcy5fbG9hZEN1cnJlbnRUcmFjaygpO1xuICB9XG5cbiAgX29uVGV4dFRyYWNrc0NoYW5nZWQgKCkge1xuICAgIC8vIE1lZGlhIGlzIHVuZGVmaW5lZCB3aGVuIHN3aXRjaGluZyBzdHJlYW1zIHZpYSBsb2FkU291cmNlKClcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgdHJhY2tJZCA9IC0xO1xuICAgIGxldCB0cmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyh0aGlzLm1lZGlhLnRleHRUcmFja3MpO1xuICAgIGZvciAobGV0IGlkID0gMDsgaWQgPCB0cmFja3MubGVuZ3RoOyBpZCsrKSB7XG4gICAgICBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnaGlkZGVuJykge1xuICAgICAgICAvLyBEbyBub3QgYnJlYWsgaW4gY2FzZSB0aGVyZSBpcyBhIGZvbGxvd2luZyB0cmFjayB3aXRoIHNob3dpbmcuXG4gICAgICAgIHRyYWNrSWQgPSBpZDtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgdHJhY2tJZCA9IGlkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXR0aW5nIGN1cnJlbnQgc3VidGl0bGVUcmFjayB3aWxsIGludm9rZSBjb2RlLlxuICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IHRyYWNrSWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmlsdGVyU3VidGl0bGVUcmFja3MgKHRleHRUcmFja0xpc3QpIHtcbiAgbGV0IHRyYWNrcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHRUcmFja0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0cmFjayA9IHRleHRUcmFja0xpc3RbaV07XG4gICAgLy8gRWRnZSBhZGRzIGEgdHJhY2sgd2l0aG91dCBhIGxhYmVsOyB3ZSBkb24ndCB3YW50IHRvIHVzZSBpdFxuICAgIGlmICh0cmFjay5raW5kID09PSAnc3VidGl0bGVzJyAmJiB0cmFjay5sYWJlbCkge1xuICAgICAgdHJhY2tzLnB1c2godGV4dFRyYWNrTGlzdFtpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFja3M7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuIiwiLypcbiAqIFRpbWVsaW5lIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCBDZWE2MDhQYXJzZXIgZnJvbSAnLi4vdXRpbHMvY2VhLTYwOC1wYXJzZXInO1xuaW1wb3J0IE91dHB1dEZpbHRlciBmcm9tICcuLi91dGlscy9vdXRwdXQtZmlsdGVyJztcbmltcG9ydCBXZWJWVFRQYXJzZXIgZnJvbSAnLi4vdXRpbHMvd2VidnR0LXBhcnNlcic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgc2VuZEFkZFRyYWNrRXZlbnQsIGNsZWFyQ3VycmVudEN1ZXMgfSBmcm9tICcuLi91dGlscy90ZXh0dHJhY2stdXRpbHMnO1xuXG5mdW5jdGlvbiBjYW5SZXVzZVZ0dFRleHRUcmFjayAoaW5Vc2VUcmFjaywgbWFuaWZlc3RUcmFjaykge1xuICByZXR1cm4gaW5Vc2VUcmFjayAmJiBpblVzZVRyYWNrLmxhYmVsID09PSBtYW5pZmVzdFRyYWNrLm5hbWUgJiYgIShpblVzZVRyYWNrLnRleHRUcmFjazEgfHwgaW5Vc2VUcmFjay50ZXh0VHJhY2syKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uICh4MSwgeDIsIHkxLCB5Mikge1xuICByZXR1cm4gTWF0aC5taW4oeDIsIHkyKSAtIE1hdGgubWF4KHgxLCB5MSk7XG59XG5cbmNsYXNzIFRpbWVsaW5lQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsIEV2ZW50Lk1FRElBX0FUVEFDSElORyxcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcbiAgICAgIEV2ZW50LkZSQUdfUEFSU0lOR19VU0VSREFUQSxcbiAgICAgIEV2ZW50LkZSQUdfREVDUllQVEVELFxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxuICAgICAgRXZlbnQuTEVWRUxfU1dJVENISU5HLFxuICAgICAgRXZlbnQuSU5JVF9QVFNfRk9VTkQpO1xuXG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5DdWVzID0gaGxzLmNvbmZpZy5jdWVIYW5kbGVyO1xuICAgIHRoaXMudGV4dFRyYWNrcyA9IFtdO1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgdGhpcy5pbml0UFRTID0gW107XG4gICAgdGhpcy5jdWVSYW5nZXMgPSBbXTtcbiAgICB0aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG5cbiAgICB0aGlzLmNhcHRpb25zUHJvcGVydGllcyA9IHtcbiAgICAgIHRleHRUcmFjazE6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhbmd1YWdlQ29kZVxuICAgICAgfSxcbiAgICAgIHRleHRUcmFjazI6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhbmd1YWdlQ29kZVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMpIHtcbiAgICAgIGxldCBjaGFubmVsMSA9IG5ldyBPdXRwdXRGaWx0ZXIodGhpcywgJ3RleHRUcmFjazEnKTtcbiAgICAgIGxldCBjaGFubmVsMiA9IG5ldyBPdXRwdXRGaWx0ZXIodGhpcywgJ3RleHRUcmFjazInKTtcblxuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIgPSBuZXcgQ2VhNjA4UGFyc2VyKDAsIGNoYW5uZWwxLCBjaGFubmVsMik7XG4gICAgfVxuICB9XG5cbiAgYWRkQ3VlcyAodHJhY2tOYW1lLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbikge1xuICAgIC8vIHNraXAgY3VlcyB3aGljaCBvdmVybGFwIG1vcmUgdGhhbiA1MCUgd2l0aCBwcmV2aW91c2x5IHBhcnNlZCB0aW1lIHJhbmdlc1xuICAgIGNvbnN0IHJhbmdlcyA9IHRoaXMuY3VlUmFuZ2VzO1xuICAgIGxldCBtZXJnZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gcmFuZ2VzLmxlbmd0aDsgaS0tOykge1xuICAgICAgbGV0IGN1ZVJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgbGV0IG92ZXJsYXAgPSBpbnRlcnNlY3Rpb24oY3VlUmFuZ2VbMF0sIGN1ZVJhbmdlWzFdLCBzdGFydFRpbWUsIGVuZFRpbWUpO1xuICAgICAgaWYgKG92ZXJsYXAgPj0gMCkge1xuICAgICAgICBjdWVSYW5nZVswXSA9IE1hdGgubWluKGN1ZVJhbmdlWzBdLCBzdGFydFRpbWUpO1xuICAgICAgICBjdWVSYW5nZVsxXSA9IE1hdGgubWF4KGN1ZVJhbmdlWzFdLCBlbmRUaW1lKTtcbiAgICAgICAgbWVyZ2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKChvdmVybGFwIC8gKGVuZFRpbWUgLSBzdGFydFRpbWUpKSA+IDAuNSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW1lcmdlZCkge1xuICAgICAgcmFuZ2VzLnB1c2goW3N0YXJ0VGltZSwgZW5kVGltZV0pO1xuICAgIH1cblxuICAgIHRoaXMuQ3Vlcy5uZXdDdWUodGhpcy5jYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gIH1cblxuICAvLyBUcmlnZ2VyZWQgd2hlbiBhbiBpbml0aWFsIFBUUyBpcyBmb3VuZDsgdXNlZCBmb3Igc3luY2hyb25pc2F0aW9uIG9mIFdlYlZUVC5cbiAgb25Jbml0UHRzRm91bmQgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5pZCA9PT0gJ21haW4nKSB7XG4gICAgICB0aGlzLmluaXRQVFNbZGF0YS5mcmFnLmNjXSA9IGRhdGEuaW5pdFBUUztcbiAgICB9XG5cbiAgICAvLyBEdWUgdG8gYXN5bmNocm9ub3VzIHByb2Nlc3NpbmcsIGluaXRpYWwgUFRTIG1heSBhcnJpdmUgbGF0ZXIgdGhhbiB0aGUgZmlyc3QgVlRUIGZyYWdtZW50cyBhcmUgbG9hZGVkLlxuICAgIC8vIFBhcnNlIGFueSB1bnBhcnNlZCBmcmFnbWVudHMgdXBvbiByZWNlaXZpbmcgdGhlIGluaXRpYWwgUFRTLlxuICAgIGlmICh0aGlzLnVucGFyc2VkVnR0RnJhZ3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCB1bnBhcnNlZFZ0dEZyYWdzID0gdGhpcy51bnBhcnNlZFZ0dEZyYWdzO1xuICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgICB1bnBhcnNlZFZ0dEZyYWdzLmZvckVhY2goZnJhZyA9PiB7XG4gICAgICAgIHRoaXMub25GcmFnTG9hZGVkKGZyYWcpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0RXhpc3RpbmdUcmFjayAodHJhY2tOYW1lKSB7XG4gICAgY29uc3QgeyBtZWRpYSB9ID0gdGhpcztcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVkaWEudGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgdGV4dFRyYWNrID0gbWVkaWEudGV4dFRyYWNrc1tpXTtcbiAgICAgICAgaWYgKHRleHRUcmFja1t0cmFja05hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHRUcmFjaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNyZWF0ZUNhcHRpb25zVHJhY2sgKHRyYWNrTmFtZSkge1xuICAgIGNvbnN0IHsgbGFiZWwsIGxhbmd1YWdlQ29kZSB9ID0gdGhpcy5jYXB0aW9uc1Byb3BlcnRpZXNbdHJhY2tOYW1lXTtcbiAgICBjb25zdCBjYXB0aW9uc1RyYWNrcyA9IHRoaXMuY2FwdGlvbnNUcmFja3M7XG4gICAgaWYgKCFjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdKSB7XG4gICAgICAvLyBFbmFibGUgcmV1c2Ugb2YgZXhpc3RpbmcgdGV4dCB0cmFjay5cbiAgICAgIGNvbnN0IGV4aXN0aW5nVHJhY2sgPSB0aGlzLmdldEV4aXN0aW5nVHJhY2sodHJhY2tOYW1lKTtcbiAgICAgIGlmICghZXhpc3RpbmdUcmFjaykge1xuICAgICAgICBjb25zdCB0ZXh0VHJhY2sgPSB0aGlzLmNyZWF0ZVRleHRUcmFjaygnY2FwdGlvbnMnLCBsYWJlbCwgbGFuZ3VhZ2VDb2RlKTtcbiAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgIC8vIFNldCBhIHNwZWNpYWwgcHJvcGVydHkgb24gdGhlIHRyYWNrIHNvIHdlIGtub3cgaXQncyBtYW5hZ2VkIGJ5IEhscy5qc1xuICAgICAgICAgIHRleHRUcmFja1t0cmFja05hbWVdID0gdHJ1ZTtcbiAgICAgICAgICBjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdID0gdGV4dFRyYWNrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdID0gZXhpc3RpbmdUcmFjaztcbiAgICAgICAgY2xlYXJDdXJyZW50Q3VlcyhjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdKTtcbiAgICAgICAgc2VuZEFkZFRyYWNrRXZlbnQoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSwgdGhpcy5tZWRpYSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlVGV4dFRyYWNrIChraW5kLCBsYWJlbCwgbGFuZykge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHJldHVybiBtZWRpYS5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgb25NZWRpYUF0dGFjaGluZyAoZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMuX2NsZWFuVHJhY2tzKCk7XG4gIH1cblxuICBvbk1lZGlhRGV0YWNoaW5nICgpIHtcbiAgICBjb25zdCB7IGNhcHRpb25zVHJhY2tzIH0gPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKGNhcHRpb25zVHJhY2tzKS5mb3JFYWNoKHRyYWNrTmFtZSA9PiB7XG4gICAgICBjbGVhckN1cnJlbnRDdWVzKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pO1xuICAgICAgZGVsZXRlIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV07XG4gICAgfSk7XG4gIH1cblxuICBvbk1hbmlmZXN0TG9hZGluZyAoKSB7XG4gICAgdGhpcy5sYXN0U24gPSAtMTsgLy8gRGV0ZWN0IGRpc2NvbnRpZ3VpdHkgaW4gZnJhZ21lbnQgcGFyc2luZ1xuICAgIHRoaXMucHJldkNDID0gLTE7XG4gICAgdGhpcy52dHRDQ3MgPSB7IC8vIERldGVjdCBkaXNjb250aW51aXR5IGluIHN1YnRpdGxlIG1hbmlmZXN0c1xuICAgICAgY2NPZmZzZXQ6IDAsXG4gICAgICBwcmVzZW50YXRpb25PZmZzZXQ6IDAsXG4gICAgICAwOiB7XG4gICAgICAgIHN0YXJ0OiAwLCBwcmV2Q0M6IC0xLCBuZXc6IGZhbHNlXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9jbGVhblRyYWNrcygpO1xuICB9XG5cbiAgX2NsZWFuVHJhY2tzICgpIHtcbiAgICAvLyBjbGVhciBvdXRkYXRlZCBzdWJ0aXRsZXNcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBjb25zdCB0ZXh0VHJhY2tzID0gbWVkaWEudGV4dFRyYWNrcztcbiAgICAgIGlmICh0ZXh0VHJhY2tzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNsZWFyQ3VycmVudEN1ZXModGV4dFRyYWNrc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbk1hbmlmZXN0TG9hZGVkIChkYXRhKSB7XG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gdGhpcy51bnBhcnNlZFZ0dEZyYWdzIHx8IFtdO1xuICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICAgIHRoaXMuY3VlUmFuZ2VzID0gW107XG5cbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlV2ViVlRUKSB7XG4gICAgICB0aGlzLnRyYWNrcyA9IGRhdGEuc3VidGl0bGVzIHx8IFtdO1xuICAgICAgY29uc3QgaW5Vc2VUcmFja3MgPSB0aGlzLm1lZGlhID8gdGhpcy5tZWRpYS50ZXh0VHJhY2tzIDogW107XG5cbiAgICAgIHRoaXMudHJhY2tzLmZvckVhY2goKHRyYWNrLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgdGV4dFRyYWNrO1xuICAgICAgICBpZiAoaW5kZXggPCBpblVzZVRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICBsZXQgaW5Vc2VUcmFjayA9IG51bGw7XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluVXNlVHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2FuUmV1c2VWdHRUZXh0VHJhY2soaW5Vc2VUcmFja3NbaV0sIHRyYWNrKSkge1xuICAgICAgICAgICAgICBpblVzZVRyYWNrID0gaW5Vc2VUcmFja3NbaV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJldXNlIHRyYWNrcyB3aXRoIHRoZSBzYW1lIGxhYmVsLCBidXQgZG8gbm90IHJldXNlIDYwOC83MDggdHJhY2tzXG4gICAgICAgICAgaWYgKGluVXNlVHJhY2spIHtcbiAgICAgICAgICAgIHRleHRUcmFjayA9IGluVXNlVHJhY2s7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGV4dFRyYWNrKSB7XG4gICAgICAgICAgdGV4dFRyYWNrID0gdGhpcy5jcmVhdGVUZXh0VHJhY2soJ3N1YnRpdGxlcycsIHRyYWNrLm5hbWUsIHRyYWNrLmxhbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYWNrLmRlZmF1bHQpIHtcbiAgICAgICAgICB0ZXh0VHJhY2subW9kZSA9IHRoaXMuaGxzLnN1YnRpdGxlRGlzcGxheSA/ICdzaG93aW5nJyA6ICdoaWRkZW4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRUcmFjay5tb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGV4dFRyYWNrcy5wdXNoKHRleHRUcmFjayk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBvbkxldmVsU3dpdGNoaW5nICgpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSB0aGlzLmhscy5jdXJyZW50TGV2ZWwuY2xvc2VkQ2FwdGlvbnMgIT09ICdOT05FJztcbiAgfVxuXG4gIG9uRnJhZ0xvYWRlZCAoZGF0YSkge1xuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgcGF5bG9hZCA9IGRhdGEucGF5bG9hZDtcbiAgICBpZiAoZnJhZy50eXBlID09PSAnbWFpbicpIHtcbiAgICAgIGxldCBzbiA9IGZyYWcuc247XG4gICAgICAvLyBpZiB0aGlzIGZyYWcgaXNuJ3QgY29udGlndW91cywgY2xlYXIgdGhlIHBhcnNlciBzbyBjdWVzIHdpdGggYmFkIHN0YXJ0L2VuZCB0aW1lcyBhcmVuJ3QgYWRkZWQgdG8gdGhlIHRleHRUcmFja1xuICAgICAgaWYgKHNuICE9PSB0aGlzLmxhc3RTbiArIDEpIHtcbiAgICAgICAgY29uc3QgY2VhNjA4UGFyc2VyID0gdGhpcy5jZWE2MDhQYXJzZXI7XG4gICAgICAgIGlmIChjZWE2MDhQYXJzZXIpIHtcbiAgICAgICAgICBjZWE2MDhQYXJzZXIucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0U24gPSBzbjtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYnJhY2Utc3R5bGVcbiAgICAvLyBJZiBmcmFnbWVudCBpcyBzdWJ0aXRsZSB0eXBlLCBwYXJzZSBhcyBXZWJWVFQuXG4gICAgZWxzZSBpZiAoZnJhZy50eXBlID09PSAnc3VidGl0bGUnKSB7XG4gICAgICBpZiAocGF5bG9hZC5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgYW4gaW5pdGlhbCBzeW5jaHJvbmlzYXRpb24gUFRTLiBTdG9yZSBmcmFnbWVudHMgYXMgbG9uZyBhcyBub25lIGhhcyBhcnJpdmVkLlxuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh0aGlzLmluaXRQVFNbZnJhZy5jY10pKSB7XG4gICAgICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzLnB1c2goZGF0YSk7XG4gICAgICAgICAgaWYgKHRoaXMuaW5pdFBUUy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGZpbmlzaCB1bnN1Y2Nlc3NmdWxseSwgb3RoZXJ3aXNlIHRoZSBzdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlciBjb3VsZCBiZSBibG9ja2VkIGZyb20gbG9hZGluZyBuZXcgZnJhZ3MuXG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7IHN1Y2Nlc3M6IGZhbHNlLCBmcmFnOiBmcmFnIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGVjcnlwdERhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgICAgICAvLyBJZiB0aGUgc3VidGl0bGVzIGFyZSBub3QgZW5jcnlwdGVkLCBwYXJzZSBWVFRzIG5vdy4gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIHdhaXQuXG4gICAgICAgIGlmICgoZGVjcnlwdERhdGEgPT0gbnVsbCkgfHwgKGRlY3J5cHREYXRhLmtleSA9PSBudWxsKSB8fCAoZGVjcnlwdERhdGEubWV0aG9kICE9PSAnQUVTLTEyOCcpKSB7XG4gICAgICAgICAgdGhpcy5fcGFyc2VWVFRzKGZyYWcsIHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbiBjYXNlIHRoZXJlIGlzIG5vIHBheWxvYWQsIGZpbmlzaCB1bnN1Y2Nlc3NmdWxseS5cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgeyBzdWNjZXNzOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfcGFyc2VWVFRzIChmcmFnLCBwYXlsb2FkKSB7XG4gICAgbGV0IHZ0dENDcyA9IHRoaXMudnR0Q0NzO1xuICAgIGlmICghdnR0Q0NzW2ZyYWcuY2NdKSB7XG4gICAgICB2dHRDQ3NbZnJhZy5jY10gPSB7IHN0YXJ0OiBmcmFnLnN0YXJ0LCBwcmV2Q0M6IHRoaXMucHJldkNDLCBuZXc6IHRydWUgfTtcbiAgICAgIHRoaXMucHJldkNDID0gZnJhZy5jYztcbiAgICB9XG4gICAgbGV0IHRleHRUcmFja3MgPSB0aGlzLnRleHRUcmFja3MsXG4gICAgICBobHMgPSB0aGlzLmhscztcblxuICAgIC8vIFBhcnNlIHRoZSBXZWJWVFQgZmlsZSBjb250ZW50cy5cbiAgICBXZWJWVFRQYXJzZXIucGFyc2UocGF5bG9hZCwgdGhpcy5pbml0UFRTW2ZyYWcuY2NdLCB2dHRDQ3MsIGZyYWcuY2MsIGZ1bmN0aW9uIChjdWVzKSB7XG4gICAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0ZXh0VHJhY2tzW2ZyYWcubGV2ZWxzXTtcbiAgICAgIC8vIFdlYlZUVFBhcnNlci5wYXJzZSBpcyBhbiBhc3luYyBtZXRob2QgYW5kIGlmIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dCB0cmFjayBtb2RlIGlzIHNldCB0byBcImRpc2FibGVkXCJcbiAgICAgIC8vIGJlZm9yZSBwYXJzaW5nIGlzIGRvbmUgdGhlbiBkb24ndCB0cnkgdG8gYWNjZXNzIGN1cnJlbnRUcmFjay5jdWVzLmdldEN1ZUJ5SWQgYXMgY3VlcyB3aWxsIGJlIG51bGxcbiAgICAgIC8vIGFuZCB0cnlpbmcgdG8gYWNjZXNzIGdldEN1ZUJ5SWQgbWV0aG9kIG9mIGN1ZXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb25cbiAgICAgIGlmIChjdXJyZW50VHJhY2subW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgeyBzdWNjZXNzOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gQWRkIGN1ZXMgYW5kIHRyaWdnZXIgZXZlbnQgd2l0aCBzdWNjZXNzIHRydWUuXG4gICAgICBjdWVzLmZvckVhY2goY3VlID0+IHtcbiAgICAgICAgLy8gU29tZXRpbWVzIHRoZXJlIGFyZSBjdWUgb3ZlcmxhcHMgb24gc2VnbWVudGVkIHZ0dHMgc28gdGhlIHNhbWVcbiAgICAgICAgLy8gY3VlIGNhbiBhcHBlYXIgbW9yZSB0aGFuIG9uY2UgaW4gZGlmZmVyZW50IHZ0dCBmaWxlcy5cbiAgICAgICAgLy8gVGhpcyBhdm9pZCBzaG93aW5nIGR1cGxpY2F0ZWQgY3VlcyB3aXRoIHNhbWUgdGltZWNvZGUgYW5kIHRleHQuXG4gICAgICAgIGlmICghY3VycmVudFRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChjdWUuaWQpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGN1cnJlbnRUcmFjay5hZGRDdWUoY3VlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRUcmFja0N1ZSA9IG5ldyB3aW5kb3cuVGV4dFRyYWNrQ3VlKGN1ZS5zdGFydFRpbWUsIGN1ZS5lbmRUaW1lLCBjdWUudGV4dCk7XG4gICAgICAgICAgICB0ZXh0VHJhY2tDdWUuaWQgPSBjdWUuaWQ7XG4gICAgICAgICAgICBjdXJyZW50VHJhY2suYWRkQ3VlKHRleHRUcmFja0N1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICApO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHsgc3VjY2VzczogdHJ1ZSwgZnJhZzogZnJhZyB9KTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBwYXJzaW5nLiBUcmlnZ2VyIGV2ZW50IHdpdGggc3VjY2VzcyBmYWxzZS5cbiAgICAgIGxvZ2dlci5sb2coYEZhaWxlZCB0byBwYXJzZSBWVFQgY3VlOiAke2V9YCk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgeyBzdWNjZXNzOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIG9uRnJhZ0RlY3J5cHRlZCAoZGF0YSkge1xuICAgIGxldCBkZWNyeXB0ZWREYXRhID0gZGF0YS5wYXlsb2FkLFxuICAgICAgZnJhZyA9IGRhdGEuZnJhZztcblxuICAgIGlmIChmcmFnLnR5cGUgPT09ICdzdWJ0aXRsZScpIHtcbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHRoaXMuaW5pdFBUU1tmcmFnLmNjXSkpIHtcbiAgICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzLnB1c2goZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcGFyc2VWVFRzKGZyYWcsIGRlY3J5cHRlZERhdGEpO1xuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdVc2VyZGF0YSAoZGF0YSkge1xuICAgIC8vIHB1c2ggYWxsIG9mIHRoZSBDRUEtNzA4IG1lc3NhZ2VzIGludG8gdGhlIGludGVycHJldGVyXG4gICAgLy8gaW1tZWRpYXRlbHkuIEl0IHdpbGwgY3JlYXRlIHRoZSBwcm9wZXIgdGltZXN0YW1wcyBiYXNlZCBvbiBvdXIgUFRTIHZhbHVlXG4gICAgaWYgKHRoaXMuZW5hYmxlZCAmJiB0aGlzLmNvbmZpZy5lbmFibGVDRUE3MDhDYXB0aW9ucykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLnNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNjZGF0YXMgPSB0aGlzLmV4dHJhY3RDZWE2MDhEYXRhKGRhdGEuc2FtcGxlc1tpXS5ieXRlcyk7XG4gICAgICAgIHRoaXMuY2VhNjA4UGFyc2VyLmFkZERhdGEoZGF0YS5zYW1wbGVzW2ldLnB0cywgY2NkYXRhcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZXh0cmFjdENlYTYwOERhdGEgKGJ5dGVBcnJheSkge1xuICAgIGxldCBjb3VudCA9IGJ5dGVBcnJheVswXSAmIDMxO1xuICAgIGxldCBwb3NpdGlvbiA9IDI7XG4gICAgbGV0IHRtcEJ5dGUsIGNjYnl0ZTEsIGNjYnl0ZTIsIGNjVmFsaWQsIGNjVHlwZTtcbiAgICBsZXQgYWN0dWFsQ0NCeXRlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICB0bXBCeXRlID0gYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgY2NieXRlMSA9IDB4N0YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICBjY2J5dGUyID0gMHg3RiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgIGNjVmFsaWQgPSAoNCAmIHRtcEJ5dGUpICE9PSAwO1xuICAgICAgY2NUeXBlID0gMyAmIHRtcEJ5dGU7XG5cbiAgICAgIGlmIChjY2J5dGUxID09PSAwICYmIGNjYnl0ZTIgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjY1ZhbGlkKSB7XG4gICAgICAgIGlmIChjY1R5cGUgPT09IDApIHsgLy8gfHwgY2NUeXBlID09PSAxXG4gICAgICAgICAgYWN0dWFsQ0NCeXRlcy5wdXNoKGNjYnl0ZTEpO1xuICAgICAgICAgIGFjdHVhbENDQnl0ZXMucHVzaChjY2J5dGUyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWN0dWFsQ0NCeXRlcztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1lbGluZUNvbnRyb2xsZXI7XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBBRVNDcnlwdG8ge1xuICBjb25zdHJ1Y3RvciAoc3VidGxlLCBpdikge1xuICAgIHRoaXMuc3VidGxlID0gc3VidGxlO1xuICAgIHRoaXMuYWVzSVYgPSBpdjtcbiAgfVxuXG4gIGRlY3J5cHQgKGRhdGEsIGtleSkge1xuICAgIHJldHVybiB0aGlzLnN1YnRsZS5kZWNyeXB0KHsgbmFtZTogJ0FFUy1DQkMnLCBpdjogdGhpcy5hZXNJViB9LCBrZXksIGRhdGEpO1xuICB9XG59XG4iLCIvLyBQS0NTN1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVBhZGRpbmcgKGJ1ZmZlcikge1xuICBjb25zdCBvdXRwdXRCeXRlcyA9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICBjb25zdCBwYWRkaW5nQnl0ZXMgPSBvdXRwdXRCeXRlcyAmJiAobmV3IERhdGFWaWV3KGJ1ZmZlcikpLmdldFVpbnQ4KG91dHB1dEJ5dGVzIC0gMSk7XG4gIGlmIChwYWRkaW5nQnl0ZXMpIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIG91dHB1dEJ5dGVzIC0gcGFkZGluZ0J5dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG59XG5cbmNsYXNzIEFFU0RlY3J5cHRvciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvLyBTdGF0aWMgYWZ0ZXIgcnVubmluZyBpbml0VGFibGVcbiAgICB0aGlzLnJjb24gPSBbMHgwLCAweDEsIDB4MiwgMHg0LCAweDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xuICAgIHRoaXMuc3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpXTtcbiAgICB0aGlzLmludlN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KV07XG4gICAgdGhpcy5zQm94ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdGhpcy5pbnZTQm94ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG5cbiAgICAvLyBDaGFuZ2VzIGR1cmluZyBydW50aW1lXG4gICAgdGhpcy5rZXkgPSBuZXcgVWludDMyQXJyYXkoMCk7XG5cbiAgICB0aGlzLmluaXRUYWJsZSgpO1xuICB9XG5cbiAgLy8gVXNpbmcgdmlldy5nZXRVaW50MzIoKSBhbHNvIHN3YXBzIHRoZSBieXRlIG9yZGVyLlxuICB1aW50OEFycmF5VG9VaW50MzJBcnJheV8gKGFycmF5QnVmZmVyKSB7XG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICAgIGxldCBuZXdBcnJheSA9IG5ldyBVaW50MzJBcnJheSg0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgbmV3QXJyYXlbaV0gPSB2aWV3LmdldFVpbnQzMihpICogNCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG5cbiAgaW5pdFRhYmxlICgpIHtcbiAgICBsZXQgc0JveCA9IHRoaXMuc0JveDtcbiAgICBsZXQgaW52U0JveCA9IHRoaXMuaW52U0JveDtcbiAgICBsZXQgc3ViTWl4ID0gdGhpcy5zdWJNaXg7XG4gICAgbGV0IHN1Yk1peDAgPSBzdWJNaXhbMF07XG4gICAgbGV0IHN1Yk1peDEgPSBzdWJNaXhbMV07XG4gICAgbGV0IHN1Yk1peDIgPSBzdWJNaXhbMl07XG4gICAgbGV0IHN1Yk1peDMgPSBzdWJNaXhbM107XG4gICAgbGV0IGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgIGxldCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIGxldCBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xuICAgIGxldCBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgIGxldCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuXG4gICAgbGV0IGQgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHhpID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBpZiAoaSA8IDEyOCkge1xuICAgICAgICBkW2ldID0gaSA8PCAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZFtpXSA9IChpIDw8IDEpIF4gMHgxMWI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBsZXQgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KTtcbiAgICAgIHN4ID0gKHN4ID4+PiA4KSBeIChzeCAmIDB4ZmYpIF4gMHg2MztcbiAgICAgIHNCb3hbeF0gPSBzeDtcbiAgICAgIGludlNCb3hbc3hdID0geDtcblxuICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuICAgICAgbGV0IHgyID0gZFt4XTtcbiAgICAgIGxldCB4NCA9IGRbeDJdO1xuICAgICAgbGV0IHg4ID0gZFt4NF07XG5cbiAgICAgIC8vIENvbXB1dGUgc3ViL2ludlN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICBsZXQgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMCk7XG4gICAgICBzdWJNaXgwW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuICAgICAgc3ViTWl4MVt4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG4gICAgICBzdWJNaXgyW3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuICAgICAgc3ViTWl4M1t4XSA9IHQ7XG5cbiAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgdCA9ICh4OCAqIDB4MTAxMDEwMSkgXiAoeDQgKiAweDEwMDAxKSBeICh4MiAqIDB4MTAxKSBeICh4ICogMHgxMDEwMTAwKTtcbiAgICAgIGludlN1Yk1peDBbc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuICAgICAgaW52U3ViTWl4MVtzeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuICAgICAgaW52U3ViTWl4MltzeF0gPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG4gICAgICBpbnZTdWJNaXgzW3N4XSA9IHQ7XG5cbiAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG4gICAgICBpZiAoIXgpIHtcbiAgICAgICAgeCA9IHhpID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG4gICAgICAgIHhpIF49IGRbZFt4aV1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV4cGFuZEtleSAoa2V5QnVmZmVyKSB7XG4gICAgLy8gY29udmVydCBrZXlCdWZmZXIgdG8gVWludDMyQXJyYXlcbiAgICBsZXQga2V5ID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oa2V5QnVmZmVyKTtcbiAgICBsZXQgc2FtZUtleSA9IHRydWU7XG4gICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwga2V5Lmxlbmd0aCAmJiBzYW1lS2V5KSB7XG4gICAgICBzYW1lS2V5ID0gKGtleVtvZmZzZXRdID09PSB0aGlzLmtleVtvZmZzZXRdKTtcbiAgICAgIG9mZnNldCsrO1xuICAgIH1cblxuICAgIGlmIChzYW1lS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgbGV0IGtleVNpemUgPSB0aGlzLmtleVNpemUgPSBrZXkubGVuZ3RoO1xuXG4gICAgaWYgKGtleVNpemUgIT09IDQgJiYga2V5U2l6ZSAhPT0gNiAmJiBrZXlTaXplICE9PSA4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWVzIGtleSBzaXplPScgKyBrZXlTaXplKTtcbiAgICB9XG5cbiAgICBsZXQga3NSb3dzID0gdGhpcy5rc1Jvd3MgPSAoa2V5U2l6ZSArIDYgKyAxKSAqIDQ7XG4gICAgbGV0IGtzUm93O1xuICAgIGxldCBpbnZLc1JvdztcblxuICAgIGxldCBrZXlTY2hlZHVsZSA9IHRoaXMua2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKTtcbiAgICBsZXQgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlID0gbmV3IFVpbnQzMkFycmF5KGtzUm93cyk7XG4gICAgbGV0IHNib3ggPSB0aGlzLnNCb3g7XG4gICAgbGV0IHJjb24gPSB0aGlzLnJjb247XG5cbiAgICBsZXQgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgbGV0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgbGV0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgbGV0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgbGV0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG5cbiAgICBsZXQgcHJldjtcbiAgICBsZXQgdDtcblxuICAgIGZvciAoa3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xuICAgICAgaWYgKGtzUm93IDwga2V5U2l6ZSkge1xuICAgICAgICBwcmV2ID0ga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5W2tzUm93XTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0ID0gcHJldjtcblxuICAgICAgaWYgKGtzUm93ICUga2V5U2l6ZSA9PT0gMCkge1xuICAgICAgICAvLyBSb3Qgd29yZFxuICAgICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuXG4gICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgIHQgPSAoc2JveFt0ID4+PiAyNF0gPDwgMjQpIHwgKHNib3hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChzYm94Wyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgc2JveFt0ICYgMHhmZl07XG5cbiAgICAgICAgLy8gTWl4IFJjb25cbiAgICAgICAgdCBePSByY29uWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQ7XG4gICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PT0gNCkge1xuICAgICAgICAvLyBTdWIgd29yZFxuICAgICAgICB0ID0gKHNib3hbdCA+Pj4gMjRdIDw8IDI0KSB8IChzYm94Wyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoc2JveFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IHNib3hbdCAmIDB4ZmZdO1xuICAgICAgfVxuXG4gICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBwcmV2ID0gKGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0KSA+Pj4gMDtcbiAgICB9XG5cbiAgICBmb3IgKGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcbiAgICAgIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3c7XG4gICAgICBpZiAoaW52S3NSb3cgJiAzKSB7XG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZTdWJNaXgwW3Nib3hbdCA+Pj4gMjRdXSBeIGludlN1Yk1peDFbc2JveFsodCA+Pj4gMTYpICYgMHhmZl1dIF4gaW52U3ViTWl4MltzYm94Wyh0ID4+PiA4KSAmIDB4ZmZdXSBeIGludlN1Yk1peDNbc2JveFt0ICYgMHhmZl1dO1xuICAgICAgfVxuXG4gICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPj4+IDA7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkaW5nIHRoaXMgYXMgYSBtZXRob2QgZ3JlYXRseSBpbXByb3ZlcyBwZXJmb3JtYW5jZS5cbiAgbmV0d29ya1RvSG9zdE9yZGVyU3dhcCAod29yZCkge1xuICAgIHJldHVybiAod29yZCA8PCAyNCkgfCAoKHdvcmQgJiAweGZmMDApIDw8IDgpIHwgKCh3b3JkICYgMHhmZjAwMDApID4+IDgpIHwgKHdvcmQgPj4+IDI0KTtcbiAgfVxuXG4gIGRlY3J5cHQgKGlucHV0QXJyYXlCdWZmZXIsIG9mZnNldCwgYWVzSVYsIHJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgIGxldCBuUm91bmRzID0gdGhpcy5rZXlTaXplICsgNjtcbiAgICBsZXQgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlO1xuICAgIGxldCBpbnZTQk9YID0gdGhpcy5pbnZTQm94O1xuXG4gICAgbGV0IGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgIGxldCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIGxldCBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xuICAgIGxldCBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgIGxldCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuXG4gICAgbGV0IGluaXRWZWN0b3IgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhhZXNJVik7XG4gICAgbGV0IGluaXRWZWN0b3IwID0gaW5pdFZlY3RvclswXTtcbiAgICBsZXQgaW5pdFZlY3RvcjEgPSBpbml0VmVjdG9yWzFdO1xuICAgIGxldCBpbml0VmVjdG9yMiA9IGluaXRWZWN0b3JbMl07XG4gICAgbGV0IGluaXRWZWN0b3IzID0gaW5pdFZlY3RvclszXTtcblxuICAgIGxldCBpbnB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRBcnJheUJ1ZmZlcik7XG4gICAgbGV0IG91dHB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRJbnQzMi5sZW5ndGgpO1xuXG4gICAgbGV0IHQwLCB0MSwgdDIsIHQzO1xuICAgIGxldCBzMCwgczEsIHMyLCBzMztcbiAgICBsZXQgaW5wdXRXb3JkczAsIGlucHV0V29yZHMxLCBpbnB1dFdvcmRzMiwgaW5wdXRXb3JkczM7XG5cbiAgICBsZXQga3NSb3csIGk7XG4gICAgbGV0IHN3YXBXb3JkID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IGlucHV0SW50MzIubGVuZ3RoKSB7XG4gICAgICBpbnB1dFdvcmRzMCA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0XSk7XG4gICAgICBpbnB1dFdvcmRzMSA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgMV0pO1xuICAgICAgaW5wdXRXb3JkczIgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDJdKTtcbiAgICAgIGlucHV0V29yZHMzID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAzXSk7XG5cbiAgICAgIHMwID0gaW5wdXRXb3JkczAgXiBpbnZLZXlTY2hlZHVsZVswXTtcbiAgICAgIHMxID0gaW5wdXRXb3JkczMgXiBpbnZLZXlTY2hlZHVsZVsxXTtcbiAgICAgIHMyID0gaW5wdXRXb3JkczIgXiBpbnZLZXlTY2hlZHVsZVsyXTtcbiAgICAgIHMzID0gaW5wdXRXb3JkczEgXiBpbnZLZXlTY2hlZHVsZVszXTtcblxuICAgICAga3NSb3cgPSA0O1xuXG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHJvdW5kcyBvZiBkZWNyeXB0aW9uXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgblJvdW5kczsgaSsrKSB7XG4gICAgICAgIHQwID0gaW52U3ViTWl4MFtzMCA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczEgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMiA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMyAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgICB0MSA9IGludlN1Yk1peDBbczEgPj4+IDI0XSBeIGludlN1Yk1peDFbKHMyID4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4MlsoczMgPj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbczAgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XG4gICAgICAgIHQyID0gaW52U3ViTWl4MFtzMiA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczMgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMCA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMSAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgICAgdDMgPSBpbnZTdWJNaXgwW3MzID4+PiAyNF0gXiBpbnZTdWJNaXgxWyhzMCA+PiAxNikgJiAweGZmXSBeIGludlN1Yk1peDJbKHMxID4+IDgpICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MyICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuICAgICAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICAgICAgczAgPSB0MDtcbiAgICAgICAgczEgPSB0MTtcbiAgICAgICAgczIgPSB0MjtcbiAgICAgICAgczMgPSB0MztcblxuICAgICAgICBrc1JvdyA9IGtzUm93ICsgNDtcbiAgICAgIH1cblxuICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG4gICAgICB0MCA9ICgoaW52U0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSBeIChpbnZTQk9YWyhzMSA+PiAxNikgJiAweGZmXSA8PCAxNikgXiAoaW52U0JPWFsoczIgPj4gOCkgJiAweGZmXSA8PCA4KSBeIGludlNCT1hbczMgJiAweGZmXSkgXiBpbnZLZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICB0MSA9ICgoaW52U0JPWFtzMSA+Pj4gMjRdIDw8IDI0KSBeIChpbnZTQk9YWyhzMiA+PiAxNikgJiAweGZmXSA8PCAxNikgXiAoaW52U0JPWFsoczMgPj4gOCkgJiAweGZmXSA8PCA4KSBeIGludlNCT1hbczAgJiAweGZmXSkgXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xuICAgICAgdDIgPSAoKGludlNCT1hbczIgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczMgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMwID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MxICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgIHQzID0gKChpbnZTQk9YW3MzID4+PiAyNF0gPDwgMjQpIF4gKGludlNCT1hbKHMwID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeIChpbnZTQk9YWyhzMSA+PiA4KSAmIDB4ZmZdIDw8IDgpIF4gaW52U0JPWFtzMiAmIDB4ZmZdKSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgM107XG4gICAgICBrc1JvdyA9IGtzUm93ICsgMztcblxuICAgICAgLy8gV3JpdGVcbiAgICAgIG91dHB1dEludDMyW29mZnNldF0gPSBzd2FwV29yZCh0MCBeIGluaXRWZWN0b3IwKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDFdID0gc3dhcFdvcmQodDMgXiBpbml0VmVjdG9yMSk7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAyXSA9IHN3YXBXb3JkKHQyIF4gaW5pdFZlY3RvcjIpO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgM10gPSBzd2FwV29yZCh0MSBeIGluaXRWZWN0b3IzKTtcblxuICAgICAgLy8gcmVzZXQgaW5pdFZlY3RvciB0byBsYXN0IDQgdW5zaWduZWQgaW50XG4gICAgICBpbml0VmVjdG9yMCA9IGlucHV0V29yZHMwO1xuICAgICAgaW5pdFZlY3RvcjEgPSBpbnB1dFdvcmRzMTtcbiAgICAgIGluaXRWZWN0b3IyID0gaW5wdXRXb3JkczI7XG4gICAgICBpbml0VmVjdG9yMyA9IGlucHV0V29yZHMzO1xuXG4gICAgICBvZmZzZXQgPSBvZmZzZXQgKyA0O1xuICAgIH1cblxuICAgIHJldHVybiByZW1vdmVQS0NTN1BhZGRpbmcgPyByZW1vdmVQYWRkaW5nKG91dHB1dEludDMyLmJ1ZmZlcikgOiBvdXRwdXRJbnQzMi5idWZmZXI7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmtleSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmtleVNpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5rc1Jvd3MgPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLnNCb3ggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbnZTQm94ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3ViTWl4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW52U3ViTWl4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMua2V5U2NoZWR1bGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbnZLZXlTY2hlZHVsZSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMucmNvbiA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBRVNEZWNyeXB0b3I7XG4iLCJpbXBvcnQgQUVTQ3J5cHRvIGZyb20gJy4vYWVzLWNyeXB0byc7XG5pbXBvcnQgRmFzdEFFU0tleSBmcm9tICcuL2Zhc3QtYWVzLWtleSc7XG5pbXBvcnQgQUVTRGVjcnlwdG9yIGZyb20gJy4vYWVzLWRlY3J5cHRvcic7XG5cbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcblxuaW1wb3J0IHsgZ2V0U2VsZlNjb3BlIH0gZnJvbSAnLi4vdXRpbHMvZ2V0LXNlbGYtc2NvcGUnO1xuXG4vLyBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExMjM3MjU5LzU4OTQ5M1xuY29uc3QgZ2xvYmFsID0gZ2V0U2VsZlNjb3BlKCk7IC8vIHNhZmVndWFyZCBmb3IgY29kZSB0aGF0IG1pZ2h0IHJ1biBib3RoIG9uIHdvcmtlciBhbmQgbWFpbiB0aHJlYWRcblxuY2xhc3MgRGVjcnlwdGVyIHtcbiAgY29uc3RydWN0b3IgKG9ic2VydmVyLCBjb25maWcsIHsgcmVtb3ZlUEtDUzdQYWRkaW5nID0gdHJ1ZSB9ID0ge30pIHtcbiAgICB0aGlzLmxvZ0VuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZyA9IHJlbW92ZVBLQ1M3UGFkZGluZztcbiAgICAvLyBidWlsdCBpbiBkZWNyeXB0b3IgZXhwZWN0cyBQS0NTNyBwYWRkaW5nXG4gICAgaWYgKHJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYnJvd3NlckNyeXB0byA9IGdsb2JhbC5jcnlwdG87XG4gICAgICAgIGlmIChicm93c2VyQ3J5cHRvKSB7XG4gICAgICAgICAgdGhpcy5zdWJ0bGUgPSBicm93c2VyQ3J5cHRvLnN1YnRsZSB8fCBicm93c2VyQ3J5cHRvLndlYmtpdFN1YnRsZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlV2ViQ3J5cHRvID0gIXRoaXMuc3VidGxlO1xuICB9XG5cbiAgaXNTeW5jICgpIHtcbiAgICByZXR1cm4gKHRoaXMuZGlzYWJsZVdlYkNyeXB0byAmJiB0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUyk7XG4gIH1cblxuICBkZWNyeXB0IChkYXRhLCBrZXksIGl2LCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmRpc2FibGVXZWJDcnlwdG8gJiYgdGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMpIHtcbiAgICAgIGlmICh0aGlzLmxvZ0VuYWJsZWQpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSlMgQUVTIGRlY3J5cHQnKTtcbiAgICAgICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgZGVjcnlwdG9yID0gdGhpcy5kZWNyeXB0b3I7XG4gICAgICBpZiAoIWRlY3J5cHRvcikge1xuICAgICAgICB0aGlzLmRlY3J5cHRvciA9IGRlY3J5cHRvciA9IG5ldyBBRVNEZWNyeXB0b3IoKTtcbiAgICAgIH1cblxuICAgICAgZGVjcnlwdG9yLmV4cGFuZEtleShrZXkpO1xuICAgICAgY2FsbGJhY2soZGVjcnlwdG9yLmRlY3J5cHQoZGF0YSwgMCwgaXYsIHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmxvZ0VuYWJsZWQpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnV2ViQ3J5cHRvIEFFUyBkZWNyeXB0Jyk7XG4gICAgICAgIHRoaXMubG9nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3VidGxlID0gdGhpcy5zdWJ0bGU7XG4gICAgICBpZiAodGhpcy5rZXkgIT09IGtleSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5mYXN0QWVzS2V5ID0gbmV3IEZhc3RBRVNLZXkoc3VidGxlLCBrZXkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZhc3RBZXNLZXkuZXhwYW5kS2V5KClcbiAgICAgICAgLnRoZW4oKGFlc0tleSkgPT4ge1xuICAgICAgICAgIC8vIGRlY3J5cHQgdXNpbmcgd2ViIGNyeXB0b1xuICAgICAgICAgIGxldCBjcnlwdG8gPSBuZXcgQUVTQ3J5cHRvKHN1YnRsZSwgaXYpO1xuICAgICAgICAgIGNyeXB0by5kZWNyeXB0KGRhdGEsIGFlc0tleSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMub25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICB0aGlzLm9uV2ViQ3J5cHRvRXJyb3IoZXJyLCBkYXRhLCBrZXksIGl2LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIG9uV2ViQ3J5cHRvRXJyb3IgKGVyciwgZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMpIHtcbiAgICAgIGxvZ2dlci5sb2coJ1dlYkNyeXB0byBFcnJvciwgZGlzYWJsZSBXZWJDcnlwdG8gQVBJJyk7XG4gICAgICB0aGlzLmRpc2FibGVXZWJDcnlwdG8gPSB0cnVlO1xuICAgICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZGVjcnlwdChkYXRhLCBrZXksIGl2LCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5lcnJvcihgZGVjcnlwdGluZyBlcnJvciA6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUiwgZmF0YWw6IHRydWUsIHJlYXNvbjogZXJyLm1lc3NhZ2UgfSk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgbGV0IGRlY3J5cHRvciA9IHRoaXMuZGVjcnlwdG9yO1xuICAgIGlmIChkZWNyeXB0b3IpIHtcbiAgICAgIGRlY3J5cHRvci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmRlY3J5cHRvciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGVjcnlwdGVyO1xuIiwiY2xhc3MgRmFzdEFFU0tleSB7XG4gIGNvbnN0cnVjdG9yIChzdWJ0bGUsIGtleSkge1xuICAgIHRoaXMuc3VidGxlID0gc3VidGxlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICB9XG5cbiAgZXhwYW5kS2V5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCB0aGlzLmtleSwgeyBuYW1lOiAnQUVTLUNCQycgfSwgZmFsc2UsIFsnZW5jcnlwdCcsICdkZWNyeXB0J10pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZhc3RBRVNLZXk7XG4iLCIvKipcbiAqIEFBQyBkZW11eGVyXG4gKi9cbmltcG9ydCAqIGFzIEFEVFMgZnJvbSAnLi9hZHRzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgSUQzIGZyb20gJy4uL2RlbXV4L2lkMyc7XG5cbmNsYXNzIEFBQ0RlbXV4ZXIge1xuICBjb25zdHJ1Y3RvciAob2JzZXJ2ZXIsIHJlbXV4ZXIsIGNvbmZpZykge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnJlbXV4ZXIgPSByZW11eGVyO1xuICB9XG5cbiAgcmVzZXRJbml0U2VnbWVudCAoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHsgY29udGFpbmVyOiAnYXVkaW8vYWR0cycsIHR5cGU6ICdhdWRpbycsIGlkOiAwLCBzZXF1ZW5jZU51bWJlcjogMCwgaXNBQUM6IHRydWUsIHNhbXBsZXM6IFtdLCBsZW46IDAsIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsIGR1cmF0aW9uOiBkdXJhdGlvbiwgaW5wdXRUaW1lU2NhbGU6IDkwMDAwIH07XG4gIH1cblxuICByZXNldFRpbWVTdGFtcCAoKSB7XG4gIH1cblxuICBzdGF0aWMgcHJvYmUgKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgdGhlIEFEVFMgc3luYyB3b3JkXG4gICAgLy8gTG9vayBmb3IgQURUUyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTExIFgwMFggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxXG4gICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyAwIGZvciBBRFRTXG4gICAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gICAgY29uc3QgaWQzRGF0YSA9IElEMy5nZXRJRDNEYXRhKGRhdGEsIDApIHx8IFtdO1xuICAgIGxldCBvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICBpZiAoQURUUy5wcm9iZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0FEVFMgc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgYXBwZW5kIChkYXRhLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICBsZXQgdHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrO1xuICAgIGxldCBpZDNEYXRhID0gSUQzLmdldElEM0RhdGEoZGF0YSwgMCkgfHwgW107XG4gICAgbGV0IHRpbWVzdGFtcCA9IElEMy5nZXRUaW1lU3RhbXAoaWQzRGF0YSk7XG4gICAgbGV0IHB0cyA9IE51bWJlci5pc0Zpbml0ZSh0aW1lc3RhbXApID8gdGltZXN0YW1wICogOTAgOiB0aW1lT2Zmc2V0ICogOTAwMDA7XG4gICAgbGV0IGZyYW1lSW5kZXggPSAwO1xuICAgIGxldCBzdGFtcCA9IHB0cztcbiAgICBsZXQgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgbGV0IG9mZnNldCA9IGlkM0RhdGEubGVuZ3RoO1xuXG4gICAgbGV0IGlkM1NhbXBsZXMgPSBbeyBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wLCBkYXRhOiBpZDNEYXRhIH1dO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCAtIDEpIHtcbiAgICAgIGlmIChBRFRTLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkgJiYgKG9mZnNldCArIDUpIDwgbGVuZ3RoKSB7XG4gICAgICAgIEFEVFMuaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCB0aGlzLm9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIHRyYWNrLm1hbmlmZXN0Q29kZWMpO1xuICAgICAgICBsZXQgZnJhbWUgPSBBRFRTLmFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCk7XG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgc3RhbXAgPSBmcmFtZS5zYW1wbGUucHRzO1xuICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdVbmFibGUgdG8gcGFyc2UgQUFDIGZyYW1lJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoSUQzLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgaWQzRGF0YSA9IElEMy5nZXRJRDNEYXRhKGRhdGEsIG9mZnNldCk7XG4gICAgICAgIGlkM1NhbXBsZXMucHVzaCh7IHB0czogc3RhbXAsIGR0czogc3RhbXAsIGRhdGE6IGlkM0RhdGEgfSk7XG4gICAgICAgIG9mZnNldCArPSBpZDNEYXRhLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlbXV4ZXIucmVtdXgodHJhY2ssXG4gICAgICB7IHNhbXBsZXM6IFtdIH0sXG4gICAgICB7IHNhbXBsZXM6IGlkM1NhbXBsZXMsIGlucHV0VGltZVNjYWxlOiA5MDAwMCB9LFxuICAgICAgeyBzYW1wbGVzOiBbXSB9LFxuICAgICAgdGltZU9mZnNldCxcbiAgICAgIGNvbnRpZ3VvdXMsXG4gICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQUFDRGVtdXhlcjtcbiIsIi8qKlxuICogIEFEVFMgcGFyc2VyIGhlbHBlclxuICovXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5cbmltcG9ydCB7IGdldFNlbGZTY29wZSB9IGZyb20gJy4uL3V0aWxzL2dldC1zZWxmLXNjb3BlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEF1ZGlvQ29uZmlnIChvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKSB7XG4gIGxldCBhZHRzT2JqZWN0VHlwZSwgLy8gOmludFxuICAgIGFkdHNTYW1wbGVpbmdJbmRleCwgLy8gOmludFxuICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCwgLy8gOmludFxuICAgIGFkdHNDaGFuZWxDb25maWcsIC8vIDppbnRcbiAgICBjb25maWcsXG4gICAgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLFxuICAgIG1hbmlmZXN0Q29kZWMgPSBhdWRpb0NvZGVjLFxuICAgIGFkdHNTYW1wbGVpbmdSYXRlcyA9IFtcbiAgICAgIDk2MDAwLCA4ODIwMCxcbiAgICAgIDY0MDAwLCA0ODAwMCxcbiAgICAgIDQ0MTAwLCAzMjAwMCxcbiAgICAgIDI0MDAwLCAyMjA1MCxcbiAgICAgIDE2MDAwLCAxMjAwMCxcbiAgICAgIDExMDI1LCA4MDAwLFxuICAgICAgNzM1MF07XG4gIC8vIGJ5dGUgMlxuICBhZHRzT2JqZWN0VHlwZSA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4QzApID4+PiA2KSArIDE7XG4gIGFkdHNTYW1wbGVpbmdJbmRleCA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4M0MpID4+PiAyKTtcbiAgaWYgKGFkdHNTYW1wbGVpbmdJbmRleCA+IGFkdHNTYW1wbGVpbmdSYXRlcy5sZW5ndGggLSAxKSB7XG4gICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgcmVhc29uOiBgaW52YWxpZCBBRFRTIHNhbXBsaW5nIGluZGV4OiR7YWR0c1NhbXBsZWluZ0luZGV4fWAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFkdHNDaGFuZWxDb25maWcgPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDAxKSA8PCAyKTtcbiAgLy8gYnl0ZSAzXG4gIGFkdHNDaGFuZWxDb25maWcgfD0gKChkYXRhW29mZnNldCArIDNdICYgMHhDMCkgPj4+IDYpO1xuICBsb2dnZXIubG9nKGBtYW5pZmVzdCBjb2RlYzoke2F1ZGlvQ29kZWN9LEFEVFMgZGF0YTp0eXBlOiR7YWR0c09iamVjdFR5cGV9LHNhbXBsZWluZ0luZGV4OiR7YWR0c1NhbXBsZWluZ0luZGV4fVske2FkdHNTYW1wbGVpbmdSYXRlc1thZHRzU2FtcGxlaW5nSW5kZXhdfUh6XSxjaGFubmVsQ29uZmlnOiR7YWR0c0NoYW5lbENvbmZpZ31gKTtcbiAgLy8gZmlyZWZveDogZnJlcSBsZXNzIHRoYW4gMjRrSHogPSBBQUMgU0JSIChIRS1BQUMpXG4gIGlmICgvZmlyZWZveC9pLnRlc3QodXNlckFnZW50KSkge1xuICAgIGlmIChhZHRzU2FtcGxlaW5nSW5kZXggPj0gNikge1xuICAgICAgYWR0c09iamVjdFR5cGUgPSA1O1xuICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleCAtIDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgICB9XG4gICAgLy8gQW5kcm9pZCA6IGFsd2F5cyB1c2UgQUFDXG4gIH0gZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEpIHtcbiAgICBhZHRzT2JqZWN0VHlwZSA9IDI7XG4gICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgfSBlbHNlIHtcbiAgICAvKiAgZm9yIG90aGVyIGJyb3dzZXJzIChDaHJvbWUvVml2YWxkaS9PcGVyYSAuLi4pXG4gICAgICAgIGFsd2F5cyBmb3JjZSBhdWRpbyB0eXBlIHRvIGJlIEhFLUFBQyBTQlIsIGFzIHNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgYXVkaW8gY29kZWMgc3dpdGNoIHByb3Blcmx5IChsaWtlIENocm9tZSAuLi4pXG4gICAgKi9cbiAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuICAgIC8vIGlmIChtYW5pZmVzdCBjb2RlYyBpcyBIRS1BQUMgb3IgSEUtQUFDdjIpIE9SIChtYW5pZmVzdCBjb2RlYyBub3Qgc3BlY2lmaWVkIEFORCBmcmVxdWVuY3kgbGVzcyB0aGFuIDI0a0h6KVxuICAgIGlmICgoYXVkaW9Db2RlYyAmJiAoKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yOScpICE9PSAtMSkgfHxcbiAgICAgIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkpKSB8fFxuICAgICAgKCFhdWRpb0NvZGVjICYmIGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2KSkge1xuICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleCAtIDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIChtYW5pZmVzdCBjb2RlYyBpcyBBQUMpIEFORCAoZnJlcXVlbmN5IGxlc3MgdGhhbiAyNGtIeiBBTkQgbmIgY2hhbm5lbCBpcyAxKSBPUiAobWFuaWZlc3QgY29kZWMgbm90IHNwZWNpZmllZCBhbmQgbW9ubyBhdWRpbylcbiAgICAgIC8vIENocm9tZSBmYWlscyB0byBwbGF5IGJhY2sgd2l0aCBsb3cgZnJlcXVlbmN5IEFBQyBMQyBtb25vIHdoZW4gaW5pdGlhbGl6ZWQgd2l0aCBIRS1BQUMuICBUaGlzIGlzIG5vdCBhIHByb2JsZW0gd2l0aCBzdGVyZW8uXG4gICAgICBpZiAoYXVkaW9Db2RlYyAmJiBhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMSAmJiAoKGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2ICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpIHx8XG4gICAgICAgICAgICAvdml2YWxkaS9pLnRlc3QodXNlckFnZW50KSkgfHxcbiAgICAgICAgKCFhdWRpb0NvZGVjICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpKSB7XG4gICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgfVxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4O1xuICAgIH1cbiAgfVxuICAvKiByZWZlciB0byBodHRwOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1NUEVHLTRfQXVkaW8jQXVkaW9fU3BlY2lmaWNfQ29uZmlnXG4gICAgICBJU08gMTQ0OTYtMyAoQUFDKS5wZGYgLSBUYWJsZSAxLjEzIOKAlCBTeW50YXggb2YgQXVkaW9TcGVjaWZpY0NvbmZpZygpXG4gICAgQXVkaW8gUHJvZmlsZSAvIEF1ZGlvIE9iamVjdCBUeXBlXG4gICAgMDogTnVsbFxuICAgIDE6IEFBQyBNYWluXG4gICAgMjogQUFDIExDIChMb3cgQ29tcGxleGl0eSlcbiAgICAzOiBBQUMgU1NSIChTY2FsYWJsZSBTYW1wbGUgUmF0ZSlcbiAgICA0OiBBQUMgTFRQIChMb25nIFRlcm0gUHJlZGljdGlvbilcbiAgICA1OiBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pXG4gICAgNjogQUFDIFNjYWxhYmxlXG4gICBzYW1wbGluZyBmcmVxXG4gICAgMDogOTYwMDAgSHpcbiAgICAxOiA4ODIwMCBIelxuICAgIDI6IDY0MDAwIEh6XG4gICAgMzogNDgwMDAgSHpcbiAgICA0OiA0NDEwMCBIelxuICAgIDU6IDMyMDAwIEh6XG4gICAgNjogMjQwMDAgSHpcbiAgICA3OiAyMjA1MCBIelxuICAgIDg6IDE2MDAwIEh6XG4gICAgOTogMTIwMDAgSHpcbiAgICAxMDogMTEwMjUgSHpcbiAgICAxMTogODAwMCBIelxuICAgIDEyOiA3MzUwIEh6XG4gICAgMTM6IFJlc2VydmVkXG4gICAgMTQ6IFJlc2VydmVkXG4gICAgMTU6IGZyZXF1ZW5jeSBpcyB3cml0dGVuIGV4cGxpY3RseVxuICAgIENoYW5uZWwgQ29uZmlndXJhdGlvbnNcbiAgICBUaGVzZSBhcmUgdGhlIGNoYW5uZWwgY29uZmlndXJhdGlvbnM6XG4gICAgMDogRGVmaW5lZCBpbiBBT1QgU3BlY2lmYyBDb25maWdcbiAgICAxOiAxIGNoYW5uZWw6IGZyb250LWNlbnRlclxuICAgIDI6IDIgY2hhbm5lbHM6IGZyb250LWxlZnQsIGZyb250LXJpZ2h0XG4gICovXG4gIC8vIGF1ZGlvT2JqZWN0VHlwZSA9IHByb2ZpbGUgPT4gcHJvZmlsZSwgdGhlIE1QRUctNCBBdWRpbyBPYmplY3QgVHlwZSBtaW51cyAxXG4gIGNvbmZpZ1swXSA9IGFkdHNPYmplY3RUeXBlIDw8IDM7XG4gIC8vIHNhbXBsaW5nRnJlcXVlbmN5SW5kZXhcbiAgY29uZmlnWzBdIHw9IChhZHRzU2FtcGxlaW5nSW5kZXggJiAweDBFKSA+PiAxO1xuICBjb25maWdbMV0gfD0gKGFkdHNTYW1wbGVpbmdJbmRleCAmIDB4MDEpIDw8IDc7XG4gIC8vIGNoYW5uZWxDb25maWd1cmF0aW9uXG4gIGNvbmZpZ1sxXSB8PSBhZHRzQ2hhbmVsQ29uZmlnIDw8IDM7XG4gIGlmIChhZHRzT2JqZWN0VHlwZSA9PT0gNSkge1xuICAgIC8vIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleFxuICAgIGNvbmZpZ1sxXSB8PSAoYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ICYgMHgwRSkgPj4gMTtcbiAgICBjb25maWdbMl0gPSAoYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgICAvLyBhZHRzT2JqZWN0VHlwZSAoZm9yY2UgdG8gMiwgY2hyb21lIGlzIGNoZWNraW5nIHRoYXQgb2JqZWN0IHR5cGUgaXMgbGVzcyB0aGFuIDUgPz8/XG4gICAgLy8gICAgaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy5naXQvKy9tYXN0ZXIvbWVkaWEvZm9ybWF0cy9tcDQvYWFjLmNjXG4gICAgY29uZmlnWzJdIHw9IDIgPDwgMjtcbiAgICBjb25maWdbM10gPSAwO1xuICB9XG4gIHJldHVybiB7IGNvbmZpZzogY29uZmlnLCBzYW1wbGVyYXRlOiBhZHRzU2FtcGxlaW5nUmF0ZXNbYWR0c1NhbXBsZWluZ0luZGV4XSwgY2hhbm5lbENvdW50OiBhZHRzQ2hhbmVsQ29uZmlnLCBjb2RlYzogKCdtcDRhLjQwLicgKyBhZHRzT2JqZWN0VHlwZSksIG1hbmlmZXN0Q29kZWM6IG1hbmlmZXN0Q29kZWMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSGVhZGVyUGF0dGVybiAoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGY2KSA9PT0gMHhmMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhlYWRlckxlbmd0aCAoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDEgPyA3IDogOSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGdWxsRnJhbWVMZW5ndGggKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gKChkYXRhW29mZnNldCArIDNdICYgMHgwMykgPDwgMTEpIHxcbiAgICAoZGF0YVtvZmZzZXQgKyA0XSA8PCAzKSB8XG4gICAgKChkYXRhW29mZnNldCArIDVdICYgMHhFMCkgPj4+IDUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNIZWFkZXIgKGRhdGEsIG9mZnNldCkge1xuICAvLyBMb29rIGZvciBBRFRTIGhlYWRlciB8IDExMTEgMTExMSB8IDExMTEgWDAwWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDFcbiAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyAwIGZvciBBRFRTXG4gIC8vIE1vcmUgaW5mbyBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICBpZiAob2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9iZSAoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIHNhbWUgYXMgaXNIZWFkZXIgYnV0IHdlIGFsc28gY2hlY2sgdGhhdCBBRFRTIGZyYW1lIGZvbGxvd3MgbGFzdCBBRFRTIGZyYW1lXG4gIC8vIG9yIGVuZCBvZiBkYXRhIGlzIHJlYWNoZWRcbiAgaWYgKG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSkge1xuICAgIC8vIEFEVFMgaGVhZGVyIExlbmd0aFxuICAgIGxldCBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgICAvLyBBRFRTIGZyYW1lIExlbmd0aFxuICAgIGxldCBmcmFtZUxlbmd0aCA9IGhlYWRlckxlbmd0aDtcbiAgICBpZiAob2Zmc2V0ICsgNSA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICBmcmFtZUxlbmd0aCA9IGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAgIH1cblxuICAgIGxldCBuZXdPZmZzZXQgPSBvZmZzZXQgKyBmcmFtZUxlbmd0aDtcbiAgICBpZiAobmV3T2Zmc2V0ID09PSBkYXRhLmxlbmd0aCB8fCAobmV3T2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBuZXdPZmZzZXQpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRUcmFja0NvbmZpZyAodHJhY2ssIG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgaWYgKCF0cmFjay5zYW1wbGVyYXRlKSB7XG4gICAgbGV0IGNvbmZpZyA9IGdldEF1ZGlvQ29uZmlnKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpO1xuICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgdHJhY2suc2FtcGxlcmF0ZSA9IGNvbmZpZy5zYW1wbGVyYXRlO1xuICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGNvbmZpZy5jaGFubmVsQ291bnQ7XG4gICAgdHJhY2suY29kZWMgPSBjb25maWcuY29kZWM7XG4gICAgdHJhY2subWFuaWZlc3RDb2RlYyA9IGNvbmZpZy5tYW5pZmVzdENvZGVjO1xuICAgIGxvZ2dlci5sb2coYHBhcnNlZCBjb2RlYzoke3RyYWNrLmNvZGVjfSxyYXRlOiR7Y29uZmlnLnNhbXBsZXJhdGV9LG5iIGNoYW5uZWw6JHtjb25maWcuY2hhbm5lbENvdW50fWApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFtZUR1cmF0aW9uIChzYW1wbGVyYXRlKSB7XG4gIHJldHVybiAxMDI0ICogOTAwMDAgLyBzYW1wbGVyYXRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGcmFtZUhlYWRlciAoZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgsIGZyYW1lRHVyYXRpb24pIHtcbiAgbGV0IGhlYWRlckxlbmd0aCwgZnJhbWVMZW5ndGgsIHN0YW1wO1xuICBsZXQgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgLy8gVGhlIHByb3RlY3Rpb24gc2tpcCBiaXQgdGVsbHMgdXMgaWYgd2UgaGF2ZSAyIGJ5dGVzIG9mIENSQyBkYXRhIGF0IHRoZSBlbmQgb2YgdGhlIEFEVFMgaGVhZGVyXG4gIGhlYWRlckxlbmd0aCA9IGdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAvLyByZXRyaWV2ZSBmcmFtZSBzaXplXG4gIGZyYW1lTGVuZ3RoID0gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG4gIGZyYW1lTGVuZ3RoIC09IGhlYWRlckxlbmd0aDtcblxuICBpZiAoKGZyYW1lTGVuZ3RoID4gMCkgJiYgKChvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCkgPD0gbGVuZ3RoKSkge1xuICAgIHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XG4gICAgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofS8keyhzdGFtcC85MCkudG9GaXhlZCgwKX1gKTtcbiAgICByZXR1cm4geyBoZWFkZXJMZW5ndGgsIGZyYW1lTGVuZ3RoLCBzdGFtcCB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZEZyYW1lICh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpIHtcbiAgbGV0IGZyYW1lRHVyYXRpb24gPSBnZXRGcmFtZUR1cmF0aW9uKHRyYWNrLnNhbXBsZXJhdGUpO1xuICBsZXQgaGVhZGVyID0gcGFyc2VGcmFtZUhlYWRlcihkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCwgZnJhbWVEdXJhdGlvbik7XG4gIGlmIChoZWFkZXIpIHtcbiAgICBsZXQgc3RhbXAgPSBoZWFkZXIuc3RhbXA7XG4gICAgbGV0IGhlYWRlckxlbmd0aCA9IGhlYWRlci5oZWFkZXJMZW5ndGg7XG4gICAgbGV0IGZyYW1lTGVuZ3RoID0gaGVhZGVyLmZyYW1lTGVuZ3RoO1xuXG4gICAgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofS8keyhzdGFtcC85MCkudG9GaXhlZCgwKX1gKTtcbiAgICBsZXQgYWFjU2FtcGxlID0ge1xuICAgICAgdW5pdDogZGF0YS5zdWJhcnJheShvZmZzZXQgKyBoZWFkZXJMZW5ndGgsIG9mZnNldCArIGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoKSxcbiAgICAgIHB0czogc3RhbXAsXG4gICAgICBkdHM6IHN0YW1wXG4gICAgfTtcblxuICAgIHRyYWNrLnNhbXBsZXMucHVzaChhYWNTYW1wbGUpO1xuICAgIHRyYWNrLmxlbiArPSBmcmFtZUxlbmd0aDtcblxuICAgIHJldHVybiB7IHNhbXBsZTogYWFjU2FtcGxlLCBsZW5ndGg6IGZyYW1lTGVuZ3RoICsgaGVhZGVyTGVuZ3RoIH07XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuIiwiLyoqXG4gKlxuICogaW5saW5lIGRlbXV4ZXI6IHByb2JlIGZyYWdtZW50cyBhbmQgaW5zdGFudGlhdGVcbiAqIGFwcHJvcHJpYXRlIGRlbXV4ZXIgZGVwZW5kaW5nIG9uIGNvbnRlbnQgdHlwZSAoVFNEZW11eGVyLCBBQUNEZW11eGVyLCAuLi4pXG4gKlxuICovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCBEZWNyeXB0ZXIgZnJvbSAnLi4vY3J5cHQvZGVjcnlwdGVyJztcbmltcG9ydCBBQUNEZW11eGVyIGZyb20gJy4uL2RlbXV4L2FhY2RlbXV4ZXInO1xuaW1wb3J0IE1QNERlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvbXA0ZGVtdXhlcic7XG5pbXBvcnQgVFNEZW11eGVyIGZyb20gJy4uL2RlbXV4L3RzZGVtdXhlcic7XG5pbXBvcnQgTVAzRGVtdXhlciBmcm9tICcuLi9kZW11eC9tcDNkZW11eGVyJztcbmltcG9ydCBNUDRSZW11eGVyIGZyb20gJy4uL3JlbXV4L21wNC1yZW11eGVyJztcbmltcG9ydCBQYXNzVGhyb3VnaFJlbXV4ZXIgZnJvbSAnLi4vcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlcic7XG5cbmltcG9ydCB7IGdldFNlbGZTY29wZSB9IGZyb20gJy4uL3V0aWxzL2dldC1zZWxmLXNjb3BlJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbi8vIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTEyMzcyNTkvNTg5NDkzXG5jb25zdCBnbG9iYWwgPSBnZXRTZWxmU2NvcGUoKTsgLy8gc2FmZWd1YXJkIGZvciBjb2RlIHRoYXQgbWlnaHQgcnVuIGJvdGggb24gd29ya2VyIGFuZCBtYWluIHRocmVhZFxuXG5sZXQgbm93O1xuLy8gcGVyZm9ybWFuY2Uubm93KCkgbm90IGF2YWlsYWJsZSBvbiBXZWJXb3JrZXIsIGF0IGxlYXN0IG9uIFNhZmFyaSBEZXNrdG9wXG50cnkge1xuICBub3cgPSBnbG9iYWwucGVyZm9ybWFuY2Uubm93LmJpbmQoZ2xvYmFsLnBlcmZvcm1hbmNlKTtcbn0gY2F0Y2ggKGVycikge1xuICBsb2dnZXIuZGVidWcoJ1VuYWJsZSB0byB1c2UgUGVyZm9ybWFuY2UgQVBJIG9uIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgbm93ID0gZ2xvYmFsLkRhdGUubm93O1xufVxuXG5jbGFzcyBEZW11eGVySW5saW5lIHtcbiAgY29uc3RydWN0b3IgKG9ic2VydmVyLCB0eXBlU3VwcG9ydGVkLCBjb25maWcsIHZlbmRvcikge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudmVuZG9yID0gdmVuZG9yO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgbGV0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgaWYgKGRlbXV4ZXIpIHtcbiAgICAgIGRlbXV4ZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2ggKGRhdGEsIGRlY3J5cHRkYXRhLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTKSB7XG4gICAgaWYgKChkYXRhLmJ5dGVMZW5ndGggPiAwKSAmJiAoZGVjcnlwdGRhdGEgIT0gbnVsbCkgJiYgKGRlY3J5cHRkYXRhLmtleSAhPSBudWxsKSAmJiAoZGVjcnlwdGRhdGEubWV0aG9kID09PSAnQUVTLTEyOCcpKSB7XG4gICAgICBsZXQgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXI7XG4gICAgICBpZiAoZGVjcnlwdGVyID09IG51bGwpIHtcbiAgICAgICAgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKHRoaXMub2JzZXJ2ZXIsIHRoaXMuY29uZmlnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gbm93KCk7XG4gICAgICBkZWNyeXB0ZXIuZGVjcnlwdChkYXRhLCBkZWNyeXB0ZGF0YS5rZXkuYnVmZmVyLCBkZWNyeXB0ZGF0YS5pdi5idWZmZXIsIChkZWNyeXB0ZWREYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBub3coKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfREVDUllQVEVELCB7IHN0YXRzOiB7IHRzdGFydDogc3RhcnRUaW1lLCB0ZGVjcnlwdDogZW5kVGltZSB9IH0pO1xuICAgICAgICB0aGlzLnB1c2hEZWNyeXB0ZWQobmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSksIGRlY3J5cHRkYXRhLCBuZXcgVWludDhBcnJheShpbml0U2VnbWVudCksIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoRGVjcnlwdGVkKG5ldyBVaW50OEFycmF5KGRhdGEpLCBkZWNyeXB0ZGF0YSwgbmV3IFVpbnQ4QXJyYXkoaW5pdFNlZ21lbnQpLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hEZWNyeXB0ZWQgKGRhdGEsIGRlY3J5cHRkYXRhLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTKSB7XG4gICAgbGV0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgaWYgKCFkZW11eGVyIHx8XG4gICAgICAvLyBpbiBjYXNlIG9mIGNvbnRpbnVpdHkgY2hhbmdlLCBvciB0cmFjayBzd2l0Y2hcbiAgICAgIC8vIHdlIG1pZ2h0IHN3aXRjaCBmcm9tIGNvbnRlbnQgdHlwZSAoQUFDIGNvbnRhaW5lciB0byBUUyBjb250YWluZXIsIG9yIFRTIHRvIGZtcDQgZm9yIGV4YW1wbGUpXG4gICAgICAvLyBzbyBsZXQncyBjaGVjayB0aGF0IGN1cnJlbnQgZGVtdXhlciBpcyBzdGlsbCB2YWxpZFxuICAgICAgKChkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoKSAmJiAhdGhpcy5wcm9iZShkYXRhKSkpIHtcbiAgICAgIGNvbnN0IG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcjtcbiAgICAgIGNvbnN0IHR5cGVTdXBwb3J0ZWQgPSB0aGlzLnR5cGVTdXBwb3J0ZWQ7XG4gICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgIC8vIHByb2Jpbmcgb3JkZXIgaXMgVFMvQUFDL01QMy9NUDRcbiAgICAgIGNvbnN0IG11eENvbmZpZyA9IFtcbiAgICAgICAgeyBkZW11eDogVFNEZW11eGVyLCByZW11eDogTVA0UmVtdXhlciB9LFxuICAgICAgICB7IGRlbXV4OiBNUDREZW11eGVyLCByZW11eDogUGFzc1Rocm91Z2hSZW11eGVyIH0sXG4gICAgICAgIHsgZGVtdXg6IEFBQ0RlbXV4ZXIsIHJlbXV4OiBNUDRSZW11eGVyIH0sXG4gICAgICAgIHsgZGVtdXg6IE1QM0RlbXV4ZXIsIHJlbXV4OiBNUDRSZW11eGVyIH1cbiAgICAgIF07XG5cbiAgICAgIC8vIHByb2JlIGZvciBjb250ZW50IHR5cGVcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtdXhDb25maWcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgbXV4ID0gbXV4Q29uZmlnW2ldO1xuICAgICAgICBjb25zdCBwcm9iZSA9IG11eC5kZW11eC5wcm9iZTtcbiAgICAgICAgaWYgKHByb2JlKGRhdGEpKSB7XG4gICAgICAgICAgY29uc3QgcmVtdXhlciA9IHRoaXMucmVtdXhlciA9IG5ldyBtdXgucmVtdXgob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCwgdGhpcy52ZW5kb3IpO1xuICAgICAgICAgIGRlbXV4ZXIgPSBuZXcgbXV4LmRlbXV4KG9ic2VydmVyLCByZW11eGVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQpO1xuICAgICAgICAgIHRoaXMucHJvYmUgPSBwcm9iZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFkZW11eGVyKSB7XG4gICAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IHRydWUsIHJlYXNvbjogJ25vIGRlbXV4IG1hdGNoaW5nIHdpdGggY29udGVudCBmb3VuZCcgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVtdXhlciA9IGRlbXV4ZXI7XG4gICAgfVxuICAgIGNvbnN0IHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XG5cbiAgICBpZiAoZGlzY29udGludWl0eSB8fCB0cmFja1N3aXRjaCkge1xuICAgICAgZGVtdXhlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbik7XG4gICAgICByZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoKTtcbiAgICB9XG4gICAgaWYgKGRpc2NvbnRpbnVpdHkpIHtcbiAgICAgIGRlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQVFMpO1xuICAgICAgcmVtdXhlci5yZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFBUUyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGVtdXhlci5zZXREZWNyeXB0RGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGVtdXhlci5zZXREZWNyeXB0RGF0YShkZWNyeXB0ZGF0YSk7XG4gICAgfVxuXG4gICAgZGVtdXhlci5hcHBlbmQoZGF0YSwgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZW11eGVySW5saW5lO1xuIiwiLyogZGVtdXhlciB3ZWIgd29ya2VyLlxuICogIC0gbGlzdGVuIHRvIHdvcmtlciBtZXNzYWdlLCBhbmQgdHJpZ2dlciBEZW11eGVySW5saW5lIHVwb24gcmVjZXB0aW9uIG9mIEZyYWdtZW50cy5cbiAqICAtIHByb3ZpZGVzIE1QNCBCb3hlcyBiYWNrIHRvIG1haW4gdGhyZWFkIHVzaW5nIFt0cmFuc2ZlcmFibGUgb2JqZWN0c10oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3VwZGF0ZXMvMjAxMS8xMi9UcmFuc2ZlcmFibGUtT2JqZWN0cy1MaWdodG5pbmctRmFzdCkgaW4gb3JkZXIgdG8gbWluaW1pemUgbWVzc2FnZSBwYXNzaW5nIG92ZXJoZWFkLlxuICovXG5cbmltcG9ydCBEZW11eGVySW5saW5lIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXItaW5saW5lJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgZW5hYmxlTG9ncyB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5cbmxldCBEZW11eGVyV29ya2VyID0gZnVuY3Rpb24gKHNlbGYpIHtcbiAgLy8gb2JzZXJ2ZXIgc2V0dXBcbiAgbGV0IG9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBvYnNlcnZlci50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlciAoZXZlbnQsIC4uLmRhdGEpIHtcbiAgICBvYnNlcnZlci5lbWl0KGV2ZW50LCBldmVudCwgLi4uZGF0YSk7XG4gIH07XG5cbiAgb2JzZXJ2ZXIub2ZmID0gZnVuY3Rpb24gb2ZmIChldmVudCwgLi4uZGF0YSkge1xuICAgIG9ic2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCAuLi5kYXRhKTtcbiAgfTtcblxuICBsZXQgZm9yd2FyZE1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHsgZXZlbnQ6IGV2LCBkYXRhOiBkYXRhIH0pO1xuICB9O1xuXG4gIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgIGxldCBkYXRhID0gZXYuZGF0YTtcbiAgICAvLyBjb25zb2xlLmxvZygnZGVtdXhlciBjbWQ6JyArIGRhdGEuY21kKTtcbiAgICBzd2l0Y2ggKGRhdGEuY21kKSB7XG4gICAgY2FzZSAnaW5pdCc6XG4gICAgICBjb25zdCBjb25maWcgPSBKU09OLnBhcnNlKGRhdGEuY29uZmlnKTtcbiAgICAgIHNlbGYuZGVtdXhlciA9IG5ldyBEZW11eGVySW5saW5lKG9ic2VydmVyLCBkYXRhLnR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgZGF0YS52ZW5kb3IpO1xuXG4gICAgICBlbmFibGVMb2dzKGNvbmZpZy5kZWJ1Zyk7XG5cbiAgICAgIC8vIHNpZ25hbCBlbmQgb2Ygd29ya2VyIGluaXRcbiAgICAgIGZvcndhcmRNZXNzYWdlKCdpbml0JywgbnVsbCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkZW11eCc6XG4gICAgICBzZWxmLmRlbXV4ZXIucHVzaChkYXRhLmRhdGEsIGRhdGEuZGVjcnlwdGRhdGEsIGRhdGEuaW5pdFNlZ21lbnQsIGRhdGEuYXVkaW9Db2RlYywgZGF0YS52aWRlb0NvZGVjLCBkYXRhLnRpbWVPZmZzZXQsIGRhdGEuZGlzY29udGludWl0eSwgZGF0YS50cmFja1N3aXRjaCwgZGF0YS5jb250aWd1b3VzLCBkYXRhLmR1cmF0aW9uLCBkYXRhLmFjY3VyYXRlVGltZU9mZnNldCwgZGF0YS5kZWZhdWx0SW5pdFBUUyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcblxuICAvLyBmb3J3YXJkIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICBvYnNlcnZlci5vbihFdmVudC5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0VELCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19NRVRBREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xuICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnQuSU5JVF9QVFNfRk9VTkQsIGZvcndhcmRNZXNzYWdlKTtcblxuICAvLyBzcGVjaWFsIGNhc2UgZm9yIEZSQUdfUEFSU0lOR19EQVRBOiBwYXNzIGRhdGExL2RhdGEyIGFzIHRyYW5zZmVyYWJsZSBvYmplY3QgKG5vIGNvcHkpXG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcbiAgICBsZXQgdHJhbnNmZXJhYmxlID0gW107XG4gICAgbGV0IG1lc3NhZ2UgPSB7IGV2ZW50OiBldiwgZGF0YTogZGF0YSB9O1xuICAgIGlmIChkYXRhLmRhdGExKSB7XG4gICAgICBtZXNzYWdlLmRhdGExID0gZGF0YS5kYXRhMS5idWZmZXI7XG4gICAgICB0cmFuc2ZlcmFibGUucHVzaChkYXRhLmRhdGExLmJ1ZmZlcik7XG4gICAgICBkZWxldGUgZGF0YS5kYXRhMTtcbiAgICB9XG4gICAgaWYgKGRhdGEuZGF0YTIpIHtcbiAgICAgIG1lc3NhZ2UuZGF0YTIgPSBkYXRhLmRhdGEyLmJ1ZmZlcjtcbiAgICAgIHRyYW5zZmVyYWJsZS5wdXNoKGRhdGEuZGF0YTIuYnVmZmVyKTtcbiAgICAgIGRlbGV0ZSBkYXRhLmRhdGEyO1xuICAgIH1cbiAgICBzZWxmLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyYWJsZSk7XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRGVtdXhlcldvcmtlcjtcbiIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgKiBhcyB3b3JrIGZyb20gJ3dlYndvcmtpZnktd2VicGFjayc7XG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IERlbXV4ZXJJbmxpbmUgZnJvbSAnLi4vZGVtdXgvZGVtdXhlci1pbmxpbmUnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBnZXRNZWRpYVNvdXJjZSB9IGZyb20gJy4uL3V0aWxzL21lZGlhc291cmNlLWhlbHBlcic7XG5pbXBvcnQgeyBnZXRTZWxmU2NvcGUgfSBmcm9tICcuLi91dGlscy9nZXQtc2VsZi1zY29wZSc7XG5cbmltcG9ydCB7IE9ic2VydmVyIH0gZnJvbSAnLi4vb2JzZXJ2ZXInO1xuXG4vLyBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExMjM3MjU5LzU4OTQ5M1xuY29uc3QgZ2xvYmFsID0gZ2V0U2VsZlNjb3BlKCk7IC8vIHNhZmVndWFyZCBmb3IgY29kZSB0aGF0IG1pZ2h0IHJ1biBib3RoIG9uIHdvcmtlciBhbmQgbWFpbiB0aHJlYWRcbmNvbnN0IE1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UoKTtcblxuY2xhc3MgRGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yIChobHMsIGlkKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5pZCA9IGlkO1xuXG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyID0gbmV3IE9ic2VydmVyKCk7XG4gICAgY29uc3QgY29uZmlnID0gaGxzLmNvbmZpZztcblxuICAgIGNvbnN0IGZvcndhcmRNZXNzYWdlID0gKGV2LCBkYXRhKSA9PiB7XG4gICAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgIGRhdGEuZnJhZyA9IHRoaXMuZnJhZztcbiAgICAgIGRhdGEuaWQgPSB0aGlzLmlkO1xuICAgICAgaGxzLnRyaWdnZXIoZXYsIGRhdGEpO1xuICAgIH07XG5cbiAgICAvLyBmb3J3YXJkIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICAgIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfREVDUllQVEVELCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTRUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihFdmVudC5FUlJPUiwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19NRVRBREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLm9uKEV2ZW50LklOSVRfUFRTX0ZPVU5ELCBmb3J3YXJkTWVzc2FnZSk7XG5cbiAgICBjb25zdCB0eXBlU3VwcG9ydGVkID0ge1xuICAgICAgbXA0OiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNCcpLFxuICAgICAgbXBlZzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcGVnJyksXG4gICAgICBtcDM6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXA0OyBjb2RlY3M9XCJtcDNcIicpXG4gICAgfTtcbiAgICAvLyBuYXZpZ2F0b3IudmVuZG9yIGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlIGluIFdlYiBXb3JrZXJcbiAgICAvLyByZWZlciB0byBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV29ya2VyR2xvYmFsU2NvcGUvbmF2aWdhdG9yXG4gICAgY29uc3QgdmVuZG9yID0gbmF2aWdhdG9yLnZlbmRvcjtcbiAgICBpZiAoY29uZmlnLmVuYWJsZVdvcmtlciAmJiAodHlwZW9mIChXb3JrZXIpICE9PSAndW5kZWZpbmVkJykpIHtcbiAgICAgIGxvZ2dlci5sb2coJ2RlbXV4aW5nIGluIHdlYndvcmtlcicpO1xuICAgICAgbGV0IHc7XG4gICAgICB0cnkge1xuICAgICAgICB3ID0gdGhpcy53ID0gd29yayhyZXF1aXJlLnJlc29sdmUoJy4uL2RlbXV4L2RlbXV4ZXItd29ya2VyLmpzJykpO1xuICAgICAgICB0aGlzLm9ud21zZyA9IHRoaXMub25Xb3JrZXJNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHcuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMub253bXNnKTtcbiAgICAgICAgdy5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTiwgZmF0YWw6IHRydWUsIGV2ZW50OiAnZGVtdXhlcldvcmtlcicsIGVycjogeyBtZXNzYWdlOiBldmVudC5tZXNzYWdlICsgJyAoJyArIGV2ZW50LmZpbGVuYW1lICsgJzonICsgZXZlbnQubGluZW5vICsgJyknIH0gfSk7XG4gICAgICAgIH07XG4gICAgICAgIHcucG9zdE1lc3NhZ2UoeyBjbWQ6ICdpbml0JywgdHlwZVN1cHBvcnRlZDogdHlwZVN1cHBvcnRlZCwgdmVuZG9yOiB2ZW5kb3IsIGlkOiBpZCwgY29uZmlnOiBKU09OLnN0cmluZ2lmeShjb25maWcpIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdFcnJvciBpbiB3b3JrZXI6JywgZXJyKTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciB3aGlsZSBpbml0aWFsaXppbmcgRGVtdXhlcldvcmtlciwgZmFsbGJhY2sgb24gRGVtdXhlcklubGluZScpO1xuICAgICAgICBpZiAodykge1xuICAgICAgICAgIC8vIHJldm9rZSB0aGUgT2JqZWN0IFVSTCB0aGF0IHdhcyB1c2VkIHRvIGNyZWF0ZSBkZW11eGVyIHdvcmtlciwgc28gYXMgbm90IHRvIGxlYWsgaXRcbiAgICAgICAgICBnbG9iYWwuVVJMLnJldm9rZU9iamVjdFVSTCh3Lm9iamVjdFVSTCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXJJbmxpbmUob2JzZXJ2ZXIsIHR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgdmVuZG9yKTtcbiAgICAgICAgdGhpcy53ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcklubGluZShvYnNlcnZlciwgdHlwZVN1cHBvcnRlZCwgY29uZmlnLCB2ZW5kb3IpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGxldCB3ID0gdGhpcy53O1xuICAgIGlmICh3KSB7XG4gICAgICB3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyk7XG4gICAgICB3LnRlcm1pbmF0ZSgpO1xuICAgICAgdGhpcy53ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgICBpZiAoZGVtdXhlcikge1xuICAgICAgICBkZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgb2JzZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdXNoIChkYXRhLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZnJhZywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpIHtcbiAgICBjb25zdCB3ID0gdGhpcy53O1xuICAgIGNvbnN0IHRpbWVPZmZzZXQgPSBOdW1iZXIuaXNGaW5pdGUoZnJhZy5zdGFydFBUUykgPyBmcmFnLnN0YXJ0UFRTIDogZnJhZy5zdGFydDtcbiAgICBjb25zdCBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgY29uc3QgbGFzdEZyYWcgPSB0aGlzLmZyYWc7XG4gICAgY29uc3QgZGlzY29udGludWl0eSA9ICEobGFzdEZyYWcgJiYgKGZyYWcuY2MgPT09IGxhc3RGcmFnLmNjKSk7XG4gICAgY29uc3QgdHJhY2tTd2l0Y2ggPSAhKGxhc3RGcmFnICYmIChmcmFnLmxldmVscyA9PT0gbGFzdEZyYWcubGV2ZWxzKSk7XG4gICAgY29uc3QgbmV4dFNOID0gbGFzdEZyYWcgJiYgKGZyYWcuc24gPT09IChsYXN0RnJhZy5zbiArIDEpKTtcbiAgICBjb25zdCBjb250aWd1b3VzID0gIXRyYWNrU3dpdGNoICYmIG5leHRTTjtcbiAgICBpZiAoZGlzY29udGludWl0eSkge1xuICAgICAgbG9nZ2VyLmxvZyhgJHt0aGlzLmlkfTpkaXNjb250aW51aXR5IGRldGVjdGVkYCk7XG4gICAgfVxuXG4gICAgaWYgKHRyYWNrU3dpdGNoKSB7XG4gICAgICBsb2dnZXIubG9nKGAke3RoaXMuaWR9OnN3aXRjaCBkZXRlY3RlZGApO1xuICAgIH1cblxuICAgIHRoaXMuZnJhZyA9IGZyYWc7XG4gICAgaWYgKHcpIHtcbiAgICAgIC8vIHBvc3QgZnJhZ21lbnQgcGF5bG9hZCBhcyB0cmFuc2ZlcmFibGUgb2JqZWN0cyBmb3IgQXJyYXlCdWZmZXIgKG5vIGNvcHkpXG4gICAgICB3LnBvc3RNZXNzYWdlKHsgY21kOiAnZGVtdXgnLCBkYXRhLCBkZWNyeXB0ZGF0YSwgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUyB9LCBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBbZGF0YV0gOiBbXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xuICAgICAgaWYgKGRlbXV4ZXIpIHtcbiAgICAgICAgZGVtdXhlci5wdXNoKGRhdGEsIGRlY3J5cHRkYXRhLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbldvcmtlck1lc3NhZ2UgKGV2KSB7XG4gICAgbGV0IGRhdGEgPSBldi5kYXRhLFxuICAgICAgaGxzID0gdGhpcy5obHM7XG4gICAgc3dpdGNoIChkYXRhLmV2ZW50KSB7XG4gICAgY2FzZSAnaW5pdCc6XG4gICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgZGVtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICBnbG9iYWwuVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLncub2JqZWN0VVJMKTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBGUkFHX1BBUlNJTkdfREFUQTogZGF0YTEgYW5kIGRhdGEyIGFyZSB0cmFuc2ZlcmFibGUgb2JqZWN0c1xuICAgIGNhc2UgRXZlbnQuRlJBR19QQVJTSU5HX0RBVEE6XG4gICAgICBkYXRhLmRhdGEuZGF0YTEgPSBuZXcgVWludDhBcnJheShkYXRhLmRhdGExKTtcbiAgICAgIGlmIChkYXRhLmRhdGEyKSB7XG4gICAgICAgIGRhdGEuZGF0YS5kYXRhMiA9IG5ldyBVaW50OEFycmF5KGRhdGEuZGF0YTIpO1xuICAgICAgfVxuXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgZGVmYXVsdDpcbiAgICAgIGRhdGEuZGF0YSA9IGRhdGEuZGF0YSB8fCB7fTtcbiAgICAgIGRhdGEuZGF0YS5mcmFnID0gdGhpcy5mcmFnO1xuICAgICAgZGF0YS5kYXRhLmlkID0gdGhpcy5pZDtcbiAgICAgIGhscy50cmlnZ2VyKGRhdGEuZXZlbnQsIGRhdGEuZGF0YSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGVtdXhlcjtcbiIsIi8qKlxuICogUGFyc2VyIGZvciBleHBvbmVudGlhbCBHb2xvbWIgY29kZXMsIGEgdmFyaWFibGUtYml0d2lkdGggbnVtYmVyIGVuY29kaW5nIHNjaGVtZSB1c2VkIGJ5IGgyNjQuXG4qL1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jbGFzcyBFeHBHb2xvbWIge1xuICBjb25zdHJ1Y3RvciAoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhpcy5kYXRhXG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAvLyB0aGUgY3VycmVudCB3b3JkIGJlaW5nIGV4YW1pbmVkXG4gICAgdGhpcy53b3JkID0gMDsgLy8gOnVpbnRcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJpdHMgbGVmdCB0byBleGFtaW5lIGluIHRoZSBjdXJyZW50IHdvcmRcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSAwOyAvLyA6dWludFxuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBsb2FkV29yZCAoKSB7XG4gICAgbGV0XG4gICAgICBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgYnl0ZXNBdmFpbGFibGUgPSB0aGlzLmJ5dGVzQXZhaWxhYmxlLFxuICAgICAgcG9zaXRpb24gPSBkYXRhLmJ5dGVMZW5ndGggLSBieXRlc0F2YWlsYWJsZSxcbiAgICAgIHdvcmtpbmdCeXRlcyA9IG5ldyBVaW50OEFycmF5KDQpLFxuICAgICAgYXZhaWxhYmxlQnl0ZXMgPSBNYXRoLm1pbig0LCBieXRlc0F2YWlsYWJsZSk7XG4gICAgaWYgKGF2YWlsYWJsZUJ5dGVzID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJ5dGVzIGF2YWlsYWJsZScpO1xuICAgIH1cblxuICAgIHdvcmtpbmdCeXRlcy5zZXQoZGF0YS5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBhdmFpbGFibGVCeXRlcykpO1xuICAgIHRoaXMud29yZCA9IG5ldyBEYXRhVmlldyh3b3JraW5nQnl0ZXMuYnVmZmVyKS5nZXRVaW50MzIoMCk7XG4gICAgLy8gdHJhY2sgdGhlIGFtb3VudCBvZiB0aGlzLmRhdGEgdGhhdCBoYXMgYmVlbiBwcm9jZXNzZWRcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSBhdmFpbGFibGVCeXRlcyAqIDg7XG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSAtPSBhdmFpbGFibGVCeXRlcztcbiAgfVxuXG4gIC8vIChjb3VudDppbnQpOnZvaWRcbiAgc2tpcEJpdHMgKGNvdW50KSB7XG4gICAgbGV0IHNraXBCeXRlczsgLy8gOmludFxuICAgIGlmICh0aGlzLmJpdHNBdmFpbGFibGUgPiBjb3VudCkge1xuICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgLT0gdGhpcy5iaXRzQXZhaWxhYmxlO1xuICAgICAgc2tpcEJ5dGVzID0gY291bnQgPj4gMztcbiAgICAgIGNvdW50IC09IChza2lwQnl0ZXMgPj4gMyk7XG4gICAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IHNraXBCeXRlcztcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gKHNpemU6aW50KTp1aW50XG4gIHJlYWRCaXRzIChzaXplKSB7XG4gICAgbGV0XG4gICAgICBiaXRzID0gTWF0aC5taW4odGhpcy5iaXRzQXZhaWxhYmxlLCBzaXplKSwgLy8gOnVpbnRcbiAgICAgIHZhbHUgPSB0aGlzLndvcmQgPj4+ICgzMiAtIGJpdHMpOyAvLyA6dWludFxuICAgIGlmIChzaXplID4gMzIpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignQ2Fubm90IHJlYWQgbW9yZSB0aGFuIDMyIGJpdHMgYXQgYSB0aW1lJyk7XG4gICAgfVxuXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGJpdHM7XG4gICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IDApIHtcbiAgICAgIHRoaXMud29yZCA8PD0gYml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXNBdmFpbGFibGUgPiAwKSB7XG4gICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgfVxuXG4gICAgYml0cyA9IHNpemUgLSBiaXRzO1xuICAgIGlmIChiaXRzID4gMCAmJiB0aGlzLmJpdHNBdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiB2YWx1IDw8IGJpdHMgfCB0aGlzLnJlYWRCaXRzKGJpdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsdTtcbiAgICB9XG4gIH1cblxuICAvLyAoKTp1aW50XG4gIHNraXBMWiAoKSB7XG4gICAgbGV0IGxlYWRpbmdaZXJvQ291bnQ7IC8vIDp1aW50XG4gICAgZm9yIChsZWFkaW5nWmVyb0NvdW50ID0gMDsgbGVhZGluZ1plcm9Db3VudCA8IHRoaXMuYml0c0F2YWlsYWJsZTsgKytsZWFkaW5nWmVyb0NvdW50KSB7XG4gICAgICBpZiAoKHRoaXMud29yZCAmICgweDgwMDAwMDAwID4+PiBsZWFkaW5nWmVyb0NvdW50KSkgIT09IDApIHtcbiAgICAgICAgLy8gdGhlIGZpcnN0IGJpdCBvZiB3b3JraW5nIHdvcmQgaXMgMVxuICAgICAgICB0aGlzLndvcmQgPDw9IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd2UgZXhoYXVzdGVkIHdvcmQgYW5kIHN0aWxsIGhhdmUgbm90IGZvdW5kIGEgMVxuICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudCArIHRoaXMuc2tpcExaKCk7XG4gIH1cblxuICAvLyAoKTp2b2lkXG4gIHNraXBVRUcgKCkge1xuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBza2lwRUcgKCkge1xuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICB9XG5cbiAgLy8gKCk6dWludFxuICByZWFkVUVHICgpIHtcbiAgICBsZXQgY2x6ID0gdGhpcy5za2lwTFooKTsgLy8gOnVpbnRcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cyhjbHogKyAxKSAtIDE7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZEVHICgpIHtcbiAgICBsZXQgdmFsdSA9IHRoaXMucmVhZFVFRygpOyAvLyA6aW50XG4gICAgaWYgKDB4MDEgJiB2YWx1KSB7XG4gICAgICAvLyB0aGUgbnVtYmVyIGlzIG9kZCBpZiB0aGUgbG93IG9yZGVyIGJpdCBpcyBzZXRcbiAgICAgIHJldHVybiAoMSArIHZhbHUpID4+PiAxOyAvLyBhZGQgMSB0byBtYWtlIGl0IGV2ZW4sIGFuZCBkaXZpZGUgYnkgMlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTEgKiAodmFsdSA+Pj4gMSk7IC8vIGRpdmlkZSBieSB0d28gdGhlbiBtYWtlIGl0IG5lZ2F0aXZlXG4gICAgfVxuICB9XG5cbiAgLy8gU29tZSBjb252ZW5pZW5jZSBmdW5jdGlvbnNcbiAgLy8gOkJvb2xlYW5cbiAgcmVhZEJvb2xlYW4gKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDEpID09PSAxO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIHJlYWRVQnl0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoOCk7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZFVTaG9ydCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMTYpO1xuICB9XG4gIC8vICgpOmludFxuICByZWFkVUludCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMzIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkdmFuY2UgdGhlIEV4cEdvbG9tYiBkZWNvZGVyIHBhc3QgYSBzY2FsaW5nIGxpc3QuIFRoZSBzY2FsaW5nXG4gICAqIGxpc3QgaXMgb3B0aW9uYWxseSB0cmFuc21pdHRlZCBhcyBwYXJ0IG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyXG4gICAqIHNldCBhbmQgaXMgbm90IHJlbGV2YW50IHRvIHRyYW5zbXV4aW5nLlxuICAgKiBAcGFyYW0gY291bnQge251bWJlcn0gdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIHRoaXMgc2NhbGluZyBsaXN0XG4gICAqIEBzZWUgUmVjb21tZW5kYXRpb24gSVRVLVQgSC4yNjQsIFNlY3Rpb24gNy4zLjIuMS4xLjFcbiAgICovXG4gIHNraXBTY2FsaW5nTGlzdCAoY291bnQpIHtcbiAgICBsZXRcbiAgICAgIGxhc3RTY2FsZSA9IDgsXG4gICAgICBuZXh0U2NhbGUgPSA4LFxuICAgICAgaixcbiAgICAgIGRlbHRhU2NhbGU7XG4gICAgZm9yIChqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgIGlmIChuZXh0U2NhbGUgIT09IDApIHtcbiAgICAgICAgZGVsdGFTY2FsZSA9IHRoaXMucmVhZEVHKCk7XG4gICAgICAgIG5leHRTY2FsZSA9IChsYXN0U2NhbGUgKyBkZWx0YVNjYWxlICsgMjU2KSAlIDI1NjtcbiAgICAgIH1cbiAgICAgIGxhc3RTY2FsZSA9IChuZXh0U2NhbGUgPT09IDApID8gbGFzdFNjYWxlIDogbmV4dFNjYWxlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBhbmQgcmV0dXJuIHNvbWUgaW50ZXJlc3RpbmcgdmlkZW9cbiAgICogcHJvcGVydGllcy4gQSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGlzIHRoZSBIMjY0IG1ldGFkYXRhIHRoYXRcbiAgICogZGVzY3JpYmVzIHRoZSBwcm9wZXJ0aWVzIG9mIHVwY29taW5nIHZpZGVvIGZyYW1lcy5cbiAgICogQHBhcmFtIGRhdGEge1VpbnQ4QXJyYXl9IHRoZSBieXRlcyBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXRcbiAgICogQHJldHVybiB7b2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHBhcnNlZCBmcm9tIHRoZVxuICAgKiBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0LCBpbmNsdWRpbmcgdGhlIGRpbWVuc2lvbnMgb2YgdGhlXG4gICAqIGFzc29jaWF0ZWQgdmlkZW8gZnJhbWVzLlxuICAgKi9cbiAgcmVhZFNQUyAoKSB7XG4gICAgbGV0XG4gICAgICBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gMCxcbiAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gMCxcbiAgICAgIGZyYW1lQ3JvcFRvcE9mZnNldCA9IDAsXG4gICAgICBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSAwLFxuICAgICAgcHJvZmlsZUlkYywgcHJvZmlsZUNvbXBhdCwgbGV2ZWxJZGMsXG4gICAgICBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUsIHBpY1dpZHRoSW5NYnNNaW51czEsXG4gICAgICBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxLFxuICAgICAgZnJhbWVNYnNPbmx5RmxhZyxcbiAgICAgIHNjYWxpbmdMaXN0Q291bnQsXG4gICAgICBpLFxuICAgICAgcmVhZFVCeXRlID0gdGhpcy5yZWFkVUJ5dGUuYmluZCh0aGlzKSxcbiAgICAgIHJlYWRCaXRzID0gdGhpcy5yZWFkQml0cy5iaW5kKHRoaXMpLFxuICAgICAgcmVhZFVFRyA9IHRoaXMucmVhZFVFRy5iaW5kKHRoaXMpLFxuICAgICAgcmVhZEJvb2xlYW4gPSB0aGlzLnJlYWRCb29sZWFuLmJpbmQodGhpcyksXG4gICAgICBza2lwQml0cyA9IHRoaXMuc2tpcEJpdHMuYmluZCh0aGlzKSxcbiAgICAgIHNraXBFRyA9IHRoaXMuc2tpcEVHLmJpbmQodGhpcyksXG4gICAgICBza2lwVUVHID0gdGhpcy5za2lwVUVHLmJpbmQodGhpcyksXG4gICAgICBza2lwU2NhbGluZ0xpc3QgPSB0aGlzLnNraXBTY2FsaW5nTGlzdC5iaW5kKHRoaXMpO1xuXG4gICAgcmVhZFVCeXRlKCk7XG4gICAgcHJvZmlsZUlkYyA9IHJlYWRVQnl0ZSgpOyAvLyBwcm9maWxlX2lkY1xuICAgIHByb2ZpbGVDb21wYXQgPSByZWFkQml0cyg1KTsgLy8gY29uc3RyYWludF9zZXRbMC00XV9mbGFnLCB1KDUpXG4gICAgc2tpcEJpdHMoMyk7IC8vIHJlc2VydmVkX3plcm9fM2JpdHMgdSgzKSxcbiAgICBsZXZlbElkYyA9IHJlYWRVQnl0ZSgpOyAvLyBsZXZlbF9pZGMgdSg4KVxuICAgIHNraXBVRUcoKTsgLy8gc2VxX3BhcmFtZXRlcl9zZXRfaWRcbiAgICAvLyBzb21lIHByb2ZpbGVzIGhhdmUgbW9yZSBvcHRpb25hbCBkYXRhIHdlIGRvbid0IG5lZWRcbiAgICBpZiAocHJvZmlsZUlkYyA9PT0gMTAwIHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDExMCB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSAxMjIgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMjQ0IHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDQ0IHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDgzIHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDg2IHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDExOCB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSAxMjgpIHtcbiAgICAgIGxldCBjaHJvbWFGb3JtYXRJZGMgPSByZWFkVUVHKCk7XG4gICAgICBpZiAoY2hyb21hRm9ybWF0SWRjID09PSAzKSB7XG4gICAgICAgIHNraXBCaXRzKDEpO1xuICAgICAgfSAvLyBzZXBhcmF0ZV9jb2xvdXJfcGxhbmVfZmxhZ1xuXG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9sdW1hX21pbnVzOFxuICAgICAgc2tpcFVFRygpOyAvLyBiaXRfZGVwdGhfY2hyb21hX21pbnVzOFxuICAgICAgc2tpcEJpdHMoMSk7IC8vIHFwcHJpbWVfeV96ZXJvX3RyYW5zZm9ybV9ieXBhc3NfZmxhZ1xuICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHsgLy8gc2VxX3NjYWxpbmdfbWF0cml4X3ByZXNlbnRfZmxhZ1xuICAgICAgICBzY2FsaW5nTGlzdENvdW50ID0gKGNocm9tYUZvcm1hdElkYyAhPT0gMykgPyA4IDogMTI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FsaW5nTGlzdENvdW50OyBpKyspIHtcbiAgICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkgeyAvLyBzZXFfc2NhbGluZ19saXN0X3ByZXNlbnRfZmxhZ1sgaSBdXG4gICAgICAgICAgICBpZiAoaSA8IDYpIHtcbiAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDE2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCg2NCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNraXBVRUcoKTsgLy8gbG9nMl9tYXhfZnJhbWVfbnVtX21pbnVzNFxuICAgIGxldCBwaWNPcmRlckNudFR5cGUgPSByZWFkVUVHKCk7XG4gICAgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMCkge1xuICAgICAgcmVhZFVFRygpOyAvLyBsb2cyX21heF9waWNfb3JkZXJfY250X2xzYl9taW51czRcbiAgICB9IGVsc2UgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMSkge1xuICAgICAgc2tpcEJpdHMoMSk7IC8vIGRlbHRhX3BpY19vcmRlcl9hbHdheXNfemVyb19mbGFnXG4gICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl9ub25fcmVmX3BpY1xuICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3JfdG9wX3RvX2JvdHRvbV9maWVsZFxuICAgICAgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlID0gcmVhZFVFRygpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTsgaSsrKSB7XG4gICAgICAgIHNraXBFRygpO1xuICAgICAgfSAvLyBvZmZzZXRfZm9yX3JlZl9mcmFtZVsgaSBdXG4gICAgfVxuICAgIHNraXBVRUcoKTsgLy8gbWF4X251bV9yZWZfZnJhbWVzXG4gICAgc2tpcEJpdHMoMSk7IC8vIGdhcHNfaW5fZnJhbWVfbnVtX3ZhbHVlX2FsbG93ZWRfZmxhZ1xuICAgIHBpY1dpZHRoSW5NYnNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgcGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSA9IHJlYWRVRUcoKTtcbiAgICBmcmFtZU1ic09ubHlGbGFnID0gcmVhZEJpdHMoMSk7XG4gICAgaWYgKGZyYW1lTWJzT25seUZsYWcgPT09IDApIHtcbiAgICAgIHNraXBCaXRzKDEpO1xuICAgIH0gLy8gbWJfYWRhcHRpdmVfZnJhbWVfZmllbGRfZmxhZ1xuXG4gICAgc2tpcEJpdHMoMSk7IC8vIGRpcmVjdF84eDhfaW5mZXJlbmNlX2ZsYWdcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkgeyAvLyBmcmFtZV9jcm9wcGluZ19mbGFnXG4gICAgICBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgfVxuICAgIGxldCBwaXhlbFJhdGlvID0gWzEsIDFdO1xuICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAvLyB2dWlfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWdcbiAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgIC8vIGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpb0lkYyA9IHJlYWRVQnl0ZSgpO1xuICAgICAgICBzd2l0Y2ggKGFzcGVjdFJhdGlvSWRjKSB7XG4gICAgICAgIGNhc2UgMTogcGl4ZWxSYXRpbyA9IFsxLCAxXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogcGl4ZWxSYXRpbyA9IFsxMiwgMTFdOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBwaXhlbFJhdGlvID0gWzEwLCAxMV07IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IHBpeGVsUmF0aW8gPSBbMTYsIDExXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNTogcGl4ZWxSYXRpbyA9IFs0MCwgMzNdOyBicmVhaztcbiAgICAgICAgY2FzZSA2OiBwaXhlbFJhdGlvID0gWzI0LCAxMV07IGJyZWFrO1xuICAgICAgICBjYXNlIDc6IHBpeGVsUmF0aW8gPSBbMjAsIDExXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgODogcGl4ZWxSYXRpbyA9IFszMiwgMTFdOyBicmVhaztcbiAgICAgICAgY2FzZSA5OiBwaXhlbFJhdGlvID0gWzgwLCAzM107IGJyZWFrO1xuICAgICAgICBjYXNlIDEwOiBwaXhlbFJhdGlvID0gWzE4LCAxMV07IGJyZWFrO1xuICAgICAgICBjYXNlIDExOiBwaXhlbFJhdGlvID0gWzE1LCAxMV07IGJyZWFrO1xuICAgICAgICBjYXNlIDEyOiBwaXhlbFJhdGlvID0gWzY0LCAzM107IGJyZWFrO1xuICAgICAgICBjYXNlIDEzOiBwaXhlbFJhdGlvID0gWzE2MCwgOTldOyBicmVhaztcbiAgICAgICAgY2FzZSAxNDogcGl4ZWxSYXRpbyA9IFs0LCAzXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMTU6IHBpeGVsUmF0aW8gPSBbMywgMl07IGJyZWFrO1xuICAgICAgICBjYXNlIDE2OiBwaXhlbFJhdGlvID0gWzIsIDFdOyBicmVhaztcbiAgICAgICAgY2FzZSAyNTU6IHtcbiAgICAgICAgICBwaXhlbFJhdGlvID0gW3JlYWRVQnl0ZSgpIDw8IDggfCByZWFkVUJ5dGUoKSwgcmVhZFVCeXRlKCkgPDwgOCB8IHJlYWRVQnl0ZSgpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogTWF0aC5jZWlsKCgoKHBpY1dpZHRoSW5NYnNNaW51czEgKyAxKSAqIDE2KSAtIGZyYW1lQ3JvcExlZnRPZmZzZXQgKiAyIC0gZnJhbWVDcm9wUmlnaHRPZmZzZXQgKiAyKSksXG4gICAgICBoZWlnaHQ6ICgoMiAtIGZyYW1lTWJzT25seUZsYWcpICogKHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgKyAxKSAqIDE2KSAtICgoZnJhbWVNYnNPbmx5RmxhZyA/IDIgOiA0KSAqIChmcmFtZUNyb3BUb3BPZmZzZXQgKyBmcmFtZUNyb3BCb3R0b21PZmZzZXQpKSxcbiAgICAgIHBpeGVsUmF0aW86IHBpeGVsUmF0aW9cbiAgICB9O1xuICB9XG5cbiAgcmVhZFNsaWNlVHlwZSAoKSB7XG4gICAgLy8gc2tpcCBOQUx1IHR5cGVcbiAgICB0aGlzLnJlYWRVQnl0ZSgpO1xuICAgIC8vIGRpc2NhcmQgZmlyc3RfbWJfaW5fc2xpY2VcbiAgICB0aGlzLnJlYWRVRUcoKTtcbiAgICAvLyByZXR1cm4gc2xpY2VfdHlwZVxuICAgIHJldHVybiB0aGlzLnJlYWRVRUcoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFeHBHb2xvbWI7XG4iLCIvKipcbiAqIElEMyBwYXJzZXJcbiAqL1xuY2xhc3MgSUQzIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2ggaW5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGlzIGZvdW5kXG4gICAqL1xuICBzdGF0aWMgaXNIZWFkZXIgKGRhdGEsIG9mZnNldCkge1xuICAgIC8qXG4gICAgKiBodHRwOi8vaWQzLm9yZy9pZDN2Mi4zLjBcbiAgICAqIFswXSAgICAgPSAnSSdcbiAgICAqIFsxXSAgICAgPSAnRCdcbiAgICAqIFsyXSAgICAgPSAnMydcbiAgICAqIFszLDRdICAgPSB7VmVyc2lvbn1cbiAgICAqIFs1XSAgICAgPSB7RmxhZ3N9XG4gICAgKiBbNi05XSAgID0ge0lEMyBTaXplfVxuICAgICpcbiAgICAqIEFuIElEM3YyIHRhZyBjYW4gYmUgZGV0ZWN0ZWQgd2l0aCB0aGUgZm9sbG93aW5nIHBhdHRlcm46XG4gICAgKiAgJDQ5IDQ0IDMzIHl5IHl5IHh4IHp6IHp6IHp6IHp6XG4gICAgKiBXaGVyZSB5eSBpcyBsZXNzIHRoYW4gJEZGLCB4eCBpcyB0aGUgJ2ZsYWdzJyBieXRlIGFuZCB6eiBpcyBsZXNzIHRoYW4gJDgwXG4gICAgKi9cbiAgICBpZiAob2Zmc2V0ICsgMTAgPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vIGxvb2sgZm9yICdJRDMnIGlkZW50aWZpZXJcbiAgICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4NDkgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg0NCAmJiBkYXRhW29mZnNldCArIDJdID09PSAweDMzKSB7XG4gICAgICAgIC8vIGNoZWNrIHZlcnNpb24gaXMgd2l0aGluIHJhbmdlXG4gICAgICAgIGlmIChkYXRhW29mZnNldCArIDNdIDwgMHhGRiAmJiBkYXRhW29mZnNldCArIDRdIDwgMHhGRikge1xuICAgICAgICAgIC8vIGNoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXG4gICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgNl0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgN10gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOF0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOV0gPCAweDgwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGFuIElEMyBmb290ZXIgY2FuIGJlIGZvdW5kIGF0IG9mZnNldCBpbiBkYXRhXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaCBpblxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIGFuIElEMyBmb290ZXIgaXMgZm91bmRcbiAgICovXG4gIHN0YXRpYyBpc0Zvb3RlciAoZGF0YSwgb2Zmc2V0KSB7XG4gICAgLypcbiAgICAqIFRoZSBmb290ZXIgaXMgYSBjb3B5IG9mIHRoZSBoZWFkZXIsIGJ1dCB3aXRoIGEgZGlmZmVyZW50IGlkZW50aWZpZXJcbiAgICAqL1xuICAgIGlmIChvZmZzZXQgKyAxMCA8PSBkYXRhLmxlbmd0aCkge1xuICAgICAgLy8gbG9vayBmb3IgJzNESScgaWRlbnRpZmllclxuICAgICAgaWYgKGRhdGFbb2Zmc2V0XSA9PT0gMHgzMyAmJiBkYXRhW29mZnNldCArIDFdID09PSAweDQ0ICYmIGRhdGFbb2Zmc2V0ICsgMl0gPT09IDB4NDkpIHtcbiAgICAgICAgLy8gY2hlY2sgdmVyc2lvbiBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgM10gPCAweEZGICYmIGRhdGFbb2Zmc2V0ICsgNF0gPCAweEZGKSB7XG4gICAgICAgICAgLy8gY2hlY2sgc2l6ZSBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyA2XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA3XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA4XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA5XSA8IDB4ODApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFueSBhZGphY2VudCBJRDMgdGFncyBmb3VuZCBpbiBkYXRhIHN0YXJ0aW5nIGF0IG9mZnNldCwgYXMgb25lIGJsb2NrIG9mIGRhdGFcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSAtIFRoZSBibG9jayBvZiBkYXRhIGNvbnRhaW5pbmcgYW55IElEMyB0YWdzIGZvdW5kXG4gICAqL1xuICBzdGF0aWMgZ2V0SUQzRGF0YSAoZGF0YSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgZnJvbnQgPSBvZmZzZXQ7XG4gICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICB3aGlsZSAoSUQzLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgIC8vIElEMyBoZWFkZXIgaXMgMTAgYnl0ZXNcbiAgICAgIGxlbmd0aCArPSAxMDtcblxuICAgICAgY29uc3Qgc2l6ZSA9IElEMy5fcmVhZFNpemUoZGF0YSwgb2Zmc2V0ICsgNik7XG4gICAgICBsZW5ndGggKz0gc2l6ZTtcblxuICAgICAgaWYgKElEMy5pc0Zvb3RlcihkYXRhLCBvZmZzZXQgKyAxMCkpIHtcbiAgICAgICAgLy8gSUQzIGZvb3RlciBpcyAxMCBieXRlc1xuICAgICAgICBsZW5ndGggKz0gMTA7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldCArPSBsZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBkYXRhLnN1YmFycmF5KGZyb250LCBmcm9udCArIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHN0YXRpYyBfcmVhZFNpemUgKGRhdGEsIG9mZnNldCkge1xuICAgIGxldCBzaXplID0gMDtcbiAgICBzaXplID0gKChkYXRhW29mZnNldF0gJiAweDdmKSA8PCAyMSk7XG4gICAgc2l6ZSB8PSAoKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDdmKSA8PCAxNCk7XG4gICAgc2l6ZSB8PSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDdmKSA8PCA3KTtcbiAgICBzaXplIHw9IChkYXRhW29mZnNldCArIDNdICYgMHg3Zik7XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cblxuICAvKipcbiAgICogU2VhcmNoZXMgZm9yIHRoZSBFbGVtZW50YXJ5IFN0cmVhbSB0aW1lc3RhbXAgZm91bmQgaW4gdGhlIElEMyBkYXRhIGNodW5rXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YSAtIEJsb2NrIG9mIGRhdGEgY29udGFpbmluZyBvbmUgb3IgbW9yZSBJRDMgdGFnc1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHRpbWVzdGFtcFxuICAgKi9cbiAgc3RhdGljIGdldFRpbWVTdGFtcCAoZGF0YSkge1xuICAgIGNvbnN0IGZyYW1lcyA9IElEMy5nZXRJRDNGcmFtZXMoZGF0YSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZyYW1lID0gZnJhbWVzW2ldO1xuICAgICAgaWYgKElEMy5pc1RpbWVTdGFtcEZyYW1lKGZyYW1lKSkge1xuICAgICAgICByZXR1cm4gSUQzLl9yZWFkVGltZVN0YW1wKGZyYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSUQzIGZyYW1lIGlzIGFuIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmcmFtZVxuICAgKiBAcGFyYW0ge0lEMyBmcmFtZX0gZnJhbWVcbiAgICovXG4gIHN0YXRpYyBpc1RpbWVTdGFtcEZyYW1lIChmcmFtZSkge1xuICAgIHJldHVybiAoZnJhbWUgJiYgZnJhbWUua2V5ID09PSAnUFJJVicgJiYgZnJhbWUuaW5mbyA9PT0gJ2NvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wJyk7XG4gIH1cblxuICBzdGF0aWMgX2dldEZyYW1lRGF0YSAoZGF0YSkge1xuICAgIC8qXG4gICAgRnJhbWUgSUQgICAgICAgJHh4IHh4IHh4IHh4IChmb3VyIGNoYXJhY3RlcnMpXG4gICAgU2l6ZSAgICAgICAgICAgJHh4IHh4IHh4IHh4XG4gICAgRmxhZ3MgICAgICAgICAgJHh4IHh4XG4gICAgKi9cbiAgICBjb25zdCB0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhWzBdLCBkYXRhWzFdLCBkYXRhWzJdLCBkYXRhWzNdKTtcbiAgICBjb25zdCBzaXplID0gSUQzLl9yZWFkU2l6ZShkYXRhLCA0KTtcblxuICAgIC8vIHNraXAgZnJhbWUgaWQsIHNpemUsIGFuZCBmbGFnc1xuICAgIGxldCBvZmZzZXQgPSAxMDtcblxuICAgIHJldHVybiB7IHR5cGUsIHNpemUsIGRhdGE6IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBzaXplKSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgSUQzIGZyYW1lcyBmb3VuZCBpbiBhbGwgdGhlIElEMyB0YWdzIGluIHRoZSBpZDNEYXRhXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gaWQzRGF0YSAtIFRoZSBJRDMgZGF0YSBjb250YWluaW5nIG9uZSBvciBtb3JlIElEMyB0YWdzXG4gICAqIEByZXR1cm4ge0lEMyBmcmFtZVtdfSAtIEFycmF5IG9mIElEMyBmcmFtZSBvYmplY3RzXG4gICAqL1xuICBzdGF0aWMgZ2V0SUQzRnJhbWVzIChpZDNEYXRhKSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgZnJhbWVzID0gW107XG5cbiAgICB3aGlsZSAoSUQzLmlzSGVhZGVyKGlkM0RhdGEsIG9mZnNldCkpIHtcbiAgICAgIGNvbnN0IHNpemUgPSBJRDMuX3JlYWRTaXplKGlkM0RhdGEsIG9mZnNldCArIDYpO1xuICAgICAgLy8gc2tpcCBwYXN0IElEMyBoZWFkZXJcbiAgICAgIG9mZnNldCArPSAxMDtcbiAgICAgIGNvbnN0IGVuZCA9IG9mZnNldCArIHNpemU7XG4gICAgICAvLyBsb29wIHRocm91Z2ggZnJhbWVzIGluIHRoZSBJRDMgdGFnXG4gICAgICB3aGlsZSAob2Zmc2V0ICsgOCA8IGVuZCkge1xuICAgICAgICBjb25zdCBmcmFtZURhdGEgPSBJRDMuX2dldEZyYW1lRGF0YShpZDNEYXRhLnN1YmFycmF5KG9mZnNldCkpO1xuICAgICAgICBjb25zdCBmcmFtZSA9IElEMy5fZGVjb2RlRnJhbWUoZnJhbWVEYXRhKTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgZnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2tpcCBmcmFtZSBoZWFkZXIgYW5kIGZyYW1lIGRhdGFcbiAgICAgICAgb2Zmc2V0ICs9IGZyYW1lRGF0YS5zaXplICsgMTA7XG4gICAgICB9XG5cbiAgICAgIGlmIChJRDMuaXNGb290ZXIoaWQzRGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBvZmZzZXQgKz0gMTA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYW1lcztcbiAgfVxuXG4gIHN0YXRpYyBfZGVjb2RlRnJhbWUgKGZyYW1lKSB7XG4gICAgaWYgKGZyYW1lLnR5cGUgPT09ICdQUklWJykge1xuICAgICAgcmV0dXJuIElEMy5fZGVjb2RlUHJpdkZyYW1lKGZyYW1lKTtcbiAgICB9IGVsc2UgaWYgKGZyYW1lLnR5cGVbMF0gPT09ICdUJykge1xuICAgICAgcmV0dXJuIElEMy5fZGVjb2RlVGV4dEZyYW1lKGZyYW1lKTtcbiAgICB9IGVsc2UgaWYgKGZyYW1lLnR5cGVbMF0gPT09ICdXJykge1xuICAgICAgcmV0dXJuIElEMy5fZGVjb2RlVVJMRnJhbWUoZnJhbWUpO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBzdGF0aWMgX3JlYWRUaW1lU3RhbXAgKHRpbWVTdGFtcEZyYW1lKSB7XG4gICAgaWYgKHRpbWVTdGFtcEZyYW1lLmRhdGEuYnl0ZUxlbmd0aCA9PT0gOCkge1xuICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRpbWVTdGFtcEZyYW1lLmRhdGEpO1xuICAgICAgLy8gdGltZXN0YW1wIGlzIDMzIGJpdCBleHByZXNzZWQgYXMgYSBiaWctZW5kaWFuIGVpZ2h0LW9jdGV0IG51bWJlcixcbiAgICAgIC8vIHdpdGggdGhlIHVwcGVyIDMxIGJpdHMgc2V0IHRvIHplcm8uXG4gICAgICBjb25zdCBwdHMzM0JpdCA9IGRhdGFbM10gJiAweDE7XG4gICAgICBsZXQgdGltZXN0YW1wID0gKGRhdGFbNF0gPDwgMjMpICtcbiAgICAgICAgICAgICAgICAgICAgICAoZGF0YVs1XSA8PCAxNSkgK1xuICAgICAgICAgICAgICAgICAgICAgIChkYXRhWzZdIDw8IDcpICtcbiAgICAgICAgICAgICAgICAgICAgICAgZGF0YVs3XTtcbiAgICAgIHRpbWVzdGFtcCAvPSA0NTtcblxuICAgICAgaWYgKHB0czMzQml0KSB7XG4gICAgICAgIHRpbWVzdGFtcCArPSA0NzcyMTg1OC44NDtcbiAgICAgIH0gLy8gMl4zMiAvIDkwXG5cbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHRpbWVzdGFtcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHN0YXRpYyBfZGVjb2RlUHJpdkZyYW1lIChmcmFtZSkge1xuICAgIC8qXG4gICAgRm9ybWF0OiA8dGV4dCBzdHJpbmc+XFwwPGJpbmFyeSBkYXRhPlxuICAgICovXG4gICAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IG93bmVyID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLCB0cnVlKTtcbiAgICBjb25zdCBwcml2YXRlRGF0YSA9IG5ldyBVaW50OEFycmF5KGZyYW1lLmRhdGEuc3ViYXJyYXkob3duZXIubGVuZ3RoICsgMSkpO1xuXG4gICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBpbmZvOiBvd25lciwgZGF0YTogcHJpdmF0ZURhdGEuYnVmZmVyIH07XG4gIH1cblxuICBzdGF0aWMgX2RlY29kZVRleHRGcmFtZSAoZnJhbWUpIHtcbiAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGZyYW1lLnR5cGUgPT09ICdUWFhYJykge1xuICAgICAgLypcbiAgICAgIEZvcm1hdDpcbiAgICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gICAgICBbMS0/XSA9IHtEZXNjcmlwdGlvbn1cXDB7VmFsdWV9XG4gICAgICAqL1xuICAgICAgbGV0IGluZGV4ID0gMTtcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XG5cbiAgICAgIGluZGV4ICs9IGRlc2NyaXB0aW9uLmxlbmd0aCArIDE7XG4gICAgICBjb25zdCB2YWx1ZSA9IElEMy5fdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuXG4gICAgICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGluZm86IGRlc2NyaXB0aW9uLCBkYXRhOiB2YWx1ZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvKlxuICAgICAgRm9ybWF0OlxuICAgICAgWzBdICAgPSB7VGV4dCBFbmNvZGluZ31cbiAgICAgIFsxLT9dID0ge1ZhbHVlfVxuICAgICAgKi9cbiAgICAgIGNvbnN0IHRleHQgPSBJRDMuX3V0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoMSkpO1xuICAgICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBkYXRhOiB0ZXh0IH07XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIF9kZWNvZGVVUkxGcmFtZSAoZnJhbWUpIHtcbiAgICBpZiAoZnJhbWUudHlwZSA9PT0gJ1dYWFgnKSB7XG4gICAgICAvKlxuICAgICAgRm9ybWF0OlxuICAgICAgWzBdICAgPSB7VGV4dCBFbmNvZGluZ31cbiAgICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtVUkx9XG4gICAgICAqL1xuICAgICAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGxldCBpbmRleCA9IDE7XG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IElEMy5fdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuXG4gICAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgICAgY29uc3QgdmFsdWUgPSBJRDMuX3V0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcblxuICAgICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBpbmZvOiBkZXNjcmlwdGlvbiwgZGF0YTogdmFsdWUgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLypcbiAgICAgIEZvcm1hdDpcbiAgICAgIFswLT9dID0ge1VSTH1cbiAgICAgICovXG4gICAgICBjb25zdCB1cmwgPSBJRDMuX3V0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEpO1xuICAgICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBkYXRhOiB1cmwgfTtcbiAgICB9XG4gIH1cblxuICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg5MzY5ODQvdWludDhhcnJheS10by1zdHJpbmctaW4tamF2YXNjcmlwdC8yMjM3MzE5N1xuICAvLyBodHRwOi8vd3d3Lm9uaWNvcy5jb20vc3RhZmYvaXovYW11c2UvamF2YXNjcmlwdC9leHBlcnQvdXRmLnR4dFxuICAvKiB1dGYuanMgLSBVVEYtOCA8PT4gVVRGLTE2IGNvbnZlcnRpb25cbiAgICpcbiAgICogQ29weXJpZ2h0IChDKSAxOTk5IE1hc2FuYW8gSXp1bW8gPGl6QG9uaWNvcy5jby5qcD5cbiAgICogVmVyc2lvbjogMS4wXG4gICAqIExhc3RNb2RpZmllZDogRGVjIDI1IDE5OTlcbiAgICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUuICBZb3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0LlxuICAgKi9cbiAgc3RhdGljIF91dGY4QXJyYXlUb1N0ciAoYXJyYXksIGV4aXRPbk51bGwgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICBsZXQgYztcbiAgICBsZXQgY2hhcjI7XG4gICAgbGV0IGNoYXIzO1xuICAgIGxldCBvdXQgPSAnJztcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGMgPSBhcnJheVtpKytdO1xuICAgICAgaWYgKGMgPT09IDB4MDAgJiYgZXhpdE9uTnVsbCkge1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfSBlbHNlIGlmIChjID09PSAweDAwIHx8IGMgPT09IDB4MDMpIHtcbiAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyAzIChFTkRfT0ZfVEVYVCkgb3IgMCAoTlVMTCkgdGhlbiBza2lwIGl0XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjID4+IDQpIHtcbiAgICAgIGNhc2UgMDogY2FzZSAxOiBjYXNlIDI6IGNhc2UgMzogY2FzZSA0OiBjYXNlIDU6IGNhc2UgNjogY2FzZSA3OlxuICAgICAgICAvLyAweHh4eHh4eFxuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyOiBjYXNlIDEzOlxuICAgICAgICAvLyAxMTB4IHh4eHggICAxMHh4IHh4eHhcbiAgICAgICAgY2hhcjIgPSBhcnJheVtpKytdO1xuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDFGKSA8PCA2KSB8IChjaGFyMiAmIDB4M0YpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE0OlxuICAgICAgICAvLyAxMTEwIHh4eHggIDEweHggeHh4eCAgMTB4eCB4eHh4XG4gICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcbiAgICAgICAgY2hhcjMgPSBhcnJheVtpKytdO1xuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDBGKSA8PCAxMikgfFxuICAgICAgICAgICAgICAgICAgICAoKGNoYXIyICYgMHgzRikgPDwgNikgfFxuICAgICAgICAgICAgICAgICAgICAoKGNoYXIzICYgMHgzRikgPDwgMCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn1cblxuY29uc3QgdXRmOEFycmF5VG9TdHIgPSBJRDMuX3V0ZjhBcnJheVRvU3RyO1xuXG5leHBvcnQgZGVmYXVsdCBJRDM7XG5cbmV4cG9ydCB7IHV0ZjhBcnJheVRvU3RyIH07XG4iLCIvKipcbiAqIE1QMyBkZW11eGVyXG4gKi9cbmltcG9ydCBJRDMgZnJvbSAnLi4vZGVtdXgvaWQzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgTXBlZ0F1ZGlvIGZyb20gJy4vbXBlZ2F1ZGlvJztcblxuY2xhc3MgTVAzRGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yIChvYnNlcnZlciwgcmVtdXhlciwgY29uZmlnKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XG4gIH1cblxuICByZXNldEluaXRTZWdtZW50IChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0geyBjb250YWluZXI6ICdhdWRpby9tcGVnJywgdHlwZTogJ2F1ZGlvJywgaWQ6IC0xLCBzZXF1ZW5jZU51bWJlcjogMCwgaXNBQUM6IGZhbHNlLCBzYW1wbGVzOiBbXSwgbGVuOiAwLCBtYW5pZmVzdENvZGVjOiBhdWRpb0NvZGVjLCBkdXJhdGlvbjogZHVyYXRpb24sIGlucHV0VGltZVNjYWxlOiA5MDAwMCB9O1xuICB9XG5cbiAgcmVzZXRUaW1lU3RhbXAgKCkge1xuICB9XG5cbiAgc3RhdGljIHByb2JlIChkYXRhKSB7XG4gICAgLy8gY2hlY2sgaWYgZGF0YSBjb250YWlucyBJRDMgdGltZXN0YW1wIGFuZCBNUEVHIHN5bmMgd29yZFxuICAgIGxldCBvZmZzZXQsIGxlbmd0aDtcbiAgICBsZXQgaWQzRGF0YSA9IElEMy5nZXRJRDNEYXRhKGRhdGEsIDApO1xuICAgIGlmIChpZDNEYXRhICYmIElEMy5nZXRUaW1lU3RhbXAoaWQzRGF0YSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gTG9vayBmb3IgTVBFRyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTFYIFhZWlggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxIGFuZCBZIG9yIFogc2hvdWxkIGJlIDFcbiAgICAgIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgZGlmZmVyZW50IGZyb20gMCAoTGF5ZXIgSSBvciBMYXllciBJSSBvciBMYXllciBJSUkpXG4gICAgICAvLyBNb3JlIGluZm8gaHR0cDovL3d3dy5tcDMtdGVjaC5vcmcvcHJvZ3JhbW1lci9mcmFtZV9oZWFkZXIuaHRtbFxuICAgICAgZm9yIChvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aCwgbGVuZ3RoID0gTWF0aC5taW4oZGF0YS5sZW5ndGggLSAxLCBvZmZzZXQgKyAxMDApOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICAgIGlmIChNcGVnQXVkaW8ucHJvYmUoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ01QRUcgQXVkaW8gc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gIGFwcGVuZCAoZGF0YSwgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgbGV0IGlkM0RhdGEgPSBJRDMuZ2V0SUQzRGF0YShkYXRhLCAwKTtcbiAgICBsZXQgdGltZXN0YW1wID0gSUQzLmdldFRpbWVTdGFtcChpZDNEYXRhKTtcbiAgICBsZXQgcHRzID0gdGltZXN0YW1wID8gOTAgKiB0aW1lc3RhbXAgOiB0aW1lT2Zmc2V0ICogOTAwMDA7XG4gICAgbGV0IG9mZnNldCA9IGlkM0RhdGEubGVuZ3RoO1xuICAgIGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICBsZXQgZnJhbWVJbmRleCA9IDAsIHN0YW1wID0gMDtcbiAgICBsZXQgdHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrO1xuXG4gICAgbGV0IGlkM1NhbXBsZXMgPSBbeyBwdHM6IHB0cywgZHRzOiBwdHMsIGRhdGE6IGlkM0RhdGEgfV07XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoTXBlZ0F1ZGlvLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgbGV0IGZyYW1lID0gTXBlZ0F1ZGlvLmFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCk7XG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgc3RhbXAgPSBmcmFtZS5zYW1wbGUucHRzO1xuICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdVbmFibGUgdG8gcGFyc2UgTXBlZyBhdWRpbyBmcmFtZScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKElEMy5pc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGlkM0RhdGEgPSBJRDMuZ2V0SUQzRGF0YShkYXRhLCBvZmZzZXQpO1xuICAgICAgICBpZDNTYW1wbGVzLnB1c2goeyBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wLCBkYXRhOiBpZDNEYXRhIH0pO1xuICAgICAgICBvZmZzZXQgKz0gaWQzRGF0YS5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGZvdW5kLCBrZWVwIGxvb2tpbmdcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZW11eGVyLnJlbXV4KHRyYWNrLFxuICAgICAgeyBzYW1wbGVzOiBbXSB9LFxuICAgICAgeyBzYW1wbGVzOiBpZDNTYW1wbGVzLCBpbnB1dFRpbWVTY2FsZTogOTAwMDAgfSxcbiAgICAgIHsgc2FtcGxlczogW10gfSxcbiAgICAgIHRpbWVPZmZzZXQsXG4gICAgICBjb250aWd1b3VzLFxuICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1QM0RlbXV4ZXI7XG4iLCIvKipcbiAqIE1QNCBkZW11eGVyXG4gKi9cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcblxuY29uc3QgVUlOVDMyX01BWCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5cbmNsYXNzIE1QNERlbXV4ZXIge1xuICBjb25zdHJ1Y3RvciAob2JzZXJ2ZXIsIHJlbXV4ZXIpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5yZW11eGVyID0gcmVtdXhlcjtcbiAgfVxuXG4gIHJlc2V0VGltZVN0YW1wIChpbml0UFRTKSB7XG4gICAgdGhpcy5pbml0UFRTID0gaW5pdFBUUztcbiAgfVxuXG4gIHJlc2V0SW5pdFNlZ21lbnQgKGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbikge1xuICAgIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgICBpZiAoaW5pdFNlZ21lbnQgJiYgaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkge1xuICAgICAgY29uc3QgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhID0gTVA0RGVtdXhlci5wYXJzZUluaXRTZWdtZW50KGluaXRTZWdtZW50KTtcblxuICAgICAgLy8gZGVmYXVsdCBhdWRpbyBjb2RlYyBpZiBub3RoaW5nIHNwZWNpZmllZFxuICAgICAgLy8gVE9ETyA6IGV4dHJhY3QgdGhhdCBmcm9tIGluaXRzZWdtZW50XG4gICAgICBpZiAoYXVkaW9Db2RlYyA9PSBudWxsKSB7XG4gICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgIH1cblxuICAgICAgaWYgKHZpZGVvQ29kZWMgPT0gbnVsbCkge1xuICAgICAgICB2aWRlb0NvZGVjID0gJ2F2YzEuNDJlMDFlJztcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHJhY2tzID0ge307XG4gICAgICBpZiAoaW5pdERhdGEuYXVkaW8gJiYgaW5pdERhdGEudmlkZW8pIHtcbiAgICAgICAgdHJhY2tzLmF1ZGlvdmlkZW8gPSB7IGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsIGNvZGVjOiBhdWRpb0NvZGVjICsgJywnICsgdmlkZW9Db2RlYywgaW5pdFNlZ21lbnQ6IGR1cmF0aW9uID8gaW5pdFNlZ21lbnQgOiBudWxsIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5pdERhdGEuYXVkaW8pIHtcbiAgICAgICAgICB0cmFja3MuYXVkaW8gPSB7IGNvbnRhaW5lcjogJ2F1ZGlvL21wNCcsIGNvZGVjOiBhdWRpb0NvZGVjLCBpbml0U2VnbWVudDogZHVyYXRpb24gPyBpbml0U2VnbWVudCA6IG51bGwgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbml0RGF0YS52aWRlbykge1xuICAgICAgICAgIHRyYWNrcy52aWRlbyA9IHsgY29udGFpbmVyOiAndmlkZW8vbXA0JywgY29kZWM6IHZpZGVvQ29kZWMsIGluaXRTZWdtZW50OiBkdXJhdGlvbiA/IGluaXRTZWdtZW50IDogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwgeyB0cmFja3MgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhdWRpb0NvZGVjKSB7XG4gICAgICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICB9XG5cbiAgICAgIGlmICh2aWRlb0NvZGVjKSB7XG4gICAgICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHByb2JlIChkYXRhKSB7XG4gICAgLy8gZW5zdXJlIHdlIGZpbmQgYSBtb29mIGJveCBpbiB0aGUgZmlyc3QgMTYga0JcbiAgICByZXR1cm4gTVA0RGVtdXhlci5maW5kQm94KHsgZGF0YTogZGF0YSwgc3RhcnQ6IDAsIGVuZDogTWF0aC5taW4oZGF0YS5sZW5ndGgsIDE2Mzg0KSB9LCBbJ21vb2YnXSkubGVuZ3RoID4gMDtcbiAgfVxuXG4gIHN0YXRpYyBiaW4yc3RyIChidWZmZXIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBidWZmZXIpO1xuICB9XG5cbiAgc3RhdGljIHJlYWRVaW50MTYgKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgaWYgKGJ1ZmZlci5kYXRhKSB7XG4gICAgICBvZmZzZXQgKz0gYnVmZmVyLnN0YXJ0O1xuICAgICAgYnVmZmVyID0gYnVmZmVyLmRhdGE7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsID0gYnVmZmVyW29mZnNldF0gPDwgOCB8XG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIDFdO1xuXG4gICAgcmV0dXJuIHZhbCA8IDAgPyA2NTUzNiArIHZhbCA6IHZhbDtcbiAgfVxuXG4gIHN0YXRpYyByZWFkVWludDMyIChidWZmZXIsIG9mZnNldCkge1xuICAgIGlmIChidWZmZXIuZGF0YSkge1xuICAgICAgb2Zmc2V0ICs9IGJ1ZmZlci5zdGFydDtcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5kYXRhO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbCA9IGJ1ZmZlcltvZmZzZXRdIDw8IDI0IHxcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPDwgMTYgfFxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAyXSA8PCA4IHxcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgM107XG4gICAgcmV0dXJuIHZhbCA8IDAgPyA0Mjk0OTY3Mjk2ICsgdmFsIDogdmFsO1xuICB9XG5cbiAgc3RhdGljIHdyaXRlVWludDMyIChidWZmZXIsIG9mZnNldCwgdmFsdWUpIHtcbiAgICBpZiAoYnVmZmVyLmRhdGEpIHtcbiAgICAgIG9mZnNldCArPSBidWZmZXIuc3RhcnQ7XG4gICAgICBidWZmZXIgPSBidWZmZXIuZGF0YTtcbiAgICB9XG4gICAgYnVmZmVyW29mZnNldF0gPSB2YWx1ZSA+PiAyNDtcbiAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlcltvZmZzZXQgKyAzXSA9IHZhbHVlICYgMHhmZjtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGRhdGEgZm9yIGEgYm94IHNwZWNpZmllZCBieSBpdHMgcGF0aFxuICBzdGF0aWMgZmluZEJveCAoZGF0YSwgcGF0aCkge1xuICAgIGxldCByZXN1bHRzID0gW10sXG4gICAgICBpLCBzaXplLCB0eXBlLCBlbmQsIHN1YnJlc3VsdHMsIHN0YXJ0LCBlbmRib3g7XG5cbiAgICBpZiAoZGF0YS5kYXRhKSB7XG4gICAgICBzdGFydCA9IGRhdGEuc3RhcnQ7XG4gICAgICBlbmQgPSBkYXRhLmVuZDtcbiAgICAgIGRhdGEgPSBkYXRhLmRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGVuZCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAoIXBhdGgubGVuZ3RoKSB7XG4gICAgICAvLyBzaG9ydC1jaXJjdWl0IHRoZSBzZWFyY2ggZm9yIGVtcHR5IHBhdGhzXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDspIHtcbiAgICAgIHNpemUgPSBNUDREZW11eGVyLnJlYWRVaW50MzIoZGF0YSwgaSk7XG4gICAgICB0eXBlID0gTVA0RGVtdXhlci5iaW4yc3RyKGRhdGEuc3ViYXJyYXkoaSArIDQsIGkgKyA4KSk7XG4gICAgICBlbmRib3ggPSBzaXplID4gMSA/IGkgKyBzaXplIDogZW5kO1xuXG4gICAgICBpZiAodHlwZSA9PT0gcGF0aFswXSkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBlbmQgb2YgdGhlIHBhdGggYW5kIHdlJ3ZlIGZvdW5kIHRoZSBib3ggd2Ugd2VyZVxuICAgICAgICAgIC8vIGxvb2tpbmcgZm9yXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHsgZGF0YTogZGF0YSwgc3RhcnQ6IGkgKyA4LCBlbmQ6IGVuZGJveCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHRoZSBuZXh0IGJveCBhbG9uZyB0aGUgcGF0aFxuICAgICAgICAgIHN1YnJlc3VsdHMgPSBNUDREZW11eGVyLmZpbmRCb3goeyBkYXRhOiBkYXRhLCBzdGFydDogaSArIDgsIGVuZDogZW5kYm94IH0sIHBhdGguc2xpY2UoMSkpO1xuICAgICAgICAgIGlmIChzdWJyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHN1YnJlc3VsdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaSA9IGVuZGJveDtcbiAgICB9XG5cbiAgICAvLyB3ZSd2ZSBmaW5pc2hlZCBzZWFyY2hpbmcgYWxsIG9mIGRhdGFcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZVNlZ21lbnRJbmRleCAoaW5pdFNlZ21lbnQpIHtcbiAgICBjb25zdCBtb292ID0gTVA0RGVtdXhlci5maW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnXSlbMF07XG4gICAgY29uc3QgbW9vdkVuZE9mZnNldCA9IG1vb3YgPyBtb292LmVuZCA6IG51bGw7IC8vIHdlIG5lZWQgdGhpcyBpbiBjYXNlIHdlIG5lZWQgdG8gY2hvcCBvZiBnYXJiYWdlIG9mIHRoZSBlbmQgb2YgY3VycmVudCBkYXRhXG5cbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGxldCBzaWR4ID0gTVA0RGVtdXhlci5maW5kQm94KGluaXRTZWdtZW50LCBbJ3NpZHgnXSk7XG4gICAgbGV0IHJlZmVyZW5jZXM7XG5cbiAgICBpZiAoIXNpZHggfHwgIXNpZHhbMF0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJlZmVyZW5jZXMgPSBbXTtcbiAgICBzaWR4ID0gc2lkeFswXTtcblxuICAgIGNvbnN0IHZlcnNpb24gPSBzaWR4LmRhdGFbMF07XG5cbiAgICAvLyBzZXQgaW5pdGlhbCBvZmZzZXQsIHdlIHNraXAgdGhlIHJlZmVyZW5jZSBJRCAobm90IG5lZWRlZClcbiAgICBpbmRleCA9IHZlcnNpb24gPT09IDAgPyA4IDogMTY7XG5cbiAgICBjb25zdCB0aW1lc2NhbGUgPSBNUDREZW11eGVyLnJlYWRVaW50MzIoc2lkeCwgaW5kZXgpO1xuICAgIGluZGV4ICs9IDQ7XG5cbiAgICAvLyBUT0RPOiBwYXJzZSBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgYW5kIGZpcnN0T2Zmc2V0XG4gICAgLy8gdXN1YWxseSB6ZXJvIGluIG91ciBjYXNlXG4gICAgbGV0IGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSA9IDA7XG4gICAgbGV0IGZpcnN0T2Zmc2V0ID0gMDtcblxuICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICBpbmRleCArPSA4O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCArPSAxNjtcbiAgICB9XG5cbiAgICAvLyBza2lwIHJlc2VydmVkXG4gICAgaW5kZXggKz0gMjtcblxuICAgIGxldCBzdGFydEJ5dGUgPSBzaWR4LmVuZCArIGZpcnN0T2Zmc2V0O1xuXG4gICAgY29uc3QgcmVmZXJlbmNlc0NvdW50ID0gTVA0RGVtdXhlci5yZWFkVWludDE2KHNpZHgsIGluZGV4KTtcbiAgICBpbmRleCArPSAyO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWZlcmVuY2VzQ291bnQ7IGkrKykge1xuICAgICAgbGV0IHJlZmVyZW5jZUluZGV4ID0gaW5kZXg7XG5cbiAgICAgIGNvbnN0IHJlZmVyZW5jZUluZm8gPSBNUDREZW11eGVyLnJlYWRVaW50MzIoc2lkeCwgcmVmZXJlbmNlSW5kZXgpO1xuICAgICAgcmVmZXJlbmNlSW5kZXggKz0gNDtcblxuICAgICAgY29uc3QgcmVmZXJlbmNlU2l6ZSA9IHJlZmVyZW5jZUluZm8gJiAweDdGRkZGRkZGO1xuICAgICAgY29uc3QgcmVmZXJlbmNlVHlwZSA9IChyZWZlcmVuY2VJbmZvICYgMHg4MDAwMDAwMCkgPj4+IDMxO1xuXG4gICAgICBpZiAocmVmZXJlbmNlVHlwZSA9PT0gMSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1NJRFggaGFzIGhpZXJhcmNoaWNhbCByZWZlcmVuY2VzIChub3Qgc3VwcG9ydGVkKScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN1YnNlZ21lbnREdXJhdGlvbiA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMihzaWR4LCByZWZlcmVuY2VJbmRleCk7XG4gICAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuXG4gICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICByZWZlcmVuY2VTaXplLFxuICAgICAgICBzdWJzZWdtZW50RHVyYXRpb24sIC8vIHVuc2NhbGVkXG4gICAgICAgIGluZm86IHtcbiAgICAgICAgICBkdXJhdGlvbjogc3Vic2VnbWVudER1cmF0aW9uIC8gdGltZXNjYWxlLFxuICAgICAgICAgIHN0YXJ0OiBzdGFydEJ5dGUsXG4gICAgICAgICAgZW5kOiBzdGFydEJ5dGUgKyByZWZlcmVuY2VTaXplIC0gMVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgc3RhcnRCeXRlICs9IHJlZmVyZW5jZVNpemU7XG5cbiAgICAgIC8vIFNraXBwaW5nIDEgYml0IGZvciB8c3RhcnRzV2l0aFNhcHwsIDMgYml0cyBmb3IgfHNhcFR5cGV8LCBhbmQgMjggYml0c1xuICAgICAgLy8gZm9yIHxzYXBEZWx0YXwuXG4gICAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuXG4gICAgICAvLyBza2lwIHRvIG5leHQgcmVmXG4gICAgICBpbmRleCA9IHJlZmVyZW5jZUluZGV4O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUsXG4gICAgICB0aW1lc2NhbGUsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgcmVmZXJlbmNlc0NvdW50LFxuICAgICAgcmVmZXJlbmNlcyxcbiAgICAgIG1vb3ZFbmRPZmZzZXRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBNUDQgaW5pdGlhbGl6YXRpb24gc2VnbWVudCBhbmQgZXh0cmFjdHMgc3RyZWFtIHR5cGUgYW5kXG4gICAqIHRpbWVzY2FsZSB2YWx1ZXMgZm9yIGFueSBkZWNsYXJlZCB0cmFja3MuIFRpbWVzY2FsZSB2YWx1ZXMgaW5kaWNhdGUgdGhlXG4gICAqIG51bWJlciBvZiBjbG9jayB0aWNrcyBwZXIgc2Vjb25kIHRvIGFzc3VtZSBmb3IgdGltZS1iYXNlZCB2YWx1ZXNcbiAgICogZWxzZXdoZXJlIGluIHRoZSBNUDQuXG4gICAqXG4gICAqIFRvIGRldGVybWluZSB0aGUgc3RhcnQgdGltZSBvZiBhbiBNUDQsIHlvdSBuZWVkIHR3byBwaWVjZXMgb2ZcbiAgICogaW5mb3JtYXRpb246IHRoZSB0aW1lc2NhbGUgdW5pdCBhbmQgdGhlIGVhcmxpZXN0IGJhc2UgbWVkaWEgZGVjb2RlXG4gICAqIHRpbWUuIE11bHRpcGxlIHRpbWVzY2FsZXMgY2FuIGJlIHNwZWNpZmllZCB3aXRoaW4gYW4gTVA0IGJ1dCB0aGVcbiAgICogYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBpcyBhbHdheXMgZXhwcmVzc2VkIGluIHRoZSB0aW1lc2NhbGUgZnJvbVxuICAgKiB0aGUgbWVkaWEgaGVhZGVyIGJveCBmb3IgdGhlIHRyYWNrOlxuICAgKiBgYGBcbiAgICogbW9vdiA+IHRyYWsgPiBtZGlhID4gbWRoZC50aW1lc2NhbGVcbiAgICogbW9vdiA+IHRyYWsgPiBtZGlhID4gaGRsclxuICAgKiBgYGBcbiAgICogQHBhcmFtIGluaXQge1VpbnQ4QXJyYXl9IHRoZSBieXRlcyBvZiB0aGUgaW5pdCBzZWdtZW50XG4gICAqIEByZXR1cm4ge29iamVjdH0gYSBoYXNoIG9mIHRyYWNrIHR5cGUgdG8gdGltZXNjYWxlIHZhbHVlcyBvciBudWxsIGlmXG4gICAqIHRoZSBpbml0IHNlZ21lbnQgaXMgbWFsZm9ybWVkLlxuICAgKi9cbiAgc3RhdGljIHBhcnNlSW5pdFNlZ21lbnQgKGluaXRTZWdtZW50KSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGxldCB0cmFrcyA9IE1QNERlbXV4ZXIuZmluZEJveChpbml0U2VnbWVudCwgWydtb292JywgJ3RyYWsnXSk7XG5cbiAgICB0cmFrcy5mb3JFYWNoKHRyYWsgPT4ge1xuICAgICAgY29uc3QgdGtoZCA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFrLCBbJ3RraGQnXSlbMF07XG4gICAgICBpZiAodGtoZCkge1xuICAgICAgICBsZXQgdmVyc2lvbiA9IHRraGQuZGF0YVt0a2hkLnN0YXJ0XTtcbiAgICAgICAgbGV0IGluZGV4ID0gdmVyc2lvbiA9PT0gMCA/IDEyIDogMjA7XG4gICAgICAgIGxldCB0cmFja0lkID0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRraGQsIGluZGV4KTtcblxuICAgICAgICBjb25zdCBtZGhkID0gTVA0RGVtdXhlci5maW5kQm94KHRyYWssIFsnbWRpYScsICdtZGhkJ10pWzBdO1xuICAgICAgICBpZiAobWRoZCkge1xuICAgICAgICAgIHZlcnNpb24gPSBtZGhkLmRhdGFbbWRoZC5zdGFydF07XG4gICAgICAgICAgaW5kZXggPSB2ZXJzaW9uID09PSAwID8gMTIgOiAyMDtcbiAgICAgICAgICBjb25zdCB0aW1lc2NhbGUgPSBNUDREZW11eGVyLnJlYWRVaW50MzIobWRoZCwgaW5kZXgpO1xuXG4gICAgICAgICAgY29uc3QgaGRsciA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnaGRsciddKVswXTtcbiAgICAgICAgICBpZiAoaGRscikge1xuICAgICAgICAgICAgY29uc3QgaGRsclR5cGUgPSBNUDREZW11eGVyLmJpbjJzdHIoaGRsci5kYXRhLnN1YmFycmF5KGhkbHIuc3RhcnQgKyA4LCBoZGxyLnN0YXJ0ICsgMTIpKTtcbiAgICAgICAgICAgIGxldCB0eXBlID0geyAnc291bic6ICdhdWRpbycsICd2aWRlJzogJ3ZpZGVvJyB9W2hkbHJUeXBlXTtcbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgIC8vIGV4dHJhY3QgY29kZWMgaW5mby4gVE9ETyA6IHBhcnNlIGNvZGVjIGRldGFpbHMgdG8gYmUgYWJsZSB0byBidWlsZCBNSU1FIHR5cGVcbiAgICAgICAgICAgICAgbGV0IGNvZGVjQm94ID0gTVA0RGVtdXhlci5maW5kQm94KHRyYWssIFsnbWRpYScsICdtaW5mJywgJ3N0YmwnLCAnc3RzZCddKTtcbiAgICAgICAgICAgICAgaWYgKGNvZGVjQm94Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvZGVjQm94ID0gY29kZWNCb3hbMF07XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVjVHlwZSA9IE1QNERlbXV4ZXIuYmluMnN0cihjb2RlY0JveC5kYXRhLnN1YmFycmF5KGNvZGVjQm94LnN0YXJ0ICsgMTIsIGNvZGVjQm94LnN0YXJ0ICsgMTYpKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBNUDREZW11eGVyOiR7dHlwZX06JHtjb2RlY1R5cGV9IGZvdW5kYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0W3RyYWNrSWRdID0geyB0aW1lc2NhbGU6IHRpbWVzY2FsZSwgdHlwZTogdHlwZSB9O1xuICAgICAgICAgICAgICByZXN1bHRbdHlwZV0gPSB7IHRpbWVzY2FsZTogdGltZXNjYWxlLCBpZDogdHJhY2tJZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAqIERldGVybWluZSB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgc3RhcnQgdGltZSwgaW4gc2Vjb25kcywgZm9yIGFuIE1QNFxuICogZnJhZ21lbnQuIElmIG11bHRpcGxlIGZyYWdtZW50cyBhcmUgc3BlY2lmaWVkLCB0aGUgZWFybGllc3QgdGltZSBpc1xuICogcmV0dXJuZWQuXG4gKlxuICogVGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgY2FuIGJlIHBhcnNlZCBmcm9tIHRyYWNrIGZyYWdtZW50XG4gKiBtZXRhZGF0YTpcbiAqIGBgYFxuICogbW9vZiA+IHRyYWYgPiB0ZmR0LmJhc2VNZWRpYURlY29kZVRpbWVcbiAqIGBgYFxuICogSXQgcmVxdWlyZXMgdGhlIHRpbWVzY2FsZSB2YWx1ZSBmcm9tIHRoZSBtZGhkIHRvIGludGVycHJldC5cbiAqXG4gKiBAcGFyYW0gdGltZXNjYWxlIHtvYmplY3R9IGEgaGFzaCBvZiB0cmFjayBpZHMgdG8gdGltZXNjYWxlIHZhbHVlcy5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGVhcmxpZXN0IGJhc2UgbWVkaWEgZGVjb2RlIHN0YXJ0IHRpbWUgZm9yIHRoZVxuICogZnJhZ21lbnQsIGluIHNlY29uZHNcbiAqL1xuICBzdGF0aWMgZ2V0U3RhcnREVFMgKGluaXREYXRhLCBmcmFnbWVudCkge1xuICAgIGxldCB0cmFmcywgYmFzZVRpbWVzLCByZXN1bHQ7XG5cbiAgICAvLyB3ZSBuZWVkIGluZm8gZnJvbSB0d28gY2hpbGRyZW5kIG9mIGVhY2ggdHJhY2sgZnJhZ21lbnQgYm94XG4gICAgdHJhZnMgPSBNUDREZW11eGVyLmZpbmRCb3goZnJhZ21lbnQsIFsnbW9vZicsICd0cmFmJ10pO1xuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBzdGFydCB0aW1lcyBmb3IgZWFjaCB0cmFja1xuICAgIGJhc2VUaW1lcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgdHJhZnMubWFwKGZ1bmN0aW9uICh0cmFmKSB7XG4gICAgICByZXR1cm4gTVA0RGVtdXhlci5maW5kQm94KHRyYWYsIFsndGZoZCddKS5tYXAoZnVuY3Rpb24gKHRmaGQpIHtcbiAgICAgICAgbGV0IGlkLCBzY2FsZSwgYmFzZVRpbWU7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG4gICAgICAgIGlkID0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRmaGQsIDQpO1xuICAgICAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuICAgICAgICBzY2FsZSA9IGluaXREYXRhW2lkXS50aW1lc2NhbGUgfHwgOTBlMztcblxuICAgICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuICAgICAgICBiYXNlVGltZSA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkubWFwKGZ1bmN0aW9uICh0ZmR0KSB7XG4gICAgICAgICAgbGV0IHZlcnNpb24sIHJlc3VsdDtcblxuICAgICAgICAgIHZlcnNpb24gPSB0ZmR0LmRhdGFbdGZkdC5zdGFydF07XG4gICAgICAgICAgcmVzdWx0ID0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRmZHQsIDQpO1xuICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgICByZXN1bHQgKj0gTWF0aC5wb3coMiwgMzIpO1xuXG4gICAgICAgICAgICByZXN1bHQgKz0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRmZHQsIDgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KVswXTtcbiAgICAgICAgLy8gY29udmVydCBiYXNlIHRpbWUgdG8gc2Vjb25kc1xuICAgICAgICByZXR1cm4gYmFzZVRpbWUgLyBzY2FsZTtcbiAgICAgIH0pO1xuICAgIH0pKTtcblxuICAgIC8vIHJldHVybiB0aGUgbWluaW11bVxuICAgIHJlc3VsdCA9IE1hdGgubWluLmFwcGx5KG51bGwsIGJhc2VUaW1lcyk7XG4gICAgcmV0dXJuIGlzRmluaXRlKHJlc3VsdCkgPyByZXN1bHQgOiAwO1xuICB9XG5cbiAgc3RhdGljIG9mZnNldFN0YXJ0RFRTIChpbml0RGF0YSwgZnJhZ21lbnQsIHRpbWVPZmZzZXQpIHtcbiAgICBNUDREZW11eGVyLmZpbmRCb3goZnJhZ21lbnQsIFsnbW9vZicsICd0cmFmJ10pLm1hcChmdW5jdGlvbiAodHJhZikge1xuICAgICAgcmV0dXJuIE1QNERlbXV4ZXIuZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkubWFwKGZ1bmN0aW9uICh0ZmhkKSB7XG4gICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgICAgbGV0IGlkID0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRmaGQsIDQpO1xuICAgICAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuICAgICAgICBsZXQgdGltZXNjYWxlID0gaW5pdERhdGFbaWRdLnRpbWVzY2FsZSB8fCA5MGUzO1xuXG4gICAgICAgIC8vIGdldCB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBmcm9tIHRoZSB0ZmR0XG4gICAgICAgIE1QNERlbXV4ZXIuZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkubWFwKGZ1bmN0aW9uICh0ZmR0KSB7XG4gICAgICAgICAgbGV0IHZlcnNpb24gPSB0ZmR0LmRhdGFbdGZkdC5zdGFydF07XG4gICAgICAgICAgbGV0IGJhc2VNZWRpYURlY29kZVRpbWUgPSBNUDREZW11eGVyLnJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgIE1QNERlbXV4ZXIud3JpdGVVaW50MzIodGZkdCwgNCwgYmFzZU1lZGlhRGVjb2RlVGltZSAtIHRpbWVPZmZzZXQgKiB0aW1lc2NhbGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lICo9IE1hdGgucG93KDIsIDMyKTtcbiAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgKz0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRmZHQsIDgpO1xuICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAtPSB0aW1lT2Zmc2V0ICogdGltZXNjYWxlO1xuICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGgubWF4KGJhc2VNZWRpYURlY29kZVRpbWUsIDApO1xuICAgICAgICAgICAgY29uc3QgdXBwZXIgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICAgICAgICAgIGNvbnN0IGxvd2VyID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICAgICAgICBNUDREZW11eGVyLndyaXRlVWludDMyKHRmZHQsIDQsIHVwcGVyKTtcbiAgICAgICAgICAgIE1QNERlbXV4ZXIud3JpdGVVaW50MzIodGZkdCwgOCwgbG93ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgYXBwZW5kIChkYXRhLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICBsZXQgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhO1xuICAgIGlmICghaW5pdERhdGEpIHtcbiAgICAgIHRoaXMucmVzZXRJbml0U2VnbWVudChkYXRhLCB0aGlzLmF1ZGlvQ29kZWMsIHRoaXMudmlkZW9Db2RlYywgZmFsc2UpO1xuICAgICAgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhO1xuICAgIH1cbiAgICBsZXQgc3RhcnREVFMsIGluaXRQVFMgPSB0aGlzLmluaXRQVFM7XG4gICAgaWYgKGluaXRQVFMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IHN0YXJ0RFRTID0gTVA0RGVtdXhlci5nZXRTdGFydERUUyhpbml0RGF0YSwgZGF0YSk7XG4gICAgICB0aGlzLmluaXRQVFMgPSBpbml0UFRTID0gc3RhcnREVFMgLSB0aW1lT2Zmc2V0O1xuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LklOSVRfUFRTX0ZPVU5ELCB7IGluaXRQVFM6IGluaXRQVFMgfSk7XG4gICAgfVxuICAgIE1QNERlbXV4ZXIub2Zmc2V0U3RhcnREVFMoaW5pdERhdGEsIGRhdGEsIGluaXRQVFMpO1xuICAgIHN0YXJ0RFRTID0gTVA0RGVtdXhlci5nZXRTdGFydERUUyhpbml0RGF0YSwgZGF0YSk7XG4gICAgdGhpcy5yZW11eGVyLnJlbXV4KGluaXREYXRhLmF1ZGlvLCBpbml0RGF0YS52aWRlbywgbnVsbCwgbnVsbCwgc3RhcnREVFMsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgZGF0YSk7XG4gIH1cblxuICBkZXN0cm95ICgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1QNERlbXV4ZXI7XG4iLCIvKipcbiAqICBNUEVHIHBhcnNlciBoZWxwZXJcbiAqL1xuXG5jb25zdCBNcGVnQXVkaW8gPSB7XG5cbiAgQml0cmF0ZXNNYXA6IFtcbiAgICAzMiwgNjQsIDk2LCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMjg4LCAzMjAsIDM1MiwgMzg0LCA0MTYsIDQ0OCxcbiAgICAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIDM4NCxcbiAgICAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwLFxuICAgIDMyLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsIDE2MCwgMTc2LCAxOTIsIDIyNCwgMjU2LFxuICAgIDgsIDE2LCAyNCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsIDE2MF0sXG5cbiAgU2FtcGxpbmdSYXRlTWFwOiBbNDQxMDAsIDQ4MDAwLCAzMjAwMCwgMjIwNTAsIDI0MDAwLCAxNjAwMCwgMTEwMjUsIDEyMDAwLCA4MDAwXSxcblxuICBTYW1wbGVzQ29lZmZpY2llbnRzOiBbXG4gICAgLy8gTVBFRyAyLjVcbiAgICBbXG4gICAgICAwLCAvLyBSZXNlcnZlZFxuICAgICAgNzIsIC8vIExheWVyM1xuICAgICAgMTQ0LCAvLyBMYXllcjJcbiAgICAgIDEyIC8vIExheWVyMVxuICAgIF0sXG4gICAgLy8gUmVzZXJ2ZWRcbiAgICBbXG4gICAgICAwLCAvLyBSZXNlcnZlZFxuICAgICAgMCwgLy8gTGF5ZXIzXG4gICAgICAwLCAvLyBMYXllcjJcbiAgICAgIDAgLy8gTGF5ZXIxXG4gICAgXSxcbiAgICAvLyBNUEVHIDJcbiAgICBbXG4gICAgICAwLCAvLyBSZXNlcnZlZFxuICAgICAgNzIsIC8vIExheWVyM1xuICAgICAgMTQ0LCAvLyBMYXllcjJcbiAgICAgIDEyIC8vIExheWVyMVxuICAgIF0sXG4gICAgLy8gTVBFRyAxXG4gICAgW1xuICAgICAgMCwgLy8gUmVzZXJ2ZWRcbiAgICAgIDE0NCwgLy8gTGF5ZXIzXG4gICAgICAxNDQsIC8vIExheWVyMlxuICAgICAgMTIgLy8gTGF5ZXIxXG4gICAgXVxuICBdLFxuXG4gIEJ5dGVzSW5TbG90OiBbXG4gICAgMCwgLy8gUmVzZXJ2ZWRcbiAgICAxLCAvLyBMYXllcjNcbiAgICAxLCAvLyBMYXllcjJcbiAgICA0IC8vIExheWVyMVxuICBdLFxuXG4gIGFwcGVuZEZyYW1lOiBmdW5jdGlvbiAodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KSB7XG4gICAgLy8gVXNpbmcgaHR0cDovL3d3dy5kYXRhdm95YWdlLmNvbS9tcGdzY3JpcHQvbXBlZ2hkci5odG0gYXMgYSByZWZlcmVuY2VcbiAgICBpZiAob2Zmc2V0ICsgMjQgPiBkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBsZXQgaGVhZGVyID0gdGhpcy5wYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICAgIGlmIChoZWFkZXIgJiYgb2Zmc2V0ICsgaGVhZGVyLmZyYW1lTGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgICBsZXQgZnJhbWVEdXJhdGlvbiA9IGhlYWRlci5zYW1wbGVzUGVyRnJhbWUgKiA5MDAwMCAvIGhlYWRlci5zYW1wbGVSYXRlO1xuICAgICAgbGV0IHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XG4gICAgICBsZXQgc2FtcGxlID0geyB1bml0OiBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgaGVhZGVyLmZyYW1lTGVuZ3RoKSwgcHRzOiBzdGFtcCwgZHRzOiBzdGFtcCB9O1xuXG4gICAgICB0cmFjay5jb25maWcgPSBbXTtcbiAgICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGhlYWRlci5jaGFubmVsQ291bnQ7XG4gICAgICB0cmFjay5zYW1wbGVyYXRlID0gaGVhZGVyLnNhbXBsZVJhdGU7XG4gICAgICB0cmFjay5zYW1wbGVzLnB1c2goc2FtcGxlKTtcbiAgICAgIHRyYWNrLmxlbiArPSBoZWFkZXIuZnJhbWVMZW5ndGg7XG5cbiAgICAgIHJldHVybiB7IHNhbXBsZSwgbGVuZ3RoOiBoZWFkZXIuZnJhbWVMZW5ndGggfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LFxuXG4gIHBhcnNlSGVhZGVyOiBmdW5jdGlvbiAoZGF0YSwgb2Zmc2V0KSB7XG4gICAgbGV0IGhlYWRlckIgPSAoZGF0YVtvZmZzZXQgKyAxXSA+PiAzKSAmIDM7XG4gICAgbGV0IGhlYWRlckMgPSAoZGF0YVtvZmZzZXQgKyAxXSA+PiAxKSAmIDM7XG4gICAgbGV0IGhlYWRlckUgPSAoZGF0YVtvZmZzZXQgKyAyXSA+PiA0KSAmIDE1O1xuICAgIGxldCBoZWFkZXJGID0gKGRhdGFbb2Zmc2V0ICsgMl0gPj4gMikgJiAzO1xuICAgIGxldCBoZWFkZXJHID0gKGRhdGFbb2Zmc2V0ICsgMl0gPj4gMSkgJiAxO1xuICAgIGlmIChoZWFkZXJCICE9PSAxICYmIGhlYWRlckUgIT09IDAgJiYgaGVhZGVyRSAhPT0gMTUgJiYgaGVhZGVyRiAhPT0gMykge1xuICAgICAgbGV0IGNvbHVtbkluQml0cmF0ZXMgPSBoZWFkZXJCID09PSAzID8gKDMgLSBoZWFkZXJDKSA6IChoZWFkZXJDID09PSAzID8gMyA6IDQpO1xuICAgICAgbGV0IGJpdFJhdGUgPSBNcGVnQXVkaW8uQml0cmF0ZXNNYXBbY29sdW1uSW5CaXRyYXRlcyAqIDE0ICsgaGVhZGVyRSAtIDFdICogMTAwMDtcbiAgICAgIGxldCBjb2x1bW5JblNhbXBsZVJhdGVzID0gaGVhZGVyQiA9PT0gMyA/IDAgOiBoZWFkZXJCID09PSAyID8gMSA6IDI7XG4gICAgICBsZXQgc2FtcGxlUmF0ZSA9IE1wZWdBdWRpby5TYW1wbGluZ1JhdGVNYXBbY29sdW1uSW5TYW1wbGVSYXRlcyAqIDMgKyBoZWFkZXJGXTtcbiAgICAgIGxldCBjaGFubmVsQ291bnQgPSBkYXRhW29mZnNldCArIDNdID4+IDYgPT09IDMgPyAxIDogMjsgLy8gSWYgYml0cyBvZiBjaGFubmVsIG1vZGUgYXJlIGAxMWAgdGhlbiBpdCBpcyBhIHNpbmdsZSBjaGFubmVsIChNb25vKVxuICAgICAgbGV0IHNhbXBsZUNvZWZmaWNpZW50ID0gTXBlZ0F1ZGlvLlNhbXBsZXNDb2VmZmljaWVudHNbaGVhZGVyQl1baGVhZGVyQ107XG4gICAgICBsZXQgYnl0ZXNJblNsb3QgPSBNcGVnQXVkaW8uQnl0ZXNJblNsb3RbaGVhZGVyQ107XG4gICAgICBsZXQgc2FtcGxlc1BlckZyYW1lID0gc2FtcGxlQ29lZmZpY2llbnQgKiA4ICogYnl0ZXNJblNsb3Q7XG4gICAgICBsZXQgZnJhbWVMZW5ndGggPSBwYXJzZUludChzYW1wbGVDb2VmZmljaWVudCAqIGJpdFJhdGUgLyBzYW1wbGVSYXRlICsgaGVhZGVyRywgMTApICogYnl0ZXNJblNsb3Q7XG5cbiAgICAgIHJldHVybiB7IHNhbXBsZVJhdGUsIGNoYW5uZWxDb3VudCwgZnJhbWVMZW5ndGgsIHNhbXBsZXNQZXJGcmFtZSB9O1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgaXNIZWFkZXJQYXR0ZXJuOiBmdW5jdGlvbiAoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFbb2Zmc2V0XSA9PT0gMHhmZiAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZTApID09PSAweGUwICYmIChkYXRhW29mZnNldCArIDFdICYgMHgwNikgIT09IDB4MDA7XG4gIH0sXG5cbiAgaXNIZWFkZXI6IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQpIHtcbiAgICAvLyBMb29rIGZvciBNUEVHIGhlYWRlciB8IDExMTEgMTExMSB8IDExMVggWFlaWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDEgYW5kIFkgb3IgWiBzaG91bGQgYmUgMVxuICAgIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgZGlmZmVyZW50IGZyb20gMCAoTGF5ZXIgSSBvciBMYXllciBJSSBvciBMYXllciBJSUkpXG4gICAgLy8gTW9yZSBpbmZvIGh0dHA6Ly93d3cubXAzLXRlY2gub3JnL3Byb2dyYW1tZXIvZnJhbWVfaGVhZGVyLmh0bWxcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIHRoaXMuaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBwcm9iZTogZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgIC8vIHNhbWUgYXMgaXNIZWFkZXIgYnV0IHdlIGFsc28gY2hlY2sgdGhhdCBNUEVHIGZyYW1lIGZvbGxvd3MgbGFzdCBNUEVHIGZyYW1lXG4gICAgLy8gb3IgZW5kIG9mIGRhdGEgaXMgcmVhY2hlZFxuICAgIGlmIChvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgdGhpcy5pc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgLy8gTVBFRyBoZWFkZXIgTGVuZ3RoXG4gICAgICBsZXQgaGVhZGVyTGVuZ3RoID0gNDtcbiAgICAgIC8vIE1QRUcgZnJhbWUgTGVuZ3RoXG4gICAgICBsZXQgaGVhZGVyID0gdGhpcy5wYXJzZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICAgICAgbGV0IGZyYW1lTGVuZ3RoID0gaGVhZGVyTGVuZ3RoO1xuICAgICAgaWYgKGhlYWRlciAmJiBoZWFkZXIuZnJhbWVMZW5ndGgpIHtcbiAgICAgICAgZnJhbWVMZW5ndGggPSBoZWFkZXIuZnJhbWVMZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGxldCBuZXdPZmZzZXQgPSBvZmZzZXQgKyBmcmFtZUxlbmd0aDtcbiAgICAgIGlmIChuZXdPZmZzZXQgPT09IGRhdGEubGVuZ3RoIHx8IChuZXdPZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgdGhpcy5pc0hlYWRlclBhdHRlcm4oZGF0YSwgbmV3T2Zmc2V0KSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTXBlZ0F1ZGlvO1xuIiwiLyoqXG4gKiBTQU1QTEUtQUVTIGRlY3J5cHRlclxuKi9cblxuaW1wb3J0IERlY3J5cHRlciBmcm9tICcuLi9jcnlwdC9kZWNyeXB0ZXInO1xuXG5jbGFzcyBTYW1wbGVBZXNEZWNyeXB0ZXIge1xuICBjb25zdHJ1Y3RvciAob2JzZXJ2ZXIsIGNvbmZpZywgZGVjcnlwdGRhdGEsIGRpc2NhcmRFUEIpIHtcbiAgICB0aGlzLmRlY3J5cHRkYXRhID0gZGVjcnlwdGRhdGE7XG4gICAgdGhpcy5kaXNjYXJkRVBCID0gZGlzY2FyZEVQQjtcbiAgICB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIob2JzZXJ2ZXIsIGNvbmZpZywgeyByZW1vdmVQS0NTN1BhZGRpbmc6IGZhbHNlIH0pO1xuICB9XG5cbiAgZGVjcnlwdEJ1ZmZlciAoZW5jcnlwdGVkRGF0YSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KGVuY3J5cHRlZERhdGEsIHRoaXMuZGVjcnlwdGRhdGEua2V5LmJ1ZmZlciwgdGhpcy5kZWNyeXB0ZGF0YS5pdi5idWZmZXIsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIEFBQyAtIGVuY3J5cHQgYWxsIGZ1bGwgMTYgYnl0ZXMgYmxvY2tzIHN0YXJ0aW5nIGZyb20gb2Zmc2V0IDE2XG4gIGRlY3J5cHRBYWNTYW1wbGUgKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjaywgc3luYykge1xuICAgIGxldCBjdXJVbml0ID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdDtcbiAgICBsZXQgZW5jcnlwdGVkRGF0YSA9IGN1clVuaXQuc3ViYXJyYXkoMTYsIGN1clVuaXQubGVuZ3RoIC0gY3VyVW5pdC5sZW5ndGggJSAxNik7XG4gICAgbGV0IGVuY3J5cHRlZEJ1ZmZlciA9IGVuY3J5cHRlZERhdGEuYnVmZmVyLnNsaWNlKFxuICAgICAgZW5jcnlwdGVkRGF0YS5ieXRlT2Zmc2V0LFxuICAgICAgZW5jcnlwdGVkRGF0YS5ieXRlT2Zmc2V0ICsgZW5jcnlwdGVkRGF0YS5sZW5ndGgpO1xuXG4gICAgbGV0IGxvY2FsdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5kZWNyeXB0QnVmZmVyKGVuY3J5cHRlZEJ1ZmZlciwgZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgIGRlY3J5cHRlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcbiAgICAgIGN1clVuaXQuc2V0KGRlY3J5cHRlZERhdGEsIDE2KTtcblxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGxvY2FsdGhpcy5kZWNyeXB0QWFjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCArIDEsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRlY3J5cHRBYWNTYW1wbGVzIChzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2spIHtcbiAgICBmb3IgKDs7IHNhbXBsZUluZGV4KyspIHtcbiAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0Lmxlbmd0aCA8IDMyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgc3luYyA9IHRoaXMuZGVjcnlwdGVyLmlzU3luYygpO1xuXG4gICAgICB0aGlzLmRlY3J5cHRBYWNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrLCBzeW5jKTtcblxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBVkMgLSBlbmNyeXB0IG9uZSAxNiBieXRlcyBibG9jayBvdXQgb2YgdGVuLCBzdGFydGluZyBmcm9tIG9mZnNldCAzMlxuICBnZXRBdmNFbmNyeXB0ZWREYXRhIChkZWNvZGVkRGF0YSkge1xuICAgIGxldCBlbmNyeXB0ZWREYXRhTGVuID0gTWF0aC5mbG9vcigoZGVjb2RlZERhdGEubGVuZ3RoIC0gNDgpIC8gMTYwKSAqIDE2ICsgMTY7XG4gICAgbGV0IGVuY3J5cHRlZERhdGEgPSBuZXcgSW50OEFycmF5KGVuY3J5cHRlZERhdGFMZW4pO1xuICAgIGxldCBvdXRwdXRQb3MgPSAwO1xuICAgIGZvciAobGV0IGlucHV0UG9zID0gMzI7IGlucHV0UG9zIDw9IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2OyBpbnB1dFBvcyArPSAxNjAsIG91dHB1dFBvcyArPSAxNikge1xuICAgICAgZW5jcnlwdGVkRGF0YS5zZXQoZGVjb2RlZERhdGEuc3ViYXJyYXkoaW5wdXRQb3MsIGlucHV0UG9zICsgMTYpLCBvdXRwdXRQb3MpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmNyeXB0ZWREYXRhO1xuICB9XG5cbiAgZ2V0QXZjRGVjcnlwdGVkVW5pdCAoZGVjb2RlZERhdGEsIGRlY3J5cHRlZERhdGEpIHtcbiAgICBkZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSk7XG4gICAgbGV0IGlucHV0UG9zID0gMDtcbiAgICBmb3IgKGxldCBvdXRwdXRQb3MgPSAzMjsgb3V0cHV0UG9zIDw9IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2OyBvdXRwdXRQb3MgKz0gMTYwLCBpbnB1dFBvcyArPSAxNikge1xuICAgICAgZGVjb2RlZERhdGEuc2V0KGRlY3J5cHRlZERhdGEuc3ViYXJyYXkoaW5wdXRQb3MsIGlucHV0UG9zICsgMTYpLCBvdXRwdXRQb3MpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNvZGVkRGF0YTtcbiAgfVxuXG4gIGRlY3J5cHRBdmNTYW1wbGUgKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0LCBzeW5jKSB7XG4gICAgbGV0IGRlY29kZWREYXRhID0gdGhpcy5kaXNjYXJkRVBCKGN1clVuaXQuZGF0YSk7XG4gICAgbGV0IGVuY3J5cHRlZERhdGEgPSB0aGlzLmdldEF2Y0VuY3J5cHRlZERhdGEoZGVjb2RlZERhdGEpO1xuICAgIGxldCBsb2NhbHRoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5kZWNyeXB0QnVmZmVyKGVuY3J5cHRlZERhdGEuYnVmZmVyLCBmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xuICAgICAgY3VyVW5pdC5kYXRhID0gbG9jYWx0aGlzLmdldEF2Y0RlY3J5cHRlZFVuaXQoZGVjb2RlZERhdGEsIGRlY3J5cHRlZERhdGEpO1xuXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgbG9jYWx0aGlzLmRlY3J5cHRBdmNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXggKyAxLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBkZWNyeXB0QXZjU2FtcGxlcyAoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2spIHtcbiAgICBmb3IgKDs7IHNhbXBsZUluZGV4KyssIHVuaXRJbmRleCA9IDApIHtcbiAgICAgIGlmIChzYW1wbGVJbmRleCA+PSBzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBjdXJVbml0cyA9IHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXRzO1xuICAgICAgZm9yICg7OyB1bml0SW5kZXgrKykge1xuICAgICAgICBpZiAodW5pdEluZGV4ID49IGN1clVuaXRzLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGN1clVuaXQgPSBjdXJVbml0c1t1bml0SW5kZXhdO1xuICAgICAgICBpZiAoY3VyVW5pdC5sZW5ndGggPD0gNDggfHwgKGN1clVuaXQudHlwZSAhPT0gMSAmJiBjdXJVbml0LnR5cGUgIT09IDUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3luYyA9IHRoaXMuZGVjcnlwdGVyLmlzU3luYygpO1xuXG4gICAgICAgIHRoaXMuZGVjcnlwdEF2Y1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaywgY3VyVW5pdCwgc3luYyk7XG5cbiAgICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNhbXBsZUFlc0RlY3J5cHRlcjtcbiIsIi8qKlxuICogaGlnaGx5IG9wdGltaXplZCBUUyBkZW11eGVyOlxuICogcGFyc2UgUEFULCBQTVRcbiAqIGV4dHJhY3QgUEVTIHBhY2tldCBmcm9tIGF1ZGlvIGFuZCB2aWRlbyBQSURzXG4gKiBleHRyYWN0IEFWQy9IMjY0IE5BTCB1bml0cyBhbmQgQUFDL0FEVFMgc2FtcGxlcyBmcm9tIFBFUyBwYWNrZXRcbiAqIHRyaWdnZXIgdGhlIHJlbXV4ZXIgdXBvbiBwYXJzaW5nIGNvbXBsZXRpb25cbiAqIGl0IGFsc28gdHJpZXMgdG8gd29ya2Fyb3VuZCBhcyBiZXN0IGFzIGl0IGNhbiBhdWRpbyBjb2RlYyBzd2l0Y2ggKEhFLUFBQyB0byBBQUMgYW5kIHZpY2UgdmVyc2EpLCB3aXRob3V0IGhhdmluZyB0byByZXN0YXJ0IHRoZSBNZWRpYVNvdXJjZS5cbiAqIGl0IGFsc28gY29udHJvbHMgdGhlIHJlbXV4aW5nIHByb2Nlc3MgOlxuICogdXBvbiBkaXNjb250aW51aXR5IG9yIGxldmVsIHN3aXRjaCBkZXRlY3Rpb24sIGl0IHdpbGwgYWxzbyBub3RpZmllcyB0aGUgcmVtdXhlciBzbyB0aGF0IGl0IGNhbiByZXNldCBpdHMgc3RhdGUuXG4qL1xuXG5pbXBvcnQgKiBhcyBBRFRTIGZyb20gJy4vYWR0cyc7XG5pbXBvcnQgTXBlZ0F1ZGlvIGZyb20gJy4vbXBlZ2F1ZGlvJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV4cEdvbG9tYiBmcm9tICcuL2V4cC1nb2xvbWInO1xuaW1wb3J0IFNhbXBsZUFlc0RlY3J5cHRlciBmcm9tICcuL3NhbXBsZS1hZXMnO1xuLy8gaW1wb3J0IEhleCBmcm9tICcuLi91dGlscy9oZXgnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5cbi8vIFdlIGFyZSB1c2luZyBmaXhlZCB0cmFjayBJRHMgZm9yIGRyaXZpbmcgdGhlIE1QNCByZW11eGVyXG4vLyBpbnN0ZWFkIG9mIGZvbGxvd2luZyB0aGUgVFMgUElEcy5cbi8vIFRoZXJlIGlzIG5vIHJlYXNvbiBub3QgdG8gZG8gdGhpcyBhbmQgc29tZSBicm93c2Vycy9Tb3VyY2VCdWZmZXItZGVtdXhlcnNcbi8vIG1heSBub3QgbGlrZSBpZiB0aGVyZSBhcmUgVHJhY2tJRCBcInN3aXRjaGVzXCJcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMTMzMVxuLy8gSGVyZSB3ZSBhcmUgbWFwcGluZyBvdXIgaW50ZXJuYWwgdHJhY2sgdHlwZXMgdG8gY29uc3RhbnQgTVA0IHRyYWNrIElEc1xuLy8gV2l0aCBNU0UgY3VycmVudGx5IG9uZSBjYW4gb25seSBoYXZlIG9uZSB0cmFjayBvZiBlYWNoLCBhbmQgd2UgYXJlIG11eGluZ1xuLy8gd2hhdGV2ZXIgdmlkZW8vYXVkaW8gcmVuZGl0aW9uIGluIHRoZW0uXG5jb25zdCBSZW11eGVyVHJhY2tJZENvbmZpZyA9IHtcbiAgdmlkZW86IDEsXG4gIGF1ZGlvOiAyLFxuICBpZDM6IDMsXG4gIHRleHQ6IDRcbn07XG5cbmNsYXNzIFRTRGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yIChvYnNlcnZlciwgcmVtdXhlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgdGhpcy5yZW11eGVyID0gcmVtdXhlcjtcbiAgICB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XG4gIH1cblxuICBzZXREZWNyeXB0RGF0YSAoZGVjcnlwdGRhdGEpIHtcbiAgICBpZiAoKGRlY3J5cHRkYXRhICE9IG51bGwpICYmIChkZWNyeXB0ZGF0YS5rZXkgIT0gbnVsbCkgJiYgKGRlY3J5cHRkYXRhLm1ldGhvZCA9PT0gJ1NBTVBMRS1BRVMnKSkge1xuICAgICAgdGhpcy5zYW1wbGVBZXMgPSBuZXcgU2FtcGxlQWVzRGVjcnlwdGVyKHRoaXMub2JzZXJ2ZXIsIHRoaXMuY29uZmlnLCBkZWNyeXB0ZGF0YSwgdGhpcy5kaXNjYXJkRVBCKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwcm9iZSAoZGF0YSkge1xuICAgIGNvbnN0IHN5bmNPZmZzZXQgPSBUU0RlbXV4ZXIuX3N5bmNPZmZzZXQoZGF0YSk7XG4gICAgaWYgKHN5bmNPZmZzZXQgPCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzeW5jT2Zmc2V0KSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBNUEVHMi1UUyBkZXRlY3RlZCBidXQgZmlyc3Qgc3luYyB3b3JkIGZvdW5kIEAgb2Zmc2V0ICR7c3luY09mZnNldH0sIGp1bmsgYWhlYWQgP2ApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgX3N5bmNPZmZzZXQgKGRhdGEpIHtcbiAgICAvLyBzY2FuIDEwMDAgZmlyc3QgYnl0ZXNcbiAgICBjb25zdCBzY2Fud2luZG93ID0gTWF0aC5taW4oMTAwMCwgZGF0YS5sZW5ndGggLSAzICogMTg4KTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzY2Fud2luZG93KSB7XG4gICAgICAvLyBhIFRTIGZyYWdtZW50IHNob3VsZCBjb250YWluIGF0IGxlYXN0IDMgVFMgcGFja2V0cywgYSBQQVQsIGEgUE1ULCBhbmQgb25lIFBJRCwgZWFjaCBzdGFydGluZyB3aXRoIDB4NDdcbiAgICAgIGlmIChkYXRhW2ldID09PSAweDQ3ICYmIGRhdGFbaSArIDE4OF0gPT09IDB4NDcgJiYgZGF0YVtpICsgMiAqIDE4OF0gPT09IDB4NDcpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdHJhY2sgbW9kZWwgaW50ZXJuYWwgdG8gZGVtdXhlciB1c2VkIHRvIGRyaXZlIHJlbXV4aW5nIGlucHV0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlICdhdWRpbycgfCAndmlkZW8nIHwgJ2lkMycgfCAndGV4dCdcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXG4gICAqIEByZXR1cm4ge29iamVjdH0gVFNEZW11eGVyJ3MgaW50ZXJuYWwgdHJhY2sgbW9kZWxcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVUcmFjayAodHlwZSwgZHVyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGFpbmVyOiB0eXBlID09PSAndmlkZW8nIHx8IHR5cGUgPT09ICdhdWRpbycgPyAndmlkZW8vbXAydCcgOiB1bmRlZmluZWQsXG4gICAgICB0eXBlLFxuICAgICAgaWQ6IFJlbXV4ZXJUcmFja0lkQ29uZmlnW3R5cGVdLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBsZW46IDAsXG4gICAgICBkcm9wcGVkOiB0eXBlID09PSAndmlkZW8nID8gMCA6IHVuZGVmaW5lZCxcbiAgICAgIGlzQUFDOiB0eXBlID09PSAnYXVkaW8nID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGR1cmF0aW9uOiB0eXBlID09PSAnYXVkaW8nID8gZHVyYXRpb24gOiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3IGluaXQgc2VnbWVudCBvbiB0aGUgZGVtdXhlci9yZW11eGVyIGludGVyZmFjZS4gTmVlZGVkIGZvciBkaXNjb250aW51aXRpZXMvdHJhY2stc3dpdGNoZXMgKG9yIGF0IHN0cmVhbSBzdGFydClcbiAgICogUmVzZXRzIGFsbCBpbnRlcm5hbCB0cmFjayBpbnN0YW5jZXMgb2YgdGhlIGRlbXV4ZXIuXG4gICAqXG4gICAqIEBvdmVycmlkZSBJbXBsZW1lbnRzIGdlbmVyaWMgZGVtdXhpbmcvcmVtdXhpbmcgaW50ZXJmYWNlIChzZWUgRGVtdXhlcklubGluZSlcbiAgICogQHBhcmFtIHtvYmplY3R9IGluaXRTZWdtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdWRpb0NvZGVjXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aWRlb0NvZGVjXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiAoaW4gVFMgdGltZXNjYWxlID0gOTBrSHopXG4gICAqL1xuICByZXNldEluaXRTZWdtZW50IChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcbiAgICB0aGlzLnBtdFBhcnNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BtdElkID0gLTE7XG5cbiAgICB0aGlzLl9hdmNUcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygndmlkZW8nLCBkdXJhdGlvbik7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygnYXVkaW8nLCBkdXJhdGlvbik7XG4gICAgdGhpcy5faWQzVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ2lkMycsIGR1cmF0aW9uKTtcbiAgICB0aGlzLl90eHRUcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygndGV4dCcsIGR1cmF0aW9uKTtcblxuICAgIC8vIGZsdXNoIGFueSBwYXJ0aWFsIGNvbnRlbnRcbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLmFhY0xhc3RQVFMgPSBudWxsO1xuICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlc2V0VGltZVN0YW1wICgpIHt9XG5cbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICBhcHBlbmQgKGRhdGEsIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIGxldCBzdGFydCwgbGVuID0gZGF0YS5sZW5ndGgsIHN0dCwgcGlkLCBhdGYsIG9mZnNldCwgcGVzLFxuICAgICAgdW5rbm93blBJRHMgPSBmYWxzZTtcbiAgICB0aGlzLmNvbnRpZ3VvdXMgPSBjb250aWd1b3VzO1xuICAgIGxldCBwbXRQYXJzZWQgPSB0aGlzLnBtdFBhcnNlZCxcbiAgICAgIGF2Y1RyYWNrID0gdGhpcy5fYXZjVHJhY2ssXG4gICAgICBhdWRpb1RyYWNrID0gdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgIGlkM1RyYWNrID0gdGhpcy5faWQzVHJhY2ssXG4gICAgICBhdmNJZCA9IGF2Y1RyYWNrLnBpZCxcbiAgICAgIGF1ZGlvSWQgPSBhdWRpb1RyYWNrLnBpZCxcbiAgICAgIGlkM0lkID0gaWQzVHJhY2sucGlkLFxuICAgICAgcG10SWQgPSB0aGlzLl9wbXRJZCxcbiAgICAgIGF2Y0RhdGEgPSBhdmNUcmFjay5wZXNEYXRhLFxuICAgICAgYXVkaW9EYXRhID0gYXVkaW9UcmFjay5wZXNEYXRhLFxuICAgICAgaWQzRGF0YSA9IGlkM1RyYWNrLnBlc0RhdGEsXG4gICAgICBwYXJzZVBBVCA9IHRoaXMuX3BhcnNlUEFULFxuICAgICAgcGFyc2VQTVQgPSB0aGlzLl9wYXJzZVBNVCxcbiAgICAgIHBhcnNlUEVTID0gdGhpcy5fcGFyc2VQRVMsXG4gICAgICBwYXJzZUFWQ1BFUyA9IHRoaXMuX3BhcnNlQVZDUEVTLmJpbmQodGhpcyksXG4gICAgICBwYXJzZUFBQ1BFUyA9IHRoaXMuX3BhcnNlQUFDUEVTLmJpbmQodGhpcyksXG4gICAgICBwYXJzZU1QRUdQRVMgPSB0aGlzLl9wYXJzZU1QRUdQRVMuYmluZCh0aGlzKSxcbiAgICAgIHBhcnNlSUQzUEVTID0gdGhpcy5fcGFyc2VJRDNQRVMuYmluZCh0aGlzKTtcblxuICAgIGNvbnN0IHN5bmNPZmZzZXQgPSBUU0RlbXV4ZXIuX3N5bmNPZmZzZXQoZGF0YSk7XG5cbiAgICAvLyBkb24ndCBwYXJzZSBsYXN0IFRTIHBhY2tldCBpZiBpbmNvbXBsZXRlXG4gICAgbGVuIC09IChsZW4gKyBzeW5jT2Zmc2V0KSAlIDE4ODtcblxuICAgIC8vIGxvb3AgdGhyb3VnaCBUUyBwYWNrZXRzXG4gICAgZm9yIChzdGFydCA9IHN5bmNPZmZzZXQ7IHN0YXJ0IDwgbGVuOyBzdGFydCArPSAxODgpIHtcbiAgICAgIGlmIChkYXRhW3N0YXJ0XSA9PT0gMHg0Nykge1xuICAgICAgICBzdHQgPSAhIShkYXRhW3N0YXJ0ICsgMV0gJiAweDQwKTtcbiAgICAgICAgLy8gcGlkIGlzIGEgMTMtYml0IGZpZWxkIHN0YXJ0aW5nIGF0IHRoZSBsYXN0IGJpdCBvZiBUU1sxXVxuICAgICAgICBwaWQgPSAoKGRhdGFbc3RhcnQgKyAxXSAmIDB4MWYpIDw8IDgpICsgZGF0YVtzdGFydCArIDJdO1xuICAgICAgICBhdGYgPSAoZGF0YVtzdGFydCArIDNdICYgMHgzMCkgPj4gNDtcbiAgICAgICAgLy8gaWYgYW4gYWRhcHRpb24gZmllbGQgaXMgcHJlc2VudCwgaXRzIGxlbmd0aCBpcyBzcGVjaWZpZWQgYnkgdGhlIGZpZnRoIGJ5dGUgb2YgdGhlIFRTIHBhY2tldCBoZWFkZXIuXG4gICAgICAgIGlmIChhdGYgPiAxKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gc3RhcnQgKyA1ICsgZGF0YVtzdGFydCArIDRdO1xuICAgICAgICAgIC8vIGNvbnRpbnVlIGlmIHRoZXJlIGlzIG9ubHkgYWRhcHRhdGlvbiBmaWVsZFxuICAgICAgICAgIGlmIChvZmZzZXQgPT09IChzdGFydCArIDE4OCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChwaWQpIHtcbiAgICAgICAgY2FzZSBhdmNJZDpcbiAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICBpZiAoYXZjRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXZjRGF0YSkpICYmIHBlcy5wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBwYXJzZUFWQ1BFUyhwZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXZjRGF0YSA9IHsgZGF0YTogW10sIHNpemU6IDAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF2Y0RhdGEpIHtcbiAgICAgICAgICAgIGF2Y0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIDE4OCkpO1xuICAgICAgICAgICAgYXZjRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBhdWRpb0lkOlxuICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgIGlmIChhdWRpb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF1ZGlvRGF0YSkpICYmIHBlcy5wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoYXVkaW9UcmFjay5pc0FBQykge1xuICAgICAgICAgICAgICAgIHBhcnNlQUFDUEVTKHBlcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VNUEVHUEVTKHBlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1ZGlvRGF0YSA9IHsgZGF0YTogW10sIHNpemU6IDAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF1ZGlvRGF0YSkge1xuICAgICAgICAgICAgYXVkaW9EYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcbiAgICAgICAgICAgIGF1ZGlvRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZDNJZDpcbiAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICBpZiAoaWQzRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoaWQzRGF0YSkpICYmIHBlcy5wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBwYXJzZUlEM1BFUyhwZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZDNEYXRhID0geyBkYXRhOiBbXSwgc2l6ZTogMCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaWQzRGF0YSkge1xuICAgICAgICAgICAgaWQzRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICBpZDNEYXRhLnNpemUgKz0gc3RhcnQgKyAxODggLSBvZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcG10SWQgPSB0aGlzLl9wbXRJZCA9IHBhcnNlUEFUKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgcG10SWQ6XG4gICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHBhcnNlZFBJRHMgPSBwYXJzZVBNVChkYXRhLCBvZmZzZXQsIHRoaXMudHlwZVN1cHBvcnRlZC5tcGVnID09PSB0cnVlIHx8IHRoaXMudHlwZVN1cHBvcnRlZC5tcDMgPT09IHRydWUsIHRoaXMuc2FtcGxlQWVzICE9IG51bGwpO1xuXG4gICAgICAgICAgLy8gb25seSB1cGRhdGUgdHJhY2sgaWQgaWYgdHJhY2sgUElEIGZvdW5kIHdoaWxlIHBhcnNpbmcgUE1UXG4gICAgICAgICAgLy8gdGhpcyBpcyB0byBhdm9pZCByZXNldHRpbmcgdGhlIFBJRCB0byAtMSBpbiBjYXNlXG4gICAgICAgICAgLy8gdHJhY2sgUElEIHRyYW5zaWVudGx5IGRpc2FwcGVhcnMgZnJvbSB0aGUgc3RyZWFtXG4gICAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaW4gY2FzZSBvZiB0cmFuc2llbnQgbWlzc2luZyBhdWRpbyBzYW1wbGVzIGZvciBleGFtcGxlXG4gICAgICAgICAgLy8gTk9URSB0aGlzIGlzIG9ubHkgdGhlIFBJRCBvZiB0aGUgdHJhY2sgYXMgZm91bmQgaW4gVFMsXG4gICAgICAgICAgLy8gYnV0IHdlIGFyZSBub3QgdXNpbmcgdGhpcyBmb3IgTVA0IHRyYWNrIElEcy5cbiAgICAgICAgICBhdmNJZCA9IHBhcnNlZFBJRHMuYXZjO1xuICAgICAgICAgIGlmIChhdmNJZCA+IDApIHtcbiAgICAgICAgICAgIGF2Y1RyYWNrLnBpZCA9IGF2Y0lkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF1ZGlvSWQgPSBwYXJzZWRQSURzLmF1ZGlvO1xuICAgICAgICAgIGlmIChhdWRpb0lkID4gMCkge1xuICAgICAgICAgICAgYXVkaW9UcmFjay5waWQgPSBhdWRpb0lkO1xuICAgICAgICAgICAgYXVkaW9UcmFjay5pc0FBQyA9IHBhcnNlZFBJRHMuaXNBQUM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlkM0lkID0gcGFyc2VkUElEcy5pZDM7XG4gICAgICAgICAgaWYgKGlkM0lkID4gMCkge1xuICAgICAgICAgICAgaWQzVHJhY2sucGlkID0gaWQzSWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHVua25vd25QSURzICYmICFwbXRQYXJzZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ3JlcGFyc2UgZnJvbSBiZWdpbm5pbmcnKTtcbiAgICAgICAgICAgIHVua25vd25QSURzID0gZmFsc2U7XG4gICAgICAgICAgICAvLyB3ZSBzZXQgaXQgdG8gLTE4OCwgdGhlICs9IDE4OCBpbiB0aGUgZm9yIGxvb3Agd2lsbCByZXNldCBzdGFydCB0byAwXG4gICAgICAgICAgICBzdGFydCA9IHN5bmNPZmZzZXQgLSAxODg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgY2FzZSAweDFmZmY6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdW5rbm93blBJRHMgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCByZWFzb246ICdUUyBwYWNrZXQgZGlkIG5vdCBzdGFydCB3aXRoIDB4NDcnIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB0cnkgdG8gcGFyc2UgbGFzdCBQRVMgcGFja2V0c1xuICAgIGlmIChhdmNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdmNEYXRhKSkgJiYgcGVzLnB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJzZUFWQ1BFUyhwZXMsIHRydWUpO1xuICAgICAgYXZjVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVpdGhlciBhdmNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgIGF2Y1RyYWNrLnBlc0RhdGEgPSBhdmNEYXRhO1xuICAgIH1cblxuICAgIGlmIChhdWRpb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF1ZGlvRGF0YSkpICYmIHBlcy5wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGF1ZGlvVHJhY2suaXNBQUMpIHtcbiAgICAgICAgcGFyc2VBQUNQRVMocGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlTVBFR1BFUyhwZXMpO1xuICAgICAgfVxuXG4gICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXVkaW9EYXRhICYmIGF1ZGlvRGF0YS5zaXplKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ2xhc3QgQUFDIFBFUyBwYWNrZXQgdHJ1bmNhdGVkLG1pZ2h0IG92ZXJsYXAgYmV0d2VlbiBmcmFnbWVudHMnKTtcbiAgICAgIH1cblxuICAgICAgLy8gZWl0aGVyIGF1ZGlvRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBhdWRpb0RhdGE7XG4gICAgfVxuXG4gICAgaWYgKGlkM0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGlkM0RhdGEpKSAmJiBwZXMucHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcnNlSUQzUEVTKHBlcyk7XG4gICAgICBpZDNUcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWl0aGVyIGlkM0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IGlkM0RhdGE7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2FtcGxlQWVzID09IG51bGwpIHtcbiAgICAgIHRoaXMucmVtdXhlci5yZW11eChhdWRpb1RyYWNrLCBhdmNUcmFjaywgaWQzVHJhY2ssIHRoaXMuX3R4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlY3J5cHRBbmRSZW11eChhdWRpb1RyYWNrLCBhdmNUcmFjaywgaWQzVHJhY2ssIHRoaXMuX3R4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgIH1cbiAgfVxuXG4gIGRlY3J5cHRBbmRSZW11eCAoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgaWYgKGF1ZGlvVHJhY2suc2FtcGxlcyAmJiBhdWRpb1RyYWNrLmlzQUFDKSB7XG4gICAgICBsZXQgbG9jYWx0aGlzID0gdGhpcztcbiAgICAgIHRoaXMuc2FtcGxlQWVzLmRlY3J5cHRBYWNTYW1wbGVzKGF1ZGlvVHJhY2suc2FtcGxlcywgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2NhbHRoaXMuZGVjcnlwdEFuZFJlbXV4QXZjKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWNyeXB0QW5kUmVtdXhBdmMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICB9XG4gIH1cblxuICBkZWNyeXB0QW5kUmVtdXhBdmMgKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMpIHtcbiAgICAgIGxldCBsb2NhbHRoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5zYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvY2FsdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5faW5pdFBUUyA9IHRoaXMuX2luaXREVFMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHVyYXRpb24gPSAwO1xuICB9XG5cbiAgX3BhcnNlUEFUIChkYXRhLCBvZmZzZXQpIHtcbiAgICAvLyBza2lwIHRoZSBQU0kgaGVhZGVyIGFuZCBwYXJzZSB0aGUgZmlyc3QgUE1UIGVudHJ5XG4gICAgcmV0dXJuIChkYXRhW29mZnNldCArIDEwXSAmIDB4MUYpIDw8IDggfCBkYXRhW29mZnNldCArIDExXTtcbiAgICAvLyBsb2dnZXIubG9nKCdQTVQgUElEOicgICsgdGhpcy5fcG10SWQpO1xuICB9XG5cbiAgX3BhcnNlUE1UIChkYXRhLCBvZmZzZXQsIG1wZWdTdXBwb3J0ZWQsIGlzU2FtcGxlQWVzKSB7XG4gICAgbGV0IHNlY3Rpb25MZW5ndGgsIHRhYmxlRW5kLCBwcm9ncmFtSW5mb0xlbmd0aCwgcGlkLCByZXN1bHQgPSB7IGF1ZGlvOiAtMSwgYXZjOiAtMSwgaWQzOiAtMSwgaXNBQUM6IHRydWUgfTtcbiAgICBzZWN0aW9uTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAyXTtcbiAgICB0YWJsZUVuZCA9IG9mZnNldCArIDMgKyBzZWN0aW9uTGVuZ3RoIC0gNDtcbiAgICAvLyB0byBkZXRlcm1pbmUgd2hlcmUgdGhlIHRhYmxlIGlzLCB3ZSBoYXZlIHRvIGZpZ3VyZSBvdXQgaG93XG4gICAgLy8gbG9uZyB0aGUgcHJvZ3JhbSBpbmZvIGRlc2NyaXB0b3JzIGFyZVxuICAgIHByb2dyYW1JbmZvTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xuICAgIC8vIGFkdmFuY2UgdGhlIG9mZnNldCB0byB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIG1hcHBpbmcgdGFibGVcbiAgICBvZmZzZXQgKz0gMTIgKyBwcm9ncmFtSW5mb0xlbmd0aDtcbiAgICB3aGlsZSAob2Zmc2V0IDwgdGFibGVFbmQpIHtcbiAgICAgIHBpZCA9IChkYXRhW29mZnNldCArIDFdICYgMHgxRikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMl07XG4gICAgICBzd2l0Y2ggKGRhdGFbb2Zmc2V0XSkge1xuICAgICAgY2FzZSAweGNmOiAvLyBTQU1QTEUtQUVTIEFBQ1xuICAgICAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygndW5rb3duIHN0cmVhbSB0eXBlOicgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgICAgICAvLyBJU08vSUVDIDEzODE4LTcgQURUUyBBQUMgKE1QRUctMiBsb3dlciBiaXQtcmF0ZSBhdWRpbylcbiAgICAgIGNhc2UgMHgwZjpcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnQUFDIFBJRDonICArIHBpZCk7XG4gICAgICAgIGlmIChyZXN1bHQuYXVkaW8gPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmF1ZGlvID0gcGlkO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gUGFja2V0aXplZCBtZXRhZGF0YSAoSUQzKVxuICAgICAgY2FzZSAweDE1OlxuICAgICAgICAvLyBsb2dnZXIubG9nKCdJRDMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pZDMgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmlkMyA9IHBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4ZGI6IC8vIFNBTVBMRS1BRVMgQVZDXG4gICAgICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCd1bmtvd24gc3RyZWFtIHR5cGU6JyArIGRhdGFbb2Zmc2V0XSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuXG4gICAgICAgIC8vIElUVS1UIFJlYy4gSC4yNjQgYW5kIElTTy9JRUMgMTQ0OTYtMTAgKGxvd2VyIGJpdC1yYXRlIHZpZGVvKVxuICAgICAgY2FzZSAweDFiOlxuICAgICAgICAvLyBsb2dnZXIubG9nKCdBVkMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC5hdmMgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmF2YyA9IHBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIElTTy9JRUMgMTExNzItMyAoTVBFRy0xIGF1ZGlvKVxuICAgICAgICAvLyBvciBJU08vSUVDIDEzODE4LTMgKE1QRUctMiBoYWx2ZWQgc2FtcGxlIHJhdGUgYXVkaW8pXG4gICAgICBjYXNlIDB4MDM6XG4gICAgICBjYXNlIDB4MDQ6XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ01QRUcgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKCFtcGVnU3VwcG9ydGVkKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnTVBFRyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIgZm9yIG5vdycpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5hdWRpbyA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuYXVkaW8gPSBwaWQ7XG4gICAgICAgICAgcmVzdWx0LmlzQUFDID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMHgyNDpcbiAgICAgICAgbG9nZ2VyLndhcm4oJ0hFVkMgc3RyZWFtIHR5cGUgZm91bmQsIG5vdCBzdXBwb3J0ZWQgZm9yIG5vdycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbG9nZ2VyLmxvZygndW5rb3duIHN0cmVhbSB0eXBlOicgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIG1vdmUgdG8gdGhlIG5leHQgdGFibGUgZW50cnlcbiAgICAgIC8vIHNraXAgcGFzdCB0aGUgZWxlbWVudGFyeSBzdHJlYW0gZGVzY3JpcHRvcnMsIGlmIHByZXNlbnRcbiAgICAgIG9mZnNldCArPSAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDBGKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyA0XSkgKyA1O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgX3BhcnNlUEVTIChzdHJlYW0pIHtcbiAgICBsZXQgaSA9IDAsIGZyYWcsIHBlc0ZsYWdzLCBwZXNQcmVmaXgsIHBlc0xlbiwgcGVzSGRyTGVuLCBwZXNEYXRhLCBwZXNQdHMsIHBlc0R0cywgcGF5bG9hZFN0YXJ0T2Zmc2V0LCBkYXRhID0gc3RyZWFtLmRhdGE7XG4gICAgLy8gc2FmZXR5IGNoZWNrXG4gICAgaWYgKCFzdHJlYW0gfHwgc3RyZWFtLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIHdlIG1pZ2h0IG5lZWQgdXAgdG8gMTkgYnl0ZXMgdG8gcmVhZCBQRVMgaGVhZGVyXG4gICAgLy8gaWYgZmlyc3QgY2h1bmsgb2YgZGF0YSBpcyBsZXNzIHRoYW4gMTkgYnl0ZXMsIGxldCdzIG1lcmdlIGl0IHdpdGggZm9sbG93aW5nIG9uZXMgdW50aWwgd2UgZ2V0IDE5IGJ5dGVzXG4gICAgLy8gdXN1YWxseSBvbmx5IG9uZSBtZXJnZSBpcyBuZWVkZWQgKGFuZCB0aGlzIGlzIHJhcmUgLi4uKVxuICAgIHdoaWxlIChkYXRhWzBdLmxlbmd0aCA8IDE5ICYmIGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgbGV0IG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShkYXRhWzBdLmxlbmd0aCArIGRhdGFbMV0ubGVuZ3RoKTtcbiAgICAgIG5ld0RhdGEuc2V0KGRhdGFbMF0pO1xuICAgICAgbmV3RGF0YS5zZXQoZGF0YVsxXSwgZGF0YVswXS5sZW5ndGgpO1xuICAgICAgZGF0YVswXSA9IG5ld0RhdGE7XG4gICAgICBkYXRhLnNwbGljZSgxLCAxKTtcbiAgICB9XG4gICAgLy8gcmV0cmlldmUgUFRTL0RUUyBmcm9tIGZpcnN0IGZyYWdtZW50XG4gICAgZnJhZyA9IGRhdGFbMF07XG4gICAgcGVzUHJlZml4ID0gKGZyYWdbMF0gPDwgMTYpICsgKGZyYWdbMV0gPDwgOCkgKyBmcmFnWzJdO1xuICAgIGlmIChwZXNQcmVmaXggPT09IDEpIHtcbiAgICAgIHBlc0xlbiA9IChmcmFnWzRdIDw8IDgpICsgZnJhZ1s1XTtcbiAgICAgIC8vIGlmIFBFUyBwYXJzZWQgbGVuZ3RoIGlzIG5vdCB6ZXJvIGFuZCBncmVhdGVyIHRoYW4gdG90YWwgcmVjZWl2ZWQgbGVuZ3RoLCBzdG9wIHBhcnNpbmcuIFBFUyBtaWdodCBiZSB0cnVuY2F0ZWRcbiAgICAgIC8vIG1pbnVzIDYgOiBQRVMgaGVhZGVyIHNpemVcbiAgICAgIGlmIChwZXNMZW4gJiYgcGVzTGVuID4gc3RyZWFtLnNpemUgLSA2KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBwZXNGbGFncyA9IGZyYWdbN107XG4gICAgICBpZiAocGVzRmxhZ3MgJiAweEMwKSB7XG4gICAgICAgIC8qIFBFUyBoZWFkZXIgZGVzY3JpYmVkIGhlcmUgOiBodHRwOi8vZHZkLnNvdXJjZWZvcmdlLm5ldC9kdmRpbmZvL3Blcy1oZHIuaHRtbFxuICAgICAgICAgICAgYXMgUFRTIC8gRFRTIGlzIDMzIGJpdCB3ZSBjYW5ub3QgdXNlIGJpdHdpc2Ugb3BlcmF0b3IgaW4gSlMsXG4gICAgICAgICAgICBhcyBCaXR3aXNlIG9wZXJhdG9ycyB0cmVhdCB0aGVpciBvcGVyYW5kcyBhcyBhIHNlcXVlbmNlIG9mIDMyIGJpdHMgKi9cbiAgICAgICAgcGVzUHRzID0gKGZyYWdbOV0gJiAweDBFKSAqIDUzNjg3MDkxMiArLy8gMSA8PCAyOVxuICAgICAgICAgIChmcmFnWzEwXSAmIDB4RkYpICogNDE5NDMwNCArLy8gMSA8PCAyMlxuICAgICAgICAgIChmcmFnWzExXSAmIDB4RkUpICogMTYzODQgKy8vIDEgPDwgMTRcbiAgICAgICAgICAoZnJhZ1sxMl0gJiAweEZGKSAqIDEyOCArLy8gMSA8PCA3XG4gICAgICAgICAgKGZyYWdbMTNdICYgMHhGRSkgLyAyO1xuICAgICAgICAvLyBjaGVjayBpZiBncmVhdGVyIHRoYW4gMl4zMiAtMVxuICAgICAgICBpZiAocGVzUHRzID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgIC8vIGRlY3JlbWVudCAyXjMzXG4gICAgICAgICAgcGVzUHRzIC09IDg1ODk5MzQ1OTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlc0ZsYWdzICYgMHg0MCkge1xuICAgICAgICAgIHBlc0R0cyA9IChmcmFnWzE0XSAmIDB4MEUpICogNTM2ODcwOTEyICsvLyAxIDw8IDI5XG4gICAgICAgICAgICAoZnJhZ1sxNV0gJiAweEZGKSAqIDQxOTQzMDQgKy8vIDEgPDwgMjJcbiAgICAgICAgICAgIChmcmFnWzE2XSAmIDB4RkUpICogMTYzODQgKy8vIDEgPDwgMTRcbiAgICAgICAgICAgIChmcmFnWzE3XSAmIDB4RkYpICogMTI4ICsvLyAxIDw8IDdcbiAgICAgICAgICAgIChmcmFnWzE4XSAmIDB4RkUpIC8gMjtcbiAgICAgICAgICAvLyBjaGVjayBpZiBncmVhdGVyIHRoYW4gMl4zMiAtMVxuICAgICAgICAgIGlmIChwZXNEdHMgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICAvLyBkZWNyZW1lbnQgMl4zM1xuICAgICAgICAgICAgcGVzRHRzIC09IDg1ODk5MzQ1OTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwZXNQdHMgLSBwZXNEdHMgPiA2MCAqIDkwMDAwKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgJHtNYXRoLnJvdW5kKChwZXNQdHMgLSBwZXNEdHMpIC8gOTAwMDApfXMgZGVsdGEgYmV0d2VlbiBQVFMgYW5kIERUUywgYWxpZ24gdGhlbWApO1xuICAgICAgICAgICAgcGVzUHRzID0gcGVzRHRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZXNEdHMgPSBwZXNQdHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBlc0hkckxlbiA9IGZyYWdbOF07XG4gICAgICAvLyA5IGJ5dGVzIDogNiBieXRlcyBmb3IgUEVTIGhlYWRlciArIDMgYnl0ZXMgZm9yIFBFUyBleHRlbnNpb25cbiAgICAgIHBheWxvYWRTdGFydE9mZnNldCA9IHBlc0hkckxlbiArIDk7XG5cbiAgICAgIHN0cmVhbS5zaXplIC09IHBheWxvYWRTdGFydE9mZnNldDtcbiAgICAgIC8vIHJlYXNzZW1ibGUgUEVTIHBhY2tldFxuICAgICAgcGVzRGF0YSA9IG5ldyBVaW50OEFycmF5KHN0cmVhbS5zaXplKTtcbiAgICAgIGZvciAobGV0IGogPSAwLCBkYXRhTGVuID0gZGF0YS5sZW5ndGg7IGogPCBkYXRhTGVuOyBqKyspIHtcbiAgICAgICAgZnJhZyA9IGRhdGFbal07XG4gICAgICAgIGxldCBsZW4gPSBmcmFnLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0ID4gbGVuKSB7XG4gICAgICAgICAgICAvLyB0cmltIGZ1bGwgZnJhZyBpZiBQRVMgaGVhZGVyIGJpZ2dlciB0aGFuIGZyYWdcbiAgICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCAtPSBsZW47XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdHJpbSBwYXJ0aWFsIGZyYWcgaWYgUEVTIGhlYWRlciBzbWFsbGVyIHRoYW4gZnJhZ1xuICAgICAgICAgICAgZnJhZyA9IGZyYWcuc3ViYXJyYXkocGF5bG9hZFN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgIGxlbiAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwZXNEYXRhLnNldChmcmFnLCBpKTtcbiAgICAgICAgaSArPSBsZW47XG4gICAgICB9XG4gICAgICBpZiAocGVzTGVuKSB7XG4gICAgICAgIC8vIHBheWxvYWQgc2l6ZSA6IHJlbW92ZSBQRVMgaGVhZGVyICsgUEVTIGV4dGVuc2lvblxuICAgICAgICBwZXNMZW4gLT0gcGVzSGRyTGVuICsgMztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRhdGE6IHBlc0RhdGEsIHB0czogcGVzUHRzLCBkdHM6IHBlc0R0cywgbGVuOiBwZXNMZW4gfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVzaEFjY2VzVW5pdCAoYXZjU2FtcGxlLCBhdmNUcmFjaykge1xuICAgIGlmIChhdmNTYW1wbGUudW5pdHMubGVuZ3RoICYmIGF2Y1NhbXBsZS5mcmFtZSkge1xuICAgICAgY29uc3Qgc2FtcGxlcyA9IGF2Y1RyYWNrLnNhbXBsZXM7XG4gICAgICBjb25zdCBuYlNhbXBsZXMgPSBzYW1wbGVzLmxlbmd0aDtcbiAgICAgIC8vIG9ubHkgcHVzaCBBVkMgc2FtcGxlIGlmIHN0YXJ0aW5nIHdpdGggYSBrZXlmcmFtZSBpcyBub3QgbWFuZGF0b3J5IE9SXG4gICAgICAvLyAgICBpZiBrZXlmcmFtZSBhbHJlYWR5IGZvdW5kIGluIHRoaXMgZnJhZ21lbnQgT1JcbiAgICAgIC8vICAgICAgIGtleWZyYW1lIGZvdW5kIGluIGxhc3QgZnJhZ21lbnQgKHRyYWNrLnNwcykgQU5EXG4gICAgICAvLyAgICAgICAgICBzYW1wbGVzIGFscmVhZHkgYXBwZW5kZWQgKHdlIGFscmVhZHkgZm91bmQgYSBrZXlmcmFtZSBpbiB0aGlzIGZyYWdtZW50KSBPUiBmcmFnbWVudCBpcyBjb250aWd1b3VzXG4gICAgICBpZiAoIXRoaXMuY29uZmlnLmZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHkgfHxcbiAgICAgICAgICBhdmNTYW1wbGUua2V5ID09PSB0cnVlIHx8XG4gICAgICAgICAgKGF2Y1RyYWNrLnNwcyAmJiAobmJTYW1wbGVzIHx8IHRoaXMuY29udGlndW91cykpKSB7XG4gICAgICAgIGF2Y1NhbXBsZS5pZCA9IG5iU2FtcGxlcztcbiAgICAgICAgc2FtcGxlcy5wdXNoKGF2Y1NhbXBsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkcm9wcGVkIHNhbXBsZXMsIHRyYWNrIGl0XG4gICAgICAgIGF2Y1RyYWNrLmRyb3BwZWQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF2Y1NhbXBsZS5kZWJ1Zy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci5sb2coYXZjU2FtcGxlLnB0cyArICcvJyArIGF2Y1NhbXBsZS5kdHMgKyAnOicgKyBhdmNTYW1wbGUuZGVidWcpO1xuICAgIH1cbiAgfVxuXG4gIF9wYXJzZUFWQ1BFUyAocGVzLCBsYXN0KSB7XG4gICAgLy8gbG9nZ2VyLmxvZygncGFyc2UgbmV3IFBFUycpO1xuICAgIGxldCB0cmFjayA9IHRoaXMuX2F2Y1RyYWNrLFxuICAgICAgdW5pdHMgPSB0aGlzLl9wYXJzZUFWQ05BTHUocGVzLmRhdGEpLFxuICAgICAgZGVidWcgPSBmYWxzZSxcbiAgICAgIGV4cEdvbG9tYkRlY29kZXIsXG4gICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSxcbiAgICAgIHB1c2gsXG4gICAgICBzcHNmb3VuZCA9IGZhbHNlLFxuICAgICAgaSxcbiAgICAgIHB1c2hBY2Nlc1VuaXQgPSB0aGlzLnB1c2hBY2Nlc1VuaXQuYmluZCh0aGlzKSxcbiAgICAgIGNyZWF0ZUFWQ1NhbXBsZSA9IGZ1bmN0aW9uIChrZXksIHB0cywgZHRzLCBkZWJ1Zykge1xuICAgICAgICByZXR1cm4geyBrZXk6IGtleSwgcHRzOiBwdHMsIGR0czogZHRzLCB1bml0czogW10sIGRlYnVnOiBkZWJ1ZyB9O1xuICAgICAgfTtcbiAgICAvLyBmcmVlIHBlcy5kYXRhIHRvIHNhdmUgdXAgc29tZSBtZW1vcnlcbiAgICBwZXMuZGF0YSA9IG51bGw7XG5cbiAgICAvLyBpZiBuZXcgTkFMIHVuaXRzIGZvdW5kIGFuZCBsYXN0IHNhbXBsZSBzdGlsbCB0aGVyZSwgbGV0J3MgcHVzaCAuLi5cbiAgICAvLyB0aGlzIGhlbHBzIHBhcnNpbmcgc3RyZWFtcyB3aXRoIG1pc3NpbmcgQVVEIChvbmx5IGRvIHRoaXMgaWYgQVVEIG5ldmVyIGZvdW5kKVxuICAgIGlmIChhdmNTYW1wbGUgJiYgdW5pdHMubGVuZ3RoICYmICF0cmFjay5hdWRGb3VuZCkge1xuICAgICAgcHVzaEFjY2VzVW5pdChhdmNTYW1wbGUsIHRyYWNrKTtcbiAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgfVxuXG4gICAgdW5pdHMuZm9yRWFjaCh1bml0ID0+IHtcbiAgICAgIHN3aXRjaCAodW5pdC50eXBlKSB7XG4gICAgICAvLyBORFJcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgIGlmICghYXZjU2FtcGxlKSB7XG4gICAgICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUgPSBjcmVhdGVBVkNTYW1wbGUodHJ1ZSwgcGVzLnB0cywgcGVzLmR0cywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdORFIgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGF2Y1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgIGxldCBkYXRhID0gdW5pdC5kYXRhO1xuICAgICAgICAvLyBvbmx5IGNoZWNrIHNsaWNlIHR5cGUgdG8gZGV0ZWN0IEtGIGluIGNhc2UgU1BTIGZvdW5kIGluIHNhbWUgcGFja2V0IChhbnkga2V5ZnJhbWUgaXMgcHJlY2VkZWQgYnkgU1BTIC4uLilcbiAgICAgICAgaWYgKHNwc2ZvdW5kICYmIGRhdGEubGVuZ3RoID4gNCkge1xuICAgICAgICAgIC8vIHJldHJpZXZlIHNsaWNlIHR5cGUgYnkgcGFyc2luZyBiZWdpbm5pbmcgb2YgTkFMIHVuaXQgKGZvbGxvdyBIMjY0IHNwZWMsIHNsaWNlX2hlYWRlciBkZWZpbml0aW9uKSB0byBkZXRlY3Qga2V5ZnJhbWUgZW1iZWRkZWQgaW4gTkRSXG4gICAgICAgICAgbGV0IHNsaWNlVHlwZSA9IG5ldyBFeHBHb2xvbWIoZGF0YSkucmVhZFNsaWNlVHlwZSgpO1xuICAgICAgICAgIC8vIDIgOiBJIHNsaWNlLCA0IDogU0kgc2xpY2UsIDcgOiBJIHNsaWNlLCA5OiBTSSBzbGljZVxuICAgICAgICAgIC8vIFNJIHNsaWNlIDogQSBzbGljZSB0aGF0IGlzIGNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seSBhbmQgdXNpbmcgcXVhbnRpc2F0aW9uIG9mIHRoZSBwcmVkaWN0aW9uIHNhbXBsZXMuXG4gICAgICAgICAgLy8gQW4gU0kgc2xpY2UgY2FuIGJlIGNvZGVkIHN1Y2ggdGhhdCBpdHMgZGVjb2RlZCBzYW1wbGVzIGNhbiBiZSBjb25zdHJ1Y3RlZCBpZGVudGljYWxseSB0byBhbiBTUCBzbGljZS5cbiAgICAgICAgICAvLyBJIHNsaWNlOiBBIHNsaWNlIHRoYXQgaXMgbm90IGFuIFNJIHNsaWNlIHRoYXQgaXMgZGVjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkuXG4gICAgICAgICAgLy8gaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDcpIHtcbiAgICAgICAgICBpZiAoc2xpY2VUeXBlID09PSAyIHx8IHNsaWNlVHlwZSA9PT0gNCB8fCBzbGljZVR5cGUgPT09IDcgfHwgc2xpY2VUeXBlID09PSA5KSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIElEUlxuICAgICAgY2FzZSA1OlxuICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgLy8gaGFuZGxlIFBFUyBub3Qgc3RhcnRpbmcgd2l0aCBBVURcbiAgICAgICAgaWYgKCFhdmNTYW1wbGUpIHtcbiAgICAgICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IGNyZWF0ZUFWQ1NhbXBsZSh0cnVlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ0lEUiAnO1xuICAgICAgICB9XG5cbiAgICAgICAgYXZjU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgIGF2Y1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBTRUlcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ1NFSSAnO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwR29sb21iRGVjb2RlciA9IG5ldyBFeHBHb2xvbWIodGhpcy5kaXNjYXJkRVBCKHVuaXQuZGF0YSkpO1xuXG4gICAgICAgIC8vIHNraXAgZnJhbWVUeXBlXG4gICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgdmFyIHBheWxvYWRUeXBlID0gMDtcbiAgICAgICAgdmFyIHBheWxvYWRTaXplID0gMDtcbiAgICAgICAgdmFyIGVuZE9mQ2FwdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGIgPSAwO1xuXG4gICAgICAgIHdoaWxlICghZW5kT2ZDYXB0aW9ucyAmJiBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlID4gMSkge1xuICAgICAgICAgIHBheWxvYWRUeXBlID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBiID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgIHBheWxvYWRUeXBlICs9IGI7XG4gICAgICAgICAgfSB3aGlsZSAoYiA9PT0gMHhGRik7XG5cbiAgICAgICAgICAvLyBQYXJzZSBwYXlsb2FkIHNpemUuXG4gICAgICAgICAgcGF5bG9hZFNpemUgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGIgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgcGF5bG9hZFNpemUgKz0gYjtcbiAgICAgICAgICB9IHdoaWxlIChiID09PSAweEZGKTtcblxuICAgICAgICAgIC8vIFRPRE86IHRoZXJlIGNhbiBiZSBtb3JlIHRoYW4gb25lIHBheWxvYWQgaW4gYW4gU0VJIHBhY2tldC4uLlxuICAgICAgICAgIC8vIFRPRE86IG5lZWQgdG8gcmVhZCB0eXBlIGFuZCBzaXplIGluIGEgd2hpbGUgbG9vcCB0byBnZXQgdGhlbSBhbGxcbiAgICAgICAgICBpZiAocGF5bG9hZFR5cGUgPT09IDQgJiYgZXhwR29sb21iRGVjb2Rlci5ieXRlc0F2YWlsYWJsZSAhPT0gMCkge1xuICAgICAgICAgICAgZW5kT2ZDYXB0aW9ucyA9IHRydWU7XG5cbiAgICAgICAgICAgIGxldCBjb3VudHJ5Q29kZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICAgIGlmIChjb3VudHJ5Q29kZSA9PT0gMTgxKSB7XG4gICAgICAgICAgICAgIGxldCBwcm92aWRlckNvZGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVU2hvcnQoKTtcblxuICAgICAgICAgICAgICBpZiAocHJvdmlkZXJDb2RlID09PSA0OSkge1xuICAgICAgICAgICAgICAgIGxldCB1c2VyU3RydWN0dXJlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUludCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHVzZXJTdHJ1Y3R1cmUgPT09IDB4NDc0MTM5MzQpIHtcbiAgICAgICAgICAgICAgICAgIGxldCB1c2VyRGF0YVR5cGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAvLyBSYXcgQ0VBLTYwOCBieXRlcyB3cmFwcGVkIGluIENFQS03MDggcGFja2V0XG4gICAgICAgICAgICAgICAgICBpZiAodXNlckRhdGFUeXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaXJzdEJ5dGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2Vjb25kQnl0ZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvdGFsQ0NzID0gMzEgJiBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBieXRlQXJyYXkgPSBbZmlyc3RCeXRlLCBzZWNvbmRCeXRlXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDQ3M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIDMgYnl0ZXMgcGVyIENDXG4gICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnNlcnRTYW1wbGVJbk9yZGVyKHRoaXMuX3R4dFRyYWNrLnNhbXBsZXMsIHsgdHlwZTogMywgcHRzOiBwZXMucHRzLCBieXRlczogYnl0ZUFycmF5IH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZFNpemUgPCBleHBHb2xvbWJEZWNvZGVyLmJ5dGVzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF5bG9hZFNpemU7IGkrKykge1xuICAgICAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgLy8gU1BTXG4gICAgICBjYXNlIDc6XG4gICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICBzcHNmb3VuZCA9IHRydWU7XG4gICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ1NQUyAnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0cmFjay5zcHMpIHtcbiAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyID0gbmV3IEV4cEdvbG9tYih1bml0LmRhdGEpO1xuICAgICAgICAgIGxldCBjb25maWcgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRTUFMoKTtcbiAgICAgICAgICB0cmFjay53aWR0aCA9IGNvbmZpZy53aWR0aDtcbiAgICAgICAgICB0cmFjay5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgICAgIHRyYWNrLnBpeGVsUmF0aW8gPSBjb25maWcucGl4ZWxSYXRpbztcbiAgICAgICAgICB0cmFjay5zcHMgPSBbdW5pdC5kYXRhXTtcbiAgICAgICAgICB0cmFjay5kdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgICAgICAgIGxldCBjb2RlY2FycmF5ID0gdW5pdC5kYXRhLnN1YmFycmF5KDEsIDQpO1xuICAgICAgICAgIGxldCBjb2RlY3N0cmluZyA9ICdhdmMxLic7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgbGV0IGggPSBjb2RlY2FycmF5W2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvZGVjc3RyaW5nICs9IGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyYWNrLmNvZGVjID0gY29kZWNzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFBQU1xuICAgICAgY2FzZSA4OlxuICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgaWYgKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xuICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnUFBTICc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRyYWNrLnBwcykge1xuICAgICAgICAgIHRyYWNrLnBwcyA9IFt1bml0LmRhdGFdO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEFVRFxuICAgICAgY2FzZSA5OlxuICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgIHRyYWNrLmF1ZEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgICAgIHB1c2hBY2Nlc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IGNyZWF0ZUFWQ1NhbXBsZShmYWxzZSwgcGVzLnB0cywgcGVzLmR0cywgZGVidWcgPyAnQVVEICcgOiAnJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBGaWxsZXIgRGF0YVxuICAgICAgY2FzZSAxMjpcbiAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKGF2Y1NhbXBsZSkge1xuICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAndW5rbm93biBOQUwgJyArIHVuaXQudHlwZSArICcgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGF2Y1NhbXBsZSAmJiBwdXNoKSB7XG4gICAgICAgIGxldCB1bml0cyA9IGF2Y1NhbXBsZS51bml0cztcbiAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBpZiBsYXN0IFBFUyBwYWNrZXQsIHB1c2ggc2FtcGxlc1xuICAgIGlmIChsYXN0ICYmIGF2Y1NhbXBsZSkge1xuICAgICAgcHVzaEFjY2VzVW5pdChhdmNTYW1wbGUsIHRyYWNrKTtcbiAgICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBfaW5zZXJ0U2FtcGxlSW5PcmRlciAoYXJyLCBkYXRhKSB7XG4gICAgbGV0IGxlbiA9IGFyci5sZW5ndGg7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgIGlmIChkYXRhLnB0cyA+PSBhcnJbbGVuIC0gMV0ucHRzKSB7XG4gICAgICAgIGFyci5wdXNoKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gbGVuIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgICAgaWYgKGRhdGEucHRzIDwgYXJyW3Bvc10ucHRzKSB7XG4gICAgICAgICAgICBhcnIuc3BsaWNlKHBvcywgMCwgZGF0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXJyLnB1c2goZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgX2dldExhc3ROYWxVbml0ICgpIHtcbiAgICBsZXQgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUsIGxhc3RVbml0O1xuICAgIC8vIHRyeSB0byBmYWxsYmFjayB0byBwcmV2aW91cyBzYW1wbGUgaWYgY3VycmVudCBvbmUgaXMgZW1wdHlcbiAgICBpZiAoIWF2Y1NhbXBsZSB8fCBhdmNTYW1wbGUudW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsZXQgdHJhY2sgPSB0aGlzLl9hdmNUcmFjaywgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgICBhdmNTYW1wbGUgPSBzYW1wbGVzW3NhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGlmIChhdmNTYW1wbGUpIHtcbiAgICAgIGxldCB1bml0cyA9IGF2Y1NhbXBsZS51bml0cztcbiAgICAgIGxhc3RVbml0ID0gdW5pdHNbdW5pdHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBsYXN0VW5pdDtcbiAgfVxuXG4gIF9wYXJzZUFWQ05BTHUgKGFycmF5KSB7XG4gICAgbGV0IGkgPSAwLCBsZW4gPSBhcnJheS5ieXRlTGVuZ3RoLCB2YWx1ZSwgb3ZlcmZsb3csIHRyYWNrID0gdGhpcy5fYXZjVHJhY2ssIHN0YXRlID0gdHJhY2submFsdVN0YXRlIHx8IDAsIGxhc3RTdGF0ZSA9IHN0YXRlO1xuICAgIGxldCB1bml0cyA9IFtdLCB1bml0LCB1bml0VHlwZSwgbGFzdFVuaXRTdGFydCA9IC0xLCBsYXN0VW5pdFR5cGU7XG4gICAgLy8gbG9nZ2VyLmxvZygnUEVTOicgKyBIZXguaGV4RHVtcChhcnJheSkpO1xuXG4gICAgaWYgKHN0YXRlID09PSAtMSkge1xuICAgIC8vIHNwZWNpYWwgdXNlIGNhc2Ugd2hlcmUgd2UgZm91bmQgMyBvciA0LWJ5dGUgc3RhcnQgY29kZXMgZXhhY3RseSBhdCB0aGUgZW5kIG9mIHByZXZpb3VzIFBFUyBwYWNrZXRcbiAgICAgIGxhc3RVbml0U3RhcnQgPSAwO1xuICAgICAgLy8gTkFMdSB0eXBlIGlzIHZhbHVlIHJlYWQgZnJvbSBvZmZzZXQgMFxuICAgICAgbGFzdFVuaXRUeXBlID0gYXJyYXlbMF0gJiAweDFmO1xuICAgICAgc3RhdGUgPSAwO1xuICAgICAgaSA9IDE7XG4gICAgfVxuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIHZhbHVlID0gYXJyYXlbaSsrXTtcbiAgICAgIC8vIG9wdGltaXphdGlvbi4gc3RhdGUgMCBhbmQgMSBhcmUgdGhlIHByZWRvbWluYW50IGNhc2UuIGxldCdzIGhhbmRsZSB0aGVtIG91dHNpZGUgb2YgdGhlIHN3aXRjaC9jYXNlXG4gICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgPT09IDEpIHtcbiAgICAgICAgc3RhdGUgPSB2YWx1ZSA/IDAgOiAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIGhlcmUgd2UgaGF2ZSBzdGF0ZSBlaXRoZXIgZXF1YWwgdG8gMiBvciAzXG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHN0YXRlID0gMztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDEpIHtcbiAgICAgICAgaWYgKGxhc3RVbml0U3RhcnQgPj0gMCkge1xuICAgICAgICAgIHVuaXQgPSB7IGRhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGkgLSBzdGF0ZSAtIDEpLCB0eXBlOiBsYXN0VW5pdFR5cGUgfTtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbGFzdFVuaXRTdGFydCBpcyB1bmRlZmluZWQgPT4gdGhpcyBpcyB0aGUgZmlyc3Qgc3RhcnQgY29kZSBmb3VuZCBpbiB0aGlzIFBFUyBwYWNrZXRcbiAgICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiBzdGFydCBjb2RlIGRlbGltaXRlciBpcyBvdmVybGFwcGluZyBiZXR3ZWVuIDIgUEVTIHBhY2tldHMsXG4gICAgICAgICAgLy8gaWUgaXQgc3RhcnRlZCBpbiBsYXN0IHBhY2tldCAobGFzdFN0YXRlIG5vdCB6ZXJvKVxuICAgICAgICAgIC8vIGFuZCBlbmRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgUEVTIHBhY2tldCAoaSA8PSA0IC0gbGFzdFN0YXRlKVxuICAgICAgICAgIGxldCBsYXN0VW5pdCA9IHRoaXMuX2dldExhc3ROYWxVbml0KCk7XG4gICAgICAgICAgaWYgKGxhc3RVbml0KSB7XG4gICAgICAgICAgICBpZiAobGFzdFN0YXRlICYmIChpIDw9IDQgLSBsYXN0U3RhdGUpKSB7XG4gICAgICAgICAgICAgIC8vIHN0YXJ0IGRlbGltaXRlciBvdmVybGFwcGluZyBiZXR3ZWVuIFBFUyBwYWNrZXRzXG4gICAgICAgICAgICAgIC8vIHN0cmlwIHN0YXJ0IGRlbGltaXRlciBieXRlcyBmcm9tIHRoZSBlbmQgb2YgbGFzdCBOQUwgdW5pdFxuICAgICAgICAgICAgICAvLyBjaGVjayBpZiBsYXN0VW5pdCBoYWQgYSBzdGF0ZSBkaWZmZXJlbnQgZnJvbSB6ZXJvXG4gICAgICAgICAgICAgIGlmIChsYXN0VW5pdC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGxhc3QgYnl0ZXNcbiAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gbGFzdFVuaXQuZGF0YS5zdWJhcnJheSgwLCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggLSBsYXN0U3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBOQUwgdW5pdHMgYXJlIG5vdCBzdGFydGluZyByaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGFja2V0LCBwdXNoIHByZWNlZGluZyBkYXRhIGludG8gcHJldmlvdXMgTkFMIHVuaXQuXG4gICAgICAgICAgICBvdmVyZmxvdyA9IGkgLSBzdGF0ZSAtIDE7XG4gICAgICAgICAgICBpZiAob3ZlcmZsb3cgPiAwKSB7XG4gICAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2ZpcnN0IE5BTFUgZm91bmQgd2l0aCBvdmVyZmxvdzonICsgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgICBsZXQgdG1wID0gbmV3IFVpbnQ4QXJyYXkobGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgICB0bXAuc2V0KGxhc3RVbml0LmRhdGEsIDApO1xuICAgICAgICAgICAgICB0bXAuc2V0KGFycmF5LnN1YmFycmF5KDAsIG92ZXJmbG93KSwgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgY2FuIHJlYWQgdW5pdCB0eXBlXG4gICAgICAgIGlmIChpIDwgbGVuKSB7XG4gICAgICAgICAgdW5pdFR5cGUgPSBhcnJheVtpXSAmIDB4MWY7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnZmluZCBOQUxVIEAgb2Zmc2V0OicgKyBpICsgJyx0eXBlOicgKyB1bml0VHlwZSk7XG4gICAgICAgICAgbGFzdFVuaXRTdGFydCA9IGk7XG4gICAgICAgICAgbGFzdFVuaXRUeXBlID0gdW5pdFR5cGU7XG4gICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vdCBlbm91Z2ggYnl0ZSB0byByZWFkIHVuaXQgdHlwZS4gbGV0J3MgcmVhZCBpdCBvbiBuZXh0IFBFUyBwYXJzaW5nXG4gICAgICAgICAgc3RhdGUgPSAtMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdFVuaXRTdGFydCA+PSAwICYmIHN0YXRlID49IDApIHtcbiAgICAgIHVuaXQgPSB7IGRhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGxlbiksIHR5cGU6IGxhc3RVbml0VHlwZSwgc3RhdGU6IHN0YXRlIH07XG4gICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgICAgLy8gbG9nZ2VyLmxvZygncHVzaGluZyBOQUxVLCB0eXBlL3NpemUvc3RhdGU6JyArIHVuaXQudHlwZSArICcvJyArIHVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgJy8nICsgc3RhdGUpO1xuICAgIH1cbiAgICAvLyBubyBOQUx1IGZvdW5kXG4gICAgaWYgKHVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gYXBwZW5kIHBlcy5kYXRhIHRvIHByZXZpb3VzIE5BTCB1bml0XG4gICAgICBsZXQgbGFzdFVuaXQgPSB0aGlzLl9nZXRMYXN0TmFsVW5pdCgpO1xuICAgICAgaWYgKGxhc3RVbml0KSB7XG4gICAgICAgIGxldCB0bXAgPSBuZXcgVWludDhBcnJheShsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggKyBhcnJheS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdG1wLnNldChsYXN0VW5pdC5kYXRhLCAwKTtcbiAgICAgICAgdG1wLnNldChhcnJheSwgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgbGFzdFVuaXQuZGF0YSA9IHRtcDtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJhY2submFsdVN0YXRlID0gc3RhdGU7XG4gICAgcmV0dXJuIHVuaXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlbW92ZSBFbXVsYXRpb24gUHJldmVudGlvbiBieXRlcyBmcm9tIGEgUkJTUFxuICAgKi9cbiAgZGlzY2FyZEVQQiAoZGF0YSkge1xuICAgIGxldCBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICBFUEJQb3NpdGlvbnMgPSBbXSxcbiAgICAgIGkgPSAxLFxuICAgICAgbmV3TGVuZ3RoLCBuZXdEYXRhO1xuXG4gICAgLy8gRmluZCBhbGwgYEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzYFxuICAgIHdoaWxlIChpIDwgbGVuZ3RoIC0gMikge1xuICAgICAgaWYgKGRhdGFbaV0gPT09IDAgJiZcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9PT0gMCAmJlxuICAgICAgICAgIGRhdGFbaSArIDJdID09PSAweDAzKSB7XG4gICAgICAgIEVQQlBvc2l0aW9ucy5wdXNoKGkgKyAyKTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vIEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzIHdlcmUgZm91bmQganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gICAgLy8gYXJyYXlcbiAgICBpZiAoRVBCUG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIGhvbGQgdGhlIE5BTCB1bml0IGRhdGFcbiAgICBuZXdMZW5ndGggPSBsZW5ndGggLSBFUEJQb3NpdGlvbnMubGVuZ3RoO1xuICAgIG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xuICAgIGxldCBzb3VyY2VJbmRleCA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbmV3TGVuZ3RoOyBzb3VyY2VJbmRleCsrLCBpKyspIHtcbiAgICAgIGlmIChzb3VyY2VJbmRleCA9PT0gRVBCUG9zaXRpb25zWzBdKSB7XG4gICAgICAgIC8vIFNraXAgdGhpcyBieXRlXG4gICAgICAgIHNvdXJjZUluZGV4Kys7XG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIHBvc2l0aW9uIGluZGV4XG4gICAgICAgIEVQQlBvc2l0aW9ucy5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgbmV3RGF0YVtpXSA9IGRhdGFbc291cmNlSW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfVxuXG4gIF9wYXJzZUFBQ1BFUyAocGVzKSB7XG4gICAgbGV0IHRyYWNrID0gdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgIGRhdGEgPSBwZXMuZGF0YSxcbiAgICAgIHB0cyA9IHBlcy5wdHMsXG4gICAgICBzdGFydE9mZnNldCA9IDAsXG4gICAgICBhYWNPdmVyRmxvdyA9IHRoaXMuYWFjT3ZlckZsb3csXG4gICAgICBhYWNMYXN0UFRTID0gdGhpcy5hYWNMYXN0UFRTLFxuICAgICAgZnJhbWVEdXJhdGlvbiwgZnJhbWVJbmRleCwgb2Zmc2V0LCBzdGFtcCwgbGVuO1xuICAgIGlmIChhYWNPdmVyRmxvdykge1xuICAgICAgbGV0IHRtcCA9IG5ldyBVaW50OEFycmF5KGFhY092ZXJGbG93LmJ5dGVMZW5ndGggKyBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgdG1wLnNldChhYWNPdmVyRmxvdywgMCk7XG4gICAgICB0bXAuc2V0KGRhdGEsIGFhY092ZXJGbG93LmJ5dGVMZW5ndGgpO1xuICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDOiBhcHBlbmQgb3ZlcmZsb3dpbmcgJHthYWNPdmVyRmxvdy5ieXRlTGVuZ3RofSBieXRlcyB0byBiZWdpbm5pbmcgb2YgbmV3IFBFU2ApO1xuICAgICAgZGF0YSA9IHRtcDtcbiAgICB9XG4gICAgLy8gbG9vayBmb3IgQURUUyBoZWFkZXIgKDB4RkZGeClcbiAgICBmb3IgKG9mZnNldCA9IHN0YXJ0T2Zmc2V0LCBsZW4gPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgIGlmIChBRFRTLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIEFEVFMgaGVhZGVyIGRvZXMgbm90IHN0YXJ0IHN0cmFpZ2h0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBheWxvYWQsIHJhaXNlIGFuIGVycm9yXG4gICAgaWYgKG9mZnNldCkge1xuICAgICAgbGV0IHJlYXNvbiwgZmF0YWw7XG4gICAgICBpZiAob2Zmc2V0IDwgbGVuIC0gMSkge1xuICAgICAgICByZWFzb24gPSBgQUFDIFBFUyBkaWQgbm90IHN0YXJ0IHdpdGggQURUUyBoZWFkZXIsb2Zmc2V0OiR7b2Zmc2V0fWA7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWFzb24gPSAnbm8gQURUUyBoZWFkZXIgZm91bmQgaW4gQUFDIFBFUyc7XG4gICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci53YXJuKGBwYXJzaW5nIGVycm9yOiR7cmVhc29ufWApO1xuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiBmYXRhbCwgcmVhc29uOiByZWFzb24gfSk7XG4gICAgICBpZiAoZmF0YWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIEFEVFMuaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCB0aGlzLm9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIHRoaXMuYXVkaW9Db2RlYyk7XG4gICAgZnJhbWVJbmRleCA9IDA7XG4gICAgZnJhbWVEdXJhdGlvbiA9IEFEVFMuZ2V0RnJhbWVEdXJhdGlvbih0cmFjay5zYW1wbGVyYXRlKTtcblxuICAgIC8vIGlmIGxhc3QgQUFDIGZyYW1lIGlzIG92ZXJmbG93aW5nLCB3ZSBzaG91bGQgZW5zdXJlIHRpbWVzdGFtcHMgYXJlIGNvbnRpZ3VvdXM6XG4gICAgLy8gZmlyc3Qgc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZnJhbWVEdXJhdGlvblxuICAgIGlmIChhYWNPdmVyRmxvdyAmJiBhYWNMYXN0UFRTKSB7XG4gICAgICBsZXQgbmV3UFRTID0gYWFjTGFzdFBUUyArIGZyYW1lRHVyYXRpb247XG4gICAgICBpZiAoTWF0aC5hYnMobmV3UFRTIC0gcHRzKSA+IDEpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgQUFDOiBhbGlnbiBQVFMgZm9yIG92ZXJsYXBwaW5nIGZyYW1lcyBieSAke01hdGgucm91bmQoKG5ld1BUUyAtIHB0cykgLyA5MCl9YCk7XG4gICAgICAgIHB0cyA9IG5ld1BUUztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzY2FuIGZvciBhYWMgc2FtcGxlc1xuICAgIHdoaWxlIChvZmZzZXQgPCBsZW4pIHtcbiAgICAgIGlmIChBRFRTLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkgJiYgKG9mZnNldCArIDUpIDwgbGVuKSB7XG4gICAgICAgIGxldCBmcmFtZSA9IEFEVFMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZyhgJHtNYXRoLnJvdW5kKGZyYW1lLnNhbXBsZS5wdHMpfSA6IEFBQ2ApO1xuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgc3RhbXAgPSBmcmFtZS5zYW1wbGUucHRzO1xuICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdVbmFibGUgdG8gcGFyc2UgQUFDIGZyYW1lJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICBhYWNPdmVyRmxvdyA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBsZW4pO1xuICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDOiBvdmVyZmxvdyBkZXRlY3RlZDoke2xlbi1vZmZzZXR9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmFhY092ZXJGbG93ID0gYWFjT3ZlckZsb3c7XG4gICAgdGhpcy5hYWNMYXN0UFRTID0gc3RhbXA7XG4gIH1cblxuICBfcGFyc2VNUEVHUEVTIChwZXMpIHtcbiAgICBsZXQgZGF0YSA9IHBlcy5kYXRhO1xuICAgIGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICBsZXQgZnJhbWVJbmRleCA9IDA7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgbGV0IHB0cyA9IHBlcy5wdHM7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoTXBlZ0F1ZGlvLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgbGV0IGZyYW1lID0gTXBlZ0F1ZGlvLmFwcGVuZEZyYW1lKHRoaXMuX2F1ZGlvVHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnVW5hYmxlIHRvIHBhcnNlIE1wZWcgYXVkaW8gZnJhbWUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBmb3VuZCwga2VlcCBsb29raW5nXG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9wYXJzZUlEM1BFUyAocGVzKSB7XG4gICAgdGhpcy5faWQzVHJhY2suc2FtcGxlcy5wdXNoKHBlcyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVFNEZW11eGVyO1xuIiwiZXhwb3J0IGNvbnN0IEVycm9yVHlwZXMgPSB7XG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbmV0d29yayBlcnJvciAobG9hZGluZyBlcnJvciAvIHRpbWVvdXQgLi4uKVxuICBORVRXT1JLX0VSUk9SOiAnbmV0d29ya0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtZWRpYSBFcnJvciAodmlkZW8vcGFyc2luZy9tZWRpYXNvdXJjZSBlcnJvcilcbiAgTUVESUFfRVJST1I6ICdtZWRpYUVycm9yJyxcbiAgLy8gRU1FIChlbmNyeXB0ZWQgbWVkaWEgZXh0ZW5zaW9ucykgZXJyb3JzXG4gIEtFWV9TWVNURU1fRVJST1I6ICdrZXlTeXN0ZW1FcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbXV4IEVycm9yIChkZW11eGluZy9yZW11eGluZylcbiAgTVVYX0VSUk9SOiAnbXV4RXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbGwgb3RoZXIgZXJyb3JzXG4gIE9USEVSX0VSUk9SOiAnb3RoZXJFcnJvcidcbn07XG5cbi8qKlxuICogQGVudW0ge0Vycm9yRGV0YWlsc31cbiAqIEB0eXBlZGVmIHtzdHJpbmd9IEVycm9yRGV0YWlsXG4gKi9cbmV4cG9ydCBjb25zdCBFcnJvckRldGFpbHMgPSB7XG4gIEtFWV9TWVNURU1fTk9fS0VZUzogJ2tleVN5c3RlbU5vS2V5cycsXG4gIEtFWV9TWVNURU1fTk9fQUNDRVNTOiAna2V5U3lzdGVtTm9BY2Nlc3MnLFxuICBLRVlfU1lTVEVNX05PX1NFU1NJT046ICdrZXlTeXN0ZW1Ob1Nlc3Npb24nLFxuICBLRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQ6ICdrZXlTeXN0ZW1MaWNlbnNlUmVxdWVzdEZhaWxlZCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTUFOSUZFU1RfTE9BRF9FUlJPUjogJ21hbmlmZXN0TG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIE1BTklGRVNUX0xPQURfVElNRU9VVDogJ21hbmlmZXN0TG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IHBhcnNpbmcgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlYXNvbiA6IGVycm9yIHJlYXNvbn1cbiAgTUFOSUZFU1RfUEFSU0lOR19FUlJPUjogJ21hbmlmZXN0UGFyc2luZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCB3aXRoIG9ubHkgaW5jb21wYXRpYmxlIGNvZGVjcyBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVhc29uIDogZXJyb3IgcmVhc29ufVxuICBNQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SOiAnbWFuaWZlc3RJbmNvbXBhdGlibGVDb2RlY3NFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTEVWRUxfTE9BRF9FUlJPUjogJ2xldmVsTG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIExFVkVMX0xPQURfVElNRU9VVDogJ2xldmVsTG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIHN3aXRjaCBlcnJvciAtIGRhdGE6IHsgbGV2ZWwgOiBmYXVsdHkgbGV2ZWwgSWQsIGV2ZW50IDogZXJyb3IgZGVzY3JpcHRpb259XG4gIExFVkVMX1NXSVRDSF9FUlJPUjogJ2xldmVsU3dpdGNoRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBBVURJT19UUkFDS19MT0FEX0VSUk9SOiAnYXVkaW9UcmFja0xvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGF1ZGlvIHRyYWNrIGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOiAnYXVkaW9UcmFja0xvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgRlJBR19MT0FEX0VSUk9SOiAnZnJhZ0xvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvYWQgdGltZW91dCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdH1cbiAgRlJBR19MT0FEX1RJTUVPVVQ6ICdmcmFnTG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IGRlY3J5cHRpb24gZXJyb3IgZXZlbnQgLSBkYXRhOiB7aWQgOiBkZW11eGVyIElkLGZyYWc6IGZyYWdtZW50IG9iamVjdCwgcmVhc29uIDogcGFyc2luZyBlcnJvciBkZXNjcmlwdGlvbiB9XG4gIEZSQUdfREVDUllQVF9FUlJPUjogJ2ZyYWdEZWNyeXB0RXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IHBhcnNpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBJZCwgcmVhc29uIDogcGFyc2luZyBlcnJvciBkZXNjcmlwdGlvbiB9XG4gIC8vIHdpbGwgYmUgcmVuYW1lZCBERU1VWF9QQVJTSU5HX0VSUk9SIGFuZCBzd2l0Y2hlZCB0byBNVVhfRVJST1IgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxuICBGUkFHX1BBUlNJTkdfRVJST1I6ICdmcmFnUGFyc2luZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSByZW11eCBhbGxvYyBlcnJvciBldmVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIElkLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBieXRlcyA6IG5iIG9mIGJ5dGVzIG9uIHdoaWNoIGFsbG9jYXRpb24gZmFpbGVkICwgcmVhc29uIDogZXJyb3IgdGV4dCB9XG4gIFJFTVVYX0FMTE9DX0VSUk9SOiAncmVtdXhBbGxvY0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZGVjcnlwdCBrZXkgbG9hZCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgS0VZX0xPQURfRVJST1I6ICdrZXlMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBkZWNyeXB0IGtleSBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEtFWV9MT0FEX1RJTUVPVVQ6ICdrZXlMb2FkVGltZU91dCcsXG4gIC8vIFRyaWdnZXJlZCB3aGVuIGFuIGV4Y2VwdGlvbiBvY2N1cnMgd2hpbGUgYWRkaW5nIGEgc291cmNlQnVmZmVyIHRvIE1lZGlhU291cmNlIC0gZGF0YSA6IHsgIGVyciA6IGV4Y2VwdGlvbiAsIG1pbWVUeXBlIDogbWltZVR5cGUgfVxuICBCVUZGRVJfQUREX0NPREVDX0VSUk9SOiAnYnVmZmVyQWRkQ29kZWNFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGFwcGVuZCBlcnJvciAtIGRhdGE6IGFwcGVuZCBlcnJvciBkZXNjcmlwdGlvblxuICBCVUZGRVJfQVBQRU5EX0VSUk9SOiAnYnVmZmVyQXBwZW5kRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBhcHBlbmRpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiBhcHBlbmRpbmcgZXJyb3IgZGVzY3JpcHRpb25cbiAgQlVGRkVSX0FQUEVORElOR19FUlJPUjogJ2J1ZmZlckFwcGVuZGluZ0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgc3RhbGxlZCBlcnJvciBldmVudFxuICBCVUZGRVJfU1RBTExFRF9FUlJPUjogJ2J1ZmZlclN0YWxsZWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGZ1bGwgZXZlbnRcbiAgQlVGRkVSX0ZVTExfRVJST1I6ICdidWZmZXJGdWxsRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBzZWVrIG92ZXIgaG9sZSBldmVudFxuICBCVUZGRVJfU0VFS19PVkVSX0hPTEU6ICdidWZmZXJTZWVrT3ZlckhvbGUnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBudWRnZSBvbiBzdGFsbCAocGxheWJhY2sgaXMgc3R1Y2sgYWx0aG91Z2ggY3VycmVudFRpbWUgaXMgaW4gYSBidWZmZXJlZCBhcmVhKVxuICBCVUZGRVJfTlVER0VfT05fU1RBTEw6ICdidWZmZXJOdWRnZU9uU3RhbGwnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBpbnRlcm5hbCBleGNlcHRpb24gaGFwcGVuaW5nIGluc2lkZSBobHMuanMgd2hpbGUgaGFuZGxpbmcgYW4gZXZlbnRcbiAgSU5URVJOQUxfRVhDRVBUSU9OOiAnaW50ZXJuYWxFeGNlcHRpb24nXG59O1xuIiwiLypcbipcbiogQWxsIG9iamVjdHMgaW4gdGhlIGV2ZW50IGhhbmRsaW5nIGNoYWluIHNob3VsZCBpbmhlcml0IGZyb20gdGhpcyBjbGFzc1xuKlxuKi9cblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4vZXZlbnRzJztcblxuY29uc3QgRk9SQklEREVOX0VWRU5UX05BTUVTID0ge1xuICAnaGxzRXZlbnRHZW5lcmljJzogdHJ1ZSxcbiAgJ2hsc0hhbmRsZXJEZXN0cm95aW5nJzogdHJ1ZSxcbiAgJ2hsc0hhbmRsZXJEZXN0cm95ZWQnOiB0cnVlXG59O1xuXG5jbGFzcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzLCAuLi5ldmVudHMpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLm9uRXZlbnQgPSB0aGlzLm9uRXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZWRFdmVudHMgPSBldmVudHM7XG4gICAgdGhpcy51c2VHZW5lcmljSGFuZGxlciA9IHRydWU7XG5cbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLm9uSGFuZGxlckRlc3Ryb3lpbmcoKTtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLm9uSGFuZGxlckRlc3Ryb3llZCgpO1xuICB9XG5cbiAgb25IYW5kbGVyRGVzdHJveWluZyAoKSB7fVxuICBvbkhhbmRsZXJEZXN0cm95ZWQgKCkge31cblxuICBpc0V2ZW50SGFuZGxlciAoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLmhhbmRsZWRFdmVudHMgPT09ICdvYmplY3QnICYmIHRoaXMuaGFuZGxlZEV2ZW50cy5sZW5ndGggJiYgdHlwZW9mIHRoaXMub25FdmVudCA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIHJlZ2lzdGVyTGlzdGVuZXJzICgpIHtcbiAgICBpZiAodGhpcy5pc0V2ZW50SGFuZGxlcigpKSB7XG4gICAgICB0aGlzLmhhbmRsZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKEZPUkJJRERFTl9FVkVOVF9OQU1FU1tldmVudF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvcmJpZGRlbiBldmVudC1uYW1lOiAnICsgZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5obHMub24oZXZlbnQsIHRoaXMub25FdmVudCk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzICgpIHtcbiAgICBpZiAodGhpcy5pc0V2ZW50SGFuZGxlcigpKSB7XG4gICAgICB0aGlzLmhhbmRsZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5obHMub2ZmKGV2ZW50LCB0aGlzLm9uRXZlbnQpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGFyZ3VtZW50czogZXZlbnQgKHN0cmluZyksIGRhdGEgKGFueSlcbiAgICovXG4gIG9uRXZlbnQgKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5vbkV2ZW50R2VuZXJpYyhldmVudCwgZGF0YSk7XG4gIH1cblxuICBvbkV2ZW50R2VuZXJpYyAoZXZlbnQsIGRhdGEpIHtcbiAgICBsZXQgZXZlbnRUb0Z1bmN0aW9uID0gZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgICBsZXQgZnVuY05hbWUgPSAnb24nICsgZXZlbnQucmVwbGFjZSgnaGxzJywgJycpO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzW2Z1bmNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV2ZW50ICR7ZXZlbnR9IGhhcyBubyBnZW5lcmljIGhhbmRsZXIgaW4gdGhpcyAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gY2xhc3MgKHRyaWVkICR7ZnVuY05hbWV9KWApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpc1tmdW5jTmFtZV0uYmluZCh0aGlzLCBkYXRhKTtcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBldmVudFRvRnVuY3Rpb24uY2FsbCh0aGlzLCBldmVudCwgZGF0YSkuY2FsbCgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyLmVycm9yKGBBbiBpbnRlcm5hbCBlcnJvciBoYXBwZW5lZCB3aGlsZSBoYW5kbGluZyBldmVudCAke2V2ZW50fS4gRXJyb3IgbWVzc2FnZTogXCIke2Vyci5tZXNzYWdlfVwiLiBIZXJlIGlzIGEgc3RhY2t0cmFjZTpgLCBlcnIpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLCBmYXRhbDogZmFsc2UsIGV2ZW50OiBldmVudCwgZXJyOiBlcnIgfSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50SGFuZGxlcjtcbiIsIi8qKlxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5jb25zdCBIbHNFdmVudHMgPSB7XG4gIC8vIGZpcmVkIGJlZm9yZSBNZWRpYVNvdXJjZSBpcyBhdHRhY2hpbmcgdG8gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgbWVkaWEgfVxuICBNRURJQV9BVFRBQ0hJTkc6ICdobHNNZWRpYUF0dGFjaGluZycsXG4gIC8vIGZpcmVkIHdoZW4gTWVkaWFTb3VyY2UgaGFzIGJlZW4gc3VjY2VzZnVsbHkgYXR0YWNoZWQgdG8gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgfVxuICBNRURJQV9BVFRBQ0hFRDogJ2hsc01lZGlhQXR0YWNoZWQnLFxuICAvLyBmaXJlZCBiZWZvcmUgZGV0YWNoaW5nIE1lZGlhU291cmNlIGZyb20gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgfVxuICBNRURJQV9ERVRBQ0hJTkc6ICdobHNNZWRpYURldGFjaGluZycsXG4gIC8vIGZpcmVkIHdoZW4gTWVkaWFTb3VyY2UgaGFzIGJlZW4gZGV0YWNoZWQgZnJvbSBtZWRpYSBlbGVtZW50IC0gZGF0YTogeyB9XG4gIE1FRElBX0RFVEFDSEVEOiAnaGxzTWVkaWFEZXRhY2hlZCcsXG4gIC8vIGZpcmVkIHdoZW4gd2UgYnVmZmVyIGlzIGdvaW5nIHRvIGJlIHJlc2V0IC0gZGF0YTogeyB9XG4gIEJVRkZFUl9SRVNFVDogJ2hsc0J1ZmZlclJlc2V0JyxcbiAgLy8gZmlyZWQgd2hlbiB3ZSBrbm93IGFib3V0IHRoZSBjb2RlY3MgdGhhdCB3ZSBuZWVkIGJ1ZmZlcnMgZm9yIHRvIHB1c2ggaW50byAtIGRhdGE6IHt0cmFja3MgOiB7IGNvbnRhaW5lciwgY29kZWMsIGxldmVsQ29kZWMsIGluaXRTZWdtZW50LCBtZXRhZGF0YSB9fVxuICBCVUZGRVJfQ09ERUNTOiAnaGxzQnVmZmVyQ29kZWNzJyxcbiAgLy8gZmlyZWQgd2hlbiBzb3VyY2VidWZmZXJzIGhhdmUgYmVlbiBjcmVhdGVkIC0gZGF0YTogeyB0cmFja3MgOiB0cmFja3MgfVxuICBCVUZGRVJfQ1JFQVRFRDogJ2hsc0J1ZmZlckNyZWF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIHdlIGFwcGVuZCBhIHNlZ21lbnQgdG8gdGhlIGJ1ZmZlciAtIGRhdGE6IHsgc2VnbWVudDogc2VnbWVudCBvYmplY3QgfVxuICBCVUZGRVJfQVBQRU5ESU5HOiAnaGxzQnVmZmVyQXBwZW5kaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiB3ZSBhcmUgZG9uZSB3aXRoIGFwcGVuZGluZyBhIG1lZGlhIHNlZ21lbnQgdG8gdGhlIGJ1ZmZlciAtIGRhdGEgOiB7IHBhcmVudCA6IHNlZ21lbnQgcGFyZW50IHRoYXQgdHJpZ2dlcmVkIEJVRkZFUl9BUFBFTkRJTkcsIHBlbmRpbmcgOiBuYiBvZiBzZWdtZW50cyB3YWl0aW5nIGZvciBhcHBlbmRpbmcgZm9yIHRoaXMgc2VnbWVudCBwYXJlbnR9XG4gIEJVRkZFUl9BUFBFTkRFRDogJ2hsc0J1ZmZlckFwcGVuZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiB0aGUgc3RyZWFtIGlzIGZpbmlzaGVkIGFuZCB3ZSB3YW50IHRvIG5vdGlmeSB0aGUgbWVkaWEgYnVmZmVyIHRoYXQgdGhlcmUgd2lsbCBiZSBubyBtb3JlIGRhdGEgLSBkYXRhOiB7IH1cbiAgQlVGRkVSX0VPUzogJ2hsc0J1ZmZlckVvcycsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIG1lZGlhIGJ1ZmZlciBzaG91bGQgYmUgZmx1c2hlZCAtIGRhdGEgeyBzdGFydE9mZnNldCwgZW5kT2Zmc2V0IH1cbiAgQlVGRkVSX0ZMVVNISU5HOiAnaGxzQnVmZmVyRmx1c2hpbmcnLFxuICAvLyBmaXJlZCB3aGVuIHRoZSBtZWRpYSBidWZmZXIgaGFzIGJlZW4gZmx1c2hlZCAtIGRhdGE6IHsgfVxuICBCVUZGRVJfRkxVU0hFRDogJ2hsc0J1ZmZlckZsdXNoZWQnLFxuICAvLyBmaXJlZCB0byBzaWduYWwgdGhhdCBhIG1hbmlmZXN0IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBtYW5pZmVzdFVSTH1cbiAgTUFOSUZFU1RfTE9BRElORzogJ2hsc01hbmlmZXN0TG9hZGluZycsXG4gIC8vIGZpcmVkIGFmdGVyIG1hbmlmZXN0IGhhcyBiZWVuIGxvYWRlZCAtIGRhdGE6IHsgbGV2ZWxzIDogW2F2YWlsYWJsZSBxdWFsaXR5IGxldmVsc10sIGF1ZGlvVHJhY2tzIDogWyBhdmFpbGFibGUgYXVkaW8gdHJhY2tzXSwgdXJsIDogbWFuaWZlc3RVUkwsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbXRpbWV9fVxuICBNQU5JRkVTVF9MT0FERUQ6ICdobHNNYW5pZmVzdExvYWRlZCcsXG4gIC8vIGZpcmVkIGFmdGVyIG1hbmlmZXN0IGhhcyBiZWVuIHBhcnNlZCAtIGRhdGE6IHsgbGV2ZWxzIDogW2F2YWlsYWJsZSBxdWFsaXR5IGxldmVsc10sIGZpcnN0TGV2ZWwgOiBpbmRleCBvZiBmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiBNYW5pZmVzdH1cbiAgTUFOSUZFU1RfUEFSU0VEOiAnaGxzTWFuaWZlc3RQYXJzZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgc3dpdGNoIGlzIHJlcXVlc3RlZCAtIGRhdGE6IHsgbGV2ZWwgOiBpZCBvZiBuZXcgbGV2ZWwgfVxuICBMRVZFTF9TV0lUQ0hJTkc6ICdobHNMZXZlbFN3aXRjaGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBzd2l0Y2ggaXMgZWZmZWN0aXZlIC0gZGF0YTogeyBsZXZlbCA6IGlkIG9mIG5ldyBsZXZlbCB9XG4gIExFVkVMX1NXSVRDSEVEOiAnaGxzTGV2ZWxTd2l0Y2hlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBwbGF5bGlzdCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogbGV2ZWwgVVJMLCBsZXZlbCA6IGlkIG9mIGxldmVsIGJlaW5nIGxvYWRlZH1cbiAgTEVWRUxfTE9BRElORzogJ2hsc0xldmVsTG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBwbGF5bGlzdCBsb2FkaW5nIGZpbmlzaGVzIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiBsb2FkZWQgbGV2ZWwsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbXRpbWV9IH1cbiAgTEVWRUxfTE9BREVEOiAnaGxzTGV2ZWxMb2FkZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwncyBkZXRhaWxzIGhhdmUgYmVlbiB1cGRhdGVkIGJhc2VkIG9uIHByZXZpb3VzIGRldGFpbHMsIGFmdGVyIGl0IGhhcyBiZWVuIGxvYWRlZCAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgdXBkYXRlZCBsZXZlbCB9XG4gIExFVkVMX1VQREFURUQ6ICdobHNMZXZlbFVwZGF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwncyBQVFMgaW5mb3JtYXRpb24gaGFzIGJlZW4gdXBkYXRlZCBhZnRlciBwYXJzaW5nIGEgZnJhZ21lbnQgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIHVwZGF0ZWQgbGV2ZWwsIGRyaWZ0OiBQVFMgZHJpZnQgb2JzZXJ2ZWQgd2hlbiBwYXJzaW5nIGxhc3QgZnJhZ21lbnQgfVxuICBMRVZFTF9QVFNfVVBEQVRFRDogJ2hsc0xldmVsUHRzVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHRvIG5vdGlmeSB0aGF0IGF1ZGlvIHRyYWNrIGxpc3RzIGhhcyBiZWVuIHVwZGF0ZWQgLSBkYXRhOiB7IGF1ZGlvVHJhY2tzIDogYXVkaW9UcmFja3MgfVxuICBBVURJT19UUkFDS1NfVVBEQVRFRDogJ2hsc0F1ZGlvVHJhY2tzVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgc3dpdGNoaW5nIGlzIHJlcXVlc3RlZCAtIGRhdGE6IHsgaWQgOiBhdWRpbyB0cmFjayBpZCB9XG4gIEFVRElPX1RSQUNLX1NXSVRDSElORzogJ2hsc0F1ZGlvVHJhY2tTd2l0Y2hpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIHN3aXRjaCBhY3R1YWxseSBvY2N1cnMgLSBkYXRhOiB7IGlkIDogYXVkaW8gdHJhY2sgaWQgfVxuICBBVURJT19UUkFDS19TV0lUQ0hFRDogJ2hsc0F1ZGlvVHJhY2tTd2l0Y2hlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IGF1ZGlvIHRyYWNrIFVSTCwgaWQgOiBhdWRpbyB0cmFjayBpZCB9XG4gIEFVRElPX1RSQUNLX0xPQURJTkc6ICdobHNBdWRpb1RyYWNrTG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGlkIDogYXVkaW8gdHJhY2sgaWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbXRpbWUgfSB9XG4gIEFVRElPX1RSQUNLX0xPQURFRDogJ2hsc0F1ZGlvVHJhY2tMb2FkZWQnLFxuICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBzdWJ0aXRsZSB0cmFjayBsaXN0cyBoYXMgYmVlbiB1cGRhdGVkIC0gZGF0YTogeyBzdWJ0aXRsZVRyYWNrcyA6IHN1YnRpdGxlVHJhY2tzIH1cbiAgU1VCVElUTEVfVFJBQ0tTX1VQREFURUQ6ICdobHNTdWJ0aXRsZVRyYWNrc1VwZGF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGFuIHN1YnRpdGxlIHRyYWNrIHN3aXRjaCBvY2N1cnMgLSBkYXRhOiB7IGlkIDogc3VidGl0bGUgdHJhY2sgaWQgfVxuICBTVUJUSVRMRV9UUkFDS19TV0lUQ0g6ICdobHNTdWJ0aXRsZVRyYWNrU3dpdGNoJyxcbiAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIHRyYWNrIGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBzdWJ0aXRsZSB0cmFjayBVUkwsIGlkIDogc3VidGl0bGUgdHJhY2sgaWQgfVxuICBTVUJUSVRMRV9UUkFDS19MT0FESU5HOiAnaGxzU3VidGl0bGVUcmFja0xvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgc3VidGl0bGUgdHJhY2sgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGlkIDogc3VidGl0bGUgdHJhY2sgaWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbXRpbWUgfSB9XG4gIFNVQlRJVExFX1RSQUNLX0xPQURFRDogJ2hsc1N1YnRpdGxlVHJhY2tMb2FkZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgc3VidGl0bGUgZnJhZ21lbnQgaGFzIGJlZW4gcHJvY2Vzc2VkIC0gZGF0YTogeyBzdWNjZXNzIDogYm9vbGVhbiwgZnJhZyA6IHRoZSBwcm9jZXNzZWQgZnJhZyB9XG4gIFNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VEOiAnaGxzU3VidGl0bGVGcmFnUHJvY2Vzc2VkJyxcbiAgLy8gZmlyZWQgd2hlbiB0aGUgZmlyc3QgdGltZXN0YW1wIGlzIGZvdW5kIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGluaXRQVFM6IGluaXRQVFMsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICBJTklUX1BUU19GT1VORDogJ2hsc0luaXRQdHNGb3VuZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gIEZSQUdfTE9BRElORzogJ2hsc0ZyYWdMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgaXMgcHJvZ3Jlc3NpbmcgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHsgdHJlcXVlc3QsIHRmaXJzdCwgbG9hZGVkIH0gfVxuICBGUkFHX0xPQURfUFJPR1JFU1M6ICdobHNGcmFnTG9hZFByb2dyZXNzJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBhYm9ydGluZyBmb3IgZW1lcmdlbmN5IHN3aXRjaCBkb3duIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVEOiAnaGxzRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBwYXlsb2FkIDogZnJhZ21lbnQgcGF5bG9hZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBsZW5ndGggfSB9XG4gIEZSQUdfTE9BREVEOiAnaGxzRnJhZ0xvYWRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBoYXMgZmluaXNoZWQgZGVjcnlwdGluZyAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHBheWxvYWQgOiBmcmFnbWVudCBwYXlsb2FkLCBzdGF0cyA6IHsgdHN0YXJ0LCB0ZGVjcnlwdCB9IH1cbiAgRlJBR19ERUNSWVBURUQ6ICdobHNGcmFnRGVjcnlwdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBJbml0IFNlZ21lbnQgaGFzIGJlZW4gZXh0cmFjdGVkIGZyb20gZnJhZ21lbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBtb292IDogbW9vdiBNUDQgYm94LCBjb2RlY3MgOiBjb2RlY3MgZm91bmQgd2hpbGUgcGFyc2luZyBmcmFnbWVudCB9XG4gIEZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQ6ICdobHNGcmFnUGFyc2luZ0luaXRTZWdtZW50JyxcbiAgLy8gZmlyZWQgd2hlbiBwYXJzaW5nIHNlaSB0ZXh0IGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHNhbXBsZXMgOiBbIHNlaSBzYW1wbGVzIHBlcyBdIH1cbiAgRlJBR19QQVJTSU5HX1VTRVJEQVRBOiAnaGxzRnJhZ1BhcnNpbmdVc2VyZGF0YScsXG4gIC8vIGZpcmVkIHdoZW4gcGFyc2luZyBpZDMgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgc2FtcGxlcyA6IFsgaWQzIHNhbXBsZXMgcGVzIF0gfVxuICBGUkFHX1BBUlNJTkdfTUVUQURBVEE6ICdobHNGcmFnUGFyc2luZ01ldGFkYXRhJyxcbiAgLy8gZmlyZWQgd2hlbiBkYXRhIGhhdmUgYmVlbiBleHRyYWN0ZWQgZnJvbSBmcmFnbWVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIGRhdGExIDogbW9vZiBNUDQgYm94IG9yIFRTIGZyYWdtZW50cywgZGF0YTIgOiBtZGF0IE1QNCBib3ggb3IgbnVsbH1cbiAgRlJBR19QQVJTSU5HX0RBVEE6ICdobHNGcmFnUGFyc2luZ0RhdGEnLFxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHBhcnNpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCB9XG4gIEZSQUdfUEFSU0VEOiAnaGxzRnJhZ1BhcnNlZCcsXG4gIC8vIGZpcmVkIHdoZW4gZnJhZ21lbnQgcmVtdXhlZCBNUDQgYm94ZXMgaGF2ZSBhbGwgYmVlbiBhcHBlbmRlZCBpbnRvIFNvdXJjZUJ1ZmZlciAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIHRwYXJzZWQsIHRidWZmZXJlZCwgbGVuZ3RoLCBid0VzdGltYXRlIH0gfVxuICBGUkFHX0JVRkZFUkVEOiAnaGxzRnJhZ0J1ZmZlcmVkJyxcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCBtYXRjaGluZyB3aXRoIGN1cnJlbnQgbWVkaWEgcG9zaXRpb24gaXMgY2hhbmdpbmcgLSBkYXRhIDogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICBGUkFHX0NIQU5HRUQ6ICdobHNGcmFnQ2hhbmdlZCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgRlBTIGRyb3AgZXZlbnQgLSBkYXRhOiB7IGN1cmVudERyb3BwZWQsIGN1cnJlbnREZWNvZGVkLCB0b3RhbERyb3BwZWRGcmFtZXMgfVxuICBGUFNfRFJPUDogJ2hsc0Zwc0Ryb3AnLFxuICAvLyB0cmlnZ2VyZWQgd2hlbiBGUFMgZHJvcCB0cmlnZ2VycyBhdXRvIGxldmVsIGNhcHBpbmcgLSBkYXRhOiB7IGxldmVsLCBkcm9wcGVkbGV2ZWwgfVxuICBGUFNfRFJPUF9MRVZFTF9DQVBQSU5HOiAnaGxzRnBzRHJvcExldmVsQ2FwcGluZycsXG4gIC8vIElkZW50aWZpZXIgZm9yIGFuIGVycm9yIGV2ZW50IC0gZGF0YTogeyB0eXBlIDogZXJyb3IgdHlwZSwgZGV0YWlscyA6IGVycm9yIGRldGFpbHMsIGZhdGFsIDogaWYgdHJ1ZSwgaGxzLmpzIGNhbm5vdC93aWxsIG5vdCB0cnkgdG8gcmVjb3ZlciwgaWYgZmFsc2UsIGhscy5qcyB3aWxsIHRyeSB0byByZWNvdmVyLG90aGVyIGVycm9yIHNwZWNpZmljIGRhdGEgfVxuICBFUlJPUjogJ2hsc0Vycm9yJyxcbiAgLy8gZmlyZWQgd2hlbiBobHMuanMgaW5zdGFuY2Ugc3RhcnRzIGRlc3Ryb3lpbmcuIERpZmZlcmVudCBmcm9tIE1FRElBX0RFVEFDSEVEIGFzIG9uZSBjb3VsZCB3YW50IHRvIGRldGFjaCBhbmQgcmVhdHRhY2ggYSBtZWRpYSB0byB0aGUgaW5zdGFuY2Ugb2YgaGxzLmpzIHRvIGhhbmRsZSBtaWQtcm9sbHMgZm9yIGV4YW1wbGUgLSBkYXRhOiB7IH1cbiAgREVTVFJPWUlORzogJ2hsc0Rlc3Ryb3lpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgZGVjcnlwdCBrZXkgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICBLRVlfTE9BRElORzogJ2hsc0tleUxvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgZGVjcnlwdCBrZXkgbG9hZGluZyBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHBheWxvYWQgOiBrZXkgcGF5bG9hZCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCBsZW5ndGggfSB9XG4gIEtFWV9MT0FERUQ6ICdobHNLZXlMb2FkZWQnLFxuICAvLyBmaXJlZCB1cG9uIHN0cmVhbSBjb250cm9sbGVyIHN0YXRlIHRyYW5zaXRpb25zIC0gZGF0YTogeyBwcmV2aW91c1N0YXRlLCBuZXh0U3RhdGUgfVxuICBTVFJFQU1fU1RBVEVfVFJBTlNJVElPTjogJ2hsc1N0cmVhbVN0YXRlVHJhbnNpdGlvbidcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhsc0V2ZW50cztcbiIsImltcG9ydCAqIGFzIFVSTFRvb2xraXQgZnJvbSAndXJsLXRvb2xraXQnO1xuXG5pbXBvcnQge1xuICBFcnJvclR5cGVzLFxuICBFcnJvckRldGFpbHNcbn0gZnJvbSAnLi9lcnJvcnMnO1xuXG5pbXBvcnQgUGxheWxpc3RMb2FkZXIgZnJvbSAnLi9sb2FkZXIvcGxheWxpc3QtbG9hZGVyJztcbmltcG9ydCBGcmFnbWVudExvYWRlciBmcm9tICcuL2xvYWRlci9mcmFnbWVudC1sb2FkZXInO1xuaW1wb3J0IEtleUxvYWRlciBmcm9tICcuL2xvYWRlci9rZXktbG9hZGVyJztcblxuaW1wb3J0IHsgRnJhZ21lbnRUcmFja2VyIH0gZnJvbSAnLi9jb250cm9sbGVyL2ZyYWdtZW50LXRyYWNrZXInO1xuaW1wb3J0IFN0cmVhbUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCBMZXZlbENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2xldmVsLWNvbnRyb2xsZXInO1xuaW1wb3J0IElEM1RyYWNrQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvaWQzLXRyYWNrLWNvbnRyb2xsZXInO1xuXG5pbXBvcnQgeyBpc1N1cHBvcnRlZCB9IGZyb20gJy4vaXMtc3VwcG9ydGVkJztcbmltcG9ydCB7IGxvZ2dlciwgZW5hYmxlTG9ncyB9IGZyb20gJy4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IGhsc0RlZmF1bHRDb25maWcgfSBmcm9tICcuL2NvbmZpZyc7XG5cbmltcG9ydCBIbHNFdmVudHMgZnJvbSAnLi9ldmVudHMnO1xuXG5pbXBvcnQgeyBPYnNlcnZlciB9IGZyb20gJy4vb2JzZXJ2ZXInO1xuXG4vKipcbiAqIEBtb2R1bGUgSGxzXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIbHMgZXh0ZW5kcyBPYnNlcnZlciB7XG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCB2ZXJzaW9uICgpIHtcbiAgICByZXR1cm4gX19WRVJTSU9OX187XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNTdXBwb3J0ZWQgKCkge1xuICAgIHJldHVybiBpc1N1cHBvcnRlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtIbHNFdmVudHN9XG4gICAqL1xuICBzdGF0aWMgZ2V0IEV2ZW50cyAoKSB7XG4gICAgcmV0dXJuIEhsc0V2ZW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7SGxzRXJyb3JUeXBlc31cbiAgICovXG4gIHN0YXRpYyBnZXQgRXJyb3JUeXBlcyAoKSB7XG4gICAgcmV0dXJuIEVycm9yVHlwZXM7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0hsc0Vycm9yRGV0YWlsc31cbiAgICovXG4gIHN0YXRpYyBnZXQgRXJyb3JEZXRhaWxzICgpIHtcbiAgICByZXR1cm4gRXJyb3JEZXRhaWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtIbHNDb25maWd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERlZmF1bHRDb25maWcgKCkge1xuICAgIGlmICghSGxzLmRlZmF1bHRDb25maWcpIHtcbiAgICAgIHJldHVybiBobHNEZWZhdWx0Q29uZmlnO1xuICAgIH1cblxuICAgIHJldHVybiBIbHMuZGVmYXVsdENvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7SGxzQ29uZmlnfVxuICAgKi9cbiAgc3RhdGljIHNldCBEZWZhdWx0Q29uZmlnIChkZWZhdWx0Q29uZmlnKSB7XG4gICAgSGxzLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYW4gSExTIGNsaWVudCB0aGF0IGNhbiBhdHRhY2ggdG8gZXhhY3RseSBvbmUgYEhUTUxNZWRpYUVsZW1lbnRgLlxuICAgKlxuICAgKiBAY29uc3RydWN0cyBIbHNcbiAgICogQHBhcmFtIHtIbHNDb25maWd9IGNvbmZpZ1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSBIbHMuRGVmYXVsdENvbmZpZztcblxuICAgIGlmICgoY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50KSAmJiAoY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogZG9uXFwndCBtaXggdXAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50L2xpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCBhbmQgbGl2ZVN5bmNEdXJhdGlvbi9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uJyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgcHJvcCBpbiBkZWZhdWx0Q29uZmlnKSB7XG4gICAgICBpZiAocHJvcCBpbiBjb25maWcpIGNvbnRpbnVlO1xuICAgICAgY29uZmlnW3Byb3BdID0gZGVmYXVsdENvbmZpZ1twcm9wXTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgPD0gY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50XCIgbXVzdCBiZSBndCBcImxpdmVTeW5jRHVyYXRpb25Db3VudFwiJyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgJiYgKGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDw9IGNvbmZpZy5saXZlU3luY0R1cmF0aW9uIHx8IGNvbmZpZy5saXZlU3luY0R1cmF0aW9uID09PSB1bmRlZmluZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIgbXVzdCBiZSBndCBcImxpdmVTeW5jRHVyYXRpb25cIicpO1xuICAgIH1cblxuICAgIGVuYWJsZUxvZ3MoY29uZmlnLmRlYnVnKTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG5cbiAgICAvLyBjb3JlIGNvbnRyb2xsZXJzIGFuZCBuZXR3b3JrIGxvYWRlcnNcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0FickNvbnRyb2xsZXJ9IGFickNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBjb25zdCBhYnJDb250cm9sbGVyID0gdGhpcy5hYnJDb250cm9sbGVyID0gbmV3IGNvbmZpZy5hYnJDb250cm9sbGVyKHRoaXMpO1xuXG4gICAgY29uc3QgYnVmZmVyQ29udHJvbGxlciA9IG5ldyBjb25maWcuYnVmZmVyQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBjYXBMZXZlbENvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmNhcExldmVsQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBmcHNDb250cm9sbGVyID0gbmV3IGNvbmZpZy5mcHNDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IHBsYXlMaXN0TG9hZGVyID0gbmV3IFBsYXlsaXN0TG9hZGVyKHRoaXMpO1xuICAgIGNvbnN0IGZyYWdtZW50TG9hZGVyID0gbmV3IEZyYWdtZW50TG9hZGVyKHRoaXMpO1xuICAgIGNvbnN0IGtleUxvYWRlciA9IG5ldyBLZXlMb2FkZXIodGhpcyk7XG4gICAgY29uc3QgaWQzVHJhY2tDb250cm9sbGVyID0gbmV3IElEM1RyYWNrQ29udHJvbGxlcih0aGlzKTtcblxuICAgIC8vIG5ldHdvcmsgY29udHJvbGxlcnNcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0xldmVsQ29udHJvbGxlcn0gbGV2ZWxDb250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3QgbGV2ZWxDb250cm9sbGVyID0gdGhpcy5sZXZlbENvbnRyb2xsZXIgPSBuZXcgTGV2ZWxDb250cm9sbGVyKHRoaXMpO1xuXG4gICAgLy8gRklYTUU6IEZyYWdtZW50VHJhY2tlciBtdXN0IGJlIGRlZmluZWQgYmVmb3JlIFN0cmVhbUNvbnRyb2xsZXIgYmVjYXVzZSB0aGUgb3JkZXIgb2YgZXZlbnQgaGFuZGxpbmcgaXMgaW1wb3J0YW50XG4gICAgY29uc3QgZnJhZ21lbnRUcmFja2VyID0gbmV3IEZyYWdtZW50VHJhY2tlcih0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1N0cmVhbUNvbnRyb2xsZXJ9IHN0cmVhbUNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBjb25zdCBzdHJlYW1Db250cm9sbGVyID0gdGhpcy5zdHJlYW1Db250cm9sbGVyID0gbmV3IFN0cmVhbUNvbnRyb2xsZXIodGhpcywgZnJhZ21lbnRUcmFja2VyKTtcblxuICAgIGxldCBuZXR3b3JrQ29udHJvbGxlcnMgPSBbbGV2ZWxDb250cm9sbGVyLCBzdHJlYW1Db250cm9sbGVyXTtcblxuICAgIC8vIG9wdGlvbmFsIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyXG4gICAgLyoqXG4gICAgICogQHZhciB7SUNvcmVDb21wb25lbnQgfCBDb250cm9sbGVyfVxuICAgICAqL1xuICAgIGxldCBDb250cm9sbGVyID0gY29uZmlnLmF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcbiAgICBpZiAoQ29udHJvbGxlcikge1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnB1c2gobmV3IENvbnRyb2xsZXIodGhpcywgZnJhZ21lbnRUcmFja2VyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7SU5ldHdvcmtDb250cm9sbGVyW119IG5ldHdvcmtDb250cm9sbGVyc1xuICAgICAqL1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzID0gbmV0d29ya0NvbnRyb2xsZXJzO1xuXG4gICAgLyoqXG4gICAgICogQHZhciB7SUNvcmVDb21wb25lbnRbXX1cbiAgICAgKi9cbiAgICBjb25zdCBjb3JlQ29tcG9uZW50cyA9IFtcbiAgICAgIHBsYXlMaXN0TG9hZGVyLFxuICAgICAgZnJhZ21lbnRMb2FkZXIsXG4gICAgICBrZXlMb2FkZXIsXG4gICAgICBhYnJDb250cm9sbGVyLFxuICAgICAgYnVmZmVyQ29udHJvbGxlcixcbiAgICAgIGNhcExldmVsQ29udHJvbGxlcixcbiAgICAgIGZwc0NvbnRyb2xsZXIsXG4gICAgICBpZDNUcmFja0NvbnRyb2xsZXIsXG4gICAgICBmcmFnbWVudFRyYWNrZXJcbiAgICBdO1xuXG4gICAgLy8gb3B0aW9uYWwgYXVkaW8gdHJhY2sgYW5kIHN1YnRpdGxlIGNvbnRyb2xsZXJcbiAgICBDb250cm9sbGVyID0gY29uZmlnLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChDb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKHRoaXMpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge0F1ZGlvVHJhY2tDb250cm9sbGVyfSBhdWRpb1RyYWNrQ29udHJvbGxlclxuICAgICAgICovXG4gICAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgICBjb3JlQ29tcG9uZW50cy5wdXNoKGF1ZGlvVHJhY2tDb250cm9sbGVyKTtcbiAgICB9XG5cbiAgICBDb250cm9sbGVyID0gY29uZmlnLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChDb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKHRoaXMpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge1N1YnRpdGxlVHJhY2tDb250cm9sbGVyfSBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlclxuICAgICAgICovXG4gICAgICB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcik7XG4gICAgfVxuXG4gICAgQ29udHJvbGxlciA9IGNvbmZpZy5lbWVDb250cm9sbGVyO1xuICAgIGlmIChDb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBlbWVDb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIodGhpcyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7RU1FQ29udHJvbGxlcn0gZW1lQ29udHJvbGxlclxuICAgICAgICovXG4gICAgICB0aGlzLmVtZUNvbnRyb2xsZXIgPSBlbWVDb250cm9sbGVyO1xuICAgICAgY29yZUNvbXBvbmVudHMucHVzaChlbWVDb250cm9sbGVyKTtcbiAgICB9XG5cbiAgICAvLyBvcHRpb25hbCBzdWJ0aXRsZSBjb250cm9sbGVyc1xuICAgIENvbnRyb2xsZXIgPSBjb25maWcuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xuICAgIGlmIChDb250cm9sbGVyKSB7XG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChuZXcgQ29udHJvbGxlcih0aGlzLCBmcmFnbWVudFRyYWNrZXIpKTtcbiAgICB9XG4gICAgQ29udHJvbGxlciA9IGNvbmZpZy50aW1lbGluZUNvbnRyb2xsZXI7XG4gICAgaWYgKENvbnRyb2xsZXIpIHtcbiAgICAgIGNvcmVDb21wb25lbnRzLnB1c2gobmV3IENvbnRyb2xsZXIodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0lDb3JlQ29tcG9uZW50W119XG4gICAgICovXG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cyA9IGNvcmVDb21wb25lbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2Ugb2YgdGhlIGluc3RhbmNlXG4gICAqL1xuICBkZXN0cm95ICgpIHtcbiAgICBsb2dnZXIubG9nKCdkZXN0cm95Jyk7XG4gICAgdGhpcy50cmlnZ2VyKEhsc0V2ZW50cy5ERVNUUk9ZSU5HKTtcbiAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cy5jb25jYXQodGhpcy5uZXR3b3JrQ29udHJvbGxlcnMpLmZvckVhY2goY29tcG9uZW50ID0+IHtcbiAgICAgIGNvbXBvbmVudC5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgdGhpcy51cmwgPSBudWxsO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBhIG1lZGlhIGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYVxuICAgKi9cbiAgYXR0YWNoTWVkaWEgKG1lZGlhKSB7XG4gICAgbG9nZ2VyLmxvZygnYXR0YWNoTWVkaWEnKTtcbiAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgdGhpcy50cmlnZ2VyKEhsc0V2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHsgbWVkaWE6IG1lZGlhIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFjaCBmcm9tIHRoZSBtZWRpYVxuICAgKi9cbiAgZGV0YWNoTWVkaWEgKCkge1xuICAgIGxvZ2dlci5sb2coJ2RldGFjaE1lZGlhJyk7XG4gICAgdGhpcy50cmlnZ2VyKEhsc0V2ZW50cy5NRURJQV9ERVRBQ0hJTkcpO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIFVSTC4gQ2FuIGJlIHJlbGF0aXZlIG9yIGFic29sdXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqL1xuICBsb2FkU291cmNlICh1cmwpIHtcbiAgICB1cmwgPSBVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYsIHVybCwgeyBhbHdheXNOb3JtYWxpemU6IHRydWUgfSk7XG4gICAgbG9nZ2VyLmxvZyhgbG9hZFNvdXJjZToke3VybH1gKTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICAvLyB3aGVuIGF0dGFjaGluZyB0byBhIHNvdXJjZSBVUkwsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkXG4gICAgdGhpcy50cmlnZ2VyKEhsc0V2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB7IHVybDogdXJsIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGxvYWRpbmcgZGF0YSBmcm9tIHRoZSBzdHJlYW0gc291cmNlLlxuICAgKiBEZXBlbmRpbmcgb24gZGVmYXVsdCBjb25maWcsIGNsaWVudCBzdGFydHMgbG9hZGluZyBhdXRvbWF0aWNhbGx5IHdoZW4gYSBzb3VyY2UgaXMgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRQb3NpdGlvbiBTZXQgdGhlIHN0YXJ0IHBvc2l0aW9uIHRvIHN0cmVhbSBmcm9tXG4gICAqIEBkZWZhdWx0IC0xIE5vbmUgKGZyb20gZWFybGllc3QgcG9pbnQpXG4gICAqL1xuICBzdGFydExvYWQgKHN0YXJ0UG9zaXRpb24gPSAtMSkge1xuICAgIGxvZ2dlci5sb2coYHN0YXJ0TG9hZCgke3N0YXJ0UG9zaXRpb259KWApO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goY29udHJvbGxlciA9PiB7XG4gICAgICBjb250cm9sbGVyLnN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGxvYWRpbmcgb2YgYW55IHN0cmVhbSBkYXRhLlxuICAgKi9cbiAgc3RvcExvYWQgKCkge1xuICAgIGxvZ2dlci5sb2coJ3N0b3BMb2FkJyk7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaChjb250cm9sbGVyID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuc3RvcExvYWQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2FwIHRocm91Z2ggcG9zc2libGUgYXVkaW8gY29kZWNzIGluIHRoZSBzdHJlYW0gKGZvciBleGFtcGxlIHRvIHN3aXRjaCBmcm9tIHN0ZXJlbyB0byA1LjEpXG4gICAqL1xuICBzd2FwQXVkaW9Db2RlYyAoKSB7XG4gICAgbG9nZ2VyLmxvZygnc3dhcEF1ZGlvQ29kZWMnKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuc3dhcEF1ZGlvQ29kZWMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBtZWRpYS1lbGVtZW50IGZhaWxzLCB0aGlzIGFsbG93cyB0byBkZXRhY2ggYW5kIHRoZW4gcmUtYXR0YWNoIGl0XG4gICAqIGFzIG9uZSBjYWxsIChjb252ZW5pZW5jZSBtZXRob2QpLlxuICAgKlxuICAgKiBBdXRvbWF0aWMgcmVjb3Zlcnkgb2YgbWVkaWEtZXJyb3JzIGJ5IHRoaXMgcHJvY2VzcyBpcyBjb25maWd1cmFibGUuXG4gICAqL1xuICByZWNvdmVyTWVkaWFFcnJvciAoKSB7XG4gICAgbG9nZ2VyLmxvZygncmVjb3Zlck1lZGlhRXJyb3InKTtcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICB0aGlzLmF0dGFjaE1lZGlhKG1lZGlhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7UXVhbGl0eUxldmVsW119XG4gICAqL1xuICBnZXQgbGV2ZWxzICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHF1YWxpdHkgbGV2ZWwgY3VycmVudGx5IHBsYXllZFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRMZXZlbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5jdXJyZW50TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggaW1tZWRpYXRlbHkgLlxuICAgKiBUaGlzIHdpbGwgZmx1c2ggdGhlIGN1cnJlbnQgYnVmZmVyIHRvIHJlcGxhY2UgdGhlIHF1YWxpdHkgYXNhcC5cbiAgICogVGhhdCBtZWFucyBwbGF5YmFjayB3aWxsIGludGVycnVwdCBhdCBsZWFzdCBzaG9ydGx5IHRvIHJlLWJ1ZmZlciBhbmQgcmUtc3luYyBldmVudHVhbGx5LlxuICAgKiBAdHlwZSB7bnVtYmVyfSAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvblxuICAgKi9cbiAgc2V0IGN1cnJlbnRMZXZlbCAobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgY3VycmVudExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sb2FkTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuaW1tZWRpYXRlTGV2ZWxTd2l0Y2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRleCBvZiBuZXh0IHF1YWxpdHkgbGV2ZWwgbG9hZGVkIGFzIHNjaGVkdWxlZCBieSBzdHJlYW0gY29udHJvbGxlci5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBuZXh0TGV2ZWwgKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBxdWFsaXR5IGxldmVsIGluZGV4IGZvciBuZXh0IGxvYWRlZCBkYXRhLlxuICAgKiBUaGlzIHdpbGwgc3dpdGNoIHRoZSB2aWRlbyBxdWFsaXR5IGFzYXAsIHdpdGhvdXQgaW50ZXJydXB0aW5nIHBsYXliYWNrLlxuICAgKiBNYXkgYWJvcnQgY3VycmVudCBsb2FkaW5nIG9mIGRhdGEsIGFuZCBmbHVzaCBwYXJ0cyBvZiBidWZmZXIgKG91dHNpZGUgY3VycmVudGx5IHBsYXllZCBmcmFnbWVudCByZWdpb24pLlxuICAgKiBAdHlwZSB7bnVtYmVyfSAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvblxuICAgKi9cbiAgc2V0IG5leHRMZXZlbCAobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgbmV4dExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIHRoZSBjdXJyZW50bHkgb3IgbGFzdCAob2Ygbm9uZSBpcyBsb2FkZWQgY3VycmVudGx5KSBzZWdtZW50XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbG9hZExldmVsICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEgaW4gYSBjb25zZXJ2YXRpdmUgd2F5LlxuICAgKiBUaGlzIHdpbGwgc3dpdGNoIHRoZSBxdWFsaXR5IHdpdGhvdXQgZmx1c2hpbmcsIGJ1dCBpbnRlcnJ1cHQgY3VycmVudCBsb2FkaW5nLlxuICAgKiBUaHVzIHRoZSBtb21lbnQgd2hlbiB0aGUgcXVhbGl0eSBzd2l0Y2ggd2lsbCBhcHBlYXIgaW4gZWZmZWN0IHdpbGwgb25seSBiZSBhZnRlciB0aGUgYWxyZWFkeSBleGlzdGluZyBidWZmZXIuXG4gICAqIEB0eXBlIHtudW1iZXJ9IG5ld0xldmVsIC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uXG4gICAqL1xuICBzZXQgbG9hZExldmVsIChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBsb2FkTGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBuZXh0IHF1YWxpdHkgbGV2ZWwgbG9hZGVkXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbmV4dExvYWRMZXZlbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgb2YgbmV4dCBsb2FkZWQgc2VnbWVudCBpbiBhIGZ1bGx5IFwibm9uLWRlc3RydWN0aXZlXCIgd2F5LlxuICAgKiBTYW1lIGFzIGBsb2FkTGV2ZWxgIGJ1dCB3aWxsIHdhaXQgZm9yIG5leHQgc3dpdGNoICh1bnRpbCBjdXJyZW50IGxvYWRpbmcgaXMgZG9uZSkuXG4gICAqIEB0eXBlIHtudW1iZXJ9IGxldmVsXG4gICAqL1xuICBzZXQgbmV4dExvYWRMZXZlbCAobGV2ZWwpIHtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsID0gbGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIFwiZmlyc3QgbGV2ZWxcIjogbGlrZSBhIGRlZmF1bHQgbGV2ZWwsIGlmIG5vdCBzZXQsXG4gICAqIGZhbGxzIGJhY2sgdG8gaW5kZXggb2YgZmlyc3QgbGV2ZWwgcmVmZXJlbmNlZCBpbiBtYW5pZmVzdFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGZpcnN0TGV2ZWwgKCkge1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBcImZpcnN0LWxldmVsXCIsIHNlZSBnZXR0ZXIuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzZXQgZmlyc3RMZXZlbCAobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgZmlyc3RMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICogaWYgbm90IG92ZXJyaWRlZCBieSB1c2VyLCBmaXJzdCBsZXZlbCBhcHBlYXJpbmcgaW4gbWFuaWZlc3Qgd2lsbCBiZSB1c2VkIGFzIHN0YXJ0IGxldmVsXG4gICAqIGlmIC0xIDogYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiwgcGxheWJhY2sgd2lsbCBzdGFydCBmcm9tIGxldmVsIG1hdGNoaW5nIGRvd25sb2FkIGJhbmR3aWR0aFxuICAgKiAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc3RhcnRMZXZlbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogc2V0ICBzdGFydCBsZXZlbCAobGV2ZWwgb2YgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIHBsYXllZCBiYWNrKVxuICAgKiBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcbiAgICogaWYgLTEgOiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLCBwbGF5YmFjayB3aWxsIHN0YXJ0IGZyb20gbGV2ZWwgbWF0Y2hpbmcgZG93bmxvYWQgYmFuZHdpZHRoXG4gICAqIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgICogQHR5cGUge251bWJlcn0gbmV3TGV2ZWxcbiAgICovXG4gIHNldCBzdGFydExldmVsIChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBzdGFydExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgY29uc3QgaGxzID0gdGhpcztcbiAgICAvLyBpZiBub3QgaW4gYXV0b21hdGljIHN0YXJ0IGxldmVsIGRldGVjdGlvbiwgZW5zdXJlIHN0YXJ0TGV2ZWwgaXMgZ3JlYXRlciB0aGFuIG1pbkF1dG9MZXZlbFxuICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcbiAgICAgIG5ld0xldmVsID0gTWF0aC5tYXgobmV3TGV2ZWwsIGhscy5taW5BdXRvTGV2ZWwpO1xuICAgIH1cblxuICAgIGhscy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIENhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKGBBQlJDb250cm9sbGVyYClcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBhdXRvTGV2ZWxDYXBwaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b0xldmVsQ2FwcGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtIChgQUJSQ29udHJvbGxlcmApXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzZXQgYXV0b0xldmVsQ2FwcGluZyAobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgYXV0b0xldmVsQ2FwcGluZzoke25ld0xldmVsfWApO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcnVlIHdoZW4gYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBlbmFibGVkXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGF1dG9MZXZlbEVuYWJsZWQgKCkge1xuICAgIHJldHVybiAodGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPT09IC0xKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMZXZlbCBzZXQgbWFudWFsbHkgKGlmIGFueSlcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtYW51YWxMZXZlbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIG1pbiBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gY29uZmlnLm1pbkF1dG9CaXRyYXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWluQXV0b0xldmVsICgpIHtcbiAgICBsZXQgaGxzID0gdGhpcywgbGV2ZWxzID0gaGxzLmxldmVscywgbWluQXV0b0JpdHJhdGUgPSBobHMuY29uZmlnLm1pbkF1dG9CaXRyYXRlLCBsZW4gPSBsZXZlbHMgPyBsZXZlbHMubGVuZ3RoIDogMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBsZXZlbE5leHRCaXRyYXRlID0gbGV2ZWxzW2ldLnJlYWxCaXRyYXRlID8gTWF0aC5tYXgobGV2ZWxzW2ldLnJlYWxCaXRyYXRlLCBsZXZlbHNbaV0uYml0cmF0ZSkgOiBsZXZlbHNbaV0uYml0cmF0ZTtcbiAgICAgIGlmIChsZXZlbE5leHRCaXRyYXRlID4gbWluQXV0b0JpdHJhdGUpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIG1heCBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gYXV0b0xldmVsQ2FwcGluZ1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1heEF1dG9MZXZlbCAoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcztcbiAgICBjb25zdCBsZXZlbHMgPSBobHMubGV2ZWxzO1xuICAgIGNvbnN0IGF1dG9MZXZlbENhcHBpbmcgPSBobHMuYXV0b0xldmVsQ2FwcGluZztcbiAgICBsZXQgbWF4QXV0b0xldmVsO1xuICAgIGlmIChhdXRvTGV2ZWxDYXBwaW5nID09PSAtMSAmJiBsZXZlbHMgJiYgbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgbWF4QXV0b0xldmVsID0gbGV2ZWxzLmxlbmd0aCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heEF1dG9MZXZlbCA9IGF1dG9MZXZlbENhcHBpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heEF1dG9MZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBuZXh0IGF1dG9tYXRpY2FsbHkgc2VsZWN0ZWQgcXVhbGl0eSBsZXZlbFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG5leHRBdXRvTGV2ZWwgKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXM7XG4gICAgLy8gZW5zdXJlIG5leHQgYXV0byBsZXZlbCBpcyBiZXR3ZWVuICBtaW4gYW5kIG1heCBhdXRvIGxldmVsXG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGhscy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwsIGhscy5taW5BdXRvTGV2ZWwpLCBobHMubWF4QXV0b0xldmVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGlzIHNldHRlciBpcyB1c2VkIHRvIGZvcmNlIG5leHQgYXV0byBsZXZlbC5cbiAgICogdGhpcyBpcyB1c2VmdWwgdG8gZm9yY2UgYSBzd2l0Y2ggZG93biBpbiBhdXRvIG1vZGU6XG4gICAqIGluIGNhc2Ugb2YgbG9hZCBlcnJvciBvbiBsZXZlbCBOLCBobHMuanMgY2FuIHNldCBuZXh0QXV0b0xldmVsIHRvIE4tMSBmb3IgZXhhbXBsZSlcbiAgICogZm9yY2VkIHZhbHVlIGlzIHZhbGlkIGZvciBvbmUgZnJhZ21lbnQuIHVwb24gc3VjY2VzZnVsIGZyYWcgbG9hZGluZyBhdCBmb3JjZWQgbGV2ZWwsXG4gICAqIHRoaXMgdmFsdWUgd2lsbCBiZSByZXNldHRlZCB0byAtMSBieSBBQlIgY29udHJvbGxlci5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNldCBuZXh0QXV0b0xldmVsIChuZXh0TGV2ZWwpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzO1xuICAgIGhscy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwgPSBNYXRoLm1heChobHMubWluQXV0b0xldmVsLCBuZXh0TGV2ZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtBdWRpb1RyYWNrW119XG4gICAqL1xuICBnZXQgYXVkaW9UcmFja3MgKCkge1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gYXVkaW9UcmFja0NvbnRyb2xsZXIgPyBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrcyA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIGluZGV4IG9mIHRoZSBzZWxlY3RlZCBhdWRpbyB0cmFjayAoaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHMpXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgYXVkaW9UcmFjayAoKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgOiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZWxlY3RzIGFuIGF1ZGlvIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHNcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNldCBhdWRpb1RyYWNrIChhdWRpb1RyYWNrSWQpIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKGF1ZGlvVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrID0gYXVkaW9UcmFja0lkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U2Vjb25kc31cbiAgICovXG4gIGdldCBsaXZlU3luY1Bvc2l0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmxpdmVTeW5jUG9zaXRpb247XG4gIH1cblxuICAvKipcbiAgICogZ2V0IGFsdGVybmF0ZSBzdWJ0aXRsZSB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0XG4gICAqIEB0eXBlIHtTdWJ0aXRsZVRyYWNrW119XG4gICAqL1xuICBnZXQgc3VidGl0bGVUcmFja3MgKCkge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrcyA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc3VidGl0bGVUcmFjayAoKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgOiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZWxlY3QgYW4gc3VidGl0bGUgdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0c1xuICAgKiBAdHlwZXtudW1iZXJ9XG4gICAqL1xuICBzZXQgc3VidGl0bGVUcmFjayAoc3VidGl0bGVUcmFja0lkKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcikge1xuICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA9IHN1YnRpdGxlVHJhY2tJZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgc3VidGl0bGVEaXNwbGF5ICgpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVEaXNwbGF5IDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlL2Rpc2FibGUgc3VidGl0bGUgZGlzcGxheSByZW5kZXJpbmdcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzZXQgc3VidGl0bGVEaXNwbGF5ICh2YWx1ZSkge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICBpZiAoc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlRGlzcGxheSA9IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgZ2V0TWVkaWFTb3VyY2UgfSBmcm9tICcuL3V0aWxzL21lZGlhc291cmNlLWhlbHBlcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N1cHBvcnRlZCAoKSB7XG4gIGNvbnN0IG1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UoKTtcbiAgY29uc3Qgc291cmNlQnVmZmVyID0gd2luZG93LlNvdXJjZUJ1ZmZlciB8fCB3aW5kb3cuV2ViS2l0U291cmNlQnVmZmVyO1xuICBjb25zdCBpc1R5cGVTdXBwb3J0ZWQgPSBtZWRpYVNvdXJjZSAmJlxuICAgIHR5cGVvZiBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQgPT09ICdmdW5jdGlvbicgJiZcbiAgICBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS40MkUwMUUsbXA0YS40MC4yXCInKTtcblxuICAvLyBpZiBTb3VyY2VCdWZmZXIgaXMgZXhwb3NlZCBlbnN1cmUgaXRzIEFQSSBpcyB2YWxpZFxuICAvLyBzYWZhcmkgYW5kIG9sZCB2ZXJzaW9uIG9mIENocm9tZSBkb2Ugbm90IGV4cG9zZSBTb3VyY2VCdWZmZXIgZ2xvYmFsbHkgc28gY2hlY2tpbmcgU291cmNlQnVmZmVyLnByb3RvdHlwZSBpcyBpbXBvc3NpYmxlXG4gIGNvbnN0IHNvdXJjZUJ1ZmZlclZhbGlkQVBJID0gIXNvdXJjZUJ1ZmZlciB8fFxuICAgIChzb3VyY2VCdWZmZXIucHJvdG90eXBlICYmXG4gICAgICB0eXBlb2Ygc291cmNlQnVmZmVyLnByb3RvdHlwZS5hcHBlbmRCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBzb3VyY2VCdWZmZXIucHJvdG90eXBlLnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJyk7XG4gIHJldHVybiAhIWlzVHlwZVN1cHBvcnRlZCAmJiAhIXNvdXJjZUJ1ZmZlclZhbGlkQVBJO1xufVxuIiwiLypcbiAqIEZyYWdtZW50IExvYWRlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIEZyYWdtZW50TG9hZGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuRlJBR19MT0FESU5HKTtcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGxldCBsb2FkZXJzID0gdGhpcy5sb2FkZXJzO1xuICAgIGZvciAobGV0IGxvYWRlck5hbWUgaW4gbG9hZGVycykge1xuICAgICAgbGV0IGxvYWRlciA9IGxvYWRlcnNbbG9hZGVyTmFtZV07XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubG9hZGVycyA9IHt9O1xuXG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgb25GcmFnTG9hZGluZyAoZGF0YSkge1xuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICB0eXBlID0gZnJhZy50eXBlLFxuICAgICAgbG9hZGVycyA9IHRoaXMubG9hZGVycyxcbiAgICAgIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZyxcbiAgICAgIEZyYWdtZW50SUxvYWRlciA9IGNvbmZpZy5mTG9hZGVyLFxuICAgICAgRGVmYXVsdElMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuXG4gICAgLy8gcmVzZXQgZnJhZ21lbnQgc3RhdGVcbiAgICBmcmFnLmxvYWRlZCA9IDA7XG5cbiAgICBsZXQgbG9hZGVyID0gbG9hZGVyc1t0eXBlXTtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2dnZXIud2FybihgYWJvcnQgcHJldmlvdXMgZnJhZ21lbnQgbG9hZGVyIGZvciB0eXBlOiAke3R5cGV9YCk7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICBsb2FkZXIgPSBsb2FkZXJzW3R5cGVdID0gZnJhZy5sb2FkZXIgPVxuICAgICAgY29uZmlnLmZMb2FkZXIgPyBuZXcgRnJhZ21lbnRJTG9hZGVyKGNvbmZpZykgOiBuZXcgRGVmYXVsdElMb2FkZXIoY29uZmlnKTtcblxuICAgIGxldCBsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcztcblxuICAgIGxvYWRlckNvbnRleHQgPSB7IHVybDogZnJhZy51cmwsIGZyYWc6IGZyYWcsIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJywgcHJvZ3Jlc3NEYXRhOiBmYWxzZSB9O1xuXG4gICAgbGV0IHN0YXJ0ID0gZnJhZy5ieXRlUmFuZ2VTdGFydE9mZnNldCxcbiAgICAgIGVuZCA9IGZyYWcuYnl0ZVJhbmdlRW5kT2Zmc2V0O1xuXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShzdGFydCkgJiYgTnVtYmVyLmlzRmluaXRlKGVuZCkpIHtcbiAgICAgIGxvYWRlckNvbnRleHQucmFuZ2VTdGFydCA9IHN0YXJ0O1xuICAgICAgbG9hZGVyQ29udGV4dC5yYW5nZUVuZCA9IGVuZDtcbiAgICB9XG5cbiAgICBsb2FkZXJDb25maWcgPSB7XG4gICAgICB0aW1lb3V0OiBjb25maWcuZnJhZ0xvYWRpbmdUaW1lT3V0LFxuICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICByZXRyeURlbGF5OiAwLFxuICAgICAgbWF4UmV0cnlEZWxheTogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0XG4gICAgfTtcblxuICAgIGxvYWRlckNhbGxiYWNrcyA9IHtcbiAgICAgIG9uU3VjY2VzczogdGhpcy5sb2Fkc3VjY2Vzcy5iaW5kKHRoaXMpLFxuICAgICAgb25FcnJvcjogdGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSxcbiAgICAgIG9uVGltZW91dDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLFxuICAgICAgb25Qcm9ncmVzczogdGhpcy5sb2FkcHJvZ3Jlc3MuYmluZCh0aGlzKVxuICAgIH07XG5cbiAgICBsb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gIH1cblxuICBsb2Fkc3VjY2VzcyAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyA9IG51bGwpIHtcbiAgICBsZXQgcGF5bG9hZCA9IHJlc3BvbnNlLmRhdGEsIGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgLy8gZGV0YWNoIGZyYWdtZW50IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcbiAgICBmcmFnLmxvYWRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxvYWRlcnNbZnJhZy50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BREVELCB7IHBheWxvYWQ6IHBheWxvYWQsIGZyYWc6IGZyYWcsIHN0YXRzOiBzdGF0cywgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzIH0pO1xuICB9XG5cbiAgbG9hZGVycm9yIChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMgPSBudWxsKSB7XG4gICAgY29uc3QgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICBsZXQgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogY29udGV4dC5mcmFnLCByZXNwb25zZTogcmVzcG9uc2UsIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyB9KTtcbiAgfVxuXG4gIGxvYWR0aW1lb3V0IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMgPSBudWxsKSB7XG4gICAgY29uc3QgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICBsZXQgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVCwgZmF0YWw6IGZhbHNlLCBmcmFnOiBjb250ZXh0LmZyYWcsIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyB9KTtcbiAgfVxuXG4gIC8vIGRhdGEgd2lsbCBiZSB1c2VkIGZvciBwcm9ncmVzc2l2ZSBwYXJzaW5nXG4gIGxvYWRwcm9ncmVzcyAoc3RhdHMsIGNvbnRleHQsIGRhdGEsIG5ldHdvcmtEZXRhaWxzID0gbnVsbCkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBsZXQgZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICBmcmFnLmxvYWRlZCA9IHN0YXRzLmxvYWRlZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRF9QUk9HUkVTUywgeyBmcmFnOiBmcmFnLCBzdGF0czogc3RhdHMsIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGcmFnbWVudExvYWRlcjtcbiIsIlxuaW1wb3J0ICogYXMgVVJMVG9vbGtpdCBmcm9tICd1cmwtdG9vbGtpdCc7XG5cbmltcG9ydCBMZXZlbEtleSBmcm9tICcuL2xldmVsLWtleSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZyYWdtZW50IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgdGhpcy5fYnl0ZVJhbmdlID0gbnVsbDtcbiAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IG51bGw7XG4gICAgdGhpcy50YWdMaXN0ID0gW107XG4gICAgdGhpcy5wcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgIHRoaXMucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcblxuICAgIC8vIEhvbGRzIHRoZSB0eXBlcyBvZiBkYXRhIHRoaXMgZnJhZ21lbnQgc3VwcG9ydHNcbiAgICB0aGlzLl9lbGVtZW50YXJ5U3RyZWFtcyA9IHtcbiAgICAgIFtGcmFnbWVudC5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dOiBmYWxzZSxcbiAgICAgIFtGcmFnbWVudC5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9dOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogYHR5cGVgIHByb3BlcnR5IGZvciB0aGlzLl9lbGVtZW50YXJ5U3RyZWFtc1xuICAgKlxuICAgKiBAZW51bVxuICAgKi9cbiAgc3RhdGljIGdldCBFbGVtZW50YXJ5U3RyZWFtVHlwZXMgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBBVURJTzogJ2F1ZGlvJyxcbiAgICAgIFZJREVPOiAndmlkZW8nXG4gICAgfTtcbiAgfVxuXG4gIGdldCB1cmwgKCkge1xuICAgIGlmICghdGhpcy5fdXJsICYmIHRoaXMucmVsdXJsKSB7XG4gICAgICB0aGlzLl91cmwgPSBVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVVUkwodGhpcy5iYXNldXJsLCB0aGlzLnJlbHVybCwgeyBhbHdheXNOb3JtYWxpemU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgfVxuXG4gIHNldCB1cmwgKHZhbHVlKSB7XG4gICAgdGhpcy5fdXJsID0gdmFsdWU7XG4gIH1cblxuICBnZXQgYnl0ZVJhbmdlICgpIHtcbiAgICBpZiAoIXRoaXMuX2J5dGVSYW5nZSAmJiAhdGhpcy5yYXdCeXRlUmFuZ2UpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYnl0ZVJhbmdlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYnl0ZVJhbmdlO1xuICAgIH1cblxuICAgIGxldCBieXRlUmFuZ2UgPSBbXTtcbiAgICBpZiAodGhpcy5yYXdCeXRlUmFuZ2UpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMucmF3Qnl0ZVJhbmdlLnNwbGl0KCdAJywgMik7XG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBsYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0ID0gdGhpcy5sYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0O1xuICAgICAgICBieXRlUmFuZ2VbMF0gPSBsYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0IHx8IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBieXRlUmFuZ2VbMF0gPSBwYXJzZUludChwYXJhbXNbMV0pO1xuICAgICAgfVxuICAgICAgYnl0ZVJhbmdlWzFdID0gcGFyc2VJbnQocGFyYW1zWzBdKSArIGJ5dGVSYW5nZVswXTtcbiAgICAgIHRoaXMuX2J5dGVSYW5nZSA9IGJ5dGVSYW5nZTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVSYW5nZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGJ5dGVSYW5nZVN0YXJ0T2Zmc2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5ieXRlUmFuZ2VbMF07XG4gIH1cblxuICBnZXQgYnl0ZVJhbmdlRW5kT2Zmc2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5ieXRlUmFuZ2VbMV07XG4gIH1cblxuICBnZXQgZGVjcnlwdGRhdGEgKCkge1xuICAgIGlmICghdGhpcy5fZGVjcnlwdGRhdGEpIHtcbiAgICAgIHRoaXMuX2RlY3J5cHRkYXRhID0gdGhpcy5mcmFnbWVudERlY3J5cHRkYXRhRnJvbUxldmVsa2V5KHRoaXMubGV2ZWxrZXksIHRoaXMuc24pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9kZWNyeXB0ZGF0YTtcbiAgfVxuXG4gIGdldCBlbmRQcm9ncmFtRGF0ZVRpbWUgKCkge1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHRoaXMucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGR1cmF0aW9uID0gIU51bWJlci5pc0Zpbml0ZSh0aGlzLmR1cmF0aW9uKSA/IDAgOiB0aGlzLmR1cmF0aW9uO1xuXG4gICAgcmV0dXJuIHRoaXMucHJvZ3JhbURhdGVUaW1lICsgKGR1cmF0aW9uICogMTAwMCk7XG4gIH1cblxuICBnZXQgZW5jcnlwdGVkICgpIHtcbiAgICByZXR1cm4gISEoKHRoaXMuZGVjcnlwdGRhdGEgJiYgdGhpcy5kZWNyeXB0ZGF0YS51cmkgIT09IG51bGwpICYmICh0aGlzLmRlY3J5cHRkYXRhLmtleSA9PT0gbnVsbCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudGFyeVN0cmVhbVR5cGV9IHR5cGVcbiAgICovXG4gIGFkZEVsZW1lbnRhcnlTdHJlYW0gKHR5cGUpIHtcbiAgICB0aGlzLl9lbGVtZW50YXJ5U3RyZWFtc1t0eXBlXSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50YXJ5U3RyZWFtVHlwZX0gdHlwZVxuICAgKi9cbiAgaGFzRWxlbWVudGFyeVN0cmVhbSAodHlwZSkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50YXJ5U3RyZWFtc1t0eXBlXSA9PT0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IG1ldGhvZCBmb3IgcGFyc2VMZXZlbFBsYXlsaXN0IHRvIGNyZWF0ZSBhbiBpbml0aWFsaXphdGlvbiB2ZWN0b3IgZm9yIGEgZ2l2ZW4gc2VnbWVudFxuICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICovXG4gIGNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yIChzZWdtZW50TnVtYmVyKSB7XG4gICAgbGV0IHVpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KDE2KTtcblxuICAgIGZvciAobGV0IGkgPSAxMjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHVpbnQ4Vmlld1tpXSA9IChzZWdtZW50TnVtYmVyID4+IDggKiAoMTUgLSBpKSkgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiB1aW50OFZpZXc7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBtZXRob2QgZm9yIHBhcnNlTGV2ZWxQbGF5bGlzdCB0byBnZXQgYSBmcmFnbWVudCdzIGRlY3J5cHRpb24gZGF0YSBmcm9tIHRoZSBjdXJyZW50bHkgcGFyc2VkIGVuY3J5cHRpb24ga2V5IGRhdGFcbiAgICogQHBhcmFtIGxldmVsa2V5IC0gYSBwbGF5bGlzdCdzIGVuY3J5cHRpb24gaW5mb1xuICAgKiBAcGFyYW0gc2VnbWVudE51bWJlciAtIHRoZSBmcmFnbWVudCdzIHNlZ21lbnQgbnVtYmVyXG4gICAqIEByZXR1cm5zIHsqfSAtIGFuIG9iamVjdCB0byBiZSBhcHBsaWVkIGFzIGEgZnJhZ21lbnQncyBkZWNyeXB0ZGF0YVxuICAgKi9cbiAgZnJhZ21lbnREZWNyeXB0ZGF0YUZyb21MZXZlbGtleSAobGV2ZWxrZXksIHNlZ21lbnROdW1iZXIpIHtcbiAgICBsZXQgZGVjcnlwdGRhdGEgPSBsZXZlbGtleTtcblxuICAgIGlmIChsZXZlbGtleSAmJiBsZXZlbGtleS5tZXRob2QgJiYgbGV2ZWxrZXkudXJpICYmICFsZXZlbGtleS5pdikge1xuICAgICAgZGVjcnlwdGRhdGEgPSBuZXcgTGV2ZWxLZXkoKTtcbiAgICAgIGRlY3J5cHRkYXRhLm1ldGhvZCA9IGxldmVsa2V5Lm1ldGhvZDtcbiAgICAgIGRlY3J5cHRkYXRhLmJhc2V1cmkgPSBsZXZlbGtleS5iYXNldXJpO1xuICAgICAgZGVjcnlwdGRhdGEucmVsdXJpID0gbGV2ZWxrZXkucmVsdXJpO1xuICAgICAgZGVjcnlwdGRhdGEuaXYgPSB0aGlzLmNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNlZ21lbnROdW1iZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNyeXB0ZGF0YTtcbiAgfVxufVxuIiwiLypcbiAqIERlY3J5cHQga2V5IExvYWRlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIEtleUxvYWRlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsIEV2ZW50LktFWV9MT0FESU5HKTtcbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgICB0aGlzLmRlY3J5cHRrZXkgPSBudWxsO1xuICAgIHRoaXMuZGVjcnlwdHVybCA9IG51bGw7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBmb3IgKGxldCBsb2FkZXJOYW1lIGluIHRoaXMubG9hZGVycykge1xuICAgICAgbGV0IGxvYWRlciA9IHRoaXMubG9hZGVyc1tsb2FkZXJOYW1lXTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2FkZXJzID0ge307XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbktleUxvYWRpbmcgKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgIHR5cGUgPSBmcmFnLnR5cGUsXG4gICAgICBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbdHlwZV0sXG4gICAgICBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGEsXG4gICAgICB1cmkgPSBkZWNyeXB0ZGF0YS51cmk7XG4gICAgLy8gaWYgdXJpIGlzIGRpZmZlcmVudCBmcm9tIHByZXZpb3VzIG9uZSBvciBpZiBkZWNyeXB0IGtleSBub3QgcmV0cmlldmVkIHlldFxuICAgIGlmICh1cmkgIT09IHRoaXMuZGVjcnlwdHVybCB8fCB0aGlzLmRlY3J5cHRrZXkgPT09IG51bGwpIHtcbiAgICAgIGxldCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYGFib3J0IHByZXZpb3VzIGtleSBsb2FkZXIgZm9yIHR5cGU6JHt0eXBlfWApO1xuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIGZyYWcubG9hZGVyID0gdGhpcy5sb2FkZXJzW3R5cGVdID0gbmV3IGNvbmZpZy5sb2FkZXIoY29uZmlnKTtcbiAgICAgIHRoaXMuZGVjcnlwdHVybCA9IHVyaTtcbiAgICAgIHRoaXMuZGVjcnlwdGtleSA9IG51bGw7XG5cbiAgICAgIGxldCBsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcztcbiAgICAgIGxvYWRlckNvbnRleHQgPSB7IHVybDogdXJpLCBmcmFnOiBmcmFnLCByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicgfTtcbiAgICAgIC8vIG1heFJldHJ5IGlzIDAgc28gdGhhdCBpbnN0ZWFkIG9mIHJldHJ5aW5nIHRoZSBzYW1lIGtleSBvbiB0aGUgc2FtZSB2YXJpYW50IG11bHRpcGxlIHRpbWVzLFxuICAgICAgLy8ga2V5LWxvYWRlciB3aWxsIHRyaWdnZXIgYW4gZXJyb3IgYW5kIHJlbHkgb24gc3RyZWFtLWNvbnRyb2xsZXIgdG8gaGFuZGxlIHJldHJ5IGxvZ2ljLlxuICAgICAgLy8gdGhpcyB3aWxsIGFsc28gYWxpZ24gcmV0cnkgbG9naWMgd2l0aCBmcmFnbWVudC1sb2FkZXJcbiAgICAgIGxvYWRlckNvbmZpZyA9IHsgdGltZW91dDogY29uZmlnLmZyYWdMb2FkaW5nVGltZU91dCwgbWF4UmV0cnk6IDAsIHJldHJ5RGVsYXk6IGNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksIG1heFJldHJ5RGVsYXk6IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCB9O1xuICAgICAgbG9hZGVyQ2FsbGJhY2tzID0geyBvblN1Y2Nlc3M6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSwgb25FcnJvcjogdGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSwgb25UaW1lb3V0OiB0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcykgfTtcbiAgICAgIGZyYWcubG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kZWNyeXB0a2V5KSB7XG4gICAgICAvLyB3ZSBhbHJlYWR5IGxvYWRlZCB0aGlzIGtleSwgcmV0dXJuIGl0XG4gICAgICBkZWNyeXB0ZGF0YS5rZXkgPSB0aGlzLmRlY3J5cHRrZXk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FERUQsIHsgZnJhZzogZnJhZyB9KTtcbiAgICB9XG4gIH1cblxuICBsb2Fkc3VjY2VzcyAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0KSB7XG4gICAgbGV0IGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgdGhpcy5kZWNyeXB0a2V5ID0gZnJhZy5kZWNyeXB0ZGF0YS5rZXkgPSBuZXcgVWludDhBcnJheShyZXNwb25zZS5kYXRhKTtcbiAgICAvLyBkZXRhY2ggZnJhZ21lbnQgbG9hZGVyIG9uIGxvYWQgc3VjY2Vzc1xuICAgIGZyYWcubG9hZGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubG9hZGVyc1tmcmFnLnR5cGVdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuS0VZX0xPQURFRCwgeyBmcmFnOiBmcmFnIH0pO1xuICB9XG5cbiAgbG9hZGVycm9yIChyZXNwb25zZSwgY29udGV4dCkge1xuICAgIGxldCBmcmFnID0gY29udGV4dC5mcmFnLFxuICAgICAgbG9hZGVyID0gZnJhZy5sb2FkZXI7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgZmF0YWw6IGZhbHNlLCBmcmFnOiBmcmFnLCByZXNwb25zZTogcmVzcG9uc2UgfSk7XG4gIH1cblxuICBsb2FkdGltZW91dCAoc3RhdHMsIGNvbnRleHQpIHtcbiAgICBsZXQgZnJhZyA9IGNvbnRleHQuZnJhZyxcbiAgICAgIGxvYWRlciA9IGZyYWcubG9hZGVyO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVCwgZmF0YWw6IGZhbHNlLCBmcmFnOiBmcmFnIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEtleUxvYWRlcjtcbiIsImltcG9ydCAqIGFzIFVSTFRvb2xraXQgZnJvbSAndXJsLXRvb2xraXQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZXZlbEtleSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLm1ldGhvZCA9IG51bGw7XG4gICAgdGhpcy5rZXkgPSBudWxsO1xuICAgIHRoaXMuaXYgPSBudWxsO1xuICAgIHRoaXMuX3VyaSA9IG51bGw7XG4gIH1cblxuICBnZXQgdXJpICgpIHtcbiAgICBpZiAoIXRoaXMuX3VyaSAmJiB0aGlzLnJlbHVyaSkge1xuICAgICAgdGhpcy5fdXJpID0gVVJMVG9vbGtpdC5idWlsZEFic29sdXRlVVJMKHRoaXMuYmFzZXVyaSwgdGhpcy5yZWx1cmksIHsgYWx3YXlzTm9ybWFsaXplOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl91cmk7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIExldmVsIHtcbiAgY29uc3RydWN0b3IgKGJhc2VVcmwpIHtcbiAgICAvLyBQbGVhc2Uga2VlcCBwcm9wZXJ0aWVzIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICAgIHRoaXMuZW5kQ0MgPSAwO1xuICAgIHRoaXMuZW5kU04gPSAwO1xuICAgIHRoaXMuZnJhZ21lbnRzID0gW107XG4gICAgdGhpcy5pbml0U2VnbWVudCA9IG51bGw7XG4gICAgdGhpcy5saXZlID0gdHJ1ZTtcbiAgICB0aGlzLm5lZWRTaWR4UmFuZ2VzID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydENDID0gMDtcbiAgICB0aGlzLnN0YXJ0U04gPSAwO1xuICAgIHRoaXMuc3RhcnRUaW1lT2Zmc2V0ID0gbnVsbDtcbiAgICB0aGlzLnRhcmdldGR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnRvdGFsZHVyYXRpb24gPSAwO1xuICAgIHRoaXMudHlwZSA9IG51bGw7XG4gICAgdGhpcy51cmwgPSBiYXNlVXJsO1xuICAgIHRoaXMudmVyc2lvbiA9IG51bGw7XG4gIH1cblxuICBnZXQgaGFzUHJvZ3JhbURhdGVUaW1lICgpIHtcbiAgICByZXR1cm4gISEodGhpcy5mcmFnbWVudHNbMF0gJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMuZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZSkpO1xuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBVUkxUb29sa2l0IGZyb20gJ3VybC10b29sa2l0JztcblxuaW1wb3J0IEZyYWdtZW50IGZyb20gJy4vZnJhZ21lbnQnO1xuaW1wb3J0IExldmVsIGZyb20gJy4vbGV2ZWwnO1xuaW1wb3J0IExldmVsS2V5IGZyb20gJy4vbGV2ZWwta2V5JztcblxuaW1wb3J0IEF0dHJMaXN0IGZyb20gJy4uL3V0aWxzL2F0dHItbGlzdCc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgaXNDb2RlY1R5cGUgfSBmcm9tICcuLi91dGlscy9jb2RlY3MnO1xuXG4vKipcbiAqIE0zVTggcGFyc2VyXG4gKiBAbW9kdWxlXG4gKi9cblxuLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20gaXMgeW91ciBmcmllbmRcbmNvbnN0IE1BU1RFUl9QTEFZTElTVF9SRUdFWCA9IC8jRVhULVgtU1RSRUFNLUlORjooW15cXG5cXHJdKilbXFxyXFxuXSsoW15cXHJcXG5dKykvZztcbmNvbnN0IE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWCA9IC8jRVhULVgtTUVESUE6KC4qKS9nO1xuXG5jb25zdCBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNUID0gbmV3IFJlZ0V4cChbXG4gIC8jRVhUSU5GOlxccyooXFxkKig/OlxcLlxcZCspPykoPzosKC4qKVxccyspPy8uc291cmNlLCAvLyBkdXJhdGlvbiAoI0VYVElORjo8ZHVyYXRpb24+LDx0aXRsZT4pLCBncm91cCAxID0+IGR1cmF0aW9uLCBncm91cCAyID0+IHRpdGxlXG4gIC98KD8hIykoW1xcUysgP10rKS8uc291cmNlLCAvLyBzZWdtZW50IFVSSSwgZ3JvdXAgMyA9PiB0aGUgVVJJIChub3RlIG5ld2xpbmUgaXMgbm90IGVhdGVuKVxuICAvfCNFWFQtWC1CWVRFUkFOR0U6KiguKykvLnNvdXJjZSwgLy8gbmV4dCBzZWdtZW50J3MgYnl0ZXJhbmdlLCBncm91cCA0ID0+IHJhbmdlIHNwZWMgKHhAeSlcbiAgL3wjRVhULVgtUFJPR1JBTS1EQVRFLVRJTUU6KC4rKS8uc291cmNlLCAvLyBuZXh0IHNlZ21lbnQncyBwcm9ncmFtIGRhdGUvdGltZSBncm91cCA1ID0+IHRoZSBkYXRldGltZSBzcGVjXG4gIC98Iy4qLy5zb3VyY2UgLy8gQWxsIG90aGVyIG5vbi1zZWdtZW50IG9yaWVudGVkIHRhZ3Mgd2lsbCBtYXRjaCB3aXRoIGFsbCBncm91cHMgZW1wdHlcbl0uam9pbignJyksICdnJyk7XG5cbmNvbnN0IExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cgPSAvKD86KD86IyhFWFRNM1UpKXwoPzojRVhULVgtKFBMQVlMSVNULVRZUEUpOiguKykpfCg/OiNFWFQtWC0oTUVESUEtU0VRVUVOQ0UpOiAqKFxcZCspKXwoPzojRVhULVgtKFRBUkdFVERVUkFUSU9OKTogKihcXGQrKSl8KD86I0VYVC1YLShLRVkpOiguKykpfCg/OiNFWFQtWC0oU1RBUlQpOiguKykpfCg/OiNFWFQtWC0oRU5ETElTVCkpfCg/OiNFWFQtWC0oRElTQ09OVElOVUlUWS1TRVEpVUVOQ0U6KFxcZCspKXwoPzojRVhULVgtKERJUylDT05USU5VSVRZKSl8KD86I0VYVC1YLShWRVJTSU9OKTooXFxkKykpfCg/OiNFWFQtWC0oTUFQKTooLispKXwoPzooIykoW146XSopOiguKikpfCg/OigjKSguKikpKD86LiopXFxyP1xcbj8vO1xuXG5jb25zdCBNUDRfUkVHRVhfU1VGRklYID0gL1xcLihtcDR8bTRzfG00dnxtNGEpJC9pO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNM1U4UGFyc2VyIHtcbiAgc3RhdGljIGZpbmRHcm91cCAoZ3JvdXBzLCBtZWRpYUdyb3VwSWQpIHtcbiAgICBpZiAoIWdyb3Vwcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IG1hdGNoaW5nR3JvdXAgPSBudWxsO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgaWYgKGdyb3VwLmlkID09PSBtZWRpYUdyb3VwSWQpIHtcbiAgICAgICAgbWF0Y2hpbmdHcm91cCA9IGdyb3VwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGluZ0dyb3VwO1xuICB9XG5cbiAgc3RhdGljIGNvbnZlcnRBVkMxVG9BVkNPVEkgKGNvZGVjKSB7XG4gICAgbGV0IHJlc3VsdCwgYXZjZGF0YSA9IGNvZGVjLnNwbGl0KCcuJyk7XG4gICAgaWYgKGF2Y2RhdGEubGVuZ3RoID4gMikge1xuICAgICAgcmVzdWx0ID0gYXZjZGF0YS5zaGlmdCgpICsgJy4nO1xuICAgICAgcmVzdWx0ICs9IHBhcnNlSW50KGF2Y2RhdGEuc2hpZnQoKSkudG9TdHJpbmcoMTYpO1xuICAgICAgcmVzdWx0ICs9ICgnMDAwJyArIHBhcnNlSW50KGF2Y2RhdGEuc2hpZnQoKSkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBjb2RlYztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHN0YXRpYyByZXNvbHZlICh1cmwsIGJhc2VVcmwpIHtcbiAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZEFic29sdXRlVVJMKGJhc2VVcmwsIHVybCwgeyBhbHdheXNOb3JtYWxpemU6IHRydWUgfSk7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VNYXN0ZXJQbGF5bGlzdCAoc3RyaW5nLCBiYXNldXJsKSB7XG4gICAgbGV0IGxldmVscyA9IFtdLCByZXN1bHQ7XG4gICAgTUFTVEVSX1BMQVlMSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG5cbiAgICBmdW5jdGlvbiBzZXRDb2RlY3MgKGNvZGVjcywgbGV2ZWwpIHtcbiAgICAgIFsndmlkZW8nLCAnYXVkaW8nXS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0gY29kZWNzLmZpbHRlcigoY29kZWMpID0+IGlzQ29kZWNUeXBlKGNvZGVjLCB0eXBlKSk7XG4gICAgICAgIGlmIChmaWx0ZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBwcmVmZXJyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoKGNvZGVjKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY29kZWMubGFzdEluZGV4T2YoJ2F2YzEnLCAwKSA9PT0gMCB8fCBjb2RlYy5sYXN0SW5kZXhPZignbXA0YScsIDApID09PSAwO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxldmVsW2Ake3R5cGV9Q29kZWNgXSA9IHByZWZlcnJlZC5sZW5ndGggPiAwID8gcHJlZmVycmVkWzBdIDogZmlsdGVyZWRbMF07XG5cbiAgICAgICAgICAvLyByZW1vdmUgZnJvbSBsaXN0XG4gICAgICAgICAgY29kZWNzID0gY29kZWNzLmZpbHRlcigoY29kZWMpID0+IGZpbHRlcmVkLmluZGV4T2YoY29kZWMpID09PSAtMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBsZXZlbC51bmtub3duQ29kZWNzID0gY29kZWNzO1xuICAgIH1cblxuICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT0gbnVsbCkge1xuICAgICAgY29uc3QgbGV2ZWwgPSB7fTtcblxuICAgICAgY29uc3QgYXR0cnMgPSBsZXZlbC5hdHRycyA9IG5ldyBBdHRyTGlzdChyZXN1bHRbMV0pO1xuICAgICAgbGV2ZWwudXJsID0gTTNVOFBhcnNlci5yZXNvbHZlKHJlc3VsdFsyXSwgYmFzZXVybCk7XG5cbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSBhdHRycy5kZWNpbWFsUmVzb2x1dGlvbignUkVTT0xVVElPTicpO1xuICAgICAgaWYgKHJlc29sdXRpb24pIHtcbiAgICAgICAgbGV2ZWwud2lkdGggPSByZXNvbHV0aW9uLndpZHRoO1xuICAgICAgICBsZXZlbC5oZWlnaHQgPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGxldmVsLmJpdHJhdGUgPSBhdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKSB8fCBhdHRycy5kZWNpbWFsSW50ZWdlcignQkFORFdJRFRIJyk7XG4gICAgICBsZXZlbC5uYW1lID0gYXR0cnMuTkFNRTtcblxuICAgICAgc2V0Q29kZWNzKFtdLmNvbmNhdCgoYXR0cnMuQ09ERUNTIHx8ICcnKS5zcGxpdCgvWyAsXSsvKSksIGxldmVsKTtcblxuICAgICAgaWYgKGxldmVsLnZpZGVvQ29kZWMgJiYgbGV2ZWwudmlkZW9Db2RlYy5pbmRleE9mKCdhdmMxJykgIT09IC0xKSB7XG4gICAgICAgIGxldmVsLnZpZGVvQ29kZWMgPSBNM1U4UGFyc2VyLmNvbnZlcnRBVkMxVG9BVkNPVEkobGV2ZWwudmlkZW9Db2RlYyk7XG4gICAgICB9XG5cbiAgICAgIGxldmVscy5wdXNoKGxldmVsKTtcbiAgICB9XG4gICAgcmV0dXJuIGxldmVscztcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEgKHN0cmluZywgYmFzZXVybCwgdHlwZSwgYXVkaW9Hcm91cHMgPSBbXSkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IG1lZGlhcyA9IFtdO1xuICAgIGxldCBpZCA9IDA7XG4gICAgTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVguZXhlYyhzdHJpbmcpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgbWVkaWEgPSB7fTtcbiAgICAgIGNvbnN0IGF0dHJzID0gbmV3IEF0dHJMaXN0KHJlc3VsdFsxXSk7XG4gICAgICBpZiAoYXR0cnMuVFlQRSA9PT0gdHlwZSkge1xuICAgICAgICBtZWRpYS5ncm91cElkID0gYXR0cnNbJ0dST1VQLUlEJ107XG4gICAgICAgIG1lZGlhLm5hbWUgPSBhdHRycy5OQU1FO1xuICAgICAgICBtZWRpYS50eXBlID0gdHlwZTtcbiAgICAgICAgbWVkaWEuZGVmYXVsdCA9IChhdHRycy5ERUZBVUxUID09PSAnWUVTJyk7XG4gICAgICAgIG1lZGlhLmF1dG9zZWxlY3QgPSAoYXR0cnMuQVVUT1NFTEVDVCA9PT0gJ1lFUycpO1xuICAgICAgICBtZWRpYS5mb3JjZWQgPSAoYXR0cnMuRk9SQ0VEID09PSAnWUVTJyk7XG4gICAgICAgIGlmIChhdHRycy5VUkkpIHtcbiAgICAgICAgICBtZWRpYS51cmwgPSBNM1U4UGFyc2VyLnJlc29sdmUoYXR0cnMuVVJJLCBiYXNldXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lZGlhLmxhbmcgPSBhdHRycy5MQU5HVUFHRTtcbiAgICAgICAgaWYgKCFtZWRpYS5uYW1lKSB7XG4gICAgICAgICAgbWVkaWEubmFtZSA9IG1lZGlhLmxhbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXVkaW9Hcm91cHMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZ3JvdXBDb2RlYyA9IE0zVThQYXJzZXIuZmluZEdyb3VwKGF1ZGlvR3JvdXBzLCBtZWRpYS5ncm91cElkKTtcbiAgICAgICAgICBtZWRpYS5hdWRpb0NvZGVjID0gZ3JvdXBDb2RlYyA/IGdyb3VwQ29kZWMuY29kZWMgOiBhdWRpb0dyb3Vwc1swXS5jb2RlYztcbiAgICAgICAgfVxuICAgICAgICBtZWRpYS5pZCA9IGlkKys7XG4gICAgICAgIG1lZGlhcy5wdXNoKG1lZGlhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lZGlhcztcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZUxldmVsUGxheWxpc3QgKHN0cmluZywgYmFzZXVybCwgaWQsIHR5cGUsIGxldmVsVXJsSWQpIHtcbiAgICBsZXQgY3VycmVudFNOID0gMDtcbiAgICBsZXQgdG90YWxkdXJhdGlvbiA9IDA7XG4gICAgbGV0IGxldmVsID0gbmV3IExldmVsKGJhc2V1cmwpO1xuICAgIGxldCBsZXZlbGtleSA9IG5ldyBMZXZlbEtleSgpO1xuICAgIGxldCBjYyA9IDA7XG4gICAgbGV0IHByZXZGcmFnID0gbnVsbDtcbiAgICBsZXQgZnJhZyA9IG5ldyBGcmFnbWVudCgpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGk7XG5cbiAgICBsZXQgZmlyc3RQZHRJbmRleCA9IG51bGw7XG5cbiAgICBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmxhc3RJbmRleCA9IDA7XG5cbiAgICB3aGlsZSAoKHJlc3VsdCA9IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QuZXhlYyhzdHJpbmcpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSByZXN1bHRbMV07XG4gICAgICBpZiAoZHVyYXRpb24pIHsgLy8gSU5GXG4gICAgICAgIGZyYWcuZHVyYXRpb24gPSBwYXJzZUZsb2F0KGR1cmF0aW9uKTtcbiAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICBjb25zdCB0aXRsZSA9ICgnICcgKyByZXN1bHRbMl0pLnNsaWNlKDEpO1xuICAgICAgICBmcmFnLnRpdGxlID0gdGl0bGUgfHwgbnVsbDtcbiAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godGl0bGUgPyBbICdJTkYnLCBkdXJhdGlvbiwgdGl0bGUgXSA6IFsgJ0lORicsIGR1cmF0aW9uIF0pO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbM10pIHsgLy8gdXJsXG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZnJhZy5kdXJhdGlvbikpIHtcbiAgICAgICAgICBjb25zdCBzbiA9IGN1cnJlbnRTTisrO1xuICAgICAgICAgIGZyYWcudHlwZSA9IHR5cGU7XG4gICAgICAgICAgZnJhZy5zdGFydCA9IHRvdGFsZHVyYXRpb247XG4gICAgICAgICAgZnJhZy5sZXZlbGtleSA9IGxldmVsa2V5O1xuICAgICAgICAgIGZyYWcuc24gPSBzbjtcbiAgICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgICAgZnJhZy5jYyA9IGNjO1xuICAgICAgICAgIGZyYWcudXJsSWQgPSBsZXZlbFVybElkO1xuICAgICAgICAgIGZyYWcuYmFzZXVybCA9IGJhc2V1cmw7XG4gICAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICAgIGZyYWcucmVsdXJsID0gKCcgJyArIHJlc3VsdFszXSkuc2xpY2UoMSk7XG4gICAgICAgICAgYXNzaWduUHJvZ3JhbURhdGVUaW1lKGZyYWcsIHByZXZGcmFnKTtcblxuICAgICAgICAgIGxldmVsLmZyYWdtZW50cy5wdXNoKGZyYWcpO1xuICAgICAgICAgIHByZXZGcmFnID0gZnJhZztcbiAgICAgICAgICB0b3RhbGR1cmF0aW9uICs9IGZyYWcuZHVyYXRpb247XG5cbiAgICAgICAgICBmcmFnID0gbmV3IEZyYWdtZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzRdKSB7IC8vIFgtQllURVJBTkdFXG4gICAgICAgIGZyYWcucmF3Qnl0ZVJhbmdlID0gKCcgJyArIHJlc3VsdFs0XSkuc2xpY2UoMSk7XG4gICAgICAgIGlmIChwcmV2RnJhZykge1xuICAgICAgICAgIGNvbnN0IGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgPSBwcmV2RnJhZy5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgaWYgKGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQpIHtcbiAgICAgICAgICAgIGZyYWcubGFzdEJ5dGVSYW5nZUVuZE9mZnNldCA9IGxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFs1XSkgeyAvLyBQUk9HUkFNLURBVEUtVElNRVxuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gKCcgJyArIHJlc3VsdFs1XSkuc2xpY2UoMSk7XG4gICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnUFJPR1JBTS1EQVRFLVRJTUUnLCBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZV0pO1xuICAgICAgICBpZiAoZmlyc3RQZHRJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgIGZpcnN0UGR0SW5kZXggPSBsZXZlbC5mcmFnbWVudHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRbMF0ubWF0Y2goTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocmVzdWx0W2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgY29uc3QgdmFsdWUxID0gKCcgJyArIHJlc3VsdFtpICsgMV0pLnNsaWNlKDEpO1xuICAgICAgICBjb25zdCB2YWx1ZTIgPSAoJyAnICsgcmVzdWx0W2kgKyAyXSkuc2xpY2UoMSk7XG5cbiAgICAgICAgc3dpdGNoIChyZXN1bHRbaV0pIHtcbiAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godmFsdWUyID8gWyB2YWx1ZTEsIHZhbHVlMiBdIDogWyB2YWx1ZTEgXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1BMQVlMSVNULVRZUEUnOlxuICAgICAgICAgIGxldmVsLnR5cGUgPSB2YWx1ZTEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTUVESUEtU0VRVUVOQ0UnOlxuICAgICAgICAgIGN1cnJlbnRTTiA9IGxldmVsLnN0YXJ0U04gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdUQVJHRVREVVJBVElPTic6XG4gICAgICAgICAgbGV2ZWwudGFyZ2V0ZHVyYXRpb24gPSBwYXJzZUZsb2F0KHZhbHVlMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1ZFUlNJT04nOlxuICAgICAgICAgIGxldmVsLnZlcnNpb24gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFWFRNM1UnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdFTkRMSVNUJzpcbiAgICAgICAgICBsZXZlbC5saXZlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0RJUyc6XG4gICAgICAgICAgY2MrKztcbiAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ0RJUyddKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRElTQ09OVElOVUlUWS1TRVEnOlxuICAgICAgICAgIGNjID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnS0VZJzpcbiAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGFudG9zLWh0dHAtbGl2ZS1zdHJlYW1pbmctMDgjc2VjdGlvbi0zLjQuNFxuICAgICAgICAgIHZhciBkZWNyeXB0cGFyYW1zID0gdmFsdWUxO1xuICAgICAgICAgIHZhciBrZXlBdHRycyA9IG5ldyBBdHRyTGlzdChkZWNyeXB0cGFyYW1zKTtcbiAgICAgICAgICB2YXIgZGVjcnlwdG1ldGhvZCA9IGtleUF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ01FVEhPRCcpLFxuICAgICAgICAgICAgZGVjcnlwdHVyaSA9IGtleUF0dHJzLlVSSSxcbiAgICAgICAgICAgIGRlY3J5cHRpdiA9IGtleUF0dHJzLmhleGFkZWNpbWFsSW50ZWdlcignSVYnKTtcbiAgICAgICAgICBpZiAoZGVjcnlwdG1ldGhvZCkge1xuICAgICAgICAgICAgbGV2ZWxrZXkgPSBuZXcgTGV2ZWxLZXkoKTtcbiAgICAgICAgICAgIGlmICgoZGVjcnlwdHVyaSkgJiYgKFsnQUVTLTEyOCcsICdTQU1QTEUtQUVTJywgJ1NBTVBMRS1BRVMtQ0VOQyddLmluZGV4T2YoZGVjcnlwdG1ldGhvZCkgPj0gMCkpIHtcbiAgICAgICAgICAgICAgbGV2ZWxrZXkubWV0aG9kID0gZGVjcnlwdG1ldGhvZDtcbiAgICAgICAgICAgICAgLy8gVVJJIHRvIGdldCB0aGUga2V5XG4gICAgICAgICAgICAgIGxldmVsa2V5LmJhc2V1cmkgPSBiYXNldXJsO1xuICAgICAgICAgICAgICBsZXZlbGtleS5yZWx1cmkgPSBkZWNyeXB0dXJpO1xuICAgICAgICAgICAgICBsZXZlbGtleS5rZXkgPSBudWxsO1xuICAgICAgICAgICAgICAvLyBJbml0aWFsaXphdGlvbiBWZWN0b3IgKElWKVxuICAgICAgICAgICAgICBsZXZlbGtleS5pdiA9IGRlY3J5cHRpdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1NUQVJUJzpcbiAgICAgICAgICBsZXQgc3RhcnRQYXJhbXMgPSB2YWx1ZTE7XG4gICAgICAgICAgbGV0IHN0YXJ0QXR0cnMgPSBuZXcgQXR0ckxpc3Qoc3RhcnRQYXJhbXMpO1xuICAgICAgICAgIGxldCBzdGFydFRpbWVPZmZzZXQgPSBzdGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdUSU1FLU9GRlNFVCcpO1xuICAgICAgICAgIC8vIFRJTUUtT0ZGU0VUIGNhbiBiZSAwXG4gICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShzdGFydFRpbWVPZmZzZXQpKSB7XG4gICAgICAgICAgICBsZXZlbC5zdGFydFRpbWVPZmZzZXQgPSBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01BUCc6XG4gICAgICAgICAgbGV0IG1hcEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgZnJhZy5yZWx1cmwgPSBtYXBBdHRycy5VUkk7XG4gICAgICAgICAgZnJhZy5yYXdCeXRlUmFuZ2UgPSBtYXBBdHRycy5CWVRFUkFOR0U7XG4gICAgICAgICAgZnJhZy5iYXNldXJsID0gYmFzZXVybDtcbiAgICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgICAgZnJhZy50eXBlID0gdHlwZTtcbiAgICAgICAgICBmcmFnLnNuID0gJ2luaXRTZWdtZW50JztcbiAgICAgICAgICBsZXZlbC5pbml0U2VnbWVudCA9IGZyYWc7XG4gICAgICAgICAgZnJhZyA9IG5ldyBGcmFnbWVudCgpO1xuICAgICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gbGV2ZWwuaW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxvZ2dlci53YXJuKGBsaW5lIHBhcnNlZCBidXQgbm90IGhhbmRsZWQ6ICR7cmVzdWx0fWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZyYWcgPSBwcmV2RnJhZztcbiAgICAvLyBsb2dnZXIubG9nKCdmb3VuZCAnICsgbGV2ZWwuZnJhZ21lbnRzLmxlbmd0aCArICcgZnJhZ21lbnRzJyk7XG4gICAgaWYgKGZyYWcgJiYgIWZyYWcucmVsdXJsKSB7XG4gICAgICBsZXZlbC5mcmFnbWVudHMucG9wKCk7XG4gICAgICB0b3RhbGR1cmF0aW9uIC09IGZyYWcuZHVyYXRpb247XG4gICAgfVxuICAgIGxldmVsLnRvdGFsZHVyYXRpb24gPSB0b3RhbGR1cmF0aW9uO1xuICAgIGxldmVsLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb24gLyBsZXZlbC5mcmFnbWVudHMubGVuZ3RoO1xuICAgIGxldmVsLmVuZFNOID0gY3VycmVudFNOIC0gMTtcbiAgICBsZXZlbC5zdGFydENDID0gbGV2ZWwuZnJhZ21lbnRzWzBdID8gbGV2ZWwuZnJhZ21lbnRzWzBdLmNjIDogMDtcbiAgICBsZXZlbC5lbmRDQyA9IGNjO1xuXG4gICAgaWYgKCFsZXZlbC5pbml0U2VnbWVudCAmJiBsZXZlbC5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyB0aGlzIGlzIGEgYml0IGx1cmt5IGJ1dCBITFMgcmVhbGx5IGhhcyBubyBvdGhlciB3YXkgdG8gdGVsbCB1c1xuICAgICAgLy8gaWYgdGhlIGZyYWdtZW50cyBhcmUgVFMgb3IgTVA0LCBleGNlcHQgaWYgd2UgZG93bmxvYWQgdGhlbSA6L1xuICAgICAgLy8gYnV0IHRoaXMgaXMgdG8gYmUgYWJsZSB0byBoYW5kbGUgU0lEWC5cbiAgICAgIGlmIChsZXZlbC5mcmFnbWVudHMuZXZlcnkoKGZyYWcpID0+IE1QNF9SRUdFWF9TVUZGSVgudGVzdChmcmFnLnJlbHVybCkpKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdNUDQgZnJhZ21lbnRzIGZvdW5kIGJ1dCBubyBpbml0IHNlZ21lbnQgKHByb2JhYmx5IG5vIE1BUCwgaW5jb21wbGV0ZSBNM1U4KSwgdHJ5aW5nIHRvIGZldGNoIFNJRFgnKTtcblxuICAgICAgICBmcmFnID0gbmV3IEZyYWdtZW50KCk7XG4gICAgICAgIGZyYWcucmVsdXJsID0gbGV2ZWwuZnJhZ21lbnRzWzBdLnJlbHVybDtcbiAgICAgICAgZnJhZy5iYXNldXJsID0gYmFzZXVybDtcbiAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuICAgICAgICBmcmFnLnR5cGUgPSB0eXBlO1xuICAgICAgICBmcmFnLnNuID0gJ2luaXRTZWdtZW50JztcblxuICAgICAgICBsZXZlbC5pbml0U2VnbWVudCA9IGZyYWc7XG4gICAgICAgIGxldmVsLm5lZWRTaWR4UmFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCYWNrZmlsbCBhbnkgbWlzc2luZyBQRFQgdmFsdWVzXG4gICAgICAgXCJJZiB0aGUgZmlyc3QgRVhULVgtUFJPR1JBTS1EQVRFLVRJTUUgdGFnIGluIGEgUGxheWxpc3QgYXBwZWFycyBhZnRlclxuICAgICAgIG9uZSBvciBtb3JlIE1lZGlhIFNlZ21lbnQgVVJJcywgdGhlIGNsaWVudCBTSE9VTEQgZXh0cmFwb2xhdGVcbiAgICAgICBiYWNrd2FyZCBmcm9tIHRoYXQgdGFnICh1c2luZyBFWFRJTkYgZHVyYXRpb25zIGFuZC9vciBtZWRpYVxuICAgICAgIHRpbWVzdGFtcHMpIHRvIGFzc29jaWF0ZSBkYXRlcyB3aXRoIHRob3NlIHNlZ21lbnRzLlwiXG4gICAgICogV2UgaGF2ZSBhbHJlYWR5IGV4dHJhcG9sYXRlZCBmb3J3YXJkLCBidXQgYWxsIGZyYWdtZW50cyB1cCB0byB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgUERUIGRvIG5vdCBoYXZlIHRoZWlyIFBEVHNcbiAgICAgKiBjb21wdXRlZC5cbiAgICAgKi9cbiAgICBpZiAoZmlyc3RQZHRJbmRleCkge1xuICAgICAgYmFja2ZpbGxQcm9ncmFtRGF0ZVRpbWVzKGxldmVsLmZyYWdtZW50cywgZmlyc3RQZHRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxldmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhY2tmaWxsUHJvZ3JhbURhdGVUaW1lcyAoZnJhZ21lbnRzLCBzdGFydEluZGV4KSB7XG4gIGxldCBmcmFnUHJldiA9IGZyYWdtZW50c1tzdGFydEluZGV4XTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudHNbaV07XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBmcmFnUHJldi5wcm9ncmFtRGF0ZVRpbWUgLSAoZnJhZy5kdXJhdGlvbiAqIDEwMDApO1xuICAgIGZyYWdQcmV2ID0gZnJhZztcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUgKGZyYWcsIHByZXZGcmFnKSB7XG4gIGlmIChmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSkge1xuICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gRGF0ZS5wYXJzZShmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSk7XG4gIH0gZWxzZSBpZiAocHJldkZyYWcgJiYgcHJldkZyYWcucHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBwcmV2RnJhZy5lbmRQcm9ncmFtRGF0ZVRpbWU7XG4gIH1cblxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcmFnLnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICB9XG59XG4iLCIvKipcbiAqIFBsYXlsaXN0TG9hZGVyIC0gZGVsZWdhdGUgZm9yIG1lZGlhIG1hbmlmZXN0L3BsYXlsaXN0IGxvYWRpbmcgdGFza3MuIFRha2VzIGNhcmUgb2YgcGFyc2luZyBtZWRpYSB0byBpbnRlcm5hbCBkYXRhLW1vZGVscy5cbiAqXG4gKiBPbmNlIGxvYWRlZCwgZGlzcGF0Y2hlcyBldmVudHMgd2l0aCBwYXJzZWQgZGF0YS1tb2RlbHMgb2YgbWFuaWZlc3QvbGV2ZWxzL2F1ZGlvL3N1YnRpdGxlIHRyYWNrcy5cbiAqXG4gKiBVc2VzIGxvYWRlcihzKSBzZXQgaW4gY29uZmlnIHRvIGRvIGFjdHVhbCBpbnRlcm5hbCBsb2FkaW5nIG9mIHJlc291cmNlIHRhc2tzLlxuICpcbiAqIEBtb2R1bGVcbiAqXG4gKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuaW1wb3J0IE1QNERlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvbXA0ZGVtdXhlcic7XG5pbXBvcnQgTTNVOFBhcnNlciBmcm9tICcuL20zdTgtcGFyc2VyJztcblxuY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gd2luZG93O1xuXG4vKipcbiAqIGB0eXBlYCBwcm9wZXJ0eSB2YWx1ZXMgZm9yIHRoaXMgbG9hZGVycycgY29udGV4dCBvYmplY3RcbiAqIEBlbnVtXG4gKlxuICovXG5jb25zdCBDb250ZXh0VHlwZSA9IHtcbiAgTUFOSUZFU1Q6ICdtYW5pZmVzdCcsXG4gIExFVkVMOiAnbGV2ZWxzLmpzJyxcbiAgQVVESU9fVFJBQ0s6ICdhdWRpb1RyYWNrJyxcbiAgU1VCVElUTEVfVFJBQ0s6ICdzdWJ0aXRsZVRyYWNrJ1xufTtcblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5jb25zdCBMZXZlbFR5cGUgPSB7XG4gIE1BSU46ICdtYWluJyxcbiAgQVVESU86ICdhdWRpbycsXG4gIFNVQlRJVExFOiAnc3VidGl0bGUnXG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBQbGF5bGlzdExvYWRlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0c1xuICAgKiBAcGFyYW0ge0hsc30gaGxzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcbiAgICAgIEV2ZW50LkxFVkVMX0xPQURJTkcsXG4gICAgICBFdmVudC5BVURJT19UUkFDS19MT0FESU5HLFxuICAgICAgRXZlbnQuU1VCVElUTEVfVFJBQ0tfTE9BRElORyk7XG5cbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgQ29udGV4dFR5cGUgKCkge1xuICAgIHJldHVybiBDb250ZXh0VHlwZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTGV2ZWxUeXBlICgpIHtcbiAgICByZXR1cm4gTGV2ZWxUeXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGV4dFR5cGV9IHR5cGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgY2FuSGF2ZVF1YWxpdHlMZXZlbHMgKHR5cGUpIHtcbiAgICByZXR1cm4gKHR5cGUgIT09IENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmXG4gICAgICB0eXBlICE9PSBDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyk7XG4gIH1cblxuICAvKipcbiAgICogTWFwIGNvbnRleHQudHlwZSB0byBMZXZlbFR5cGVcbiAgICogQHBhcmFtIHt7dHlwZTogQ29udGV4dFR5cGV9fSBjb250ZXh0XG4gICAqIEByZXR1cm5zIHtMZXZlbFR5cGV9XG4gICAqL1xuICBzdGF0aWMgbWFwQ29udGV4dFRvTGV2ZWxUeXBlIChjb250ZXh0KSB7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBjb250ZXh0O1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgIHJldHVybiBMZXZlbFR5cGUuQVVESU87XG4gICAgY2FzZSBDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgIHJldHVybiBMZXZlbFR5cGUuU1VCVElUTEU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBMZXZlbFR5cGUuTUFJTjtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0UmVzcG9uc2VVcmwgKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgbGV0IHVybCA9IHJlc3BvbnNlLnVybDtcbiAgICAvLyByZXNwb25zZVVSTCBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMgKGl0IGlzIHVzZWQgdG8gZGV0ZWN0IFVSTCByZWRpcmVjdGlvbilcbiAgICAvLyBkYXRhLXVyaSBtb2RlIGFsc28gbm90IHN1cHBvcnRlZCAoYnV0IG5vIG5lZWQgdG8gZGV0ZWN0IHJlZGlyZWN0aW9uKVxuICAgIGlmICh1cmwgPT09IHVuZGVmaW5lZCB8fCB1cmwuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgICAgLy8gZmFsbGJhY2sgdG8gaW5pdGlhbCBVUkxcbiAgICAgIHVybCA9IGNvbnRleHQudXJsO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZGVmYXVsdHMgb3IgY29uZmlndXJlZCBsb2FkZXItdHlwZSBvdmVybG9hZHMgKHBMb2FkZXIgYW5kIGxvYWRlciBjb25maWcgcGFyYW1zKVxuICAgKiBEZWZhdWx0IGxvYWRlciBpcyBYSFJMb2FkZXIgKHNlZSB1dGlscylcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybnMge1hIUkxvYWRlcn0gb3Igb3RoZXIgY29tcGF0aWJsZSBjb25maWd1cmVkIG92ZXJsb2FkXG4gICAqL1xuICBjcmVhdGVJbnRlcm5hbExvYWRlciAoY29udGV4dCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBjb25zdCBQTG9hZGVyID0gY29uZmlnLnBMb2FkZXI7XG4gICAgY29uc3QgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICBjb25zdCBJbnRlcm5hbExvYWRlciA9IFBMb2FkZXIgfHwgTG9hZGVyO1xuXG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEludGVybmFsTG9hZGVyKGNvbmZpZyk7XG5cbiAgICBjb250ZXh0LmxvYWRlciA9IGxvYWRlcjtcbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IGxvYWRlcjtcblxuICAgIHJldHVybiBsb2FkZXI7XG4gIH1cblxuICBnZXRJbnRlcm5hbExvYWRlciAoY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXTtcbiAgfVxuXG4gIHJlc2V0SW50ZXJuYWxMb2FkZXIgKGNvbnRleHRUeXBlKSB7XG4gICAgaWYgKHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGBkZXN0cm95YCBvbiBhbGwgaW50ZXJuYWwgbG9hZGVyIGluc3RhbmNlcyBtYXBwZWQgKG9uZSBwZXIgY29udGV4dCB0eXBlKVxuICAgKi9cbiAgZGVzdHJveUludGVybmFsTG9hZGVycyAoKSB7XG4gICAgZm9yIChsZXQgY29udGV4dFR5cGUgaW4gdGhpcy5sb2FkZXJzKSB7XG4gICAgICBsZXQgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHRUeXBlKTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmRlc3Ryb3lJbnRlcm5hbExvYWRlcnMoKTtcblxuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIG9uTWFuaWZlc3RMb2FkaW5nIChkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGU6IENvbnRleHRUeXBlLk1BTklGRVNULCBsZXZlbDogMCwgaWQ6IG51bGwgfSk7XG4gIH1cblxuICBvbkxldmVsTG9hZGluZyAoZGF0YSkge1xuICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlOiBDb250ZXh0VHlwZS5MRVZFTCwgbGV2ZWw6IGRhdGEubGV2ZWxzLCBpZDogZGF0YS5pZCB9KTtcbiAgfVxuXG4gIG9uQXVkaW9UcmFja0xvYWRpbmcgKGRhdGEpIHtcbiAgICB0aGlzLmxvYWQoZGF0YS51cmwsIHsgdHlwZTogQ29udGV4dFR5cGUuQVVESU9fVFJBQ0ssIGxldmVsOiBudWxsLCBpZDogZGF0YS5pZCB9KTtcbiAgfVxuXG4gIG9uU3VidGl0bGVUcmFja0xvYWRpbmcgKGRhdGEpIHtcbiAgICB0aGlzLmxvYWQoZGF0YS51cmwsIHsgdHlwZTogQ29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0ssIGxldmVsOiBudWxsLCBpZDogZGF0YS5pZCB9KTtcbiAgfVxuXG4gIGxvYWQgKHVybCwgY29udGV4dCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcblxuICAgIGxvZ2dlci5kZWJ1ZyhgTG9hZGluZyBwbGF5bGlzdCBvZiB0eXBlICR7Y29udGV4dC50eXBlfSwgbGV2ZWw6ICR7Y29udGV4dC5sZXZlbHN9LCBpZDogJHtjb250ZXh0LmlkfWApO1xuXG4gICAgLy8gQ2hlY2sgaWYgYSBsb2FkZXIgZm9yIHRoaXMgY29udGV4dCBhbHJlYWR5IGV4aXN0c1xuICAgIGxldCBsb2FkZXIgPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQgPSBsb2FkZXIuY29udGV4dDtcbiAgICAgIGlmIChsb2FkZXJDb250ZXh0ICYmIGxvYWRlckNvbnRleHQudXJsID09PSB1cmwpIHsgLy8gc2FtZSBVUkwgY2FuJ3Qgb3ZlcmxhcFxuICAgICAgICBsb2dnZXIudHJhY2UoJ3BsYXlsaXN0IHJlcXVlc3Qgb25nb2luZycpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybihgYWJvcnRpbmcgcHJldmlvdXMgbG9hZGVyIGZvciB0eXBlOiAke2NvbnRleHQudHlwZX1gKTtcbiAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG1heFJldHJ5LFxuICAgICAgdGltZW91dCxcbiAgICAgIHJldHJ5RGVsYXksXG4gICAgICBtYXhSZXRyeURlbGF5O1xuXG4gICAgLy8gYXBwbHkgZGlmZmVyZW50IGNvbmZpZ3MgZm9yIHJldHJpZXMgZGVwZW5kaW5nIG9uXG4gICAgLy8gY29udGV4dCAobWFuaWZlc3QsIGxldmVsLCBhdWRpby9zdWJzIHBsYXlsaXN0KVxuICAgIHN3aXRjaCAoY29udGV4dC50eXBlKSB7XG4gICAgY2FzZSBDb250ZXh0VHlwZS5NQU5JRkVTVDpcbiAgICAgIG1heFJldHJ5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ01heFJldHJ5O1xuICAgICAgdGltZW91dCA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdUaW1lT3V0O1xuICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgbWF4UmV0cnlEZWxheSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENvbnRleHRUeXBlLkxFVkVMOlxuICAgICAgLy8gRGlzYWJsZSBpbnRlcm5hbCBsb2FkZXIgcmV0cnkgbG9naWMsIHNpbmNlIHdlIGFyZSBtYW5hZ2luZyByZXRyaWVzIGluIExldmVsIENvbnRyb2xsZXJcbiAgICAgIG1heFJldHJ5ID0gMDtcbiAgICAgIHRpbWVvdXQgPSBjb25maWcubGV2ZWxMb2FkaW5nVGltZU91dDtcbiAgICAgIC8vIFRPRE8gSW50cm9kdWNlIHJldHJ5IHNldHRpbmdzIGZvciBhdWRpby10cmFjayBhbmQgc3VidGl0bGUtdHJhY2ssIGl0IHNob3VsZCBub3QgdXNlIGxldmVsIHJldHJ5IGNvbmZpZ1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG1heFJldHJ5ID0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5O1xuICAgICAgdGltZW91dCA9IGNvbmZpZy5sZXZlbExvYWRpbmdUaW1lT3V0O1xuICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgbWF4UmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBsb2FkZXIgPSB0aGlzLmNyZWF0ZUludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuXG4gICAgY29udGV4dC51cmwgPSB1cmw7XG4gICAgY29udGV4dC5yZXNwb25zZVR5cGUgPSBjb250ZXh0LnJlc3BvbnNlVHlwZSB8fCAnJzsgLy8gRklYTUU6IChzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSB0byBkbyB0aGlzKVxuXG4gICAgY29uc3QgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgdGltZW91dCxcbiAgICAgIG1heFJldHJ5LFxuICAgICAgcmV0cnlEZWxheSxcbiAgICAgIG1heFJldHJ5RGVsYXlcbiAgICB9O1xuXG4gICAgY29uc3QgbG9hZGVyQ2FsbGJhY2tzID0ge1xuICAgICAgb25TdWNjZXNzOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLmxvYWRlcnJvci5iaW5kKHRoaXMpLFxuICAgICAgb25UaW1lb3V0OiB0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcylcbiAgICB9O1xuXG4gICAgbG9nZ2VyLmRlYnVnKGBDYWxsaW5nIGludGVybmFsIGxvYWRlciBkZWxlZ2F0ZSBmb3IgVVJMOiAke3VybH1gKTtcblxuICAgIGxvYWRlci5sb2FkKGNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgbG9hZHN1Y2Nlc3MgKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMgPSBudWxsKSB7XG4gICAgaWYgKGNvbnRleHQuaXNTaWR4UmVxdWVzdCkge1xuICAgICAgdGhpcy5faGFuZGxlU2lkeFJlcXVlc3QocmVzcG9uc2UsIGNvbnRleHQpO1xuICAgICAgdGhpcy5faGFuZGxlUGxheWxpc3RMb2FkZWQocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHQudHlwZSk7XG5cbiAgICBjb25zdCBzdHJpbmcgPSByZXNwb25zZS5kYXRhO1xuXG4gICAgc3RhdHMudGxvYWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAvLyBzdGF0cy5tdGltZSA9IG5ldyBEYXRlKHRhcmdldC5nZXRSZXNwb25zZUhlYWRlcignTGFzdC1Nb2RpZmllZCcpKTtcblxuICAgIC8vIFZhbGlkYXRlIGlmIGl0IGlzIGFuIE0zVTggYXQgYWxsXG4gICAgaWYgKHN0cmluZy5pbmRleE9mKCcjRVhUTTNVJykgIT09IDApIHtcbiAgICAgIHRoaXMuX2hhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCAnbm8gRVhUTTNVIGRlbGltaXRlcicsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBjaHVuay1saXN0IG9yIG1hc3Rlci4gaGFuZGxlIGVtcHR5IGNodW5rIGxpc3QgY2FzZSAoZmlyc3QgRVhUSU5GIG5vdCBzaWduYWxlZCwgYnV0IFRBUkdFVERVUkFUSU9OIHByZXNlbnQpXG4gICAgaWYgKHN0cmluZy5pbmRleE9mKCcjRVhUSU5GOicpID4gMCB8fCBzdHJpbmcuaW5kZXhPZignI0VYVC1YLVRBUkdFVERVUkFUSU9OOicpID4gMCkge1xuICAgICAgdGhpcy5faGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hhbmRsZU1hc3RlclBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpO1xuICAgIH1cbiAgfVxuXG4gIGxvYWRlcnJvciAocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzID0gbnVsbCkge1xuICAgIHRoaXMuX2hhbmRsZU5ldHdvcmtFcnJvcihjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgZmFsc2UsIHJlc3BvbnNlKTtcbiAgfVxuXG4gIGxvYWR0aW1lb3V0IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMgPSBudWxsKSB7XG4gICAgdGhpcy5faGFuZGxlTmV0d29ya0Vycm9yKGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCB0cnVlKTtcbiAgfVxuXG4gIF9oYW5kbGVNYXN0ZXJQbGF5bGlzdCAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IHN0cmluZyA9IHJlc3BvbnNlLmRhdGE7XG5cbiAgICBjb25zdCB1cmwgPSBQbGF5bGlzdExvYWRlci5nZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XG5cbiAgICBjb25zdCBsZXZlbHMgPSBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3Qoc3RyaW5nLCB1cmwpO1xuICAgIGlmICghbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgdGhpcy5faGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsICdubyBsZXZlbCBmb3VuZCBpbiBtYW5pZmVzdCcsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBtdWx0aSBsZXZlbCBwbGF5bGlzdCwgcGFyc2UgbGV2ZWwgaW5mb1xuXG4gICAgY29uc3QgYXVkaW9Hcm91cHMgPSBsZXZlbHMubWFwKGxldmVsID0+ICh7XG4gICAgICBpZDogbGV2ZWwuYXR0cnMuQVVESU8sXG4gICAgICBjb2RlYzogbGV2ZWwuYXVkaW9Db2RlY1xuICAgIH0pKTtcblxuICAgIGxldCBhdWRpb1RyYWNrcyA9IE0zVThQYXJzZXIucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCAnQVVESU8nLCBhdWRpb0dyb3Vwcyk7XG4gICAgbGV0IHN1YnRpdGxlcyA9IE0zVThQYXJzZXIucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCAnU1VCVElUTEVTJyk7XG5cbiAgICBpZiAoYXVkaW9UcmFja3MubGVuZ3RoKSB7XG4gICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGZvdW5kIGFuIGF1ZGlvIHRyYWNrIGVtYmVkZGVkIGluIG1haW4gcGxheWxpc3QgKGF1ZGlvIHRyYWNrIHdpdGhvdXQgVVJJIGF0dHJpYnV0ZSlcbiAgICAgIGxldCBlbWJlZGRlZEF1ZGlvRm91bmQgPSBmYWxzZTtcbiAgICAgIGF1ZGlvVHJhY2tzLmZvckVhY2goYXVkaW9UcmFjayA9PiB7XG4gICAgICAgIGlmICghYXVkaW9UcmFjay51cmwpIHtcbiAgICAgICAgICBlbWJlZGRlZEF1ZGlvRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gaWYgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgZGVmaW5lZCwgYnV0IGF1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsXG4gICAgICAvLyB3ZSBuZWVkIHRvIHNpZ25hbCB0aGlzIG1haW4gYXVkaW8gdHJhY2sgdGhpcyBjb3VsZCBoYXBwZW4gd2l0aCBwbGF5bGlzdHMgd2l0aFxuICAgICAgLy8gYWx0IGF1ZGlvIHJlbmRpdGlvbiBpbiB3aGljaCBxdWFsaXR5IGxldmVscyAobWFpbilcbiAgICAgIC8vIGNvbnRhaW5zIGJvdGggYXVkaW8rdmlkZW8uIGJ1dCB3aXRoIG1peGVkIGF1ZGlvIHRyYWNrIG5vdCBzaWduYWxlZFxuICAgICAgaWYgKGVtYmVkZGVkQXVkaW9Gb3VuZCA9PT0gZmFsc2UgJiYgbGV2ZWxzWzBdLmF1ZGlvQ29kZWMgJiYgIWxldmVsc1swXS5hdHRycy5BVURJTykge1xuICAgICAgICBsb2dnZXIubG9nKCdhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLCBidXQgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgc2lnbmFsZWQsIGNyZWF0ZSBvbmUnKTtcbiAgICAgICAgYXVkaW9UcmFja3MudW5zaGlmdCh7XG4gICAgICAgICAgdHlwZTogJ21haW4nLFxuICAgICAgICAgIG5hbWU6ICdtYWluJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBobHMudHJpZ2dlcihFdmVudC5NQU5JRkVTVF9MT0FERUQsIHtcbiAgICAgIGxldmVscyxcbiAgICAgIGF1ZGlvVHJhY2tzLFxuICAgICAgc3VidGl0bGVzLFxuICAgICAgdXJsLFxuICAgICAgc3RhdHMsXG4gICAgICBuZXR3b3JrRGV0YWlsc1xuICAgIH0pO1xuICB9XG5cbiAgX2hhbmRsZVRyYWNrT3JMZXZlbFBsYXlsaXN0IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG5cbiAgICBjb25zdCB7IGlkLCBsZXZlbCwgdHlwZSB9ID0gY29udGV4dDtcblxuICAgIGNvbnN0IHVybCA9IFBsYXlsaXN0TG9hZGVyLmdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IGxldmVsVXJsSWQgPSBOdW1iZXIuaXNGaW5pdGUoaWQpID8gaWQgOiAwO1xuICAgIGNvbnN0IGxldmVsSWQgPSBOdW1iZXIuaXNGaW5pdGUobGV2ZWwpID8gbGV2ZWwgOiBsZXZlbFVybElkO1xuICAgIGNvbnN0IGxldmVsVHlwZSA9IFBsYXlsaXN0TG9hZGVyLm1hcENvbnRleHRUb0xldmVsVHlwZShjb250ZXh0KTtcblxuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IE0zVThQYXJzZXIucGFyc2VMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLmRhdGEsIHVybCwgbGV2ZWxJZCwgbGV2ZWxUeXBlLCBsZXZlbFVybElkKTtcblxuICAgIC8vIHNldCBzdGF0cyBvbiBsZXZlbCBzdHJ1Y3R1cmVcbiAgICBsZXZlbERldGFpbHMudGxvYWQgPSBzdGF0cy50bG9hZDtcblxuICAgIC8vIFdlIGhhdmUgZG9uZSBvdXIgZmlyc3QgcmVxdWVzdCAoTWFuaWZlc3QtdHlwZSkgYW5kIHJlY2VpdmVcbiAgICAvLyBub3QgYSBtYXN0ZXIgcGxheWxpc3QgYnV0IGEgY2h1bmstbGlzdCAodHJhY2svbGV2ZWwpXG4gICAgLy8gV2UgZmlyZSB0aGUgbWFuaWZlc3QtbG9hZGVkIGV2ZW50IGFueXdheSB3aXRoIHRoZSBwYXJzZWQgbGV2ZWwtZGV0YWlsc1xuICAgIC8vIGJ5IGNyZWF0aW5nIGEgc2luZ2xlLWxldmVsIHN0cnVjdHVyZSBmb3IgaXQuXG4gICAgaWYgKHR5cGUgPT09IENvbnRleHRUeXBlLk1BTklGRVNUKSB7XG4gICAgICBjb25zdCBzaW5nbGVMZXZlbCA9IHtcbiAgICAgICAgdXJsLFxuICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHNcbiAgICAgIH07XG5cbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50Lk1BTklGRVNUX0xPQURFRCwge1xuICAgICAgICBsZXZlbHM6IFtzaW5nbGVMZXZlbF0sXG4gICAgICAgIGF1ZGlvVHJhY2tzOiBbXSxcbiAgICAgICAgdXJsLFxuICAgICAgICBzdGF0cyxcbiAgICAgICAgbmV0d29ya0RldGFpbHNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHNhdmUgcGFyc2luZyB0aW1lXG4gICAgc3RhdHMudHBhcnNlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgLy8gaW4gY2FzZSB3ZSBuZWVkIFNJRFggcmFuZ2VzXG4gICAgLy8gcmV0dXJuIGVhcmx5IGFmdGVyIGNhbGxpbmcgbG9hZCBmb3JcbiAgICAvLyB0aGUgU0lEWCBib3guXG4gICAgaWYgKGxldmVsRGV0YWlscy5uZWVkU2lkeFJhbmdlcykge1xuICAgICAgY29uc3Qgc2lkeFVybCA9IGxldmVsRGV0YWlscy5pbml0U2VnbWVudC51cmw7XG4gICAgICB0aGlzLmxvYWQoc2lkeFVybCwge1xuICAgICAgICBpc1NpZHhSZXF1ZXN0OiB0cnVlLFxuICAgICAgICB0eXBlLFxuICAgICAgICBsZXZlbCxcbiAgICAgICAgbGV2ZWxEZXRhaWxzLFxuICAgICAgICBpZCxcbiAgICAgICAgcmFuZ2VTdGFydDogMCxcbiAgICAgICAgcmFuZ2VFbmQ6IDIwNDgsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJ1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZXh0ZW5kIHRoZSBjb250ZXh0IHdpdGggdGhlIG5ldyBsZXZlbERldGFpbHMgcHJvcGVydHlcbiAgICBjb250ZXh0LmxldmVsRGV0YWlscyA9IGxldmVsRGV0YWlscztcblxuICAgIHRoaXMuX2hhbmRsZVBsYXlsaXN0TG9hZGVkKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpO1xuICB9XG5cbiAgX2hhbmRsZVNpZHhSZXF1ZXN0IChyZXNwb25zZSwgY29udGV4dCkge1xuICAgIGNvbnN0IHNpZHhJbmZvID0gTVA0RGVtdXhlci5wYXJzZVNlZ21lbnRJbmRleChuZXcgVWludDhBcnJheShyZXNwb25zZS5kYXRhKSk7XG4gICAgLy8gaWYgcHJvdmlkZWQgZnJhZ21lbnQgZG9lcyBub3QgY29udGFpbiBzaWR4LCBlYXJseSByZXR1cm5cbiAgICBpZiAoIXNpZHhJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNpZHhSZWZlcmVuY2VzID0gc2lkeEluZm8ucmVmZXJlbmNlcztcbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSBjb250ZXh0LmxldmVsRGV0YWlscztcbiAgICBzaWR4UmVmZXJlbmNlcy5mb3JFYWNoKChzZWdtZW50UmVmLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3Qgc2VnUmVmSW5mbyA9IHNlZ21lbnRSZWYuaW5mbztcbiAgICAgIGNvbnN0IGZyYWcgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzW2luZGV4XTtcblxuICAgICAgaWYgKGZyYWcuYnl0ZVJhbmdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmcmFnLnJhd0J5dGVSYW5nZSA9IFN0cmluZygxICsgc2VnUmVmSW5mby5lbmQgLSBzZWdSZWZJbmZvLnN0YXJ0KSArICdAJyArIFN0cmluZyhzZWdSZWZJbmZvLnN0YXJ0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQucmF3Qnl0ZVJhbmdlID0gU3RyaW5nKHNpZHhJbmZvLm1vb3ZFbmRPZmZzZXQpICsgJ0AwJztcbiAgfVxuXG4gIF9oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvciAocmVzcG9uc2UsIGNvbnRleHQsIHJlYXNvbiwgbmV0d29ya0RldGFpbHMpIHtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfUEFSU0lOR19FUlJPUixcbiAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICByZWFzb24sXG4gICAgICBuZXR3b3JrRGV0YWlsc1xuICAgIH0pO1xuICB9XG5cbiAgX2hhbmRsZU5ldHdvcmtFcnJvciAoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHRpbWVvdXQgPSBmYWxzZSwgcmVzcG9uc2UgPSBudWxsKSB7XG4gICAgbG9nZ2VyLmluZm8oYEEgbmV0d29yayBlcnJvciBvY2N1cmVkIHdoaWxlIGxvYWRpbmcgYSAke2NvbnRleHQudHlwZX0tdHlwZSBwbGF5bGlzdGApO1xuXG4gICAgbGV0IGRldGFpbHM7XG4gICAgbGV0IGZhdGFsO1xuXG4gICAgY29uc3QgbG9hZGVyID0gdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcblxuICAgIHN3aXRjaCAoY29udGV4dC50eXBlKSB7XG4gICAgY2FzZSBDb250ZXh0VHlwZS5NQU5JRkVTVDpcbiAgICAgIGRldGFpbHMgPSAodGltZW91dCA/IEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX1RJTUVPVVQgOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9FUlJPUik7XG4gICAgICBmYXRhbCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENvbnRleHRUeXBlLkxFVkVMOlxuICAgICAgZGV0YWlscyA9ICh0aW1lb3V0ID8gRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVCA6IEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SKTtcbiAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENvbnRleHRUeXBlLkFVRElPX1RSQUNLOlxuICAgICAgZGV0YWlscyA9ICh0aW1lb3V0ID8gRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVCA6IEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SKTtcbiAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZGV0YWlscyA9IC4uLj9cbiAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dC50eXBlKTtcbiAgICB9XG5cbiAgICBsZXQgZXJyb3JEYXRhID0ge1xuICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgZGV0YWlscyxcbiAgICAgIGZhdGFsLFxuICAgICAgdXJsOiBsb2FkZXIudXJsLFxuICAgICAgbG9hZGVyLFxuICAgICAgY29udGV4dCxcbiAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgfTtcblxuICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgZXJyb3JEYXRhLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgZXJyb3JEYXRhKTtcbiAgfVxuXG4gIF9oYW5kbGVQbGF5bGlzdExvYWRlZCAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgIGNvbnN0IHsgdHlwZSwgbGV2ZWwsIGlkLCBsZXZlbERldGFpbHMgfSA9IGNvbnRleHQ7XG5cbiAgICBpZiAoIWxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikge1xuICAgICAgdGhpcy5faGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsICdpbnZhbGlkIHRhcmdldCBkdXJhdGlvbicsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjYW5IYXZlTGV2ZWxzID0gUGxheWxpc3RMb2FkZXIuY2FuSGF2ZVF1YWxpdHlMZXZlbHMoY29udGV4dC50eXBlKTtcbiAgICBpZiAoY2FuSGF2ZUxldmVscykge1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5MRVZFTF9MT0FERUQsIHtcbiAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICBsZXZlbDogbGV2ZWwgfHwgMCxcbiAgICAgICAgaWQ6IGlkIHx8IDAsXG4gICAgICAgIHN0YXRzLFxuICAgICAgICBuZXR3b3JrRGV0YWlsc1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19MT0FERUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQbGF5bGlzdExvYWRlcjtcbiIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuXG4vKipcbiAqIEBjbGFzc1xuICpcbiAqIFNpbXBsZSBhZGFwdGVyIHN1Yi1jbGFzcyBvZiBOb2RlanMtbGlrZSBFdmVudEVtaXR0ZXIuXG4gKlxuICogV2Ugc2ltcGx5IHdhbnQgdG8gcGFzcyBhbG9uZyB0aGUgZXZlbnQtbmFtZSBpdHNlbGZcbiAqIGluIGV2ZXJ5IGNhbGwgdG8gYSBoYW5kbGVyLCB3aGljaCBpcyB0aGUgcHVycG9zZSBvZiBvdXIgYHRyaWdnZXJgIG1ldGhvZFxuICogZXh0ZW5kaW5nIHRoZSBzdGFuZGFyZCBBUEkuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgT2JzZXJ2ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7YW55fSBkYXRhXG4gICAqL1xuICB0cmlnZ2VyIChldmVudCwgLi4uZGF0YSkge1xuICAgIHRoaXMuZW1pdChldmVudCwgZXZlbnQsIC4uLmRhdGEpO1xuICB9XG59XG4iLCIvKipcbiAqICBBQUMgaGVscGVyXG4gKi9cblxuY2xhc3MgQUFDIHtcbiAgc3RhdGljIGdldFNpbGVudEZyYW1lIChjb2RlYywgY2hhbm5lbENvdW50KSB7XG4gICAgc3dpdGNoIChjb2RlYykge1xuICAgIGNhc2UgJ21wNGEuNDAuMic6XG4gICAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMywgMHg4MF0pO1xuICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDIxLCAweDAwLCAweDQ5LCAweDkwLCAweDAyLCAweDE5LCAweDAwLCAweDIzLCAweDgwXSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4OGVdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MCwgMHgyYywgMHg4MCwgMHgwOCwgMHgwMiwgMHgzOF0pO1xuICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDM4XSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNikge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MDAsIDB4YjIsIDB4MDAsIDB4MjAsIDB4MDgsIDB4ZTBdKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgLy8gaGFuZGxlIEhFLUFBQyBiZWxvdyAobXA0YS40MC41IC8gbXA0YS40MC4yOSlcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZSAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg0ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDFjLCAweDYsIDB4ZjEsIDB4YzEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xuICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MHwwOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZV92MiAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XG4gICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MHwwOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZV92MiAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBQUM7XG4iLCIvKipcbiAqIEdlbmVyYXRlIE1QNCBCb3hcbiovXG5cbmNvbnN0IFVJTlQzMl9NQVggPSBNYXRoLnBvdygyLCAzMikgLSAxO1xuXG5jbGFzcyBNUDQge1xuICBzdGF0aWMgaW5pdCAoKSB7XG4gICAgTVA0LnR5cGVzID0ge1xuICAgICAgYXZjMTogW10sIC8vIGNvZGluZ25hbWVcbiAgICAgIGF2Y0M6IFtdLFxuICAgICAgYnRydDogW10sXG4gICAgICBkaW5mOiBbXSxcbiAgICAgIGRyZWY6IFtdLFxuICAgICAgZXNkczogW10sXG4gICAgICBmdHlwOiBbXSxcbiAgICAgIGhkbHI6IFtdLFxuICAgICAgbWRhdDogW10sXG4gICAgICBtZGhkOiBbXSxcbiAgICAgIG1kaWE6IFtdLFxuICAgICAgbWZoZDogW10sXG4gICAgICBtaW5mOiBbXSxcbiAgICAgIG1vb2Y6IFtdLFxuICAgICAgbW9vdjogW10sXG4gICAgICBtcDRhOiBbXSxcbiAgICAgICcubXAzJzogW10sXG4gICAgICBtdmV4OiBbXSxcbiAgICAgIG12aGQ6IFtdLFxuICAgICAgcGFzcDogW10sXG4gICAgICBzZHRwOiBbXSxcbiAgICAgIHN0Ymw6IFtdLFxuICAgICAgc3RjbzogW10sXG4gICAgICBzdHNjOiBbXSxcbiAgICAgIHN0c2Q6IFtdLFxuICAgICAgc3RzejogW10sXG4gICAgICBzdHRzOiBbXSxcbiAgICAgIHRmZHQ6IFtdLFxuICAgICAgdGZoZDogW10sXG4gICAgICB0cmFmOiBbXSxcbiAgICAgIHRyYWs6IFtdLFxuICAgICAgdHJ1bjogW10sXG4gICAgICB0cmV4OiBbXSxcbiAgICAgIHRraGQ6IFtdLFxuICAgICAgdm1oZDogW10sXG4gICAgICBzbWhkOiBbXVxuICAgIH07XG5cbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgaW4gTVA0LnR5cGVzKSB7XG4gICAgICBpZiAoTVA0LnR5cGVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIE1QNC50eXBlc1tpXSA9IFtcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMCksXG4gICAgICAgICAgaS5jaGFyQ29kZUF0KDEpLFxuICAgICAgICAgIGkuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMylcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgdmlkZW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgIDB4NzYsIDB4NjksIDB4NjQsIDB4NjUsIC8vIGhhbmRsZXJfdHlwZTogJ3ZpZGUnXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDU2LCAweDY5LCAweDY0LCAweDY1LFxuICAgICAgMHg2ZiwgMHg0OCwgMHg2MSwgMHg2ZSxcbiAgICAgIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1ZpZGVvSGFuZGxlcidcbiAgICBdKTtcblxuICAgIGxldCBhdWRpb0hkbHIgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHg3MywgMHg2ZiwgMHg3NSwgMHg2ZSwgLy8gaGFuZGxlcl90eXBlOiAnc291bidcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4NTMsIDB4NmYsIDB4NzUsIDB4NmUsXG4gICAgICAweDY0LCAweDQ4LCAweDYxLCAweDZlLFxuICAgICAgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnU291bmRIYW5kbGVyJ1xuICAgIF0pO1xuXG4gICAgTVA0LkhETFJfVFlQRVMgPSB7XG4gICAgICAndmlkZW8nOiB2aWRlb0hkbHIsXG4gICAgICAnYXVkaW8nOiBhdWRpb0hkbHJcbiAgICB9O1xuXG4gICAgbGV0IGRyZWYgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLCAvLyBlbnRyeV9jb3VudFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwYywgLy8gZW50cnlfc2l6ZVxuICAgICAgMHg3NSwgMHg3MiwgMHg2YywgMHgyMCwgLy8gJ3VybCcgdHlwZVxuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAxIC8vIGVudHJ5X2ZsYWdzXG4gICAgXSk7XG5cbiAgICBsZXQgc3RjbyA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIGVudHJ5X2NvdW50XG4gICAgXSk7XG5cbiAgICBNUDQuU1RUUyA9IE1QNC5TVFNDID0gTVA0LlNUQ08gPSBzdGNvO1xuXG4gICAgTVA0LlNUU1ogPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gc2FtcGxlX3NpemVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gc2FtcGxlX2NvdW50XG4gICAgXSk7XG4gICAgTVA0LlZNSEQgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAxLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgLy8gZ3JhcGhpY3Ntb2RlXG4gICAgICAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAgLy8gb3Bjb2xvclxuICAgIF0pO1xuICAgIE1QNC5TTUhEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGJhbGFuY2VcbiAgICAgIDB4MDAsIDB4MDAgLy8gcmVzZXJ2ZWRcbiAgICBdKTtcblxuICAgIE1QNC5TVFNEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMV0pOy8vIGVudHJ5X2NvdW50XG5cbiAgICBsZXQgbWFqb3JCcmFuZCA9IG5ldyBVaW50OEFycmF5KFsxMDUsIDExNSwgMTExLCAxMDldKTsgLy8gaXNvbVxuICAgIGxldCBhdmMxQnJhbmQgPSBuZXcgVWludDhBcnJheShbOTcsIDExOCwgOTksIDQ5XSk7IC8vIGF2YzFcbiAgICBsZXQgbWlub3JWZXJzaW9uID0gbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDFdKTtcblxuICAgIE1QNC5GVFlQID0gTVA0LmJveChNUDQudHlwZXMuZnR5cCwgbWFqb3JCcmFuZCwgbWlub3JWZXJzaW9uLCBtYWpvckJyYW5kLCBhdmMxQnJhbmQpO1xuICAgIE1QNC5ESU5GID0gTVA0LmJveChNUDQudHlwZXMuZGluZiwgTVA0LmJveChNUDQudHlwZXMuZHJlZiwgZHJlZikpO1xuICB9XG5cbiAgc3RhdGljIGJveCAodHlwZSkge1xuICAgIGxldFxuICAgICAgcGF5bG9hZCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICBzaXplID0gOCxcbiAgICAgIGkgPSBwYXlsb2FkLmxlbmd0aCxcbiAgICAgIGxlbiA9IGksXG4gICAgICByZXN1bHQ7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBzaXplIHdlIG5lZWQgdG8gYWxsb2NhdGVcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICByZXN1bHRbMF0gPSAoc2l6ZSA+PiAyNCkgJiAweGZmO1xuICAgIHJlc3VsdFsxXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzdWx0WzJdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgIHJlc3VsdFszXSA9IHNpemUgJiAweGZmO1xuICAgIHJlc3VsdC5zZXQodHlwZSwgNCk7XG4gICAgLy8gY29weSB0aGUgcGF5bG9hZCBpbnRvIHRoZSByZXN1bHRcbiAgICBmb3IgKGkgPSAwLCBzaXplID0gODsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBjb3B5IHBheWxvYWRbaV0gYXJyYXkgQCBvZmZzZXQgc2l6ZVxuICAgICAgcmVzdWx0LnNldChwYXlsb2FkW2ldLCBzaXplKTtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgc3RhdGljIGhkbHIgKHR5cGUpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuaGRsciwgTVA0LkhETFJfVFlQRVNbdHlwZV0pO1xuICB9XG5cbiAgc3RhdGljIG1kYXQgKGRhdGEpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRhdCwgZGF0YSk7XG4gIH1cblxuICBzdGF0aWMgbWRoZCAodGltZXNjYWxlLCBkdXJhdGlvbikge1xuICAgIGR1cmF0aW9uICo9IHRpbWVzY2FsZTtcbiAgICBjb25zdCB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICBjb25zdCBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRoZCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMSwgLy8gdmVyc2lvbiAxXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMiwgLy8gY3JlYXRpb25fdGltZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgICh0aW1lc2NhbGUgPj4gMjQpICYgMHhGRixcbiAgICAgICh0aW1lc2NhbGUgPj4gMTYpICYgMHhGRixcbiAgICAgICh0aW1lc2NhbGUgPj4gOCkgJiAweEZGLFxuICAgICAgdGltZXNjYWxlICYgMHhGRiwgLy8gdGltZXNjYWxlXG4gICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMjQpLFxuICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXG4gICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweEZGLFxuICAgICAgdXBwZXJXb3JkRHVyYXRpb24gJiAweEZGLFxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDI0KSxcbiAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDgpICYgMHhGRixcbiAgICAgIGxvd2VyV29yZER1cmF0aW9uICYgMHhGRixcbiAgICAgIDB4NTUsIDB4YzQsIC8vICd1bmQnIGxhbmd1YWdlICh1bmRldGVybWluZWQpXG4gICAgICAweDAwLCAweDAwXG4gICAgXSkpO1xuICB9XG5cbiAgc3RhdGljIG1kaWEgKHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaWEsIE1QNC5tZGhkKHRyYWNrLnRpbWVzY2FsZSwgdHJhY2suZHVyYXRpb24pLCBNUDQuaGRscih0cmFjay50eXBlKSwgTVA0Lm1pbmYodHJhY2spKTtcbiAgfVxuXG4gIHN0YXRpYyBtZmhkIChzZXF1ZW5jZU51bWJlcikge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZmhkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIChzZXF1ZW5jZU51bWJlciA+PiAyNCksXG4gICAgICAoc2VxdWVuY2VOdW1iZXIgPj4gMTYpICYgMHhGRixcbiAgICAgIChzZXF1ZW5jZU51bWJlciA+PiA4KSAmIDB4RkYsXG4gICAgICBzZXF1ZW5jZU51bWJlciAmIDB4RkYgLy8gc2VxdWVuY2VfbnVtYmVyXG4gICAgXSkpO1xuICB9XG5cbiAgc3RhdGljIG1pbmYgKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5taW5mLCBNUDQuYm94KE1QNC50eXBlcy5zbWhkLCBNUDQuU01IRCksIE1QNC5ESU5GLCBNUDQuc3RibCh0cmFjaykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMudm1oZCwgTVA0LlZNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgbW9vZiAoc24sIGJhc2VNZWRpYURlY29kZVRpbWUsIHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1vb2YsIE1QNC5tZmhkKHNuKSwgTVA0LnRyYWYodHJhY2ssIGJhc2VNZWRpYURlY29kZVRpbWUpKTtcbiAgfVxuICAvKipcbiAqIEBwYXJhbSB0cmFja3MuLi4gKG9wdGlvbmFsKSB7YXJyYXl9IHRoZSB0cmFja3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbW92aWVcbiAqL1xuICBzdGF0aWMgbW9vdiAodHJhY2tzKSB7XG4gICAgbGV0XG4gICAgICBpID0gdHJhY2tzLmxlbmd0aCxcbiAgICAgIGJveGVzID0gW107XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBib3hlc1tpXSA9IE1QNC50cmFrKHRyYWNrc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1QNC5ib3guYXBwbHkobnVsbCwgW01QNC50eXBlcy5tb292LCBNUDQubXZoZCh0cmFja3NbMF0udGltZXNjYWxlLCB0cmFja3NbMF0uZHVyYXRpb24pXS5jb25jYXQoYm94ZXMpLmNvbmNhdChNUDQubXZleCh0cmFja3MpKSk7XG4gIH1cblxuICBzdGF0aWMgbXZleCAodHJhY2tzKSB7XG4gICAgbGV0XG4gICAgICBpID0gdHJhY2tzLmxlbmd0aCxcbiAgICAgIGJveGVzID0gW107XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBib3hlc1tpXSA9IE1QNC50cmV4KHRyYWNrc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1QNC5ib3guYXBwbHkobnVsbCwgW01QNC50eXBlcy5tdmV4XS5jb25jYXQoYm94ZXMpKTtcbiAgfVxuXG4gIHN0YXRpYyBtdmhkICh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgZHVyYXRpb24gKj0gdGltZXNjYWxlO1xuICAgIGNvbnN0IHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGxldFxuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MDEsIC8vIHZlcnNpb24gMVxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICAgICh0aW1lc2NhbGUgPj4gMjQpICYgMHhGRixcbiAgICAgICAgKHRpbWVzY2FsZSA+PiAxNikgJiAweEZGLFxuICAgICAgICAodGltZXNjYWxlID4+IDgpICYgMHhGRixcbiAgICAgICAgdGltZXNjYWxlICYgMHhGRiwgLy8gdGltZXNjYWxlXG4gICAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAyNCksXG4gICAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweEZGLFxuICAgICAgICB1cHBlcldvcmREdXJhdGlvbiAmIDB4RkYsXG4gICAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAyNCksXG4gICAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweEZGLFxuICAgICAgICBsb3dlcldvcmREdXJhdGlvbiAmIDB4RkYsXG4gICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIC8vIDEuMCByYXRlXG4gICAgICAgIDB4MDEsIDB4MDAsIC8vIDEuMCB2b2x1bWVcbiAgICAgICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgICAweGZmLCAweGZmLCAweGZmLCAweGZmIC8vIG5leHRfdHJhY2tfSURcbiAgICAgIF0pO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tdmhkLCBieXRlcyk7XG4gIH1cblxuICBzdGF0aWMgc2R0cCAodHJhY2spIHtcbiAgICBsZXRcbiAgICAgIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdLFxuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheSg0ICsgc2FtcGxlcy5sZW5ndGgpLFxuICAgICAgZmxhZ3MsXG4gICAgICBpO1xuICAgIC8vIGxlYXZlIHRoZSBmdWxsIGJveCBoZWFkZXIgKDQgYnl0ZXMpIGFsbCB6ZXJvXG4gICAgLy8gd3JpdGUgdGhlIHNhbXBsZSB0YWJsZVxuICAgIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmbGFncyA9IHNhbXBsZXNbaV0uZmxhZ3M7XG4gICAgICBieXRlc1tpICsgNF0gPSAoZmxhZ3MuZGVwZW5kc09uIDw8IDQpIHxcbiAgICAgICAgKGZsYWdzLmlzRGVwZW5kZWRPbiA8PCAyKSB8XG4gICAgICAgIChmbGFncy5oYXNSZWR1bmRhbmN5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc2R0cCwgYnl0ZXMpO1xuICB9XG5cbiAgc3RhdGljIHN0YmwgKHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0YmwsIE1QNC5zdHNkKHRyYWNrKSwgTVA0LmJveChNUDQudHlwZXMuc3R0cywgTVA0LlNUVFMpLCBNUDQuYm94KE1QNC50eXBlcy5zdHNjLCBNUDQuU1RTQyksIE1QNC5ib3goTVA0LnR5cGVzLnN0c3osIE1QNC5TVFNaKSwgTVA0LmJveChNUDQudHlwZXMuc3RjbywgTVA0LlNUQ08pKTtcbiAgfVxuXG4gIHN0YXRpYyBhdmMxICh0cmFjaykge1xuICAgIGxldCBzcHMgPSBbXSwgcHBzID0gW10sIGksIGRhdGEsIGxlbjtcbiAgICAvLyBhc3NlbWJsZSB0aGUgU1BTc1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnNwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSA9IHRyYWNrLnNwc1tpXTtcbiAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHNwcy5wdXNoKChsZW4gPj4+IDgpICYgMHhGRik7XG4gICAgICBzcHMucHVzaCgobGVuICYgMHhGRikpO1xuXG4gICAgICAvLyBTUFNcbiAgICAgIHNwcyA9IHNwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xuICAgIH1cblxuICAgIC8vIGFzc2VtYmxlIHRoZSBQUFNzXG4gICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnBwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSA9IHRyYWNrLnBwc1tpXTtcbiAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHBwcy5wdXNoKChsZW4gPj4+IDgpICYgMHhGRik7XG4gICAgICBwcHMucHVzaCgobGVuICYgMHhGRikpO1xuXG4gICAgICBwcHMgPSBwcHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEpKTtcbiAgICB9XG5cbiAgICBsZXQgYXZjYyA9IE1QNC5ib3goTVA0LnR5cGVzLmF2Y0MsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMHgwMSwgLy8gdmVyc2lvblxuICAgICAgICBzcHNbM10sIC8vIHByb2ZpbGVcbiAgICAgICAgc3BzWzRdLCAvLyBwcm9maWxlIGNvbXBhdFxuICAgICAgICBzcHNbNV0sIC8vIGxldmVsXG4gICAgICAgIDB4ZmMgfCAzLCAvLyBsZW5ndGhTaXplTWludXNPbmUsIGhhcmQtY29kZWQgdG8gNCBieXRlc1xuICAgICAgICAweEUwIHwgdHJhY2suc3BzLmxlbmd0aCAvLyAzYml0IHJlc2VydmVkICgxMTEpICsgbnVtT2ZTZXF1ZW5jZVBhcmFtZXRlclNldHNcbiAgICAgIF0uY29uY2F0KHNwcykuY29uY2F0KFtcbiAgICAgICAgdHJhY2sucHBzLmxlbmd0aCAvLyBudW1PZlBpY3R1cmVQYXJhbWV0ZXJTZXRzXG4gICAgICBdKS5jb25jYXQocHBzKSkpLCAvLyBcIlBQU1wiXG4gICAgICB3aWR0aCA9IHRyYWNrLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0LFxuICAgICAgaFNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzBdLFxuICAgICAgdlNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzFdO1xuXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmF2YzEsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgKHdpZHRoID4+IDgpICYgMHhGRixcbiAgICAgIHdpZHRoICYgMHhmZiwgLy8gd2lkdGhcbiAgICAgIChoZWlnaHQgPj4gOCkgJiAweEZGLFxuICAgICAgaGVpZ2h0ICYgMHhmZiwgLy8gaGVpZ2h0XG4gICAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLCAvLyBob3JpenJlc29sdXRpb25cbiAgICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsIC8vIHZlcnRyZXNvbHV0aW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgLy8gZnJhbWVfY291bnRcbiAgICAgIDB4MTIsXG4gICAgICAweDY0LCAweDYxLCAweDY5LCAweDZDLCAvLyBkYWlseW1vdGlvbi9obHMuanNcbiAgICAgIDB4NzksIDB4NkQsIDB4NkYsIDB4NzQsXG4gICAgICAweDY5LCAweDZGLCAweDZFLCAweDJGLFxuICAgICAgMHg2OCwgMHg2QywgMHg3MywgMHgyRSxcbiAgICAgIDB4NkEsIDB4NzMsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGNvbXByZXNzb3JuYW1lXG4gICAgICAweDAwLCAweDE4LCAvLyBkZXB0aCA9IDI0XG4gICAgICAweDExLCAweDExXSksIC8vIHByZV9kZWZpbmVkID0gLTFcbiAgICBhdmNjLFxuICAgIE1QNC5ib3goTVA0LnR5cGVzLmJ0cnQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIDB4MWMsIDB4OWMsIDB4ODAsIC8vIGJ1ZmZlclNpemVEQlxuICAgICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMCwgLy8gbWF4Qml0cmF0ZVxuICAgICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMF0pKSwgLy8gYXZnQml0cmF0ZVxuICAgIE1QNC5ib3goTVA0LnR5cGVzLnBhc3AsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIChoU3BhY2luZyA+PiAyNCksIC8vIGhTcGFjaW5nXG4gICAgICAoaFNwYWNpbmcgPj4gMTYpICYgMHhGRixcbiAgICAgIChoU3BhY2luZyA+PiA4KSAmIDB4RkYsXG4gICAgICBoU3BhY2luZyAmIDB4RkYsXG4gICAgICAodlNwYWNpbmcgPj4gMjQpLCAvLyB2U3BhY2luZ1xuICAgICAgKHZTcGFjaW5nID4+IDE2KSAmIDB4RkYsXG4gICAgICAodlNwYWNpbmcgPj4gOCkgJiAweEZGLFxuICAgICAgdlNwYWNpbmcgJiAweEZGXSkpXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBlc2RzICh0cmFjaykge1xuICAgIGxldCBjb25maWdsZW4gPSB0cmFjay5jb25maWcubGVuZ3RoO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG5cbiAgICAgIDB4MDMsIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgICAgMHgxNyArIGNvbmZpZ2xlbiwgLy8gbGVuZ3RoXG4gICAgICAweDAwLCAweDAxLCAvLyBlc19pZFxuICAgICAgMHgwMCwgLy8gc3RyZWFtX3ByaW9yaXR5XG5cbiAgICAgIDB4MDQsIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgICAgMHgwZiArIGNvbmZpZ2xlbiwgLy8gbGVuZ3RoXG4gICAgICAweDQwLCAvLyBjb2RlYyA6IG1wZWc0X2F1ZGlvXG4gICAgICAweDE1LCAvLyBzdHJlYW1fdHlwZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gYnVmZmVyX3NpemVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIG1heEJpdHJhdGVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGF2Z0JpdHJhdGVcblxuICAgICAgMHgwNSAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICBdLmNvbmNhdChbY29uZmlnbGVuXSkuY29uY2F0KHRyYWNrLmNvbmZpZykuY29uY2F0KFsweDA2LCAweDAxLCAweDAyXSkpOyAvLyBHQVNwZWNpZmljQ29uZmlnKSk7IC8vIGxlbmd0aCArIGF1ZGlvIGNvbmZpZyBkZXNjcmlwdG9yXG4gIH1cblxuICBzdGF0aWMgbXA0YSAodHJhY2spIHtcbiAgICBsZXQgc2FtcGxlcmF0ZSA9IHRyYWNrLnNhbXBsZXJhdGU7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1wNGEsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LCAvLyBjaGFubmVsY291bnRcbiAgICAgIDB4MDAsIDB4MTAsIC8vIHNhbXBsZVNpemU6MTZiaXRzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDJcbiAgICAgIChzYW1wbGVyYXRlID4+IDgpICYgMHhGRixcbiAgICAgIHNhbXBsZXJhdGUgJiAweGZmLCAvL1xuICAgICAgMHgwMCwgMHgwMF0pLFxuICAgIE1QNC5ib3goTVA0LnR5cGVzLmVzZHMsIE1QNC5lc2RzKHRyYWNrKSkpO1xuICB9XG5cbiAgc3RhdGljIG1wMyAodHJhY2spIHtcbiAgICBsZXQgc2FtcGxlcmF0ZSA9IHRyYWNrLnNhbXBsZXJhdGU7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzWycubXAzJ10sIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LCAvLyBjaGFubmVsY291bnRcbiAgICAgIDB4MDAsIDB4MTAsIC8vIHNhbXBsZVNpemU6MTZiaXRzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDJcbiAgICAgIChzYW1wbGVyYXRlID4+IDgpICYgMHhGRixcbiAgICAgIHNhbXBsZXJhdGUgJiAweGZmLCAvL1xuICAgICAgMHgwMCwgMHgwMF0pKTtcbiAgfVxuXG4gIHN0YXRpYyBzdHNkICh0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICBpZiAoIXRyYWNrLmlzQUFDICYmIHRyYWNrLmNvZGVjID09PSAnbXAzJykge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDModHJhY2spKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQubXA0YSh0cmFjaykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5hdmMxKHRyYWNrKSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHRraGQgKHRyYWNrKSB7XG4gICAgbGV0IGlkID0gdHJhY2suaWQsXG4gICAgICBkdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uICogdHJhY2sudGltZXNjYWxlLFxuICAgICAgd2lkdGggPSB0cmFjay53aWR0aCxcbiAgICAgIGhlaWdodCA9IHRyYWNrLmhlaWdodCxcbiAgICAgIHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpLFxuICAgICAgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRraGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDEsIC8vIHZlcnNpb24gMVxuICAgICAgMHgwMCwgMHgwMCwgMHgwNywgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICAoaWQgPj4gMjQpICYgMHhGRixcbiAgICAgIChpZCA+PiAxNikgJiAweEZGLFxuICAgICAgKGlkID4+IDgpICYgMHhGRixcbiAgICAgIGlkICYgMHhGRiwgLy8gdHJhY2tfSURcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMjQpLFxuICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4RkYsXG4gICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweEZGLFxuICAgICAgdXBwZXJXb3JkRHVyYXRpb24gJiAweEZGLFxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDI0KSxcbiAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDgpICYgMHhGRixcbiAgICAgIGxvd2VyV29yZER1cmF0aW9uICYgMHhGRixcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgLy8gbGF5ZXJcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGFsdGVybmF0ZV9ncm91cFxuICAgICAgMHgwMCwgMHgwMCwgLy8gbm9uLWF1ZGlvIHRyYWNrIHZvbHVtZVxuICAgICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgICAgKHdpZHRoID4+IDgpICYgMHhGRixcbiAgICAgIHdpZHRoICYgMHhGRixcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHdpZHRoXG4gICAgICAoaGVpZ2h0ID4+IDgpICYgMHhGRixcbiAgICAgIGhlaWdodCAmIDB4RkYsXG4gICAgICAweDAwLCAweDAwIC8vIGhlaWdodFxuICAgIF0pKTtcbiAgfVxuXG4gIHN0YXRpYyB0cmFmICh0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSkge1xuICAgIGxldCBzYW1wbGVEZXBlbmRlbmN5VGFibGUgPSBNUDQuc2R0cCh0cmFjayksXG4gICAgICBpZCA9IHRyYWNrLmlkLFxuICAgICAgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAvIChVSU5UMzJfTUFYICsgMSkpLFxuICAgICAgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFmLFxuICAgICAgTVA0LmJveChNUDQudHlwZXMudGZoZCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgICAgKGlkID4+IDI0KSxcbiAgICAgICAgKGlkID4+IDE2KSAmIDBYRkYsXG4gICAgICAgIChpZCA+PiA4KSAmIDBYRkYsXG4gICAgICAgIChpZCAmIDB4RkYpIC8vIHRyYWNrX0lEXG4gICAgICBdKSksXG4gICAgICBNUDQuYm94KE1QNC50eXBlcy50ZmR0LCBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MDEsIC8vIHZlcnNpb24gMVxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgICAodXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAyNCksXG4gICAgICAgICh1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDE2KSAmIDBYRkYsXG4gICAgICAgICh1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDgpICYgMFhGRixcbiAgICAgICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgJiAweEZGKSxcbiAgICAgICAgKGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMjQpLFxuICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAxNikgJiAwWEZGLFxuICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4KSAmIDBYRkYsXG4gICAgICAgIChsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhGRilcbiAgICAgIF0pKSxcbiAgICAgIE1QNC50cnVuKHRyYWNrLFxuICAgICAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAgICAgMTYgKyAvLyB0ZmhkXG4gICAgICAgICAgICAgICAgICAgIDIwICsgLy8gdGZkdFxuICAgICAgICAgICAgICAgICAgICA4ICsgLy8gdHJhZiBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgMTYgKyAvLyBtZmhkXG4gICAgICAgICAgICAgICAgICAgIDggKyAvLyBtb29mIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICA4KSwgLy8gbWRhdCBoZWFkZXJcbiAgICAgIHNhbXBsZURlcGVuZGVuY3lUYWJsZSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFjayBib3guXG4gICAqIEBwYXJhbSB0cmFjayB7b2JqZWN0fSBhIHRyYWNrIGRlZmluaXRpb25cbiAgICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIHRyYWNrIGJveFxuICAgKi9cbiAgc3RhdGljIHRyYWsgKHRyYWNrKSB7XG4gICAgdHJhY2suZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiB8fCAweGZmZmZmZmZmO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFrLCBNUDQudGtoZCh0cmFjayksIE1QNC5tZGlhKHRyYWNrKSk7XG4gIH1cblxuICBzdGF0aWMgdHJleCAodHJhY2spIHtcbiAgICBsZXQgaWQgPSB0cmFjay5pZDtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJleCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgKGlkID4+IDI0KSxcbiAgICAgIChpZCA+PiAxNikgJiAwWEZGLFxuICAgICAgKGlkID4+IDgpICYgMFhGRixcbiAgICAgIChpZCAmIDB4RkYpLCAvLyB0cmFja19JRFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9zaXplXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAxIC8vIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXG4gICAgXSkpO1xuICB9XG5cbiAgc3RhdGljIHRydW4gKHRyYWNrLCBvZmZzZXQpIHtcbiAgICBsZXQgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW10sXG4gICAgICBsZW4gPSBzYW1wbGVzLmxlbmd0aCxcbiAgICAgIGFycmF5bGVuID0gMTIgKyAoMTYgKiBsZW4pLFxuICAgICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheWxlbiksXG4gICAgICBpLCBzYW1wbGUsIGR1cmF0aW9uLCBzaXplLCBmbGFncywgY3RzO1xuICAgIG9mZnNldCArPSA4ICsgYXJyYXlsZW47XG4gICAgYXJyYXkuc2V0KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwZiwgMHgwMSwgLy8gZmxhZ3NcbiAgICAgIChsZW4gPj4+IDI0KSAmIDB4RkYsXG4gICAgICAobGVuID4+PiAxNikgJiAweEZGLFxuICAgICAgKGxlbiA+Pj4gOCkgJiAweEZGLFxuICAgICAgbGVuICYgMHhGRiwgLy8gc2FtcGxlX2NvdW50XG4gICAgICAob2Zmc2V0ID4+PiAyNCkgJiAweEZGLFxuICAgICAgKG9mZnNldCA+Pj4gMTYpICYgMHhGRixcbiAgICAgIChvZmZzZXQgPj4+IDgpICYgMHhGRixcbiAgICAgIG9mZnNldCAmIDB4RkYgLy8gZGF0YV9vZmZzZXRcbiAgICBdLCAwKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNhbXBsZSA9IHNhbXBsZXNbaV07XG4gICAgICBkdXJhdGlvbiA9IHNhbXBsZS5kdXJhdGlvbjtcbiAgICAgIHNpemUgPSBzYW1wbGUuc2l6ZTtcbiAgICAgIGZsYWdzID0gc2FtcGxlLmZsYWdzO1xuICAgICAgY3RzID0gc2FtcGxlLmN0cztcbiAgICAgIGFycmF5LnNldChbXG4gICAgICAgIChkdXJhdGlvbiA+Pj4gMjQpICYgMHhGRixcbiAgICAgICAgKGR1cmF0aW9uID4+PiAxNikgJiAweEZGLFxuICAgICAgICAoZHVyYXRpb24gPj4+IDgpICYgMHhGRixcbiAgICAgICAgZHVyYXRpb24gJiAweEZGLCAvLyBzYW1wbGVfZHVyYXRpb25cbiAgICAgICAgKHNpemUgPj4+IDI0KSAmIDB4RkYsXG4gICAgICAgIChzaXplID4+PiAxNikgJiAweEZGLFxuICAgICAgICAoc2l6ZSA+Pj4gOCkgJiAweEZGLFxuICAgICAgICBzaXplICYgMHhGRiwgLy8gc2FtcGxlX3NpemVcbiAgICAgICAgKGZsYWdzLmlzTGVhZGluZyA8PCAyKSB8IGZsYWdzLmRlcGVuZHNPbixcbiAgICAgICAgKGZsYWdzLmlzRGVwZW5kZWRPbiA8PCA2KSB8XG4gICAgICAgICAgKGZsYWdzLmhhc1JlZHVuZGFuY3kgPDwgNCkgfFxuICAgICAgICAgIChmbGFncy5wYWRkaW5nVmFsdWUgPDwgMSkgfFxuICAgICAgICAgIGZsYWdzLmlzTm9uU3luYyxcbiAgICAgICAgZmxhZ3MuZGVncmFkUHJpbyAmIDB4RjAgPDwgOCxcbiAgICAgICAgZmxhZ3MuZGVncmFkUHJpbyAmIDB4MEYsIC8vIHNhbXBsZV9mbGFnc1xuICAgICAgICAoY3RzID4+PiAyNCkgJiAweEZGLFxuICAgICAgICAoY3RzID4+PiAxNikgJiAweEZGLFxuICAgICAgICAoY3RzID4+PiA4KSAmIDB4RkYsXG4gICAgICAgIGN0cyAmIDB4RkYgLy8gc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XG4gICAgICBdLCAxMiArIDE2ICogaSk7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cnVuLCBhcnJheSk7XG4gIH1cblxuICBzdGF0aWMgaW5pdFNlZ21lbnQgKHRyYWNrcykge1xuICAgIGlmICghTVA0LnR5cGVzKSB7XG4gICAgICBNUDQuaW5pdCgpO1xuICAgIH1cblxuICAgIGxldCBtb3ZpZSA9IE1QNC5tb292KHRyYWNrcyksIHJlc3VsdDtcbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShNUDQuRlRZUC5ieXRlTGVuZ3RoICsgbW92aWUuYnl0ZUxlbmd0aCk7XG4gICAgcmVzdWx0LnNldChNUDQuRlRZUCk7XG4gICAgcmVzdWx0LnNldChtb3ZpZSwgTVA0LkZUWVAuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNUDQ7XG4iLCIvKipcbiAqIGZNUDQgcmVtdXhlclxuKi9cblxuaW1wb3J0IEFBQyBmcm9tICcuL2FhYy1oZWxwZXInO1xuaW1wb3J0IE1QNCBmcm9tICcuL21wNC1nZW5lcmF0b3InO1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbi8vIDEwIHNlY29uZHNcbmNvbnN0IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gPSAxMCAqIDEwMDA7XG5cbmNsYXNzIE1QNFJlbXV4ZXIge1xuICBjb25zdHJ1Y3RvciAob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCwgdmVuZG9yKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICB0aGlzLmlzU2FmYXJpID0gdmVuZG9yICYmIHZlbmRvci5pbmRleE9mKCdBcHBsZScpID4gLTEgJiYgdXNlckFnZW50ICYmICF1c2VyQWdlbnQubWF0Y2goJ0NyaU9TJyk7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gIH1cblxuICByZXNldFRpbWVTdGFtcCAoZGVmYXVsdFRpbWVTdGFtcCkge1xuICAgIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gZGVmYXVsdFRpbWVTdGFtcDtcbiAgfVxuXG4gIHJlc2V0SW5pdFNlZ21lbnQgKCkge1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHJlbXV4IChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICAvLyBnZW5lcmF0ZSBJbml0IFNlZ21lbnQgaWYgbmVlZGVkXG4gICAgaWYgKCF0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgIGNvbnN0IG5iQXVkaW9TYW1wbGVzID0gYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG5iVmlkZW9TYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aDtcbiAgICAgIGxldCBhdWRpb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgICAgbGV0IHZpZGVvVGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG4gICAgICBpZiAobmJBdWRpb1NhbXBsZXMgJiYgbmJWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgLy8gdGltZU9mZnNldCBpcyBleHBlY3RlZCB0byBiZSB0aGUgb2Zmc2V0IG9mIHRoZSBmaXJzdCB0aW1lc3RhbXAgb2YgdGhpcyBmcmFnbWVudCAoZmlyc3QgRFRTKVxuICAgICAgICAvLyBpZiBmaXJzdCBhdWRpbyBEVFMgaXMgbm90IGFsaWduZWQgd2l0aCBmaXJzdCB2aWRlbyBEVFMgdGhlbiB3ZSBuZWVkIHRvIHRha2UgdGhhdCBpbnRvIGFjY291bnRcbiAgICAgICAgLy8gd2hlbiBwcm92aWRpbmcgdGltZU9mZnNldCB0byByZW11eEF1ZGlvIC8gcmVtdXhWaWRlby4gaWYgd2UgZG9uJ3QgZG8gdGhhdCwgdGhlcmUgbWlnaHQgYmUgYSBwZXJtYW5lbnQgLyBzbWFsbFxuICAgICAgICAvLyBkcmlmdCBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbyBzdHJlYW1zXG4gICAgICAgIGxldCBhdWRpb3ZpZGVvRGVsdGFEdHMgPSAoYXVkaW9UcmFjay5zYW1wbGVzWzBdLnB0cyAtIHZpZGVvVHJhY2suc2FtcGxlc1swXS5wdHMpIC8gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgYXVkaW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIGF1ZGlvdmlkZW9EZWx0YUR0cyk7XG4gICAgICAgIHZpZGVvVGltZU9mZnNldCArPSBNYXRoLm1heCgwLCAtYXVkaW92aWRlb0RlbHRhRHRzKTtcbiAgICAgIH1cbiAgICAgIC8vIFB1cnBvc2VmdWxseSByZW11eGluZyBhdWRpbyBiZWZvcmUgdmlkZW8sIHNvIHRoYXQgcmVtdXhWaWRlbyBjYW4gdXNlIG5leHRBdWRpb1B0cywgd2hpY2ggaXNcbiAgICAgIC8vIGNhbGN1bGF0ZWQgaW4gcmVtdXhBdWRpby5cbiAgICAgIC8vIGxvZ2dlci5sb2coJ25iIEFBQyBzYW1wbGVzOicgKyBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICAgIGlmIChuYkF1ZGlvU2FtcGxlcykge1xuICAgICAgICAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgdmlkZW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxuICAgICAgICBpZiAoIWF1ZGlvVHJhY2sudGltZXNjYWxlKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ3JlZ2VuZXJhdGUgSW5pdFNlZ21lbnQgYXMgYXVkaW8gZGV0ZWN0ZWQnKTtcbiAgICAgICAgICB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGF1ZGlvRGF0YSA9IHRoaXMucmVtdXhBdWRpbyhhdWRpb1RyYWNrLCBhdWRpb1RpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ25iIEFWQyBzYW1wbGVzOicgKyB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKG5iVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgICAgbGV0IGF1ZGlvVHJhY2tMZW5ndGg7XG4gICAgICAgICAgaWYgKGF1ZGlvRGF0YSkge1xuICAgICAgICAgICAgYXVkaW9UcmFja0xlbmd0aCA9IGF1ZGlvRGF0YS5lbmRQVFMgLSBhdWRpb0RhdGEuc3RhcnRQVFM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IHZpZGVvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cbiAgICAgICAgICBpZiAoIXZpZGVvVHJhY2sudGltZXNjYWxlKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybigncmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyB2aWRlbyBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjaywgdmlkZW9UaW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhdWRpb1RyYWNrTGVuZ3RoLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsb2dnZXIubG9nKCduYiBBVkMgc2FtcGxlczonICsgdmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgICAgIGlmIChuYlZpZGVvU2FtcGxlcykge1xuICAgICAgICAgIGxldCB2aWRlb0RhdGEgPSB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjaywgdmlkZW9UaW1lT2Zmc2V0LCBjb250aWd1b3VzLCAwLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICAgIGlmICh2aWRlb0RhdGEgJiYgYXVkaW9UcmFjay5jb2RlYykge1xuICAgICAgICAgICAgdGhpcy5yZW11eEVtcHR5QXVkaW8oYXVkaW9UcmFjaywgYXVkaW9UaW1lT2Zmc2V0LCBjb250aWd1b3VzLCB2aWRlb0RhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBsb2dnZXIubG9nKCduYiBJRDMgc2FtcGxlczonICsgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgaWYgKGlkM1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJlbXV4SUQzKGlkM1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICB9XG5cbiAgICAvLyBsb2dnZXIubG9nKCduYiBJRDMgc2FtcGxlczonICsgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgaWYgKHRleHRUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5yZW11eFRleHQodGV4dFRyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICB9XG5cbiAgICAvLyBub3RpZnkgZW5kIG9mIHBhcnNpbmdcbiAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTRUQpO1xuICB9XG5cbiAgZ2VuZXJhdGVJUyAoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCkge1xuICAgIGxldCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXIsXG4gICAgICBhdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXMsXG4gICAgICB2aWRlb1NhbXBsZXMgPSB2aWRlb1RyYWNrLnNhbXBsZXMsXG4gICAgICB0eXBlU3VwcG9ydGVkID0gdGhpcy50eXBlU3VwcG9ydGVkLFxuICAgICAgY29udGFpbmVyID0gJ2F1ZGlvL21wNCcsXG4gICAgICB0cmFja3MgPSB7fSxcbiAgICAgIGRhdGEgPSB7IHRyYWNrczogdHJhY2tzIH0sXG4gICAgICBjb21wdXRlUFRTRFRTID0gKHRoaXMuX2luaXRQVFMgPT09IHVuZGVmaW5lZCksXG4gICAgICBpbml0UFRTLCBpbml0RFRTO1xuXG4gICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gSW5maW5pdHk7XG4gICAgfVxuXG4gICAgaWYgKGF1ZGlvVHJhY2suY29uZmlnICYmIGF1ZGlvU2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIC8vIGxldCdzIHVzZSBhdWRpbyBzYW1wbGluZyByYXRlIGFzIE1QNCB0aW1lIHNjYWxlLlxuICAgICAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgdGhlcmUgaXMgYSBpbnRlZ2VyIG5iIG9mIGF1ZGlvIGZyYW1lcyBwZXIgYXVkaW8gc2FtcGxlICgxMDI0IGZvciBBQUMpXG4gICAgICAvLyB1c2luZyBhdWRpbyBzYW1wbGluZyByYXRlIGhlcmUgaGVscHMgaGF2aW5nIGFuIGludGVnZXIgTVA0IGZyYW1lIGR1cmF0aW9uXG4gICAgICAvLyB0aGlzIGF2b2lkcyBwb3RlbnRpYWwgcm91bmRpbmcgaXNzdWUgYW5kIEFWIHN5bmMgaXNzdWVcbiAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gYXVkaW9UcmFjay5zYW1wbGVyYXRlO1xuICAgICAgbG9nZ2VyLmxvZyhgYXVkaW8gc2FtcGxpbmcgcmF0ZSA6ICR7YXVkaW9UcmFjay5zYW1wbGVyYXRlfWApO1xuICAgICAgaWYgKCFhdWRpb1RyYWNrLmlzQUFDKSB7XG4gICAgICAgIGlmICh0eXBlU3VwcG9ydGVkLm1wZWcpIHsgLy8gQ2hyb21lIGFuZCBTYWZhcmlcbiAgICAgICAgICBjb250YWluZXIgPSAnYXVkaW8vbXBlZyc7XG4gICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVTdXBwb3J0ZWQubXAzKSB7IC8vIEZpcmVmb3hcbiAgICAgICAgICBhdWRpb1RyYWNrLmNvZGVjID0gJ21wMyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyYWNrcy5hdWRpbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIGNvZGVjOiBhdWRpb1RyYWNrLmNvZGVjLFxuICAgICAgICBpbml0U2VnbWVudDogIWF1ZGlvVHJhY2suaXNBQUMgJiYgdHlwZVN1cHBvcnRlZC5tcGVnID8gbmV3IFVpbnQ4QXJyYXkoKSA6IE1QNC5pbml0U2VnbWVudChbYXVkaW9UcmFja10pLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGNoYW5uZWxDb3VudDogYXVkaW9UcmFjay5jaGFubmVsQ291bnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiB0aGlzIGRlbXV4aW5nIGNvbnRleHQuIGZvciBhdWRpbywgUFRTID0gRFRTXG4gICAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gYXVkaW9TYW1wbGVzWzBdLnB0cyAtIGF1ZGlvVHJhY2suaW5wdXRUaW1lU2NhbGUgKiB0aW1lT2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2aWRlb1RyYWNrLnNwcyAmJiB2aWRlb1RyYWNrLnBwcyAmJiB2aWRlb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAvLyBsZXQncyB1c2UgaW5wdXQgdGltZSBzY2FsZSBhcyBNUDQgdmlkZW8gdGltZXNjYWxlXG4gICAgICAvLyB3ZSB1c2UgaW5wdXQgdGltZSBzY2FsZSBzdHJhaWdodCBhd2F5IHRvIGF2b2lkIHJvdW5kaW5nIGlzc3VlcyBvbiBmcmFtZSBkdXJhdGlvbiAvIGN0cyBjb21wdXRhdGlvblxuICAgICAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgdmlkZW9UcmFjay50aW1lc2NhbGUgPSBpbnB1dFRpbWVTY2FsZTtcbiAgICAgIHRyYWNrcy52aWRlbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiAndmlkZW8vbXA0JyxcbiAgICAgICAgY29kZWM6IHZpZGVvVHJhY2suY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50OiBNUDQuaW5pdFNlZ21lbnQoW3ZpZGVvVHJhY2tdKSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICB3aWR0aDogdmlkZW9UcmFjay53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHZpZGVvVHJhY2suaGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICBpbml0UFRTID0gTWF0aC5taW4oaW5pdFBUUywgdmlkZW9TYW1wbGVzWzBdLnB0cyAtIGlucHV0VGltZVNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgIGluaXREVFMgPSBNYXRoLm1pbihpbml0RFRTLCB2aWRlb1NhbXBsZXNbMF0uZHRzIC0gaW5wdXRUaW1lU2NhbGUgKiB0aW1lT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LklOSVRfUFRTX0ZPVU5ELCB7IGluaXRQVFM6IGluaXRQVFMgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHRyYWNrcykubGVuZ3RoKSB7XG4gICAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIGRhdGEpO1xuICAgICAgdGhpcy5JU0dlbmVyYXRlZCA9IHRydWU7XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICB0aGlzLl9pbml0UFRTID0gaW5pdFBUUztcbiAgICAgICAgdGhpcy5faW5pdERUUyA9IGluaXREVFM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IGZhbHNlLCByZWFzb246ICdubyBhdWRpby92aWRlbyBzYW1wbGVzIGZvdW5kJyB9KTtcbiAgICB9XG4gIH1cblxuICByZW11eFZpZGVvICh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYXVkaW9UcmFja0xlbmd0aCwgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgbGV0IG9mZnNldCA9IDg7XG4gICAgbGV0IG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgIGxldCBtZGF0O1xuICAgIGxldCBtb29mO1xuICAgIGxldCBmaXJzdFBUUztcbiAgICBsZXQgZmlyc3REVFM7XG4gICAgbGV0IGxhc3RQVFM7XG4gICAgbGV0IGxhc3REVFM7XG4gICAgY29uc3QgdGltZVNjYWxlID0gdHJhY2sudGltZXNjYWxlO1xuICAgIGNvbnN0IGlucHV0U2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgY29uc3Qgb3V0cHV0U2FtcGxlcyA9IFtdO1xuICAgIGNvbnN0IG5iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7XG4gICAgY29uc3QgcHRzTm9ybWFsaXplID0gdGhpcy5fUFRTTm9ybWFsaXplO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuXG4gICAgLy8gaWYgcGFyc2VkIGZyYWdtZW50IGlzIGNvbnRpZ3VvdXMgd2l0aCBsYXN0IG9uZSwgbGV0J3MgdXNlIGxhc3QgRFRTIHZhbHVlIGFzIHJlZmVyZW5jZVxuICAgIGxldCBuZXh0QXZjRHRzID0gdGhpcy5uZXh0QXZjRHRzO1xuXG4gICAgY29uc3QgaXNTYWZhcmkgPSB0aGlzLmlzU2FmYXJpO1xuXG4gICAgaWYgKG5iU2FtcGxlcyA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNhZmFyaSBkb2VzIG5vdCBsaWtlIG92ZXJsYXBwaW5nIERUUyBvbiBjb25zZWN1dGl2ZSBmcmFnbWVudHMuIGxldCdzIHVzZSBuZXh0QXZjRHRzIHRvIG92ZXJjb21lIHRoaXMgaWYgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZVxuICAgIGlmIChpc1NhZmFyaSkge1xuICAgICAgLy8gYWxzbyBjb25zaWRlciBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXMgYmVpbmcgY29udGlndW91cyAoZXZlbiBpZiBhIGxldmVsIHN3aXRjaCBvY2N1cnMpLFxuICAgICAgLy8gZm9yIHNha2Ugb2YgY2xhcml0eTpcbiAgICAgIC8vIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcmUgZnJhZ3Mgd2l0aFxuICAgICAgLy8gIC0gbGVzcyB0aGFuIDEwMG1zIGdhcHMgYmV0d2VlbiBuZXcgdGltZSBvZmZzZXQgKGlmIGFjY3VyYXRlKSBhbmQgbmV4dCBleHBlY3RlZCBQVFMgT1JcbiAgICAgIC8vICAtIGxlc3MgdGhhbiAyMDAgbXMgUFRTIGdhcHMgKHRpbWVTY2FsZS81KVxuICAgICAgY29udGlndW91cyB8PSAoaW5wdXRTYW1wbGVzLmxlbmd0aCAmJiBuZXh0QXZjRHRzICYmXG4gICAgICAgICAgICAgICAgICAgICAoKGFjY3VyYXRlVGltZU9mZnNldCAmJiBNYXRoLmFicyh0aW1lT2Zmc2V0IC0gbmV4dEF2Y0R0cyAvIHRpbWVTY2FsZSkgPCAwLjEpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoKGlucHV0U2FtcGxlc1swXS5wdHMgLSBuZXh0QXZjRHRzIC0gaW5pdFBUUykpIDwgdGltZVNjYWxlIC8gNSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb250aWd1b3VzKSB7XG4gICAgICAvLyBpZiBub3QgY29udGlndW91cywgbGV0J3MgdXNlIHRhcmdldCB0aW1lT2Zmc2V0XG4gICAgICBuZXh0QXZjRHRzID0gdGltZU9mZnNldCAqIHRpbWVTY2FsZTtcbiAgICB9XG5cbiAgICAvLyBQVFMgaXMgY29kZWQgb24gMzNiaXRzLCBhbmQgY2FuIGxvb3AgZnJvbSAtMl4zMiB0byAyXjMyXG4gICAgLy8gcHRzTm9ybWFsaXplIHdpbGwgbWFrZSBQVFMvRFRTIHZhbHVlIG1vbm90b25pYywgd2UgdXNlIGxhc3Qga25vd24gRFRTIHZhbHVlIGFzIHJlZmVyZW5jZSB2YWx1ZVxuICAgIGlucHV0U2FtcGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgIHNhbXBsZS5wdHMgPSBwdHNOb3JtYWxpemUoc2FtcGxlLnB0cyAtIGluaXRQVFMsIG5leHRBdmNEdHMpO1xuICAgICAgc2FtcGxlLmR0cyA9IHB0c05vcm1hbGl6ZShzYW1wbGUuZHRzIC0gaW5pdFBUUywgbmV4dEF2Y0R0cyk7XG4gICAgfSk7XG5cbiAgICAvLyBzb3J0IHZpZGVvIHNhbXBsZXMgYnkgRFRTIHRoZW4gUFRTIHRoZW4gZGVtdXggaWQgb3JkZXJcbiAgICBpbnB1dFNhbXBsZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgY29uc3QgZGVsdGFkdHMgPSBhLmR0cyAtIGIuZHRzO1xuICAgICAgY29uc3QgZGVsdGFwdHMgPSBhLnB0cyAtIGIucHRzO1xuICAgICAgcmV0dXJuIGRlbHRhZHRzIHx8IChkZWx0YXB0cyB8fCAoYS5pZCAtIGIuaWQpKTtcbiAgICB9KTtcblxuICAgIC8vIGhhbmRsZSBicm9rZW4gc3RyZWFtcyB3aXRoIFBUUyA8IERUUywgdG9sZXJhbmNlIHVwIDIwMG1zICgxODAwMCBpbiA5MGtIeiB0aW1lc2NhbGUpXG4gICAgbGV0IFBUU0RUU3NoaWZ0ID0gaW5wdXRTYW1wbGVzLnJlZHVjZSgocHJldiwgY3VycikgPT4gTWF0aC5tYXgoTWF0aC5taW4ocHJldiwgY3Vyci5wdHMgLSBjdXJyLmR0cyksIC0xODAwMCksIDApO1xuICAgIGlmIChQVFNEVFNzaGlmdCA8IDApIHtcbiAgICAgIGxvZ2dlci53YXJuKGBQVFMgPCBEVFMgZGV0ZWN0ZWQgaW4gdmlkZW8gc2FtcGxlcywgc2hpZnRpbmcgRFRTIGJ5ICR7TWF0aC5yb3VuZChQVFNEVFNzaGlmdCAvIDkwKX0gbXMgdG8gb3ZlcmNvbWUgdGhpcyBpc3N1ZWApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW5wdXRTYW1wbGVzW2ldLmR0cyArPSBQVFNEVFNzaGlmdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIGZpcnN0IERUUyBhbmQgbGFzdCBEVFMsIG5vcm1hbGl6ZSB0aGVtIGFnYWluc3QgcmVmZXJlbmNlIHZhbHVlXG4gICAgbGV0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1swXTtcbiAgICBmaXJzdERUUyA9IE1hdGgubWF4KHNhbXBsZS5kdHMsIDApO1xuICAgIGZpcnN0UFRTID0gTWF0aC5tYXgoc2FtcGxlLnB0cywgMCk7XG5cbiAgICAvLyBjaGVjayB0aW1lc3RhbXAgY29udGludWl0eSBhY2Nyb3NzIGNvbnNlY3V0aXZlIGZyYWdtZW50cyAodGhpcyBpcyB0byByZW1vdmUgaW50ZXItZnJhZ21lbnQgZ2FwL2hvbGUpXG4gICAgbGV0IGRlbHRhID0gTWF0aC5yb3VuZCgoZmlyc3REVFMgLSBuZXh0QXZjRHRzKSAvIDkwKTtcbiAgICAvLyBpZiBmcmFnbWVudCBhcmUgY29udGlndW91cywgZGV0ZWN0IGhvbGUvb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHNcbiAgICBpZiAoY29udGlndW91cykge1xuICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgIGlmIChkZWx0YSA+IDEpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBBVkM6JHtkZWx0YX0gbXMgaG9sZSBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZCxmaWxsaW5nIGl0YCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPCAtMSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coYEFWQzokeygtZGVsdGEpfSBtcyBvdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGhvbGUvZ2FwIDogc2V0IERUUyB0byBuZXh0IGV4cGVjdGVkIERUU1xuICAgICAgICBmaXJzdERUUyA9IG5leHRBdmNEdHM7XG4gICAgICAgIGlucHV0U2FtcGxlc1swXS5kdHMgPSBmaXJzdERUUztcbiAgICAgICAgLy8gb2Zmc2V0IFBUUyBhcyB3ZWxsLCBlbnN1cmUgdGhhdCBQVFMgaXMgc21hbGxlciBvciBlcXVhbCB0aGFuIG5ldyBEVFNcbiAgICAgICAgZmlyc3RQVFMgPSBNYXRoLm1heChmaXJzdFBUUyAtIGRlbHRhLCBuZXh0QXZjRHRzKTtcbiAgICAgICAgaW5wdXRTYW1wbGVzWzBdLnB0cyA9IGZpcnN0UFRTO1xuICAgICAgICBsb2dnZXIubG9nKGBWaWRlby9QVFMvRFRTIGFkanVzdGVkOiAke01hdGgucm91bmQoZmlyc3RQVFMgLyA5MCl9LyR7TWF0aC5yb3VuZChmaXJzdERUUyAvIDkwKX0sZGVsdGE6JHtkZWx0YX0gbXNgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIGxhc3RQVFMvbGFzdERUU1xuICAgIHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpbnB1dFNhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgbGFzdERUUyA9IE1hdGgubWF4KHNhbXBsZS5kdHMsIDApO1xuICAgIGxhc3RQVFMgPSBNYXRoLm1heChzYW1wbGUucHRzLCAwLCBsYXN0RFRTKTtcblxuICAgIC8vIG9uIFNhZmFyaSBsZXQncyBzaWduYWwgdGhlIHNhbWUgc2FtcGxlIGR1cmF0aW9uIGZvciBhbGwgc2FtcGxlc1xuICAgIC8vIHNhbXBsZSBkdXJhdGlvbiAoYXMgZXhwZWN0ZWQgYnkgdHJ1biBNUDQgYm94ZXMpLCBzaG91bGQgYmUgdGhlIGRlbHRhIGJldHdlZW4gc2FtcGxlIERUU1xuICAgIC8vIHNldCB0aGlzIGNvbnN0YW50IGR1cmF0aW9uIGFzIGJlaW5nIHRoZSBhdmcgZGVsdGEgYmV0d2VlbiBjb25zZWN1dGl2ZSBEVFMuXG4gICAgaWYgKGlzU2FmYXJpKSB7XG4gICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IE1hdGgucm91bmQoKGxhc3REVFMgLSBmaXJzdERUUykgLyAoaW5wdXRTYW1wbGVzLmxlbmd0aCAtIDEpKTtcbiAgICB9XG5cbiAgICBsZXQgbmJOYWx1ID0gMCwgbmFsdUxlbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgLy8gY29tcHV0ZSB0b3RhbC9hdmMgc2FtcGxlIGxlbmd0aCBhbmQgbmIgb2YgTkFMIHVuaXRzXG4gICAgICBsZXQgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldLCB1bml0cyA9IHNhbXBsZS51bml0cywgbmJVbml0cyA9IHVuaXRzLmxlbmd0aCwgc2FtcGxlTGVuID0gMDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmJVbml0czsgaisrKSB7XG4gICAgICAgIHNhbXBsZUxlbiArPSB1bml0c1tqXS5kYXRhLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgbmFsdUxlbiArPSBzYW1wbGVMZW47XG4gICAgICBuYk5hbHUgKz0gbmJVbml0cztcbiAgICAgIHNhbXBsZS5sZW5ndGggPSBzYW1wbGVMZW47XG5cbiAgICAgIC8vIG5vcm1hbGl6ZSBQVFMvRFRTXG4gICAgICBpZiAoaXNTYWZhcmkpIHtcbiAgICAgICAgLy8gc2FtcGxlIERUUyBpcyBjb21wdXRlZCB1c2luZyBhIGNvbnN0YW50IGRlY29kaW5nIG9mZnNldCAobXA0U2FtcGxlRHVyYXRpb24pIGJldHdlZW4gc2FtcGxlc1xuICAgICAgICBzYW1wbGUuZHRzID0gZmlyc3REVFMgKyBpICogbXA0U2FtcGxlRHVyYXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbnN1cmUgc2FtcGxlIG1vbm90b25pYyBEVFNcbiAgICAgICAgc2FtcGxlLmR0cyA9IE1hdGgubWF4KHNhbXBsZS5kdHMsIGZpcnN0RFRTKTtcbiAgICAgIH1cbiAgICAgIC8vIGVuc3VyZSB0aGF0IGNvbXB1dGVkIHZhbHVlIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiBzYW1wbGUgRFRTXG4gICAgICBzYW1wbGUucHRzID0gTWF0aC5tYXgoc2FtcGxlLnB0cywgc2FtcGxlLmR0cyk7XG4gICAgfVxuXG4gICAgLyogY29uY2F0ZW5hdGUgdGhlIHZpZGVvIGRhdGEgYW5kIGNvbnN0cnVjdCB0aGUgbWRhdCBpbiBwbGFjZVxuICAgICAgKG5lZWQgOCBtb3JlIGJ5dGVzIHRvIGZpbGwgbGVuZ3RoIGFuZCBtcGRhdCB0eXBlKSAqL1xuICAgIGxldCBtZGF0U2l6ZSA9IG5hbHVMZW4gKyAoNCAqIG5iTmFsdSkgKyA4O1xuICAgIHRyeSB7XG4gICAgICBtZGF0ID0gbmV3IFVpbnQ4QXJyYXkobWRhdFNpemUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTVVYX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1IsIGZhdGFsOiBmYWxzZSwgYnl0ZXM6IG1kYXRTaXplLCByZWFzb246IGBmYWlsIGFsbG9jYXRpbmcgdmlkZW8gbWRhdCAke21kYXRTaXplfWAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcbiAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgbWRhdC5zZXQoTVA0LnR5cGVzLm1kYXQsIDQpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgbGV0IGF2Y1NhbXBsZSA9IGlucHV0U2FtcGxlc1tpXSxcbiAgICAgICAgYXZjU2FtcGxlVW5pdHMgPSBhdmNTYW1wbGUudW5pdHMsXG4gICAgICAgIG1wNFNhbXBsZUxlbmd0aCA9IDAsXG4gICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldDtcbiAgICAgIC8vIGNvbnZlcnQgTkFMVSBiaXRzdHJlYW0gdG8gTVA0IGZvcm1hdCAocHJlcGVuZCBOQUxVIHdpdGggc2l6ZSBmaWVsZClcbiAgICAgIGZvciAobGV0IGogPSAwLCBuYlVuaXRzID0gYXZjU2FtcGxlVW5pdHMubGVuZ3RoOyBqIDwgbmJVbml0czsgaisrKSB7XG4gICAgICAgIGxldCB1bml0ID0gYXZjU2FtcGxlVW5pdHNbal0sXG4gICAgICAgICAgdW5pdERhdGEgPSB1bml0LmRhdGEsXG4gICAgICAgICAgdW5pdERhdGFMZW4gPSB1bml0LmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCB1bml0RGF0YUxlbik7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICBtZGF0LnNldCh1bml0RGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IHVuaXREYXRhTGVuO1xuICAgICAgICBtcDRTYW1wbGVMZW5ndGggKz0gNCArIHVuaXREYXRhTGVuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzU2FmYXJpKSB7XG4gICAgICAgIC8vIGV4cGVjdGVkIHNhbXBsZSBkdXJhdGlvbiBpcyB0aGUgRGVjb2RpbmcgVGltZXN0YW1wIGRpZmYgb2YgY29uc2VjdXRpdmUgc2FtcGxlc1xuICAgICAgICBpZiAoaSA8IG5iU2FtcGxlcyAtIDEpIHtcbiAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGlucHV0U2FtcGxlc1tpICsgMV0uZHRzIC0gYXZjU2FtcGxlLmR0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgICAgICBsYXN0RnJhbWVEdXJhdGlvbiA9IGF2Y1NhbXBsZS5kdHMgLSBpbnB1dFNhbXBsZXNbaSA+IDAgPyBpIC0gMSA6IGldLmR0cztcbiAgICAgICAgICBpZiAoY29uZmlnLnN0cmV0Y2hTaG9ydFZpZGVvVHJhY2spIHtcbiAgICAgICAgICAgIC8vIEluIHNvbWUgY2FzZXMsIGEgc2VnbWVudCdzIGF1ZGlvIHRyYWNrIGR1cmF0aW9uIG1heSBleGNlZWQgdGhlIHZpZGVvIHRyYWNrIGR1cmF0aW9uLlxuICAgICAgICAgICAgLy8gU2luY2Ugd2UndmUgYWxyZWFkeSByZW11eGVkIGF1ZGlvLCBhbmQgd2Uga25vdyBob3cgbG9uZyB0aGUgYXVkaW8gdHJhY2sgaXMsIHdlIGxvb2sgdG9cbiAgICAgICAgICAgIC8vIHNlZSBpZiB0aGUgZGVsdGEgdG8gdGhlIG5leHQgc2VnbWVudCBpcyBsb25nZXIgdGhhbiBtYXhCdWZmZXJIb2xlLlxuICAgICAgICAgICAgLy8gSWYgc28sIHBsYXliYWNrIHdvdWxkIHBvdGVudGlhbGx5IGdldCBzdHVjaywgc28gd2UgYXJ0aWZpY2lhbGx5IGluZmxhdGVcbiAgICAgICAgICAgIC8vIHRoZSBkdXJhdGlvbiBvZiB0aGUgbGFzdCBmcmFtZSB0byBtaW5pbWl6ZSBhbnkgcG90ZW50aWFsIGdhcCBiZXR3ZWVuIHNlZ21lbnRzLlxuICAgICAgICAgICAgbGV0IG1heEJ1ZmZlckhvbGUgPSBjb25maWcubWF4QnVmZmVySG9sZSxcbiAgICAgICAgICAgICAgZ2FwVG9sZXJhbmNlID0gTWF0aC5mbG9vcihtYXhCdWZmZXJIb2xlICogdGltZVNjYWxlKSxcbiAgICAgICAgICAgICAgZGVsdGFUb0ZyYW1lRW5kID0gKGF1ZGlvVHJhY2tMZW5ndGggPyBmaXJzdFBUUyArIGF1ZGlvVHJhY2tMZW5ndGggKiB0aW1lU2NhbGUgOiB0aGlzLm5leHRBdWRpb1B0cykgLSBhdmNTYW1wbGUucHRzO1xuICAgICAgICAgICAgaWYgKGRlbHRhVG9GcmFtZUVuZCA+IGdhcFRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAvLyBXZSBzdWJ0cmFjdCBsYXN0RnJhbWVEdXJhdGlvbiBmcm9tIGRlbHRhVG9GcmFtZUVuZCB0byB0cnkgdG8gcHJldmVudCBhbnkgdmlkZW9cbiAgICAgICAgICAgICAgLy8gZnJhbWUgb3ZlcmxhcC4gbWF4QnVmZmVySG9sZSBzaG91bGQgYmUgPj4gbGFzdEZyYW1lRHVyYXRpb24gYW55d2F5LlxuICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGRlbHRhVG9GcmFtZUVuZCAtIGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgICBpZiAobXA0U2FtcGxlRHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYEl0IGlzIGFwcHJveGltYXRlbHkgJHtkZWx0YVRvRnJhbWVFbmQgLyA5MH0gbXMgdG8gdGhlIG5leHQgc2VnbWVudDsgdXNpbmcgZHVyYXRpb24gJHttcDRTYW1wbGVEdXJhdGlvbiAvIDkwfSBtcyBmb3IgdGhlIGxhc3QgdmlkZW8gZnJhbWUuYCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXQgPSBNYXRoLnJvdW5kKGF2Y1NhbXBsZS5wdHMgLSBhdmNTYW1wbGUuZHRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IE1hdGgubWF4KDAsIG1wNFNhbXBsZUR1cmF0aW9uICogTWF0aC5yb3VuZCgoYXZjU2FtcGxlLnB0cyAtIGF2Y1NhbXBsZS5kdHMpIC8gbXA0U2FtcGxlRHVyYXRpb24pKTtcbiAgICAgIH1cblxuICAgICAgLy8gY29uc29sZS5sb2coJ1BUUy9EVFMvaW5pdERUUy9ub3JtUFRTL25vcm1EVFMvcmVsYXRpdmUgUFRTIDogJHthdmNTYW1wbGUucHRzfS8ke2F2Y1NhbXBsZS5kdHN9LyR7aW5pdERUU30vJHtwdHNub3JtfS8ke2R0c25vcm19LyR7KGF2Y1NhbXBsZS5wdHMvNDI5NDk2NzI5NikudG9GaXhlZCgzKX0nKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBhdmNTYW1wbGUuZHRzOiAke2F2Y1NhbXBsZS5kdHMgLyA5MH0sIGF2Y1NhbXBsZS5wdHM6ICR7YXZjU2FtcGxlLnB0cyAvIDkwfSwgbXA0U2FtcGxlRHVyYXRpb246ICR7bXA0U2FtcGxlRHVyYXRpb24gLyA5MH1gLCBhdmNTYW1wbGUpXG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2goe1xuICAgICAgICBzaXplOiBtcDRTYW1wbGVMZW5ndGgsXG4gICAgICAgIC8vIGNvbnN0YW50IGR1cmF0aW9uXG4gICAgICAgIGR1cmF0aW9uOiBtcDRTYW1wbGVEdXJhdGlvbixcbiAgICAgICAgY3RzOiBjb21wb3NpdGlvblRpbWVPZmZzZXQsXG4gICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgaXNMZWFkaW5nOiAwLFxuICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgICAgIGRlZ3JhZFByaW86IDAsXG4gICAgICAgICAgZGVwZW5kc09uOiBhdmNTYW1wbGUua2V5ID8gMiA6IDEsXG4gICAgICAgICAgaXNOb25TeW5jOiBhdmNTYW1wbGUua2V5ID8gMCA6IDFcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIG5leHQgQVZDIHNhbXBsZSBEVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIERUUyArIGxhc3Qgc2FtcGxlIGR1cmF0aW9uIChpbiBQRVMgdGltZXNjYWxlKVxuICAgIHRoaXMubmV4dEF2Y0R0cyA9IGxhc3REVFMgKyBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICBsZXQgZHJvcHBlZCA9IHRyYWNrLmRyb3BwZWQ7XG4gICAgdHJhY2subGVuID0gMDtcbiAgICB0cmFjay5uYk5hbHUgPSAwO1xuICAgIHRyYWNrLmRyb3BwZWQgPSAwO1xuICAgIGlmIChvdXRwdXRTYW1wbGVzLmxlbmd0aCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY2hyb21lJykgPiAtMSkge1xuICAgICAgbGV0IGZsYWdzID0gb3V0cHV0U2FtcGxlc1swXS5mbGFncztcbiAgICAgIC8vIGNocm9tZSB3b3JrYXJvdW5kLCBtYXJrIGZpcnN0IHNhbXBsZSBhcyBiZWluZyBhIFJhbmRvbSBBY2Nlc3MgUG9pbnQgdG8gYXZvaWQgc291cmNlYnVmZmVyIGFwcGVuZCBpc3N1ZVxuICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTQxMlxuICAgICAgZmxhZ3MuZGVwZW5kc09uID0gMjtcbiAgICAgIGZsYWdzLmlzTm9uU3luYyA9IDA7XG4gICAgfVxuICAgIHRyYWNrLnNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzO1xuICAgIG1vb2YgPSBNUDQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdERUUywgdHJhY2spO1xuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcblxuICAgIGxldCBkYXRhID0ge1xuICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICBkYXRhMjogbWRhdCxcbiAgICAgIHN0YXJ0UFRTOiBmaXJzdFBUUyAvIHRpbWVTY2FsZSxcbiAgICAgIGVuZFBUUzogKGxhc3RQVFMgKyBtcDRTYW1wbGVEdXJhdGlvbikgLyB0aW1lU2NhbGUsXG4gICAgICBzdGFydERUUzogZmlyc3REVFMgLyB0aW1lU2NhbGUsXG4gICAgICBlbmREVFM6IHRoaXMubmV4dEF2Y0R0cyAvIHRpbWVTY2FsZSxcbiAgICAgIHR5cGU6ICd2aWRlbycsXG4gICAgICBoYXNBdWRpbzogZmFsc2UsXG4gICAgICBoYXNWaWRlbzogdHJ1ZSxcbiAgICAgIG5iOiBvdXRwdXRTYW1wbGVzLmxlbmd0aCxcbiAgICAgIGRyb3BwZWQ6IGRyb3BwZWRcbiAgICB9O1xuICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfREFUQSwgZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICByZW11eEF1ZGlvICh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBtcDR0aW1lU2NhbGUgPSB0cmFjay50aW1lc2NhbGU7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZTtcbiAgICBjb25zdCBtcDRTYW1wbGVEdXJhdGlvbiA9IHRyYWNrLmlzQUFDID8gMTAyNCA6IDExNTI7XG4gICAgY29uc3QgaW5wdXRTYW1wbGVEdXJhdGlvbiA9IG1wNFNhbXBsZUR1cmF0aW9uICogc2NhbGVGYWN0b3I7XG4gICAgY29uc3QgcHRzTm9ybWFsaXplID0gdGhpcy5fUFRTTm9ybWFsaXplO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgIGNvbnN0IHJhd01QRUcgPSAhdHJhY2suaXNBQUMgJiYgdGhpcy50eXBlU3VwcG9ydGVkLm1wZWc7XG5cbiAgICBsZXQgb2Zmc2V0LFxuICAgICAgbXA0U2FtcGxlLFxuICAgICAgZmlsbEZyYW1lLFxuICAgICAgbWRhdCwgbW9vZixcbiAgICAgIGZpcnN0UFRTLCBsYXN0UFRTLFxuICAgICAgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcyxcbiAgICAgIG91dHB1dFNhbXBsZXMgPSBbXSxcbiAgICAgIG5leHRBdWRpb1B0cyA9IHRoaXMubmV4dEF1ZGlvUHRzO1xuXG4gICAgLy8gZm9yIGF1ZGlvIHNhbXBsZXMsIGFsc28gY29uc2lkZXIgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFzIGJlaW5nIGNvbnRpZ3VvdXMgKGV2ZW4gaWYgYSBsZXZlbCBzd2l0Y2ggb2NjdXJzKSxcbiAgICAvLyBmb3Igc2FrZSBvZiBjbGFyaXR5OlxuICAgIC8vIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcmUgZnJhZ3Mgd2l0aFxuICAgIC8vICAtIGxlc3MgdGhhbiAxMDBtcyBnYXBzIGJldHdlZW4gbmV3IHRpbWUgb2Zmc2V0IChpZiBhY2N1cmF0ZSkgYW5kIG5leHQgZXhwZWN0ZWQgUFRTIE9SXG4gICAgLy8gIC0gbGVzcyB0aGFuIDIwIGF1ZGlvIGZyYW1lcyBkaXN0YW5jZVxuICAgIC8vIGNvbnRpZ3VvdXMgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZSBmcmFnbWVudHMgZnJvbSBzYW1lIHF1YWxpdHkgbGV2ZWwgKHNhbWUgbGV2ZWwsIG5ldyBTTiA9IG9sZCBTTiArIDEpXG4gICAgLy8gdGhpcyBoZWxwcyBlbnN1cmluZyBhdWRpbyBjb250aW51aXR5XG4gICAgLy8gYW5kIHRoaXMgYWxzbyBhdm9pZHMgYXVkaW8gZ2xpdGNoZXMvY3V0IHdoZW4gc3dpdGNoaW5nIHF1YWxpdHksIG9yIHJlcG9ydGluZyB3cm9uZyBkdXJhdGlvbiBvbiBmaXJzdCBhdWRpbyBmcmFtZVxuICAgIGNvbnRpZ3VvdXMgfD0gKGlucHV0U2FtcGxlcy5sZW5ndGggJiYgbmV4dEF1ZGlvUHRzICYmXG4gICAgICAgICAgICAgICAgICAgKChhY2N1cmF0ZVRpbWVPZmZzZXQgJiYgTWF0aC5hYnModGltZU9mZnNldCAtIG5leHRBdWRpb1B0cyAvIGlucHV0VGltZVNjYWxlKSA8IDAuMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoKGlucHV0U2FtcGxlc1swXS5wdHMgLSBuZXh0QXVkaW9QdHMgLSBpbml0UFRTKSkgPCAyMCAqIGlucHV0U2FtcGxlRHVyYXRpb24pXG4gICAgKTtcblxuICAgIC8vIGNvbXB1dGUgbm9ybWFsaXplZCBQVFNcbiAgICBpbnB1dFNhbXBsZXMuZm9yRWFjaChmdW5jdGlvbiAoc2FtcGxlKSB7XG4gICAgICBzYW1wbGUucHRzID0gc2FtcGxlLmR0cyA9IHB0c05vcm1hbGl6ZShzYW1wbGUucHRzIC0gaW5pdFBUUywgdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlKTtcbiAgICB9KTtcblxuICAgIC8vIGZpbHRlciBvdXQgc2FtcGxlIHdpdGggbmVnYXRpdmUgUFRTIHRoYXQgYXJlIG5vdCBwbGF5YWJsZSBhbnl3YXlcbiAgICAvLyBpZiB3ZSBkb24ndCByZW1vdmUgdGhlc2UgbmVnYXRpdmUgc2FtcGxlcywgdGhleSB3aWxsIHNoaWZ0IGFsbCBhdWRpbyBzYW1wbGVzIGZvcndhcmQuXG4gICAgLy8gbGVhZGluZyB0byBhdWRpbyBvdmVybGFwIGJldHdlZW4gY3VycmVudCAvIG5leHQgZnJhZ21lbnRcbiAgICBpbnB1dFNhbXBsZXMgPSBpbnB1dFNhbXBsZXMuZmlsdGVyKGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgIHJldHVybiBzYW1wbGUucHRzID49IDA7XG4gICAgfSk7XG5cbiAgICAvLyBpbiBjYXNlIGFsbCBzYW1wbGVzIGhhdmUgbmVnYXRpdmUgUFRTLCBhbmQgaGF2ZSBiZWVuIGZpbHRlcmVkIG91dCwgcmV0dXJuIG5vd1xuICAgIGlmIChpbnB1dFNhbXBsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFjb250aWd1b3VzKSB7XG4gICAgICBpZiAoIWFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgICAvLyBpZiBmcmFnIGFyZSBtb3QgY29udGlndW91cyBhbmQgaWYgd2UgY2FudCB0cnVzdCB0aW1lIG9mZnNldCwgbGV0J3MgdXNlIGZpcnN0IHNhbXBsZSBQVFMgYXMgbmV4dCBhdWRpbyBQVFNcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gaW5wdXRTYW1wbGVzWzBdLnB0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHRpbWVPZmZzZXQgaXMgYWNjdXJhdGUsIGxldCdzIHVzZSBpdCBhcyBwcmVkaWN0ZWQgbmV4dCBhdWRpbyBQVFNcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBhdWRpbyB0cmFjayBpcyBtaXNzaW5nIHNhbXBsZXMsIHRoZSBmcmFtZXMgc2VlbSB0byBnZXQgXCJsZWZ0LXNoaWZ0ZWRcIiB3aXRoaW4gdGhlXG4gICAgLy8gcmVzdWx0aW5nIG1wNCBzZWdtZW50LCBjYXVzaW5nIHN5bmMgaXNzdWVzIGFuZCBsZWF2aW5nIGdhcHMgYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gc2VnbWVudC5cbiAgICAvLyBJbiBhbiBlZmZvcnQgdG8gcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nLCB3ZSBpbmplY3QgZnJhbWVzIGhlcmUgd2hlcmUgdGhlcmUgYXJlIGdhcHMuXG4gICAgLy8gV2hlbiBwb3NzaWJsZSwgd2UgaW5qZWN0IGEgc2lsZW50IGZyYW1lOyB3aGVuIHRoYXQncyBub3QgcG9zc2libGUsIHdlIGR1cGxpY2F0ZSB0aGUgbGFzdFxuICAgIC8vIGZyYW1lLlxuXG4gICAgaWYgKHRyYWNrLmlzQUFDKSB7XG4gICAgICBjb25zdCBtYXhBdWRpb0ZyYW1lc0RyaWZ0ID0gdGhpcy5jb25maWcubWF4QXVkaW9GcmFtZXNEcmlmdDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBuZXh0UHRzID0gbmV4dEF1ZGlvUHRzOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDspIHtcbiAgICAgICAgLy8gRmlyc3QsIGxldCdzIHNlZSBob3cgZmFyIG9mZiB0aGlzIGZyYW1lIGlzIGZyb20gd2hlcmUgd2UgZXhwZWN0IGl0IHRvIGJlXG4gICAgICAgIHZhciBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV0sIGRlbHRhO1xuICAgICAgICBsZXQgcHRzID0gc2FtcGxlLnB0cztcbiAgICAgICAgZGVsdGEgPSBwdHMgLSBuZXh0UHRzO1xuXG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gTWF0aC5hYnMoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpO1xuXG4gICAgICAgIC8vIElmIHdlJ3JlIG92ZXJsYXBwaW5nIGJ5IG1vcmUgdGhhbiBhIGR1cmF0aW9uLCBkcm9wIHRoaXMgc2FtcGxlXG4gICAgICAgIGlmIChkZWx0YSA8PSAtbWF4QXVkaW9GcmFtZXNEcmlmdCAqIGlucHV0U2FtcGxlRHVyYXRpb24pIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgRHJvcHBpbmcgMSBhdWRpbyBmcmFtZSBAICR7KG5leHRQdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKX1zIGR1ZSB0byAke01hdGgucm91bmQoZHVyYXRpb24pfSBtcyBvdmVybGFwLmApO1xuICAgICAgICAgIGlucHV0U2FtcGxlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgdHJhY2subGVuIC09IHNhbXBsZS51bml0Lmxlbmd0aDtcbiAgICAgICAgICAvLyBEb24ndCB0b3VjaCBuZXh0UHRzTm9ybSBvciBpXG4gICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBicmFjZS1zdHlsZVxuXG4gICAgICAgIC8vIEluc2VydCBtaXNzaW5nIGZyYW1lcyBpZjpcbiAgICAgICAgLy8gMTogV2UncmUgbW9yZSB0aGFuIG1heEF1ZGlvRnJhbWVzRHJpZnQgZnJhbWUgYXdheVxuICAgICAgICAvLyAyOiBOb3QgbW9yZSB0aGFuIE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gYXdheVxuICAgICAgICAvLyAzOiBjdXJyZW50VGltZSAoYWthIG5leHRQdHNOb3JtKSBpcyBub3QgMFxuICAgICAgICBlbHNlIGlmIChkZWx0YSA+PSBtYXhBdWRpb0ZyYW1lc0RyaWZ0ICogaW5wdXRTYW1wbGVEdXJhdGlvbiAmJiBkdXJhdGlvbiA8IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gJiYgbmV4dFB0cykge1xuICAgICAgICAgIGxldCBtaXNzaW5nID0gTWF0aC5yb3VuZChkZWx0YSAvIGlucHV0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBJbmplY3RpbmcgJHttaXNzaW5nfSBhdWRpbyBmcmFtZSBAICR7KG5leHRQdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKX1zIGR1ZSB0byAke01hdGgucm91bmQoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpfSBtcyBnYXAuYCk7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtaXNzaW5nOyBqKyspIHtcbiAgICAgICAgICAgIGxldCBuZXdTdGFtcCA9IE1hdGgubWF4KG5leHRQdHMsIDApO1xuICAgICAgICAgICAgZmlsbEZyYW1lID0gQUFDLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG4gICAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKCdVbmFibGUgdG8gZ2V0IHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWM7IGR1cGxpY2F0aW5nIGxhc3QgZnJhbWUgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgZmlsbEZyYW1lID0gc2FtcGxlLnVuaXQuc3ViYXJyYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0U2FtcGxlcy5zcGxpY2UoaSwgMCwgeyB1bml0OiBmaWxsRnJhbWUsIHB0czogbmV3U3RhbXAsIGR0czogbmV3U3RhbXAgfSk7XG4gICAgICAgICAgICB0cmFjay5sZW4gKz0gZmlsbEZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBZGp1c3Qgc2FtcGxlIHRvIG5leHQgZXhwZWN0ZWQgcHRzXG4gICAgICAgICAgc2FtcGxlLnB0cyA9IHNhbXBsZS5kdHMgPSBuZXh0UHRzO1xuICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwganVzdCBhZGp1c3QgcHRzXG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA+ICgwLjEgKiBpbnB1dFNhbXBsZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZyhgSW52YWxpZCBmcmFtZSBkZWx0YSAke01hdGgucm91bmQoZGVsdGEgKyBpbnB1dFNhbXBsZUR1cmF0aW9uKX0gYXQgUFRTICR7TWF0aC5yb3VuZChwdHMgLyA5MCl9IChzaG91bGQgYmUgJHtNYXRoLnJvdW5kKGlucHV0U2FtcGxlRHVyYXRpb24pfSkuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNhbXBsZS5wdHMgPSBzYW1wbGUuZHRzID0gbmV4dFB0cztcbiAgICAgICAgICBuZXh0UHRzICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaiA9IDAsIG5iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7IGogPCBuYlNhbXBsZXM7IGorKykge1xuICAgICAgbGV0IGF1ZGlvU2FtcGxlID0gaW5wdXRTYW1wbGVzW2pdO1xuICAgICAgbGV0IHVuaXQgPSBhdWRpb1NhbXBsZS51bml0O1xuICAgICAgbGV0IHB0cyA9IGF1ZGlvU2FtcGxlLnB0cztcbiAgICAgIC8vIGxvZ2dlci5sb2coYEF1ZGlvL1BUUzoke01hdGgucm91bmQocHRzLzkwKX1gKTtcbiAgICAgIC8vIGlmIG5vdCBmaXJzdCBzYW1wbGVcbiAgICAgIGlmIChsYXN0UFRTICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbXA0U2FtcGxlLmR1cmF0aW9uID0gTWF0aC5yb3VuZCgocHRzIC0gbGFzdFBUUykgLyBzY2FsZUZhY3Rvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZGVsdGEgPSBNYXRoLnJvdW5kKDEwMDAgKiAocHRzIC0gbmV4dEF1ZGlvUHRzKSAvIGlucHV0VGltZVNjYWxlKSxcbiAgICAgICAgICBudW1NaXNzaW5nRnJhbWVzID0gMDtcbiAgICAgICAgLy8gaWYgZnJhZ21lbnQgYXJlIGNvbnRpZ3VvdXMsIGRldGVjdCBob2xlL292ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzXG4gICAgICAgIC8vIGNvbnRpZ3VvdXMgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZSBmcmFnbWVudHMgZnJvbSBzYW1lIHF1YWxpdHkgbGV2ZWwgKHNhbWUgbGV2ZWwsIG5ldyBTTiA9IG9sZCBTTiArIDEpXG4gICAgICAgIGlmIChjb250aWd1b3VzICYmIHRyYWNrLmlzQUFDKSB7XG4gICAgICAgICAgLy8gbG9nIGRlbHRhXG4gICAgICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgICAgICBpZiAoZGVsdGEgPiAwICYmIGRlbHRhIDwgTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTikge1xuICAgICAgICAgICAgICBudW1NaXNzaW5nRnJhbWVzID0gTWF0aC5yb3VuZCgocHRzIC0gbmV4dEF1ZGlvUHRzKSAvIGlucHV0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGAke2RlbHRhfSBtcyBob2xlIGJldHdlZW4gQUFDIHNhbXBsZXMgZGV0ZWN0ZWQsZmlsbGluZyBpdGApO1xuICAgICAgICAgICAgICBpZiAobnVtTWlzc2luZ0ZyYW1lcyA+IDApIHtcbiAgICAgICAgICAgICAgICBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgICAgICAgZmlsbEZyYW1lID0gdW5pdC5zdWJhcnJheSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyYWNrLmxlbiArPSBudW1NaXNzaW5nRnJhbWVzICogZmlsbEZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGZyYW1lIG92ZXJsYXAsIG92ZXJsYXBwaW5nIGZvciBtb3JlIHRoYW4gaGFsZiBhIGZyYW1lIGR1cmFpb25cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPCAtMTIpIHtcbiAgICAgICAgICAgICAgLy8gZHJvcCBvdmVybGFwcGluZyBhdWRpbyBmcmFtZXMuLi4gYnJvd3NlciB3aWxsIGRlYWwgd2l0aCBpdFxuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBkcm9wIG92ZXJsYXBwaW5nIEFBQyBzYW1wbGUsIGV4cGVjdGVkL3BhcnNlZC9kZWx0YTokeyhuZXh0QXVkaW9QdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKX1zLyR7KHB0cyAvIGlucHV0VGltZVNjYWxlKS50b0ZpeGVkKDMpfXMvJHsoLWRlbHRhKX1tc2ApO1xuICAgICAgICAgICAgICB0cmFjay5sZW4gLT0gdW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBQVFMvRFRTIHRvIGV4cGVjdGVkIFBUUy9EVFNcbiAgICAgICAgICAgIHB0cyA9IG5leHRBdWRpb1B0cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIG91ciBhdWRpb1NhbXBsZXNcbiAgICAgICAgZmlyc3RQVFMgPSBwdHM7XG4gICAgICAgIGlmICh0cmFjay5sZW4gPiAwKSB7XG4gICAgICAgICAgLyogY29uY2F0ZW5hdGUgdGhlIGF1ZGlvIGRhdGEgYW5kIGNvbnN0cnVjdCB0aGUgbWRhdCBpbiBwbGFjZVxuICAgICAgICAgICAgKG5lZWQgOCBtb3JlIGJ5dGVzIHRvIGZpbGwgbGVuZ3RoIGFuZCBtZGF0IHR5cGUpICovXG4gICAgICAgICAgbGV0IG1kYXRTaXplID0gcmF3TVBFRyA/IHRyYWNrLmxlbiA6IHRyYWNrLmxlbiArIDg7XG4gICAgICAgICAgb2Zmc2V0ID0gcmF3TVBFRyA/IDAgOiA4O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZGF0ID0gbmV3IFVpbnQ4QXJyYXkobWRhdFNpemUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTVVYX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1IsIGZhdGFsOiBmYWxzZSwgYnl0ZXM6IG1kYXRTaXplLCByZWFzb246IGBmYWlsIGFsbG9jYXRpbmcgYXVkaW8gbWRhdCAke21kYXRTaXplfWAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmF3TVBFRykge1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgICAgICAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIGF1ZGlvIHNhbXBsZXNcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1NaXNzaW5nRnJhbWVzOyBpKyspIHtcbiAgICAgICAgICBmaWxsRnJhbWUgPSBBQUMuZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcbiAgICAgICAgICBpZiAoIWZpbGxGcmFtZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyB0aGlzIGZyYW1lIGluc3RlYWQuJyk7XG4gICAgICAgICAgICBmaWxsRnJhbWUgPSB1bml0LnN1YmFycmF5KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1kYXQuc2V0KGZpbGxGcmFtZSwgb2Zmc2V0KTtcbiAgICAgICAgICBvZmZzZXQgKz0gZmlsbEZyYW1lLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgbXA0U2FtcGxlID0ge1xuICAgICAgICAgICAgc2l6ZTogZmlsbEZyYW1lLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICBjdHM6IDAsXG4gICAgICAgICAgICBkdXJhdGlvbjogMTAyNCxcbiAgICAgICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgICAgICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgICAgICAgICBkZWdyYWRQcmlvOiAwLFxuICAgICAgICAgICAgICBkZXBlbmRzT246IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIG91dHB1dFNhbXBsZXMucHVzaChtcDRTYW1wbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZGF0LnNldCh1bml0LCBvZmZzZXQpO1xuICAgICAgbGV0IHVuaXRMZW4gPSB1bml0LmJ5dGVMZW5ndGg7XG4gICAgICBvZmZzZXQgKz0gdW5pdExlbjtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdQVFMvRFRTL2luaXREVFMvbm9ybVBUUy9ub3JtRFRTL3JlbGF0aXZlIFBUUyA6ICR7YXVkaW9TYW1wbGUucHRzfS8ke2F1ZGlvU2FtcGxlLmR0c30vJHtpbml0RFRTfS8ke3B0c25vcm19LyR7ZHRzbm9ybX0vJHsoYXVkaW9TYW1wbGUucHRzLzQyOTQ5NjcyOTYpLnRvRml4ZWQoMyl9Jyk7XG4gICAgICBtcDRTYW1wbGUgPSB7XG4gICAgICAgIHNpemU6IHVuaXRMZW4sXG4gICAgICAgIGN0czogMCxcbiAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgaXNMZWFkaW5nOiAwLFxuICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgICAgIGRlZ3JhZFByaW86IDAsXG4gICAgICAgICAgZGVwZW5kc09uOiAxXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobXA0U2FtcGxlKTtcbiAgICAgIGxhc3RQVFMgPSBwdHM7XG4gICAgfVxuICAgIGxldCBsYXN0U2FtcGxlRHVyYXRpb24gPSAwO1xuICAgIGxldCBuYlNhbXBsZXMgPSBvdXRwdXRTYW1wbGVzLmxlbmd0aDtcbiAgICAvLyBzZXQgbGFzdCBzYW1wbGUgZHVyYXRpb24gYXMgYmVpbmcgaWRlbnRpY2FsIHRvIHByZXZpb3VzIHNhbXBsZVxuICAgIGlmIChuYlNhbXBsZXMgPj0gMikge1xuICAgICAgbGFzdFNhbXBsZUR1cmF0aW9uID0gb3V0cHV0U2FtcGxlc1tuYlNhbXBsZXMgLSAyXS5kdXJhdGlvbjtcbiAgICAgIG1wNFNhbXBsZS5kdXJhdGlvbiA9IGxhc3RTYW1wbGVEdXJhdGlvbjtcbiAgICB9XG4gICAgaWYgKG5iU2FtcGxlcykge1xuICAgICAgLy8gbmV4dCBhdWRpbyBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBkdXJhdGlvblxuICAgICAgdGhpcy5uZXh0QXVkaW9QdHMgPSBuZXh0QXVkaW9QdHMgPSBsYXN0UFRTICsgc2NhbGVGYWN0b3IgKiBsYXN0U2FtcGxlRHVyYXRpb247XG4gICAgICAvLyBsb2dnZXIubG9nKCdBdWRpby9QVFMvUFRTZW5kOicgKyBhdWRpb1NhbXBsZS5wdHMudG9GaXhlZCgwKSArICcvJyArIHRoaXMubmV4dEFhY0R0cy50b0ZpeGVkKDApKTtcbiAgICAgIHRyYWNrLmxlbiA9IDA7XG4gICAgICB0cmFjay5zYW1wbGVzID0gb3V0cHV0U2FtcGxlcztcbiAgICAgIGlmIChyYXdNUEVHKSB7XG4gICAgICAgIG1vb2YgPSBuZXcgVWludDhBcnJheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9vZiA9IE1QNC5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0UFRTIC8gc2NhbGVGYWN0b3IsIHRyYWNrKTtcbiAgICAgIH1cblxuICAgICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgICAgY29uc3Qgc3RhcnQgPSBmaXJzdFBUUyAvIGlucHV0VGltZVNjYWxlO1xuICAgICAgY29uc3QgZW5kID0gbmV4dEF1ZGlvUHRzIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgICBjb25zdCBhdWRpb0RhdGEgPSB7XG4gICAgICAgIGRhdGExOiBtb29mLFxuICAgICAgICBkYXRhMjogbWRhdCxcbiAgICAgICAgc3RhcnRQVFM6IHN0YXJ0LFxuICAgICAgICBlbmRQVFM6IGVuZCxcbiAgICAgICAgc3RhcnREVFM6IHN0YXJ0LFxuICAgICAgICBlbmREVFM6IGVuZCxcbiAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgaGFzQXVkaW86IHRydWUsXG4gICAgICAgIGhhc1ZpZGVvOiBmYWxzZSxcbiAgICAgICAgbmI6IG5iU2FtcGxlc1xuICAgICAgfTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfREFUQSwgYXVkaW9EYXRhKTtcbiAgICAgIHJldHVybiBhdWRpb0RhdGE7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmVtdXhFbXB0eUF1ZGlvICh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgdmlkZW9EYXRhKSB7XG4gICAgbGV0IGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGUsXG4gICAgICBtcDR0aW1lU2NhbGUgPSB0cmFjay5zYW1wbGVyYXRlID8gdHJhY2suc2FtcGxlcmF0ZSA6IGlucHV0VGltZVNjYWxlLFxuICAgICAgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZSxcbiAgICAgIG5leHRBdWRpb1B0cyA9IHRoaXMubmV4dEF1ZGlvUHRzLFxuXG4gICAgICAvLyBzeW5jIHdpdGggdmlkZW8ncyB0aW1lc3RhbXBcbiAgICAgIHN0YXJ0RFRTID0gKG5leHRBdWRpb1B0cyAhPT0gdW5kZWZpbmVkID8gbmV4dEF1ZGlvUHRzIDogdmlkZW9EYXRhLnN0YXJ0RFRTICogaW5wdXRUaW1lU2NhbGUpICsgdGhpcy5faW5pdERUUyxcbiAgICAgIGVuZERUUyA9IHZpZGVvRGF0YS5lbmREVFMgKiBpbnB1dFRpbWVTY2FsZSArIHRoaXMuX2luaXREVFMsXG4gICAgICAvLyBvbmUgc2FtcGxlJ3MgZHVyYXRpb24gdmFsdWVcbiAgICAgIHNhbXBsZUR1cmF0aW9uID0gMTAyNCxcbiAgICAgIGZyYW1lRHVyYXRpb24gPSBzY2FsZUZhY3RvciAqIHNhbXBsZUR1cmF0aW9uLFxuXG4gICAgICAvLyBzYW1wbGVzIGNvdW50IG9mIHRoaXMgc2VnbWVudCdzIGR1cmF0aW9uXG4gICAgICBuYlNhbXBsZXMgPSBNYXRoLmNlaWwoKGVuZERUUyAtIHN0YXJ0RFRTKSAvIGZyYW1lRHVyYXRpb24pLFxuXG4gICAgICAvLyBzaWxlbnQgZnJhbWVcbiAgICAgIHNpbGVudEZyYW1lID0gQUFDLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG5cbiAgICBsb2dnZXIud2FybigncmVtdXggZW1wdHkgQXVkaW8nKTtcbiAgICAvLyBDYW4ndCByZW11eCBpZiB3ZSBjYW4ndCBnZW5lcmF0ZSBhIHNpbGVudCBmcmFtZS4uLlxuICAgIGlmICghc2lsZW50RnJhbWUpIHtcbiAgICAgIGxvZ2dlci50cmFjZSgnVW5hYmxlIHRvIHJlbXV4RW1wdHlBdWRpbyBzaW5jZSB3ZSB3ZXJlIHVuYWJsZSB0byBnZXQgYSBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjIScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBzYW1wbGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgbGV0IHN0YW1wID0gc3RhcnREVFMgKyBpICogZnJhbWVEdXJhdGlvbjtcbiAgICAgIHNhbXBsZXMucHVzaCh7IHVuaXQ6IHNpbGVudEZyYW1lLCBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wIH0pO1xuICAgICAgdHJhY2subGVuICs9IHNpbGVudEZyYW1lLmxlbmd0aDtcbiAgICB9XG4gICAgdHJhY2suc2FtcGxlcyA9IHNhbXBsZXM7XG5cbiAgICB0aGlzLnJlbXV4QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMpO1xuICB9XG5cbiAgcmVtdXhJRDMgKHRyYWNrKSB7XG4gICAgbGV0IGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoLCBzYW1wbGU7XG4gICAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICBjb25zdCBpbml0RFRTID0gdGhpcy5faW5pdERUUztcbiAgICAvLyBjb25zdW1lIHNhbXBsZXNcbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xuICAgICAgICAvLyBzZXR0aW5nIGlkMyBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcbiAgICAgICAgc2FtcGxlLnB0cyA9ICgoc2FtcGxlLnB0cyAtIGluaXRQVFMpIC8gaW5wdXRUaW1lU2NhbGUpO1xuICAgICAgICBzYW1wbGUuZHRzID0gKChzYW1wbGUuZHRzIC0gaW5pdERUUykgLyBpbnB1dFRpbWVTY2FsZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX01FVEFEQVRBLCB7XG4gICAgICAgIHNhbXBsZXM6IHRyYWNrLnNhbXBsZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgfVxuXG4gIHJlbXV4VGV4dCAodHJhY2spIHtcbiAgICB0cmFjay5zYW1wbGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiAoYS5wdHMgLSBiLnB0cyk7XG4gICAgfSk7XG5cbiAgICBsZXQgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGgsIHNhbXBsZTtcbiAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgIC8vIGNvbnN1bWUgc2FtcGxlc1xuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07XG4gICAgICAgIC8vIHNldHRpbmcgdGV4dCBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcbiAgICAgICAgc2FtcGxlLnB0cyA9ICgoc2FtcGxlLnB0cyAtIGluaXRQVFMpIC8gaW5wdXRUaW1lU2NhbGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19VU0VSREFUQSwge1xuICAgICAgICBzYW1wbGVzOiB0cmFjay5zYW1wbGVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gIH1cblxuICBfUFRTTm9ybWFsaXplICh2YWx1ZSwgcmVmZXJlbmNlKSB7XG4gICAgbGV0IG9mZnNldDtcbiAgICBpZiAocmVmZXJlbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAocmVmZXJlbmNlIDwgdmFsdWUpIHtcbiAgICAgIC8vIC0gMl4zM1xuICAgICAgb2Zmc2V0ID0gLTg1ODk5MzQ1OTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICsgMl4zM1xuICAgICAgb2Zmc2V0ID0gODU4OTkzNDU5MjtcbiAgICB9XG4gICAgLyogUFRTIGlzIDMzYml0IChmcm9tIDAgdG8gMl4zMyAtMSlcbiAgICAgIGlmIGRpZmYgYmV0d2VlbiB2YWx1ZSBhbmQgcmVmZXJlbmNlIGlzIGJpZ2dlciB0aGFuIGhhbGYgb2YgdGhlIGFtcGxpdHVkZSAoMl4zMikgdGhlbiBpdCBtZWFucyB0aGF0XG4gICAgICBQVFMgbG9vcGluZyBvY2N1cmVkLiBmaWxsIHRoZSBnYXAgKi9cbiAgICB3aGlsZSAoTWF0aC5hYnModmFsdWUgLSByZWZlcmVuY2UpID4gNDI5NDk2NzI5Nikge1xuICAgICAgdmFsdWUgKz0gb2Zmc2V0O1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNUDRSZW11eGVyO1xuIiwiLyoqXG4gKiBwYXNzdGhyb3VnaCByZW11eGVyXG4qL1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5cbmNsYXNzIFBhc3NUaHJvdWdoUmVtdXhlciB7XG4gIGNvbnN0cnVjdG9yIChvYnNlcnZlcikge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICB9XG5cbiAgcmVzZXRUaW1lU3RhbXAgKCkge1xuICB9XG5cbiAgcmVzZXRJbml0U2VnbWVudCAoKSB7XG4gIH1cblxuICByZW11eCAoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCByYXdEYXRhKSB7XG4gICAgbGV0IG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcjtcbiAgICBsZXQgc3RyZWFtVHlwZSA9ICcnO1xuICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICBzdHJlYW1UeXBlICs9ICdhdWRpbyc7XG4gICAgfVxuXG4gICAgaWYgKHZpZGVvVHJhY2spIHtcbiAgICAgIHN0cmVhbVR5cGUgKz0gJ3ZpZGVvJztcbiAgICB9XG5cbiAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCB7XG4gICAgICBkYXRhMTogcmF3RGF0YSxcbiAgICAgIHN0YXJ0UFRTOiB0aW1lT2Zmc2V0LFxuICAgICAgc3RhcnREVFM6IHRpbWVPZmZzZXQsXG4gICAgICB0eXBlOiBzdHJlYW1UeXBlLFxuICAgICAgaGFzQXVkaW86ICEhYXVkaW9UcmFjayxcbiAgICAgIGhhc1ZpZGVvOiAhIXZpZGVvVHJhY2ssXG4gICAgICBuYjogMSxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9KTtcbiAgICAvLyBub3RpZnkgZW5kIG9mIHBhcnNpbmdcbiAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0VEKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXNzVGhyb3VnaFJlbXV4ZXI7XG4iLCJpbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4vZXZlbnQtaGFuZGxlcic7XG5cbi8qKlxuICogU3ViLWNsYXNzIHNwZWNpYWxpemF0aW9uIG9mIEV2ZW50SGFuZGxlciBiYXNlIGNsYXNzLlxuICpcbiAqIFRhc2tMb29wIGFsbG93cyB0byBzY2hlZHVsZSBhIHRhc2sgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIChvcHRpb25uYWx5IHJlcGVhdGVkbHkpIG9uIHRoZSBtYWluIGxvb3AsXG4gKiBzY2hlZHVsZWQgYXN5bmNocm9uZW91c2x5LCBhdm9pZGluZyByZWN1cnNpdmUgY2FsbHMgaW4gdGhlIHNhbWUgdGljay5cbiAqXG4gKiBUaGUgdGFzayBpdHNlbGYgaXMgaW1wbGVtZW50ZWQgaW4gYGRvVGlja2AuIEl0IGNhbiBiZSByZXF1ZXN0ZWQgYW5kIGNhbGxlZCBmb3Igc2luZ2xlIGV4ZWN1dGlvblxuICogdXNpbmcgdGhlIGB0aWNrYCBtZXRob2QuXG4gKlxuICogSXQgd2lsbCBiZSBhc3N1cmVkIHRoYXQgdGhlIHRhc2sgZXhlY3V0aW9uIG1ldGhvZCAoYHRpY2tgKSBvbmx5IGdldHMgY2FsbGVkIG9uY2UgcGVyIG1haW4gbG9vcCBcInRpY2tcIixcbiAqIG5vIG1hdHRlciBob3cgb2Z0ZW4gaXQgZ2V0cyByZXF1ZXN0ZWQgZm9yIGV4ZWN1dGlvbi4gRXhlY3V0aW9uIGluIGZ1cnRoZXIgdGlja3Mgd2lsbCBiZSBzY2hlZHVsZWQgYWNjb3JkaW5nbHkuXG4gKlxuICogSWYgZnVydGhlciBleGVjdXRpb24gcmVxdWVzdHMgaGF2ZSBhbHJlYWR5IGJlZW4gc2NoZWR1bGVkIG9uIHRoZSBuZXh0IHRpY2ssIGl0IGNhbiBiZSBjaGVja2VkIHdpdGggYGhhc05leHRUaWNrYCxcbiAqIGFuZCBjYW5jZWxsZWQgd2l0aCBgY2xlYXJOZXh0VGlja2AuXG4gKlxuICogVGhlIHRhc2sgY2FuIGJlIHNjaGVkdWxlZCBhcyBhbiBpbnRlcnZhbCByZXBlYXRlZGx5IHdpdGggYSBwZXJpb2QgYXMgcGFyYW1ldGVyIChzZWUgYHNldEludGVydmFsYCwgYGNsZWFySW50ZXJ2YWxgKS5cbiAqXG4gKiBTdWItY2xhc3NlcyBuZWVkIHRvIGltcGxlbWVudCB0aGUgYGRvVGlja2AgbWV0aG9kIHdoaWNoIHdpbGwgZWZmZWN0aXZlbHkgaGF2ZSB0aGUgdGFzayBleGVjdXRpb24gcm91dGluZS5cbiAqXG4gKiBGdXJ0aGVyIGV4cGxhbmF0aW9uczpcbiAqXG4gKiBUaGUgYmFzZWNsYXNzIGhhcyBhIGB0aWNrYCBtZXRob2QgdGhhdCB3aWxsIHNjaGVkdWxlIHRoZSBkb1RpY2sgY2FsbC4gSXQgbWF5IGJlIGNhbGxlZCBzeW5jaHJvbmVvdXNseVxuICogb25seSBmb3IgYSBzdGFjay1kZXB0aCBvZiBvbmUuIE9uIHJlLWVudHJhbnQgY2FsbHMsIHN1Yi1zZXF1ZW50IGNhbGxzIGFyZSBzY2hlZHVsZWQgZm9yIG5leHQgbWFpbiBsb29wIHRpY2tzLlxuICpcbiAqIFdoZW4gdGhlIHRhc2sgZXhlY3V0aW9uIChgdGlja2AgbWV0aG9kKSBpcyBjYWxsZWQgaW4gcmUtZW50cmFudCB3YXkgdGhpcyBpcyBkZXRlY3RlZCBhbmRcbiAqIHdlIGFyZSBsaW1pdGluZyB0aGUgdGFzayBleGVjdXRpb24gcGVyIGNhbGwgc3RhY2sgdG8gZXhhY3RseSBvbmUsIGJ1dCBzY2hlZHVsaW5nL3Bvc3QtcG9uaW5nIGZ1cnRoZXJcbiAqIHRhc2sgcHJvY2Vzc2luZyBvbiB0aGUgbmV4dCBtYWluIGxvb3AgaXRlcmF0aW9uIChhbHNvIGtub3duIGFzIFwibmV4dCB0aWNrXCIgaW4gdGhlIE5vZGUvSlMgcnVudGltZSBsaW5nbykuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFza0xvb3AgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzLCAuLi5ldmVudHMpIHtcbiAgICBzdXBlcihobHMsIC4uLmV2ZW50cyk7XG5cbiAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgIHRoaXMuX3RpY2tUaW1lciA9IG51bGw7XG4gICAgdGhpcy5fdGlja0NhbGxDb3VudCA9IDA7XG4gICAgdGhpcy5fYm91bmRUaWNrID0gdGhpcy50aWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBvbkhhbmRsZXJEZXN0cm95aW5nICgpIHtcbiAgICAvLyBjbGVhciBhbGwgdGltZXJzIGJlZm9yZSB1bnJlZ2lzdGVyaW5nIGZyb20gZXZlbnQgYnVzXG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBoYXNJbnRlcnZhbCAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fdGlja0ludGVydmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaGFzTmV4dFRpY2sgKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3RpY2tUaW1lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzIEludGVydmFsIHRpbWUgKG1zKVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIGludGVydmFsIGhhcyBiZWVuIHNjaGVkdWxlZCwgZmFsc2Ugd2hlbiBhbHJlYWR5IHNjaGVkdWxlZCAobm8gZWZmZWN0KVxuICAgKi9cbiAgc2V0SW50ZXJ2YWwgKG1pbGxpcykge1xuICAgIGlmICghdGhpcy5fdGlja0ludGVydmFsKSB7XG4gICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLl9ib3VuZFRpY2ssIG1pbGxpcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIHdoZW4gaW50ZXJ2YWwgd2FzIGNsZWFyZWQsIGZhbHNlIHdoZW4gbm9uZSB3YXMgc2V0IChubyBlZmZlY3QpXG4gICAqL1xuICBjbGVhckludGVydmFsICgpIHtcbiAgICBpZiAodGhpcy5fdGlja0ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX3RpY2tJbnRlcnZhbCk7XG4gICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIHRpbWVvdXQgd2FzIGNsZWFyZWQsIGZhbHNlIHdoZW4gbm9uZSB3YXMgc2V0IChubyBlZmZlY3QpXG4gICAqL1xuICBjbGVhck5leHRUaWNrICgpIHtcbiAgICBpZiAodGhpcy5fdGlja1RpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGlja1RpbWVyKTtcbiAgICAgIHRoaXMuX3RpY2tUaW1lciA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgY2FsbCB0aGUgc3ViY2xhc3MgZG9UaWNrIGltcGxlbWVudGF0aW9uIGluIHRoaXMgbWFpbiBsb29wIHRpY2tcbiAgICogb3IgaW4gdGhlIG5leHQgb25lICh2aWEgc2V0VGltZW91dCgsMCkpIGluIGNhc2UgaXQgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcbiAgICogaW4gdGhpcyB0aWNrIChpbiBjYXNlIHRoaXMgaXMgYSByZS1lbnRyYW50IGNhbGwpLlxuICAgKi9cbiAgdGljayAoKSB7XG4gICAgdGhpcy5fdGlja0NhbGxDb3VudCsrO1xuICAgIGlmICh0aGlzLl90aWNrQ2FsbENvdW50ID09PSAxKSB7XG4gICAgICB0aGlzLmRvVGljaygpO1xuICAgICAgLy8gcmUtZW50cmFudCBjYWxsIHRvIHRpY2sgZnJvbSBwcmV2aW91cyBkb1RpY2sgY2FsbCBzdGFja1xuICAgICAgLy8gLT4gc2NoZWR1bGUgYSBjYWxsIG9uIHRoZSBuZXh0IG1haW4gbG9vcCBpdGVyYXRpb24gdG8gcHJvY2VzcyB0aGlzIHRhc2sgcHJvY2Vzc2luZyByZXF1ZXN0XG4gICAgICBpZiAodGhpcy5fdGlja0NhbGxDb3VudCA+IDEpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIG9ubHkgb25lIHRpbWVyIGV4aXN0cyBhdCBhbnkgdGltZSBhdCBtYXhcbiAgICAgICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgICAgIHRoaXMuX3RpY2tUaW1lciA9IHNldFRpbWVvdXQodGhpcy5fYm91bmRUaWNrLCAwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3Igc3ViY2xhc3MgdG8gaW1wbGVtZW50IHRhc2sgbG9naWNcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBkb1RpY2sgKCkge31cbn1cbiIsImNvbnN0IERFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWCA9IC9eKFxcZCspeChcXGQrKSQvOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG5jb25zdCBBVFRSX0xJU1RfUkVHRVggPSAvXFxzKiguKz8pXFxzKj0oKD86XFxcIi4qP1xcXCIpfC4qPykoPzosfCQpL2c7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcblxuLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5vbmdpbC9ub2RlLW0zdThwYXJzZS9ibG9iL21hc3Rlci9hdHRybGlzdC5qc1xuY2xhc3MgQXR0ckxpc3Qge1xuICBjb25zdHJ1Y3RvciAoYXR0cnMpIHtcbiAgICBpZiAodHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xuICAgICAgYXR0cnMgPSBBdHRyTGlzdC5wYXJzZUF0dHJMaXN0KGF0dHJzKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBhdHRyIGluIGF0dHJzKSB7XG4gICAgICBpZiAoYXR0cnMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgdGhpc1thdHRyXSA9IGF0dHJzW2F0dHJdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRlY2ltYWxJbnRlZ2VyIChhdHRyTmFtZSkge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDEwKTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cblxuICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgfVxuXG4gIGhleGFkZWNpbWFsSW50ZWdlciAoYXR0ck5hbWUpIHtcbiAgICBpZiAodGhpc1thdHRyTmFtZV0pIHtcbiAgICAgIGxldCBzdHJpbmdWYWx1ZSA9ICh0aGlzW2F0dHJOYW1lXSB8fCAnMHgnKS5zbGljZSgyKTtcbiAgICAgIHN0cmluZ1ZhbHVlID0gKChzdHJpbmdWYWx1ZS5sZW5ndGggJiAxKSA/ICcwJyA6ICcnKSArIHN0cmluZ1ZhbHVlO1xuXG4gICAgICBjb25zdCB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSBwYXJzZUludChzdHJpbmdWYWx1ZS5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGhleGFkZWNpbWFsSW50ZWdlckFzTnVtYmVyIChhdHRyTmFtZSkge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDE2KTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cblxuICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgfVxuXG4gIGRlY2ltYWxGbG9hdGluZ1BvaW50IChhdHRyTmFtZSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXNbYXR0ck5hbWVdKTtcbiAgfVxuXG4gIGVudW1lcmF0ZWRTdHJpbmcgKGF0dHJOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXNbYXR0ck5hbWVdO1xuICB9XG5cbiAgZGVjaW1hbFJlc29sdXRpb24gKGF0dHJOYW1lKSB7XG4gICAgY29uc3QgcmVzID0gREVDSU1BTF9SRVNPTFVUSU9OX1JFR0VYLmV4ZWModGhpc1thdHRyTmFtZV0pO1xuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBwYXJzZUludChyZXNbMV0sIDEwKSxcbiAgICAgIGhlaWdodDogcGFyc2VJbnQocmVzWzJdLCAxMClcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIHBhcnNlQXR0ckxpc3QgKGlucHV0KSB7XG4gICAgbGV0IG1hdGNoLCBhdHRycyA9IHt9O1xuICAgIEFUVFJfTElTVF9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlICgobWF0Y2ggPSBBVFRSX0xJU1RfUkVHRVguZXhlYyhpbnB1dCkpICE9PSBudWxsKSB7XG4gICAgICBsZXQgdmFsdWUgPSBtYXRjaFsyXSwgcXVvdGUgPSAnXCInO1xuXG4gICAgICBpZiAodmFsdWUuaW5kZXhPZihxdW90ZSkgPT09IDAgJiZcbiAgICAgICAgICB2YWx1ZS5sYXN0SW5kZXhPZihxdW90ZSkgPT09ICh2YWx1ZS5sZW5ndGggLSAxKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICAgIH1cblxuICAgICAgYXR0cnNbbWF0Y2hbMV1dID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhdHRycztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdHRyTGlzdDtcbiIsImxldCBCaW5hcnlTZWFyY2ggPSB7XG4gIC8qKlxuICAgICAqIFNlYXJjaGVzIGZvciBhbiBpdGVtIGluIGFuIGFycmF5IHdoaWNoIG1hdGNoZXMgYSBjZXJ0YWluIGNvbmRpdGlvbi5cbiAgICAgKiBUaGlzIHJlcXVpcmVzIHRoZSBjb25kaXRpb24gdG8gb25seSBtYXRjaCBvbmUgaXRlbSBpbiB0aGUgYXJyYXksXG4gICAgICogYW5kIGZvciB0aGUgYXJyYXkgdG8gYmUgb3JkZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJpc29uRnVuY3Rpb25cbiAgICAgKiAgICAgIENhbGxlZCBhbmQgcHJvdmlkZWQgYSBjYW5kaWRhdGUgaXRlbSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAgICogICAgICBTaG91bGQgcmV0dXJuOlxuICAgICAqICAgICAgICAgID4gLTEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBsb3dlciBpbmRleCB0aGFuIHRoZSBwcm92aWRlZCBpdGVtLlxuICAgICAqICAgICAgICAgID4gMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGhpZ2hlciBpbmRleCB0aGFuIHRoZSBwcm92aWRlZCBpdGVtLlxuICAgICAqICAgICAgICAgID4gMCBpZiB0aGUgaXRlbSBpcyB0aGUgaXRlbSB5b3UncmUgbG9va2luZyBmb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgb2JqZWN0IGlmIGl0IGlzIGZvdW5kIG9yIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICBzZWFyY2g6IGZ1bmN0aW9uIChsaXN0LCBjb21wYXJpc29uRnVuY3Rpb24pIHtcbiAgICBsZXQgbWluSW5kZXggPSAwO1xuICAgIGxldCBtYXhJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICBsZXQgY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICBsZXQgY3VycmVudEVsZW1lbnQgPSBudWxsO1xuXG4gICAgd2hpbGUgKG1pbkluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICBjdXJyZW50SW5kZXggPSAobWluSW5kZXggKyBtYXhJbmRleCkgLyAyIHwgMDtcbiAgICAgIGN1cnJlbnRFbGVtZW50ID0gbGlzdFtjdXJyZW50SW5kZXhdO1xuXG4gICAgICBsZXQgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmlzb25GdW5jdGlvbihjdXJyZW50RWxlbWVudCk7XG4gICAgICBpZiAoY29tcGFyaXNvblJlc3VsdCA+IDApIHtcbiAgICAgICAgbWluSW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xuICAgICAgfSBlbHNlIGlmIChjb21wYXJpc29uUmVzdWx0IDwgMCkge1xuICAgICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJpbmFyeVNlYXJjaDtcbiIsIi8qKlxuICogQG1vZHVsZSBCdWZmZXJIZWxwZXJcbiAqXG4gKiBQcm92aWRpbmcgbWV0aG9kcyBkZWFsaW5nIHdpdGggYnVmZmVyIGxlbmd0aCByZXRyaWV2YWwgZm9yIGV4YW1wbGUuXG4gKlxuICogSW4gZ2VuZXJhbCwgYSBoZWxwZXIgYXJvdW5kIEhUTUw1IE1lZGlhRWxlbWVudCBUaW1lUmFuZ2VzIGdhdGhlcmVkIGZyb20gYGJ1ZmZlcmVkYCBwcm9wZXJ0eS5cbiAqXG4gKiBBbHNvIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvYnVmZmVyZWRcbiovXG5cbmV4cG9ydCBjbGFzcyBCdWZmZXJIZWxwZXIge1xuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgYG1lZGlhYCdzIGJ1ZmZlcmVkIGluY2x1ZGUgYHBvc2l0aW9uYFxuICAgKiBAcGFyYW0ge0hUTUxNZWRpYUVsZW1lbnR8U291cmNlQnVmZmVyfSBtZWRpYVxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNCdWZmZXJlZCAobWVkaWEsIHBvc2l0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBsZXQgYnVmZmVyZWQgPSBtZWRpYS5idWZmZXJlZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBidWZmZXJlZC5zdGFydChpKSAmJiBwb3NpdGlvbiA8PSBidWZmZXJlZC5lbmQoaSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyB0aGlzIGlzIHRvIGNhdGNoXG4gICAgICAvLyBJbnZhbGlkU3RhdGVFcnJvcjogRmFpbGVkIHRvIHJlYWQgdGhlICdidWZmZXJlZCcgcHJvcGVydHkgZnJvbSAnU291cmNlQnVmZmVyJzpcbiAgICAgIC8vIFRoaXMgU291cmNlQnVmZmVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IG1lZGlhIHNvdXJjZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgYnVmZmVySW5mbyAobWVkaWEsIHBvcywgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBsZXQgdmJ1ZmZlcmVkID0gbWVkaWEuYnVmZmVyZWQsIGJ1ZmZlcmVkID0gW10sIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBidWZmZXJlZC5wdXNoKHsgc3RhcnQ6IHZidWZmZXJlZC5zdGFydChpKSwgZW5kOiB2YnVmZmVyZWQuZW5kKGkpIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkLCBwb3MsIG1heEhvbGVEdXJhdGlvbik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHRoaXMgaXMgdG8gY2F0Y2hcbiAgICAgIC8vIEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2J1ZmZlcmVkJyBwcm9wZXJ0eSBmcm9tICdTb3VyY2VCdWZmZXInOlxuICAgICAgLy8gVGhpcyBTb3VyY2VCdWZmZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgbWVkaWEgc291cmNlXG4gICAgfVxuICAgIHJldHVybiB7IGxlbjogMCwgc3RhcnQ6IHBvcywgZW5kOiBwb3MsIG5leHRTdGFydDogdW5kZWZpbmVkIH07XG4gIH1cblxuICBzdGF0aWMgYnVmZmVyZWRJbmZvIChidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICBsZXQgYnVmZmVyZWQyID0gW10sXG4gICAgICAvLyBidWZmZXJTdGFydCBhbmQgYnVmZmVyRW5kIGFyZSBidWZmZXIgYm91bmRhcmllcyBhcm91bmQgY3VycmVudCB2aWRlbyBwb3NpdGlvblxuICAgICAgYnVmZmVyTGVuLCBidWZmZXJTdGFydCwgYnVmZmVyRW5kLCBidWZmZXJTdGFydE5leHQsIGk7XG4gICAgLy8gc29ydCBvbiBidWZmZXIuc3RhcnQvc21hbGxlciBlbmQgKElFIGRvZXMgbm90IGFsd2F5cyByZXR1cm4gc29ydGVkIGJ1ZmZlcmVkIHJhbmdlKVxuICAgIGJ1ZmZlcmVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGxldCBkaWZmID0gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICBpZiAoZGlmZikge1xuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiLmVuZCAtIGEuZW5kO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHRoZXJlIG1pZ2h0IGJlIHNvbWUgc21hbGwgaG9sZXMgYmV0d2VlbiBidWZmZXIgdGltZSByYW5nZVxuICAgIC8vIGNvbnNpZGVyIHRoYXQgaG9sZXMgc21hbGxlciB0aGFuIG1heEhvbGVEdXJhdGlvbiBhcmUgaXJyZWxldmFudCBhbmQgYnVpbGQgYW5vdGhlclxuICAgIC8vIGJ1ZmZlciB0aW1lIHJhbmdlIHJlcHJlc2VudGF0aW9ucyB0aGF0IGRpc2NhcmRzIHRob3NlIGhvbGVzXG4gICAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYnVmMmxlbiA9IGJ1ZmZlcmVkMi5sZW5ndGg7XG4gICAgICBpZiAoYnVmMmxlbikge1xuICAgICAgICBsZXQgYnVmMmVuZCA9IGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kO1xuICAgICAgICAvLyBpZiBzbWFsbCBob2xlICh2YWx1ZSBiZXR3ZWVuIDAgb3IgbWF4SG9sZUR1cmF0aW9uICkgb3Igb3ZlcmxhcHBpbmcgKG5lZ2F0aXZlKVxuICAgICAgICBpZiAoKGJ1ZmZlcmVkW2ldLnN0YXJ0IC0gYnVmMmVuZCkgPCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAvLyBtZXJnZSBvdmVybGFwcGluZyB0aW1lIHJhbmdlc1xuICAgICAgICAgIC8vIHVwZGF0ZSBsYXN0UmFuZ2UuZW5kIG9ubHkgaWYgc21hbGxlciB0aGFuIGl0ZW0uZW5kXG4gICAgICAgICAgLy8gZS5nLiAgWyAxLCAxNV0gd2l0aCAgWyAyLDhdID0+IFsgMSwxNV0gKG5vIG5lZWQgdG8gbW9kaWZ5IGxhc3RSYW5nZS5lbmQpXG4gICAgICAgICAgLy8gd2hlcmVhcyBbIDEsIDhdIHdpdGggIFsgMiwxNV0gPT4gWyAxLDE1XSAoIGxhc3RSYW5nZSBzaG91bGQgc3dpdGNoIGZyb20gWzEsOF0gdG8gWzEsMTVdKVxuICAgICAgICAgIGlmIChidWZmZXJlZFtpXS5lbmQgPiBidWYyZW5kKSB7XG4gICAgICAgICAgICBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZCA9IGJ1ZmZlcmVkW2ldLmVuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYmlnIGhvbGVcbiAgICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZpcnN0IHZhbHVlXG4gICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMCwgYnVmZmVyTGVuID0gMCwgYnVmZmVyU3RhcnQgPSBidWZmZXJFbmQgPSBwb3M7IGkgPCBidWZmZXJlZDIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzdGFydCA9IGJ1ZmZlcmVkMltpXS5zdGFydCxcbiAgICAgICAgZW5kID0gYnVmZmVyZWQyW2ldLmVuZDtcbiAgICAgIC8vIGxvZ2dlci5sb2coJ2J1ZiBzdGFydC9lbmQ6JyArIGJ1ZmZlcmVkLnN0YXJ0KGkpICsgJy8nICsgYnVmZmVyZWQuZW5kKGkpKTtcbiAgICAgIGlmICgocG9zICsgbWF4SG9sZUR1cmF0aW9uKSA+PSBzdGFydCAmJiBwb3MgPCBlbmQpIHtcbiAgICAgICAgLy8gcGxheSBwb3NpdGlvbiBpcyBpbnNpZGUgdGhpcyBidWZmZXIgVGltZVJhbmdlLCByZXRyaWV2ZSBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uIGFuZCBidWZmZXIgbGVuZ3RoXG4gICAgICAgIGJ1ZmZlclN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIGJ1ZmZlckVuZCA9IGVuZDtcbiAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVyRW5kIC0gcG9zO1xuICAgICAgfSBlbHNlIGlmICgocG9zICsgbWF4SG9sZUR1cmF0aW9uKSA8IHN0YXJ0KSB7XG4gICAgICAgIGJ1ZmZlclN0YXJ0TmV4dCA9IHN0YXJ0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbGVuOiBidWZmZXJMZW4sIHN0YXJ0OiBidWZmZXJTdGFydCwgZW5kOiBidWZmZXJFbmQsIG5leHRTdGFydDogYnVmZmVyU3RhcnROZXh0IH07XG4gIH1cbn1cbiIsIi8qKlxuICpcbiAqIFRoaXMgY29kZSB3YXMgcG9ydGVkIGZyb20gdGhlIGRhc2guanMgcHJvamVjdCBhdDpcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL0Rhc2gtSW5kdXN0cnktRm9ydW0vZGFzaC5qcy9ibG9iL2RldmVsb3BtZW50L2V4dGVybmFscy9jZWE2MDgtcGFyc2VyLmpzXG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvY29tbWl0LzgyNjliMjZhNzYxZTA4NTNiYjIxZDc4NzgwZWQ5NDUxNDRlY2RkNGQjZGlmZi03MWJjMjk1YTJkNmI2YjcwOTNhMWQzMjkwZDUzYTRiMlxuICpcbiAqIFRoZSBvcmlnaW5hbCBjb3B5cmlnaHQgYXBwZWFycyBiZWxvdzpcbiAqXG4gKiBUaGUgY29weXJpZ2h0IGluIHRoaXMgc29mdHdhcmUgaXMgYmVpbmcgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLFxuICogaW5jbHVkZWQgYmVsb3cuIFRoaXMgc29mdHdhcmUgbWF5IGJlIHN1YmplY3QgdG8gb3RoZXIgdGhpcmQgcGFydHkgYW5kIGNvbnRyaWJ1dG9yXG4gKiByaWdodHMsIGluY2x1ZGluZyBwYXRlbnQgcmlnaHRzLCBhbmQgbm8gc3VjaCByaWdodHMgYXJlIGdyYW50ZWQgdW5kZXIgdGhpcyBsaWNlbnNlLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDE2LCBEQVNIIEluZHVzdHJ5IEZvcnVtLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICogIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yXG4gKiAgb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAyLiBOZWl0aGVyIHRoZSBuYW1lIG9mIERhc2ggSW5kdXN0cnkgRm9ydW0gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gKiAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgQVMgSVMgQU5EIEFOWVxuICogIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAqICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuXG4gKiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCxcbiAqICBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUXG4gKiAgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLFxuICogIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqICBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG4vKipcbiAgICAgKiAgRXhjZXB0aW9ucyBmcm9tIHJlZ3VsYXIgQVNDSUkuIENvZGVQb2ludHMgYXJlIG1hcHBlZCB0byBVVEYtMTYgY29kZXNcbiAgICAgKi9cblxubGV0IHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzID0ge1xuICAweDJhOiAweGUxLCAvLyBsb3dlcmNhc2UgYSwgYWN1dGUgYWNjZW50XG4gIDB4NWM6IDB4ZTksIC8vIGxvd2VyY2FzZSBlLCBhY3V0ZSBhY2NlbnRcbiAgMHg1ZTogMHhlZCwgLy8gbG93ZXJjYXNlIGksIGFjdXRlIGFjY2VudFxuICAweDVmOiAweGYzLCAvLyBsb3dlcmNhc2UgbywgYWN1dGUgYWNjZW50XG4gIDB4NjA6IDB4ZmEsIC8vIGxvd2VyY2FzZSB1LCBhY3V0ZSBhY2NlbnRcbiAgMHg3YjogMHhlNywgLy8gbG93ZXJjYXNlIGMgd2l0aCBjZWRpbGxhXG4gIDB4N2M6IDB4ZjcsIC8vIGRpdmlzaW9uIHN5bWJvbFxuICAweDdkOiAweGQxLCAvLyB1cHBlcmNhc2UgTiB0aWxkZVxuICAweDdlOiAweGYxLCAvLyBsb3dlcmNhc2UgbiB0aWxkZVxuICAweDdmOiAweDI1ODgsIC8vIEZ1bGwgYmxvY2tcbiAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMTYgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDExIEFORCBMT1cgQkVUV0VFTiAweDMwIEFORCAweDNGXG4gIC8vIFRISVMgTUVBTlMgVEhBVCBcXHg1MCBNVVNUIEJFIEFEREVEIFRPIFRIRSBWQUxVRVNcbiAgMHg4MDogMHhhZSwgLy8gUmVnaXN0ZXJlZCBzeW1ib2wgKFIpXG4gIDB4ODE6IDB4YjAsIC8vIGRlZ3JlZSBzaWduXG4gIDB4ODI6IDB4YmQsIC8vIDEvMiBzeW1ib2xcbiAgMHg4MzogMHhiZiwgLy8gSW52ZXJ0ZWQgKG9wZW4pIHF1ZXN0aW9uIG1hcmtcbiAgMHg4NDogMHgyMTIyLCAvLyBUcmFkZW1hcmsgc3ltYm9sIChUTSlcbiAgMHg4NTogMHhhMiwgLy8gQ2VudHMgc3ltYm9sXG4gIDB4ODY6IDB4YTMsIC8vIFBvdW5kcyBzdGVybGluZ1xuICAweDg3OiAweDI2NmEsIC8vIE11c2ljIDgndGggbm90ZVxuICAweDg4OiAweGUwLCAvLyBsb3dlcmNhc2UgYSwgZ3JhdmUgYWNjZW50XG4gIDB4ODk6IDB4MjAsIC8vIHRyYW5zcGFyZW50IHNwYWNlIChyZWd1bGFyKVxuICAweDhhOiAweGU4LCAvLyBsb3dlcmNhc2UgZSwgZ3JhdmUgYWNjZW50XG4gIDB4OGI6IDB4ZTIsIC8vIGxvd2VyY2FzZSBhLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhjOiAweGVhLCAvLyBsb3dlcmNhc2UgZSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4ZDogMHhlZSwgLy8gbG93ZXJjYXNlIGksIGNpcmN1bWZsZXggYWNjZW50XG4gIDB4OGU6IDB4ZjQsIC8vIGxvd2VyY2FzZSBvLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhmOiAweGZiLCAvLyBsb3dlcmNhc2UgdSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEyIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXG4gIDB4OTA6IDB4YzEsIC8vIGNhcGl0YWwgbGV0dGVyIEEgd2l0aCBhY3V0ZVxuICAweDkxOiAweGM5LCAvLyBjYXBpdGFsIGxldHRlciBFIHdpdGggYWN1dGVcbiAgMHg5MjogMHhkMywgLy8gY2FwaXRhbCBsZXR0ZXIgTyB3aXRoIGFjdXRlXG4gIDB4OTM6IDB4ZGEsIC8vIGNhcGl0YWwgbGV0dGVyIFUgd2l0aCBhY3V0ZVxuICAweDk0OiAweGRjLCAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggZGlhcmVzaXNcbiAgMHg5NTogMHhmYywgLy8gbG93ZXJjYXNlIGxldHRlciBVIHdpdGggZGlhZXJlc2lzXG4gIDB4OTY6IDB4MjAxOCwgLy8gb3BlbmluZyBzaW5nbGUgcXVvdGVcbiAgMHg5NzogMHhhMSwgLy8gaW52ZXJ0ZWQgZXhjbGFtYXRpb24gbWFya1xuICAweDk4OiAweDJhLCAvLyBhc3Rlcmlza1xuICAweDk5OiAweDIwMTksIC8vIGNsb3Npbmcgc2luZ2xlIHF1b3RlXG4gIDB4OWE6IDB4MjUwMSwgLy8gYm94IGRyYXdpbmdzIGhlYXZ5IGhvcml6b250YWxcbiAgMHg5YjogMHhhOSwgLy8gY29weXJpZ2h0IHNpZ25cbiAgMHg5YzogMHgyMTIwLCAvLyBTZXJ2aWNlIG1hcmtcbiAgMHg5ZDogMHgyMDIyLCAvLyAocm91bmQpIGJ1bGxldFxuICAweDllOiAweDIwMWMsIC8vIExlZnQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXG4gIDB4OWY6IDB4MjAxZCwgLy8gUmlnaHQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXG4gIDB4YTA6IDB4YzAsIC8vIHVwcGVyY2FzZSBBLCBncmF2ZSBhY2NlbnRcbiAgMHhhMTogMHhjMiwgLy8gdXBwZXJjYXNlIEEsIGNpcmN1bWZsZXhcbiAgMHhhMjogMHhjNywgLy8gdXBwZXJjYXNlIEMgd2l0aCBjZWRpbGxhXG4gIDB4YTM6IDB4YzgsIC8vIHVwcGVyY2FzZSBFLCBncmF2ZSBhY2NlbnRcbiAgMHhhNDogMHhjYSwgLy8gdXBwZXJjYXNlIEUsIGNpcmN1bWZsZXhcbiAgMHhhNTogMHhjYiwgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGRpYXJlc2lzXG4gIDB4YTY6IDB4ZWIsIC8vIGxvd2VyY2FzZSBsZXR0ZXIgZSB3aXRoIGRpYXJlc2lzXG4gIDB4YTc6IDB4Y2UsIC8vIHVwcGVyY2FzZSBJLCBjaXJjdW1mbGV4XG4gIDB4YTg6IDB4Y2YsIC8vIHVwcGVyY2FzZSBJLCB3aXRoIGRpYXJlc2lzXG4gIDB4YTk6IDB4ZWYsIC8vIGxvd2VyY2FzZSBpLCB3aXRoIGRpYXJlc2lzXG4gIDB4YWE6IDB4ZDQsIC8vIHVwcGVyY2FzZSBPLCBjaXJjdW1mbGV4XG4gIDB4YWI6IDB4ZDksIC8vIHVwcGVyY2FzZSBVLCBncmF2ZSBhY2NlbnRcbiAgMHhhYzogMHhmOSwgLy8gbG93ZXJjYXNlIHUsIGdyYXZlIGFjY2VudFxuICAweGFkOiAweGRiLCAvLyB1cHBlcmNhc2UgVSwgY2lyY3VtZmxleFxuICAweGFlOiAweGFiLCAvLyBsZWZ0LXBvaW50aW5nIGRvdWJsZSBhbmdsZSBxdW90YXRpb24gbWFya1xuICAweGFmOiAweGJiLCAvLyByaWdodC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEzIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXG4gIDB4YjA6IDB4YzMsIC8vIFVwcGVyY2FzZSBBLCB0aWxkZVxuICAweGIxOiAweGUzLCAvLyBMb3dlcmNhc2UgYSwgdGlsZGVcbiAgMHhiMjogMHhjZCwgLy8gVXBwZXJjYXNlIEksIGFjdXRlIGFjY2VudFxuICAweGIzOiAweGNjLCAvLyBVcHBlcmNhc2UgSSwgZ3JhdmUgYWNjZW50XG4gIDB4YjQ6IDB4ZWMsIC8vIExvd2VyY2FzZSBpLCBncmF2ZSBhY2NlbnRcbiAgMHhiNTogMHhkMiwgLy8gVXBwZXJjYXNlIE8sIGdyYXZlIGFjY2VudFxuICAweGI2OiAweGYyLCAvLyBMb3dlcmNhc2UgbywgZ3JhdmUgYWNjZW50XG4gIDB4Yjc6IDB4ZDUsIC8vIFVwcGVyY2FzZSBPLCB0aWxkZVxuICAweGI4OiAweGY1LCAvLyBMb3dlcmNhc2UgbywgdGlsZGVcbiAgMHhiOTogMHg3YiwgLy8gT3BlbiBjdXJseSBicmFjZVxuICAweGJhOiAweDdkLCAvLyBDbG9zaW5nIGN1cmx5IGJyYWNlXG4gIDB4YmI6IDB4NWMsIC8vIEJhY2tzbGFzaFxuICAweGJjOiAweDVlLCAvLyBDYXJldFxuICAweGJkOiAweDVmLCAvLyBVbmRlcnNjb3JlXG4gIDB4YmU6IDB4N2MsIC8vIFBpcGUgKHZlcnRpY2FsIGxpbmUpXG4gIDB4YmY6IDB4MjIzYywgLy8gVGlsZGUgb3BlcmF0b3JcbiAgMHhjMDogMHhjNCwgLy8gVXBwZXJjYXNlIEEsIHVtbGF1dFxuICAweGMxOiAweGU0LCAvLyBMb3dlcmNhc2UgQSwgdW1sYXV0XG4gIDB4YzI6IDB4ZDYsIC8vIFVwcGVyY2FzZSBPLCB1bWxhdXRcbiAgMHhjMzogMHhmNiwgLy8gTG93ZXJjYXNlIG8sIHVtbGF1dFxuICAweGM0OiAweGRmLCAvLyBFc3N6ZXR0IChzaGFycCBTKVxuICAweGM1OiAweGE1LCAvLyBZZW4gc3ltYm9sXG4gIDB4YzY6IDB4YTQsIC8vIEdlbmVyaWMgY3VycmVuY3kgc2lnblxuICAweGM3OiAweDI1MDMsIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB2ZXJ0aWNhbFxuICAweGM4OiAweGM1LCAvLyBVcHBlcmNhc2UgQSwgcmluZ1xuICAweGM5OiAweGU1LCAvLyBMb3dlcmNhc2UgQSwgcmluZ1xuICAweGNhOiAweGQ4LCAvLyBVcHBlcmNhc2UgTywgc3Ryb2tlXG4gIDB4Y2I6IDB4ZjgsIC8vIExvd2VyY2FzZSBvLCBzdHJva1xuICAweGNjOiAweDI1MGYsIC8vIEJveCBkcmF3aW5ncyBoZWF2eSBkb3duIGFuZCByaWdodFxuICAweGNkOiAweDI1MTMsIC8vIEJveCBkcmF3aW5ncyBoZWF2eSBkb3duIGFuZCBsZWZ0XG4gIDB4Y2U6IDB4MjUxNywgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHVwIGFuZCByaWdodFxuICAweGNmOiAweDI1MWIgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHVwIGFuZCBsZWZ0XG59O1xuXG4vKipcbiAqIFV0aWxzXG4gKi9cbmxldCBnZXRDaGFyRm9yQnl0ZSA9IGZ1bmN0aW9uIChieXRlKSB7XG4gIGxldCBjaGFyQ29kZSA9IGJ5dGU7XG4gIGlmIChzcGVjaWFsQ2VhNjA4Q2hhcnNDb2Rlcy5oYXNPd25Qcm9wZXJ0eShieXRlKSkge1xuICAgIGNoYXJDb2RlID0gc3BlY2lhbENlYTYwOENoYXJzQ29kZXNbYnl0ZV07XG4gIH1cblxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG59O1xuXG5sZXQgTlJfUk9XUyA9IDE1LFxuICBOUl9DT0xTID0gMTAwO1xuLy8gVGFibGVzIHRvIGxvb2sgdXAgcm93IGZyb20gUEFDIGRhdGFcbmxldCByb3dzTG93Q2gxID0geyAweDExOiAxLCAweDEyOiAzLCAweDE1OiA1LCAweDE2OiA3LCAweDE3OiA5LCAweDEwOiAxMSwgMHgxMzogMTIsIDB4MTQ6IDE0IH07XG5sZXQgcm93c0hpZ2hDaDEgPSB7IDB4MTE6IDIsIDB4MTI6IDQsIDB4MTU6IDYsIDB4MTY6IDgsIDB4MTc6IDEwLCAweDEzOiAxMywgMHgxNDogMTUgfTtcbmxldCByb3dzTG93Q2gyID0geyAweDE5OiAxLCAweDFBOiAzLCAweDFEOiA1LCAweDFFOiA3LCAweDFGOiA5LCAweDE4OiAxMSwgMHgxQjogMTIsIDB4MUM6IDE0IH07XG5sZXQgcm93c0hpZ2hDaDIgPSB7IDB4MTk6IDIsIDB4MUE6IDQsIDB4MUQ6IDYsIDB4MUU6IDgsIDB4MUY6IDEwLCAweDFCOiAxMywgMHgxQzogMTUgfTtcblxubGV0IGJhY2tncm91bmRDb2xvcnMgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnLCAnYmxhY2snLCAndHJhbnNwYXJlbnQnXTtcblxuLyoqXG4gKiBTaW1wbGUgbG9nZ2VyIGNsYXNzIHRvIGJlIGFibGUgdG8gd3JpdGUgd2l0aCB0aW1lLXN0YW1wcyBhbmQgZmlsdGVyIG9uIGxldmVsLlxuICovXG5sZXQgbG9nZ2VyID0ge1xuICB2ZXJib3NlRmlsdGVyOiB7ICdEQVRBJzogMywgJ0RFQlVHJzogMywgJ0lORk8nOiAyLCAnV0FSTklORyc6IDIsICdURVhUJzogMSwgJ0VSUk9SJzogMCB9LFxuICB0aW1lOiBudWxsLFxuICB2ZXJib3NlTGV2ZWw6IDAsIC8vIE9ubHkgd3JpdGUgZXJyb3JzXG4gIHNldFRpbWU6IGZ1bmN0aW9uIChuZXdUaW1lKSB7XG4gICAgdGhpcy50aW1lID0gbmV3VGltZTtcbiAgfSxcbiAgbG9nOiBmdW5jdGlvbiAoc2V2ZXJpdHksIG1zZykge1xuICAgIGxldCBtaW5MZXZlbCA9IHRoaXMudmVyYm9zZUZpbHRlcltzZXZlcml0eV07XG4gICAgaWYgKHRoaXMudmVyYm9zZUxldmVsID49IG1pbkxldmVsKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnRpbWUgKyAnIFsnICsgc2V2ZXJpdHkgKyAnXSAnICsgbXNnKTtcbiAgICB9XG4gIH1cbn07XG5cbmxldCBudW1BcnJheVRvSGV4QXJyYXkgPSBmdW5jdGlvbiAobnVtQXJyYXkpIHtcbiAgbGV0IGhleEFycmF5ID0gW107XG4gIGZvciAobGV0IGogPSAwOyBqIDwgbnVtQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICBoZXhBcnJheS5wdXNoKG51bUFycmF5W2pdLnRvU3RyaW5nKDE2KSk7XG4gIH1cblxuICByZXR1cm4gaGV4QXJyYXk7XG59O1xuXG5jbGFzcyBQZW5TdGF0ZSB7XG4gIGNvbnN0cnVjdG9yIChmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKSB7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZCB8fCAnd2hpdGUnO1xuICAgIHRoaXMudW5kZXJsaW5lID0gdW5kZXJsaW5lIHx8IGZhbHNlO1xuICAgIHRoaXMuaXRhbGljcyA9IGl0YWxpY3MgfHwgZmFsc2U7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZCB8fCAnYmxhY2snO1xuICAgIHRoaXMuZmxhc2ggPSBmbGFzaCB8fCBmYWxzZTtcbiAgfVxuXG4gIHJlc2V0ICgpIHtcbiAgICB0aGlzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xuICAgIHRoaXMudW5kZXJsaW5lID0gZmFsc2U7XG4gICAgdGhpcy5pdGFsaWNzID0gZmFsc2U7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gJ2JsYWNrJztcbiAgICB0aGlzLmZsYXNoID0gZmFsc2U7XG4gIH1cblxuICBzZXRTdHlsZXMgKHN0eWxlcykge1xuICAgIGxldCBhdHRyaWJzID0gWydmb3JlZ3JvdW5kJywgJ3VuZGVybGluZScsICdpdGFsaWNzJywgJ2JhY2tncm91bmQnLCAnZmxhc2gnXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzdHlsZSA9IGF0dHJpYnNbaV07XG4gICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICB0aGlzW3N0eWxlXSA9IHN0eWxlc1tzdHlsZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNEZWZhdWx0ICgpIHtcbiAgICByZXR1cm4gKHRoaXMuZm9yZWdyb3VuZCA9PT0gJ3doaXRlJyAmJiAhdGhpcy51bmRlcmxpbmUgJiYgIXRoaXMuaXRhbGljcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZCA9PT0gJ2JsYWNrJyAmJiAhdGhpcy5mbGFzaCk7XG4gIH1cblxuICBlcXVhbHMgKG90aGVyKSB7XG4gICAgcmV0dXJuICgodGhpcy5mb3JlZ3JvdW5kID09PSBvdGhlci5mb3JlZ3JvdW5kKSAmJlxuICAgICAgICAgICAgICAgICAodGhpcy51bmRlcmxpbmUgPT09IG90aGVyLnVuZGVybGluZSkgJiZcbiAgICAgICAgICAgICAgICAgKHRoaXMuaXRhbGljcyA9PT0gb3RoZXIuaXRhbGljcykgJiZcbiAgICAgICAgICAgICAgICAgKHRoaXMuYmFja2dyb3VuZCA9PT0gb3RoZXIuYmFja2dyb3VuZCkgJiZcbiAgICAgICAgICAgICAgICAgKHRoaXMuZmxhc2ggPT09IG90aGVyLmZsYXNoKSk7XG4gIH1cblxuICBjb3B5IChuZXdQZW5TdGF0ZSkge1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IG5ld1BlblN0YXRlLmZvcmVncm91bmQ7XG4gICAgdGhpcy51bmRlcmxpbmUgPSBuZXdQZW5TdGF0ZS51bmRlcmxpbmU7XG4gICAgdGhpcy5pdGFsaWNzID0gbmV3UGVuU3RhdGUuaXRhbGljcztcbiAgICB0aGlzLmJhY2tncm91bmQgPSBuZXdQZW5TdGF0ZS5iYWNrZ3JvdW5kO1xuICAgIHRoaXMuZmxhc2ggPSBuZXdQZW5TdGF0ZS5mbGFzaDtcbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gKCdjb2xvcj0nICsgdGhpcy5mb3JlZ3JvdW5kICsgJywgdW5kZXJsaW5lPScgKyB0aGlzLnVuZGVybGluZSArICcsIGl0YWxpY3M9JyArIHRoaXMuaXRhbGljcyArXG4gICAgICAgICAgICAnLCBiYWNrZ3JvdW5kPScgKyB0aGlzLmJhY2tncm91bmQgKyAnLCBmbGFzaD0nICsgdGhpcy5mbGFzaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBVbmljb2RlIGNoYXJhY3RlciB3aXRoIHN0eWxpbmcgYW5kIGJhY2tncm91bmQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgU3R5bGVkVW5pY29kZUNoYXIge1xuICBjb25zdHJ1Y3RvciAodWNoYXIsIGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpIHtcbiAgICB0aGlzLnVjaGFyID0gdWNoYXIgfHwgJyAnOyAvLyB1bmljb2RlIGNoYXJhY3RlclxuICAgIHRoaXMucGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoZm9yZWdyb3VuZCwgdW5kZXJsaW5lLCBpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCk7XG4gIH1cblxuICByZXNldCAoKSB7XG4gICAgdGhpcy51Y2hhciA9ICcgJztcbiAgICB0aGlzLnBlblN0YXRlLnJlc2V0KCk7XG4gIH1cblxuICBzZXRDaGFyICh1Y2hhciwgbmV3UGVuU3RhdGUpIHtcbiAgICB0aGlzLnVjaGFyID0gdWNoYXI7XG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgfVxuXG4gIHNldFBlblN0YXRlIChuZXdQZW5TdGF0ZSkge1xuICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdQZW5TdGF0ZSk7XG4gIH1cblxuICBlcXVhbHMgKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMudWNoYXIgPT09IG90aGVyLnVjaGFyICYmIHRoaXMucGVuU3RhdGUuZXF1YWxzKG90aGVyLnBlblN0YXRlKTtcbiAgfVxuXG4gIGNvcHkgKG5ld0NoYXIpIHtcbiAgICB0aGlzLnVjaGFyID0gbmV3Q2hhci51Y2hhcjtcbiAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3Q2hhci5wZW5TdGF0ZSk7XG4gIH1cblxuICBpc0VtcHR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gJyAnICYmIHRoaXMucGVuU3RhdGUuaXNEZWZhdWx0KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDRUEtNjA4IHJvdyBjb25zaXN0aW5nIG9mIE5SX0NPTFMgaW5zdGFuY2VzIG9mIFN0eWxlZFVuaWNvZGVDaGFyLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFJvdyB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmNoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIHRoaXMuY2hhcnMucHVzaChuZXcgU3R5bGVkVW5pY29kZUNoYXIoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuY3VyclBlblN0YXRlID0gbmV3IFBlblN0YXRlKCk7XG4gIH1cblxuICBlcXVhbHMgKG90aGVyKSB7XG4gICAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLmNoYXJzW2ldLmVxdWFscyhvdGhlci5jaGFyc1tpXSkpIHtcbiAgICAgICAgZXF1YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcXVhbDtcbiAgfVxuXG4gIGNvcHkgKG90aGVyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIHRoaXMuY2hhcnNbaV0uY29weShvdGhlci5jaGFyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgaXNFbXB0eSAoKSB7XG4gICAgbGV0IGVtcHR5ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLmNoYXJzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5O1xuICB9XG5cbiAgLyoqXG4gICAgICogIFNldCB0aGUgY3Vyc29yIHRvIGEgdmFsaWQgY29sdW1uLlxuICAgICAqL1xuICBzZXRDdXJzb3IgKGFic1Bvcykge1xuICAgIGlmICh0aGlzLnBvcyAhPT0gYWJzUG9zKSB7XG4gICAgICB0aGlzLnBvcyA9IGFic1BvcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wb3MgPCAwKSB7XG4gICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdOZWdhdGl2ZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucG9zID4gTlJfQ09MUykge1xuICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnVG9vIGxhcmdlIGN1cnNvciBwb3NpdGlvbiAnICsgdGhpcy5wb3MpO1xuICAgICAgdGhpcy5wb3MgPSBOUl9DT0xTO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgICAqIE1vdmUgdGhlIGN1cnNvciByZWxhdGl2ZSB0byBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAqL1xuICBtb3ZlQ3Vyc29yIChyZWxQb3MpIHtcbiAgICBsZXQgbmV3UG9zID0gdGhpcy5wb3MgKyByZWxQb3M7XG4gICAgaWYgKHJlbFBvcyA+IDEpIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLnBvcyArIDE7IGkgPCBuZXdQb3MgKyAxOyBpKyspIHtcbiAgICAgICAgdGhpcy5jaGFyc1tpXS5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2V0Q3Vyc29yKG5ld1Bvcyk7XG4gIH1cblxuICAvKipcbiAgICAgKiBCYWNrc3BhY2UsIG1vdmUgb25lIHN0ZXAgYmFjayBhbmQgY2xlYXIgY2hhcmFjdGVyLlxuICAgICAqL1xuICBiYWNrU3BhY2UgKCkge1xuICAgIHRoaXMubW92ZUN1cnNvcigtMSk7XG4gICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcignICcsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgfVxuXG4gIGluc2VydENoYXIgKGJ5dGUpIHtcbiAgICBpZiAoYnl0ZSA+PSAweDkwKSB7IC8vIEV4dGVuZGVkIGNoYXJcbiAgICAgIHRoaXMuYmFja1NwYWNlKCk7XG4gICAgfVxuICAgIGxldCBjaGFyID0gZ2V0Q2hhckZvckJ5dGUoYnl0ZSk7XG4gICAgaWYgKHRoaXMucG9zID49IE5SX0NPTFMpIHtcbiAgICAgIGxvZ2dlci5sb2coJ0VSUk9SJywgJ0Nhbm5vdCBpbnNlcnQgJyArIGJ5dGUudG9TdHJpbmcoMTYpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgKCcgKyBjaGFyICsgJykgYXQgcG9zaXRpb24gJyArIHRoaXMucG9zICsgJy4gU2tpcHBpbmcgaXQhJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2hhcnNbdGhpcy5wb3NdLnNldENoYXIoY2hhciwgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgIHRoaXMubW92ZUN1cnNvcigxKTtcbiAgfVxuXG4gIGNsZWFyRnJvbVBvcyAoc3RhcnRQb3MpIHtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSBzdGFydFBvczsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgdGhpcy5jaGFyc1tpXS5yZXNldCgpO1xuICAgIH1cbiAgfVxuXG4gIGNsZWFyICgpIHtcbiAgICB0aGlzLmNsZWFyRnJvbVBvcygwKTtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5jdXJyUGVuU3RhdGUucmVzZXQoKTtcbiAgfVxuXG4gIGNsZWFyVG9FbmRPZlJvdyAoKSB7XG4gICAgdGhpcy5jbGVhckZyb21Qb3ModGhpcy5wb3MpO1xuICB9XG5cbiAgZ2V0VGV4dFN0cmluZyAoKSB7XG4gICAgbGV0IGNoYXJzID0gW107XG4gICAgbGV0IGVtcHR5ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgbGV0IGNoYXIgPSB0aGlzLmNoYXJzW2ldLnVjaGFyO1xuICAgICAgaWYgKGNoYXIgIT09ICcgJykge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjaGFycy5wdXNoKGNoYXIpO1xuICAgIH1cbiAgICBpZiAoZW1wdHkpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgIH1cbiAgfVxuXG4gIHNldFBlblN0eWxlcyAoc3R5bGVzKSB7XG4gICAgdGhpcy5jdXJyUGVuU3RhdGUuc2V0U3R5bGVzKHN0eWxlcyk7XG4gICAgbGV0IGN1cnJDaGFyID0gdGhpcy5jaGFyc1t0aGlzLnBvc107XG4gICAgY3VyckNoYXIuc2V0UGVuU3RhdGUodGhpcy5jdXJyUGVuU3RhdGUpO1xuICB9XG59XG5cbi8qKlxuICogS2VlcCBhIENFQS02MDggc2NyZWVuIG9mIDMyeDE1IHN0eWxlZCBjaGFyYWN0ZXJzXG4gKiBAY29uc3RydWN0b3JcbiovXG5jbGFzcyBDYXB0aW9uU2NyZWVuIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMucm93cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICB0aGlzLnJvd3MucHVzaChuZXcgUm93KCkpO1xuICAgIH0gLy8gTm90ZSB0aGF0IHdlIHVzZSB6ZXJvLWJhc2VkIG51bWJlcmluZyAoMC0xNClcblxuICAgIHRoaXMuY3VyclJvdyA9IE5SX1JPV1MgLSAxO1xuICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICByZXNldCAoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xuICAgIH1cblxuICAgIHRoaXMuY3VyclJvdyA9IE5SX1JPV1MgLSAxO1xuICB9XG5cbiAgZXF1YWxzIChvdGhlcikge1xuICAgIGxldCBlcXVhbCA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5yb3dzW2ldLmVxdWFscyhvdGhlci5yb3dzW2ldKSkge1xuICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVxdWFsO1xuICB9XG5cbiAgY29weSAob3RoZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgdGhpcy5yb3dzW2ldLmNvcHkob3RoZXIucm93c1tpXSk7XG4gICAgfVxuICB9XG5cbiAgaXNFbXB0eSAoKSB7XG4gICAgbGV0IGVtcHR5ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLnJvd3NbaV0uaXNFbXB0eSgpKSB7XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cblxuICBiYWNrU3BhY2UgKCkge1xuICAgIGxldCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuYmFja1NwYWNlKCk7XG4gIH1cblxuICBjbGVhclRvRW5kT2ZSb3cgKCkge1xuICAgIGxldCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuY2xlYXJUb0VuZE9mUm93KCk7XG4gIH1cblxuICAvKipcbiAgICAgKiBJbnNlcnQgYSBjaGFyYWN0ZXIgKHdpdGhvdXQgc3R5bGluZykgaW4gdGhlIGN1cnJlbnQgcm93LlxuICAgICAqL1xuICBpbnNlcnRDaGFyIChjaGFyKSB7XG4gICAgbGV0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5pbnNlcnRDaGFyKGNoYXIpO1xuICB9XG5cbiAgc2V0UGVuIChzdHlsZXMpIHtcbiAgICBsZXQgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LnNldFBlblN0eWxlcyhzdHlsZXMpO1xuICB9XG5cbiAgbW92ZUN1cnNvciAocmVsUG9zKSB7XG4gICAgbGV0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5tb3ZlQ3Vyc29yKHJlbFBvcyk7XG4gIH1cblxuICBzZXRDdXJzb3IgKGFic1Bvcykge1xuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnc2V0Q3Vyc29yOiAnICsgYWJzUG9zKTtcbiAgICBsZXQgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LnNldEN1cnNvcihhYnNQb3MpO1xuICB9XG5cbiAgc2V0UEFDIChwYWNEYXRhKSB7XG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdwYWNEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KHBhY0RhdGEpKTtcbiAgICBsZXQgbmV3Um93ID0gcGFjRGF0YS5yb3cgLSAxO1xuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiBuZXdSb3cgPCB0aGlzLm5yUm9sbFVwUm93cyAtIDEpIHtcbiAgICAgIG5ld1JvdyA9IHRoaXMubnJSb2xsVXBSb3dzIC0gMTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhpcyBvbmx5IGFmZmVjdHMgUm9sbC11cCBDYXB0aW9ucyBieSBjaGVja2luZyB0aGlzLm5yUm9sbFVwUm93c1xuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiB0aGlzLmN1cnJSb3cgIT09IG5ld1Jvdykge1xuICAgICAgLy8gY2xlYXIgYWxsIHJvd3MgZmlyc3RcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3B5IHRoaXMubnJSb2xsVXBSb3dzIHJvd3MgZnJvbSBsYXN0T3V0cHV0U2NyZWVuIGFuZCBwbGFjZSBpdCBpbiB0aGUgbmV3Um93IGxvY2F0aW9uXG4gICAgICAvLyB0b3BSb3dJbmRleCAtIHRoZSBzdGFydCBvZiByb3dzIHRvIGNvcHkgKGluY2x1c2l2ZSBpbmRleClcbiAgICAgIGxldCB0b3BSb3dJbmRleCA9IHRoaXMuY3VyclJvdyArIDEgLSAodGhpcy5uclJvbGxVcFJvd3MpO1xuICAgICAgLy8gV2Ugb25seSBjb3B5IGlmIHRoZSBsYXN0IHBvc2l0aW9uIHdhcyBhbHJlYWR5IHNob3duLlxuICAgICAgLy8gV2UgdXNlIHRoZSBjdWVTdGFydFRpbWUgdmFsdWUgdG8gY2hlY2sgdGhpcy5cbiAgICAgIGNvbnN0IGxhc3RPdXRwdXRTY3JlZW4gPSB0aGlzLmxhc3RPdXRwdXRTY3JlZW47XG4gICAgICBpZiAobGFzdE91dHB1dFNjcmVlbikge1xuICAgICAgICBsZXQgcHJldkxpbmVUaW1lID0gbGFzdE91dHB1dFNjcmVlbi5yb3dzW3RvcFJvd0luZGV4XS5jdWVTdGFydFRpbWU7XG4gICAgICAgIGlmIChwcmV2TGluZVRpbWUgJiYgcHJldkxpbmVUaW1lIDwgbG9nZ2VyLnRpbWUpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnJSb2xsVXBSb3dzOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucm93c1tuZXdSb3cgLSB0aGlzLm5yUm9sbFVwUm93cyArIGkgKyAxXS5jb3B5KGxhc3RPdXRwdXRTY3JlZW4ucm93c1t0b3BSb3dJbmRleCArIGldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmN1cnJSb3cgPSBuZXdSb3c7XG4gICAgbGV0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIGlmIChwYWNEYXRhLmluZGVudCAhPT0gbnVsbCkge1xuICAgICAgbGV0IGluZGVudCA9IHBhY0RhdGEuaW5kZW50O1xuICAgICAgbGV0IHByZXZQb3MgPSBNYXRoLm1heChpbmRlbnQgLSAxLCAwKTtcbiAgICAgIHJvdy5zZXRDdXJzb3IocGFjRGF0YS5pbmRlbnQpO1xuICAgICAgcGFjRGF0YS5jb2xvciA9IHJvdy5jaGFyc1twcmV2UG9zXS5wZW5TdGF0ZS5mb3JlZ3JvdW5kO1xuICAgIH1cbiAgICBsZXQgc3R5bGVzID0geyBmb3JlZ3JvdW5kOiBwYWNEYXRhLmNvbG9yLCB1bmRlcmxpbmU6IHBhY0RhdGEudW5kZXJsaW5lLCBpdGFsaWNzOiBwYWNEYXRhLml0YWxpY3MsIGJhY2tncm91bmQ6ICdibGFjaycsIGZsYXNoOiBmYWxzZSB9O1xuICAgIHRoaXMuc2V0UGVuKHN0eWxlcyk7XG4gIH1cblxuICAvKipcbiAgICAgKiBTZXQgYmFja2dyb3VuZC9leHRyYSBmb3JlZ3JvdW5kLCBidXQgZmlyc3QgZG8gYmFja19zcGFjZSwgYW5kIHRoZW4gaW5zZXJ0IHNwYWNlIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkuXG4gICAgICovXG4gIHNldEJrZ0RhdGEgKGJrZ0RhdGEpIHtcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ2JrZ0RhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkoYmtnRGF0YSkpO1xuICAgIHRoaXMuYmFja1NwYWNlKCk7XG4gICAgdGhpcy5zZXRQZW4oYmtnRGF0YSk7XG4gICAgdGhpcy5pbnNlcnRDaGFyKDB4MjApOyAvLyBTcGFjZVxuICB9XG5cbiAgc2V0Um9sbFVwUm93cyAobnJSb3dzKSB7XG4gICAgdGhpcy5uclJvbGxVcFJvd3MgPSBuclJvd3M7XG4gIH1cblxuICByb2xsVXAgKCkge1xuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyA9PT0gbnVsbCkge1xuICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAncm9sbF91cCBidXQgbnJSb2xsVXBSb3dzIG5vdCBzZXQgeWV0Jyk7XG4gICAgICByZXR1cm47IC8vIE5vdCBwcm9wZXJseSBzZXR1cFxuICAgIH1cbiAgICBsb2dnZXIubG9nKCdURVhUJywgdGhpcy5nZXREaXNwbGF5VGV4dCgpKTtcbiAgICBsZXQgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gdGhpcy5uclJvbGxVcFJvd3M7XG4gICAgbGV0IHRvcFJvdyA9IHRoaXMucm93cy5zcGxpY2UodG9wUm93SW5kZXgsIDEpWzBdO1xuICAgIHRvcFJvdy5jbGVhcigpO1xuICAgIHRoaXMucm93cy5zcGxpY2UodGhpcy5jdXJyUm93LCAwLCB0b3BSb3cpO1xuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUm9sbGluZyB1cCcpO1xuICAgIC8vIGxvZ2dlci5sb2coJ1RFWFQnLCB0aGlzLmdldF9kaXNwbGF5X3RleHQoKSlcbiAgfVxuXG4gIC8qKlxuICAgICogR2V0IGFsbCBub24tZW1wdHkgcm93cyB3aXRoIGFzIHVuaWNvZGUgdGV4dC5cbiAgICAqL1xuICBnZXREaXNwbGF5VGV4dCAoYXNPbmVSb3cpIHtcbiAgICBhc09uZVJvdyA9IGFzT25lUm93IHx8IGZhbHNlO1xuICAgIGxldCBkaXNwbGF5VGV4dCA9IFtdO1xuICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgbGV0IHJvd05yID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIGxldCByb3dUZXh0ID0gdGhpcy5yb3dzW2ldLmdldFRleHRTdHJpbmcoKTtcbiAgICAgIGlmIChyb3dUZXh0KSB7XG4gICAgICAgIHJvd05yID0gaSArIDE7XG4gICAgICAgIGlmIChhc09uZVJvdykge1xuICAgICAgICAgIGRpc3BsYXlUZXh0LnB1c2goJ1JvdyAnICsgcm93TnIgKyAnOiBcXCcnICsgcm93VGV4dCArICdcXCcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKHJvd1RleHQudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlzcGxheVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGFzT25lUm93KSB7XG4gICAgICAgIHRleHQgPSAnWycgKyBkaXNwbGF5VGV4dC5qb2luKCcgfCAnKSArICddJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBkaXNwbGF5VGV4dC5qb2luKCdcXG4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICBnZXRUZXh0QW5kRm9ybWF0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5yb3dzO1xuICB9XG59XG5cbi8vIHZhciBtb2RlcyA9IFsnTU9ERV9ST0xMLVVQJywgJ01PREVfUE9QLU9OJywgJ01PREVfUEFJTlQtT04nLCAnTU9ERV9URVhUJ107XG5cbmNsYXNzIENlYTYwOENoYW5uZWwge1xuICBjb25zdHJ1Y3RvciAoY2hhbm5lbE51bWJlciwgb3V0cHV0RmlsdGVyKSB7XG4gICAgdGhpcy5jaE5yID0gY2hhbm5lbE51bWJlcjtcbiAgICB0aGlzLm91dHB1dEZpbHRlciA9IG91dHB1dEZpbHRlcjtcbiAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgIHRoaXMudmVyYm9zZSA9IDA7XG4gICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xuICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gbmV3IENhcHRpb25TY3JlZW4oKTtcbiAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSBuZXcgQ2FwdGlvblNjcmVlbigpO1xuICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LnJvd3NbTlJfUk9XUyAtIDFdO1xuICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gbnVsbDsgLy8gS2VlcHMgdHJhY2sgb2Ygd2hlcmUgYSBjdWUgc3RhcnRlZC5cbiAgfVxuXG4gIHJlc2V0ICgpIHtcbiAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4ucmVzZXQoKTtcbiAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MgLSAxXTtcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7XG4gICAgdGhpcy5sYXN0Q3VlRW5kVGltZSA9IG51bGw7XG4gIH1cblxuICBnZXRIYW5kbGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRGaWx0ZXI7XG4gIH1cblxuICBzZXRIYW5kbGVyIChuZXdIYW5kbGVyKSB7XG4gICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBuZXdIYW5kbGVyO1xuICB9XG5cbiAgc2V0UEFDIChwYWNEYXRhKSB7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQQUMocGFjRGF0YSk7XG4gIH1cblxuICBzZXRCa2dEYXRhIChia2dEYXRhKSB7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRCa2dEYXRhKGJrZ0RhdGEpO1xuICB9XG5cbiAgc2V0TW9kZSAobmV3TW9kZSkge1xuICAgIGlmIChuZXdNb2RlID09PSB0aGlzLm1vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnTU9ERT0nICsgbmV3TW9kZSk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUE9QLU9OJykge1xuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuLnJlc2V0KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vZGUgIT09ICdNT0RFX1JPTEwtVVAnKSB7XG4gICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgfVxuXG4gIGluc2VydENoYXJzIChjaGFycykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4uaW5zZXJ0Q2hhcihjaGFyc1tpXSk7XG4gICAgfVxuXG4gICAgbGV0IHNjcmVlbiA9IHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5ID8gJ0RJU1AnIDogJ05PTl9ESVNQJztcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgc2NyZWVuICsgJzogJyArIHRoaXMud3JpdGVTY3JlZW4uZ2V0RGlzcGxheVRleHQodHJ1ZSkpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BBSU5ULU9OJyB8fCB0aGlzLm1vZGUgPT09ICdNT0RFX1JPTEwtVVAnKSB7XG4gICAgICBsb2dnZXIubG9nKCdURVhUJywgJ0RJU1BMQVlFRDogJyArIHRoaXMuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KHRydWUpKTtcbiAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGNjUkNMICgpIHsgLy8gUmVzdW1lIENhcHRpb24gTG9hZGluZyAoc3dpdGNoIG1vZGUgdG8gUG9wIE9uKVxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUkNMIC0gUmVzdW1lIENhcHRpb24gTG9hZGluZycpO1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9QT1AtT04nKTtcbiAgfVxuXG4gIGNjQlMgKCkgeyAvLyBCYWNrU3BhY2VcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0JTIC0gQmFja1NwYWNlJyk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfVEVYVCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLndyaXRlU2NyZWVuLmJhY2tTcGFjZSgpO1xuICAgIGlmICh0aGlzLndyaXRlU2NyZWVuID09PSB0aGlzLmRpc3BsYXllZE1lbW9yeSkge1xuICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgY2NBT0YgKCkgeyAvLyBSZXNlcnZlZCAoZm9ybWVybHkgQWxhcm0gT2ZmKVxuXG4gIH1cblxuICBjY0FPTiAoKSB7IC8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPbilcblxuICB9XG5cbiAgY2NERVIgKCkgeyAvLyBEZWxldGUgdG8gRW5kIG9mIFJvd1xuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnREVSLSBEZWxldGUgdG8gRW5kIG9mIFJvdycpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uY2xlYXJUb0VuZE9mUm93KCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gIH1cblxuICBjY1JVIChuclJvd3MpIHsgLy8gUm9sbC1VcCBDYXB0aW9ucy0yLDMsb3IgNCBSb3dzXG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdSVSgnICsgbnJSb3dzICsgJykgLSBSb2xsIFVwJyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9ST0xMLVVQJyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRSb2xsVXBSb3dzKG5yUm93cyk7XG4gIH1cblxuICBjY0ZPTiAoKSB7IC8vIEZsYXNoIE9uXG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdGT04gLSBGbGFzaCBPbicpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHsgZmxhc2g6IHRydWUgfSk7XG4gIH1cblxuICBjY1JEQyAoKSB7IC8vIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZyAoc3dpdGNoIG1vZGUgdG8gUGFpbnRPbilcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JEQyAtIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZycpO1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9QQUlOVC1PTicpO1xuICB9XG5cbiAgY2NUUiAoKSB7IC8vIFRleHQgUmVzdGFydCBpbiB0ZXh0IG1vZGUgKG5vdCBzdXBwb3J0ZWQsIGhvd2V2ZXIpXG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdUUicpO1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XG4gIH1cblxuICBjY1JURCAoKSB7IC8vIFJlc3VtZSBUZXh0IERpc3BsYXkgaW4gVGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUlREJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1RFWFQnKTtcbiAgfVxuXG4gIGNjRURNICgpIHsgLy8gRXJhc2UgRGlzcGxheWVkIE1lbW9yeVxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRURNIC0gRXJhc2UgRGlzcGxheWVkIE1lbW9yeScpO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICB9XG5cbiAgY2NDUiAoKSB7IC8vIENhcnJpYWdlIFJldHVyblxuICAgIGxvZ2dlci5sb2coJ0NSIC0gQ2FycmlhZ2UgUmV0dXJuJyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5yb2xsVXAoKTtcbiAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUodHJ1ZSk7XG4gIH1cblxuICBjY0VOTSAoKSB7IC8vIEVyYXNlIE5vbi1EaXNwbGF5ZWQgTWVtb3J5XG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdFTk0gLSBFcmFzZSBOb24tZGlzcGxheWVkIE1lbW9yeScpO1xuICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gIH1cblxuICBjY0VPQyAoKSB7IC8vIEVuZCBvZiBDYXB0aW9uIChGbGlwIE1lbW9yaWVzKVxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRU9DIC0gRW5kIE9mIENhcHRpb24nKTtcbiAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QT1AtT04nKSB7XG4gICAgICBsZXQgdG1wID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSB0bXA7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgICBsb2dnZXIubG9nKCdURVhUJywgJ0RJU1A6ICcgKyB0aGlzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCgpKTtcbiAgICB9XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICB9XG5cbiAgY2NUTyAobnJDb2xzKSB7IC8vIFRhYiBPZmZzZXQgMSwyLCBvciAzIGNvbHVtbnNcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1RPKCcgKyBuckNvbHMgKyAnKSAtIFRhYiBPZmZzZXQnKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLm1vdmVDdXJzb3IobnJDb2xzKTtcbiAgfVxuXG4gIGNjTUlEUk9XIChzZWNvbmRCeXRlKSB7IC8vIFBhcnNlIE1JRFJPVyBjb21tYW5kXG4gICAgbGV0IHN0eWxlcyA9IHsgZmxhc2g6IGZhbHNlIH07XG4gICAgc3R5bGVzLnVuZGVybGluZSA9IHNlY29uZEJ5dGUgJSAyID09PSAxO1xuICAgIHN0eWxlcy5pdGFsaWNzID0gc2Vjb25kQnl0ZSA+PSAweDJlO1xuICAgIGlmICghc3R5bGVzLml0YWxpY3MpIHtcbiAgICAgIGxldCBjb2xvckluZGV4ID0gTWF0aC5mbG9vcihzZWNvbmRCeXRlIC8gMikgLSAweDEwO1xuICAgICAgbGV0IGNvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YSddO1xuICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSBjb2xvcnNbY29sb3JJbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICB9XG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdNSURST1c6ICcgKyBKU09OLnN0cmluZ2lmeShzdHlsZXMpKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbihzdHlsZXMpO1xuICB9XG5cbiAgb3V0cHV0RGF0YVVwZGF0ZSAoZGlzcGF0Y2ggPSBmYWxzZSkge1xuICAgIGxldCB0ID0gbG9nZ2VyLnRpbWU7XG4gICAgaWYgKHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIpIHtcbiAgICAgIGlmICh0aGlzLmN1ZVN0YXJ0VGltZSA9PT0gbnVsbCAmJiAhdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7IC8vIFN0YXJ0IG9mIGEgbmV3IGN1ZVxuICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmVxdWFscyh0aGlzLmxhc3RPdXRwdXRTY3JlZW4pKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKHRoaXMuY3VlU3RhcnRUaW1lLCB0LCB0aGlzLmxhc3RPdXRwdXRTY3JlZW4pO1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoID09PSB0cnVlICYmIHRoaXMub3V0cHV0RmlsdGVyLmRpc3BhdGNoQ3VlKSB7XG4gICAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLmRpc3BhdGNoQ3VlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpID8gbnVsbCA6IHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5jb3B5KHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICB9XG4gIH1cblxuICBjdWVTcGxpdEF0VGltZSAodCkge1xuICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkpIHtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSkge1xuICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSh0aGlzLmN1ZVN0YXJ0VGltZSwgdCwgdGhpcy5kaXNwbGF5ZWRNZW1vcnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBDZWE2MDhQYXJzZXIge1xuICBjb25zdHJ1Y3RvciAoZmllbGQsIG91dDEsIG91dDIpIHtcbiAgICB0aGlzLmZpZWxkID0gZmllbGQgfHwgMTtcbiAgICB0aGlzLm91dHB1dHMgPSBbb3V0MSwgb3V0Ml07XG4gICAgdGhpcy5jaGFubmVscyA9IFtuZXcgQ2VhNjA4Q2hhbm5lbCgxLCBvdXQxKSwgbmV3IENlYTYwOENoYW5uZWwoMiwgb3V0MildO1xuICAgIHRoaXMuY3VyckNoTnIgPSAtMTsgLy8gV2lsbCBiZSAxIG9yIDJcbiAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDsgLy8gRmlyc3QgYnl0ZSBvZiBsYXN0IGNvbW1hbmRcbiAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDsgLy8gU2Vjb25kIGJ5dGUgb2YgbGFzdCBjb21tYW5kXG4gICAgdGhpcy5idWZmZXJlZERhdGEgPSBbXTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gICAgdGhpcy5sYXN0VGltZSA9IG51bGw7XG4gICAgdGhpcy5kYXRhQ291bnRlcnMgPSB7ICdwYWRkaW5nJzogMCwgJ2NoYXInOiAwLCAnY21kJzogMCwgJ290aGVyJzogMCB9O1xuICB9XG5cbiAgZ2V0SGFuZGxlciAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsc1tpbmRleF0uZ2V0SGFuZGxlcigpO1xuICB9XG5cbiAgc2V0SGFuZGxlciAoaW5kZXgsIG5ld0hhbmRsZXIpIHtcbiAgICB0aGlzLmNoYW5uZWxzW2luZGV4XS5zZXRIYW5kbGVyKG5ld0hhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAgICogQWRkIGRhdGEgZm9yIHRpbWUgdCBpbiBmb3JtcyBvZiBsaXN0IG9mIGJ5dGVzICh1bnNpZ25lZCBpbnRzKS4gVGhlIGJ5dGVzIGFyZSB0cmVhdGVkIGFzIHBhaXJzLlxuICAgICAqL1xuICBhZGREYXRhICh0LCBieXRlTGlzdCkge1xuICAgIGxldCBjbWRGb3VuZCwgYSwgYixcbiAgICAgIGNoYXJzRm91bmQgPSBmYWxzZTtcblxuICAgIHRoaXMubGFzdFRpbWUgPSB0O1xuICAgIGxvZ2dlci5zZXRUaW1lKHQpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlTGlzdC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgYSA9IGJ5dGVMaXN0W2ldICYgMHg3ZjtcbiAgICAgIGIgPSBieXRlTGlzdFtpICsgMV0gJiAweDdmO1xuICAgICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuICAgICAgICB0aGlzLmRhdGFDb3VudGVycy5wYWRkaW5nICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnREFUQScsICdbJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2kgKyAxXV0pICsgJ10gLT4gKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJyk7XG4gICAgICB9XG4gICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VDbWQoYSwgYik7XG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZU1pZHJvdyhhLCBiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VQQUMoYSwgYik7XG4gICAgICB9XG5cbiAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYik7XG4gICAgICB9XG5cbiAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgY2hhcnNGb3VuZCA9IHRoaXMucGFyc2VDaGFycyhhLCBiKTtcbiAgICAgICAgaWYgKGNoYXJzRm91bmQpIHtcbiAgICAgICAgICBpZiAodGhpcy5jdXJyQ2hOciAmJiB0aGlzLmN1cnJDaE5yID49IDApIHtcbiAgICAgICAgICAgIGxldCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1t0aGlzLmN1cnJDaE5yIC0gMV07XG4gICAgICAgICAgICBjaGFubmVsLmluc2VydENoYXJzKGNoYXJzRm91bmQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdXQVJOSU5HJywgJ05vIGNoYW5uZWwgZm91bmQgeWV0LiBURVhULU1PREU/Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY21kRm91bmQpIHtcbiAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMuY21kICs9IDI7XG4gICAgICB9IGVsc2UgaWYgKGNoYXJzRm91bmQpIHtcbiAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMuY2hhciArPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMub3RoZXIgKz0gMjtcbiAgICAgICAgbG9nZ2VyLmxvZygnV0FSTklORycsICdDb3VsZG5cXCd0IHBhcnNlIGNsZWFuZWQgZGF0YSAnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgb3JpZzogJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2kgKyAxXV0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICAgKiBQYXJzZSBDb21tYW5kLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBhIGNvbW1hbmQgd2FzIGZvdW5kXG4gICAgICovXG4gIHBhcnNlQ21kIChhLCBiKSB7XG4gICAgbGV0IGNoTnIgPSBudWxsO1xuXG4gICAgbGV0IGNvbmQxID0gKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxQykgJiYgKGIgPj0gMHgyMCAmJiBiIDw9IDB4MkYpO1xuICAgIGxldCBjb25kMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MUYpICYmIChiID49IDB4MjEgJiYgYiA8PSAweDIzKTtcbiAgICBpZiAoIShjb25kMSB8fCBjb25kMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYSA9PT0gdGhpcy5sYXN0Q21kQSAmJiBiID09PSB0aGlzLmxhc3RDbWRCKSB7XG4gICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsOyAvLyBSZXBlYXRlZCBjb21tYW5kcyBhcmUgZHJvcHBlZCAob25jZSlcbiAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ1JlcGVhdGVkIGNvbW1hbmQgKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpIGlzIGRyb3BwZWQnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChhID09PSAweDE0IHx8IGEgPT09IDB4MTcpIHtcbiAgICAgIGNoTnIgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaE5yID0gMjtcbiAgICB9IC8vIChhID09PSAweDFDIHx8IGE9PT0gMHgxZilcblxuICAgIGxldCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XG5cbiAgICBpZiAoYSA9PT0gMHgxNCB8fCBhID09PSAweDFDKSB7XG4gICAgICBpZiAoYiA9PT0gMHgyMCkge1xuICAgICAgICBjaGFubmVsLmNjUkNMKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjEpIHtcbiAgICAgICAgY2hhbm5lbC5jY0JTKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjIpIHtcbiAgICAgICAgY2hhbm5lbC5jY0FPRigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDIzKSB7XG4gICAgICAgIGNoYW5uZWwuY2NBT04oKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNCkge1xuICAgICAgICBjaGFubmVsLmNjREVSKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjUpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JVKDIpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI2KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVSgzKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNykge1xuICAgICAgICBjaGFubmVsLmNjUlUoNCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjgpIHtcbiAgICAgICAgY2hhbm5lbC5jY0ZPTigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI5KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSREMoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyQSkge1xuICAgICAgICBjaGFubmVsLmNjVFIoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyQikge1xuICAgICAgICBjaGFubmVsLmNjUlREKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkMpIHtcbiAgICAgICAgY2hhbm5lbC5jY0VETSgpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJEKSB7XG4gICAgICAgIGNoYW5uZWwuY2NDUigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJFKSB7XG4gICAgICAgIGNoYW5uZWwuY2NFTk0oKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyRikge1xuICAgICAgICBjaGFubmVsLmNjRU9DKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gYSA9PSAweDE3IHx8IGEgPT0gMHgxRlxuICAgICAgY2hhbm5lbC5jY1RPKGIgLSAweDIwKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0Q21kQSA9IGE7XG4gICAgdGhpcy5sYXN0Q21kQiA9IGI7XG4gICAgdGhpcy5jdXJyQ2hOciA9IGNoTnI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICAgKiBQYXJzZSBtaWRyb3cgc3R5bGluZyBjb21tYW5kXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gIHBhcnNlTWlkcm93IChhLCBiKSB7XG4gICAgbGV0IGNoTnIgPSBudWxsO1xuXG4gICAgaWYgKCgoYSA9PT0gMHgxMSkgfHwgKGEgPT09IDB4MTkpKSAmJiBiID49IDB4MjAgJiYgYiA8PSAweDJmKSB7XG4gICAgICBpZiAoYSA9PT0gMHgxMSkge1xuICAgICAgICBjaE5yID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoTnIgPSAyO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hOciAhPT0gdGhpcy5jdXJyQ2hOcikge1xuICAgICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdNaXNtYXRjaCBjaGFubmVsIGluIG1pZHJvdyBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XG4gICAgICBjaGFubmVsLmNjTUlEUk9XKGIpO1xuICAgICAgbG9nZ2VyLmxvZygnREVCVUcnLCAnTUlEUk9XICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICAgKiBQYXJzZSBQcmVhYmxlIEFjY2VzcyBDb2RlcyAoVGFibGUgNTMpLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBQQUMgZm91bmRcbiAgICAgKi9cbiAgcGFyc2VQQUMgKGEsIGIpIHtcbiAgICBsZXQgY2hOciA9IG51bGw7XG4gICAgbGV0IHJvdyA9IG51bGw7XG5cbiAgICBsZXQgY2FzZTEgPSAoKGEgPj0gMHgxMSAmJiBhIDw9IDB4MTcpIHx8IChhID49IDB4MTkgJiYgYSA8PSAweDFGKSkgJiYgKGIgPj0gMHg0MCAmJiBiIDw9IDB4N0YpO1xuICAgIGxldCBjYXNlMiA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmIChiID49IDB4NDAgJiYgYiA8PSAweDVGKTtcbiAgICBpZiAoIShjYXNlMSB8fCBjYXNlMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYSA9PT0gdGhpcy5sYXN0Q21kQSAmJiBiID09PSB0aGlzLmxhc3RDbWRCKSB7XG4gICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7IC8vIFJlcGVhdGVkIGNvbW1hbmRzIGFyZSBkcm9wcGVkIChvbmNlKVxuICAgIH1cblxuICAgIGNoTnIgPSAoYSA8PSAweDE3KSA/IDEgOiAyO1xuXG4gICAgaWYgKGIgPj0gMHg0MCAmJiBiIDw9IDB4NUYpIHtcbiAgICAgIHJvdyA9IChjaE5yID09PSAxKSA/IHJvd3NMb3dDaDFbYV0gOiByb3dzTG93Q2gyW2FdO1xuICAgIH0gZWxzZSB7IC8vIDB4NjAgPD0gYiA8PSAweDdGXG4gICAgICByb3cgPSAoY2hOciA9PT0gMSkgPyByb3dzSGlnaENoMVthXSA6IHJvd3NIaWdoQ2gyW2FdO1xuICAgIH1cbiAgICBsZXQgcGFjRGF0YSA9IHRoaXMuaW50ZXJwcmV0UEFDKHJvdywgYik7XG4gICAgbGV0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnIgLSAxXTtcbiAgICBjaGFubmVsLnNldFBBQyhwYWNEYXRhKTtcbiAgICB0aGlzLmxhc3RDbWRBID0gYTtcbiAgICB0aGlzLmxhc3RDbWRCID0gYjtcbiAgICB0aGlzLmN1cnJDaE5yID0gY2hOcjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIEludGVycHJldCB0aGUgc2Vjb25kIGJ5dGUgb2YgdGhlIHBhYywgYW5kIHJldHVybiB0aGUgaW5mb3JtYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gcGFjRGF0YSB3aXRoIHN0eWxlIHBhcmFtZXRlcnMuXG4gICAgICovXG4gIGludGVycHJldFBBQyAocm93LCBieXRlKSB7XG4gICAgbGV0IHBhY0luZGV4ID0gYnl0ZTtcbiAgICBsZXQgcGFjRGF0YSA9IHsgY29sb3I6IG51bGwsIGl0YWxpY3M6IGZhbHNlLCBpbmRlbnQ6IG51bGwsIHVuZGVybGluZTogZmFsc2UsIHJvdzogcm93IH07XG5cbiAgICBpZiAoYnl0ZSA+IDB4NUYpIHtcbiAgICAgIHBhY0luZGV4ID0gYnl0ZSAtIDB4NjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY0luZGV4ID0gYnl0ZSAtIDB4NDA7XG4gICAgfVxuXG4gICAgcGFjRGF0YS51bmRlcmxpbmUgPSAocGFjSW5kZXggJiAxKSA9PT0gMTtcbiAgICBpZiAocGFjSW5kZXggPD0gMHhkKSB7XG4gICAgICBwYWNEYXRhLmNvbG9yID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ3doaXRlJ11bTWF0aC5mbG9vcihwYWNJbmRleCAvIDIpXTtcbiAgICB9IGVsc2UgaWYgKHBhY0luZGV4IDw9IDB4Zikge1xuICAgICAgcGFjRGF0YS5pdGFsaWNzID0gdHJ1ZTtcbiAgICAgIHBhY0RhdGEuY29sb3IgPSAnd2hpdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNEYXRhLmluZGVudCA9IChNYXRoLmZsb29yKChwYWNJbmRleCAtIDB4MTApIC8gMikpICogNDtcbiAgICB9XG4gICAgcmV0dXJuIHBhY0RhdGE7IC8vIE5vdGUgdGhhdCByb3cgaGFzIHplcm8gb2Zmc2V0LiBUaGUgc3BlYyB1c2VzIDEuXG4gIH1cblxuICAvKipcbiAgICAgKiBQYXJzZSBjaGFyYWN0ZXJzLlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggMSB0byAyIGNvZGVzIGNvcnJlc3BvbmRpbmcgdG8gY2hhcnMsIGlmIGZvdW5kLiBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgcGFyc2VDaGFycyAoYSwgYikge1xuICAgIGxldCBjaGFubmVsTnIgPSBudWxsLFxuICAgICAgY2hhckNvZGVzID0gbnVsbCxcbiAgICAgIGNoYXJDb2RlMSA9IG51bGw7XG5cbiAgICBpZiAoYSA+PSAweDE5KSB7XG4gICAgICBjaGFubmVsTnIgPSAyO1xuICAgICAgY2hhckNvZGUxID0gYSAtIDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5uZWxOciA9IDE7XG4gICAgICBjaGFyQ29kZTEgPSBhO1xuICAgIH1cbiAgICBpZiAoY2hhckNvZGUxID49IDB4MTEgJiYgY2hhckNvZGUxIDw9IDB4MTMpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2hhcmFjdGVyXG4gICAgICBsZXQgb25lQ29kZSA9IGI7XG4gICAgICBpZiAoY2hhckNvZGUxID09PSAweDExKSB7XG4gICAgICAgIG9uZUNvZGUgPSBiICsgMHg1MDtcbiAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUxID09PSAweDEyKSB7XG4gICAgICAgIG9uZUNvZGUgPSBiICsgMHg3MDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uZUNvZGUgPSBiICsgMHg5MDtcbiAgICAgIH1cblxuICAgICAgbG9nZ2VyLmxvZygnSU5GTycsICdTcGVjaWFsIGNoYXIgXFwnJyArIGdldENoYXJGb3JCeXRlKG9uZUNvZGUpICsgJ1xcJyBpbiBjaGFubmVsICcgKyBjaGFubmVsTnIpO1xuICAgICAgY2hhckNvZGVzID0gW29uZUNvZGVdO1xuICAgIH0gZWxzZSBpZiAoYSA+PSAweDIwICYmIGEgPD0gMHg3Zikge1xuICAgICAgY2hhckNvZGVzID0gKGIgPT09IDApID8gW2FdIDogW2EsIGJdO1xuICAgIH1cbiAgICBpZiAoY2hhckNvZGVzKSB7XG4gICAgICBsZXQgaGV4Q29kZXMgPSBudW1BcnJheVRvSGV4QXJyYXkoY2hhckNvZGVzKTtcbiAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ0NoYXIgY29kZXMgPSAgJyArIGhleENvZGVzLmpvaW4oJywnKSk7XG4gICAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY2hhckNvZGVzO1xuICB9XG5cbiAgLyoqXG4gICAgKiBQYXJzZSBleHRlbmRlZCBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXMgd2VsbCBhcyBuZXcgZm9yZWdyb3VuZCBjb2xvciBibGFjay5cbiAgICAqIEByZXR1cm5ze0Jvb2xlYW59IFRlbGxzIGlmIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcmUgZm91bmRcbiAgICAqL1xuICBwYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzIChhLCBiKSB7XG4gICAgbGV0IGJrZ0RhdGEsXG4gICAgICBpbmRleCxcbiAgICAgIGNoTnIsXG4gICAgICBjaGFubmVsO1xuXG4gICAgbGV0IGNhc2UxID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgKGIgPj0gMHgyMCAmJiBiIDw9IDB4MmYpO1xuICAgIGxldCBjYXNlMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MWYpICYmIChiID49IDB4MmQgJiYgYiA8PSAweDJmKTtcbiAgICBpZiAoIShjYXNlMSB8fCBjYXNlMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBia2dEYXRhID0ge307XG4gICAgaWYgKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkge1xuICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChiIC0gMHgyMCkgLyAyKTtcbiAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9IGJhY2tncm91bmRDb2xvcnNbaW5kZXhdO1xuICAgICAgaWYgKGIgJSAyID09PSAxKSB7XG4gICAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9IGJrZ0RhdGEuYmFja2dyb3VuZCArICdfc2VtaSc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChiID09PSAweDJkKSB7XG4gICAgICBia2dEYXRhLmJhY2tncm91bmQgPSAndHJhbnNwYXJlbnQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBia2dEYXRhLmZvcmVncm91bmQgPSAnYmxhY2snO1xuICAgICAgaWYgKGIgPT09IDB4MmYpIHtcbiAgICAgICAgYmtnRGF0YS51bmRlcmxpbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjaE5yID0gKGEgPCAweDE4KSA/IDEgOiAyO1xuICAgIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnIgLSAxXTtcbiAgICBjaGFubmVsLnNldEJrZ0RhdGEoYmtnRGF0YSk7XG4gICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICAgKiBSZXNldCBzdGF0ZSBvZiBwYXJzZXIgYW5kIGl0cyBjaGFubmVscy5cbiAgICAgKi9cbiAgcmVzZXQgKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuY2hhbm5lbHNbaV0pIHtcbiAgICAgICAgdGhpcy5jaGFubmVsc1tpXS5yZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxhc3RDbWRBID0gbnVsbDtcbiAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFRyaWdnZXIgdGhlIGdlbmVyYXRpb24gb2YgYSBjdWUsIGFuZCB0aGUgc3RhcnQgb2YgYSBuZXcgb25lIGlmIGRpc3BsYXlTY3JlZW5zIGFyZSBub3QgZW1wdHkuXG4gICAgICovXG4gIGN1ZVNwbGl0QXRUaW1lICh0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5jaGFubmVsc1tpXSkge1xuICAgICAgICB0aGlzLmNoYW5uZWxzW2ldLmN1ZVNwbGl0QXRUaW1lKHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDZWE2MDhQYXJzZXI7XG4iLCIvLyBmcm9tIGh0dHA6Ly9tcDRyYS5vcmcvY29kZWNzLmh0bWxcbmNvbnN0IHNhbXBsZUVudHJ5Q29kZXNJU08gPSB7XG4gIGF1ZGlvOiB7XG4gICAgJ2EzZHMnOiB0cnVlLFxuICAgICdhYy0zJzogdHJ1ZSxcbiAgICAnYWMtNCc6IHRydWUsXG4gICAgJ2FsYWMnOiB0cnVlLFxuICAgICdhbGF3JzogdHJ1ZSxcbiAgICAnZHJhMSc6IHRydWUsXG4gICAgJ2R0cysnOiB0cnVlLFxuICAgICdkdHMtJzogdHJ1ZSxcbiAgICAnZHRzYyc6IHRydWUsXG4gICAgJ2R0c2UnOiB0cnVlLFxuICAgICdkdHNoJzogdHJ1ZSxcbiAgICAnZWMtMyc6IHRydWUsXG4gICAgJ2VuY2EnOiB0cnVlLFxuICAgICdnNzE5JzogdHJ1ZSxcbiAgICAnZzcyNic6IHRydWUsXG4gICAgJ200YWUnOiB0cnVlLFxuICAgICdtaGExJzogdHJ1ZSxcbiAgICAnbWhhMic6IHRydWUsXG4gICAgJ21obTEnOiB0cnVlLFxuICAgICdtaG0yJzogdHJ1ZSxcbiAgICAnbWxwYSc6IHRydWUsXG4gICAgJ21wNGEnOiB0cnVlLFxuICAgICdyYXcgJzogdHJ1ZSxcbiAgICAnT3B1cyc6IHRydWUsXG4gICAgJ3NhbXInOiB0cnVlLFxuICAgICdzYXdiJzogdHJ1ZSxcbiAgICAnc2F3cCc6IHRydWUsXG4gICAgJ3NldmMnOiB0cnVlLFxuICAgICdzcWNwJzogdHJ1ZSxcbiAgICAnc3Ntdic6IHRydWUsXG4gICAgJ3R3b3MnOiB0cnVlLFxuICAgICd1bGF3JzogdHJ1ZVxuICB9LFxuICB2aWRlbzoge1xuICAgICdhdmMxJzogdHJ1ZSxcbiAgICAnYXZjMic6IHRydWUsXG4gICAgJ2F2YzMnOiB0cnVlLFxuICAgICdhdmM0JzogdHJ1ZSxcbiAgICAnYXZjcCc6IHRydWUsXG4gICAgJ2RyYWMnOiB0cnVlLFxuICAgICdkdmF2JzogdHJ1ZSxcbiAgICAnZHZoZSc6IHRydWUsXG4gICAgJ2VuY3YnOiB0cnVlLFxuICAgICdoZXYxJzogdHJ1ZSxcbiAgICAnaHZjMSc6IHRydWUsXG4gICAgJ21qcDInOiB0cnVlLFxuICAgICdtcDR2JzogdHJ1ZSxcbiAgICAnbXZjMSc6IHRydWUsXG4gICAgJ212YzInOiB0cnVlLFxuICAgICdtdmMzJzogdHJ1ZSxcbiAgICAnbXZjNCc6IHRydWUsXG4gICAgJ3Jlc3YnOiB0cnVlLFxuICAgICdydjYwJzogdHJ1ZSxcbiAgICAnczI2Myc6IHRydWUsXG4gICAgJ3N2YzEnOiB0cnVlLFxuICAgICdzdmMyJzogdHJ1ZSxcbiAgICAndmMtMSc6IHRydWUsXG4gICAgJ3ZwMDgnOiB0cnVlLFxuICAgICd2cDA5JzogdHJ1ZVxuICB9XG59O1xuXG5mdW5jdGlvbiBpc0NvZGVjVHlwZSAoY29kZWMsIHR5cGUpIHtcbiAgY29uc3QgdHlwZUNvZGVzID0gc2FtcGxlRW50cnlDb2Rlc0lTT1t0eXBlXTtcbiAgcmV0dXJuICEhdHlwZUNvZGVzICYmIHR5cGVDb2Rlc1tjb2RlYy5zbGljZSgwLCA0KV0gPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzQ29kZWNTdXBwb3J0ZWRJbk1wNCAoY29kZWMsIHR5cGUpIHtcbiAgcmV0dXJuIHdpbmRvdy5NZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoYCR7dHlwZSB8fCAndmlkZW8nfS9tcDQ7Y29kZWNzPVwiJHtjb2RlY31cImApO1xufVxuXG5leHBvcnQgeyBpc0NvZGVjVHlwZSwgaXNDb2RlY1N1cHBvcnRlZEluTXA0IH07XG4iLCJpbXBvcnQgeyBmaXhMaW5lQnJlYWtzIH0gZnJvbSAnLi92dHRwYXJzZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gbmV3Q3VlICh0cmFjaywgc3RhcnRUaW1lLCBlbmRUaW1lLCBjYXB0aW9uU2NyZWVuKSB7XG4gIGxldCByb3c7XG4gIGxldCBjdWU7XG4gIGxldCBpbmRlbnRpbmc7XG4gIGxldCBpbmRlbnQ7XG4gIGxldCB0ZXh0O1xuICBsZXQgVlRUQ3VlID0gd2luZG93LlZUVEN1ZSB8fCB3aW5kb3cuVGV4dFRyYWNrQ3VlO1xuXG4gIGZvciAobGV0IHIgPSAwOyByIDwgY2FwdGlvblNjcmVlbi5yb3dzLmxlbmd0aDsgcisrKSB7XG4gICAgcm93ID0gY2FwdGlvblNjcmVlbi5yb3dzW3JdO1xuICAgIGluZGVudGluZyA9IHRydWU7XG4gICAgaW5kZW50ID0gMDtcbiAgICB0ZXh0ID0gJyc7XG5cbiAgICBpZiAoIXJvdy5pc0VtcHR5KCkpIHtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgcm93LmNoYXJzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgIGlmIChyb3cuY2hhcnNbY10udWNoYXIubWF0Y2goL1xccy8pICYmIGluZGVudGluZykge1xuICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHQgKz0gcm93LmNoYXJzW2NdLnVjaGFyO1xuICAgICAgICAgIGluZGVudGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBUbyBiZSB1c2VkIGZvciBjbGVhbmluZy11cCBvcnBoYW5lZCByb2xsLXVwIGNhcHRpb25zXG4gICAgICByb3cuY3VlU3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuXG4gICAgICAvLyBHaXZlIGEgc2xpZ2h0IGJ1bXAgdG8gdGhlIGVuZFRpbWUgaWYgaXQncyBlcXVhbCB0byBzdGFydFRpbWUgdG8gYXZvaWQgYSBTeW50YXhFcnJvciBpbiBJRVxuICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gZW5kVGltZSkge1xuICAgICAgICBlbmRUaW1lICs9IDAuMDAwMTtcbiAgICAgIH1cblxuICAgICAgY3VlID0gbmV3IFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIGZpeExpbmVCcmVha3ModGV4dC50cmltKCkpKTtcblxuICAgICAgaWYgKGluZGVudCA+PSAxNikge1xuICAgICAgICBpbmRlbnQtLTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGVudCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBWVFRDdWUubGluZSBnZXQncyBmbGFrZXkgd2hlbiB1c2luZyBjb250cm9scywgc28gbGV0J3Mgbm93IGluY2x1ZGUgbGluZSAxMyYxNFxuICAgICAgLy8gYWxzbywgZHJvcCBsaW5lIDEgc2luY2UgaXQncyB0byBjbG9zZSB0byB0aGUgdG9wXG4gICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLy8pKSB7XG4gICAgICAgIGN1ZS5saW5lID0gciArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdWUubGluZSA9IChyID4gNyA/IHIgLSAyIDogciArIDEpO1xuICAgICAgfVxuXG4gICAgICBjdWUuYWxpZ24gPSAnbGVmdCc7XG4gICAgICAvLyBDbGFtcCB0aGUgcG9zaXRpb24gYmV0d2VlbiAwIGFuZCAxMDAgLSBpZiBvdXQgb2YgdGhlc2UgYm91bmRzLCBGaXJlZm94IHRocm93cyBhbiBleGNlcHRpb24gYW5kIGNhcHRpb25zIGJyZWFrXG4gICAgICBjdWUucG9zaXRpb24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIDEwMCAqIChpbmRlbnQgLyAzMikgKyAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLy8pID8gNTAgOiAwKSkpO1xuICAgICAgdHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgQmluYXJ5U2VhcmNoIGZyb20gJy4vYmluYXJ5LXNlYXJjaCc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZEZpcnN0RnJhZ1dpdGhDQyAoZnJhZ21lbnRzLCBjYykge1xuICBsZXQgZmlyc3RGcmFnID0gbnVsbDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYWdtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGN1cnJlbnRGcmFnID0gZnJhZ21lbnRzW2ldO1xuICAgIGlmIChjdXJyZW50RnJhZyAmJiBjdXJyZW50RnJhZy5jYyA9PT0gY2MpIHtcbiAgICAgIGZpcnN0RnJhZyA9IGN1cnJlbnRGcmFnO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpcnN0RnJhZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGcmFnV2l0aENDIChmcmFnbWVudHMsIENDKSB7XG4gIHJldHVybiBCaW5hcnlTZWFyY2guc2VhcmNoKGZyYWdtZW50cywgKGNhbmRpZGF0ZSkgPT4ge1xuICAgIGlmIChjYW5kaWRhdGUuY2MgPCBDQykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChjYW5kaWRhdGUuY2MgPiBDQykge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyAobGFzdEZyYWcsIGxhc3RMZXZlbCwgZGV0YWlscykge1xuICBsZXQgc2hvdWxkQWxpZ24gPSBmYWxzZTtcbiAgaWYgKGxhc3RMZXZlbCAmJiBsYXN0TGV2ZWwuZGV0YWlscyAmJiBkZXRhaWxzKSB7XG4gICAgaWYgKGRldGFpbHMuZW5kQ0MgPiBkZXRhaWxzLnN0YXJ0Q0MgfHwgKGxhc3RGcmFnICYmIGxhc3RGcmFnLmNjIDwgZGV0YWlscy5zdGFydENDKSkge1xuICAgICAgc2hvdWxkQWxpZ24gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2hvdWxkQWxpZ247XG59XG5cbi8vIEZpbmQgdGhlIGZpcnN0IGZyYWcgaW4gdGhlIHByZXZpb3VzIGxldmVsIHdoaWNoIG1hdGNoZXMgdGhlIENDIG9mIHRoZSBmaXJzdCBmcmFnIG9mIHRoZSBuZXcgbGV2ZWxcbmV4cG9ydCBmdW5jdGlvbiBmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWcgKHByZXZEZXRhaWxzLCBjdXJEZXRhaWxzKSB7XG4gIGNvbnN0IHByZXZGcmFncyA9IHByZXZEZXRhaWxzLmZyYWdtZW50cztcbiAgY29uc3QgY3VyRnJhZ3MgPSBjdXJEZXRhaWxzLmZyYWdtZW50cztcblxuICBpZiAoIWN1ckZyYWdzLmxlbmd0aCB8fCAhcHJldkZyYWdzLmxlbmd0aCkge1xuICAgIGxvZ2dlci5sb2coJ05vIGZyYWdtZW50cyB0byBhbGlnbicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHByZXZTdGFydEZyYWcgPSBmaW5kRmlyc3RGcmFnV2l0aENDKHByZXZGcmFncywgY3VyRnJhZ3NbMF0uY2MpO1xuXG4gIGlmICghcHJldlN0YXJ0RnJhZyB8fCAocHJldlN0YXJ0RnJhZyAmJiAhcHJldlN0YXJ0RnJhZy5zdGFydFBUUykpIHtcbiAgICBsb2dnZXIubG9nKCdObyBmcmFnIGluIHByZXZpb3VzIGxldmVsIHRvIGFsaWduIG9uJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIHByZXZTdGFydEZyYWc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGp1c3RQdHMgKHNsaWRpbmcsIGRldGFpbHMpIHtcbiAgZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaCgoZnJhZykgPT4ge1xuICAgIGlmIChmcmFnKSB7XG4gICAgICBsZXQgc3RhcnQgPSBmcmFnLnN0YXJ0ICsgc2xpZGluZztcbiAgICAgIGZyYWcuc3RhcnQgPSBmcmFnLnN0YXJ0UFRTID0gc3RhcnQ7XG4gICAgICBmcmFnLmVuZFBUUyA9IHN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgICB9XG4gIH0pO1xuICBkZXRhaWxzLlBUU0tub3duID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVc2luZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgbGFzdCBsZXZlbCwgdGhpcyBmdW5jdGlvbiBjb21wdXRlcyBQVFMnIG9mIHRoZSBuZXcgZnJhZ21lbnRzIHNvIHRoYXQgdGhleSBmb3JtIGFcbiAqIGNvbnRpZ3VvdXMgc3RyZWFtIHdpdGggdGhlIGxhc3QgZnJhZ21lbnRzLlxuICogVGhlIFBUUyBvZiBhIGZyYWdtZW50IGxldHMgSGxzLmpzIGtub3cgd2hlcmUgaXQgZml0cyBpbnRvIGEgc3RyZWFtIC0gYnkga25vd2luZyBldmVyeSBQVFMsIHdlIGtub3cgd2hpY2ggZnJhZ21lbnQgdG9cbiAqIGRvd25sb2FkIGF0IGFueSBnaXZlbiB0aW1lLiBQVFMgaXMgbm9ybWFsbHkgY29tcHV0ZWQgd2hlbiB0aGUgZnJhZ21lbnQgaXMgZGVtdXhlZCwgc28gdGFraW5nIHRoaXMgc3RlcCBzYXZlcyB1cyB0aW1lXG4gKiBhbmQgYW4gZXh0cmEgZG93bmxvYWQuXG4gKiBAcGFyYW0gbGFzdEZyYWdcbiAqIEBwYXJhbSBsYXN0TGV2ZWxcbiAqIEBwYXJhbSBkZXRhaWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGlnblN0cmVhbSAobGFzdEZyYWcsIGxhc3RMZXZlbCwgZGV0YWlscykge1xuICBhbGlnbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgZGV0YWlscywgbGFzdExldmVsKTtcbiAgaWYgKCFkZXRhaWxzLlBUU0tub3duICYmIGxhc3RMZXZlbCkge1xuICAgIC8vIElmIHRoZSBQVFMgd2Fzbid0IGZpZ3VyZWQgb3V0IHZpYSBkaXNjb250aW51aXR5IHNlcXVlbmNlIHRoYXQgbWVhbnMgdGhlcmUgd2FzIG5vIENDIGluY3JlYXNlIHdpdGhpbiB0aGUgbGV2ZWwuXG4gICAgLy8gQWxpZ25pbmcgdmlhIFByb2dyYW0gRGF0ZSBUaW1lIHNob3VsZCB0aGVyZWZvcmUgYmUgcmVsaWFibGUsIHNpbmNlIFBEVCBzaG91bGQgYmUgdGhlIHNhbWUgd2l0aGluIHRoZSBzYW1lXG4gICAgLy8gZGlzY29udGludWl0eSBzZXF1ZW5jZS5cbiAgICBhbGlnblBEVChkZXRhaWxzLCBsYXN0TGV2ZWwuZGV0YWlscyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUFRTIGlmIGEgbmV3IGxldmVsJ3MgZnJhZ21lbnRzIHVzaW5nIHRoZSBQVFMgb2YgYSBmcmFnbWVudCBpbiB0aGUgbGFzdCBsZXZlbCB3aGljaCBzaGFyZXMgdGhlIHNhbWVcbiAqIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UuXG4gKiBAcGFyYW0gbGFzdExldmVsIC0gVGhlIGRldGFpbHMgb2YgdGhlIGxhc3QgbG9hZGVkIGxldmVsXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBuZXcgbGV2ZWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFsaWduRGlzY29udGludWl0aWVzIChsYXN0RnJhZywgZGV0YWlscywgbGFzdExldmVsKSB7XG4gIGlmIChzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBsYXN0TGV2ZWwsIGRldGFpbHMpKSB7XG4gICAgY29uc3QgcmVmZXJlbmNlRnJhZyA9IGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyhsYXN0TGV2ZWwuZGV0YWlscywgZGV0YWlscyk7XG4gICAgaWYgKHJlZmVyZW5jZUZyYWcpIHtcbiAgICAgIGxvZ2dlci5sb2coJ0FkanVzdGluZyBQVFMgdXNpbmcgbGFzdCBsZXZlbCBkdWUgdG8gQ0MgaW5jcmVhc2Ugd2l0aGluIGN1cnJlbnQgbGV2ZWwnKTtcbiAgICAgIGFkanVzdFB0cyhyZWZlcmVuY2VGcmFnLnN0YXJ0LCBkZXRhaWxzKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUFRTIG9mIGEgbmV3IGxldmVsJ3MgZnJhZ21lbnRzIHVzaW5nIHRoZSBkaWZmZXJlbmNlIGluIFByb2dyYW0gRGF0ZSBUaW1lIGZyb20gdGhlIGxhc3QgbGV2ZWwuXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBuZXcgbGV2ZWxcbiAqIEBwYXJhbSBsYXN0RGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBsYXN0IGxvYWRlZCBsZXZlbFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWxpZ25QRFQgKGRldGFpbHMsIGxhc3REZXRhaWxzKSB7XG4gIGlmIChsYXN0RGV0YWlscyAmJiBsYXN0RGV0YWlscy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgaWYgKCFkZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSB8fCAhbGFzdERldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGlmIGxhc3QgbGV2ZWwgc2xpZGluZyBpcyAxMDAwIGFuZCBpdHMgZmlyc3QgZnJhZyBQUk9HUkFNLURBVEUtVElNRSBpcyAyMDE3LTA4LTIwIDE6MTA6MDAgQU1cbiAgICAvLyBhbmQgaWYgbmV3IGRldGFpbHMgZmlyc3QgZnJhZyBQUk9HUkFNIERBVEUtVElNRSBpcyAyMDE3LTA4LTIwIDE6MTA6MDggQU1cbiAgICAvLyB0aGVuIHdlIGNhbiBkZWR1Y2UgdGhhdCBwbGF5bGlzdCBCIHNsaWRpbmcgaXMgMTAwMCs4ID0gMTAwOHNcbiAgICBsZXQgbGFzdFBEVCA9IGxhc3REZXRhaWxzLmZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7XG4gICAgbGV0IG5ld1BEVCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZTtcbiAgICAvLyBkYXRlIGRpZmYgaXMgaW4gbXMuIGZyYWcuc3RhcnQgaXMgaW4gc2Vjb25kc1xuICAgIGxldCBzbGlkaW5nID0gKG5ld1BEVCAtIGxhc3RQRFQpIC8gMTAwMCArIGxhc3REZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHNsaWRpbmcpKSB7XG4gICAgICBsb2dnZXIubG9nKGBhZGp1c3RpbmcgUFRTIHVzaW5nIHByb2dyYW1EYXRlVGltZSBkZWx0YSwgc2xpZGluZzoke3NsaWRpbmcudG9GaXhlZCgzKX1gKTtcbiAgICAgIGFkanVzdFB0cyhzbGlkaW5nLCBkZXRhaWxzKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBFV01BIEJhbmR3aWR0aCBFc3RpbWF0b3JcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAqIFRyYWNrcyBiYW5kd2lkdGggc2FtcGxlcyBhbmQgZXN0aW1hdGVzIGF2YWlsYWJsZSBiYW5kd2lkdGguXG4gKiBCYXNlZCBvbiB0aGUgbWluaW11bSBvZiB0d28gZXhwb25lbnRpYWxseS13ZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZXMgd2l0aFxuICogZGlmZmVyZW50IGhhbGYtbGl2ZXMuXG4gKi9cblxuaW1wb3J0IEVXTUEgZnJvbSAnLi4vdXRpbHMvZXdtYSc7XG5cbmNsYXNzIEV3bWFCYW5kV2lkdGhFc3RpbWF0b3Ige1xuICBjb25zdHJ1Y3RvciAoaGxzLCBzbG93LCBmYXN0LCBkZWZhdWx0RXN0aW1hdGUpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmRlZmF1bHRFc3RpbWF0ZV8gPSBkZWZhdWx0RXN0aW1hdGU7XG4gICAgdGhpcy5taW5XZWlnaHRfID0gMC4wMDE7XG4gICAgdGhpcy5taW5EZWxheU1zXyA9IDUwO1xuICAgIHRoaXMuc2xvd18gPSBuZXcgRVdNQShzbG93KTtcbiAgICB0aGlzLmZhc3RfID0gbmV3IEVXTUEoZmFzdCk7XG4gIH1cblxuICBzYW1wbGUgKGR1cmF0aW9uTXMsIG51bUJ5dGVzKSB7XG4gICAgZHVyYXRpb25NcyA9IE1hdGgubWF4KGR1cmF0aW9uTXMsIHRoaXMubWluRGVsYXlNc18pO1xuICAgIGxldCBiYW5kd2lkdGggPSA4MDAwICogbnVtQnl0ZXMgLyBkdXJhdGlvbk1zLFxuICAgICAgLy8gY29uc29sZS5sb2coJ2luc3RhbnQgYnc6JysgTWF0aC5yb3VuZChiYW5kd2lkdGgpKTtcbiAgICAgIC8vIHdlIHdlaWdodCBzYW1wbGUgdXNpbmcgbG9hZGluZyBkdXJhdGlvbi4uLi5cbiAgICAgIHdlaWdodCA9IGR1cmF0aW9uTXMgLyAxMDAwO1xuICAgIHRoaXMuZmFzdF8uc2FtcGxlKHdlaWdodCwgYmFuZHdpZHRoKTtcbiAgICB0aGlzLnNsb3dfLnNhbXBsZSh3ZWlnaHQsIGJhbmR3aWR0aCk7XG4gIH1cblxuICBjYW5Fc3RpbWF0ZSAoKSB7XG4gICAgbGV0IGZhc3QgPSB0aGlzLmZhc3RfO1xuICAgIHJldHVybiAoZmFzdCAmJiBmYXN0LmdldFRvdGFsV2VpZ2h0KCkgPj0gdGhpcy5taW5XZWlnaHRfKTtcbiAgfVxuXG4gIGdldEVzdGltYXRlICgpIHtcbiAgICBpZiAodGhpcy5jYW5Fc3RpbWF0ZSgpKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnc2xvdyBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ2Zhc3QgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLmZhc3RfLmdldEVzdGltYXRlKCkpKTtcbiAgICAgIC8vIFRha2UgdGhlIG1pbmltdW0gb2YgdGhlc2UgdHdvIGVzdGltYXRlcy4gIFRoaXMgc2hvdWxkIGhhdmUgdGhlIGVmZmVjdCBvZlxuICAgICAgLy8gYWRhcHRpbmcgZG93biBxdWlja2x5LCBidXQgdXAgbW9yZSBzbG93bHkuXG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpLCB0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXN0aW1hdGVfO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBFd21hQmFuZFdpZHRoRXN0aW1hdG9yO1xuIiwiLypcbiAqIGNvbXB1dGUgYW4gRXhwb25lbnRpYWwgV2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VcbiAqIC0gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW92aW5nX2F2ZXJhZ2UjRXhwb25lbnRpYWxfbW92aW5nX2F2ZXJhZ2VcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAqL1xuXG5jbGFzcyBFV01BIHtcbiAgLy8gIEFib3V0IGhhbGYgb2YgdGhlIGVzdGltYXRlZCB2YWx1ZSB3aWxsIGJlIGZyb20gdGhlIGxhc3QgfGhhbGZMaWZlfCBzYW1wbGVzIGJ5IHdlaWdodC5cbiAgY29uc3RydWN0b3IgKGhhbGZMaWZlKSB7XG4gICAgLy8gTGFyZ2VyIHZhbHVlcyBvZiBhbHBoYSBleHBpcmUgaGlzdG9yaWNhbCBkYXRhIG1vcmUgc2xvd2x5LlxuICAgIHRoaXMuYWxwaGFfID0gaGFsZkxpZmUgPyBNYXRoLmV4cChNYXRoLmxvZygwLjUpIC8gaGFsZkxpZmUpIDogMDtcbiAgICB0aGlzLmVzdGltYXRlXyA9IDA7XG4gICAgdGhpcy50b3RhbFdlaWdodF8gPSAwO1xuICB9XG5cbiAgc2FtcGxlICh3ZWlnaHQsIHZhbHVlKSB7XG4gICAgbGV0IGFkakFscGhhID0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHdlaWdodCk7XG4gICAgdGhpcy5lc3RpbWF0ZV8gPSB2YWx1ZSAqICgxIC0gYWRqQWxwaGEpICsgYWRqQWxwaGEgKiB0aGlzLmVzdGltYXRlXztcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyArPSB3ZWlnaHQ7XG4gIH1cblxuICBnZXRUb3RhbFdlaWdodCAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG90YWxXZWlnaHRfO1xuICB9XG5cbiAgZ2V0RXN0aW1hdGUgKCkge1xuICAgIGlmICh0aGlzLmFscGhhXykge1xuICAgICAgbGV0IHplcm9GYWN0b3IgPSAxIC0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHRoaXMudG90YWxXZWlnaHRfKTtcbiAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlXyAvIHplcm9GYWN0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlXztcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRVdNQTtcbiIsImV4cG9ydCBmdW5jdGlvbiBnZXRTZWxmU2NvcGUgKCkge1xuICAvLyBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExMjM3MjU5LzU4OTQ5M1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWYgKi9cbiAgICByZXR1cm4gc2VsZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG59XG4iLCJpbXBvcnQgeyBnZXRTZWxmU2NvcGUgfSBmcm9tICcuL2dldC1zZWxmLXNjb3BlJztcblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5jb25zdCBmYWtlTG9nZ2VyID0ge1xuICB0cmFjZTogbm9vcCxcbiAgZGVidWc6IG5vb3AsXG4gIGxvZzogbm9vcCxcbiAgd2Fybjogbm9vcCxcbiAgaW5mbzogbm9vcCxcbiAgZXJyb3I6IG5vb3Bcbn07XG5cbmxldCBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG5cbi8vIGxldCBsYXN0Q2FsbFRpbWU7XG4vLyBmdW5jdGlvbiBmb3JtYXRNc2dXaXRoVGltZUluZm8odHlwZSwgbXNnKSB7XG4vLyAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4vLyAgIGNvbnN0IGRpZmYgPSBsYXN0Q2FsbFRpbWUgPyAnKycgKyAobm93IC0gbGFzdENhbGxUaW1lKSA6ICcwJztcbi8vICAgbGFzdENhbGxUaW1lID0gbm93O1xuLy8gICBtc2cgPSAobmV3IERhdGUobm93KSkudG9JU09TdHJpbmcoKSArICcgfCBbJyArICB0eXBlICsgJ10gPiAnICsgbXNnICsgJyAoICcgKyBkaWZmICsgJyBtcyApJztcbi8vICAgcmV0dXJuIG1zZztcbi8vIH1cblxuZnVuY3Rpb24gZm9ybWF0TXNnICh0eXBlLCBtc2cpIHtcbiAgbXNnID0gJ1snICsgdHlwZSArICddID4gJyArIG1zZztcbiAgcmV0dXJuIG1zZztcbn1cblxuY29uc3QgZ2xvYmFsID0gZ2V0U2VsZlNjb3BlKCk7XG5cbmZ1bmN0aW9uIGNvbnNvbGVQcmludEZuICh0eXBlKSB7XG4gIGNvbnN0IGZ1bmMgPSBnbG9iYWwuY29uc29sZVt0eXBlXTtcbiAgaWYgKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgIGlmIChhcmdzWzBdKSB7XG4gICAgICAgIGFyZ3NbMF0gPSBmb3JtYXRNc2codHlwZSwgYXJnc1swXSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmMuYXBwbHkoZ2xvYmFsLmNvbnNvbGUsIGFyZ3MpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIG5vb3A7XG59XG5cbmZ1bmN0aW9uIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyAoZGVidWdDb25maWcsIC4uLmZ1bmN0aW9ucykge1xuICBmdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGV4cG9ydGVkTG9nZ2VyW3R5cGVdID0gZGVidWdDb25maWdbdHlwZV0gPyBkZWJ1Z0NvbmZpZ1t0eXBlXS5iaW5kKGRlYnVnQ29uZmlnKSA6IGNvbnNvbGVQcmludEZuKHR5cGUpO1xuICB9KTtcbn1cblxuZXhwb3J0IHZhciBlbmFibGVMb2dzID0gZnVuY3Rpb24gKGRlYnVnQ29uZmlnKSB7XG4gIGlmIChkZWJ1Z0NvbmZpZyA9PT0gdHJ1ZSB8fCB0eXBlb2YgZGVidWdDb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgZXhwb3J0TG9nZ2VyRnVuY3Rpb25zKGRlYnVnQ29uZmlnLFxuICAgICAgLy8gUmVtb3ZlIG91dCBmcm9tIGxpc3QgaGVyZSB0byBoYXJkLWRpc2FibGUgYSBsb2ctbGV2ZWxcbiAgICAgIC8vICd0cmFjZScsXG4gICAgICAnZGVidWcnLFxuICAgICAgJ2xvZycsXG4gICAgICAnaW5mbycsXG4gICAgICAnd2FybicsXG4gICAgICAnZXJyb3InXG4gICAgKTtcbiAgICAvLyBTb21lIGJyb3dzZXJzIGRvbid0IGFsbG93IHRvIHVzZSBiaW5kIG9uIGNvbnNvbGUgb2JqZWN0IGFueXdheVxuICAgIC8vIGZhbGxiYWNrIHRvIGRlZmF1bHQgaWYgbmVlZGVkXG4gICAgdHJ5IHtcbiAgICAgIGV4cG9ydGVkTG9nZ2VyLmxvZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIGxvZ2dlciA9IGV4cG9ydGVkTG9nZ2VyO1xuIiwiY29uc3QgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MuYmluZCh3aW5kb3cubmF2aWdhdG9yKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufSkoKTtcblxuZXhwb3J0IHtcbiAgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzXG59O1xuIiwiLyoqXG4gKiBNZWRpYVNvdXJjZSBoZWxwZXJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVkaWFTb3VyY2UgKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gd2luZG93Lk1lZGlhU291cmNlIHx8IHdpbmRvdy5XZWJLaXRNZWRpYVNvdXJjZTtcbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3V0cHV0RmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKHRpbWVsaW5lQ29udHJvbGxlciwgdHJhY2tOYW1lKSB7XG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSB0aW1lbGluZUNvbnRyb2xsZXI7XG4gICAgdGhpcy50cmFja05hbWUgPSB0cmFja05hbWU7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgIHRoaXMuZW5kVGltZSA9IG51bGw7XG4gICAgdGhpcy5zY3JlZW4gPSBudWxsO1xuICB9XG5cbiAgZGlzcGF0Y2hDdWUgKCkge1xuICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyLmFkZEN1ZXModGhpcy50cmFja05hbWUsIHRoaXMuc3RhcnRUaW1lLCB0aGlzLmVuZFRpbWUsIHRoaXMuc2NyZWVuKTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gIH1cblxuICBuZXdDdWUgKHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRUaW1lID09PSBudWxsIHx8IHRoaXMuc3RhcnRUaW1lID4gc3RhcnRUaW1lKSB7XG4gICAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICB9XG5cbiAgICB0aGlzLmVuZFRpbWUgPSBlbmRUaW1lO1xuICAgIHRoaXMuc2NyZWVuID0gc2NyZWVuO1xuICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyLmNyZWF0ZUNhcHRpb25zVHJhY2sodGhpcy50cmFja05hbWUpO1xuICB9XG59XG4iLCJcbmV4cG9ydCBmdW5jdGlvbiBzZW5kQWRkVHJhY2tFdmVudCAodHJhY2ssIHZpZGVvRWwpIHtcbiAgbGV0IGV2ZW50ID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBldmVudCA9IG5ldyB3aW5kb3cuRXZlbnQoJ2FkZHRyYWNrJyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIGZvciBJRTExXG4gICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoJ2FkZHRyYWNrJywgZmFsc2UsIGZhbHNlKTtcbiAgfVxuICBldmVudC50cmFjayA9IHRyYWNrO1xuICB2aWRlb0VsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDdXJyZW50Q3VlcyAodHJhY2spIHtcbiAgaWYgKHRyYWNrICYmIHRyYWNrLmN1ZXMpIHtcbiAgICB3aGlsZSAodHJhY2suY3Vlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0cmFjay5yZW1vdmVDdWUodHJhY2suY3Vlc1swXSk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqICBUaW1lUmFuZ2VzIHRvIHN0cmluZyBoZWxwZXJcbiAqL1xuXG5jb25zdCBUaW1lUmFuZ2VzID0ge1xuICB0b1N0cmluZzogZnVuY3Rpb24gKHIpIHtcbiAgICBsZXQgbG9nID0gJycsIGxlbiA9IHIubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxvZyArPSAnWycgKyByLnN0YXJ0KGkpLnRvRml4ZWQoMykgKyAnLCcgKyByLmVuZChpKS50b0ZpeGVkKDMpICsgJ10nO1xuICAgIH1cblxuICAgIHJldHVybiBsb2c7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVSYW5nZXM7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVlRUQ3VlKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5WVFRDdWU7XG4gIH1cblxuICBsZXQgYXV0b0tleXdvcmQgPSAnYXV0byc7XG4gIGxldCBkaXJlY3Rpb25TZXR0aW5nID0ge1xuICAgICcnOiB0cnVlLFxuICAgIGxyOiB0cnVlLFxuICAgIHJsOiB0cnVlXG4gIH07XG4gIGxldCBhbGlnblNldHRpbmcgPSB7XG4gICAgc3RhcnQ6IHRydWUsXG4gICAgbWlkZGxlOiB0cnVlLFxuICAgIGVuZDogdHJ1ZSxcbiAgICBsZWZ0OiB0cnVlLFxuICAgIHJpZ2h0OiB0cnVlXG4gIH07XG5cbiAgZnVuY3Rpb24gZmluZERpcmVjdGlvblNldHRpbmcgKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgZGlyID0gZGlyZWN0aW9uU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcbiAgICByZXR1cm4gZGlyID8gdmFsdWUudG9Mb3dlckNhc2UoKSA6IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEFsaWduU2V0dGluZyAodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBhbGlnbiA9IGFsaWduU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcbiAgICByZXR1cm4gYWxpZ24gPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQgKG9iaikge1xuICAgIGxldCBpID0gMTtcbiAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGNvYmogPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKGxldCBwIGluIGNvYmopIHtcbiAgICAgICAgb2JqW3BdID0gY29ialtwXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gVlRUQ3VlIChzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQpIHtcbiAgICBsZXQgY3VlID0gdGhpcztcbiAgICBsZXQgaXNJRTggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgvTVNJRVxcczhcXC4wLykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9KSgpO1xuICAgIGxldCBiYXNlT2JqID0ge307XG5cbiAgICBpZiAoaXNJRTgpIHtcbiAgICAgIGN1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlT2JqLmVudW1lcmFibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNoaW0gaW1wbGVtZW50YXRpb24gc3BlY2lmaWMgcHJvcGVydGllcy4gVGhlc2UgcHJvcGVydGllcyBhcmUgbm90IGluXG4gICAgICogdGhlIHNwZWMuXG4gICAgICovXG5cbiAgICAvLyBMZXRzIHVzIGtub3cgd2hlbiB0aGUgVlRUQ3VlJ3MgZGF0YSBoYXMgY2hhbmdlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgbmVlZFxuICAgIC8vIHRvIHJlY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZS4gVGhpcyBsZXRzIHVzIGNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGVcbiAgICAvLyBsYXppbHkuXG4gICAgY3VlLmhhc0JlZW5SZXNldCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVlRUQ3VlIGFuZCBUZXh0VHJhY2tDdWUgcHJvcGVydGllc1xuICAgICAqIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0Y3VlLWludGVyZmFjZVxuICAgICAqL1xuXG4gICAgbGV0IF9pZCA9ICcnO1xuICAgIGxldCBfcGF1c2VPbkV4aXQgPSBmYWxzZTtcbiAgICBsZXQgX3N0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICBsZXQgX2VuZFRpbWUgPSBlbmRUaW1lO1xuICAgIGxldCBfdGV4dCA9IHRleHQ7XG4gICAgbGV0IF9yZWdpb24gPSBudWxsO1xuICAgIGxldCBfdmVydGljYWwgPSAnJztcbiAgICBsZXQgX3NuYXBUb0xpbmVzID0gdHJ1ZTtcbiAgICBsZXQgX2xpbmUgPSAnYXV0byc7XG4gICAgbGV0IF9saW5lQWxpZ24gPSAnc3RhcnQnO1xuICAgIGxldCBfcG9zaXRpb24gPSA1MDtcbiAgICBsZXQgX3Bvc2l0aW9uQWxpZ24gPSAnbWlkZGxlJztcbiAgICBsZXQgX3NpemUgPSA1MDtcbiAgICBsZXQgX2FsaWduID0gJ21pZGRsZSc7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnaWQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2lkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF9pZCA9ICcnICsgdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3BhdXNlT25FeGl0JywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9wYXVzZU9uRXhpdDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfcGF1c2VPbkV4aXQgPSAhIXZhbHVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzdGFydFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3N0YXJ0VGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0YXJ0IHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfc3RhcnRUaW1lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnZW5kVGltZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZW5kVGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuZCB0aW1lIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2VuZFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICd0ZXh0JywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90ZXh0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF90ZXh0ID0gJycgKyB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdyZWdpb24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2lvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfcmVnaW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndmVydGljYWwnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3ZlcnRpY2FsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGxldCBzZXR0aW5nID0gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpO1xuICAgICAgICAvLyBIYXZlIHRvIGNoZWNrIGZvciBmYWxzZSBiZWNhdXNlIHRoZSBzZXR0aW5nIGFuIGJlIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgaWYgKHNldHRpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfdmVydGljYWwgPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NuYXBUb0xpbmVzJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwVG9MaW5lcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfc25hcFRvTGluZXMgPSAhIXZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2xpbmUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2xpbmU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgJiYgdmFsdWUgIT09IGF1dG9LZXl3b3JkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG51bWJlciBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2xpbmUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdsaW5lQWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2xpbmVBbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBsZXQgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9saW5lQWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NpdGlvbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3Bvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncG9zaXRpb25BbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfcG9zaXRpb25BbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBsZXQgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wb3NpdGlvbkFsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzaXplJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpemUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zaXplID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnYWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2FsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGxldCBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2FsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIE90aGVyIDx0cmFjaz4gc3BlYyBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICAgKi9cblxuICAgIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS12aWRlby1lbGVtZW50Lmh0bWwjdGV4dC10cmFjay1jdWUtZGlzcGxheS1zdGF0ZVxuICAgIGN1ZS5kaXNwbGF5U3RhdGUgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNJRTgpIHtcbiAgICAgIHJldHVybiBjdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZUVEN1ZSBtZXRob2RzXG4gICAqL1xuXG4gIFZUVEN1ZS5wcm90b3R5cGUuZ2V0Q3VlQXNIVE1MID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEFzc3VtZSBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSBpcyBvbiB0aGUgZ2xvYmFsLlxuICAgIGxldCBXZWJWVFQgPSB3aW5kb3cuV2ViVlRUO1xuICAgIHJldHVybiBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSh3aW5kb3csIHRoaXMudGV4dCk7XG4gIH07XG5cbiAgcmV0dXJuIFZUVEN1ZTtcbn0pKCk7XG4iLCIvKlxuICogU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS92dHQuanMvYmxvYi9tYXN0ZXIvZGlzdC92dHQuanMjTDE3MTZcbiAqL1xuXG5pbXBvcnQgVlRUQ3VlIGZyb20gJy4vdnR0Y3VlJztcblxuY29uc3QgU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uIFN0cmluZ0RlY29kZXIgKCkge1xuICByZXR1cm4ge1xuICAgIGRlY29kZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIGV4cGVjdGVkIHN0cmluZyBkYXRhLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZVVSSUNvbXBvbmVudChkYXRhKSk7XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gVlRUUGFyc2VyICgpIHtcbiAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gIHRoaXMuc3RhdGUgPSAnSU5JVElBTCc7XG4gIHRoaXMuYnVmZmVyID0gJyc7XG4gIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCk7XG4gIHRoaXMucmVnaW9uTGlzdCA9IFtdO1xufVxuXG4vLyBUcnkgdG8gcGFyc2UgaW5wdXQgYXMgYSB0aW1lIHN0YW1wLlxuZnVuY3Rpb24gcGFyc2VUaW1lU3RhbXAgKGlucHV0KSB7XG4gIGZ1bmN0aW9uIGNvbXB1dGVTZWNvbmRzIChoLCBtLCBzLCBmKSB7XG4gICAgcmV0dXJuIChoIHwgMCkgKiAzNjAwICsgKG0gfCAwKSAqIDYwICsgKHMgfCAwKSArIChmIHwgMCkgLyAxMDAwO1xuICB9XG5cbiAgbGV0IG0gPSBpbnB1dC5tYXRjaCgvXihcXGQrKTooXFxkezJ9KSg6XFxkezJ9KT9cXC4oXFxkezN9KS8pO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChtWzNdKSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCBtWzNdLnJlcGxhY2UoJzonLCAnJyksIG1bNF0pO1xuICB9IGVsc2UgaWYgKG1bMV0gPiA1OSkge1xuICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnNdOlttaW51dGVzXS5bbWlsbGlzZWNvbmRzXVxuICAgIC8vIEZpcnN0IHBvc2l0aW9uIGlzIGhvdXJzIGFzIGl0J3Mgb3ZlciA1OS5cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsxXSwgbVsyXSwgMCwgbVs0XSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMoMCwgbVsxXSwgbVsyXSwgbVs0XSk7XG4gIH1cbn1cblxuLy8gQSBzZXR0aW5ncyBvYmplY3QgaG9sZHMga2V5L3ZhbHVlIHBhaXJzIGFuZCB3aWxsIGlnbm9yZSBhbnl0aGluZyBidXQgdGhlIGZpcnN0XG4vLyBhc3NpZ25tZW50IHRvIGEgc3BlY2lmaWMga2V5LlxuZnVuY3Rpb24gU2V0dGluZ3MgKCkge1xuICB0aGlzLnZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cblNldHRpbmdzLnByb3RvdHlwZSA9IHtcbiAgLy8gT25seSBhY2NlcHQgdGhlIGZpcnN0IGFzc2lnbm1lbnQgdG8gYW55IGtleS5cbiAgc2V0OiBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICghdGhpcy5nZXQoaykgJiYgdiAhPT0gJycpIHtcbiAgICAgIHRoaXMudmFsdWVzW2tdID0gdjtcbiAgICB9XG4gIH0sXG4gIC8vIFJldHVybiB0aGUgdmFsdWUgZm9yIGEga2V5LCBvciBhIGRlZmF1bHQgdmFsdWUuXG4gIC8vIElmICdkZWZhdWx0S2V5JyBpcyBwYXNzZWQgdGhlbiAnZGZsdCcgaXMgYXNzdW1lZCB0byBiZSBhbiBvYmplY3Qgd2l0aFxuICAvLyBhIG51bWJlciBvZiBwb3NzaWJsZSBkZWZhdWx0IHZhbHVlcyBhcyBwcm9wZXJ0aWVzIHdoZXJlICdkZWZhdWx0S2V5JyBpc1xuICAvLyB0aGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgY2hvc2VuOyBvdGhlcndpc2UgaXQncyBhc3N1bWVkIHRvIGJlXG4gIC8vIGEgc2luZ2xlIHZhbHVlLlxuICBnZXQ6IGZ1bmN0aW9uIChrLCBkZmx0LCBkZWZhdWx0S2V5KSB7XG4gICAgaWYgKGRlZmF1bHRLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdFtkZWZhdWx0S2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHQ7XG4gIH0sXG4gIC8vIENoZWNrIHdoZXRoZXIgd2UgaGF2ZSBhIHZhbHVlIGZvciBhIGtleS5cbiAgaGFzOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrIGluIHRoaXMudmFsdWVzO1xuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cbiAgYWx0OiBmdW5jdGlvbiAoaywgdiwgYSkge1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgYS5sZW5ndGg7ICsrbikge1xuICAgICAgaWYgKHYgPT09IGFbbl0pIHtcbiAgICAgICAgdGhpcy5zZXQoaywgdik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCAoc2lnbmVkKSBpbnRlZ2VyLlxuICBpbnRlZ2VyOiBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICgvXi0/XFxkKyQvLnRlc3QodikpIHsgLy8gaW50ZWdlclxuICAgICAgdGhpcy5zZXQoaywgcGFyc2VJbnQodiwgMTApKTtcbiAgICB9XG4gIH0sXG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIGEgdmFsaWQgcGVyY2VudGFnZS5cbiAgcGVyY2VudDogZnVuY3Rpb24gKGssIHYpIHtcbiAgICBsZXQgbTtcbiAgICBpZiAoKG0gPSB2Lm1hdGNoKC9eKFtcXGRdezEsM30pKFxcLltcXGRdKik/JSQvKSkpIHtcbiAgICAgIHYgPSBwYXJzZUZsb2F0KHYpO1xuICAgICAgaWYgKHYgPj0gMCAmJiB2IDw9IDEwMCkge1xuICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGlucHV0IGludG8gZ3JvdXBzIHNlcGFyYXRlZCBieSAnZ3JvdXBEZWxpbScsIGFuZFxuLy8gaW50ZXJwcmV0ZSBlYWNoIGdyb3VwIGFzIGEga2V5L3ZhbHVlIHBhaXIgc2VwYXJhdGVkIGJ5ICdrZXlWYWx1ZURlbGltJy5cbmZ1bmN0aW9uIHBhcnNlT3B0aW9ucyAoaW5wdXQsIGNhbGxiYWNrLCBrZXlWYWx1ZURlbGltLCBncm91cERlbGltKSB7XG4gIGxldCBncm91cHMgPSBncm91cERlbGltID8gaW5wdXQuc3BsaXQoZ3JvdXBEZWxpbSkgOiBbaW5wdXRdO1xuICBmb3IgKGxldCBpIGluIGdyb3Vwcykge1xuICAgIGlmICh0eXBlb2YgZ3JvdXBzW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbGV0IGt2ID0gZ3JvdXBzW2ldLnNwbGl0KGtleVZhbHVlRGVsaW0pO1xuICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCBrID0ga3ZbMF07XG4gICAgbGV0IHYgPSBrdlsxXTtcbiAgICBjYWxsYmFjayhrLCB2KTtcbiAgfVxufVxuXG5sZXQgZGVmYXVsdHMgPSBuZXcgVlRUQ3VlKDAsIDAsIDApO1xuLy8gJ21pZGRsZScgd2FzIGNoYW5nZWQgdG8gJ2NlbnRlcicgaW4gdGhlIHNwZWM6IGh0dHBzOi8vZ2l0aHViLmNvbS93M2Mvd2VidnR0L3B1bGwvMjQ0XG4vLyAgU2FmYXJpIGRvZXNuJ3QgeWV0IHN1cHBvcnQgdGhpcyBjaGFuZ2UsIGJ1dCBGRiBhbmQgQ2hyb21lIGRvLlxubGV0IGNlbnRlciA9IGRlZmF1bHRzLmFsaWduID09PSAnbWlkZGxlJyA/ICdtaWRkbGUnIDogJ2NlbnRlcic7XG5cbmZ1bmN0aW9uIHBhcnNlQ3VlIChpbnB1dCwgY3VlLCByZWdpb25MaXN0KSB7XG4gIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCBpbnB1dCBpZiB3ZSBuZWVkIHRvIHRocm93IGFuIGVycm9yLlxuICBsZXQgb0lucHV0ID0gaW5wdXQ7XG4gIC8vIDQuMSBXZWJWVFQgdGltZXN0YW1wXG4gIGZ1bmN0aW9uIGNvbnN1bWVUaW1lU3RhbXAgKCkge1xuICAgIGxldCB0cyA9IHBhcnNlVGltZVN0YW1wKGlucHV0KTtcbiAgICBpZiAodHMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIHRpbWVzdGFtcDogJyArIG9JbnB1dCk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHRpbWUgc3RhbXAgZnJvbSBpbnB1dC5cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15bXlxcc2EtekEtWi1dKy8sICcnKTtcbiAgICByZXR1cm4gdHM7XG4gIH1cblxuICAvLyA0LjQuMiBXZWJWVFQgY3VlIHNldHRpbmdzXG4gIGZ1bmN0aW9uIGNvbnN1bWVDdWVTZXR0aW5ncyAoaW5wdXQsIGN1ZSkge1xuICAgIGxldCBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xuXG4gICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgc3dpdGNoIChrKSB7XG4gICAgICBjYXNlICdyZWdpb24nOlxuICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IHJlZ2lvbiB3ZSBwYXJzZWQgd2l0aCB0aGUgc2FtZSByZWdpb24gaWQuXG4gICAgICAgIGZvciAobGV0IGkgPSByZWdpb25MaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKHJlZ2lvbkxpc3RbaV0uaWQgPT09IHYpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNldChrLCByZWdpb25MaXN0W2ldLnJlZ2lvbik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3JsJywgJ2xyJ10pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgICB2YXIgdmFscyA9IHYuc3BsaXQoJywnKSxcbiAgICAgICAgICB2YWxzMCA9IHZhbHNbMF07XG4gICAgICAgIHNldHRpbmdzLmludGVnZXIoaywgdmFsczApO1xuICAgICAgICBpZiAoc2V0dGluZ3MucGVyY2VudChrLCB2YWxzMCkpIHtcbiAgICAgICAgICBzZXR0aW5ncy5zZXQoJ3NuYXBUb0xpbmVzJywgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGluZ3MuYWx0KGssIHZhbHMwLCBbJ2F1dG8nXSk7XG4gICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHNldHRpbmdzLmFsdCgnbGluZUFsaWduJywgdmFsc1sxXSwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICB2YWxzID0gdi5zcGxpdCgnLCcpO1xuICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHZhbHNbMF0pO1xuICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoJ3Bvc2l0aW9uQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJywgJ2xpbmUtbGVmdCcsICdsaW5lLXJpZ2h0JywgJ2F1dG8nXSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NpemUnOlxuICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHYpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2FsaWduJzpcbiAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnLCAnbGVmdCcsICdyaWdodCddKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSwgLzovLCAvXFxzLyk7XG5cbiAgICAvLyBBcHBseSBkZWZhdWx0IHZhbHVlcyBmb3IgYW55IG1pc3NpbmcgZmllbGRzLlxuICAgIGN1ZS5yZWdpb24gPSBzZXR0aW5ncy5nZXQoJ3JlZ2lvbicsIG51bGwpO1xuICAgIGN1ZS52ZXJ0aWNhbCA9IHNldHRpbmdzLmdldCgndmVydGljYWwnLCAnJyk7XG4gICAgbGV0IGxpbmUgPSBzZXR0aW5ncy5nZXQoJ2xpbmUnLCAnYXV0bycpO1xuICAgIGlmIChsaW5lID09PSAnYXV0bycgJiYgZGVmYXVsdHMubGluZSA9PT0gLTEpIHtcbiAgICAgIC8vIHNldCBudW1lcmljIGxpbmUgbnVtYmVyIGZvciBTYWZhcmlcbiAgICAgIGxpbmUgPSAtMTtcbiAgICB9XG4gICAgY3VlLmxpbmUgPSBsaW5lO1xuICAgIGN1ZS5saW5lQWxpZ24gPSBzZXR0aW5ncy5nZXQoJ2xpbmVBbGlnbicsICdzdGFydCcpO1xuICAgIGN1ZS5zbmFwVG9MaW5lcyA9IHNldHRpbmdzLmdldCgnc25hcFRvTGluZXMnLCB0cnVlKTtcbiAgICBjdWUuc2l6ZSA9IHNldHRpbmdzLmdldCgnc2l6ZScsIDEwMCk7XG4gICAgY3VlLmFsaWduID0gc2V0dGluZ3MuZ2V0KCdhbGlnbicsIGNlbnRlcik7XG4gICAgbGV0IHBvc2l0aW9uID0gc2V0dGluZ3MuZ2V0KCdwb3NpdGlvbicsICdhdXRvJyk7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgZGVmYXVsdHMucG9zaXRpb24gPT09IDUwKSB7XG4gICAgICAvLyBzZXQgbnVtZXJpYyBwb3NpdGlvbiBmb3IgU2FmYXJpXG4gICAgICBwb3NpdGlvbiA9IGN1ZS5hbGlnbiA9PT0gJ3N0YXJ0JyB8fCBjdWUuYWxpZ24gPT09ICdsZWZ0JyA/IDAgOiBjdWUuYWxpZ24gPT09ICdlbmQnIHx8IGN1ZS5hbGlnbiA9PT0gJ3JpZ2h0JyA/IDEwMCA6IDUwO1xuICAgIH1cbiAgICBjdWUucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlICgpIHtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15cXHMrLywgJycpO1xuICB9XG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgdGltaW5ncy5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY3VlLnN0YXJ0VGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDEpIGNvbGxlY3QgY3VlIHN0YXJ0IHRpbWVcbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgaWYgKGlucHV0LnN1YnN0cigwLCAzKSAhPT0gJy0tPicpIHsgLy8gKDMpIG5leHQgY2hhcmFjdGVycyBtdXN0IG1hdGNoICctLT4nXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgdGltZSBzdGFtcCAodGltZSBzdGFtcHMgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgXFwnLS0+XFwnKTogJyArXG4gICAgICBvSW5wdXQpO1xuICB9XG4gIGlucHV0ID0gaW5wdXQuc3Vic3RyKDMpO1xuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuZW5kVGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDUpIGNvbGxlY3QgY3VlIGVuZCB0aW1lXG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgc2V0dGluZ3MgbGlzdC5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpO1xufVxuXG5mdW5jdGlvbiBmaXhMaW5lQnJlYWtzIChpbnB1dCkge1xuICByZXR1cm4gaW5wdXQucmVwbGFjZSgvPGJyKD86IFxcLyk/Pi9naSwgJ1xcbicpO1xufVxuXG5WVFRQYXJzZXIucHJvdG90eXBlID0ge1xuICBwYXJzZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBkYXRhIHRoZW4gd2Ugd29uJ3QgZGVjb2RlIGl0LCBidXQgd2lsbCBqdXN0IHRyeSB0byBwYXJzZVxuICAgIC8vIHdoYXRldmVyIGlzIGluIGJ1ZmZlciBhbHJlYWR5LiBUaGlzIG1heSBvY2N1ciBpbiBjaXJjdW1zdGFuY2VzLCBmb3JcbiAgICAvLyBleGFtcGxlIHdoZW4gZmx1c2goKSBpcyBjYWxsZWQuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIGRhdGEgdGhhdCB3ZSByZWNlaXZlZC5cbiAgICAgIHNlbGYuYnVmZmVyICs9IHNlbGYuZGVjb2Rlci5kZWNvZGUoZGF0YSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdE5leHRMaW5lICgpIHtcbiAgICAgIGxldCBidWZmZXIgPSBzZWxmLmJ1ZmZlcjtcbiAgICAgIGxldCBwb3MgPSAwO1xuXG4gICAgICBidWZmZXIgPSBmaXhMaW5lQnJlYWtzKGJ1ZmZlcik7XG5cbiAgICAgIHdoaWxlIChwb3MgPCBidWZmZXIubGVuZ3RoICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxyJyAmJiBidWZmZXJbcG9zXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG5cbiAgICAgIGxldCBsaW5lID0gYnVmZmVyLnN1YnN0cigwLCBwb3MpO1xuICAgICAgLy8gQWR2YW5jZSB0aGUgYnVmZmVyIGVhcmx5IGluIGNhc2Ugd2UgZmFpbCBiZWxvdy5cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xccicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG5cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuYnVmZmVyID0gYnVmZmVyLnN1YnN0cihwb3MpO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuXG4gICAgLy8gMy4yIFdlYlZUVCBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgZnVuY3Rpb24gcGFyc2VIZWFkZXIgKGlucHV0KSB7XG4gICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICBjYXNlICdSZWdpb24nOlxuICAgICAgICAgIC8vIDMuMyBXZWJWVFQgcmVnaW9uIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygncGFyc2UgcmVnaW9uJywgdik7XG4gICAgICAgICAgLy8gcGFyc2VSZWdpb24odik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0sIC86Lyk7XG4gICAgfVxuXG4gICAgLy8gNS4xIFdlYlZUVCBmaWxlIHBhcnNpbmcuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBsaW5lO1xuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdJTklUSUFMJykge1xuICAgICAgICAvLyBXZSBjYW4ndCBzdGFydCBwYXJzaW5nIHVudGlsIHdlIGhhdmUgdGhlIGZpcnN0IGxpbmUuXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3Qoc2VsZi5idWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG4gICAgICAgIC8vIHN0cmlwIG9mIFVURi04IEJPTSBpZiBhbnlcbiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnl0ZV9vcmRlcl9tYXJrI1VURi04XG4gICAgICAgIGxldCBtID0gbGluZS5tYXRjaCgvXijDr8K7wr8pP1dFQlZUVChbIFxcdF0uKik/JC8pO1xuICAgICAgICBpZiAoIW0gfHwgIW1bMF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zdGF0ZSA9ICdIRUFERVInO1xuICAgICAgfVxuXG4gICAgICBsZXQgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChzZWxmLmJ1ZmZlcikge1xuICAgICAgICAvLyBXZSBjYW4ndCBwYXJzZSBhIGxpbmUgdW50aWwgd2UgaGF2ZSB0aGUgZnVsbCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KHNlbGYuYnVmZmVyKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhbHJlYWR5Q29sbGVjdGVkTGluZSkge1xuICAgICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChzZWxmLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgJ0hFQURFUic6XG4gICAgICAgICAgLy8gMTMtMTggLSBBbGxvdyBhIGhlYWRlciAobWV0YWRhdGEpIHVuZGVyIHRoZSBXRUJWVFQgbGluZS5cbiAgICAgICAgICBpZiAoLzovLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIHBhcnNlSGVhZGVyKGxpbmUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgIC8vIEFuIGVtcHR5IGxpbmUgdGVybWluYXRlcyB0aGUgaGVhZGVyIGFuZCBzdGFydHMgdGhlIGJvZHkgKGN1ZXMpLlxuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlICdOT1RFJzpcbiAgICAgICAgICAvLyBJZ25vcmUgTk9URSBibG9ja3MuXG4gICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSAnSUQnOlxuICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RhcnQgb2YgTk9URSBibG9ja3MuXG4gICAgICAgICAgaWYgKC9eTk9URSgkfFsgXFx0XSkvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnTk9URSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gMTktMjkgLSBBbGxvdyBhbnkgbnVtYmVyIG9mIGxpbmUgdGVybWluYXRvcnMsIHRoZW4gaW5pdGlhbGl6ZSBuZXcgY3VlIHZhbHVlcy5cbiAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuY3VlID0gbmV3IFZUVEN1ZSgwLCAwLCAnJyk7XG4gICAgICAgICAgc2VsZi5zdGF0ZSA9ICdDVUUnO1xuICAgICAgICAgIC8vIDMwLTM5IC0gQ2hlY2sgaWYgc2VsZiBsaW5lIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGlkZW50aWZpZXIgb3IgdGltaW5nIGRhdGEuXG4gICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignLS0+JykgPT09IC0xKSB7XG4gICAgICAgICAgICBzZWxmLmN1ZS5pZCA9IGxpbmU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUHJvY2VzcyBsaW5lIGFzIHN0YXJ0IG9mIGEgY3VlLlxuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnQ1VFJzpcbiAgICAgICAgICAvLyA0MCAtIENvbGxlY3QgY3VlIHRpbWluZ3MgYW5kIHNldHRpbmdzLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXJzZUN1ZShsaW5lLCBzZWxmLmN1ZSwgc2VsZi5yZWdpb25MaXN0KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yIGlnbm9yZSByZXN0IG9mIHRoZSBjdWUuXG4gICAgICAgICAgICBzZWxmLmN1ZSA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0JBRENVRSc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5zdGF0ZSA9ICdDVUVURVhUJztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSAnQ1VFVEVYVCc6XG4gICAgICAgICAgdmFyIGhhc1N1YnN0cmluZyA9IGxpbmUuaW5kZXhPZignLS0+JykgIT09IC0xO1xuICAgICAgICAgIC8vIDM0IC0gSWYgd2UgaGF2ZSBhbiBlbXB0eSBsaW5lIHRoZW4gcmVwb3J0IHRoZSBjdWUuXG4gICAgICAgICAgLy8gMzUgLSBJZiB3ZSBoYXZlIHRoZSBzcGVjaWFsIHN1YnN0cmluZyAnLS0+JyB0aGVuIHJlcG9ydCB0aGUgY3VlLFxuICAgICAgICAgIC8vIGJ1dCBkbyBub3QgY29sbGVjdCB0aGUgbGluZSBhcyB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIGN1cnJlbnRcbiAgICAgICAgICAvLyBvbmUgYXMgYSBuZXcgY3VlLlxuICAgICAgICAgIGlmICghbGluZSB8fCBoYXNTdWJzdHJpbmcgJiYgKGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgIC8vIFdlIGFyZSBkb25lIHBhcnNpbmcgc2VsZiBjdWUuXG4gICAgICAgICAgICBpZiAoc2VsZi5vbmN1ZSkge1xuICAgICAgICAgICAgICBzZWxmLm9uY3VlKHNlbGYuY3VlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jdWUgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlbGYuY3VlLnRleHQpIHtcbiAgICAgICAgICAgIHNlbGYuY3VlLnRleHQgKz0gJ1xcbic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5jdWUudGV4dCArPSBsaW5lO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlICdCQURDVUUnOiAvLyBCQURDVUVcbiAgICAgICAgICAvLyA1NC02MiAtIENvbGxlY3QgYW5kIGRpc2NhcmQgdGhlIHJlbWFpbmluZyBjdWUuXG4gICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gJ0lEJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgcGFyc2luZyBhIGN1ZSwgcmVwb3J0IHdoYXQgd2UgaGF2ZS5cbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSAnQ1VFVEVYVCcgJiYgc2VsZi5jdWUgJiYgc2VsZi5vbmN1ZSkge1xuICAgICAgICBzZWxmLm9uY3VlKHNlbGYuY3VlKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5jdWUgPSBudWxsO1xuICAgICAgLy8gRW50ZXIgQkFEV0VCVlRUIHN0YXRlIGlmIGhlYWRlciB3YXMgbm90IHBhcnNlZCBjb3JyZWN0bHkgb3RoZXJ3aXNlXG4gICAgICAvLyBhbm90aGVyIGV4Y2VwdGlvbiBvY2N1cnJlZCBzbyBlbnRlciBCQURDVUUgc3RhdGUuXG4gICAgICBzZWxmLnN0YXRlID0gc2VsZi5zdGF0ZSA9PT0gJ0lOSVRJQUwnID8gJ0JBRFdFQlZUVCcgOiAnQkFEQ1VFJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICAvLyBGaW5pc2ggZGVjb2RpbmcgdGhlIHN0cmVhbS5cbiAgICAgIHNlbGYuYnVmZmVyICs9IHNlbGYuZGVjb2Rlci5kZWNvZGUoKTtcbiAgICAgIC8vIFN5bnRoZXNpemUgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBjdWUgb3IgcmVnaW9uLlxuICAgICAgaWYgKHNlbGYuY3VlIHx8IHNlbGYuc3RhdGUgPT09ICdIRUFERVInKSB7XG4gICAgICAgIHNlbGYuYnVmZmVyICs9ICdcXG5cXG4nO1xuICAgICAgICBzZWxmLnBhcnNlKCk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSd2ZSBmbHVzaGVkLCBwYXJzZWQsIGFuZCB3ZSdyZSBzdGlsbCBvbiB0aGUgSU5JVElBTCBzdGF0ZSB0aGVuXG4gICAgICAvLyB0aGF0IG1lYW5zIHdlIGRvbid0IGhhdmUgZW5vdWdoIG9mIHRoZSBzdHJlYW0gdG8gcGFyc2UgdGhlIGZpcnN0XG4gICAgICAvLyBsaW5lLlxuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdJTklUSUFMJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGlmIChzZWxmLm9uZmx1c2gpIHtcbiAgICAgIHNlbGYub25mbHVzaCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG5leHBvcnQgeyBmaXhMaW5lQnJlYWtzIH07XG5cbmV4cG9ydCBkZWZhdWx0IFZUVFBhcnNlcjtcbiIsImltcG9ydCBWVFRQYXJzZXIgZnJvbSAnLi92dHRwYXJzZXInO1xuaW1wb3J0IHsgdXRmOEFycmF5VG9TdHIgfSBmcm9tICcuLi9kZW11eC9pZDMnO1xuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggaXMgbm90IHN1cHBvcnRlZCBpbiBJRTExXG5jb25zdCBzdGFydHNXaXRoID0gZnVuY3Rpb24gKGlucHV0U3RyaW5nLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gIHJldHVybiBpbnB1dFN0cmluZy5zdWJzdHIocG9zaXRpb24gfHwgMCwgc2VhcmNoU3RyaW5nLmxlbmd0aCkgPT09IHNlYXJjaFN0cmluZztcbn07XG5cbmNvbnN0IGN1ZVN0cmluZzJtaWxsaXMgPSBmdW5jdGlvbiAodGltZVN0cmluZykge1xuICBsZXQgdHMgPSBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cigtMykpO1xuICBsZXQgc2VjcyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKC02LCAyKSk7XG4gIGxldCBtaW5zID0gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoLTksIDIpKTtcbiAgbGV0IGhvdXJzID0gdGltZVN0cmluZy5sZW5ndGggPiA5ID8gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoMCwgdGltZVN0cmluZy5pbmRleE9mKCc6JykpKSA6IDA7XG5cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodHMpIHx8ICFOdW1iZXIuaXNGaW5pdGUoc2VjcykgfHwgIU51bWJlci5pc0Zpbml0ZShtaW5zKSB8fCAhTnVtYmVyLmlzRmluaXRlKGhvdXJzKSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHRzICs9IDEwMDAgKiBzZWNzO1xuICB0cyArPSA2MCAqIDEwMDAgKiBtaW5zO1xuICB0cyArPSA2MCAqIDYwICogMTAwMCAqIGhvdXJzO1xuXG4gIHJldHVybiB0cztcbn07XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2hcbmNvbnN0IGhhc2ggPSBmdW5jdGlvbiAodGV4dCkge1xuICBsZXQgaGFzaCA9IDUzODE7XG4gIGxldCBpID0gdGV4dC5sZW5ndGg7XG4gIHdoaWxlIChpKSB7XG4gICAgaGFzaCA9IChoYXNoICogMzMpIF4gdGV4dC5jaGFyQ29kZUF0KC0taSk7XG4gIH1cblxuICByZXR1cm4gKGhhc2ggPj4+IDApLnRvU3RyaW5nKCk7XG59O1xuXG5jb25zdCBjYWxjdWxhdGVPZmZzZXQgPSBmdW5jdGlvbiAodnR0Q0NzLCBjYywgcHJlc2VudGF0aW9uVGltZSkge1xuICBsZXQgY3VyckNDID0gdnR0Q0NzW2NjXTtcbiAgbGV0IHByZXZDQyA9IHZ0dENDc1tjdXJyQ0MucHJldkNDXTtcblxuICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBkaXNjb250aW51aXR5IG9yIGN1ZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCBzaW5jZSB0aGUgbGFzdCBkaXNjb250aW51aXR5XG4gIC8vIE9mZnNldCA9IGN1cnJlbnQgZGlzY29udGludWl0eSB0aW1lXG4gIGlmICghcHJldkNDIHx8ICghcHJldkNDLm5ldyAmJiBjdXJyQ0MubmV3KSkge1xuICAgIHZ0dENDcy5jY09mZnNldCA9IHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBjdXJyQ0Muc3RhcnQ7XG4gICAgY3VyckNDLm5ldyA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRoZXJlIGhhdmUgYmVlbiBkaXNjb250aW51aXRpZXMgc2luY2UgY3VlcyB3ZXJlIGxhc3QgcGFyc2VkLlxuICAvLyBPZmZzZXQgPSB0aW1lIGVsYXBzZWRcbiAgd2hpbGUgKHByZXZDQyAmJiBwcmV2Q0MubmV3KSB7XG4gICAgdnR0Q0NzLmNjT2Zmc2V0ICs9IGN1cnJDQy5zdGFydCAtIHByZXZDQy5zdGFydDtcbiAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XG4gICAgY3VyckNDID0gcHJldkNDO1xuICAgIHByZXZDQyA9IHZ0dENDc1tjdXJyQ0MucHJldkNDXTtcbiAgfVxuXG4gIHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBwcmVzZW50YXRpb25UaW1lO1xufTtcblxuY29uc3QgV2ViVlRUUGFyc2VyID0ge1xuICBwYXJzZTogZnVuY3Rpb24gKHZ0dEJ5dGVBcnJheSwgc3luY1BUUywgdnR0Q0NzLCBjYywgY2FsbEJhY2ssIGVycm9yQ2FsbEJhY2spIHtcbiAgICAvLyBDb252ZXJ0IGJ5dGVBcnJheSBpbnRvIHN0cmluZywgcmVwbGFjaW5nIGFueSBzb21ld2hhdCBleG90aWMgbGluZWZlZWRzIHdpdGggXCJcXG5cIiwgdGhlbiBzcGxpdCBvbiB0aGF0IGNoYXJhY3Rlci5cbiAgICBsZXQgcmUgPSAvXFxyXFxufFxcblxccnxcXG58XFxyL2c7XG4gICAgLy8gVWludDhBcnJheS5wcm90b3R5cGUucmVkdWNlIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBJRTExXG4gICAgbGV0IHZ0dExpbmVzID0gdXRmOEFycmF5VG9TdHIobmV3IFVpbnQ4QXJyYXkodnR0Qnl0ZUFycmF5KSkudHJpbSgpLnJlcGxhY2UocmUsICdcXG4nKS5zcGxpdCgnXFxuJyk7XG5cbiAgICBsZXQgY3VlVGltZSA9ICcwMDowMC4wMDAnO1xuICAgIGxldCBtcGVnVHMgPSAwO1xuICAgIGxldCBsb2NhbFRpbWUgPSAwO1xuICAgIGxldCBwcmVzZW50YXRpb25UaW1lID0gMDtcbiAgICBsZXQgY3VlcyA9IFtdO1xuICAgIGxldCBwYXJzaW5nRXJyb3I7XG4gICAgbGV0IGluSGVhZGVyID0gdHJ1ZTtcbiAgICAvLyBsZXQgVlRUQ3VlID0gVlRUQ3VlIHx8IHdpbmRvdy5UZXh0VHJhY2tDdWU7XG5cbiAgICAvLyBDcmVhdGUgcGFyc2VyIG9iamVjdCB1c2luZyBWVFRDdWUgd2l0aCBUZXh0VHJhY2tDdWUgZmFsbGJhY2sgb24gY2VydGFpbiBicm93c2Vycy5cbiAgICBsZXQgcGFyc2VyID0gbmV3IFZUVFBhcnNlcigpO1xuXG4gICAgcGFyc2VyLm9uY3VlID0gZnVuY3Rpb24gKGN1ZSkge1xuICAgICAgLy8gQWRqdXN0IGN1ZSB0aW1pbmc7IGNsYW1wIGN1ZXMgdG8gc3RhcnQgbm8gZWFybGllciB0aGFuIC0gYW5kIGRyb3AgY3VlcyB0aGF0IGRvbid0IGVuZCBhZnRlciAtIDAgb24gdGltZWxpbmUuXG4gICAgICBsZXQgY3VyckNDID0gdnR0Q0NzW2NjXTtcbiAgICAgIGxldCBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQ7XG5cbiAgICAgIC8vIFVwZGF0ZSBvZmZzZXRzIGZvciBuZXcgZGlzY29udGludWl0aWVzXG4gICAgICBpZiAoY3VyckNDICYmIGN1cnJDQy5uZXcpIHtcbiAgICAgICAgaWYgKGxvY2FsVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBsb2NhbCB0aW1lIGlzIHByb3ZpZGVkLCBvZmZzZXQgPSBkaXNjb250aW51aXR5IHN0YXJ0IHRpbWUgLSBsb2NhbCB0aW1lXG4gICAgICAgICAgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0ID0gY3VyckNDLnN0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGN1bGF0ZU9mZnNldCh2dHRDQ3MsIGNjLCBwcmVzZW50YXRpb25UaW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJlc2VudGF0aW9uVGltZSkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIE1QRUdUUywgb2Zmc2V0ID0gcHJlc2VudGF0aW9uIHRpbWUgKyBkaXNjb250aW51aXR5IG9mZnNldFxuICAgICAgICBjdWVPZmZzZXQgPSBwcmVzZW50YXRpb25UaW1lIC0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldDtcbiAgICAgIH1cblxuICAgICAgY3VlLnN0YXJ0VGltZSArPSBjdWVPZmZzZXQgLSBsb2NhbFRpbWU7XG4gICAgICBjdWUuZW5kVGltZSArPSBjdWVPZmZzZXQgLSBsb2NhbFRpbWU7XG5cbiAgICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBoYXNoIGlkIGZvciBhIGN1ZSBiYXNlZCBvbiBzdGFydC9lbmQgdGltZXMgYW5kIHRleHQuXG4gICAgICAvLyBUaGlzIGhlbHBzIHRpbWVsaW5lLWNvbnRyb2xsZXIgdG8gYXZvaWQgc2hvd2luZyByZXBlYXRlZCBjYXB0aW9ucy5cbiAgICAgIGN1ZS5pZCA9IGhhc2goY3VlLnN0YXJ0VGltZS50b1N0cmluZygpKSArIGhhc2goY3VlLmVuZFRpbWUudG9TdHJpbmcoKSkgKyBoYXNoKGN1ZS50ZXh0KTtcblxuICAgICAgLy8gRml4IGVuY29kaW5nIG9mIHNwZWNpYWwgY2hhcmFjdGVycy4gVE9ETzogVGVzdCB3aXRoIGFsbCBzb3J0cyBvZiB3ZWlyZCBjaGFyYWN0ZXJzLlxuICAgICAgY3VlLnRleHQgPSBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlVVJJQ29tcG9uZW50KGN1ZS50ZXh0KSk7XG4gICAgICBpZiAoY3VlLmVuZFRpbWUgPiAwKSB7XG4gICAgICAgIGN1ZXMucHVzaChjdWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBwYXJzZXIub25wYXJzaW5nZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcGFyc2luZ0Vycm9yID0gZTtcbiAgICB9O1xuXG4gICAgcGFyc2VyLm9uZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocGFyc2luZ0Vycm9yICYmIGVycm9yQ2FsbEJhY2spIHtcbiAgICAgICAgZXJyb3JDYWxsQmFjayhwYXJzaW5nRXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYWxsQmFjayhjdWVzKTtcbiAgICB9O1xuXG4gICAgLy8gR28gdGhyb3VnaCBjb250ZW50cyBsaW5lIGJ5IGxpbmUuXG4gICAgdnR0TGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgIGlmIChpbkhlYWRlcikge1xuICAgICAgICAvLyBMb29rIGZvciBYLVRJTUVTVEFNUC1NQVAgaW4gaGVhZGVyLlxuICAgICAgICBpZiAoc3RhcnRzV2l0aChsaW5lLCAnWC1USU1FU1RBTVAtTUFQPScpKSB7XG4gICAgICAgICAgLy8gT25jZSBmb3VuZCwgbm8gbW9yZSBhcmUgYWxsb3dlZCBhbnl3YXksIHNvIHN0b3Agc2VhcmNoaW5nLlxuICAgICAgICAgIGluSGVhZGVyID0gZmFsc2U7XG4gICAgICAgICAgLy8gRXh0cmFjdCBMT0NBTCBhbmQgTVBFR1RTLlxuICAgICAgICAgIGxpbmUuc3Vic3RyKDE2KS5zcGxpdCgnLCcpLmZvckVhY2godGltZXN0YW1wID0+IHtcbiAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHRpbWVzdGFtcCwgJ0xPQ0FMOicpKSB7XG4gICAgICAgICAgICAgIGN1ZVRpbWUgPSB0aW1lc3RhbXAuc3Vic3RyKDYpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydHNXaXRoKHRpbWVzdGFtcCwgJ01QRUdUUzonKSkge1xuICAgICAgICAgICAgICBtcGVnVHMgPSBwYXJzZUludCh0aW1lc3RhbXAuc3Vic3RyKDcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHN1YnRpdGxlIG9mZnNldCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICAgICAgICBpZiAoc3luY1BUUyArICgodnR0Q0NzW2NjXS5zdGFydCAqIDkwMDAwKSB8fCAwKSA8IDApIHtcbiAgICAgICAgICAgICAgc3luY1BUUyArPSA4NTg5OTM0NTkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRqdXN0IE1QRUdUUyBieSBzeW5jIFBUUy5cbiAgICAgICAgICAgIG1wZWdUcyAtPSBzeW5jUFRTO1xuICAgICAgICAgICAgLy8gQ29udmVydCBjdWUgdGltZSB0byBzZWNvbmRzXG4gICAgICAgICAgICBsb2NhbFRpbWUgPSBjdWVTdHJpbmcybWlsbGlzKGN1ZVRpbWUpIC8gMTAwMDtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgTVBFR1RTIHRvIHNlY29uZHMgZnJvbSA5MGtIei5cbiAgICAgICAgICAgIHByZXNlbnRhdGlvblRpbWUgPSBtcGVnVHMgLyA5MDAwMDtcblxuICAgICAgICAgICAgaWYgKGxvY2FsVGltZSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGBNYWxmb3JtZWQgWC1USU1FU1RBTVAtTUFQOiAke2xpbmV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGBNYWxmb3JtZWQgWC1USU1FU1RBTVAtTUFQOiAke2xpbmV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiB3aXRob3V0IHBhcnNpbmcgWC1USU1FU1RBTVAtTUFQIGxpbmUuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbmUgPT09ICcnKSB7XG4gICAgICAgICAgaW5IZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUGFyc2UgbGluZSBieSBkZWZhdWx0LlxuICAgICAgcGFyc2VyLnBhcnNlKGxpbmUgKyAnXFxuJyk7XG4gICAgfSk7XG5cbiAgICBwYXJzZXIuZmx1c2goKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2ViVlRUUGFyc2VyO1xuIiwiLyoqXG4gKiBYSFIgYmFzZWQgbG9nZ2VyXG4qL1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jb25zdCB7IHBlcmZvcm1hbmNlLCBYTUxIdHRwUmVxdWVzdCB9ID0gd2luZG93O1xuXG5jbGFzcyBYaHJMb2FkZXIge1xuICBjb25zdHJ1Y3RvciAoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAmJiBjb25maWcueGhyU2V0dXApIHtcbiAgICAgIHRoaXMueGhyU2V0dXAgPSBjb25maWcueGhyU2V0dXA7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5hYm9ydCgpO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgfVxuXG4gIGFib3J0ICgpIHtcbiAgICBsZXQgbG9hZGVyID0gdGhpcy5sb2FkZXI7XG4gICAgaWYgKGxvYWRlciAmJiBsb2FkZXIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgdGhpcy5zdGF0cy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG51bGw7XG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZW91dCk7XG4gICAgdGhpcy5yZXRyeVRpbWVvdXQgPSBudWxsO1xuICB9XG5cbiAgbG9hZCAoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIHRoaXMuc3RhdHMgPSB7IHRyZXF1ZXN0OiBwZXJmb3JtYW5jZS5ub3coKSwgcmV0cnk6IDAgfTtcbiAgICB0aGlzLnJldHJ5RGVsYXkgPSBjb25maWcucmV0cnlEZWxheTtcbiAgICB0aGlzLmxvYWRJbnRlcm5hbCgpO1xuICB9XG5cbiAgbG9hZEludGVybmFsICgpIHtcbiAgICBsZXQgeGhyLCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIHhociA9IHRoaXMubG9hZGVyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICBsZXQgc3RhdHMgPSB0aGlzLnN0YXRzO1xuICAgIHN0YXRzLnRmaXJzdCA9IDA7XG4gICAgc3RhdHMubG9hZGVkID0gMDtcbiAgICBjb25zdCB4aHJTZXR1cCA9IHRoaXMueGhyU2V0dXA7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHhoclNldHVwKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgeGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBmaXggeGhyU2V0dXA6ICh4aHIsIHVybCkgPT4ge3hoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1MYW5ndWFnZVwiLCBcInRlc3RcIik7fVxuICAgICAgICAgIC8vIG5vdCB3b3JraW5nLCBhcyB4aHIuc2V0UmVxdWVzdEhlYWRlciBleHBlY3RzIHhoci5yZWFkeVN0YXRlID09PSBPUEVOXG4gICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcbiAgICAgICAgICB4aHJTZXR1cCh4aHIsIGNvbnRleHQudXJsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElFMTEgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiB4aHIub3BlbiBpZiBhdHRlbXB0aW5nIHRvIGFjY2VzcyBhbiBIVFRQIHJlc291cmNlIG92ZXIgSFRUUFNcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3IoeyBjb2RlOiB4aHIuc3RhdHVzLCB0ZXh0OiBlLm1lc3NhZ2UgfSwgY29udGV4dCwgeGhyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5yYW5nZUVuZCkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgJ2J5dGVzPScgKyBjb250ZXh0LnJhbmdlU3RhcnQgKyAnLScgKyAoY29udGV4dC5yYW5nZUVuZCAtIDEpKTtcbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5yZWFkeXN0YXRlY2hhbmdlLmJpbmQodGhpcyk7XG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSB0aGlzLmxvYWRwcm9ncmVzcy5iaW5kKHRoaXMpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSBjb250ZXh0LnJlc3BvbnNlVHlwZTtcblxuICAgIC8vIHNldHVwIHRpbWVvdXQgYmVmb3JlIHdlIHBlcmZvcm0gcmVxdWVzdFxuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIHRoaXMuY29uZmlnLnRpbWVvdXQpO1xuICAgIHhoci5zZW5kKCk7XG4gIH1cblxuICByZWFkeXN0YXRlY2hhbmdlIChldmVudCkge1xuICAgIGxldCB4aHIgPSBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlLFxuICAgICAgc3RhdHMgPSB0aGlzLnN0YXRzLFxuICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgLy8gZG9uJ3QgcHJvY2VlZCBpZiB4aHIgaGFzIGJlZW4gYWJvcnRlZFxuICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gPj0gSEVBREVSU19SRUNFSVZFRFxuICAgIGlmIChyZWFkeVN0YXRlID49IDIpIHtcbiAgICAgIC8vIGNsZWFyIHhociB0aW1lb3V0IGFuZCByZWFybSBpdCBpZiByZWFkeVN0YXRlIGxlc3MgdGhhbiA0XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgaWYgKHN0YXRzLnRmaXJzdCA9PT0gMCkge1xuICAgICAgICBzdGF0cy50Zmlyc3QgPSBNYXRoLm1heChwZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMudHJlcXVlc3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBsZXQgc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgICAgLy8gaHR0cCBzdGF0dXMgYmV0d2VlbiAyMDAgdG8gMjk5IGFyZSBhbGwgc3VjY2Vzc2Z1bFxuICAgICAgICBpZiAoc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICBzdGF0cy50bG9hZCA9IE1hdGgubWF4KHN0YXRzLnRmaXJzdCwgcGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICAgIGxldCBkYXRhLCBsZW47XG4gICAgICAgICAgaWYgKGNvbnRleHQucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgICAgICBkYXRhID0geGhyLnJlc3BvbnNlO1xuICAgICAgICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0cy5sb2FkZWQgPSBzdGF0cy50b3RhbCA9IGxlbjtcbiAgICAgICAgICBsZXQgcmVzcG9uc2UgPSB7IHVybDogeGhyLnJlc3BvbnNlVVJMLCBkYXRhOiBkYXRhIH07XG4gICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgeGhyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBtYXggbmIgb2YgcmV0cmllcyByZWFjaGVkIG9yIGlmIGh0dHAgc3RhdHVzIGJldHdlZW4gNDAwIGFuZCA0OTkgKHN1Y2ggZXJyb3IgY2Fubm90IGJlIHJlY292ZXJlZCwgcmV0cnlpbmcgaXMgdXNlbGVzcyksIHJldHVybiBlcnJvclxuICAgICAgICAgIGlmIChzdGF0cy5yZXRyeSA+PSBjb25maWcubWF4UmV0cnkgfHwgKHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDwgNDk5KSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGAke3N0YXR1c30gd2hpbGUgbG9hZGluZyAke2NvbnRleHQudXJsfWApO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcih7IGNvZGU6IHN0YXR1cywgdGV4dDogeGhyLnN0YXR1c1RleHQgfSwgY29udGV4dCwgeGhyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcmV0cnlcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGAke3N0YXR1c30gd2hpbGUgbG9hZGluZyAke2NvbnRleHQudXJsfSwgcmV0cnlpbmcgaW4gJHt0aGlzLnJldHJ5RGVsYXl9Li4uYCk7XG4gICAgICAgICAgICAvLyBhYm9ydHMgYW5kIHJlc2V0cyBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAvLyBzY2hlZHVsZSByZXRyeVxuICAgICAgICAgICAgdGhpcy5yZXRyeVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLCB0aGlzLnJldHJ5RGVsYXkpO1xuICAgICAgICAgICAgLy8gc2V0IGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgICAgIHRoaXMucmV0cnlEZWxheSA9IE1hdGgubWluKDIgKiB0aGlzLnJldHJ5RGVsYXksIGNvbmZpZy5tYXhSZXRyeURlbGF5KTtcbiAgICAgICAgICAgIHN0YXRzLnJldHJ5Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWFkeVN0YXRlID49IDIgQU5EIHJlYWR5U3RhdGUgIT09NCAocmVhZHlTdGF0ZSA9IEhFQURFUlNfUkVDRUlWRUQgfHwgTE9BRElORykgcmVhcm0gdGltZW91dCBhcyB4aHIgbm90IGZpbmlzaGVkIHlldFxuICAgICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBjb25maWcudGltZW91dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbG9hZHRpbWVvdXQgKCkge1xuICAgIGxvZ2dlci53YXJuKGB0aW1lb3V0IHdoaWxlIGxvYWRpbmcgJHt0aGlzLmNvbnRleHQudXJsfWApO1xuICAgIHRoaXMuY2FsbGJhY2tzLm9uVGltZW91dCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIG51bGwpO1xuICB9XG5cbiAgbG9hZHByb2dyZXNzIChldmVudCkge1xuICAgIGxldCB4aHIgPSBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgc3RhdHMgPSB0aGlzLnN0YXRzO1xuXG4gICAgc3RhdHMubG9hZGVkID0gZXZlbnQubG9hZGVkO1xuICAgIGlmIChldmVudC5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICBzdGF0cy50b3RhbCA9IGV2ZW50LnRvdGFsO1xuICAgIH1cblxuICAgIGxldCBvblByb2dyZXNzID0gdGhpcy5jYWxsYmFja3Mub25Qcm9ncmVzcztcbiAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgLy8gdGhpcmQgYXJnIGlzIHRvIHByb3ZpZGUgb24gcHJvZ3Jlc3MgZGF0YVxuICAgICAgb25Qcm9ncmVzcyhzdGF0cywgdGhpcy5jb250ZXh0LCBudWxsLCB4aHIpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBYaHJMb2FkZXI7XG4iLCJpbXBvcnQgUGxheWVyIGZyb20gJ3hncGxheWVyJ1xuaW1wb3J0IEhscyBmcm9tICcuL2hscy5qcy9obHMnXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi91dGlscydcblxuY2xhc3MgSGxzSnNQbGF5ZXIgZXh0ZW5kcyBQbGF5ZXIge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpXG4gICAgdGhpcy5obHNPcHRzID0gb3B0aW9ucy5obHNPcHRzIHx8IHt9XG4gICAgbGV0IHV0aWwgPSBQbGF5ZXIudXRpbFxuICAgIGxldCBwbGF5ZXIgPSB0aGlzXG4gICAgdGhpcy5icm93c2VyID0gdXRpbHMuZ2V0QnJvd3NlclZlcnNpb24oKVxuICAgIGlmKHBsYXllci5jb25maWcudXNlSGxzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICgoUGxheWVyLnNuaWZmZXIuZGV2aWNlID09PSAnbW9iaWxlJyAmJiBuYXZpZ2F0b3IucGxhdGZvcm0gIT09ICdNYWNJbnRlbCcgJiYgbmF2aWdhdG9yLnBsYXRmb3JtICE9PSAnV2luMzInKSB8fCB0aGlzLmJyb3dzZXIuaW5kZXhPZignU2FmYXJpJykgPiAtMSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoIXBsYXllci5jb25maWcudXNlSGxzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgTnVtYmVyLmlzRmluaXRlID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBsZXQgaGxzXG4gICAgaGxzID0gbmV3IEhscyh0aGlzLmhsc09wdHMpXG4gICAgdGhpcy5obHMgPSBobHNcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwbGF5ZXIsICdzcmMnLCB7XG4gICAgICBnZXQgKCkge1xuICAgICAgICByZXR1cm4gcGxheWVyLmN1cnJlbnRTcmNcbiAgICAgIH0sXG4gICAgICBzZXQgKHVybCkge1xuICAgICAgICB1dGlsLnJlbW92ZUNsYXNzKHBsYXllci5yb290LCAneGdwbGF5ZXItaXMtbGl2ZScpXG4gICAgICAgIGNvbnN0IGxpdmVEb20gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcueGdwbGF5ZXItbGl2ZScpXG4gICAgICAgIGlmIChsaXZlRG9tKSB7XG4gICAgICAgICAgbGl2ZURvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpdmVEb20pXG4gICAgICAgIH1cbiAgICAgICAgLy8gcGxheWVyLmNvbmZpZy51cmwgPSB1cmxcbiAgICAgICAgY29uc3QgcGF1c2VkID0gcGxheWVyLnBhdXNlZFxuICAgICAgICBwbGF5ZXIuaGxzLnN0b3BMb2FkKClcbiAgICAgICAgcGxheWVyLmhscy5kZXRhY2hNZWRpYSgpXG4gICAgICAgIHBsYXllci5obHMuZGVzdHJveSgpXG4gICAgICAgIHBsYXllci5obHMgPSBuZXcgSGxzKHBsYXllci5obHNPcHRzKVxuICAgICAgICBwbGF5ZXIucmVnaXN0ZXIodXJsKVxuICAgICAgICBpZiAoIXBhdXNlZCkge1xuICAgICAgICAgIHBsYXllci5wYXVzZSgpXG4gICAgICAgICAgcGxheWVyLm9uY2UoJ3BhdXNlJywgKCkgPT4ge1xuICAgICAgICAgICAgcGxheWVyLmhscy5sb2FkU291cmNlKHVybClcbiAgICAgICAgICB9KVxuICAgICAgICAgIHBsYXllci5vbmNlKCdjYW5wbGF5JywgKCkgPT4ge1xuICAgICAgICAgICAgcGxheWVyLnBsYXkoKS5jYXRjaChlcnIgPT4ge30pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwbGF5ZXIuaGxzLmxvYWRTb3VyY2UodXJsKVxuICAgICAgICB9XG4gICAgICAgIHBsYXllci5obHMuYXR0YWNoTWVkaWEocGxheWVyLnZpZGVvKVxuICAgICAgICBwbGF5ZXIub25jZSgnY2FucGxheScsICgpID0+IHtcbiAgICAgICAgICBwbGF5ZXIuY3VycmVudFRpbWUgPSAwXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgICB0aGlzLnJlZ2lzdGVyKHRoaXMuY29uZmlnLnVybClcbiAgICB0aGlzLm9uY2UoJ2NvbXBsZXRlJywgKCkgPT4ge1xuICAgICAgaGxzLmF0dGFjaE1lZGlhKHBsYXllci52aWRlbylcbiAgICAgIHBsYXllci5vbmNlKCdjYW5wbGF5JywgKCkgPT4ge1xuICAgICAgICBpZihwbGF5ZXIuY29uZmlnLmF1dG9wbGF5KSB7XG4gICAgICAgICAgcGxheWVyLnBsYXkoKS5jYXRjaChlcnIgPT4ge30pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpZihwbGF5ZXIuY29uZmlnLmlzTGl2ZSkge1xuICAgICAgICB1dGlsLmFkZENsYXNzKHBsYXllci5yb290LCAneGdwbGF5ZXItaXMtbGl2ZScpXG4gICAgICAgIGlmKCF1dGlsLmZpbmREb20ocGxheWVyLnJvb3QsICcueGdwbGF5ZXItbGl2ZScpKSB7XG4gICAgICAgICAgY29uc3QgbGl2ZSA9IHV0aWwuY3JlYXRlRG9tKCd4Zy1saXZlJywgJ+ato+WcqOebtOaSrScsIHt9LCAneGdwbGF5ZXItbGl2ZScpXG4gICAgICAgICAgcGxheWVyLmNvbnRyb2xzLmFwcGVuZENoaWxkKGxpdmUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMub25jZSgnZGVzdHJveScsICgpID0+IHtcbiAgICAgIGhscy5zdG9wTG9hZCgpXG4gICAgfSlcbiAgfVxuICByZWdpc3RlciAodXJsKSB7XG4gICAgbGV0IGhscyA9IHRoaXMuaGxzXG4gICAgbGV0IHV0aWwgPSBQbGF5ZXIudXRpbFxuICAgIGxldCBwbGF5ZXIgPSB0aGlzXG4gICAgaGxzLm9uKEhscy5FdmVudHMuTUVESUFfQVRUQUNIRUQsICgpID0+IHtcbiAgICAgIGhscy5sb2FkU291cmNlKHVybClcbiAgICB9KVxuXG4gICAgaGxzLm9uKEhscy5FdmVudHMuTEVWRUxfTE9BREVELCAobmFtZSwgZSkgPT4ge1xuICAgICAgaWYgKCFobHMuaW5pdGVkKSB7XG4gICAgICAgIGhscy5pbml0ZWQgPSB0cnVlXG4gICAgICAgIGlmIChlICYmIGUuZGV0YWlscyAmJiBlLmRldGFpbHMubGl2ZSkge1xuICAgICAgICAgIHV0aWwuYWRkQ2xhc3MocGxheWVyLnJvb3QsICd4Z3BsYXllci1pcy1saXZlJylcbiAgICAgICAgICBpZighdXRpbC5maW5kRG9tKHBsYXllci5yb290LCAnLnhncGxheWVyLWxpdmUnKSkge1xuICAgICAgICAgICAgY29uc3QgbGl2ZSA9IHV0aWwuY3JlYXRlRG9tKCd4Zy1saXZlJywgJ+ato+WcqOebtOaSrScsIHt9LCAneGdwbGF5ZXItbGl2ZScpXG4gICAgICAgICAgICBwbGF5ZXIuY29udHJvbHMuYXBwZW5kQ2hpbGQobGl2ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICAgIGhscy5vbihIbHMuRXZlbnRzLkVSUk9SLCAoZXZlbnQsIGRhdGEpID0+IHtcbiAgICAgIHBsYXllci5lbWl0KCdITFNfRVJST1InLCB7XG4gICAgICAgIGVycm9yVHlwZTogZGF0YS50eXBlLFxuICAgICAgICBlcnJvckRldGFpbHM6IGRhdGEuZGV0YWlscyxcbiAgICAgICAgZXJyb3JGYXRhbDogZGF0YS5mYXRhbCxcbiAgICAgIH0pXG4gICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgSGxzLkVycm9yVHlwZXMuTkVUV09SS19FUlJPUjpcbiAgICAgICAgICAgIGhscy5zdGFydExvYWQoKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEhscy5FcnJvclR5cGVzLk1FRElBX0VSUk9SOlxuICAgICAgICAgICAgaGxzLnJlY292ZXJNZWRpYUVycm9yKClcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHBsYXllci5lbWl0KCdlcnJvcicsIGRhdGEpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuX3N0YXRpc3RpY3MoKTtcbiAgfVxuXG4gIF9zdGF0aXN0aWNzKCkge1xuICAgIGxldCBzdGF0c0luZm8gPSB7XG4gICAgICBzcGVlZDowLFxuICAgICAgcGxheWVyVHlwZTogXCJIbHNQbGF5ZXJcIlxuICAgIH07XG5cbiAgICBsZXQgbWVkaWFpbmZvID0ge1xuICAgICAgdmlkZW9EYXRhUmF0ZTowLFxuICAgICAgYXVkaW9EYXRhUmF0ZTowXG4gICAgfTtcbiAgICBsZXQgaGxzID0gdGhpcy5obHM7XG4gICAgbGV0IHBsYXllciA9IHRoaXM7XG5cbiAgICBobHMub24oSGxzLkV2ZW50cy5GUkFHX0xPQURfUFJPR1JFU1MsIChmbGFnLHBheWxvYWQpID0+e1xuICAgICAgc3RhdHNJbmZvLnNwZWVkID0gcGF5bG9hZC5zdGF0cy5sb2FkZWQgLyAxMDAwO1xuICAgIH0pO1xuICAgIGhscy5vbihIbHMuRXZlbnRzLkZSQUdfUEFSU0lOR19EQVRBLCAoZmxhZyxwYXlsb2FkKSA9PntcbiAgICAgIGlmIChwYXlsb2FkLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgbWVkaWFpbmZvLmZwcyA9IHBhcnNlSW50KHBheWxvYWQubmIvKHBheWxvYWQuZW5kUFRTIC1wYXlsb2FkLnN0YXJ0UFRTKSk7XG4gICAgICB9XG4gICAgfSlcblxuICAgIGhscy5vbihIbHMuRXZlbnRzLkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIChmbGFnLHBheWxvYWQpID0+e1xuICAgICAgbWVkaWFpbmZvLmhhc0F1ZGlvID0gKHBheWxvYWQudHJhY2tzICYmIHBheWxvYWQudHJhY2tzLmF1ZGlvKT8gdHJ1ZTogZmFsc2U7XG4gICAgICBtZWRpYWluZm8uaGFzVmlkZW8gPSAocGF5bG9hZC50cmFja3MgJiYgcGF5bG9hZC50cmFja3MuYXVkaW8pPyB0cnVlOiBmYWxzZTtcblxuICAgICAgaWYobWVkaWFpbmZvLmhhc0F1ZGlvKSB7XG4gICAgICAgIGxldCB0cmFjayA9IHBheWxvYWQudHJhY2tzLmF1ZGlvO1xuICAgICAgICBtZWRpYWluZm8uYXVkaW9DaGFubmVsQ291bnQgPSAodHJhY2subWV0YWRhdGEgJiYgdHJhY2subWV0YWRhdGEuY2hhbm5lbENvdW50KSA/IHRyYWNrLm1ldGFkYXRhLmNoYW5uZWxDb3VudDowO1xuICAgICAgICBtZWRpYWluZm8uYXVkaW9Db2RlYyA9IHRyYWNrLmNvZGVjO1xuICAgICAgfVxuXG4gICAgICBpZihtZWRpYWluZm8uaGFzVmlkZW8pIHtcbiAgICAgICAgbGV0IHRyYWNrID0gcGF5bG9hZC50cmFja3MudmlkZW87XG4gICAgICAgIG1lZGlhaW5mby52aWRlb0NvZGVjID0gdHJhY2suY29kZWM7XG4gICAgICAgIG1lZGlhaW5mby53aWR0aCA9ICh0cmFjay5tZXRhZGF0YSAmJiB0cmFjay5tZXRhZGF0YS53aWR0aCkgPyB0cmFjay5tZXRhZGF0YS53aWR0aDowO1xuICAgICAgICBtZWRpYWluZm8uaGVpZ2h0ID0gKHRyYWNrLm1ldGFkYXRhICYmIHRyYWNrLm1ldGFkYXRhLmhlaWdodCkgPyB0cmFjay5tZXRhZGF0YS5oZWlnaHQ6MDtcbiAgICAgIH1cbiAgICAgIG1lZGlhaW5mby5kdXJhdGlvbiA9IChwYXlsb2FkLmZyYWcgJiYgcGF5bG9hZC5mcmFnLmR1cmF0aW9uKSA/IHBheWxvYWQuZnJhZy5kdXJhdGlvbjowXG4gICAgICBtZWRpYWluZm8ubGV2ZWwgPShwYXlsb2FkLmZyYWcgJiYgcGF5bG9hZC5mcmFnLmxldmVscykgPyBwYXlsb2FkLmZyYWcubGV2ZWxzOjA7XG4gICAgICBpZihtZWRpYWluZm8udmlkZW9Db2RlYyB8fCBtZWRpYWluZm8uYXVkaW9Db2RlYykge1xuICAgICAgICBtZWRpYWluZm8ubWltZVR5cGUgPSBgdmlkZW8vaGxzOyBjb2RlY3M9XCIke21lZGlhaW5mby52aWRlb0NvZGVjfTske21lZGlhaW5mby5hdWRpb0NvZGVjfVwiYFxuICAgICAgfVxuXG4gICAgICBwbGF5ZXIubWVkaWFpbmZvID0gbWVkaWFpbmZvO1xuICAgICAgcGxheWVyLmVtaXQoXCJtZWRpYV9pbmZvXCIsIG1lZGlhaW5mbyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zdGF0aXN0aWNzVGltbWVyID0gc2V0SW50ZXJ2YWwoKCk9PntcbiAgICAgIHBsYXllci5lbWl0KFwic3RhdGlzdGljc19pbmZvXCIsIHN0YXRzSW5mbyk7XG4gICAgICBzdGF0c0luZm8uc3BlZWQgPSAwO1xuICAgIH0sIDEwMDApXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX3N0YXRpc3RpY3NUaW1tZXIpO1xuICB9XG59XG5cbkhsc0pzUGxheWVyLmlzU3VwcG9ydGVkID0gSGxzLmlzU3VwcG9ydGVkXG5cbmV4cG9ydCBkZWZhdWx0IEhsc0pzUGxheWVyXG4iLCJsZXQgdXRpbCA9IHt9XG5cbnV0aWwuZ2V0QnJvd3NlclZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGxldCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50IC8v5Y+W5b6X5rWP6KeI5Zmo55qEdXNlckFnZW505a2X56ym5LiyXG4gIGlmKHVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJtb2JpbGVcIikgPiAtMSkge1xuICAgIHJldHVybiBcIlVua25vd25cIlxuICB9XG4gIGlmICh1c2VyQWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikgPiAtMSkge1xuICAgIGxldCB2ZXJzaW9uID0gdXNlckFnZW50Lm1hdGNoKC9maXJlZm94XFwvW1xcZC5dKy9naSlbMF0ubWF0Y2goL1tcXGRdKy8pWzBdXG4gICAgcmV0dXJuIFwiRmlyZWZveCBcIit2ZXJzaW9uXG4gIH0gZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoXCJFZGdlXCIpID4gLTEpIHtcbiAgICBsZXQgdmVyc2lvbiA9IHVzZXJBZ2VudC5tYXRjaCgvZWRnZVxcL1tcXGQuXSsvZ2kpWzBdLm1hdGNoKC9bXFxkXSsvKVswXVxuICAgIHJldHVybiBcIkVkZ2UgXCIrdmVyc2lvblxuICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKFwicnY6MTFcIikgPiAtMSkge1xuICAgIHJldHVybiBcIklFIDExXCJcbiAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZihcIk9wZXJhXCIpID4gLTEgfHwgdXNlckFnZW50LmluZGV4T2YoXCJPUFJcIikgPiAtMSkge1xuICAgIGlmICh1c2VyQWdlbnQuaW5kZXhPZihcIk9wZXJhXCIpID4gLTEpIHtcbiAgICAgIGxldCB2ZXJzaW9uID0gdXNlckFnZW50Lm1hdGNoKC9vcGVyYVxcL1tcXGQuXSsvZ2kpWzBdLm1hdGNoKC9bXFxkXSsvKVswXVxuICAgICAgcmV0dXJuIFwiT3BlcmEgXCIrdmVyc2lvblxuICAgIH1cbiAgICBpZiAodXNlckFnZW50LmluZGV4T2YoXCJPUFJcIikgPiAtMSkge1xuICAgICAgbGV0IHZlcnNpb24gPSB1c2VyQWdlbnQubWF0Y2goL29wclxcL1tcXGQuXSsvZ2kpWzBdLm1hdGNoKC9bXFxkXSsvKVswXVxuICAgICAgcmV0dXJuIFwiT3BlcmEgXCIrdmVyc2lvblxuICAgIH1cbiAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZihcIkNocm9tZVwiKSA+IC0xKSB7XG4gICAgbGV0IHZlcnNpb24gPSB1c2VyQWdlbnQubWF0Y2goL2Nocm9tZVxcL1tcXGQuXSsvZ2kpWzBdLm1hdGNoKC9bXFxkXSsvKVswXVxuICAgIHJldHVybiBcIkNocm9tZSBcIit2ZXJzaW9uXG4gIH0gZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoXCJTYWZhcmlcIikgPiAtMSkge1xuICAgIGxldCB2ZXJzaW9uID0gdXNlckFnZW50Lm1hdGNoKC9zYWZhcmlcXC9bXFxkLl0rL2dpKVswXS5tYXRjaCgvW1xcZF0rLylbMF1cbiAgICByZXR1cm4gXCJTYWZhcmkgXCIrdmVyc2lvblxuICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRVwiKSA+IC0xIHx8IHVzZXJBZ2VudC5pbmRleE9mKFwiVHJpZGVudFwiKSA+IC0xKSB7XG4gICAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRVwiKSA+IC0xKSB7XG4gICAgICBsZXQgdmVyc2lvbiA9IHVzZXJBZ2VudC5tYXRjaCgvbXNpZSBbXFxkLl0rL2dpKVswXS5tYXRjaCgvW1xcZF0rLylbMF1cbiAgICAgIHJldHVybiBcIklFIFwiK3ZlcnNpb25cbiAgICB9XG4gICAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKFwiVHJpZGVudFwiKSA+IC0xKSB7XG4gICAgICBsZXQgdmVyc2lvblRyaWRlbnQgPSB1c2VyQWdlbnQubWF0Y2goL3RyaWRlbnRcXC9bXFxkLl0rL2dpKVswXS5tYXRjaCgvW1xcZF0rLylbMF1cbiAgICAgIGxldCB2ZXJzaW9uID0gcGFyc2VJbnQodmVyc2lvblRyaWRlbnQpICsgNFxuICAgICAgcmV0dXJuIFwiSUUgXCIrdmVyc2lvblxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJVbmtub3duXCJcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB1dGlsXG4iLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gd2luZG93W1wiUGxheWVyXCJdOyB9KCkpOyJdLCJzb3VyY2VSb290IjoiIn0=