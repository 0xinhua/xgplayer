window["HlsJsPlayer"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/eventemitter3/index.js":
/*!***********************************************************************************************!*\
  !*** /Users/leonardo/Documents/front-end/player/xgplayer/node_modules/eventemitter3/index.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "../../node_modules/events/events.js":
/*!*****************************************************************************************!*\
  !*** /Users/leonardo/Documents/front-end/player/xgplayer/node_modules/events/events.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),

/***/ "../../node_modules/url-toolkit/src/url-toolkit.js":
/*!*******************************************************************************************************!*\
  !*** /Users/leonardo/Documents/front-end/player/xgplayer/node_modules/url-toolkit/src/url-toolkit.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// see https://tools.ietf.org/html/rfc1808

/* jshint ignore:start */
(function(root) { 
/* jshint ignore:end */

  var URL_REGEX = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/\?#]*\/)*.*?)??(;.*?)?(\?.*?)?(#.*?)?$/;
  var FIRST_SEGMENT_REGEX = /^([^\/?#]*)(.*)$/;
  var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
  var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g;

  var URLToolkit = { // jshint ignore:line
    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
    // E.g
    // With opts.alwaysNormalize = false (default, spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
    // With opts.alwaysNormalize = true (not spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
    buildAbsoluteURL: function(baseURL, relativeURL, opts) {
      opts = opts || {};
      // remove any remaining space and CRLF
      baseURL = baseURL.trim();
      relativeURL = relativeURL.trim();
      if (!relativeURL) {
        // 2a) If the embedded URL is entirely empty, it inherits the
        // entire base URL (i.e., is set equal to the base URL)
        // and we are done.
        if (!opts.alwaysNormalize) {
          return baseURL;
        }
        var basePartsForNormalise = URLToolkit.parseURL(baseURL);
        if (!basePartsForNormalise) {
          throw new Error('Error trying to parse base URL.');
        }
        basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
        return URLToolkit.buildURLFromParts(basePartsForNormalise);
      }
      var relativeParts = URLToolkit.parseURL(relativeURL);
      if (!relativeParts) {
        throw new Error('Error trying to parse relative URL.');
      }
      if (relativeParts.scheme) {
        // 2b) If the embedded URL starts with a scheme name, it is
        // interpreted as an absolute URL and we are done.
        if (!opts.alwaysNormalize) {
          return relativeURL;
        }
        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
        return URLToolkit.buildURLFromParts(relativeParts);
      }
      var baseParts = URLToolkit.parseURL(baseURL);
      if (!baseParts) {
        throw new Error('Error trying to parse base URL.');
      }
      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc
        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
        baseParts.netLoc = pathParts[1];
        baseParts.path = pathParts[2];
      }
      if (baseParts.netLoc && !baseParts.path) {
        baseParts.path = '/';
      }
      var builtParts = {
        // 2c) Otherwise, the embedded URL inherits the scheme of
        // the base URL.
        scheme: baseParts.scheme,
        netLoc: relativeParts.netLoc,
        path: null,
        params: relativeParts.params,
        query: relativeParts.query,
        fragment: relativeParts.fragment
      };
      if (!relativeParts.netLoc) {
        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
        // (if any) of the base URL.
        builtParts.netLoc = baseParts.netLoc;
        // 4) If the embedded URL path is preceded by a slash "/", the
        // path is not relative and we skip to Step 7.
        if (relativeParts.path[0] !== '/') {
          if (!relativeParts.path) {
            // 5) If the embedded URL path is empty (and not preceded by a
            // slash), then the embedded URL inherits the base URL path
            builtParts.path = baseParts.path;
            // 5a) if the embedded URL's <params> is non-empty, we skip to
            // step 7; otherwise, it inherits the <params> of the base
            // URL (if any) and
            if (!relativeParts.params) {
              builtParts.params = baseParts.params;
              // 5b) if the embedded URL's <query> is non-empty, we skip to
              // step 7; otherwise, it inherits the <query> of the base
              // URL (if any) and we skip to step 7.
              if (!relativeParts.query) {
                builtParts.query = baseParts.query;
              }
            }
          } else {
            // 6) The last segment of the base URL's path (anything
            // following the rightmost slash "/", or the entire path if no
            // slash is present) is removed and the embedded URL's path is
            // appended in its place.
            var baseURLPath = baseParts.path;
            var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;
            builtParts.path = URLToolkit.normalizePath(newPath);
          }
        }
      }
      if (builtParts.path === null) {
        builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
      }
      return URLToolkit.buildURLFromParts(builtParts);
    },
    parseURL: function(url) {
      var parts = URL_REGEX.exec(url);
      if (!parts) {
        return null;
      }
      return {
        scheme: parts[1] || '',
        netLoc: parts[2] || '',
        path: parts[3] || '',
        params: parts[4] || '',
        query: parts[5] || '',
        fragment: parts[6] || ''
      };
    },
    normalizePath: function(path) {
      // The following operations are
      // then applied, in order, to the new path:
      // 6a) All occurrences of "./", where "." is a complete path
      // segment, are removed.
      // 6b) If the path ends with "." as a complete path segment,
      // that "." is removed.
      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
      // 6c) All occurrences of "<segment>/../", where <segment> is a
      // complete path segment not equal to "..", are removed.
      // Removal of these path segments is performed iteratively,
      // removing the leftmost matching pattern on each iteration,
      // until no matching pattern remains.
      // 6d) If the path ends with "<segment>/..", where <segment> is a
      // complete path segment not equal to "..", that
      // "<segment>/.." is removed.
      while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {} // jshint ignore:line
      return path.split('').reverse().join('');
    },
    buildURLFromParts: function(parts) {
      return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
    }
  };

/* jshint ignore:start */
  if(true)
    module.exports = URLToolkit;
  else {}
})(this);
/* jshint ignore:end */


/***/ }),

/***/ "../../node_modules/webworkify-webpack/index.js":
/*!****************************************************************************************************!*\
  !*** /Users/leonardo/Documents/front-end/player/xgplayer/node_modules/webworkify-webpack/index.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function webpackBootstrapFunc (modules) {
/******/  // The module cache
/******/  var installedModules = {};

/******/  // The require function
/******/  function __webpack_require__(moduleId) {

/******/    // Check if module is in cache
/******/    if(installedModules[moduleId])
/******/      return installedModules[moduleId].exports;

/******/    // Create a new module (and put it into the cache)
/******/    var module = installedModules[moduleId] = {
/******/      i: moduleId,
/******/      l: false,
/******/      exports: {}
/******/    };

/******/    // Execute the module function
/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/    // Flag the module as loaded
/******/    module.l = true;

/******/    // Return the exports of the module
/******/    return module.exports;
/******/  }

/******/  // expose the modules object (__webpack_modules__)
/******/  __webpack_require__.m = modules;

/******/  // expose the module cache
/******/  __webpack_require__.c = installedModules;

/******/  // identity function for calling harmony imports with the correct context
/******/  __webpack_require__.i = function(value) { return value; };

/******/  // define getter function for harmony exports
/******/  __webpack_require__.d = function(exports, name, getter) {
/******/    if(!__webpack_require__.o(exports, name)) {
/******/      Object.defineProperty(exports, name, {
/******/        configurable: false,
/******/        enumerable: true,
/******/        get: getter
/******/      });
/******/    }
/******/  };

/******/  // define __esModule on exports
/******/  __webpack_require__.r = function(exports) {
/******/    Object.defineProperty(exports, '__esModule', { value: true });
/******/  };

/******/  // getDefaultExport function for compatibility with non-harmony modules
/******/  __webpack_require__.n = function(module) {
/******/    var getter = module && module.__esModule ?
/******/      function getDefault() { return module['default']; } :
/******/      function getModuleExports() { return module; };
/******/    __webpack_require__.d(getter, 'a', getter);
/******/    return getter;
/******/  };

/******/  // Object.prototype.hasOwnProperty.call
/******/  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/  // __webpack_public_path__
/******/  __webpack_require__.p = "/";

/******/  // on error function for async loading
/******/  __webpack_require__.oe = function(err) { console.error(err); throw err; };

  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE)
  return f.default || f // try to call default if defined to also support babel esmodule exports
}

var moduleNameReqExp = '[\\.|\\-|\\+|\\w|\/|@]+'
var dependencyRegExp = '\\(\\s*(\/\\*.*?\\*\/)?\\s*.*?(' + moduleNameReqExp + ').*?\\)' // additional chars when output.pathinfo is true

// http://stackoverflow.com/a/2593661/130442
function quoteRegExp (str) {
  return (str + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&')
}

function isNumeric(n) {
  return !isNaN(1 * n); // 1 * n converts integers, integers as string ("123"), 1e3 and "1e3" to integers and strings to NaN
}

function getModuleDependencies (sources, module, queueName) {
  var retval = {}
  retval[queueName] = []

  var fnString = module.toString()
  var wrapperSignature = fnString.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/)
  if (!wrapperSignature) return retval
  var webpackRequireName = wrapperSignature[1]

  // main bundle deps
  var re = new RegExp('(\\\\n|\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g')
  var match
  while ((match = re.exec(fnString))) {
    if (match[3] === 'dll-reference') continue
    retval[queueName].push(match[3])
  }

  // dll deps
  re = new RegExp('\\(' + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, 'g')
  while ((match = re.exec(fnString))) {
    if (!sources[match[2]]) {
      retval[queueName].push(match[1])
      sources[match[2]] = __webpack_require__(match[1]).m
    }
    retval[match[2]] = retval[match[2]] || []
    retval[match[2]].push(match[4])
  }

  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3
  var keys = Object.keys(retval);
  for (var i = 0; i < keys.length; i++) {
    for (var j = 0; j < retval[keys[i]].length; j++) {
      if (isNumeric(retval[keys[i]][j])) {
        retval[keys[i]][j] = 1 * retval[keys[i]][j];
      }
    }
  }

  return retval
}

function hasValuesInQueues (queues) {
  var keys = Object.keys(queues)
  return keys.reduce(function (hasValues, key) {
    return hasValues || queues[key].length > 0
  }, false)
}

function getRequiredModules (sources, moduleId) {
  var modulesQueue = {
    main: [moduleId]
  }
  var requiredModules = {
    main: []
  }
  var seenModules = {
    main: {}
  }

  while (hasValuesInQueues(modulesQueue)) {
    var queues = Object.keys(modulesQueue)
    for (var i = 0; i < queues.length; i++) {
      var queueName = queues[i]
      var queue = modulesQueue[queueName]
      var moduleToCheck = queue.pop()
      seenModules[queueName] = seenModules[queueName] || {}
      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue
      seenModules[queueName][moduleToCheck] = true
      requiredModules[queueName] = requiredModules[queueName] || []
      requiredModules[queueName].push(moduleToCheck)
      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName)
      var newModulesKeys = Object.keys(newModules)
      for (var j = 0; j < newModulesKeys.length; j++) {
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || []
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]])
      }
    }
  }

  return requiredModules
}

module.exports = function (moduleId, options) {
  options = options || {}
  var sources = {
    main: __webpack_require__.m
  }

  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId)

  var src = ''

  Object.keys(requiredModules).filter(function (m) { return m !== 'main' }).forEach(function (module) {
    var entryModule = 0
    while (requiredModules[module][entryModule]) {
      entryModule++
    }
    requiredModules[module].push(entryModule)
    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'
    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[module][id].toString() }).join(',') + '});\n'
  })

  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources.main[id].toString() }).join(',') + '}))(self);'

  var blob = new window.Blob([src], { type: 'text/javascript' })
  if (options.bare) { return blob }

  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL

  var workerUrl = URL.createObjectURL(blob)
  var worker = new window.Worker(workerUrl)
  worker.objectURL = workerUrl

  return worker
}


/***/ }),

/***/ "./src/hls.js/config.js":
/*!******************************!*\
  !*** ./src/hls.js/config.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hlsDefaultConfig = undefined;

var _abrController = __webpack_require__(/*! ./controller/abr-controller */ "./src/hls.js/controller/abr-controller.js");

var _abrController2 = _interopRequireDefault(_abrController);

var _bufferController = __webpack_require__(/*! ./controller/buffer-controller */ "./src/hls.js/controller/buffer-controller.js");

var _bufferController2 = _interopRequireDefault(_bufferController);

var _capLevelController = __webpack_require__(/*! ./controller/cap-level-controller */ "./src/hls.js/controller/cap-level-controller.js");

var _capLevelController2 = _interopRequireDefault(_capLevelController);

var _fpsController = __webpack_require__(/*! ./controller/fps-controller */ "./src/hls.js/controller/fps-controller.js");

var _fpsController2 = _interopRequireDefault(_fpsController);

var _xhrLoader = __webpack_require__(/*! ./utils/xhr-loader */ "./src/hls.js/utils/xhr-loader.js");

var _xhrLoader2 = _interopRequireDefault(_xhrLoader);

var _audioTrackController = __webpack_require__(/*! ./controller/audio-track-controller */ "./src/hls.js/controller/audio-track-controller.js");

var _audioTrackController2 = _interopRequireDefault(_audioTrackController);

var _audioStreamController = __webpack_require__(/*! ./controller/audio-stream-controller */ "./src/hls.js/controller/audio-stream-controller.js");

var _audioStreamController2 = _interopRequireDefault(_audioStreamController);

var _cues = __webpack_require__(/*! ./utils/cues */ "./src/hls.js/utils/cues.js");

var Cues = _interopRequireWildcard(_cues);

var _timelineController = __webpack_require__(/*! ./controller/timeline-controller */ "./src/hls.js/controller/timeline-controller.js");

var _timelineController2 = _interopRequireDefault(_timelineController);

var _subtitleTrackController = __webpack_require__(/*! ./controller/subtitle-track-controller */ "./src/hls.js/controller/subtitle-track-controller.js");

var _subtitleTrackController2 = _interopRequireDefault(_subtitleTrackController);

var _subtitleStreamController = __webpack_require__(/*! ./controller/subtitle-stream-controller */ "./src/hls.js/controller/subtitle-stream-controller.js");

var _emeController = __webpack_require__(/*! ./controller/eme-controller */ "./src/hls.js/controller/eme-controller.js");

var _emeController2 = _interopRequireDefault(_emeController);

var _mediakeysHelper = __webpack_require__(/*! ./utils/mediakeys-helper */ "./src/hls.js/utils/mediakeys-helper.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import FetchLoader from './utils/fetch-loader';

var hlsDefaultConfig = exports.hlsDefaultConfig = {
  autoStartLoad: true, // used by stream-controller
  startPosition: -1, // used by stream-controller
  defaultAudioCodec: undefined, // used by stream-controller
  debug: false, // used by logger
  capLevelOnFPSDrop: false, // used by fps-controller
  capLevelToPlayerSize: false, // used by cap-level-controller
  initialLiveManifestSize: 1, // used by stream-controller
  maxBufferLength: 30, // used by stream-controller
  maxBufferSize: 60 * 1000 * 1000, // used by stream-controller
  maxBufferHole: 0.5, // used by stream-controller

  lowBufferWatchdogPeriod: 0.5, // used by stream-controller
  highBufferWatchdogPeriod: 3, // used by stream-controller
  nudgeOffset: 0.1, // used by stream-controller
  nudgeMaxRetry: 3, // used by stream-controller
  maxFragLookUpTolerance: 0.25, // used by stream-controller
  liveSyncDurationCount: 3, // used by stream-controller
  liveMaxLatencyDurationCount: Infinity, // used by stream-controller
  liveSyncDuration: undefined, // used by stream-controller
  liveMaxLatencyDuration: undefined, // used by stream-controller
  liveDurationInfinity: false, // used by buffer-controller
  liveBackBufferLength: Infinity, // used by buffer-controller
  maxMaxBufferLength: 600, // used by stream-controller
  enableWorker: true, // used by demuxer
  enableSoftwareAES: true, // used by decrypter
  manifestLoadingTimeOut: 10000, // used by playlist-loader
  manifestLoadingMaxRetry: 1, // used by playlist-loader
  manifestLoadingRetryDelay: 1000, // used by playlist-loader
  manifestLoadingMaxRetryTimeout: 64000, // used by playlist-loader
  startLevel: undefined, // used by level-controller
  levelLoadingTimeOut: 10000, // used by playlist-loader
  levelLoadingMaxRetry: 4, // used by playlist-loader
  levelLoadingRetryDelay: 1000, // used by playlist-loader
  levelLoadingMaxRetryTimeout: 64000, // used by playlist-loader
  fragLoadingTimeOut: 20000, // used by fragment-loader
  fragLoadingMaxRetry: 6, // used by fragment-loader
  fragLoadingRetryDelay: 1000, // used by fragment-loader
  fragLoadingMaxRetryTimeout: 64000, // used by fragment-loader
  startFragPrefetch: false, // used by stream-controller
  fpsDroppedMonitoringPeriod: 5000, // used by fps-controller
  fpsDroppedMonitoringThreshold: 0.2, // used by fps-controller
  appendErrorMaxRetry: 3, // used by buffer-controller
  loader: _xhrLoader2.default,
  // loader: FetchLoader,
  fLoader: undefined, // used by fragment-loader
  pLoader: undefined, // used by playlist-loader
  xhrSetup: undefined, // used by xhr-loader
  licenseXhrSetup: undefined, // used by eme-controller
  // fetchSetup: undefined,
  abrController: _abrController2.default,
  bufferController: _bufferController2.default,
  capLevelController: _capLevelController2.default,
  fpsController: _fpsController2.default,
  stretchShortVideoTrack: false, // used by mp4-remuxer
  maxAudioFramesDrift: 1, // used by mp4-remuxer
  forceKeyFrameOnDiscontinuity: true, // used by ts-demuxer
  abrEwmaFastLive: 3, // used by abr-controller
  abrEwmaSlowLive: 9, // used by abr-controller
  abrEwmaFastVoD: 3, // used by abr-controller
  abrEwmaSlowVoD: 9, // used by abr-controller
  abrEwmaDefaultEstimate: 5e5, // 500 kbps  // used by abr-controller
  abrBandWidthFactor: 0.95, // used by abr-controller
  abrBandWidthUpFactor: 0.7, // used by abr-controller
  abrMaxWithRealBitrate: false, // used by abr-controller
  maxStarvationDelay: 4, // used by abr-controller
  maxLoadingDelay: 4, // used by abr-controller
  minAutoBitrate: 0, // used by hls
  emeEnabled: false, // used by eme-controller
  widevineLicenseUrl: undefined, // used by eme-controller
  requestMediaKeySystemAccessFunc: _mediakeysHelper.requestMediaKeySystemAccess // used by eme-controller
}; /**
    * HLS config
    */

hlsDefaultConfig.subtitleStreamController = _subtitleStreamController.SubtitleStreamController;
hlsDefaultConfig.subtitleTrackController = _subtitleTrackController2.default;
hlsDefaultConfig.timelineController = _timelineController2.default;
hlsDefaultConfig.cueHandler = Cues; // used by timeline-controller
hlsDefaultConfig.enableCEA708Captions = true; // used by timeline-controller
hlsDefaultConfig.enableWebVTT = true; // used by timeline-controller
hlsDefaultConfig.captionsTextTrack1Label = 'English'; // used by timeline-controller
hlsDefaultConfig.captionsTextTrack1LanguageCode = 'en'; // used by timeline-controller
hlsDefaultConfig.captionsTextTrack2Label = 'Spanish'; // used by timeline-controller
hlsDefaultConfig.captionsTextTrack2LanguageCode = 'es'; // used by timeline-controller


hlsDefaultConfig.audioStreamController = _audioStreamController2.default;
hlsDefaultConfig.audioTrackController = _audioTrackController2.default;

hlsDefaultConfig.emeController = _emeController2.default;

/***/ }),

/***/ "./src/hls.js/controller/abr-controller.js":
/*!*************************************************!*\
  !*** ./src/hls.js/controller/abr-controller.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _ewmaBandwidthEstimator = __webpack_require__(/*! ../utils/ewma-bandwidth-estimator */ "./src/hls.js/utils/ewma-bandwidth-estimator.js");

var _ewmaBandwidthEstimator2 = _interopRequireDefault(_ewmaBandwidthEstimator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * simple ABR Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - compute next level based on last fragment bw heuristics
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _window = window,
    performance = _window.performance;

var AbrController = function (_EventHandler) {
  _inherits(AbrController, _EventHandler);

  function AbrController(hls) {
    _classCallCheck(this, AbrController);

    var _this = _possibleConstructorReturn(this, (AbrController.__proto__ || Object.getPrototypeOf(AbrController)).call(this, hls, _events2.default.FRAG_LOADING, _events2.default.FRAG_LOADED, _events2.default.FRAG_BUFFERED, _events2.default.ERROR));

    _this.lastLoadedFragLevel = 0;
    _this._nextAutoLevel = -1;
    _this.hls = hls;
    _this.timer = null;
    _this._bwEstimator = null;
    _this.onCheck = _this._abandonRulesCheck.bind(_this);
    return _this;
  }

  _createClass(AbrController, [{
    key: 'destroy',
    value: function destroy() {
      this.clearTimer();
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag;
      if (frag.type === 'main') {
        if (!this.timer) {
          this.fragCurrent = frag;
          this.timer = setInterval(this.onCheck, 100);
        }

        // lazy init of BwEstimator, rationale is that we use different params for Live/VoD
        // so we need to wait for stream manifest / playlist type to instantiate it.
        if (!this._bwEstimator) {
          var hls = this.hls;
          var config = hls.config;
          var level = frag.level;
          var isLive = hls.levels[level].details.live;

          var ewmaFast = void 0,
              ewmaSlow = void 0;
          if (isLive) {
            ewmaFast = config.abrEwmaFastLive;
            ewmaSlow = config.abrEwmaSlowLive;
          } else {
            ewmaFast = config.abrEwmaFastVoD;
            ewmaSlow = config.abrEwmaSlowVoD;
          }
          this._bwEstimator = new _ewmaBandwidthEstimator2.default(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);
        }
      }
    }
  }, {
    key: '_abandonRulesCheck',
    value: function _abandonRulesCheck() {
      /*
        monitor fragment retrieval time...
        we compute expected time of arrival of the complete fragment.
        we compare it to expected time of buffer starvation
      */
      var hls = this.hls;
      var video = hls.media;
      var frag = this.fragCurrent;

      if (!frag) {
        return;
      }

      var loader = frag.loader;
      var minAutoLevel = hls.minAutoLevel;

      // if loader has been destroyed or loading has been aborted, stop timer and return
      if (!loader || loader.stats && loader.stats.aborted) {
        _logger.logger.warn('frag loader destroy or aborted, disarm abandonRules');
        this.clearTimer();
        // reset forced auto level value so that next level will be selected
        this._nextAutoLevel = -1;
        return;
      }
      var stats = loader.stats;
      /* only monitor frag retrieval time if
      (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */
      if (video && stats && (!video.paused && video.playbackRate !== 0 || !video.readyState) && frag.autoLevel && frag.level) {
        var requestDelay = performance.now() - stats.trequest,
            playbackRate = Math.abs(video.playbackRate);
        // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
        if (requestDelay > 500 * frag.duration / playbackRate) {
          var levels = hls.levels,
              loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay),
              // byte/s; at least 1 byte/s to avoid division by zero
          // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size
          level = levels[frag.level],
              levelBitrate = level.realBitrate ? Math.max(level.realBitrate, level.bitrate) : level.bitrate,
              expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levelBitrate / 8)),
              pos = video.currentTime,
              fragLoadedDelay = (expectedLen - stats.loaded) / loadRate,
              bufferStarvationDelay = (_bufferHelper.BufferHelper.bufferInfo(video, pos, hls.config.maxBufferHole).end - pos) / playbackRate;
          // consider emergency switch down only if we have less than 2 frag buffered AND
          // time to finish loading current fragment is bigger than buffer starvation delay
          // ie if we risk buffer starvation if bw does not increase quickly
          if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) {
            var fragLevelNextLoadedDelay = void 0,
                nextLoadLevel = void 0;
            // lets iterate through lower level and try to find the biggest one that could avoid rebuffering
            // we start from current level - 1 and we step down , until we find a matching level
            for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
              // compute time to load next fragment at lower level
              // 0.8 : consider only 80% of current bw to be conservative
              // 8 = bits per byte (bps/Bps)
              var levelNextBitrate = levels[nextLoadLevel].realBitrate ? Math.max(levels[nextLoadLevel].realBitrate, levels[nextLoadLevel].bitrate) : levels[nextLoadLevel].bitrate;
              fragLevelNextLoadedDelay = frag.duration * levelNextBitrate / (8 * 0.8 * loadRate);
              if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
                // we found a lower level that be rebuffering free with current estimated bw !
                break;
              }
            }
            // only emergency switch down if it takes less time to load new fragment at lowest level instead
            // of finishing loading current one ...
            if (fragLevelNextLoadedDelay < fragLoadedDelay) {
              _logger.logger.warn('loading too slow, abort fragment loading and switch to level ' + nextLoadLevel + ':fragLoadedDelay[' + nextLoadLevel + ']<fragLoadedDelay[' + (frag.level - 1) + '];bufferStarvationDelay:' + fragLevelNextLoadedDelay.toFixed(1) + '<' + fragLoadedDelay.toFixed(1) + ':' + bufferStarvationDelay.toFixed(1));
              // force next load level in auto mode
              hls.nextLoadLevel = nextLoadLevel;
              // update bw estimate for this fragment before cancelling load (this will help reducing the bw)
              this._bwEstimator.sample(requestDelay, stats.loaded);
              // abort fragment loading
              loader.abort();
              // stop abandon rules timer
              this.clearTimer();
              hls.trigger(_events2.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag, stats: stats });
            }
          }
        }
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var frag = data.frag;
      if (frag.type === 'main' && Number.isFinite(frag.sn)) {
        // stop monitoring bw once frag loaded
        this.clearTimer();
        // store level id after successful fragment load
        this.lastLoadedFragLevel = frag.level;
        // reset forced auto level value so that next level will be selected
        this._nextAutoLevel = -1;

        // compute level average bitrate
        if (this.hls.config.abrMaxWithRealBitrate) {
          var level = this.hls.levels[frag.level];
          var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + data.stats.loaded;
          var loadedDuration = (level.loaded ? level.loaded.duration : 0) + data.frag.duration;
          level.loaded = { bytes: loadedBytes, duration: loadedDuration };
          level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
        }
        // if fragment has been loaded to perform a bitrate test,
        if (data.frag.bitrateTest) {
          var stats = data.stats;
          stats.tparsed = stats.tbuffered = stats.tload;
          this.onFragBuffered(data);
        }
      }
    }
  }, {
    key: 'onFragBuffered',
    value: function onFragBuffered(data) {
      var stats = data.stats;
      var frag = data.frag;
      // only update stats on first frag buffering
      // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
      // and leading to wrong bw estimation
      // on bitrate test, also only update stats once (if tload = tbuffered == on FRAG_LOADED)
      if (stats.aborted !== true && frag.type === 'main' && Number.isFinite(frag.sn) && (!frag.bitrateTest || stats.tload === stats.tbuffered)) {
        // use tparsed-trequest instead of tbuffered-trequest to compute fragLoadingProcessing; rationale is that  buffer appending only happens once media is attached
        // in case we use config.startFragPrefetch while media is not attached yet, fragment might be parsed while media not attached yet, but it will only be buffered on media attached
        // as a consequence it could happen really late in the process. meaning that appending duration might appears huge ... leading to underestimated throughput estimation
        var fragLoadingProcessingMs = stats.tparsed - stats.trequest;
        _logger.logger.log('latency/loading/parsing/append/kbps:' + Math.round(stats.tfirst - stats.trequest) + '/' + Math.round(stats.tload - stats.tfirst) + '/' + Math.round(stats.tparsed - stats.tload) + '/' + Math.round(stats.tbuffered - stats.tparsed) + '/' + Math.round(8 * stats.loaded / (stats.tbuffered - stats.trequest)));
        this._bwEstimator.sample(fragLoadingProcessingMs, stats.loaded);
        stats.bwEstimate = this._bwEstimator.getEstimate();
        // if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration
        if (frag.bitrateTest) {
          this.bitrateTestDelay = fragLoadingProcessingMs / 1000;
        } else {
          this.bitrateTestDelay = 0;
        }
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      // stop timer in case of frag loading error
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          this.clearTimer();
          break;
        default:
          break;
      }
    }
  }, {
    key: 'clearTimer',
    value: function clearTimer() {
      clearInterval(this.timer);
      this.timer = null;
    }

    // return next auto level

  }, {
    key: '_findBestLevel',
    value: function _findBestLevel(currentLevel, currentFragDuration, currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor, levels) {
      for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
        var levelInfo = levels[i];

        if (!levelInfo) {
          continue;
        }

        var levelDetails = levelInfo.details,
            avgDuration = levelDetails ? levelDetails.totalduration / levelDetails.fragments.length : currentFragDuration,
            live = levelDetails ? levelDetails.live : false,
            adjustedbw = void 0;
        // follow algorithm captured from stagefright :
        // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
        // Pick the highest bandwidth stream below or equal to estimated bandwidth.
        // consider only 80% of the available bandwidth, but if we are switching up,
        // be even more conservative (70%) to avoid overestimating and immediately
        // switching back.
        if (i <= currentLevel) {
          adjustedbw = bwFactor * currentBw;
        } else {
          adjustedbw = bwUpFactor * currentBw;
        }

        var bitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate,
            fetchDuration = bitrate * avgDuration / adjustedbw;

        _logger.logger.trace('level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: ' + i + '/' + Math.round(adjustedbw) + '/' + bitrate + '/' + avgDuration + '/' + maxFetchDuration + '/' + fetchDuration);
        // if adjusted bw is greater than level bitrate AND
        if (adjustedbw > bitrate && (
        // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
        // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
        // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that _findBestLevel will return -1
        !fetchDuration || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {
          // as we are looping from highest to lowest, this will return the best achievable quality level
          return i;
        }
      }
      // not enough time budget even with quality level 0 ... rebuffering might happen
      return -1;
    }
  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var forcedAutoLevel = this._nextAutoLevel;
      var bwEstimator = this._bwEstimator;
      // in case next auto level has been forced, and bw not available or not reliable, return forced value
      if (forcedAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {
        return forcedAutoLevel;
      }

      // compute next level using ABR logic
      var nextABRAutoLevel = this._nextABRAutoLevel;
      // if forced auto level has been defined, use it to cap ABR computed quality level
      if (forcedAutoLevel !== -1) {
        nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);
      }

      return nextABRAutoLevel;
    },
    set: function set(nextLevel) {
      this._nextAutoLevel = nextLevel;
    }
  }, {
    key: '_nextABRAutoLevel',
    get: function get() {
      var hls = this.hls,
          maxAutoLevel = hls.maxAutoLevel,
          levels = hls.levels,
          config = hls.config,
          minAutoLevel = hls.minAutoLevel;
      var video = hls.media,
          currentLevel = this.lastLoadedFragLevel,
          currentFragDuration = this.fragCurrent ? this.fragCurrent.duration : 0,
          pos = video ? video.currentTime : 0,

      // playbackRate is the absolute value of the playback rate; if video.playbackRate is 0, we use 1 to load as
      // if we're playing back at the normal rate.
      playbackRate = video && video.playbackRate !== 0 ? Math.abs(video.playbackRate) : 1.0,
          avgbw = this._bwEstimator ? this._bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate,

      // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.
      bufferStarvationDelay = (_bufferHelper.BufferHelper.bufferInfo(video, pos, config.maxBufferHole).end - pos) / playbackRate;

      // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all
      var bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);
      if (bestLevel >= 0) {
        return bestLevel;
      } else {
        _logger.logger.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering');
        // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering
        // if no matching level found, logic will return 0
        var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay,
            bwFactor = config.abrBandWidthFactor,
            bwUpFactor = config.abrBandWidthUpFactor;
        if (bufferStarvationDelay === 0) {
          // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
          var bitrateTestDelay = this.bitrateTestDelay;
          if (bitrateTestDelay) {
            // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
            // max video loading delay used in  automatic start level selection :
            // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
            // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
            // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration
            var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
            maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
            _logger.logger.trace('bitrate test took ' + Math.round(1000 * bitrateTestDelay) + 'ms, set first fragment max fetchDuration to ' + Math.round(1000 * maxStarvationDelay) + ' ms');
            // don't use conservative factor on bitrate test
            bwFactor = bwUpFactor = 1;
          }
        }
        bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor, levels);
        return Math.max(bestLevel, 0);
      }
    }
  }]);

  return AbrController;
}(_eventHandler2.default);

exports.default = AbrController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/audio-stream-controller.js":
/*!**********************************************************!*\
  !*** ./src/hls.js/controller/audio-stream-controller.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _binarySearch = __webpack_require__(/*! ../utils/binary-search */ "./src/hls.js/utils/binary-search.js");

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _demuxer = __webpack_require__(/*! ../demux/demuxer */ "./src/hls.js/demux/demuxer.js");

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

var LevelHelper = _interopRequireWildcard(_levelHelper);

var _timeRanges = __webpack_require__(/*! ../utils/time-ranges */ "./src/hls.js/utils/time-ranges.js");

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _discontinuities = __webpack_require__(/*! ../utils/discontinuities */ "./src/hls.js/utils/discontinuities.js");

var _fragmentTracker = __webpack_require__(/*! ./fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _fragment = __webpack_require__(/*! ../loader/fragment */ "./src/hls.js/loader/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _baseStreamController = __webpack_require__(/*! ./base-stream-controller */ "./src/hls.js/controller/base-stream-controller.js");

var _baseStreamController2 = _interopRequireDefault(_baseStreamController);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Audio Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var _window = window,
    performance = _window.performance;


var TICK_INTERVAL = 100; // how often to tick in ms

var AudioStreamController = function (_BaseStreamController) {
  _inherits(AudioStreamController, _BaseStreamController);

  function AudioStreamController(hls, fragmentTracker) {
    _classCallCheck(this, AudioStreamController);

    var _this = _possibleConstructorReturn(this, (AudioStreamController.__proto__ || Object.getPrototypeOf(AudioStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.AUDIO_TRACKS_UPDATED, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.BUFFER_RESET, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED, _events2.default.INIT_PTS_FOUND));

    _this.fragmentTracker = fragmentTracker;
    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this._state = _baseStreamController.State.STOPPED;
    _this.initPTS = [];
    _this.waitingFragment = null;
    _this.videoTrackCC = null;
    return _this;
  }

  // Signal that video PTS was found


  _createClass(AudioStreamController, [{
    key: 'onInitPtsFound',
    value: function onInitPtsFound(data) {
      var demuxerId = data.id,
          cc = data.frag.cc,
          initPTS = data.initPTS;
      if (demuxerId === 'main') {
        // Always update the new INIT PTS
        // Can change due level switch
        this.initPTS[cc] = initPTS;
        this.videoTrackCC = cc;
        _logger.logger.log('InitPTS for cc: ' + cc + ' found from video track: ' + initPTS);

        // If we are waiting we need to demux/remux the waiting frag
        // With the new initPTS
        if (this.state === _baseStreamController.State.WAITING_INIT_PTS) {
          this.tick();
        }
      }
    }
  }, {
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.tracks) {
        var lastCurrentTime = this.lastCurrentTime;
        this.stopLoad();
        this.setInterval(TICK_INTERVAL);
        this.fragLoadError = 0;
        if (lastCurrentTime > 0 && startPosition === -1) {
          _logger.logger.log('audio:override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
          this.state = _baseStreamController.State.IDLE;
        } else {
          this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
          this.state = _baseStreamController.State.STARTING;
        }
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
        this.tick();
      } else {
        this.startPosition = startPosition;
        this.state = _baseStreamController.State.STOPPED;
      }
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      var pos = void 0,
          track = void 0,
          trackDetails = void 0,
          hls = this.hls,
          config = hls.config;
      // logger.log('audioStream:' + this.state);
      switch (this.state) {
        case _baseStreamController.State.ERROR:
        // don't do anything in error state to avoid breaking further ...
        case _baseStreamController.State.PAUSED:
        // don't do anything in paused state either ...
        case _baseStreamController.State.BUFFER_FLUSHING:
          break;
        case _baseStreamController.State.STARTING:
          this.state = _baseStreamController.State.WAITING_TRACK;
          this.loadedmetadata = false;
          break;
        case _baseStreamController.State.IDLE:
          var tracks = this.tracks;
          // audio tracks not received => exit loop
          if (!tracks) {
            break;
          }

          // if video not attached AND
          // start fragment already requested OR start frag prefetch disable
          // exit loop
          // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
          if (!this.media && (this.startFragRequested || !config.startFragPrefetch)) {
            break;
          }

          // determine next candidate fragment to be loaded, based on current position and
          //  end of buffer position
          // if we have not yet loaded any fragment, start loading from start position
          if (this.loadedmetadata) {
            pos = this.media.currentTime;
          } else {
            pos = this.nextLoadPosition;
            if (pos === undefined) {
              break;
            }
          }
          var media = this.mediaBuffer ? this.mediaBuffer : this.media,
              videoBuffer = this.videoBuffer ? this.videoBuffer : this.media,
              bufferInfo = _bufferHelper.BufferHelper.bufferInfo(media, pos, config.maxBufferHole),
              mainBufferInfo = _bufferHelper.BufferHelper.bufferInfo(videoBuffer, pos, config.maxBufferHole),
              bufferLen = bufferInfo.len,
              bufferEnd = bufferInfo.end,
              fragPrevious = this.fragPrevious,

          // ensure we buffer at least config.maxBufferLength (default 30s) or config.maxMaxBufferLength (default: 600s)
          // whichever is smaller.
          // once we reach that threshold, don't buffer more than video (mainBufferInfo.len)
          maxConfigBuffer = Math.min(config.maxBufferLength, config.maxMaxBufferLength),
              maxBufLen = Math.max(maxConfigBuffer, mainBufferInfo.len),
              audioSwitch = this.audioSwitch,
              trackId = this.trackId;

          // if buffer length is less than maxBufLen try to load a new fragment
          if ((bufferLen < maxBufLen || audioSwitch) && trackId < tracks.length) {
            trackDetails = tracks[trackId].details;
            // if track info not retrieved yet, switch state and wait for track retrieval
            if (typeof trackDetails === 'undefined') {
              this.state = _baseStreamController.State.WAITING_TRACK;
              break;
            }

            if (!audioSwitch && this._streamEnded(bufferInfo, trackDetails)) {
              this.hls.trigger(_events2.default.BUFFER_EOS, { type: 'audio' });
              this.state = _baseStreamController.State.ENDED;
              return;
            }

            // find fragment index, contiguous with end of buffer position
            var fragments = trackDetails.fragments,
                fragLen = fragments.length,
                start = fragments[0].start,
                end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
                frag = void 0;

            // When switching audio track, reload audio as close as possible to currentTime
            if (audioSwitch) {
              if (trackDetails.live && !trackDetails.PTSKnown) {
                _logger.logger.log('switching audiotrack, live stream, unknown PTS,load first fragment');
                bufferEnd = 0;
              } else {
                bufferEnd = pos;
                // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime
                if (trackDetails.PTSKnown && pos < start) {
                  // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start
                  if (bufferInfo.end > start || bufferInfo.nextStart) {
                    _logger.logger.log('alt audio track ahead of main track, seek to start of alt audio track');
                    this.media.currentTime = start + 0.05;
                  } else {
                    return;
                  }
                }
              }
            }
            if (trackDetails.initSegment && !trackDetails.initSegment.data) {
              frag = trackDetails.initSegment;
            } // eslint-disable-line brace-style
            // if bufferEnd before start of playlist, load first fragment
            else if (bufferEnd <= start) {
                frag = fragments[0];
                if (this.videoTrackCC !== null && frag.cc !== this.videoTrackCC) {
                  // Ensure we find a fragment which matches the continuity of the video track
                  frag = (0, _discontinuities.findFragWithCC)(fragments, this.videoTrackCC);
                }
                if (trackDetails.live && frag.loadIdx && frag.loadIdx === this.fragLoadIdx) {
                  // we just loaded this first fragment, and we are still lagging behind the start of the live playlist
                  // let's force seek to start
                  var nextBuffered = bufferInfo.nextStart ? bufferInfo.nextStart : start;
                  _logger.logger.log('no alt audio available @currentTime:' + this.media.currentTime + ', seeking @' + (nextBuffered + 0.05));
                  this.media.currentTime = nextBuffered + 0.05;
                  return;
                }
              } else {
                var foundFrag = void 0;
                var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;
                var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {
                  // offset should be within fragment boundary - config.maxFragLookUpTolerance
                  // this is to cope with situations like
                  // bufferEnd = 9.991
                  // frag[Ø] : [0,10]
                  // frag[1] : [10,20]
                  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
                  //              frag start               frag start+duration
                  //                  |-----------------------------|
                  //              <--->                         <--->
                  //  ...--------><-----------------------------><---------....
                  // previous frag         matching fragment         next frag
                  //  return -1             return 0                 return 1
                  // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
                  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
                  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);
                  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
                    return 1;
                  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
                    // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
                    return -1;
                  }

                  return 0;
                };

                if (bufferEnd < end) {
                  if (bufferEnd > end - maxFragLookUpTolerance) {
                    maxFragLookUpTolerance = 0;
                  }

                  // Prefer the next fragment if it's within tolerance
                  if (fragNext && !fragmentWithinToleranceTest(fragNext)) {
                    foundFrag = fragNext;
                  } else {
                    foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);
                  }
                } else {
                  // reach end of playlist
                  foundFrag = fragments[fragLen - 1];
                }
                if (foundFrag) {
                  frag = foundFrag;
                  start = foundFrag.start;
                  // logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
                  if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
                    if (frag.sn < trackDetails.endSN) {
                      frag = fragments[frag.sn + 1 - trackDetails.startSN];
                      _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
                    } else {
                      frag = null;
                    }
                  }
                }
              }
            if (frag) {
              // logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
              if (frag.encrypted) {
                _logger.logger.log('Loading key for ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId);
                this.state = _baseStreamController.State.KEY_LOADING;
                hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
              } else {
                _logger.logger.log('Loading ' + frag.sn + ', cc: ' + frag.cc + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));
                // only load if fragment is not loaded or if in audio switch
                // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch
                this.fragCurrent = frag;
                if (audioSwitch || this.fragmentTracker.getState(frag) === _fragmentTracker.FragmentState.NOT_LOADED) {
                  this.startFragRequested = true;
                  if (Number.isFinite(frag.sn)) {
                    this.nextLoadPosition = frag.start + frag.duration;
                  }

                  hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
                  this.state = _baseStreamController.State.FRAG_LOADING;
                }
              }
            }
          }
          break;
        case _baseStreamController.State.WAITING_TRACK:
          track = this.tracks[this.trackId];
          // check if playlist is already loaded
          if (track && track.details) {
            this.state = _baseStreamController.State.IDLE;
          }

          break;
        case _baseStreamController.State.FRAG_LOADING_WAITING_RETRY:
          var now = performance.now();
          var retryDate = this.retryDate;
          media = this.media;
          var isSeeking = media && media.seeking;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || isSeeking) {
            _logger.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');
            this.state = _baseStreamController.State.IDLE;
          }
          break;
        case _baseStreamController.State.WAITING_INIT_PTS:
          var videoTrackCC = this.videoTrackCC;
          if (this.initPTS[videoTrackCC] === undefined) {
            break;
          }

          // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS
          var waitingFrag = this.waitingFragment;
          if (waitingFrag) {
            var waitingFragCC = waitingFrag.frag.cc;
            if (videoTrackCC !== waitingFragCC) {
              track = this.tracks[this.trackId];
              if (track.details && track.details.live) {
                _logger.logger.warn('Waiting fragment CC (' + waitingFragCC + ') does not match video track CC (' + videoTrackCC + ')');
                this.waitingFragment = null;
                this.state = _baseStreamController.State.IDLE;
              }
            } else {
              this.state = _baseStreamController.State.FRAG_LOADING;
              this.onFragLoaded(this.waitingFragment);
              this.waitingFragment = null;
            }
          } else {
            this.state = _baseStreamController.State.IDLE;
          }

          break;
        case _baseStreamController.State.STOPPED:
        case _baseStreamController.State.FRAG_LOADING:
        case _baseStreamController.State.PARSING:
        case _baseStreamController.State.PARSED:
        case _baseStreamController.State.ENDED:
          break;
        default:
          break;
      }
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.tracks && config.autoStartLoad) {
        this.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = this.mediaBuffer = this.videoBuffer = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onAudioTracksUpdated',
    value: function onAudioTracksUpdated(data) {
      _logger.logger.log('audio tracks updated');
      this.tracks = data.audioTracks;
    }
  }, {
    key: 'onAudioTrackSwitching',
    value: function onAudioTrackSwitching(data) {
      // if any URL found on new audio track, it is an alternate audio track
      var altAudio = !!data.url;
      this.trackId = data.id;

      this.fragCurrent = null;
      this.state = _baseStreamController.State.PAUSED;
      this.waitingFragment = null;
      // destroy useless demuxer when switching audio to main
      if (!altAudio) {
        if (this.demuxer) {
          this.demuxer.destroy();
          this.demuxer = null;
        }
      } else {
        // switching to audio track, start timer if not already started
        this.setInterval(TICK_INTERVAL);
      }

      // should we switch tracks ?
      if (altAudio) {
        this.audioSwitch = true;
        // main audio track are handled by stream-controller, just do something if switching to alt audio track
        this.state = _baseStreamController.State.IDLE;
      }
      this.tick();
    }
  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      var newDetails = data.details,
          trackId = data.id,
          track = this.tracks[trackId],
          duration = newDetails.totalduration,
          sliding = 0;

      _logger.logger.log('track ' + trackId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);

      if (newDetails.live) {
        var curDetails = track.details;
        if (curDetails && newDetails.fragments.length > 0) {
          // we already have details for that level, merge them
          LevelHelper.mergeDetails(curDetails, newDetails);
          sliding = newDetails.fragments[0].start;
          // TODO
          // this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
          if (newDetails.PTSKnown) {
            _logger.logger.log('live audio playlist sliding:' + sliding.toFixed(3));
          } else {
            _logger.logger.log('live audio playlist - outdated PTS, unknown sliding');
          }
        } else {
          newDetails.PTSKnown = false;
          _logger.logger.log('live audio playlist - first load, unknown sliding');
        }
      } else {
        newDetails.PTSKnown = false;
      }
      track.details = newDetails;

      // compute start position
      if (!this.startFragRequested) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = newDetails.startTimeOffset;
          if (Number.isFinite(startTimeOffset)) {
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            this.startPosition = 0;
          }
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment
      if (this.state === _baseStreamController.State.WAITING_TRACK) {
        this.state = _baseStreamController.State.IDLE;
      }

      // trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === _baseStreamController.State.KEY_LOADING) {
        this.state = _baseStreamController.State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent,
          fragLoaded = data.frag;
      if (this.state === _baseStreamController.State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'audio' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
        var track = this.tracks[this.trackId],
            details = track.details,
            duration = details.totalduration,
            trackId = fragCurrent.level,
            sn = fragCurrent.sn,
            cc = fragCurrent.cc,
            audioCodec = this.config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2',
            stats = this.stats = data.stats;
        if (sn === 'initSegment') {
          this.state = _baseStreamController.State.IDLE;

          stats.tparsed = stats.tbuffered = performance.now();
          details.initSegment.data = data.payload;
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'audio' });
          this.tick();
        } else {
          this.state = _baseStreamController.State.PARSING;
          // transmux the MPEG-TS data to ISO-BMFF segments
          this.appended = false;
          if (!this.demuxer) {
            this.demuxer = new _demuxer2.default(this.hls, 'audio');
          }

          // Check if we have video initPTS
          // If not we need to wait for it
          var initPTS = this.initPTS[cc];
          var initSegmentData = details.initSegment ? details.initSegment.data : [];
          if (details.initSegment || initPTS !== undefined) {
            this.pendingBuffering = true;
            _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
            // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
            var accurateTimeOffset = false; // details.PTSKnown || !details.live;
            this.demuxer.push(data.payload, initSegmentData, audioCodec, null, fragCurrent, duration, accurateTimeOffset, initPTS);
          } else {
            _logger.logger.log('unknown video PTS for continuity counter ' + cc + ', waiting for video PTS before demuxing audio frag ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
            this.waitingFragment = data;
            this.state = _baseStreamController.State.WAITING_INIT_PTS;
          }
        }
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === _baseStreamController.State.PARSING) {
        var tracks = data.tracks,
            track = void 0;

        // delete any video track found on audio demuxer
        if (tracks.video) {
          delete tracks.video;
        }

        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          track.levelCodec = track.codec;
          track.id = data.id;
          this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
          _logger.logger.log('audio track:audio,container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            var appendObj = { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' };
            if (this.audioSwitch) {
              this.pendingData = [appendObj];
            } else {
              this.appended = true;
              // arm pending Buffering flag before appending a segment
              this.pendingBuffering = true;
              this.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
            }
          }
          // trigger handler right now
          this.tick();
        }
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'audio' && data.type === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === _baseStreamController.State.PARSING) {
        var trackId = this.trackId,
            track = this.tracks[trackId],
            hls = this.hls;

        if (!Number.isFinite(data.endPTS)) {
          data.endPTS = data.startPTS + fragCurrent.duration;
          data.endDTS = data.startDTS + fragCurrent.duration;
        }

        fragCurrent.addElementaryStream(_fragment2.default.ElementaryStreamTypes.AUDIO);

        _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb);
        LevelHelper.updateFragPTSDTS(track.details, fragCurrent, data.startPTS, data.endPTS);

        var audioSwitch = this.audioSwitch,
            media = this.media,
            appendOnBufferFlush = false;
        // Only flush audio from old audio tracks when PTS is known on new audio track
        if (audioSwitch && media) {
          if (media.readyState) {
            var currentTime = media.currentTime;
            _logger.logger.log('switching audio track : currentTime:' + currentTime);
            if (currentTime >= data.startPTS) {
              _logger.logger.log('switching audio track : flushing all audio');
              this.state = _baseStreamController.State.BUFFER_FLUSHING;
              hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
              appendOnBufferFlush = true;
              // Lets announce that the initial audio track switch flush occur
              this.audioSwitch = false;
              hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
            }
          } else {
            // Lets announce that the initial audio track switch flush occur
            this.audioSwitch = false;
            hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
          }
        }

        var pendingData = this.pendingData;

        if (!pendingData) {
          _logger.logger.warn('Apparently attempt to enqueue media payload without codec initialization data upfront');
          hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: null, fatal: true });
          return;
        }

        if (!this.audioSwitch) {
          [data.data1, data.data2].forEach(function (buffer) {
            if (buffer && buffer.length) {
              pendingData.push({ type: data.type, data: buffer, parent: 'audio', content: 'data' });
            }
          });
          if (!appendOnBufferFlush && pendingData.length) {
            pendingData.forEach(function (appendObj) {
              // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
              // in that case it is useless to append following segments
              if (_this2.state === _baseStreamController.State.PARSING) {
                // arm pending Buffering flag before appending a segment
                _this2.pendingBuffering = true;
                _this2.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
              }
            });
            this.pendingData = [];
            this.appended = true;
          }
        }
        // trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === _baseStreamController.State.PARSING) {
        this.stats.tparsed = performance.now();
        this.state = _baseStreamController.State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onBufferReset',
    value: function onBufferReset() {
      // reset reference to sourcebuffers
      this.mediaBuffer = this.videoBuffer = null;
      this.loadedmetadata = false;
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var audioTrack = data.tracks.audio;
      if (audioTrack) {
        this.mediaBuffer = audioTrack.buffer;
        this.loadedmetadata = true;
      }
      if (data.tracks.video) {
        this.videoBuffer = data.tracks.video.buffer;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'audio') {
        var state = this.state;
        if (state === _baseStreamController.State.PARSING || state === _baseStreamController.State.PARSED) {
          // check if all buffers have been appended
          this.pendingBuffering = data.pending > 0;
          this._checkAppendedParsed();
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      // trigger handler right now
      if (this.state === _baseStreamController.State.PARSED && (!this.appended || !this.pendingBuffering)) {
        var frag = this.fragCurrent,
            stats = this.stats,
            hls = this.hls;
        if (frag) {
          this.fragPrevious = frag;
          stats.tbuffered = performance.now();
          hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('audio buffered : ' + _timeRanges2.default.toString(media.buffered));
          if (this.audioSwitch && this.appended) {
            this.audioSwitch = false;
            hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: this.trackId });
          }
          this.state = _baseStreamController.State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle frag error not related to audio fragment
      if (frag && frag.type !== 'audio') {
        return;
      }

      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
          var _frag = data.frag;
          // don't handle frag error not related to audio fragment
          if (_frag && _frag.type !== 'audio') {
            break;
          }

          if (!data.fatal) {
            var loadError = this.fragLoadError;
            if (loadError) {
              loadError++;
            } else {
              loadError = 1;
            }

            var config = this.config;
            if (loadError <= config.fragLoadingMaxRetry) {
              this.fragLoadError = loadError;
              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
              _logger.logger.warn('AudioStreamController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = performance.now() + delay;
              // retry loading state
              this.state = _baseStreamController.State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('AudioStreamController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // switch error to fatal
              data.fatal = true;
              this.state = _baseStreamController.State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
        case _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
          if (this.state !== _baseStreamController.State.ERROR) {
            // if fatal error, stop processing, otherwise move to IDLE to retry loading
            this.state = data.fatal ? _baseStreamController.State.ERROR : _baseStreamController.State.IDLE;
            _logger.logger.warn('AudioStreamController: ' + data.details + ' while loading frag, now switching to ' + this.state + ' state ...');
          }
          break;
        case _errors.ErrorDetails.BUFFER_FULL_ERROR:
          // if in appending state
          if (data.parent === 'audio' && (this.state === _baseStreamController.State.PARSING || this.state === _baseStreamController.State.PARSED)) {
            var media = this.mediaBuffer,
                currentTime = this.media.currentTime,
                mediaBuffered = media && _bufferHelper.BufferHelper.isBuffered(media, currentTime) && _bufferHelper.BufferHelper.isBuffered(media, currentTime + 0.5);
            // reduce max buf len if current position is buffered
            if (mediaBuffered) {
              var _config = this.config;
              if (_config.maxMaxBufferLength >= _config.maxBufferLength) {
                // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
                _config.maxMaxBufferLength /= 2;
                _logger.logger.warn('AudioStreamController: reduce max buffer length to ' + _config.maxMaxBufferLength + 's');
              }
              this.state = _baseStreamController.State.IDLE;
            } else {
              // current position is not buffered, but browser is still complaining about buffer full error
              // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
              // in that case flush the whole audio buffer to recover
              _logger.logger.warn('AudioStreamController: buffer full error also media.currentTime is not buffered, flush audio buffer');
              this.fragCurrent = null;
              // flush everything
              this.state = _baseStreamController.State.BUFFER_FLUSHING;
              this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
            }
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      var _this3 = this;

      var pendingData = this.pendingData;
      if (pendingData && pendingData.length) {
        _logger.logger.log('AudioStreamController: appending pending audio data after buffer flushed');
        pendingData.forEach(function (appendObj) {
          _this3.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
        });
        this.appended = true;
        this.pendingData = [];
        this.state = _baseStreamController.State.PARSED;
      } else {
        // move to IDLE once flush complete. this should trigger new fragment loading
        this.state = _baseStreamController.State.IDLE;
        // reset reference to frag
        this.fragPrevious = null;
        this.tick();
      }
    }
  }, {
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        _logger.logger.log('audio stream:' + previousState + '->' + nextState);
      }
    },
    get: function get() {
      return this._state;
    }
  }]);

  return AudioStreamController;
}(_baseStreamController2.default);

exports.default = AudioStreamController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/audio-track-controller.js":
/*!*********************************************************!*\
  !*** ./src/hls.js/controller/audio-track-controller.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _taskLoop = __webpack_require__(/*! ../task-loop */ "./src/hls.js/task-loop.js");

var _taskLoop2 = _interopRequireDefault(_taskLoop);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class AudioTrackController
 * @implements {EventHandler}
 *
 * Handles main manifest and audio-track metadata loaded,
 * owns and exposes the selectable audio-tracks data-models.
 *
 * Exposes internal interface to select available audio-tracks.
 *
 * Handles errors on loading audio-track playlists. Manages fallback mechanism
 * with redundants tracks (group-IDs).
 *
 * Handles level-loading and group-ID switches for video (fallback on video levels),
 * and eventually adapts the audio-track group-ID to match.
 *
 * @fires AUDIO_TRACK_LOADING
 * @fires AUDIO_TRACK_SWITCHING
 * @fires AUDIO_TRACKS_UPDATED
 * @fires ERROR
 *
 */
var AudioTrackController = function (_TaskLoop) {
  _inherits(AudioTrackController, _TaskLoop);

  function AudioTrackController(hls) {
    _classCallCheck(this, AudioTrackController);

    /**
     * @private
     * Currently selected index in `tracks`
     * @member {number} trackId
     */
    var _this = _possibleConstructorReturn(this, (AudioTrackController.__proto__ || Object.getPrototypeOf(AudioTrackController)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.AUDIO_TRACK_LOADED, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.LEVEL_LOADED, _events2.default.ERROR));

    _this._trackId = -1;

    /**
     * @private
     * If should select tracks according to default track attribute
     * @member {boolean} _selectDefaultTrack
     */
    _this._selectDefaultTrack = true;

    /**
     * @public
     * All tracks available
     * @member {AudioTrack[]}
     */
    _this.tracks = [];

    /**
     * @public
     * List of blacklisted audio track IDs (that have caused failure)
     * @member {number[]}
     */
    _this.trackIdBlacklist = Object.create(null);

    /**
     * @public
     * The currently running group ID for audio
     * (we grab this on manifest-parsed and new level-loaded)
     * @member {string}
     */
    _this.audioGroupId = null;
    return _this;
  }

  /**
   * Reset audio tracks on new manifest loading.
   */


  _createClass(AudioTrackController, [{
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.tracks = [];
      this._trackId = -1;
      this._selectDefaultTrack = true;
    }

    /**
     * Store tracks data from manifest parsed data.
     *
     * Trigger AUDIO_TRACKS_UPDATED event.
     *
     * @param {*} data
     */

  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var tracks = this.tracks = data.audioTracks || [];
      this.hls.trigger(_events2.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks });
    }

    /**
     * Store track details of loaded track in our data-model.
     *
     * Set-up metadata update interval task for live-mode streams.
     *
     * @param {} data
     */

  }, {
    key: 'onAudioTrackLoaded',
    value: function onAudioTrackLoaded(data) {
      if (data.id >= this.tracks.length) {
        _logger.logger.warn('Invalid audio track id:', data.id);
        return;
      }

      _logger.logger.log('audioTrack ' + data.id + ' loaded');

      this.tracks[data.id].details = data.details;

      // check if current playlist is a live playlist
      // and if we have already our reload interval setup
      if (data.details.live && !this.hasInterval()) {
        // if live playlist we will have to reload it periodically
        // set reload period to playlist target duration
        var updatePeriodMs = data.details.targetduration * 1000;
        this.setInterval(updatePeriodMs);
      }

      if (!data.details.live && this.hasInterval()) {
        // playlist is not live and timer is scheduled: cancel it
        this.clearInterval();
      }
    }

    /**
     * Update the internal group ID to any audio-track we may have set manually
     * or because of a failure-handling fallback.
     *
     * Quality-levels should update to that group ID in this case.
     *
     * @param {*} data
     */

  }, {
    key: 'onAudioTrackSwitched',
    value: function onAudioTrackSwitched(data) {
      var audioGroupId = this.tracks[data.id].groupId;
      if (audioGroupId && this.audioGroupId !== audioGroupId) {
        this.audioGroupId = audioGroupId;
      }
    }

    /**
     * When a level gets loaded, if it has redundant audioGroupIds (in the same ordinality as it's redundant URLs)
     * we are setting our audio-group ID internally to the one set, if it is different from the group ID currently set.
     *
     * If group-ID got update, we re-select the appropriate audio-track with this group-ID matching the currently
     * selected one (based on NAME property).
     *
     * @param {*} data
     */

  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      // FIXME: crashes because currentLevel is undefined
      // const levelInfo = this.hls.levels[this.hls.currentLevel];

      var levelInfo = this.hls.levels[data.level];

      if (!levelInfo.audioGroupIds) {
        return;
      }

      var audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];
      if (this.audioGroupId !== audioGroupId) {
        this.audioGroupId = audioGroupId;
        this._selectInitialAudioTrack();
      }
    }

    /**
     * Handle network errors loading audio track manifests
     * and also pausing on any netwok errors.
     *
     * @param {ErrorEventData} data
     */

  }, {
    key: 'onError',
    value: function onError(data) {
      // Only handle network errors
      if (data.type !== _errors.ErrorTypes.NETWORK_ERROR) {
        return;
      }

      // If fatal network error, cancel update task
      if (data.fatal) {
        this.clearInterval();
      }

      // If not an audio-track loading error don't handle further
      if (data.details !== _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR) {
        return;
      }

      _logger.logger.warn('Network failure on audio-track id:', data.context.id);
      this._handleLoadError();
    }

    /**
     * @type {AudioTrack[]} Audio-track list we own
     */

  }, {
    key: '_setAudioTrack',


    /**
     * @private
     * @param {number} newId
     */
    value: function _setAudioTrack(newId) {
      // noop on same audio track id as already set
      if (this._trackId === newId && this.tracks[this._trackId].details) {
        _logger.logger.debug('Same id as current audio-track passed, and track details available -> no-op');
        return;
      }

      // check if level idx is valid
      if (newId < 0 || newId >= this.tracks.length) {
        _logger.logger.warn('Invalid id passed to audio-track controller');
        return;
      }

      var audioTrack = this.tracks[newId];

      _logger.logger.log('Now switching to audio-track index ' + newId);

      // stopping live reloading timer if any
      this.clearInterval();
      this._trackId = newId;

      var url = audioTrack.url,
          type = audioTrack.type,
          id = audioTrack.id;

      this.hls.trigger(_events2.default.AUDIO_TRACK_SWITCHING, { id: id, type: type, url: url });
      this._loadTrackDetailsIfNeeded(audioTrack);
    }

    /**
     * @override
     */

  }, {
    key: 'doTick',
    value: function doTick() {
      this._updateTrack(this._trackId);
    }

    /**
     * Select initial track
     * @private
     */

  }, {
    key: '_selectInitialAudioTrack',
    value: function _selectInitialAudioTrack() {
      var _this2 = this;

      var tracks = this.tracks;
      if (!tracks.length) {
        return;
      }

      var currentAudioTrack = this.tracks[this._trackId];

      var name = null;
      if (currentAudioTrack) {
        name = currentAudioTrack.name;
      }

      // Pre-select default tracks if there are any
      if (this._selectDefaultTrack) {
        var defaultTracks = tracks.filter(function (track) {
          return track.default;
        });
        if (defaultTracks.length) {
          tracks = defaultTracks;
        } else {
          _logger.logger.warn('No default audio tracks defined');
        }
      }

      var trackFound = false;

      var traverseTracks = function traverseTracks() {
        // Select track with right group ID
        tracks.forEach(function (track) {
          if (trackFound) {
            return;
          }
          // We need to match the (pre-)selected group ID
          // and the NAME of the current track.
          if ((!_this2.audioGroupId || track.groupId === _this2.audioGroupId) && (!name || name === track.name)) {
            // If there was a previous track try to stay with the same `NAME`.
            // It should be unique across tracks of same group, and consistent through redundant track groups.
            _this2._setAudioTrack(track.id);
            trackFound = true;
          }
        });
      };

      traverseTracks();

      if (!trackFound) {
        name = null;
        traverseTracks();
      }

      if (!trackFound) {
        _logger.logger.error('No track found for running audio group-ID: ' + this.audioGroupId);

        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR,
          fatal: true
        });
      }
    }

    /**
     * @private
     * @param {AudioTrack} audioTrack
     * @returns {boolean}
     */

  }, {
    key: '_needsTrackLoading',
    value: function _needsTrackLoading(audioTrack) {
      var details = audioTrack.details,
          url = audioTrack.url;


      if (!details || details.live) {
        // check if we face an audio track embedded in main playlist (audio track without URI attribute)
        return !!url;
      }

      return false;
    }

    /**
     * @private
     * @param {AudioTrack} audioTrack
     */

  }, {
    key: '_loadTrackDetailsIfNeeded',
    value: function _loadTrackDetailsIfNeeded(audioTrack) {
      if (this._needsTrackLoading(audioTrack)) {
        var url = audioTrack.url,
            id = audioTrack.id;
        // track not retrieved yet, or live playlist we need to (re)load it

        _logger.logger.log('loading audio-track playlist for id: ' + id);
        this.hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: id });
      }
    }

    /**
     * @private
     * @param {number} newId
     */

  }, {
    key: '_updateTrack',
    value: function _updateTrack(newId) {
      // check if level idx is valid
      if (newId < 0 || newId >= this.tracks.length) {
        return;
      }

      // stopping live reloading timer if any
      this.clearInterval();
      this._trackId = newId;
      _logger.logger.log('trying to update audio-track ' + newId);
      var audioTrack = this.tracks[newId];
      this._loadTrackDetailsIfNeeded(audioTrack);
    }

    /**
     * @private
     */

  }, {
    key: '_handleLoadError',
    value: function _handleLoadError() {
      // First, let's black list current track id
      this.trackIdBlacklist[this._trackId] = true;

      // Let's try to fall back on a functional audio-track with the same group ID
      var previousId = this._trackId;
      var _tracks$previousId = this.tracks[previousId],
          name = _tracks$previousId.name,
          language = _tracks$previousId.language,
          groupId = _tracks$previousId.groupId;


      _logger.logger.warn('Loading failed on audio track id: ' + previousId + ', group-id: ' + groupId + ', name/language: "' + name + '" / "' + language + '"');

      // Find a non-blacklisted track ID with the same NAME
      // At least a track that is not blacklisted, thus on another group-ID.
      var newId = previousId;
      for (var i = 0; i < this.tracks.length; i++) {
        if (this.trackIdBlacklist[i]) {
          continue;
        }
        var newTrack = this.tracks[i];
        if (newTrack.name === name) {
          newId = i;
          break;
        }
      }

      if (newId === previousId) {
        _logger.logger.warn('No fallback audio-track found for name/language: "' + name + '" / "' + language + '"');
        return;
      }

      _logger.logger.log('Attempting audio-track fallback id:', newId, 'group-id:', this.tracks[newId].groupId);

      this._setAudioTrack(newId);
    }
  }, {
    key: 'audioTracks',
    get: function get() {
      return this.tracks;
    }

    /**
     * @type {number} Index into audio-tracks list of currently selected track.
     */

  }, {
    key: 'audioTrack',
    get: function get() {
      return this._trackId;
    }

    /**
     * Select current track by index
     */
    ,
    set: function set(newId) {
      this._setAudioTrack(newId);
      // If audio track is selected from API then don't choose from the manifest default track
      this._selectDefaultTrack = false;
    }
  }]);

  return AudioTrackController;
}(_taskLoop2.default);

exports.default = AudioTrackController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/base-stream-controller.js":
/*!*********************************************************!*\
  !*** ./src/hls.js/controller/base-stream-controller.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.State = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _taskLoop = __webpack_require__(/*! ../task-loop */ "./src/hls.js/task-loop.js");

var _taskLoop2 = _interopRequireDefault(_taskLoop);

var _fragmentTracker = __webpack_require__(/*! ./fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var State = exports.State = {
  STOPPED: 'STOPPED',
  STARTING: 'STARTING',
  IDLE: 'IDLE',
  PAUSED: 'PAUSED',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_TRACK: 'WAITING_TRACK',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  BUFFER_FLUSHING: 'BUFFER_FLUSHING',
  ENDED: 'ENDED',
  ERROR: 'ERROR',
  WAITING_INIT_PTS: 'WAITING_INIT_PTS',
  WAITING_LEVEL: 'WAITING_LEVEL'
};

var BaseStreamController = function (_TaskLoop) {
  _inherits(BaseStreamController, _TaskLoop);

  function BaseStreamController() {
    _classCallCheck(this, BaseStreamController);

    return _possibleConstructorReturn(this, (BaseStreamController.__proto__ || Object.getPrototypeOf(BaseStreamController)).apply(this, arguments));
  }

  _createClass(BaseStreamController, [{
    key: 'doTick',
    value: function doTick() {}
  }, {
    key: 'startLoad',
    value: function startLoad() {}
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      var frag = this.fragCurrent;
      if (frag) {
        if (frag.loader) {
          frag.loader.abort();
        }
        this.fragmentTracker.removeFragment(frag);
      }
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
      this.fragCurrent = null;
      this.fragPrevious = null;
      this.clearInterval();
      this.clearNextTick();
      this.state = State.STOPPED;
    }
  }, {
    key: '_streamEnded',
    value: function _streamEnded(bufferInfo, levelDetails) {
      var fragCurrent = this.fragCurrent,
          fragmentTracker = this.fragmentTracker;
      // we just got done loading the final fragment and there is no other buffered range after ...
      // rationale is that in case there are any buffered ranges after, it means that there are unbuffered portion in between
      // so we should not switch to ENDED in that case, to be able to buffer them
      // dont switch to ENDED if we need to backtrack last fragment

      if (!levelDetails.live && fragCurrent && !fragCurrent.backtracked && fragCurrent.sn === levelDetails.endSN && !bufferInfo.nextStart) {
        var fragState = fragmentTracker.getState(fragCurrent);
        return fragState === _fragmentTracker.FragmentState.PARTIAL || fragState === _fragmentTracker.FragmentState.OK;
      }
      return false;
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      var config = this.config,
          media = this.media,
          mediaBuffer = this.mediaBuffer,
          state = this.state;

      var currentTime = media ? media.currentTime : null;
      var bufferInfo = _bufferHelper.BufferHelper.bufferInfo(mediaBuffer || media, currentTime, this.config.maxBufferHole);

      if (Number.isFinite(currentTime)) {
        _logger.logger.log('media seeking to ' + currentTime.toFixed(3));
      }

      if (state === State.FRAG_LOADING) {
        var fragCurrent = this.fragCurrent;
        // check if we are seeking to a unbuffered area AND if frag loading is in progress
        if (bufferInfo.len === 0 && fragCurrent) {
          var tolerance = config.maxFragLookUpTolerance;
          var fragStartOffset = fragCurrent.start - tolerance;
          var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
          // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything
          if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
            if (fragCurrent.loader) {
              _logger.logger.log('seeking outside of buffer while fragment load in progress, cancel fragment load');
              fragCurrent.loader.abort();
            }
            this.fragCurrent = null;
            this.fragPrevious = null;
            // switch to IDLE state to load new fragment
            this.state = State.IDLE;
          } else {
            _logger.logger.log('seeking outside of buffer but within currently loaded fragment range');
          }
        }
      } else if (state === State.ENDED) {
        // if seeking to unbuffered area, clean up fragPrevious
        if (bufferInfo.len === 0) {
          this.fragPrevious = null;
          this.fragCurrent = null;
        }

        // switch to IDLE state to check for potential new fragment
        this.state = State.IDLE;
      }
      if (media) {
        this.lastCurrentTime = currentTime;
      }

      // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target
      if (!this.loadedmetadata) {
        this.nextLoadPosition = this.startPosition = currentTime;
      }

      // tick to speed up processing
      this.tick();
    }
  }, {
    key: 'onMediaEnded',
    value: function onMediaEnded() {
      // reset startPosition and lastCurrentTime to restart playback @ stream beginning
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onHandlerDestroying',
    value: function onHandlerDestroying() {
      this.stopLoad();
      _get(BaseStreamController.prototype.__proto__ || Object.getPrototypeOf(BaseStreamController.prototype), 'onHandlerDestroying', this).call(this);
    }
  }, {
    key: 'onHandlerDestroyed',
    value: function onHandlerDestroyed() {
      this.state = State.STOPPED;
      this.fragmentTracker = null;
    }
  }]);

  return BaseStreamController;
}(_taskLoop2.default);

exports.default = BaseStreamController;

/***/ }),

/***/ "./src/hls.js/controller/buffer-controller.js":
/*!****************************************************!*\
  !*** ./src/hls.js/controller/buffer-controller.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _mediasourceHelper = __webpack_require__(/*! ../utils/mediasource-helper */ "./src/hls.js/utils/mediasource-helper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Buffer Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var MediaSource = (0, _mediasourceHelper.getMediaSource)();

var BufferController = function (_EventHandler) {
  _inherits(BufferController, _EventHandler);

  function BufferController(hls) {
    _classCallCheck(this, BufferController);

    // the value that we have set mediasource.duration to
    // (the actual duration may be tweaked slighly by the browser)
    var _this = _possibleConstructorReturn(this, (BufferController.__proto__ || Object.getPrototypeOf(BufferController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_RESET, _events2.default.BUFFER_APPENDING, _events2.default.BUFFER_CODECS, _events2.default.BUFFER_EOS, _events2.default.BUFFER_FLUSHING, _events2.default.LEVEL_PTS_UPDATED, _events2.default.LEVEL_UPDATED));

    _this._msDuration = null;
    // the value that we want to set mediaSource.duration to
    _this._levelDuration = null;
    // the target duration of the current media playlist
    _this._levelTargetDuration = 10;
    // current stream state: true - for live broadcast, false - for VoD content
    _this._live = null;
    // cache the self generated object url to detect hijack of video tag
    _this._objectUrl = null;
    // The number of BUFFER_CODEC events received before any sourceBuffers are created
    _this.bufferCodecEventsExpected = 0;

    // Source Buffer listeners
    _this.onsbue = _this.onSBUpdateEnd.bind(_this);
    _this.onsbe = _this.onSBUpdateError.bind(_this);
    _this.pendingTracks = {};
    _this.tracks = {};
    return _this;
  }

  _createClass(BufferController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onLevelPtsUpdated',
    value: function onLevelPtsUpdated(data) {
      var type = data.type;
      var audioTrack = this.tracks.audio;

      // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)
      // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`
      // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue
      // `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend`
      // event if SB is in updating state.
      // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486

      if (type === 'audio' && audioTrack && audioTrack.container === 'audio/mpeg') {
        // Chrome audio mp3 track
        var audioBuffer = this.sourceBuffer.audio;
        var delta = Math.abs(audioBuffer.timestampOffset - data.start);

        // adjust timestamp offset if time delta is greater than 100ms
        if (delta > 0.1) {
          var updating = audioBuffer.updating;

          try {
            audioBuffer.abort();
          } catch (err) {
            _logger.logger.warn('can not abort audio buffer: ' + err);
          }

          if (!updating) {
            _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + data.start);
            audioBuffer.timestampOffset = data.start;
          } else {
            this.audioTimestampOffset = data.start;
          }
        }
      }
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller
      // sourcebuffers will be created all at once when the expected nb of tracks will be reached
      // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller
      // it will contain the expected nb of source buffers, no need to compute it
      this.bufferCodecEventsExpected = data.altAudio ? 2 : 1;
      _logger.logger.log(this.bufferCodecEventsExpected + ' bufferCodec event(s) expected');
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      var media = this.media = data.media;
      if (media) {
        // setup the media source
        var ms = this.mediaSource = new MediaSource();
        // Media Source listeners
        this.onmso = this.onMediaSourceOpen.bind(this);
        this.onmse = this.onMediaSourceEnded.bind(this);
        this.onmsc = this.onMediaSourceClose.bind(this);
        ms.addEventListener('sourceopen', this.onmso);
        ms.addEventListener('sourceended', this.onmse);
        ms.addEventListener('sourceclose', this.onmsc);
        // link video and media Source
        media.src = window.URL.createObjectURL(ms);
        // cache the locally generated object url
        this._objectUrl = media.src;
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      _logger.logger.log('media source detaching');
      var ms = this.mediaSource;
      if (ms) {
        if (ms.readyState === 'open') {
          try {
            // endOfStream could trigger exception if any sourcebuffer is in updating state
            // we don't really care about checking sourcebuffer state here,
            // as we are anyway detaching the MediaSource
            // let's just avoid this exception to propagate
            ms.endOfStream();
          } catch (err) {
            _logger.logger.warn('onMediaDetaching:' + err.message + ' while calling endOfStream');
          }
        }
        ms.removeEventListener('sourceopen', this.onmso);
        ms.removeEventListener('sourceended', this.onmse);
        ms.removeEventListener('sourceclose', this.onmsc);

        // Detach properly the MediaSource from the HTMLMediaElement as
        // suggested in https://github.com/w3c/media-source/issues/53.
        if (this.media) {
          window.URL.revokeObjectURL(this._objectUrl);

          // clean up video tag src only if it's our own url. some external libraries might
          // hijack the video tag and change its 'src' without destroying the Hls instance first
          if (this.media.src === this._objectUrl) {
            this.media.removeAttribute('src');
            this.media.load();
          } else {
            _logger.logger.warn('media.src was changed by a third party - skip cleanup');
          }
        }

        this.mediaSource = null;
        this.media = null;
        this._objectUrl = null;
        this.pendingTracks = {};
        this.tracks = {};
        this.sourceBuffer = {};
        this.flushRange = [];
        this.segments = [];
        this.appended = 0;
      }
      this.onmso = this.onmse = this.onmsc = null;
      this.hls.trigger(_events2.default.MEDIA_DETACHED);
    }
  }, {
    key: 'onMediaSourceOpen',
    value: function onMediaSourceOpen() {
      _logger.logger.log('media source opened');
      this.hls.trigger(_events2.default.MEDIA_ATTACHED, { media: this.media });
      var mediaSource = this.mediaSource;
      if (mediaSource) {
        // once received, don't listen anymore to sourceopen event
        mediaSource.removeEventListener('sourceopen', this.onmso);
      }
      this.checkPendingTracks();
    }
  }, {
    key: 'checkPendingTracks',
    value: function checkPendingTracks() {
      var bufferCodecEventsExpected = this.bufferCodecEventsExpected,
          pendingTracks = this.pendingTracks;
      // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.
      // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after
      // data has been appended to existing ones.
      // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.

      var pendingTracksCount = Object.keys(pendingTracks).length;
      if (pendingTracksCount && !bufferCodecEventsExpected || pendingTracksCount === 2) {
        // ok, let's create them now !
        this.createSourceBuffers(pendingTracks);
        this.pendingTracks = {};
        // append any pending segments now !
        this.doAppending();
      }
    }
  }, {
    key: 'onMediaSourceClose',
    value: function onMediaSourceClose() {
      _logger.logger.log('media source closed');
    }
  }, {
    key: 'onMediaSourceEnded',
    value: function onMediaSourceEnded() {
      _logger.logger.log('media source ended');
    }
  }, {
    key: 'onSBUpdateEnd',
    value: function onSBUpdateEnd() {
      // update timestampOffset
      if (this.audioTimestampOffset) {
        var audioBuffer = this.sourceBuffer.audio;
        _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + this.audioTimestampOffset);
        audioBuffer.timestampOffset = this.audioTimestampOffset;
        delete this.audioTimestampOffset;
      }

      if (this._needsFlush) {
        this.doFlush();
      }

      if (this._needsEos) {
        this.checkEos();
      }

      this.appending = false;
      var parent = this.parent;
      // count nb of pending segments waiting for appending on this sourcebuffer
      var pending = this.segments.reduce(function (counter, segment) {
        return segment.parent === parent ? counter + 1 : counter;
      }, 0);

      // this.sourceBuffer is better to use than media.buffered as it is closer to the PTS data from the fragments
      var timeRanges = {};
      var sourceBuffer = this.sourceBuffer;
      for (var streamType in sourceBuffer) {
        timeRanges[streamType] = sourceBuffer[streamType].buffered;
      }

      // 寻找可播放的起始点。如果没有自动播放，需要手动Seek
      if (this._paused === false && timeRanges["video"] && timeRanges["video"].length > 0 && timeRanges["audio"] && timeRanges["audio"].length > 0) {

        if (timeRanges["video"].end(0) - timeRanges["video"].start(0) > 1 && timeRanges["audio"].end(0) - timeRanges["audio"].start(0) > 1) {
          // Seek to the point that can play;
          var startTime = Math.max(timeRanges["video"].start(0), timeRanges["audio"].start(0));
          this.media.currentTime = startTime;
          this.media.play();
          delete this["_paused"];
        } else {
          // Try to seek more
          var endTime = Math.max(timeRanges["video"].end(0), timeRanges["audio"].end(0));
          this.media.currentTime = endTime;
          this.media.play();
        }
      }

      this.hls.trigger(_events2.default.BUFFER_APPENDED, { parent: parent, pending: pending, timeRanges: timeRanges });
      // don't append in flushing mode
      if (!this._needsFlush) {
        this.doAppending();
      }

      this.updateMediaElementDuration();

      // appending goes first
      if (pending === 0) {
        this.flushLiveBackBuffer();
      }
    }
  }, {
    key: 'onSBUpdateError',
    value: function onSBUpdateError(event) {
      _logger.logger.error('sourceBuffer error:', event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
      // we don't need to do more than that, as accordin to the spec, updateend will be fired just after
    }
  }, {
    key: 'onBufferReset',
    value: function onBufferReset() {
      var sourceBuffer = this.sourceBuffer;
      for (var type in sourceBuffer) {
        var sb = sourceBuffer[type];
        try {
          this.mediaSource.removeSourceBuffer(sb);
          sb.removeEventListener('updateend', this.onsbue);
          sb.removeEventListener('error', this.onsbe);
        } catch (err) {}
      }
      this.sourceBuffer = {};
      this.flushRange = [];
      this.segments = [];
      this.appended = 0;
    }
  }, {
    key: 'onBufferCodecs',
    value: function onBufferCodecs(tracks) {
      var _this2 = this;

      // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
      // if sourcebuffers already created, do nothing ...
      /** 需要放过tracks, 有新的track需要重新加buffer 使得画面到达时，可以播放画面
      if (Object.keys(this.sourceBuffer).length) {
        return;
      }*/

      Object.keys(tracks).forEach(function (trackName) {
        _this2.pendingTracks[trackName] = tracks[trackName];
      });
      var mediaSource = this.mediaSource;

      this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);
      if (mediaSource && mediaSource.readyState === 'open') {
        this.checkPendingTracks();
      }
    }
  }, {
    key: 'createSourceBuffers',
    value: function createSourceBuffers(tracks) {
      var sourceBuffer = this.sourceBuffer,
          mediaSource = this.mediaSource;
      for (var trackName in tracks) {
        if (!sourceBuffer[trackName]) {
          var track = tracks[trackName];
          // use levelCodec as first priority
          var codec = track.levelCodec || track.codec;
          var mimeType = track.container + ';codecs=' + codec;
          _logger.logger.log('creating sourceBuffer(' + mimeType + ')');
          try {
            var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
            sb.addEventListener('updateend', this.onsbue);
            sb.addEventListener('error', this.onsbe);
            this.tracks[trackName] = { codec: codec, container: track.container };
            track.buffer = sb;
          } catch (err) {
            if (err.code == 22) {
              _logger.logger.log("Found new track, try to rebuild");
              this._paused = false;
              // setup the media source
              var ms = this.mediaSource = new MediaSource();
              // Media Source listeners
              this.onmso = this.onMediaSourceOpen.bind(this);
              this.onmse = this.onMediaSourceEnded.bind(this);
              this.onmsc = this.onMediaSourceClose.bind(this);

              for (var i = 0; i < Object.keys(this.tracks).length; i++) {
                var _track = this.tracks[Object.keys(this.tracks)[i]];
                this.pendingTracks[Object.keys(this.tracks)[i]] = _track;
              }
              this.tracks = {};
              this.sourceBuffer = {};
              ms.addEventListener('sourceopen', this.onmso);
              ms.addEventListener('sourceended', this.onmse);
              ms.addEventListener('sourceclose', this.onmsc);
              // link video and media Source
              this.media.src = window.URL.createObjectURL(ms);
              // cache the locally generated object url
              this._objectUrl = media.src;
            } else {
              _logger.logger.error('error while trying to add sourceBuffer:' + err.message);
              this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });
            }
          }
        }
      }

      this.hls.trigger(_events2.default.BUFFER_CREATED, { tracks: tracks });
    }
  }, {
    key: 'onBufferAppending',
    value: function onBufferAppending(data) {
      if (!this._needsFlush) {
        if (!this.segments) {
          this.segments = [data];
        } else {
          this.segments.push(data);
        }

        this.doAppending();
      }
    }
  }, {
    key: 'onBufferAppendFail',
    value: function onBufferAppendFail(data) {
      _logger.logger.error('sourceBuffer error:', data.event);
      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
      // this error might not always be fatal (it is fatal if decode error is set, in that case
      // it will be followed by a mediaElement error ...)
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
    }

    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()

  }, {
    key: 'onBufferEos',
    value: function onBufferEos(data) {
      var sb = this.sourceBuffer;
      var dataType = data.type;
      for (var type in sb) {
        if (!dataType || type === dataType) {
          if (!sb[type].ended) {
            sb[type].ended = true;
            _logger.logger.log(type + ' sourceBuffer now EOS');
          }
        }
      }
      this.checkEos();
    }

    // if all source buffers are marked as ended, signal endOfStream() to MediaSource.

  }, {
    key: 'checkEos',
    value: function checkEos() {
      var sb = this.sourceBuffer,
          mediaSource = this.mediaSource;
      if (!mediaSource || mediaSource.readyState !== 'open') {
        this._needsEos = false;
        return;
      }
      for (var type in sb) {
        var sbobj = sb[type];
        if (!sbobj.ended) {
          return;
        }

        if (sbobj.updating) {
          this._needsEos = true;
          return;
        }
      }
      _logger.logger.log('all media data are available, signal endOfStream() to MediaSource and stop loading fragment');
      // Notify the media element that it now has all of the media data
      try {
        mediaSource.endOfStream();
      } catch (e) {
        _logger.logger.warn('exception while calling mediaSource.endOfStream()');
      }
      this._needsEos = false;
    }
  }, {
    key: 'onBufferFlushing',
    value: function onBufferFlushing(data) {
      this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });
      // attempt flush immediately
      this.flushBufferCounter = 0;
      this.doFlush();
    }
  }, {
    key: 'flushLiveBackBuffer',
    value: function flushLiveBackBuffer() {
      // clear back buffer for live only
      if (!this._live) {
        return;
      }

      var liveBackBufferLength = this.hls.config.liveBackBufferLength;
      if (!isFinite(liveBackBufferLength) || liveBackBufferLength < 0) {
        return;
      }

      var currentTime = this.media.currentTime;
      var sourceBuffer = this.sourceBuffer;
      var bufferTypes = Object.keys(sourceBuffer);
      var targetBackBufferPosition = currentTime - Math.max(liveBackBufferLength, this._levelTargetDuration);

      for (var index = bufferTypes.length - 1; index >= 0; index--) {
        var bufferType = bufferTypes[index],
            buffered = sourceBuffer[bufferType].buffered;

        // when target buffer start exceeds actual buffer start
        if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {
          // remove buffer up until current time minus minimum back buffer length (removing buffer too close to current
          // time will lead to playback freezing)
          // credits for level target duration - https://github.com/videojs/http-streaming/blob/3132933b6aa99ddefab29c10447624efd6fd6e52/src/segment-loader.js#L91
          this.removeBufferRange(bufferType, sourceBuffer[bufferType], 0, targetBackBufferPosition);
        }
      }
    }
  }, {
    key: 'onLevelUpdated',
    value: function onLevelUpdated(_ref) {
      var details = _ref.details;

      if (details.fragments.length > 0) {
        this._levelDuration = details.totalduration + details.fragments[0].start;
        this._levelTargetDuration = details.averagetargetduration || details.targetduration || 10;
        this._live = details.live;
        this.updateMediaElementDuration();
      }
    }

    /**
     * Update Media Source duration to current level duration or override to Infinity if configuration parameter
     * 'liveDurationInfinity` is set to `true`
     * More details: https://github.com/video-dev/hls.js/issues/355
     */

  }, {
    key: 'updateMediaElementDuration',
    value: function updateMediaElementDuration() {
      var config = this.hls.config;

      var duration = void 0;

      if (this._levelDuration === null || !this.media || !this.mediaSource || !this.sourceBuffer || this.media.readyState === 0 || this.mediaSource.readyState !== 'open') {
        return;
      }

      for (var type in this.sourceBuffer) {
        if (this.sourceBuffer[type].updating === true) {
          // can't set duration whilst a buffer is updating
          return;
        }
      }

      duration = this.media.duration;
      // initialise to the value that the media source is reporting
      if (this._msDuration === null) {
        this._msDuration = this.mediaSource.duration;
      }

      if (this._live === true && config.liveDurationInfinity === true) {
        // Override duration to Infinity
        _logger.logger.log('Media Source duration is set to Infinity');
        this._msDuration = this.mediaSource.duration = Infinity;
      } else if (this._levelDuration > this._msDuration && this._levelDuration > duration || !Number.isFinite(duration)) {
        // levelDuration was the last value we set.
        // not using mediaSource.duration as the browser may tweak this value
        // only update Media Source duration if its value increase, this is to avoid
        // flushing already buffered portion when switching between quality level
        _logger.logger.log('Updating Media Source duration to ' + this._levelDuration.toFixed(3));
        this._msDuration = this.mediaSource.duration = this._levelDuration;
      }
    }
  }, {
    key: 'doFlush',
    value: function doFlush() {
      // loop through all buffer ranges to flush
      while (this.flushRange.length) {
        var range = this.flushRange[0];
        // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer
        if (this.flushBuffer(range.start, range.end, range.type)) {
          // range flushed, remove from flush array
          this.flushRange.shift();
          this.flushBufferCounter = 0;
        } else {
          this._needsFlush = true;
          // avoid looping, wait for SB update end to retrigger a flush
          return;
        }
      }
      if (this.flushRange.length === 0) {
        // everything flushed
        this._needsFlush = false;

        // let's recompute this.appended, which is used to avoid flush looping
        var appended = 0;
        var sourceBuffer = this.sourceBuffer;
        try {
          for (var type in sourceBuffer) {
            appended += sourceBuffer[type].buffered.length;
          }
        } catch (error) {
          // error could be thrown while accessing buffered, in case sourcebuffer has already been removed from MediaSource
          // this is harmess at this stage, catch this to avoid reporting an internal exception
          _logger.logger.error('error while accessing sourceBuffer.buffered');
        }
        this.appended = appended;
        this.hls.trigger(_events2.default.BUFFER_FLUSHED);
      }
    }
  }, {
    key: 'doAppending',
    value: function doAppending() {
      var hls = this.hls,
          segments = this.segments,
          sourceBuffer = this.sourceBuffer;

      if (Object.keys(sourceBuffer).length) {
        if (this.media.error) {
          this.segments = [];
          _logger.logger.error('trying to append although a media error occured, flush segment and abort');
          return;
        }
        if (this.appending) {
          // logger.log(`sb appending in progress`);
          return;
        }
        if (segments && segments.length) {
          var segment = segments.shift();
          try {
            var type = segment.type,
                sb = sourceBuffer[type];
            if (sb) {
              if (!sb.updating) {
                // reset sourceBuffer ended flag before appending segment
                sb.ended = false;
                // logger.log(`appending ${segment.content} ${type} SB, size:${segment.data.length}, ${segment.parent}`);
                this.parent = segment.parent;
                sb.appendBuffer(segment.data);
                this.appendError = 0;
                this.appended++;
                this.appending = true;
              } else {
                segments.unshift(segment);
              }
            } else {
              // in case we don't have any source buffer matching with this segment type,
              // it means that Mediasource fails to create sourcebuffer
              // discard this segment, and trigger update end
              this.onSBUpdateEnd();
            }
          } catch (err) {
            // in case any error occured while appending, put back segment in segments table
            _logger.logger.error('error while trying to append buffer:' + err.message);
            segments.unshift(segment);
            var event = { type: _errors.ErrorTypes.MEDIA_ERROR, parent: segment.parent };
            if (err.code !== 22) {
              if (this.appendError) {
                this.appendError++;
              } else {
                this.appendError = 1;
              }

              event.details = _errors.ErrorDetails.BUFFER_APPEND_ERROR;
              /* with UHD content, we could get loop of quota exceeded error until
                browser is able to evict some data from sourcebuffer. retrying help recovering this
              */
              if (this.appendError > hls.config.appendErrorMaxRetry) {
                _logger.logger.log('fail ' + hls.config.appendErrorMaxRetry + ' times to append segment in sourceBuffer');
                this.segments = [];
                event.fatal = true;
                hls.trigger(_events2.default.ERROR, event);
              } else {
                event.fatal = false;
                hls.trigger(_events2.default.ERROR, event);
              }
            } else {
              // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
              // let's stop appending any segments, and report BUFFER_FULL_ERROR error
              this.segments = [];
              event.details = _errors.ErrorDetails.BUFFER_FULL_ERROR;
              event.fatal = false;
              hls.trigger(_events2.default.ERROR, event);
            }
          }
        }
      }
    }

    /*
      flush specified buffered range,
      return true once range has been flushed.
      as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
    */

  }, {
    key: 'flushBuffer',
    value: function flushBuffer(startOffset, endOffset, typeIn) {
      var sb = void 0;
      var sourceBuffer = this.sourceBuffer;
      if (Object.keys(sourceBuffer).length) {
        _logger.logger.log('flushBuffer,pos/start/end: ' + this.media.currentTime.toFixed(3) + '/' + startOffset + '/' + endOffset);
        // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments
        if (this.flushBufferCounter < this.appended) {
          for (var type in sourceBuffer) {
            // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one
            // if no, let's flush all sourcebuffers
            if (typeIn && type !== typeIn) {
              continue;
            }

            sb = sourceBuffer[type];
            // we are going to flush buffer, mark source buffer as 'not ended'
            sb.ended = false;
            if (!sb.updating) {
              if (this.removeBufferRange(type, sb, startOffset, endOffset)) {
                this.flushBufferCounter++;
                return false;
              }
            } else {
              _logger.logger.warn('cannot flush, sb updating in progress');
              return false;
            }
          }
        } else {
          _logger.logger.warn('abort flushing too many retries');
        }
        _logger.logger.log('buffer flushed');
      }
      // everything flushed !
      return true;
    }

    /**
     * Removes first buffered range from provided source buffer that lies within given start and end offsets.
     *
     * @param type Type of the source buffer, logging purposes only.
     * @param sb Target SourceBuffer instance.
     * @param startOffset
     * @param endOffset
     *
     * @returns {boolean} True when source buffer remove requested.
     */

  }, {
    key: 'removeBufferRange',
    value: function removeBufferRange(type, sb, startOffset, endOffset) {
      try {
        for (var i = 0; i < sb.buffered.length; i++) {
          var bufStart = sb.buffered.start(i);
          var bufEnd = sb.buffered.end(i);
          var removeStart = Math.max(bufStart, startOffset);
          var removeEnd = Math.min(bufEnd, endOffset);

          /* sometimes sourcebuffer.remove() does not flush
            the exact expected time range.
            to avoid rounding issues/infinite loop,
            only flush buffer range of length greater than 500ms.
          */
          if (Math.min(removeEnd, bufEnd) - removeStart > 0.5) {
            _logger.logger.log('sb remove ' + type + ' [' + removeStart + ',' + removeEnd + '], of [' + bufStart + ',' + bufEnd + '], pos:' + this.media.currentTime);
            sb.remove(removeStart, removeEnd);
            return true;
          }
        }
      } catch (error) {
        _logger.logger.warn('removeBufferRange failed', error);
      }

      return false;
    }
  }]);

  return BufferController;
}(_eventHandler2.default);

exports.default = BufferController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/cap-level-controller.js":
/*!*******************************************************!*\
  !*** ./src/hls.js/controller/cap-level-controller.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * cap stream level to media size dimension controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var CapLevelController = function (_EventHandler) {
  _inherits(CapLevelController, _EventHandler);

  function CapLevelController(hls) {
    _classCallCheck(this, CapLevelController);

    var _this = _possibleConstructorReturn(this, (CapLevelController.__proto__ || Object.getPrototypeOf(CapLevelController)).call(this, hls, _events2.default.FPS_DROP_LEVEL_CAPPING, _events2.default.MEDIA_ATTACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_CODECS, _events2.default.MEDIA_DETACHING));

    _this.autoLevelCapping = Number.POSITIVE_INFINITY;
    _this.firstLevel = null;
    _this.levels = [];
    _this.media = null;
    _this.restrictedLevels = [];
    _this.timer = null;
    return _this;
  }

  _createClass(CapLevelController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.hls.config.capLevelToPlayerSize) {
        this.media = null;
        this._stopCapping();
      }
    }
  }, {
    key: 'onFpsDropLevelCapping',
    value: function onFpsDropLevelCapping(data) {
      // Don't add a restricted level more than once
      if (CapLevelController.isLevelAllowed(data.droppedLevel, this.restrictedLevels)) {
        this.restrictedLevels.push(data.droppedLevel);
      }
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media instanceof window.HTMLVideoElement ? data.media : null;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var hls = this.hls;
      this.restrictedLevels = [];
      this.levels = data.levels;
      this.firstLevel = data.firstLevel;
      if (hls.config.capLevelToPlayerSize && data.video) {
        // Start capping immediately if the manifest has signaled video codecs
        this._startCapping();
      }
    }

    // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted
    // to the first level

  }, {
    key: 'onBufferCodecs',
    value: function onBufferCodecs(data) {
      var hls = this.hls;
      if (hls.config.capLevelToPlayerSize && data.video) {
        // If the manifest did not signal a video codec capping has been deferred until we're certain video is present
        this._startCapping();
      }
    }
  }, {
    key: 'onLevelsUpdated',
    value: function onLevelsUpdated(data) {
      this.levels = data.levels;
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      this._stopCapping();
    }
  }, {
    key: 'detectPlayerSize',
    value: function detectPlayerSize() {
      if (this.media) {
        var levelsLength = this.levels ? this.levels.length : 0;
        if (levelsLength) {
          var hls = this.hls;
          hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);
          if (hls.autoLevelCapping > this.autoLevelCapping) {
            // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
            // usually happen when the user go to the fullscreen mode.
            hls.streamController.nextLevelSwitch();
          }
          this.autoLevelCapping = hls.autoLevelCapping;
        }
      }
    }

    /*
    * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
    */

  }, {
    key: 'getMaxLevel',
    value: function getMaxLevel(capLevelIndex) {
      var _this2 = this;

      if (!this.levels) {
        return -1;
      }

      var validLevels = this.levels.filter(function (level, index) {
        return CapLevelController.isLevelAllowed(index, _this2.restrictedLevels) && index <= capLevelIndex;
      });

      return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
    }
  }, {
    key: '_startCapping',
    value: function _startCapping() {
      if (this.timer) {
        // Don't reset capping if started twice; this can happen if the manifest signals a video codec
        return;
      }
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      this.hls.firstLevel = this.getMaxLevel(this.firstLevel);
      clearInterval(this.timer);
      this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);
      this.detectPlayerSize();
    }
  }, {
    key: '_stopCapping',
    value: function _stopCapping() {
      this.restrictedLevels = [];
      this.firstLevel = null;
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      if (this.timer) {
        this.timer = clearInterval(this.timer);
        this.timer = null;
      }
    }
  }, {
    key: 'mediaWidth',
    get: function get() {
      var width = void 0;
      var media = this.media;
      if (media) {
        width = media.width || media.clientWidth || media.offsetWidth;
        width *= CapLevelController.contentScaleFactor;
      }
      return width;
    }
  }, {
    key: 'mediaHeight',
    get: function get() {
      var height = void 0;
      var media = this.media;
      if (media) {
        height = media.height || media.clientHeight || media.offsetHeight;
        height *= CapLevelController.contentScaleFactor;
      }
      return height;
    }
  }], [{
    key: 'isLevelAllowed',
    value: function isLevelAllowed(level) {
      var restrictedLevels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      return restrictedLevels.indexOf(level) === -1;
    }
  }, {
    key: 'getMaxLevelByMediaSize',
    value: function getMaxLevelByMediaSize(levels, width, height) {
      if (!levels || levels && !levels.length) {
        return -1;
      }

      // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next
      // to determine whether we've chosen the greatest bandwidth for the media's dimensions
      var atGreatestBandiwdth = function atGreatestBandiwdth(curLevel, nextLevel) {
        if (!nextLevel) {
          return true;
        }

        return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
      };

      // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to
      // the max level
      var maxLevelIndex = levels.length - 1;

      for (var i = 0; i < levels.length; i += 1) {
        var level = levels[i];
        if ((level.width >= width || level.height >= height) && atGreatestBandiwdth(level, levels[i + 1])) {
          maxLevelIndex = i;
          break;
        }
      }

      return maxLevelIndex;
    }
  }, {
    key: 'contentScaleFactor',
    get: function get() {
      var pixelRatio = 1;
      try {
        pixelRatio = window.devicePixelRatio;
      } catch (e) {}
      return pixelRatio;
    }
  }]);

  return CapLevelController;
}(_eventHandler2.default);

exports.default = CapLevelController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/eme-controller.js":
/*!*************************************************!*\
  !*** ./src/hls.js/controller/eme-controller.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author Stephan Hesse <disparat@gmail.com> | <tchakabam@gmail.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * DRM support for Hls.js
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _window = window,
    XMLHttpRequest = _window.XMLHttpRequest;


var MAX_LICENSE_REQUEST_FAILURES = 3;

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess
 */
var KeySystems = {
  WIDEVINE: 'com.widevine.alpha',
  PLAYREADY: 'com.microsoft.playready'
};

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration
 * @param {Array<string>} audioCodecs List of required audio codecs to support
 * @param {Array<string>} videoCodecs List of required video codecs to support
 * @param {object} drmSystemOptions Optional parameters/requirements for the key-system
 * @returns {Array<MediaSystemConfiguration>} An array of supported configurations
 */

var createWidevineMediaKeySystemConfigurations = function createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs, drmSystemOptions) {
  /* jshint ignore:line */
  var baseConfig = {
    // initDataTypes: ['keyids', 'mp4'],
    // label: "",
    // persistentState: "not-allowed", // or "required" ?
    // distinctiveIdentifier: "not-allowed", // or "required" ?
    // sessionTypes: ['temporary'],
    videoCapabilities: [
      // { contentType: 'video/mp4; codecs="avc1.42E01E"' }
    ]
  };

  videoCodecs.forEach(function (codec) {
    baseConfig.videoCapabilities.push({
      contentType: 'video/mp4; codecs="' + codec + '"'
    });
  });

  return [baseConfig];
};

/**
 * The idea here is to handle key-system (and their respective platforms) specific configuration differences
 * in order to work with the local requestMediaKeySystemAccess method.
 *
 * We can also rule-out platform-related key-system support at this point by throwing an error or returning null.
 *
 * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum
 * @param {Array<string>} audioCodecs List of required audio codecs to support
 * @param {Array<string>} videoCodecs List of required video codecs to support
 * @returns {Array<MediaSystemConfiguration> | null} A non-empty Array of MediaKeySystemConfiguration objects or `null`
 */
var getSupportedMediaKeySystemConfigurations = function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs) {
  switch (keySystem) {
    case KeySystems.WIDEVINE:
      return createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs);
    default:
      throw Error('Unknown key-system: ' + keySystem);
  }
};

/**
 * Controller to deal with encrypted media extensions (EME)
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API
 *
 * @class
 * @constructor
 */

var EMEController = function (_EventHandler) {
  _inherits(EMEController, _EventHandler);

  /**
     * @constructs
     * @param {Hls} hls Our Hls.js instance
     */
  function EMEController(hls) {
    _classCallCheck(this, EMEController);

    var _this = _possibleConstructorReturn(this, (EMEController.__proto__ || Object.getPrototypeOf(EMEController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MANIFEST_PARSED));

    _this._widevineLicenseUrl = hls.config.widevineLicenseUrl;
    _this._licenseXhrSetup = hls.config.licenseXhrSetup;
    _this._emeEnabled = hls.config.emeEnabled;

    _this._requestMediaKeySystemAccess = hls.config.requestMediaKeySystemAccessFunc;

    _this._mediaKeysList = [];
    _this._media = null;

    _this._hasSetMediaKeys = false;
    _this._isMediaEncrypted = false;

    _this._requestLicenseFailureCount = 0;
    return _this;
  }

  /**
     *
     * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum
     * @returns {string} License server URL for key-system (if any configured, otherwise causes error)
     */


  _createClass(EMEController, [{
    key: 'getLicenseServerUrl',
    value: function getLicenseServerUrl(keySystem) {
      var url = void 0;
      switch (keySystem) {
        case KeySystems.WIDEVINE:
          url = this._widevineLicenseUrl;
          break;
        default:
          url = null;
          break;
      }

      if (!url) {
        _logger.logger.error('No license server URL configured for key-system "' + keySystem + '"');
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
          fatal: true
        });
      }

      return url;
    }

    /**
       * Requests access object and adds it to our list upon success
       * @private
       * @param {string} keySystem System ID (see `KeySystems`)
       * @param {Array<string>} audioCodecs List of required audio codecs to support
       * @param {Array<string>} videoCodecs List of required video codecs to support
       */

  }, {
    key: '_attemptKeySystemAccess',
    value: function _attemptKeySystemAccess(keySystem, audioCodecs, videoCodecs) {
      var _this2 = this;

      // TODO: add other DRM "options"

      var mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs);

      if (!mediaKeySystemConfigs) {
        _logger.logger.warn('Can not create config for key-system (maybe because platform is not supported):', keySystem);
        return;
      }

      _logger.logger.log('Requesting encrypted media key-system access');

      // expecting interface like window.navigator.requestMediaKeySystemAccess
      this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs).then(function (mediaKeySystemAccess) {
        _this2._onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess);
      }).catch(function (err) {
        _logger.logger.error('Failed to obtain key-system "' + keySystem + '" access:', err);
      });
    }
  }, {
    key: '_onMediaKeySystemAccessObtained',


    /**
       * Handles obtaining access to a key-system
       *
       * @param {string} keySystem
       * @param {MediaKeySystemAccess} mediaKeySystemAccess https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemAccess
       */
    value: function _onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess) {
      var _this3 = this;

      _logger.logger.log('Access for key-system "' + keySystem + '" obtained');

      var mediaKeysListItem = {
        mediaKeys: null,
        mediaKeysSession: null,
        mediaKeysSessionInitialized: false,
        mediaKeySystemAccess: mediaKeySystemAccess,
        mediaKeySystemDomain: keySystem
      };

      this._mediaKeysList.push(mediaKeysListItem);

      mediaKeySystemAccess.createMediaKeys().then(function (mediaKeys) {
        mediaKeysListItem.mediaKeys = mediaKeys;

        _logger.logger.log('Media-keys created for key-system "' + keySystem + '"');

        _this3._onMediaKeysCreated();
      }).catch(function (err) {
        _logger.logger.error('Failed to create media-keys:', err);
      });
    }

    /**
       * Handles key-creation (represents access to CDM). We are going to create key-sessions upon this
       * for all existing keys where no session exists yet.
       */

  }, {
    key: '_onMediaKeysCreated',
    value: function _onMediaKeysCreated() {
      var _this4 = this;

      // check for all key-list items if a session exists, otherwise, create one
      this._mediaKeysList.forEach(function (mediaKeysListItem) {
        if (!mediaKeysListItem.mediaKeysSession) {
          mediaKeysListItem.mediaKeysSession = mediaKeysListItem.mediaKeys.createSession();
          _this4._onNewMediaKeySession(mediaKeysListItem.mediaKeysSession);
        }
      });
    }

    /**
       *
       * @param {*} keySession
       */

  }, {
    key: '_onNewMediaKeySession',
    value: function _onNewMediaKeySession(keySession) {
      var _this5 = this;

      _logger.logger.log('New key-system session ' + keySession.sessionId);

      keySession.addEventListener('message', function (event) {
        _this5._onKeySessionMessage(keySession, event.message);
      }, false);
    }
  }, {
    key: '_onKeySessionMessage',
    value: function _onKeySessionMessage(keySession, message) {
      _logger.logger.log('Got EME message event, creating license request');

      this._requestLicense(message, function (data) {
        _logger.logger.log('Received license data, updating key-session');
        keySession.update(data);
      });
    }
  }, {
    key: '_onMediaEncrypted',
    value: function _onMediaEncrypted(initDataType, initData) {
      _logger.logger.log('Media is encrypted using "' + initDataType + '" init data type');

      this._isMediaEncrypted = true;
      this._mediaEncryptionInitDataType = initDataType;
      this._mediaEncryptionInitData = initData;

      this._attemptSetMediaKeys();
      this._generateRequestWithPreferredKeySession();
    }
  }, {
    key: '_attemptSetMediaKeys',
    value: function _attemptSetMediaKeys() {
      if (!this._hasSetMediaKeys) {
        // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?
        var keysListItem = this._mediaKeysList[0];
        if (!keysListItem || !keysListItem.mediaKeys) {
          _logger.logger.error('Fatal: Media is encrypted but no CDM access or no keys have been obtained yet');
          this.hls.trigger(_events2.default.ERROR, {
            type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
            details: _errors.ErrorDetails.KEY_SYSTEM_NO_KEYS,
            fatal: true
          });
          return;
        }

        _logger.logger.log('Setting keys for encrypted media');

        this._media.setMediaKeys(keysListItem.mediaKeys);
        this._hasSetMediaKeys = true;
      }
    }
  }, {
    key: '_generateRequestWithPreferredKeySession',
    value: function _generateRequestWithPreferredKeySession() {
      var _this6 = this;

      // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?
      var keysListItem = this._mediaKeysList[0];
      if (!keysListItem) {
        _logger.logger.error('Fatal: Media is encrypted but not any key-system access has been obtained yet');
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
          fatal: true
        });
        return;
      }

      if (keysListItem.mediaKeysSessionInitialized) {
        _logger.logger.warn('Key-Session already initialized but requested again');
        return;
      }

      var keySession = keysListItem.mediaKeysSession;
      if (!keySession) {
        _logger.logger.error('Fatal: Media is encrypted but no key-session existing');
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_NO_SESSION,
          fatal: true
        });
      }

      var initDataType = this._mediaEncryptionInitDataType;
      var initData = this._mediaEncryptionInitData;

      _logger.logger.log('Generating key-session request for "' + initDataType + '" init data type');

      keysListItem.mediaKeysSessionInitialized = true;

      keySession.generateRequest(initDataType, initData).then(function () {
        _logger.logger.debug('Key-session generation succeeded');
      }).catch(function (err) {
        _logger.logger.error('Error generating key-session request:', err);
        _this6.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_NO_SESSION,
          fatal: false
        });
      });
    }

    /**
       * @param {string} url License server URL
       * @param {ArrayBuffer} keyMessage Message data issued by key-system
       * @param {function} callback Called when XHR has succeeded
       * @returns {XMLHttpRequest} Unsent (but opened state) XHR object
       */

  }, {
    key: '_createLicenseXhr',
    value: function _createLicenseXhr(url, keyMessage, callback) {
      var xhr = new XMLHttpRequest();
      var licenseXhrSetup = this._licenseXhrSetup;

      try {
        if (licenseXhrSetup) {
          try {
            licenseXhrSetup(xhr, url);
          } catch (e) {
            // let's try to open before running setup
            xhr.open('POST', url, true);
            licenseXhrSetup(xhr, url);
          }
        }
        // if licenseXhrSetup did not yet call open, let's do it now
        if (!xhr.readyState) {
          xhr.open('POST', url, true);
        }
      } catch (e) {
        // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
        _logger.logger.error('Error setting up key-system license XHR', e);
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
          fatal: true
        });
        return;
      }

      xhr.responseType = 'arraybuffer';
      xhr.onreadystatechange = this._onLicenseRequestReadyStageChange.bind(this, xhr, url, keyMessage, callback);
      return xhr;
    }

    /**
       * @param {XMLHttpRequest} xhr
       * @param {string} url License server URL
       * @param {ArrayBuffer} keyMessage Message data issued by key-system
       * @param {function} callback Called when XHR has succeeded
       *
       */

  }, {
    key: '_onLicenseRequestReadyStageChange',
    value: function _onLicenseRequestReadyStageChange(xhr, url, keyMessage, callback) {
      switch (xhr.readyState) {
        case 4:
          if (xhr.status === 200) {
            this._requestLicenseFailureCount = 0;
            _logger.logger.log('License request succeeded');
            callback(xhr.response);
          } else {
            _logger.logger.error('License Request XHR failed (' + url + '). Status: ' + xhr.status + ' (' + xhr.statusText + ')');

            this._requestLicenseFailureCount++;
            if (this._requestLicenseFailureCount <= MAX_LICENSE_REQUEST_FAILURES) {
              var attemptsLeft = MAX_LICENSE_REQUEST_FAILURES - this._requestLicenseFailureCount + 1;
              _logger.logger.warn('Retrying license request, ' + attemptsLeft + ' attempts left');
              this._requestLicense(keyMessage, callback);
              return;
            }

            this.hls.trigger(_events2.default.ERROR, {
              type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
              details: _errors.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
              fatal: true
            });
          }
          break;
      }
    }

    /**
       * @param {object} keysListItem
       * @param {ArrayBuffer} keyMessage
       * @returns {ArrayBuffer} Challenge data posted to license server
       */

  }, {
    key: '_generateLicenseRequestChallenge',
    value: function _generateLicenseRequestChallenge(keysListItem, keyMessage) {
      var challenge = void 0;

      if (keysListItem.mediaKeySystemDomain === KeySystems.PLAYREADY) {
        _logger.logger.error('PlayReady is not supported (yet)');

        // from https://github.com/MicrosoftEdge/Demos/blob/master/eme/scripts/demo.js
        /*
          if (this.licenseType !== this.LICENSE_TYPE_WIDEVINE) {
              // For PlayReady CDMs, we need to dig the Challenge out of the XML.
              var keyMessageXml = new DOMParser().parseFromString(String.fromCharCode.apply(null, new Uint16Array(keyMessage)), 'application/xml');
              if (keyMessageXml.getElementsByTagName('Challenge')[0]) {
                  challenge = atob(keyMessageXml.getElementsByTagName('Challenge')[0].childNodes[0].nodeValue);
              } else {
                  throw 'Cannot find <Challenge> in key message';
              }
              var headerNames = keyMessageXml.getElementsByTagName('name');
              var headerValues = keyMessageXml.getElementsByTagName('value');
              if (headerNames.length !== headerValues.length) {
                  throw 'Mismatched header <name>/<value> pair in key message';
              }
              for (var i = 0; i < headerNames.length; i++) {
                  xhr.setRequestHeader(headerNames[i].childNodes[0].nodeValue, headerValues[i].childNodes[0].nodeValue);
              }
          }
          */
      } else if (keysListItem.mediaKeySystemDomain === KeySystems.WIDEVINE) {
        // For Widevine CDMs, the challenge is the keyMessage.
        challenge = keyMessage;
      } else {
        _logger.logger.error('Unsupported key-system:', keysListItem.mediaKeySystemDomain);
      }

      return challenge;
    }
  }, {
    key: '_requestLicense',
    value: function _requestLicense(keyMessage, callback) {
      _logger.logger.log('Requesting content license for key-system');

      var keysListItem = this._mediaKeysList[0];
      if (!keysListItem) {
        _logger.logger.error('Fatal error: Media is encrypted but no key-system access has been obtained yet');
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.KEY_SYSTEM_ERROR,
          details: _errors.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
          fatal: true
        });
        return;
      }

      var url = this.getLicenseServerUrl(keysListItem.mediaKeySystemDomain);
      var xhr = this._createLicenseXhr(url, keyMessage, callback);

      _logger.logger.log('Sending license request to URL: ' + url);

      xhr.send(this._generateLicenseRequestChallenge(keysListItem, keyMessage));
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var _this7 = this;

      if (!this._emeEnabled) {
        return;
      }

      var media = data.media;

      // keep reference of media
      this._media = media;

      // FIXME: also handle detaching media !

      media.addEventListener('encrypted', function (e) {
        _this7._onMediaEncrypted(e.initDataType, e.initData);
      });
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      if (!this._emeEnabled) {
        return;
      }

      var audioCodecs = data.levels.map(function (level) {
        return level.audioCodec;
      });
      var videoCodecs = data.levels.map(function (level) {
        return level.videoCodec;
      });

      this._attemptKeySystemAccess(KeySystems.WIDEVINE, audioCodecs, videoCodecs);
    }
  }, {
    key: 'requestMediaKeySystemAccess',
    get: function get() {
      if (!this._requestMediaKeySystemAccess) {
        throw new Error('No requestMediaKeySystemAccess function configured');
      }

      return this._requestMediaKeySystemAccess;
    }
  }]);

  return EMEController;
}(_eventHandler2.default);

exports.default = EMEController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/fps-controller.js":
/*!*************************************************!*\
  !*** ./src/hls.js/controller/fps-controller.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FPS Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var _window = window,
    performance = _window.performance;

var FPSController = function (_EventHandler) {
  _inherits(FPSController, _EventHandler);

  function FPSController(hls) {
    _classCallCheck(this, FPSController);

    return _possibleConstructorReturn(this, (FPSController.__proto__ || Object.getPrototypeOf(FPSController)).call(this, hls, _events2.default.MEDIA_ATTACHING));
  }

  _createClass(FPSController, [{
    key: 'destroy',
    value: function destroy() {
      if (this.timer) {
        clearInterval(this.timer);
      }

      this.isVideoPlaybackQualityAvailable = false;
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      var config = this.hls.config;
      if (config.capLevelOnFPSDrop) {
        var video = this.video = data.media instanceof window.HTMLVideoElement ? data.media : null;
        if (typeof video.getVideoPlaybackQuality === 'function') {
          this.isVideoPlaybackQualityAvailable = true;
        }

        clearInterval(this.timer);
        this.timer = setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
      }
    }
  }, {
    key: 'checkFPS',
    value: function checkFPS(video, decodedFrames, droppedFrames) {
      var currentTime = performance.now();
      if (decodedFrames) {
        if (this.lastTime) {
          var currentPeriod = currentTime - this.lastTime,
              currentDropped = droppedFrames - this.lastDroppedFrames,
              currentDecoded = decodedFrames - this.lastDecodedFrames,
              droppedFPS = 1000 * currentDropped / currentPeriod,
              hls = this.hls;
          hls.trigger(_events2.default.FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });
          if (droppedFPS > 0) {
            // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
            if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
              var currentLevel = hls.currentLevel;
              _logger.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);
              if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
                currentLevel = currentLevel - 1;
                hls.trigger(_events2.default.FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: hls.currentLevel });
                hls.autoLevelCapping = currentLevel;
                hls.streamController.nextLevelSwitch();
              }
            }
          }
        }
        this.lastTime = currentTime;
        this.lastDroppedFrames = droppedFrames;
        this.lastDecodedFrames = decodedFrames;
      }
    }
  }, {
    key: 'checkFPSInterval',
    value: function checkFPSInterval() {
      var video = this.video;
      if (video) {
        if (this.isVideoPlaybackQualityAvailable) {
          var videoPlaybackQuality = video.getVideoPlaybackQuality();
          this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
        } else {
          this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
        }
      }
    }
  }]);

  return FPSController;
}(_eventHandler2.default);

exports.default = FPSController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/fragment-finders.js":
/*!***************************************************!*\
  !*** ./src/hls.js/controller/fragment-finders.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findFragmentByPDT = findFragmentByPDT;
exports.findFragmentByPTS = findFragmentByPTS;
exports.fragmentWithinToleranceTest = fragmentWithinToleranceTest;
exports.pdtWithinToleranceTest = pdtWithinToleranceTest;

var _binarySearch = __webpack_require__(/*! ../utils/binary-search */ "./src/hls.js/utils/binary-search.js");

var _binarySearch2 = _interopRequireDefault(_binarySearch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns first fragment whose endPdt value exceeds the given PDT.
 * @param {Array<Fragment>} fragments - The array of candidate fragments
 * @param {number|null} [PDTValue = null] - The PDT value which must be exceeded
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start/end can be within in order to be considered contiguous
 * @returns {*|null} fragment - The best matching fragment
 */
function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
  if (!Array.isArray(fragments) || !fragments.length || !Number.isFinite(PDTValue)) {
    return null;
  }

  // if less than start
  if (PDTValue < fragments[0].programDateTime) {
    return null;
  }

  if (PDTValue >= fragments[fragments.length - 1].endProgramDateTime) {
    return null;
  }

  maxFragLookUpTolerance = maxFragLookUpTolerance || 0;
  for (var seg = 0; seg < fragments.length; ++seg) {
    var frag = fragments[seg];
    if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
      return frag;
    }
  }

  return null;
}

/**
 * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.
 * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus
 * breaking any traps which would cause the same fragment to be continuously selected within a small range.
 * @param {*} fragPrevious - The last frag successfully appended
 * @param {Array<Fragment>} fragments - The array of candidate fragments
 * @param {number} [bufferEnd = 0] - The end of the contiguous buffered range the playhead is currently within
 * @param {number} maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous
 * @returns {*} foundFrag - The best matching fragment
 */
function findFragmentByPTS(fragPrevious, fragments) {
  var bufferEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var maxFragLookUpTolerance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : null;
  // Prefer the next fragment if it's within tolerance
  if (fragNext && !fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext)) {
    return fragNext;
  }
  return _binarySearch2.default.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));
}

/**
 * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.
 * @param {*} candidate - The fragment to test
 * @param {number} [bufferEnd = 0] - The end of the current buffered range the playhead is currently within
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous
 * @returns {number} - 0 if it matches, 1 if too low, -1 if too high
 */
function fragmentWithinToleranceTest() {
  var bufferEnd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var maxFragLookUpTolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var candidate = arguments[2];

  // offset should be within fragment boundary - config.maxFragLookUpTolerance
  // this is to cope with situations like
  // bufferEnd = 9.991
  // frag[Ø] : [0,10]
  // frag[1] : [10,20]
  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
  //              frag start               frag start+duration
  //                  |-----------------------------|
  //              <--->                         <--->
  //  ...--------><-----------------------------><---------....
  // previous frag         matching fragment         next frag
  //  return -1             return 0                 return 1
  // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
    return 1;
  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
    // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
    return -1;
  }

  return 0;
}

/**
 * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.
 * This function tests the candidate's program date time values, as represented in Unix time
 * @param {*} candidate - The fragment to test
 * @param {number} [pdtBufferEnd = 0] - The Unix time representing the end of the current buffered range
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous
 * @returns {boolean} True if contiguous, false otherwise
 */
function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;
  return candidate.endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
}

/***/ }),

/***/ "./src/hls.js/controller/fragment-tracker.js":
/*!***************************************************!*\
  !*** ./src/hls.js/controller/fragment-tracker.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FragmentTracker = exports.FragmentState = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FragmentState = exports.FragmentState = {
  NOT_LOADED: 'NOT_LOADED',
  APPENDING: 'APPENDING',
  PARTIAL: 'PARTIAL',
  OK: 'OK'
};

var FragmentTracker = exports.FragmentTracker = function (_EventHandler) {
  _inherits(FragmentTracker, _EventHandler);

  function FragmentTracker(hls) {
    _classCallCheck(this, FragmentTracker);

    var _this = _possibleConstructorReturn(this, (FragmentTracker.__proto__ || Object.getPrototypeOf(FragmentTracker)).call(this, hls, _events2.default.BUFFER_APPENDED, _events2.default.FRAG_BUFFERED, _events2.default.FRAG_LOADED));

    _this.bufferPadding = 0.2;

    _this.fragments = Object.create(null);
    _this.timeRanges = Object.create(null);

    _this.config = hls.config;
    return _this;
  }

  _createClass(FragmentTracker, [{
    key: 'destroy',
    value: function destroy() {
      this.fragments = Object.create(null);
      this.timeRanges = Object.create(null);
      this.config = null;
      _eventHandler2.default.prototype.destroy.call(this);
      _get(FragmentTracker.prototype.__proto__ || Object.getPrototypeOf(FragmentTracker.prototype), 'destroy', this).call(this);
    }

    /**
     * Return a Fragment that match the position and levelType.
     * If not found any Fragment, return null
     * @param {number} position
     * @param {LevelType} levelType
     * @returns {Fragment|null}
     */

  }, {
    key: 'getBufferedFrag',
    value: function getBufferedFrag(position, levelType) {
      var fragments = this.fragments;
      var bufferedFrags = Object.keys(fragments).filter(function (key) {
        var fragmentEntity = fragments[key];
        if (fragmentEntity.body.type !== levelType) {
          return false;
        }

        if (!fragmentEntity.buffered) {
          return false;
        }

        var frag = fragmentEntity.body;
        return frag.startPTS <= position && position <= frag.endPTS;
      });
      if (bufferedFrags.length === 0) {
        return null;
      } else {
        // https://github.com/video-dev/hls.js/pull/1545#discussion_r166229566
        var bufferedFragKey = bufferedFrags.pop();
        return fragments[bufferedFragKey].body;
      }
    }

    /**
     * Partial fragments effected by coded frame eviction will be removed
     * The browser will unload parts of the buffer to free up memory for new buffer data
     * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
     * @param {String} elementaryStream The elementaryStream of media this is (eg. video/audio)
     * @param {TimeRanges} timeRange TimeRange object from a sourceBuffer
     */

  }, {
    key: 'detectEvictedFragments',
    value: function detectEvictedFragments(elementaryStream, timeRange) {
      var _this2 = this;

      var fragmentTimes = void 0,
          time = void 0;
      // Check if any flagged fragments have been unloaded
      Object.keys(this.fragments).forEach(function (key) {
        var fragmentEntity = _this2.fragments[key];
        if (fragmentEntity.buffered === true) {
          var esData = fragmentEntity.range[elementaryStream];
          if (esData) {
            fragmentTimes = esData.time;
            for (var i = 0; i < fragmentTimes.length; i++) {
              time = fragmentTimes[i];

              if (_this2.isTimeBuffered(time.startPTS, time.endPTS, timeRange) === false) {
                // Unregister partial fragment as it needs to load again to be reused
                _this2.removeFragment(fragmentEntity.body);
                break;
              }
            }
          }
        }
      });
    }

    /**
     * Checks if the fragment passed in is loaded in the buffer properly
     * Partially loaded fragments will be registered as a partial fragment
     * @param {Object} fragment Check the fragment against all sourceBuffers loaded
     */

  }, {
    key: 'detectPartialFragments',
    value: function detectPartialFragments(fragment) {
      var _this3 = this;

      var fragKey = this.getFragmentKey(fragment);
      var fragmentEntity = this.fragments[fragKey];
      if (fragmentEntity) {
        fragmentEntity.buffered = true;

        Object.keys(this.timeRanges).forEach(function (elementaryStream) {
          if (fragment.hasElementaryStream(elementaryStream)) {
            var timeRange = _this3.timeRanges[elementaryStream];
            // Check for malformed fragments
            // Gaps need to be calculated for each elementaryStream
            fragmentEntity.range[elementaryStream] = _this3.getBufferedTimes(fragment.startPTS, fragment.endPTS, timeRange);
          }
        });
      }
    }
  }, {
    key: 'getBufferedTimes',
    value: function getBufferedTimes(startPTS, endPTS, timeRange) {
      var fragmentTimes = [];
      var startTime = void 0,
          endTime = void 0;
      var fragmentPartial = false;
      for (var i = 0; i < timeRange.length; i++) {
        startTime = timeRange.start(i) - this.bufferPadding;
        endTime = timeRange.end(i) + this.bufferPadding;
        if (startPTS >= startTime && endPTS <= endTime) {
          // Fragment is entirely contained in buffer
          // No need to check the other timeRange times since it's completely playable
          fragmentTimes.push({
            startPTS: Math.max(startPTS, timeRange.start(i)),
            endPTS: Math.min(endPTS, timeRange.end(i))
          });
          break;
        } else if (startPTS < endTime && endPTS > startTime) {
          // Check for intersection with buffer
          // Get playable sections of the fragment
          fragmentTimes.push({
            startPTS: Math.max(startPTS, timeRange.start(i)),
            endPTS: Math.min(endPTS, timeRange.end(i))
          });
          fragmentPartial = true;
        } else if (endPTS <= startTime) {
          // No need to check the rest of the timeRange as it is in order
          break;
        }
      }

      return {
        time: fragmentTimes,
        partial: fragmentPartial
      };
    }
  }, {
    key: 'getFragmentKey',
    value: function getFragmentKey(fragment) {
      return fragment.type + '_' + fragment.level + '_' + fragment.urlId + '_' + fragment.sn;
    }

    /**
     * Gets the partial fragment for a certain time
     * @param {Number} time
     * @returns {Object} fragment Returns a partial fragment at a time or null if there is no partial fragment
     */

  }, {
    key: 'getPartialFragment',
    value: function getPartialFragment(time) {
      var _this4 = this;

      var timePadding = void 0,
          startTime = void 0,
          endTime = void 0;
      var bestFragment = null;
      var bestOverlap = 0;
      Object.keys(this.fragments).forEach(function (key) {
        var fragmentEntity = _this4.fragments[key];
        if (_this4.isPartial(fragmentEntity)) {
          startTime = fragmentEntity.body.startPTS - _this4.bufferPadding;
          endTime = fragmentEntity.body.endPTS + _this4.bufferPadding;
          if (time >= startTime && time <= endTime) {
            // Use the fragment that has the most padding from start and end time
            timePadding = Math.min(time - startTime, endTime - time);
            if (bestOverlap <= timePadding) {
              bestFragment = fragmentEntity.body;
              bestOverlap = timePadding;
            }
          }
        }
      });
      return bestFragment;
    }

    /**
     * @param {Object} fragment The fragment to check
     * @returns {String} Returns the fragment state when a fragment never loaded or if it partially loaded
     */

  }, {
    key: 'getState',
    value: function getState(fragment) {
      var fragKey = this.getFragmentKey(fragment);
      var fragmentEntity = this.fragments[fragKey];
      var state = FragmentState.NOT_LOADED;

      if (fragmentEntity !== undefined) {
        if (!fragmentEntity.buffered) {
          state = FragmentState.APPENDING;
        } else if (this.isPartial(fragmentEntity) === true) {
          state = FragmentState.PARTIAL;
        } else {
          state = FragmentState.OK;
        }
      }

      return state;
    }
  }, {
    key: 'isPartial',
    value: function isPartial(fragmentEntity) {
      return fragmentEntity.buffered === true && (fragmentEntity.range.video !== undefined && fragmentEntity.range.video.partial === true || fragmentEntity.range.audio !== undefined && fragmentEntity.range.audio.partial === true);
    }
  }, {
    key: 'isTimeBuffered',
    value: function isTimeBuffered(startPTS, endPTS, timeRange) {
      var startTime = void 0,
          endTime = void 0;
      for (var i = 0; i < timeRange.length; i++) {
        startTime = timeRange.start(i) - this.bufferPadding;
        endTime = timeRange.end(i) + this.bufferPadding;
        if (startPTS >= startTime && endPTS <= endTime) {
          return true;
        }

        if (endPTS <= startTime) {
          // No need to check the rest of the timeRange as it is in order
          return false;
        }
      }

      return false;
    }

    /**
     * Fires when a fragment loading is completed
     */

  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(e) {
      var fragment = e.frag;
      // don't track initsegment (for which sn is not a number)
      // don't track frags used for bitrateTest, they're irrelevant.
      if (!Number.isFinite(fragment.sn) || fragment.bitrateTest) {
        return;
      }

      this.fragments[this.getFragmentKey(fragment)] = {
        body: fragment,
        range: Object.create(null),
        buffered: false
      };
    }

    /**
     * Fires when the buffer is updated
     */

  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(e) {
      var _this5 = this;

      // Store the latest timeRanges loaded in the buffer
      this.timeRanges = e.timeRanges;
      Object.keys(this.timeRanges).forEach(function (elementaryStream) {
        var timeRange = _this5.timeRanges[elementaryStream];
        _this5.detectEvictedFragments(elementaryStream, timeRange);
      });
    }

    /**
     * Fires after a fragment has been loaded into the source buffer
     */

  }, {
    key: 'onFragBuffered',
    value: function onFragBuffered(e) {
      this.detectPartialFragments(e.frag);
    }

    /**
     * Return true if fragment tracker has the fragment.
     * @param {Object} fragment
     * @returns {boolean}
     */

  }, {
    key: 'hasFragment',
    value: function hasFragment(fragment) {
      var fragKey = this.getFragmentKey(fragment);
      return this.fragments[fragKey] !== undefined;
    }

    /**
     * Remove a fragment from fragment tracker until it is loaded again
     * @param {Object} fragment The fragment to remove
     */

  }, {
    key: 'removeFragment',
    value: function removeFragment(fragment) {
      var fragKey = this.getFragmentKey(fragment);
      delete this.fragments[fragKey];
    }

    /**
     * Remove all fragments from fragment tracker.
     */

  }, {
    key: 'removeAllFragments',
    value: function removeAllFragments() {
      this.fragments = Object.create(null);
    }
  }]);

  return FragmentTracker;
}(_eventHandler2.default);

/***/ }),

/***/ "./src/hls.js/controller/gap-controller.js":
/*!*************************************************!*\
  !*** ./src/hls.js/controller/gap-controller.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var stallDebounceInterval = 1000;
var jumpThreshold = 0.5; // tolerance needed as some browsers stalls playback before reaching buffered range end

var GapController = function () {
  function GapController(config, media, fragmentTracker, hls) {
    _classCallCheck(this, GapController);

    this.config = config;
    this.media = media;
    this.fragmentTracker = fragmentTracker;
    this.hls = hls;
    this.stallReported = false;
  }

  /**
   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.
   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).
   * @param lastCurrentTime
   * @param buffered
   */


  _createClass(GapController, [{
    key: 'poll',
    value: function poll(lastCurrentTime, buffered) {
      var config = this.config,
          media = this.media;

      var currentTime = media.currentTime;
      var tnow = window.performance.now();

      if (currentTime !== lastCurrentTime) {
        // The playhead is now moving, but was previously stalled
        if (this.stallReported) {
          _logger.logger.warn('playback not stuck anymore @' + currentTime + ', after ' + Math.round(tnow - this.stalled) + 'ms');
          this.stallReported = false;
        }
        this.stalled = null;
        this.nudgeRetry = 0;
        return;
      }

      if (media.ended || !media.buffered.length || media.readyState > 2) {
        return;
      }

      if (media.seeking && _bufferHelper.BufferHelper.isBuffered(media, currentTime)) {
        return;
      }

      // The playhead isn't moving but it should be
      // Allow some slack time to for small stalls to resolve themselves
      var stalledDuration = tnow - this.stalled;
      var bufferInfo = _bufferHelper.BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);
      if (!this.stalled) {
        this.stalled = tnow;
        return;
      } else if (stalledDuration >= stallDebounceInterval) {
        // Report stalling after trying to fix
        this._reportStall(bufferInfo.len);
      }

      this._tryFixBufferStall(bufferInfo, stalledDuration);
    }

    /**
     * Detects and attempts to fix known buffer stalling issues.
     * @param bufferInfo - The properties of the current buffer.
     * @param stalledDuration - The amount of time Hls.js has been stalling for.
     * @private
     */

  }, {
    key: '_tryFixBufferStall',
    value: function _tryFixBufferStall(bufferInfo, stalledDuration) {
      var config = this.config,
          fragmentTracker = this.fragmentTracker,
          media = this.media;

      var currentTime = media.currentTime;

      var partial = fragmentTracker.getPartialFragment(currentTime);
      if (partial) {
        // Try to skip over the buffer hole caused by a partial fragment
        // This method isn't limited by the size of the gap between buffered ranges
        this._trySkipBufferHole(partial);
      }

      if (bufferInfo.len > jumpThreshold && stalledDuration > config.highBufferWatchdogPeriod * 1000) {
        // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds
        // We only try to jump the hole if it's under the configured size
        // Reset stalled so to rearm watchdog timer
        this.stalled = null;
        this._tryNudgeBuffer();
      }
    }

    /**
     * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.
     * @param bufferLen - The playhead distance from the end of the current buffer segment.
     * @private
     */

  }, {
    key: '_reportStall',
    value: function _reportStall(bufferLen) {
      var hls = this.hls,
          media = this.media,
          stallReported = this.stallReported;

      if (!stallReported) {
        // Report stalled error once
        this.stallReported = true;
        _logger.logger.warn('Playback stalling at @' + media.currentTime + ' due to low buffer');
        hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.BUFFER_STALLED_ERROR,
          fatal: false,
          buffer: bufferLen
        });
      }
    }

    /**
     * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments
     * @param partial - The partial fragment found at the current time (where playback is stalling).
     * @private
     */

  }, {
    key: '_trySkipBufferHole',
    value: function _trySkipBufferHole(partial) {
      var hls = this.hls,
          media = this.media;

      var currentTime = media.currentTime;
      var lastEndTime = 0;
      // Check if currentTime is between unbuffered regions of partial fragments
      for (var i = 0; i < media.buffered.length; i++) {
        var startTime = media.buffered.start(i);
        if (currentTime >= lastEndTime && currentTime < startTime) {
          media.currentTime = Math.max(startTime, media.currentTime + 0.1);
          _logger.logger.warn('skipping hole, adjusting currentTime from ' + currentTime + ' to ' + media.currentTime);
          this.stalled = null;
          hls.trigger(_events2.default.ERROR, {
            type: _errors.ErrorTypes.MEDIA_ERROR,
            details: _errors.ErrorDetails.BUFFER_SEEK_OVER_HOLE,
            fatal: false,
            reason: 'fragment loaded with buffer holes, seeking from ' + currentTime + ' to ' + media.currentTime,
            frag: partial
          });
          return;
        }
        lastEndTime = media.buffered.end(i);
      }
    }

    /**
     * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.
     * @private
     */

  }, {
    key: '_tryNudgeBuffer',
    value: function _tryNudgeBuffer() {
      var config = this.config,
          hls = this.hls,
          media = this.media;

      var currentTime = media.currentTime;
      var nudgeRetry = (this.nudgeRetry || 0) + 1;
      this.nudgeRetry = nudgeRetry;

      if (nudgeRetry < config.nudgeMaxRetry) {
        var targetTime = currentTime + nudgeRetry * config.nudgeOffset;
        _logger.logger.log('adjust currentTime from ' + currentTime + ' to ' + targetTime);
        // playback stalled in buffered area ... let's nudge currentTime to try to overcome this
        media.currentTime = targetTime;
        hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.BUFFER_NUDGE_ON_STALL,
          fatal: false
        });
      } else {
        _logger.logger.error('still stuck in high buffer @' + currentTime + ' after ' + config.nudgeMaxRetry + ', raise fatal error');
        hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.BUFFER_STALLED_ERROR,
          fatal: true
        });
      }
    }
  }]);

  return GapController;
}();

exports.default = GapController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/id3-track-controller.js":
/*!*******************************************************!*\
  !*** ./src/hls.js/controller/id3-track-controller.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _id = __webpack_require__(/*! ../demux/id3 */ "./src/hls.js/demux/id3.js");

var _id2 = _interopRequireDefault(_id);

var _texttrackUtils = __webpack_require__(/*! ../utils/texttrack-utils */ "./src/hls.js/utils/texttrack-utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * id3 metadata track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var ID3TrackController = function (_EventHandler) {
  _inherits(ID3TrackController, _EventHandler);

  function ID3TrackController(hls) {
    _classCallCheck(this, ID3TrackController);

    var _this = _possibleConstructorReturn(this, (ID3TrackController.__proto__ || Object.getPrototypeOf(ID3TrackController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_METADATA));

    _this.id3Track = undefined;
    _this.media = undefined;
    return _this;
  }

  _createClass(ID3TrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }

    // Add ID3 metatadata text track.

  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      this.media = data.media;
      if (!this.media) {}
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      (0, _texttrackUtils.clearCurrentCues)(this.id3Track);
      this.id3Track = undefined;
      this.media = undefined;
    }
  }, {
    key: 'getID3Track',
    value: function getID3Track(textTracks) {
      for (var i = 0; i < textTracks.length; i++) {
        var textTrack = textTracks[i];
        if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {
          // send 'addtrack' when reusing the textTrack for metadata,
          // same as what we do for captions
          (0, _texttrackUtils.sendAddTrackEvent)(textTrack, this.media);

          return textTrack;
        }
      }
      return this.media.addTextTrack('metadata', 'id3');
    }
  }, {
    key: 'onFragParsingMetadata',
    value: function onFragParsingMetadata(data) {
      var fragment = data.frag;
      var samples = data.samples;

      // create track dynamically
      if (!this.id3Track) {
        this.id3Track = this.getID3Track(this.media.textTracks);
        this.id3Track.mode = 'hidden';
      }

      // Attempt to recreate Safari functionality by creating
      // WebKitDataCue objects when available and store the decoded
      // ID3 data in the value property of the cue
      var Cue = window.WebKitDataCue || window.VTTCue || window.TextTrackCue;

      for (var i = 0; i < samples.length; i++) {
        var frames = _id2.default.getID3Frames(samples[i].data);
        if (frames) {
          var startTime = samples[i].pts;
          var endTime = i < samples.length - 1 ? samples[i + 1].pts : fragment.endPTS;

          // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
          if (startTime === endTime) {
            endTime += 0.0001;
          }

          for (var j = 0; j < frames.length; j++) {
            var frame = frames[j];
            // Safari doesn't put the timestamp frame in the TextTrack
            if (!_id2.default.isTimeStampFrame(frame)) {
              var cue = new Cue(startTime, endTime, '');
              cue.value = frame;
              this.id3Track.addCue(cue);
            }
          }
        }
      }
    }
  }]);

  return ID3TrackController;
}(_eventHandler2.default);

exports.default = ID3TrackController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/level-controller.js":
/*!***************************************************!*\
  !*** ./src/hls.js/controller/level-controller.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _codecs = __webpack_require__(/*! ../utils/codecs */ "./src/hls.js/utils/codecs.js");

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Level Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var _window = window,
    performance = _window.performance;

var chromeOrFirefox = void 0;

var LevelController = function (_EventHandler) {
  _inherits(LevelController, _EventHandler);

  function LevelController(hls) {
    _classCallCheck(this, LevelController);

    var _this = _possibleConstructorReturn(this, (LevelController.__proto__ || Object.getPrototypeOf(LevelController)).call(this, hls, _events2.default.MANIFEST_LOADED, _events2.default.LEVEL_LOADED, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.FRAG_LOADED, _events2.default.ERROR));

    _this.canload = false;
    _this.currentLevelIndex = null;
    _this.manualLevelIndex = -1;
    _this.timer = null;

    chromeOrFirefox = /chrome|firefox/.test(navigator.userAgent.toLowerCase());
    return _this;
  }

  _createClass(LevelController, [{
    key: 'onHandlerDestroying',
    value: function onHandlerDestroying() {
      this.clearTimer();
      this.manualLevelIndex = -1;
    }
  }, {
    key: 'clearTimer',
    value: function clearTimer() {
      if (this.timer !== null) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      var levels = this._levels;

      this.canload = true;
      this.levelRetryCount = 0;

      // clean up live level details to force reload them, and reset load errors
      if (levels) {
        levels.forEach(function (level) {
          level.loadError = 0;
          var levelDetails = level.details;
          if (levelDetails && levelDetails.live) {
            level.details = undefined;
          }
        });
      }
      // speed up live playlist refresh if timer exists
      if (this.timer !== null) {
        this.loadLevel();
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.canload = false;
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var levels = [];
      var audioTracks = [];
      var bitrateStart = void 0;
      var levelSet = {};
      var levelFromSet = null;
      var videoCodecFound = false;
      var audioCodecFound = false;

      // regroup redundant levels together
      data.levels.forEach(function (level) {
        var attributes = level.attrs;
        level.loadError = 0;
        level.fragmentError = false;

        videoCodecFound = videoCodecFound || !!level.videoCodec;
        audioCodecFound = audioCodecFound || !!level.audioCodec;

        // erase audio codec info if browser does not support mp4a.40.34.
        // demuxer will autodetect codec and fallback to mpeg/audio
        if (chromeOrFirefox && level.audioCodec && level.audioCodec.indexOf('mp4a.40.34') !== -1) {
          level.audioCodec = undefined;
        }

        levelFromSet = levelSet[level.bitrate]; // FIXME: we would also have to match the resolution here

        if (!levelFromSet) {
          level.url = [level.url];
          level.urlId = 0;
          levelSet[level.bitrate] = level;
          levels.push(level);
        } else {
          levelFromSet.url.push(level.url);
        }

        if (attributes) {
          if (attributes.AUDIO) {
            audioCodecFound = true;
            (0, _levelHelper.addGroupId)(levelFromSet || level, 'audio', attributes.AUDIO);
          }
          if (attributes.SUBTITLES) {
            (0, _levelHelper.addGroupId)(levelFromSet || level, 'text', attributes.SUBTITLES);
          }
        }
      });

      // remove audio-only level if we also have levels with audio+video codecs signalled
      if (videoCodecFound && audioCodecFound) {
        levels = levels.filter(function (_ref) {
          var videoCodec = _ref.videoCodec;
          return !!videoCodec;
        });
      }

      // only keep levels with supported audio/video codecs
      levels = levels.filter(function (_ref2) {
        var audioCodec = _ref2.audioCodec,
            videoCodec = _ref2.videoCodec;

        return (!audioCodec || (0, _codecs.isCodecSupportedInMp4)(audioCodec, 'audio')) && (!videoCodec || (0, _codecs.isCodecSupportedInMp4)(videoCodec, 'video'));
      });

      if (data.audioTracks) {
        audioTracks = data.audioTracks.filter(function (track) {
          return !track.audioCodec || (0, _codecs.isCodecSupportedInMp4)(track.audioCodec, 'audio');
        });
        // Reassign id's after filtering since they're used as array indices
        audioTracks.forEach(function (track, index) {
          track.id = index;
        });
      }

      if (levels.length > 0) {
        // start bitrate is the first bitrate of the manifest
        bitrateStart = levels[0].bitrate;
        // sort level on bitrate
        levels.sort(function (a, b) {
          return a.bitrate - b.bitrate;
        });
        this._levels = levels;
        // find index of first level in sorted levels
        for (var i = 0; i < levels.length; i++) {
          if (levels[i].bitrate === bitrateStart) {
            this._firstLevel = i;
            _logger.logger.log('manifest loaded,' + levels.length + ' level(s) found, first bitrate:' + bitrateStart);
            break;
          }
        }

        // Audio is only alternate if manifest include a URI along with the audio group tag
        this.hls.trigger(_events2.default.MANIFEST_PARSED, {
          levels: levels,
          audioTracks: audioTracks,
          firstLevel: this._firstLevel,
          stats: data.stats,
          audio: audioCodecFound,
          video: videoCodecFound,
          altAudio: audioTracks.some(function (t) {
            return !!t.url;
          })
        });
      } else {
        this.hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.MEDIA_ERROR,
          details: _errors.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
          fatal: true,
          url: this.hls.url,
          reason: 'no level with compatible codecs found in manifest'
        });
      }
    }
  }, {
    key: 'setLevelInternal',
    value: function setLevelInternal(newLevel) {
      var levels = this._levels;
      var hls = this.hls;
      // check if level idx is valid
      if (newLevel >= 0 && newLevel < levels.length) {
        // stopping live reloading timer if any
        this.clearTimer();
        if (this.currentLevelIndex !== newLevel) {
          _logger.logger.log('switching to level ' + newLevel);
          this.currentLevelIndex = newLevel;
          var levelProperties = levels[newLevel];
          levelProperties.level = newLevel;
          hls.trigger(_events2.default.LEVEL_SWITCHING, levelProperties);
        }
        var level = levels[newLevel];
        var levelDetails = level.details;

        // check if we need to load playlist for this level
        if (!levelDetails || levelDetails.live) {
          // level not retrieved yet, or live playlist we need to (re)load it
          var urlId = level.urlId;
          hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: newLevel, id: urlId });
        }
      } else {
        // invalid level id given, trigger error
        hls.trigger(_events2.default.ERROR, {
          type: _errors.ErrorTypes.OTHER_ERROR,
          details: _errors.ErrorDetails.LEVEL_SWITCH_ERROR,
          level: newLevel,
          fatal: false,
          reason: 'invalid level idx'
        });
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      if (data.fatal) {
        if (data.type === _errors.ErrorTypes.NETWORK_ERROR) {
          this.clearTimer();
        }

        return;
      }

      var levelError = false,
          fragmentError = false;
      var levelIndex = void 0;

      // try to recover not fatal errors
      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          levelIndex = data.frag.level;
          fragmentError = true;
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          levelIndex = data.context.level;
          levelError = true;
          break;
        case _errors.ErrorDetails.REMUX_ALLOC_ERROR:
          levelIndex = data.level;
          levelError = true;
          break;
      }

      if (levelIndex !== undefined) {
        this.recoverLevel(data, levelIndex, levelError, fragmentError);
      }
    }

    /**
     * Switch to a redundant stream if any available.
     * If redundant stream is not available, emergency switch down if ABR mode is enabled.
     *
     * @param {Object} errorEvent
     * @param {Number} levelIndex current level index
     * @param {Boolean} levelError
     * @param {Boolean} fragmentError
     */
    // FIXME Find a better abstraction where fragment/level retry management is well decoupled

  }, {
    key: 'recoverLevel',
    value: function recoverLevel(errorEvent, levelIndex, levelError, fragmentError) {
      var _this2 = this;

      var config = this.hls.config;
      var errorDetails = errorEvent.details;

      var level = this._levels[levelIndex];
      var redundantLevels = void 0,
          delay = void 0,
          nextLevel = void 0;

      level.loadError++;
      level.fragmentError = fragmentError;

      if (levelError) {
        if (this.levelRetryCount + 1 <= config.levelLoadingMaxRetry) {
          // exponential backoff capped to max retry timeout
          delay = Math.min(Math.pow(2, this.levelRetryCount) * config.levelLoadingRetryDelay, config.levelLoadingMaxRetryTimeout);
          // Schedule level reload
          this.timer = setTimeout(function () {
            return _this2.loadLevel();
          }, delay);
          // boolean used to inform stream controller not to switch back to IDLE on non fatal error
          errorEvent.levelRetry = true;
          this.levelRetryCount++;
          _logger.logger.warn('level controller, ' + errorDetails + ', retry in ' + delay + ' ms, current retry count is ' + this.levelRetryCount);
        } else {
          _logger.logger.error('level controller, cannot recover from ' + errorDetails + ' error');
          this.currentLevelIndex = null;
          // stopping live reloading timer if any
          this.clearTimer();
          // switch error to fatal
          errorEvent.fatal = true;
          return;
        }
      }

      // Try any redundant streams if available for both errors: level and fragment
      // If level.loadError reaches redundantLevels it means that we tried them all, no hope  => let's switch down
      if (levelError || fragmentError) {
        redundantLevels = level.url.length;

        if (redundantLevels > 1 && level.loadError < redundantLevels) {
          level.urlId = (level.urlId + 1) % redundantLevels;
          level.details = undefined;

          _logger.logger.warn('level controller, ' + errorDetails + ' for level ' + levelIndex + ': switching to redundant URL-id ' + level.urlId);

          // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);
          // console.log('New video quality level audio group id:', level.attrs.AUDIO);
        } else {
          // Search for available level
          if (this.manualLevelIndex === -1) {
            // When lowest level has been reached, let's start hunt from the top
            nextLevel = levelIndex === 0 ? this._levels.length - 1 : levelIndex - 1;
            _logger.logger.warn('level controller, ' + errorDetails + ': switch to ' + nextLevel);
            this.hls.nextAutoLevel = this.currentLevelIndex = nextLevel;
          } else if (fragmentError) {
            // Allow fragment retry as long as configuration allows.
            // reset this._level so that another call to set level() will trigger again a frag load
            _logger.logger.warn('level controller, ' + errorDetails + ': reload a fragment');
            this.currentLevelIndex = null;
          }
        }
      }
    }

    // reset errors on the successful load of a fragment

  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(_ref3) {
      var frag = _ref3.frag;

      if (frag !== undefined && frag.type === 'main') {
        var level = this._levels[frag.level];
        if (level !== undefined) {
          level.fragmentError = false;
          level.loadError = 0;
          this.levelRetryCount = 0;
        }
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var _this3 = this;

      var level = data.level,
          details = data.details;
      // only process level loaded events matching with expected level

      if (level !== this.currentLevelIndex) {
        return;
      }

      var curLevel = this._levels[level];
      // reset level load error counter on successful level loaded only if there is no issues with fragments
      if (!curLevel.fragmentError) {
        curLevel.loadError = 0;
        this.levelRetryCount = 0;
      }
      // if current playlist is a live playlist, arm a timer to reload it
      if (details.live) {
        var reloadInterval = (0, _levelHelper.computeReloadInterval)(curLevel.details, details, data.stats.trequest);
        _logger.logger.log('live playlist, reload in ' + Math.round(reloadInterval) + ' ms');
        this.timer = setTimeout(function () {
          return _this3.loadLevel();
        }, reloadInterval);
      } else {
        this.clearTimer();
      }
    }
  }, {
    key: 'onAudioTrackSwitched',
    value: function onAudioTrackSwitched(data) {
      var audioGroupId = this.hls.audioTracks[data.id].groupId;

      var currentLevel = this.hls.levels[this.currentLevelIndex];
      if (!currentLevel) {
        return;
      }

      if (currentLevel.audioGroupIds) {
        var urlId = -1;

        for (var i = 0; i < currentLevel.audioGroupIds.length; i++) {
          if (currentLevel.audioGroupIds[i] === audioGroupId) {
            urlId = i;
            break;
          }
        }

        if (urlId !== currentLevel.urlId) {
          currentLevel.urlId = urlId;
          this.startLoad();
        }
      }
    }
  }, {
    key: 'loadLevel',
    value: function loadLevel() {
      _logger.logger.debug('call to loadLevel');

      if (this.currentLevelIndex !== null && this.canload) {
        var levelObject = this._levels[this.currentLevelIndex];

        if ((typeof levelObject === 'undefined' ? 'undefined' : _typeof(levelObject)) === 'object' && levelObject.url.length > 0) {
          var level = this.currentLevelIndex;
          var id = levelObject.urlId;
          var url = levelObject.url[id];

          _logger.logger.log('Attempt loading level index ' + level + ' with URL-id ' + id);

          // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);
          // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);

          this.hls.trigger(_events2.default.LEVEL_LOADING, { url: url, level: level, id: id });
        }
      }
    }
  }, {
    key: 'levels',
    get: function get() {
      return this._levels;
    }
  }, {
    key: 'level',
    get: function get() {
      return this.currentLevelIndex;
    },
    set: function set(newLevel) {
      var levels = this._levels;
      if (levels) {
        newLevel = Math.min(newLevel, levels.length - 1);
        if (this.currentLevelIndex !== newLevel || !levels[newLevel].details) {
          this.setLevelInternal(newLevel);
        }
      }
    }
  }, {
    key: 'manualLevel',
    get: function get() {
      return this.manualLevelIndex;
    },
    set: function set(newLevel) {
      this.manualLevelIndex = newLevel;
      if (this._startLevel === undefined) {
        this._startLevel = newLevel;
      }

      if (newLevel !== -1) {
        this.level = newLevel;
      }
    }
  }, {
    key: 'firstLevel',
    get: function get() {
      return this._firstLevel;
    },
    set: function set(newLevel) {
      this._firstLevel = newLevel;
    }
  }, {
    key: 'startLevel',
    get: function get() {
      // hls.startLevel takes precedence over config.startLevel
      // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)
      if (this._startLevel === undefined) {
        var configStartLevel = this.hls.config.startLevel;
        if (configStartLevel !== undefined) {
          return configStartLevel;
        } else {
          return this._firstLevel;
        }
      } else {
        return this._startLevel;
      }
    },
    set: function set(newLevel) {
      this._startLevel = newLevel;
    }
  }, {
    key: 'nextLoadLevel',
    get: function get() {
      if (this.manualLevelIndex !== -1) {
        return this.manualLevelIndex;
      } else {
        return this.hls.nextAutoLevel;
      }
    },
    set: function set(nextLevel) {
      this.level = nextLevel;
      if (this.manualLevelIndex === -1) {
        this.hls.nextAutoLevel = nextLevel;
      }
    }
  }]);

  return LevelController;
}(_eventHandler2.default);

exports.default = LevelController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/level-helper.js":
/*!***********************************************!*\
  !*** ./src/hls.js/controller/level-helper.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addGroupId = addGroupId;
exports.updatePTS = updatePTS;
exports.updateFragPTSDTS = updateFragPTSDTS;
exports.mergeDetails = mergeDetails;
exports.mergeSubtitlePlaylists = mergeSubtitlePlaylists;
exports.mapFragmentIntersection = mapFragmentIntersection;
exports.adjustSliding = adjustSliding;
exports.computeReloadInterval = computeReloadInterval;

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function addGroupId(level, type, id) {
  switch (type) {
    case 'audio':
      if (!level.audioGroupIds) {
        level.audioGroupIds = [];
      }
      level.audioGroupIds.push(id);
      break;
    case 'text':
      if (!level.textGroupIds) {
        level.textGroupIds = [];
      }
      level.textGroupIds.push(id);
      break;
  }
} /**
   * @module LevelHelper
   *
   * Providing methods dealing with playlist sliding and drift
   *
   * TODO: Create an actual `Level` class/model that deals with all this logic in an object-oriented-manner.
   *
   * */

function updatePTS(fragments, fromIdx, toIdx) {
  var fragFrom = fragments[fromIdx],
      fragTo = fragments[toIdx],
      fragToPTS = fragTo.startPTS;
  // if we know startPTS[toIdx]
  if (Number.isFinite(fragToPTS)) {
    // update fragment duration.
    // it helps to fix drifts between playlist reported duration and fragment real duration
    if (toIdx > fromIdx) {
      fragFrom.duration = fragToPTS - fragFrom.start;
      if (fragFrom.duration < 0) {
        _logger.logger.warn('negative duration computed for frag ' + fragFrom.sn + ',level ' + fragFrom.level + ', there should be some duration drift between playlist and fragment!');
      }
    } else {
      fragTo.duration = fragFrom.start - fragToPTS;
      if (fragTo.duration < 0) {
        _logger.logger.warn('negative duration computed for frag ' + fragTo.sn + ',level ' + fragTo.level + ', there should be some duration drift between playlist and fragment!');
      }
    }
  } else {
    // we dont know startPTS[toIdx]
    if (toIdx > fromIdx) {
      fragTo.start = fragFrom.start + fragFrom.duration;
    } else {
      fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
    }
  }
}

function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
  // update frag PTS/DTS
  var maxStartPTS = startPTS;
  if (Number.isFinite(frag.startPTS)) {
    // delta PTS between audio and video
    var deltaPTS = Math.abs(frag.startPTS - startPTS);
    if (!Number.isFinite(frag.deltaPTS)) {
      frag.deltaPTS = deltaPTS;
    } else {
      frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
    }

    maxStartPTS = Math.max(startPTS, frag.startPTS);
    startPTS = Math.min(startPTS, frag.startPTS);
    endPTS = Math.max(endPTS, frag.endPTS);
    startDTS = Math.min(startDTS, frag.startDTS);
    endDTS = Math.max(endDTS, frag.endDTS);
  }

  var drift = startPTS - frag.start;
  frag.start = frag.startPTS = startPTS;
  frag.maxStartPTS = maxStartPTS;
  frag.endPTS = endPTS;
  frag.startDTS = startDTS;
  frag.endDTS = endDTS;
  frag.duration = endPTS - startPTS;

  var sn = frag.sn;
  // exit if sn out of range
  if (!details || sn < details.startSN || sn > details.endSN) {
    return 0;
  }

  var fragIdx = void 0,
      fragments = void 0,
      i = void 0;
  fragIdx = sn - details.startSN;
  fragments = details.fragments;
  // update frag reference in fragments array
  // rationale is that fragments array might not contain this frag object.
  // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()
  // if we don't update frag, we won't be able to propagate PTS info on the playlist
  // resulting in invalid sliding computation
  fragments[fragIdx] = frag;
  // adjust fragment PTS/duration from seqnum-1 to frag 0
  for (i = fragIdx; i > 0; i--) {
    updatePTS(fragments, i, i - 1);
  }

  // adjust fragment PTS/duration from seqnum to last frag
  for (i = fragIdx; i < fragments.length - 1; i++) {
    updatePTS(fragments, i, i + 1);
  }

  details.PTSKnown = true;
  return drift;
}

function mergeDetails(oldDetails, newDetails) {
  // potentially retrieve cached initsegment
  if (newDetails.initSegment && oldDetails.initSegment) {
    newDetails.initSegment = oldDetails.initSegment;
  }

  // check if old/new playlists have fragments in common
  // loop through overlapping SN and update startPTS , cc, and duration if any found
  var ccOffset = 0;
  var PTSFrag = void 0;
  mapFragmentIntersection(oldDetails, newDetails, function (oldFrag, newFrag) {
    ccOffset = oldFrag.cc - newFrag.cc;
    if (Number.isFinite(oldFrag.startPTS)) {
      newFrag.start = newFrag.startPTS = oldFrag.startPTS;
      newFrag.endPTS = oldFrag.endPTS;
      newFrag.duration = oldFrag.duration;
      newFrag.backtracked = oldFrag.backtracked;
      newFrag.dropped = oldFrag.dropped;
      PTSFrag = newFrag;
    }
    // PTS is known when there are overlapping segments
    newDetails.PTSKnown = true;
  });

  if (!newDetails.PTSKnown) {
    return;
  }

  if (ccOffset) {
    _logger.logger.log('discontinuity sliding from playlist, take drift into account');
    var newFragments = newDetails.fragments;
    for (var i = 0; i < newFragments.length; i++) {
      newFragments[i].cc += ccOffset;
    }
  }

  // if at least one fragment contains PTS info, recompute PTS information for all fragments
  if (PTSFrag) {
    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
  } else {
    // ensure that delta is within oldFragments range
    // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
    // in that case we also need to adjust start offset of all fragments
    adjustSliding(oldDetails, newDetails);
  }
  // if we are here, it means we have fragments overlapping between
  // old and new level. reliable PTS info is thus relying on old level
  newDetails.PTSKnown = oldDetails.PTSKnown;
}

function mergeSubtitlePlaylists(oldPlaylist, newPlaylist) {
  var referenceStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var lastIndex = -1;
  mapFragmentIntersection(oldPlaylist, newPlaylist, function (oldFrag, newFrag, index) {
    newFrag.start = oldFrag.start;
    lastIndex = index;
  });

  var frags = newPlaylist.fragments;
  if (lastIndex < 0) {
    frags.forEach(function (frag) {
      frag.start += referenceStart;
    });
    return;
  }

  for (var i = lastIndex + 1; i < frags.length; i++) {
    frags[i].start = frags[i - 1].start + frags[i - 1].duration;
  }
}

function mapFragmentIntersection(oldPlaylist, newPlaylist, intersectionFn) {
  if (!oldPlaylist || !newPlaylist) {
    return;
  }

  var start = Math.max(oldPlaylist.startSN, newPlaylist.startSN) - newPlaylist.startSN;
  var end = Math.min(oldPlaylist.endSN, newPlaylist.endSN) - newPlaylist.startSN;
  var delta = newPlaylist.startSN - oldPlaylist.startSN;

  for (var i = start; i <= end; i++) {
    var oldFrag = oldPlaylist.fragments[delta + i];
    var newFrag = newPlaylist.fragments[i];
    if (!oldFrag || !newFrag) {
      break;
    }
    intersectionFn(oldFrag, newFrag, i);
  }
}

function adjustSliding(oldPlaylist, newPlaylist) {
  var delta = newPlaylist.startSN - oldPlaylist.startSN;
  var oldFragments = oldPlaylist.fragments;
  var newFragments = newPlaylist.fragments;

  if (delta < 0 || delta > oldFragments.length) {
    return;
  }
  for (var i = 0; i < newFragments.length; i++) {
    newFragments[i].start += oldFragments[delta].start;
  }
}

function computeReloadInterval(currentPlaylist, newPlaylist, lastRequestTime) {
  var reloadInterval = 1000 * (newPlaylist.averagetargetduration ? newPlaylist.averagetargetduration : newPlaylist.targetduration);
  var minReloadInterval = reloadInterval / 2;
  if (currentPlaylist && newPlaylist.endSN === currentPlaylist.endSN) {
    // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
    // changed then it MUST wait for a period of one-half the target
    // duration before retrying.
    reloadInterval = minReloadInterval;
  }

  if (lastRequestTime) {
    reloadInterval = Math.max(minReloadInterval, reloadInterval - (window.performance.now() - lastRequestTime));
  }
  // in any case, don't reload more than half of target duration
  return Math.round(reloadInterval);
}

/***/ }),

/***/ "./src/hls.js/controller/stream-controller.js":
/*!****************************************************!*\
  !*** ./src/hls.js/controller/stream-controller.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _binarySearch = __webpack_require__(/*! ../utils/binary-search */ "./src/hls.js/utils/binary-search.js");

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _demuxer = __webpack_require__(/*! ../demux/demuxer */ "./src/hls.js/demux/demuxer.js");

var _demuxer2 = _interopRequireDefault(_demuxer);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _fragmentTracker = __webpack_require__(/*! ./fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _fragment = __webpack_require__(/*! ../loader/fragment */ "./src/hls.js/loader/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _playlistLoader = __webpack_require__(/*! ../loader/playlist-loader */ "./src/hls.js/loader/playlist-loader.js");

var _playlistLoader2 = _interopRequireDefault(_playlistLoader);

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

var LevelHelper = _interopRequireWildcard(_levelHelper);

var _timeRanges = __webpack_require__(/*! ../utils/time-ranges */ "./src/hls.js/utils/time-ranges.js");

var _timeRanges2 = _interopRequireDefault(_timeRanges);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _discontinuities = __webpack_require__(/*! ../utils/discontinuities */ "./src/hls.js/utils/discontinuities.js");

var _fragmentFinders = __webpack_require__(/*! ./fragment-finders */ "./src/hls.js/controller/fragment-finders.js");

var _gapController = __webpack_require__(/*! ./gap-controller */ "./src/hls.js/controller/gap-controller.js");

var _gapController2 = _interopRequireDefault(_gapController);

var _baseStreamController = __webpack_require__(/*! ./base-stream-controller */ "./src/hls.js/controller/base-stream-controller.js");

var _baseStreamController2 = _interopRequireDefault(_baseStreamController);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var TICK_INTERVAL = 100; // how often to tick in ms

var StreamController = function (_BaseStreamController) {
  _inherits(StreamController, _BaseStreamController);

  function StreamController(hls, fragmentTracker) {
    _classCallCheck(this, StreamController);

    var _this = _possibleConstructorReturn(this, (StreamController.__proto__ || Object.getPrototypeOf(StreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.LEVEL_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_LOAD_EMERGENCY_ABORTED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED));

    _this.fragmentTracker = fragmentTracker;
    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this._state = _baseStreamController.State.STOPPED;
    _this.stallReported = false;
    _this.gapController = null;
    return _this;
  }

  _createClass(StreamController, [{
    key: 'startLoad',
    value: function startLoad(startPosition) {
      if (this.levels) {
        var lastCurrentTime = this.lastCurrentTime,
            hls = this.hls;
        this.stopLoad();
        this.setInterval(TICK_INTERVAL);
        this.level = -1;
        this.fragLoadError = 0;
        if (!this.startFragRequested) {
          // determine load level
          var startLevel = hls.startLevel;
          if (startLevel === -1) {
            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
            startLevel = 0;
            this.bitrateTest = true;
          }
          // set new level to playlist loader : this will trigger start level load
          // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded
          this.level = hls.nextLoadLevel = startLevel;
          this.loadedmetadata = false;
        }
        // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime
        if (lastCurrentTime > 0 && startPosition === -1) {
          _logger.logger.log('override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
          startPosition = lastCurrentTime;
        }
        this.state = _baseStreamController.State.IDLE;
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
        this.tick();
      } else {
        this.forceStartLoad = true;
        this.state = _baseStreamController.State.STOPPED;
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.forceStartLoad = false;
      _get(StreamController.prototype.__proto__ || Object.getPrototypeOf(StreamController.prototype), 'stopLoad', this).call(this);
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      switch (this.state) {
        case _baseStreamController.State.BUFFER_FLUSHING:
          // in buffer flushing state, reset fragLoadError counter
          this.fragLoadError = 0;
          break;
        case _baseStreamController.State.IDLE:
          this._doTickIdle();
          break;
        case _baseStreamController.State.WAITING_LEVEL:
          var level = this.levels[this.level];
          // check if playlist is already loaded
          if (level && level.details) {
            this.state = _baseStreamController.State.IDLE;
          }

          break;
        case _baseStreamController.State.FRAG_LOADING_WAITING_RETRY:
          var now = window.performance.now();
          var retryDate = this.retryDate;
          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
          if (!retryDate || now >= retryDate || this.media && this.media.seeking) {
            _logger.logger.log('mediaController: retryDate reached, switch back to IDLE state');
            this.state = _baseStreamController.State.IDLE;
          }
          break;
        case _baseStreamController.State.ERROR:
        case _baseStreamController.State.STOPPED:
        case _baseStreamController.State.FRAG_LOADING:
        case _baseStreamController.State.PARSING:
        case _baseStreamController.State.PARSED:
        case _baseStreamController.State.ENDED:
          break;
        default:
          break;
      }
      // check buffer
      this._checkBuffer();
      // check/update current fragment
      this._checkFragmentChanged();
    }

    // Ironically the "idle" state is the on we do the most logic in it seems ....
    // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently
    //       played segment, or on pause/play/seek instead of naively checking every 100ms?

  }, {
    key: '_doTickIdle',
    value: function _doTickIdle() {
      var hls = this.hls,
          config = hls.config,
          media = this.media;

      // if start level not parsed yet OR
      // if video not attached AND start fragment already requested OR start frag prefetch disable
      // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment
      if (this.levelLastLoaded === undefined || !media && (this.startFragRequested || !config.startFragPrefetch)) {
        return;
      }

      // if we have not yet loaded any fragment, start loading from start position
      var pos = void 0;
      if (this.loadedmetadata) {
        pos = media.currentTime;
      } else {
        pos = this.nextLoadPosition;
      }

      // determine next load level
      var level = hls.nextLoadLevel,
          levelInfo = this.levels[level];

      if (!levelInfo) {
        return;
      }

      var levelBitrate = levelInfo.bitrate,
          maxBufLen = void 0;

      // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
      if (levelBitrate) {
        maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
      } else {
        maxBufLen = config.maxBufferLength;
      }

      maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);

      // determine next candidate fragment to be loaded, based on current position and end of buffer position
      // ensure up to `config.maxMaxBufferLength` of buffer upfront

      var bufferInfo = _bufferHelper.BufferHelper.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, config.maxBufferHole),
          bufferLen = bufferInfo.len;
      // Stay idle if we are still with buffer margins
      if (bufferLen >= maxBufLen) {
        return;
      }

      // if buffer length is less than maxBufLen try to load a new fragment ...
      _logger.logger.trace('buffer length of ' + bufferLen.toFixed(3) + ' is below max of ' + maxBufLen.toFixed(3) + '. checking for more payload ...');

      // set next load level : this will trigger a playlist load if needed
      this.level = hls.nextLoadLevel = level;

      var levelDetails = levelInfo.details;
      // if level info not retrieved yet, switch state and wait for level retrieval
      // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
      // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)
      if (!levelDetails || levelDetails.live && this.levelLastLoaded !== level) {
        this.state = _baseStreamController.State.WAITING_LEVEL;
        return;
      }

      if (this._streamEnded(bufferInfo, levelDetails)) {
        var data = {};
        if (this.altAudio) {
          data.type = 'video';
        }

        this.hls.trigger(_events2.default.BUFFER_EOS, data);
        this.state = _baseStreamController.State.ENDED;
        return;
      }
      // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)
      this._fetchPayloadOrEos(pos, bufferInfo, levelDetails);
    }
  }, {
    key: '_fetchPayloadOrEos',
    value: function _fetchPayloadOrEos(pos, bufferInfo, levelDetails) {
      var fragPrevious = this.fragPrevious,
          level = this.level,
          fragments = levelDetails.fragments,
          fragLen = fragments.length;

      // empty playlist
      if (fragLen === 0) {
        return;
      }

      // find fragment index, contiguous with end of buffer position
      var start = fragments[0].start,
          end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
          bufferEnd = bufferInfo.end,
          frag = void 0;

      if (levelDetails.initSegment && !levelDetails.initSegment.data) {
        frag = levelDetails.initSegment;
      } else {
        // in case of live playlist we need to ensure that requested position is not located before playlist start
        if (levelDetails.live) {
          var initialLiveManifestSize = this.config.initialLiveManifestSize;
          if (fragLen < initialLiveManifestSize) {
            _logger.logger.warn('Can not start playback of a level, reason: not enough fragments ' + fragLen + ' < ' + initialLiveManifestSize);
            return;
          }

          frag = this._ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen);
          // if it explicitely returns null don't load any fragment and exit function now
          if (frag === null) {
            return;
          }
        } else {
          // VoD playlist: if bufferEnd before start of playlist, load first fragment
          if (bufferEnd < start) {
            frag = fragments[0];
          }
        }
      }
      if (!frag) {
        frag = this._findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails);
      }

      if (frag) {
        if (frag.encrypted) {
          _logger.logger.log('Loading key for ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level);
          this._loadKey(frag);
        } else {
          _logger.logger.log('Loading ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level + ', currentTime:' + pos.toFixed(3) + ',bufferEnd:' + bufferEnd.toFixed(3));
          this._loadFragment(frag);
        }
      }
    }
  }, {
    key: '_ensureFragmentAtLivePoint',
    value: function _ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen) {
      var config = this.hls.config,
          media = this.media;

      var frag = void 0;

      // check if requested position is within seekable boundaries :
      // logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);
      var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;

      if (bufferEnd < Math.max(start - config.maxFragLookUpTolerance, end - maxLatency)) {
        var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);
        _logger.logger.log('buffer end: ' + bufferEnd.toFixed(3) + ' is located too far from the end of live sliding playlist, reset currentTime to : ' + liveSyncPosition.toFixed(3));
        bufferEnd = liveSyncPosition;
        if (media && media.readyState && media.duration > liveSyncPosition) {
          media.currentTime = liveSyncPosition;
        }

        this.nextLoadPosition = liveSyncPosition;
      }

      // if end of buffer greater than live edge, don't load any fragment
      // this could happen if live playlist intermittently slides in the past.
      // level 1 loaded [182580161,182580167]
      // level 1 loaded [182580162,182580169]
      // Loading 182580168 of [182580162 ,182580169],level 1 ..
      // Loading 182580169 of [182580162 ,182580169],level 1 ..
      // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168
      // level 1 loaded [182580164,182580171]
      //
      // don't return null in case media not loaded yet (readystate === 0)
      if (levelDetails.PTSKnown && bufferEnd > end && media && media.readyState) {
        return null;
      }

      if (this.startFragRequested && !levelDetails.PTSKnown) {
        /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...
           try to load frag matching with next SN.
           even if SN are not synchronized between playlists, loading this frag will help us
           compute playlist sliding and find the right one after in case it was not the right consecutive one */
        if (fragPrevious) {
          if (levelDetails.hasProgramDateTime) {
            // Relies on PDT in order to switch bitrates (Support EXT-X-DISCONTINUITY without EXT-X-DISCONTINUITY-SEQUENCE)
            _logger.logger.log('live playlist, switching playlist, load frag with same PDT: ' + fragPrevious.programDateTime);
            frag = (0, _fragmentFinders.findFragmentByPDT)(fragments, fragPrevious.endProgramDateTime, config.maxFragLookUpTolerance);
          } else {
            // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)
            var targetSN = fragPrevious.sn + 1;
            if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
              var fragNext = fragments[targetSN - levelDetails.startSN];
              if (fragPrevious.cc === fragNext.cc) {
                frag = fragNext;
                _logger.logger.log('live playlist, switching playlist, load frag with next SN: ' + frag.sn);
              }
            }
            // next frag SN not available (or not with same continuity counter)
            // look for a frag sharing the same CC
            if (!frag) {
              frag = _binarySearch2.default.search(fragments, function (frag) {
                return fragPrevious.cc - frag.cc;
              });
              if (frag) {
                _logger.logger.log('live playlist, switching playlist, load frag with same CC: ' + frag.sn);
              }
            }
          }
        }
        if (!frag) {
          /* we have no idea about which fragment should be loaded.
             so let's load mid fragment. it will help computing playlist sliding and find the right one
          */
          frag = fragments[Math.min(fragLen - 1, Math.round(fragLen / 2))];
          _logger.logger.log('live playlist, switching playlist, unknown, load middle frag : ' + frag.sn);
        }
      }

      return frag;
    }
  }, {
    key: '_findFragment',
    value: function _findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails) {
      var config = this.hls.config;
      var frag = void 0;

      if (bufferEnd < end) {
        var lookupTolerance = bufferEnd > end - config.maxFragLookUpTolerance ? 0 : config.maxFragLookUpTolerance;
        // Remove the tolerance if it would put the bufferEnd past the actual end of stream
        // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)
        frag = (0, _fragmentFinders.findFragmentByPTS)(fragPrevious, fragments, bufferEnd, lookupTolerance);
      } else {
        // reach end of playlist
        frag = fragments[fragLen - 1];
      }
      if (frag) {
        var curSNIdx = frag.sn - levelDetails.startSN;
        var sameLevel = fragPrevious && frag.level === fragPrevious.level;
        var prevFrag = fragments[curSNIdx - 1];
        var nextFrag = fragments[curSNIdx + 1];
        // logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
        if (fragPrevious && frag.sn === fragPrevious.sn) {
          if (sameLevel && !frag.backtracked) {
            if (frag.sn < levelDetails.endSN) {
              var deltaPTS = fragPrevious.deltaPTS;
              // if there is a significant delta between audio and video, larger than max allowed hole,
              // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)
              // let's try to load previous fragment again to get last keyframe
              // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)
              if (deltaPTS && deltaPTS > config.maxBufferHole && fragPrevious.dropped && curSNIdx) {
                frag = prevFrag;
                _logger.logger.warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');
              } else {
                frag = nextFrag;
                _logger.logger.log('SN just loaded, load next one: ' + frag.sn, frag);
              }
            } else {
              frag = null;
            }
          } else if (frag.backtracked) {
            // Only backtrack a max of 1 consecutive fragment to prevent sliding back too far when little or no frags start with keyframes
            if (nextFrag && nextFrag.backtracked) {
              _logger.logger.warn('Already backtracked from fragment ' + nextFrag.sn + ', will not backtrack to fragment ' + frag.sn + '. Loading fragment ' + nextFrag.sn);
              frag = nextFrag;
            } else {
              // If a fragment has dropped frames and it's in a same level/sequence, load the previous fragment to try and find the keyframe
              // Reset the dropped count now since it won't be reset until we parse the fragment again, which prevents infinite backtracking on the same segment
              _logger.logger.warn('Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe');
              frag.dropped = 0;
              if (prevFrag) {
                frag = prevFrag;
                frag.backtracked = true;
              } else if (curSNIdx) {
                // can't backtrack on very first fragment
                frag = null;
              }
            }
          }
        }
      }
      return frag;
    }
  }, {
    key: '_loadKey',
    value: function _loadKey(frag) {
      this.state = _baseStreamController.State.KEY_LOADING;
      this.hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
    }
  }, {
    key: '_loadFragment',
    value: function _loadFragment(frag) {
      // Check if fragment is not loaded
      var fragState = this.fragmentTracker.getState(frag);

      this.fragCurrent = frag;
      this.startFragRequested = true;
      // Don't update nextLoadPosition for fragments which are not buffered
      if (Number.isFinite(frag.sn) && !frag.bitrateTest) {
        this.nextLoadPosition = frag.start + frag.duration;
      }

      // Allow backtracked fragments to load
      if (frag.backtracked || fragState === _fragmentTracker.FragmentState.NOT_LOADED || fragState === _fragmentTracker.FragmentState.PARTIAL) {
        frag.autoLevel = this.hls.autoLevelEnabled;
        frag.bitrateTest = this.bitrateTest;

        this.hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
        // lazy demuxer init, as this could take some time ... do it during frag loading
        if (!this.demuxer) {
          this.demuxer = new _demuxer2.default(this.hls, 'main');
        }

        this.state = _baseStreamController.State.FRAG_LOADING;
      } else if (fragState === _fragmentTracker.FragmentState.APPENDING) {
        // Lower the buffer size and try again
        if (this._reduceMaxBufferLength(frag.duration)) {
          this.fragmentTracker.removeFragment(frag);
        }
      }
    }
  }, {
    key: 'getBufferedFrag',
    value: function getBufferedFrag(position) {
      return this.fragmentTracker.getBufferedFrag(position, _playlistLoader2.default.LevelType.MAIN);
    }
  }, {
    key: 'followingBufferedFrag',
    value: function followingBufferedFrag(frag) {
      if (frag) {
        // try to get range of next fragment (500ms after this range)
        return this.getBufferedFrag(frag.endPTS + 0.5);
      }
      return null;
    }
  }, {
    key: '_checkFragmentChanged',
    value: function _checkFragmentChanged() {
      var fragPlayingCurrent = void 0,
          currentTime = void 0,
          video = this.media;
      if (video && video.readyState && video.seeking === false) {
        currentTime = video.currentTime;
        /* if video element is in seeked state, currentTime can only increase.
          (assuming that playback rate is positive ...)
          As sometimes currentTime jumps back to zero after a
          media decode error, check this, to avoid seeking back to
          wrong position after a media decode error
        */
        if (currentTime > this.lastCurrentTime) {
          this.lastCurrentTime = currentTime;
        }

        if (_bufferHelper.BufferHelper.isBuffered(video, currentTime)) {
          fragPlayingCurrent = this.getBufferedFrag(currentTime);
        } else if (_bufferHelper.BufferHelper.isBuffered(video, currentTime + 0.1)) {
          /* ensure that FRAG_CHANGED event is triggered at startup,
            when first video frame is displayed and playback is paused.
            add a tolerance of 100ms, in case current position is not buffered,
            check if current pos+100ms is buffered and use that buffer range
            for FRAG_CHANGED event reporting */
          fragPlayingCurrent = this.getBufferedFrag(currentTime + 0.1);
        }
        if (fragPlayingCurrent) {
          var fragPlaying = fragPlayingCurrent;
          if (fragPlaying !== this.fragPlaying) {
            this.hls.trigger(_events2.default.FRAG_CHANGED, { frag: fragPlaying });
            var fragPlayingLevel = fragPlaying.level;
            if (!this.fragPlaying || this.fragPlaying.level !== fragPlayingLevel) {
              this.hls.trigger(_events2.default.LEVEL_SWITCHED, { level: fragPlayingLevel });
            }

            this.fragPlaying = fragPlaying;
          }
        }
      }
    }

    /*
      on immediate level switch :
       - pause playback if playing
       - cancel any pending load request
       - and trigger a buffer flush
    */

  }, {
    key: 'immediateLevelSwitch',
    value: function immediateLevelSwitch() {
      _logger.logger.log('immediateLevelSwitch');
      if (!this.immediateSwitch) {
        this.immediateSwitch = true;
        var media = this.media,
            previouslyPaused = void 0;
        if (media) {
          previouslyPaused = media.paused;
          media.pause();
        } else {
          // don't restart playback after instant level switch in case media not attached
          previouslyPaused = true;
        }
        this.previouslyPaused = previouslyPaused;
      }
      var fragCurrent = this.fragCurrent;
      if (fragCurrent && fragCurrent.loader) {
        fragCurrent.loader.abort();
      }

      this.fragCurrent = null;
      // flush everything
      this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
    }

    /**
     * on immediate level switch end, after new fragment has been buffered:
     * - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)
     * - resume the playback if needed
     */

  }, {
    key: 'immediateLevelSwitchEnd',
    value: function immediateLevelSwitchEnd() {
      var media = this.media;
      if (media && media.buffered.length) {
        this.immediateSwitch = false;
        if (_bufferHelper.BufferHelper.isBuffered(media, media.currentTime)) {
          // only nudge if currentTime is buffered
          media.currentTime -= 0.0001;
        }
        if (!this.previouslyPaused) {
          media.play();
        }
      }
    }

    /**
     * try to switch ASAP without breaking video playback:
     * in order to ensure smooth but quick level switching,
     * we need to find the next flushable buffer range
     * we should take into account new segment fetch time
     */

  }, {
    key: 'nextLevelSwitch',
    value: function nextLevelSwitch() {
      var media = this.media;
      // ensure that media is defined and that metadata are available (to retrieve currentTime)
      if (media && media.readyState) {
        var fetchdelay = void 0,
            fragPlayingCurrent = void 0,
            nextBufferedFrag = void 0;
        fragPlayingCurrent = this.getBufferedFrag(media.currentTime);
        if (fragPlayingCurrent && fragPlayingCurrent.startPTS > 1) {
          // flush buffer preceding current fragment (flush until current fragment start offset)
          // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
          this.flushMainBuffer(0, fragPlayingCurrent.startPTS - 1);
        }
        if (!media.paused) {
          // add a safety delay of 1s
          var nextLevelId = this.hls.nextLoadLevel,
              nextLevel = this.levels[nextLevelId],
              fragLastKbps = this.fragLastKbps;
          if (fragLastKbps && this.fragCurrent) {
            fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1000 * fragLastKbps) + 1;
          } else {
            fetchdelay = 0;
          }
        } else {
          fetchdelay = 0;
        }
        // logger.log('fetchdelay:'+fetchdelay);
        // find buffer range that will be reached once new fragment will be fetched
        nextBufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
        if (nextBufferedFrag) {
          // we can flush buffer range following this one without stalling playback
          nextBufferedFrag = this.followingBufferedFrag(nextBufferedFrag);
          if (nextBufferedFrag) {
            // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
            var fragCurrent = this.fragCurrent;
            if (fragCurrent && fragCurrent.loader) {
              fragCurrent.loader.abort();
            }

            this.fragCurrent = null;
            // start flush position is the start PTS of next buffered frag.
            // we use frag.naxStartPTS which is max(audio startPTS, video startPTS).
            // in case there is a small PTS Delta between audio and video, using maxStartPTS avoids flushing last samples from current fragment
            this.flushMainBuffer(nextBufferedFrag.maxStartPTS, Number.POSITIVE_INFINITY);
          }
        }
      }
    }
  }, {
    key: 'flushMainBuffer',
    value: function flushMainBuffer(startOffset, endOffset) {
      this.state = _baseStreamController.State.BUFFER_FLUSHING;
      var flushScope = { startOffset: startOffset, endOffset: endOffset };
      // if alternate audio tracks are used, only flush video, otherwise flush everything
      if (this.altAudio) {
        flushScope.type = 'video';
      }

      this.hls.trigger(_events2.default.BUFFER_FLUSHING, flushScope);
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvseeked = this.onMediaSeeked.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener('seeking', this.onvseeking);
      media.addEventListener('seeked', this.onvseeked);
      media.addEventListener('ended', this.onvended);
      var config = this.config;
      if (this.levels && config.autoStartLoad) {
        this.hls.startLoad(config.startPosition);
      }

      this.gapController = new _gapController2.default(config, media, this.fragmentTracker, this.hls);
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var media = this.media;
      if (media && media.ended) {
        _logger.logger.log('MSE detaching and video ended, reset startPosition');
        this.startPosition = this.lastCurrentTime = 0;
      }

      // reset fragment backtracked flag
      var levels = this.levels;
      if (levels) {
        levels.forEach(function (level) {
          if (level.details) {
            level.details.fragments.forEach(function (fragment) {
              fragment.backtracked = undefined;
            });
          }
        });
      }
      // remove video listeners
      if (media) {
        media.removeEventListener('seeking', this.onvseeking);
        media.removeEventListener('seeked', this.onvseeked);
        media.removeEventListener('ended', this.onvended);
        this.onvseeking = this.onvseeked = this.onvended = null;
      }
      this.media = this.mediaBuffer = null;
      this.loadedmetadata = false;
      this.stopLoad();
    }
  }, {
    key: 'onMediaSeeked',
    value: function onMediaSeeked() {
      var media = this.media,
          currentTime = media ? media.currentTime : undefined;
      if (Number.isFinite(currentTime)) {
        _logger.logger.log('media seeked to ' + currentTime.toFixed(3));
      }

      // tick to speed up FRAGMENT_PLAYING triggering
      this.tick();
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      // reset buffer on manifest loading
      _logger.logger.log('trigger BUFFER_RESET');
      this.hls.trigger(_events2.default.BUFFER_RESET);
      this.fragmentTracker.removeAllFragments();
      this.stalled = false;
      this.startPosition = this.lastCurrentTime = 0;
    }
  }, {
    key: 'onManifestParsed',
    value: function onManifestParsed(data) {
      var aac = false,
          heaac = false,
          codec = void 0;
      data.levels.forEach(function (level) {
        // detect if we have different kind of audio codecs used amongst playlists
        codec = level.audioCodec;
        if (codec) {
          if (codec.indexOf('mp4a.40.2') !== -1) {
            aac = true;
          }

          if (codec.indexOf('mp4a.40.5') !== -1) {
            heaac = true;
          }
        }
      });
      this.audioCodecSwitch = aac && heaac;
      if (this.audioCodecSwitch) {
        _logger.logger.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
      }

      this.levels = data.levels;
      this.startFragRequested = false;
      var config = this.config;
      if (config.autoStartLoad || this.forceStartLoad) {
        this.hls.startLoad(config.startPosition);
      }
    }
  }, {
    key: 'onLevelLoaded',
    value: function onLevelLoaded(data) {
      var newDetails = data.details;
      var newLevelId = data.level;
      var lastLevel = this.levels[this.levelLastLoaded];
      var curLevel = this.levels[newLevelId];
      var duration = newDetails.totalduration;
      var sliding = 0;

      _logger.logger.log('level ' + newLevelId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);

      if (newDetails.live) {
        var curDetails = curLevel.details;
        if (curDetails && newDetails.fragments.length > 0) {
          // we already have details for that level, merge them
          LevelHelper.mergeDetails(curDetails, newDetails);
          sliding = newDetails.fragments[0].start;
          this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
          if (newDetails.PTSKnown && Number.isFinite(sliding)) {
            _logger.logger.log('live playlist sliding:' + sliding.toFixed(3));
          } else {
            _logger.logger.log('live playlist - outdated PTS, unknown sliding');
            (0, _discontinuities.alignStream)(this.fragPrevious, lastLevel, newDetails);
          }
        } else {
          _logger.logger.log('live playlist - first load, unknown sliding');
          newDetails.PTSKnown = false;
          (0, _discontinuities.alignStream)(this.fragPrevious, lastLevel, newDetails);
        }
      } else {
        newDetails.PTSKnown = false;
      }
      // override level info
      curLevel.details = newDetails;
      this.levelLastLoaded = newLevelId;
      this.hls.trigger(_events2.default.LEVEL_UPDATED, { details: newDetails, level: newLevelId });

      if (this.startFragRequested === false) {
        // compute start position if set to -1. use it straight away if value is defined
        if (this.startPosition === -1 || this.lastCurrentTime === -1) {
          // first, check if start time offset has been set in playlist, if yes, use this value
          var startTimeOffset = newDetails.startTimeOffset;
          if (Number.isFinite(startTimeOffset)) {
            if (startTimeOffset < 0) {
              _logger.logger.log('negative start time offset ' + startTimeOffset + ', count from end of last fragment');
              startTimeOffset = sliding + duration + startTimeOffset;
            }
            _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
            this.startPosition = startTimeOffset;
          } else {
            // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)
            if (newDetails.live) {
              this.startPosition = this.computeLivePosition(sliding, newDetails);
              _logger.logger.log('configure startPosition to ' + this.startPosition);
            } else {
              this.startPosition = 0;
            }
          }
          this.lastCurrentTime = this.startPosition;
        }
        this.nextLoadPosition = this.startPosition;
      }
      // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment
      if (this.state === _baseStreamController.State.WAITING_LEVEL) {
        this.state = _baseStreamController.State.IDLE;
      }

      // trigger handler right now
      this.tick();
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === _baseStreamController.State.KEY_LOADING) {
        this.state = _baseStreamController.State.IDLE;
        this.tick();
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent,
          hls = this.hls,
          levels = this.levels,
          media = this.media;

      var fragLoaded = data.frag;
      if (this.state === _baseStreamController.State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'main' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
        var stats = data.stats;
        var currentLevel = levels[fragCurrent.level];
        var details = currentLevel.details;
        // reset frag bitrate test in any case after frag loaded event
        // if this frag was loaded to perform a bitrate test AND if hls.nextLoadLevel is greater than 0
        // then this means that we should be able to load a fragment at a higher quality level
        this.bitrateTest = false;
        this.stats = stats;

        _logger.logger.log('Loaded ' + fragCurrent.sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + fragCurrent.level);
        if (fragLoaded.bitrateTest && hls.nextLoadLevel) {
          // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo
          this.state = _baseStreamController.State.IDLE;
          this.startFragRequested = false;
          stats.tparsed = stats.tbuffered = window.performance.now();
          hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
          this.tick();
        } else if (fragLoaded.sn === 'initSegment') {
          this.state = _baseStreamController.State.IDLE;
          stats.tparsed = stats.tbuffered = window.performance.now();
          details.initSegment.data = data.payload;
          hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
          this.tick();
        } else {
          _logger.logger.log('Parsing ' + fragCurrent.sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + fragCurrent.level + ', cc ' + fragCurrent.cc);
          this.state = _baseStreamController.State.PARSING;
          this.pendingBuffering = true;
          this.appended = false;

          // Bitrate test frags are not usually buffered so the fragment tracker ignores them. If Hls.js decides to buffer
          // it (and therefore ends up at this line), then the fragment tracker needs to be manually informed.
          if (fragLoaded.bitrateTest) {
            fragLoaded.bitrateTest = false;
            this.fragmentTracker.onFragLoaded({
              frag: fragLoaded
            });
          }

          // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live) and if media is not seeking (this is to overcome potential timestamp drifts between playlists and fragments)
          var accurateTimeOffset = !(media && media.seeking) && (details.PTSKnown || !details.live);
          var initSegmentData = details.initSegment ? details.initSegment.data : [];
          var audioCodec = this._getAudioCodec(currentLevel);

          // transmux the MPEG-TS data to ISO-BMFF segments
          var demuxer = this.demuxer = this.demuxer || new _demuxer2.default(this.hls, 'main');
          demuxer.push(data.payload, initSegmentData, audioCodec, currentLevel.videoCodec, fragCurrent, details.totalduration, accurateTimeOffset);
        }
      }
      this.fragLoadError = 0;
    }
  }, {
    key: 'onFragParsingInitSegment',
    value: function onFragParsingInitSegment(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;

      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === _baseStreamController.State.PARSING) {
        var tracks = data.tracks,
            trackName = void 0,
            track = void 0;

        // if audio track is expected to come from audio stream controller, discard any coming from main
        if (tracks.audio && this.altAudio) {
          delete tracks.audio;
        }

        // include levelCodec in audio and video tracks
        track = tracks.audio;
        if (track) {
          var audioCodec = this.levels[this.level].audioCodec,
              ua = navigator.userAgent.toLowerCase();
          if (audioCodec && this.audioCodecSwap) {
            _logger.logger.log('swapping playlist audio codec');
            if (audioCodec.indexOf('mp4a.40.5') !== -1) {
              audioCodec = 'mp4a.40.2';
            } else {
              audioCodec = 'mp4a.40.5';
            }
          }
          // in case AAC and HE-AAC audio codecs are signalled in manifest
          // force HE-AAC , as it seems that most browsers prefers that way,
          // except for mono streams OR on FF
          // these conditions might need to be reviewed ...
          if (this.audioCodecSwitch) {
            // don't force HE-AAC if mono stream
            if (track.metadata.channelCount !== 1 &&
            // don't force HE-AAC if firefox
            ua.indexOf('firefox') === -1) {
              audioCodec = 'mp4a.40.5';
            }
          }
          // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise
          if (ua.indexOf('android') !== -1 && track.container !== 'audio/mpeg') {
            // Exclude mpeg audio
            audioCodec = 'mp4a.40.2';
            _logger.logger.log('Android: force audio codec to ' + audioCodec);
          }
          track.levelCodec = audioCodec;
          track.id = data.id;
        }
        track = tracks.video;
        if (track) {
          track.levelCodec = this.levels[this.level].videoCodec;
          track.id = data.id;
        }
        this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
        // loop through tracks that are going to be provided to bufferController
        for (trackName in tracks) {
          track = tracks[trackName];
          _logger.logger.log('main track:' + trackName + ',container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
          var initSegment = track.initSegment;
          if (initSegment) {
            this.appended = true;
            // arm pending Buffering flag before appending a segment
            this.pendingBuffering = true;
            this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: trackName, data: initSegment, parent: 'main', content: 'initSegment' });
          }
        }
        // trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsingData',
    value: function onFragParsingData(data) {
      var _this2 = this;

      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && !(data.type === 'audio' && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
      this.state === _baseStreamController.State.PARSING) {
        var level = this.levels[this.level],
            frag = fragCurrent;
        if (!Number.isFinite(data.endPTS)) {
          data.endPTS = data.startPTS + fragCurrent.duration;
          data.endDTS = data.startDTS + fragCurrent.duration;
        }

        if (data.hasAudio === true) {
          frag.addElementaryStream(_fragment2.default.ElementaryStreamTypes.AUDIO);
        }

        if (data.hasVideo === true) {
          frag.addElementaryStream(_fragment2.default.ElementaryStreamTypes.VIDEO);
        }

        _logger.logger.log('Parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb + ',dropped:' + (data.dropped || 0));

        // Detect gaps in a fragment  and try to fix it by finding a keyframe in the previous fragment (see _findFragments)
        if (data.type === 'video') {
          frag.dropped = data.dropped;
          if (frag.dropped) {
            if (!frag.backtracked) {
              var levelDetails = level.details;
              if (levelDetails && frag.sn === levelDetails.startSN) {
                _logger.logger.warn('missing video frame(s) on first frag, appending with gap', frag.sn);
              } else {
                _logger.logger.warn('missing video frame(s), backtracking fragment', frag.sn);
                // Return back to the IDLE state without appending to buffer
                // Causes findFragments to backtrack a segment and find the keyframe
                // Audio fragments arriving before video sets the nextLoadPosition, causing _findFragments to skip the backtracked fragment
                this.fragmentTracker.removeFragment(frag);
                frag.backtracked = true;
                this.nextLoadPosition = data.startPTS;
                this.state = _baseStreamController.State.IDLE;
                this.fragPrevious = frag;
                this.tick();
                return;
              }
            } else {
              _logger.logger.warn('Already backtracked on this fragment, appending with the gap', frag.sn);
            }
          } else {
            // Only reset the backtracked flag if we've loaded the frag without any dropped frames
            frag.backtracked = false;
          }
        }

        var drift = LevelHelper.updateFragPTSDTS(level.details, frag, data.startPTS, data.endPTS, data.startDTS, data.endDTS),
            hls = this.hls;
        hls.trigger(_events2.default.LEVEL_PTS_UPDATED, { details: level.details, level: this.level, drift: drift, type: data.type, start: data.startPTS, end: data.endPTS });
        // has remuxer dropped video frames located before first keyframe ?
        [data.data1, data.data2].forEach(function (buffer) {
          // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
          // in that case it is useless to append following segments
          if (buffer && buffer.length && _this2.state === _baseStreamController.State.PARSING) {
            _this2.appended = true;
            // arm pending Buffering flag before appending a segment
            _this2.pendingBuffering = true;
            hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'main', content: 'data' });
          }
        });
        // trigger handler right now
        this.tick();
      }
    }
  }, {
    key: 'onFragParsed',
    value: function onFragParsed(data) {
      var fragCurrent = this.fragCurrent;
      var fragNew = data.frag;
      if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === _baseStreamController.State.PARSING) {
        this.stats.tparsed = window.performance.now();
        this.state = _baseStreamController.State.PARSED;
        this._checkAppendedParsed();
      }
    }
  }, {
    key: 'onAudioTrackSwitching',
    value: function onAudioTrackSwitching(data) {
      // if any URL found on new audio track, it is an alternate audio track
      var altAudio = !!data.url,
          trackId = data.id;
      // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
      // don't do anything if we switch to alt audio: audio stream controller is handling it.
      // we will just have to change buffer scheduling on audioTrackSwitched
      if (!altAudio) {
        if (this.mediaBuffer !== this.media) {
          _logger.logger.log('switching on main audio, use media.buffered to schedule main fragment loading');
          this.mediaBuffer = this.media;
          var fragCurrent = this.fragCurrent;
          // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch
          if (fragCurrent.loader) {
            _logger.logger.log('switching to main audio track, cancel main fragment load');
            fragCurrent.loader.abort();
          }
          this.fragCurrent = null;
          this.fragPrevious = null;
          // destroy demuxer to force init segment generation (following audio switch)
          if (this.demuxer) {
            this.demuxer.destroy();
            this.demuxer = null;
          }
          // switch to IDLE state to load new fragment
          this.state = _baseStreamController.State.IDLE;
        }
        var hls = this.hls;
        // switching to main audio, flush all audio and trigger track switched
        hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
        hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
        this.altAudio = false;
      }
    }
  }, {
    key: 'onAudioTrackSwitched',
    value: function onAudioTrackSwitched(data) {
      var trackId = data.id,
          altAudio = !!this.hls.audioTracks[trackId].url;
      if (altAudio) {
        var videoBuffer = this.videoBuffer;
        // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered
        if (videoBuffer && this.mediaBuffer !== videoBuffer) {
          _logger.logger.log('switching on alternate audio, use video.buffered to schedule main fragment loading');
          this.mediaBuffer = videoBuffer;
        }
      }
      this.altAudio = altAudio;
      this.tick();
    }
  }, {
    key: 'onBufferCreated',
    value: function onBufferCreated(data) {
      var tracks = data.tracks,
          mediaTrack = void 0,
          name = void 0,
          alternate = false;
      for (var type in tracks) {
        var track = tracks[type];
        if (track.id === 'main') {
          name = type;
          mediaTrack = track;
          // keep video source buffer reference
          if (type === 'video') {
            this.videoBuffer = tracks[type].buffer;
          }
        } else {
          alternate = true;
        }
      }
      if (alternate && mediaTrack) {
        _logger.logger.log('alternate track found, use ' + name + '.buffered to schedule main fragment loading');
        this.mediaBuffer = mediaTrack.buffer;
      } else {
        this.mediaBuffer = this.media;
      }
    }
  }, {
    key: 'onBufferAppended',
    value: function onBufferAppended(data) {
      if (data.parent === 'main') {
        var state = this.state;
        if (state === _baseStreamController.State.PARSING || state === _baseStreamController.State.PARSED) {
          // check if all buffers have been appended
          this.pendingBuffering = data.pending > 0;
          this._checkAppendedParsed();
        }
      }
    }
  }, {
    key: '_checkAppendedParsed',
    value: function _checkAppendedParsed() {
      // trigger handler right now
      if (this.state === _baseStreamController.State.PARSED && (!this.appended || !this.pendingBuffering)) {
        var frag = this.fragCurrent;
        if (frag) {
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          _logger.logger.log('main buffered : ' + _timeRanges2.default.toString(media.buffered));
          this.fragPrevious = frag;
          var stats = this.stats;
          stats.tbuffered = window.performance.now();
          // we should get rid of this.fragLastKbps
          this.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));
          this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'main' });
          this.state = _baseStreamController.State.IDLE;
        }
        this.tick();
      }
    }
  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag || this.fragCurrent;
      // don't handle frag error not related to main fragment
      if (frag && frag.type !== 'main') {
        return;
      }

      // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
      var mediaBuffered = !!this.media && _bufferHelper.BufferHelper.isBuffered(this.media, this.media.currentTime) && _bufferHelper.BufferHelper.isBuffered(this.media, this.media.currentTime + 0.5);

      switch (data.details) {
        case _errors.ErrorDetails.FRAG_LOAD_ERROR:
        case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
        case _errors.ErrorDetails.KEY_LOAD_ERROR:
        case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
          if (!data.fatal) {
            // keep retrying until the limit will be reached
            if (this.fragLoadError + 1 <= this.config.fragLoadingMaxRetry) {
              // exponential backoff capped to config.fragLoadingMaxRetryTimeout
              var delay = Math.min(Math.pow(2, this.fragLoadError) * this.config.fragLoadingRetryDelay, this.config.fragLoadingMaxRetryTimeout);
              _logger.logger.warn('mediaController: frag loading failed, retry in ' + delay + ' ms');
              this.retryDate = window.performance.now() + delay;
              // retry loading state
              // if loadedmetadata is not set, it means that we are emergency switch down on first frag
              // in that case, reset startFragRequested flag
              if (!this.loadedmetadata) {
                this.startFragRequested = false;
                this.nextLoadPosition = this.startPosition;
              }
              this.fragLoadError++;
              this.state = _baseStreamController.State.FRAG_LOADING_WAITING_RETRY;
            } else {
              _logger.logger.error('mediaController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
              // switch error to fatal
              data.fatal = true;
              this.state = _baseStreamController.State.ERROR;
            }
          }
          break;
        case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
        case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
          if (this.state !== _baseStreamController.State.ERROR) {
            if (data.fatal) {
              // if fatal error, stop processing
              this.state = _baseStreamController.State.ERROR;
              _logger.logger.warn('streamController: ' + data.details + ',switch to ' + this.state + ' state ...');
            } else {
              // in case of non fatal error while loading level, if level controller is not retrying to load level , switch back to IDLE
              if (!data.levelRetry && this.state === _baseStreamController.State.WAITING_LEVEL) {
                this.state = _baseStreamController.State.IDLE;
              }
            }
          }
          break;
        case _errors.ErrorDetails.BUFFER_FULL_ERROR:
          // if in appending state
          if (data.parent === 'main' && (this.state === _baseStreamController.State.PARSING || this.state === _baseStreamController.State.PARSED)) {
            // reduce max buf len if current position is buffered
            if (mediaBuffered) {
              this._reduceMaxBufferLength(this.config.maxBufferLength);
              this.state = _baseStreamController.State.IDLE;
            } else {
              // current position is not buffered, but browser is still complaining about buffer full error
              // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
              // in that case flush the whole buffer to recover
              _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush everything');
              this.fragCurrent = null;
              // flush everything
              this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
            }
          }
          break;
        default:
          break;
      }
    }
  }, {
    key: '_reduceMaxBufferLength',
    value: function _reduceMaxBufferLength(minLength) {
      var config = this.config;
      if (config.maxMaxBufferLength >= minLength) {
        // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
        config.maxMaxBufferLength /= 2;
        _logger.logger.warn('main:reduce max buffer length to ' + config.maxMaxBufferLength + 's');
        return true;
      }
      return false;
    }

    /**
     * Checks the health of the buffer and attempts to resolve playback stalls.
     * @private
     */

  }, {
    key: '_checkBuffer',
    value: function _checkBuffer() {
      var media = this.media;

      if (!media || media.readyState === 0) {
        // Exit early if we don't have media or if the media hasn't bufferd anything yet (readyState 0)
        return;
      }

      var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;
      var buffered = mediaBuffer.buffered;

      if (!this.loadedmetadata && buffered.length) {
        this.loadedmetadata = true;
        this._seekToStartPos();
      } else if (this.immediateSwitch) {
        this.immediateLevelSwitchEnd();
      } else {
        this.gapController.poll(this.lastCurrentTime, buffered);
      }
    }
  }, {
    key: 'onFragLoadEmergencyAborted',
    value: function onFragLoadEmergencyAborted() {
      this.state = _baseStreamController.State.IDLE;
      // if loadedmetadata is not set, it means that we are emergency switch down on first frag
      // in that case, reset startFragRequested flag
      if (!this.loadedmetadata) {
        this.startFragRequested = false;
        this.nextLoadPosition = this.startPosition;
      }
      this.tick();
    }
  }, {
    key: 'onBufferFlushed',
    value: function onBufferFlushed() {
      /* after successful buffer flushing, filter flushed fragments from bufferedFrags
        use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)
      */
      var media = this.mediaBuffer ? this.mediaBuffer : this.media;
      if (media) {
        // filter fragments potentially evicted from buffer. this is to avoid memleak on live streams
        this.fragmentTracker.detectEvictedFragments(_fragment2.default.ElementaryStreamTypes.VIDEO, media.buffered);
      }
      // move to IDLE once flush complete. this should trigger new fragment loading
      this.state = _baseStreamController.State.IDLE;
      // reset reference to frag
      this.fragPrevious = null;
    }
  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      this.audioCodecSwap = !this.audioCodecSwap;
    }
  }, {
    key: 'computeLivePosition',
    value: function computeLivePosition(sliding, levelDetails) {
      var targetLatency = this.config.liveSyncDuration !== undefined ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;
      return sliding + Math.max(0, levelDetails.totalduration - targetLatency);
    }

    /**
     * Seeks to the set startPosition if not equal to the mediaElement's current time.
     * @private
     */

  }, {
    key: '_seekToStartPos',
    value: function _seekToStartPos() {
      var media = this.media;

      var currentTime = media.currentTime;
      // only adjust currentTime if different from startPosition or if startPosition not buffered
      // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered
      var startPosition = media.seeking ? currentTime : this.startPosition;
      // if currentTime not matching with expected startPosition or startPosition not buffered but close to first buffered
      if (currentTime !== startPosition) {
        // if startPosition not buffered, let's seek to buffered.start(0)
        _logger.logger.log('target start position not buffered, seek to buffered.start(0) ' + startPosition + ' from current time ' + currentTime + ' ');
        media.currentTime = startPosition;
      }
    }
  }, {
    key: '_getAudioCodec',
    value: function _getAudioCodec(currentLevel) {
      var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
      if (this.audioCodecSwap) {
        _logger.logger.log('swapping playlist audio codec');
        if (audioCodec) {
          if (audioCodec.indexOf('mp4a.40.5') !== -1) {
            audioCodec = 'mp4a.40.2';
          } else {
            audioCodec = 'mp4a.40.5';
          }
        }
      }

      return audioCodec;
    }
  }, {
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        _logger.logger.log('main stream:' + previousState + '->' + nextState);
        this.hls.trigger(_events2.default.STREAM_STATE_TRANSITION, { previousState: previousState, nextState: nextState });
      }
    },
    get: function get() {
      return this._state;
    }
  }, {
    key: 'currentLevel',
    get: function get() {
      var media = this.media;
      if (media) {
        var frag = this.getBufferedFrag(media.currentTime);
        if (frag) {
          return frag.level;
        }
      }
      return -1;
    }
  }, {
    key: 'nextBufferedFrag',
    get: function get() {
      var media = this.media;
      if (media) {
        // first get end range of current fragment
        return this.followingBufferedFrag(this.getBufferedFrag(media.currentTime));
      } else {
        return null;
      }
    }
  }, {
    key: 'nextLevel',
    get: function get() {
      var frag = this.nextBufferedFrag;
      if (frag) {
        return frag.level;
      } else {
        return -1;
      }
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this._liveSyncPosition;
    },
    set: function set(value) {
      this._liveSyncPosition = value;
    }
  }]);

  return StreamController;
}(_baseStreamController2.default);

exports.default = StreamController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/subtitle-stream-controller.js":
/*!*************************************************************!*\
  !*** ./src/hls.js/controller/subtitle-stream-controller.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SubtitleStreamController = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _decrypter = __webpack_require__(/*! ../crypt/decrypter */ "./src/hls.js/crypt/decrypter.js");

var _decrypter2 = _interopRequireDefault(_decrypter);

var _bufferHelper = __webpack_require__(/*! ../utils/buffer-helper */ "./src/hls.js/utils/buffer-helper.js");

var _fragmentFinders = __webpack_require__(/*! ./fragment-finders */ "./src/hls.js/controller/fragment-finders.js");

var _fragmentTracker = __webpack_require__(/*! ./fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _baseStreamController = __webpack_require__(/*! ./base-stream-controller */ "./src/hls.js/controller/base-stream-controller.js");

var _baseStreamController2 = _interopRequireDefault(_baseStreamController);

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @class SubtitleStreamController
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _window = window,
    performance = _window.performance;

var TICK_INTERVAL = 500; // how often to tick in ms

var SubtitleStreamController = exports.SubtitleStreamController = function (_BaseStreamController) {
  _inherits(SubtitleStreamController, _BaseStreamController);

  function SubtitleStreamController(hls, fragmentTracker) {
    _classCallCheck(this, SubtitleStreamController);

    var _this = _possibleConstructorReturn(this, (SubtitleStreamController.__proto__ || Object.getPrototypeOf(SubtitleStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.ERROR, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.SUBTITLE_TRACKS_UPDATED, _events2.default.SUBTITLE_TRACK_SWITCH, _events2.default.SUBTITLE_TRACK_LOADED, _events2.default.SUBTITLE_FRAG_PROCESSED, _events2.default.LEVEL_UPDATED));

    _this.fragmentTracker = fragmentTracker;
    _this.config = hls.config;
    _this.state = _baseStreamController.State.STOPPED;
    _this.tracks = [];
    _this.tracksBuffered = [];
    _this.currentTrackId = -1;
    _this.decrypter = new _decrypter2.default(hls, hls.config);
    // lastAVStart stores the time in seconds for the start time of a level load
    _this.lastAVStart = 0;
    _this._onMediaSeeking = _this.onMediaSeeking.bind(_this);
    return _this;
  }

  _createClass(SubtitleStreamController, [{
    key: 'onSubtitleFragProcessed',
    value: function onSubtitleFragProcessed(data) {
      var frag = data.frag,
          success = data.success;

      this.fragPrevious = frag;
      this.state = _baseStreamController.State.IDLE;
      if (!success) {
        return;
      }

      var buffered = this.tracksBuffered[this.currentTrackId];
      if (!buffered) {
        return;
      }

      // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo
      // so we can re-use the logic used to detect how much have been buffered
      var timeRange = void 0;
      var fragStart = frag.start;
      for (var i = 0; i < buffered.length; i++) {
        if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {
          timeRange = buffered[i];
          break;
        }
      }

      var fragEnd = frag.start + frag.duration;
      if (timeRange) {
        timeRange.end = fragEnd;
      } else {
        timeRange = {
          start: fragStart,
          end: fragEnd
        };
        buffered.push(timeRange);
      }
    }
  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(_ref) {
      var media = _ref.media;

      this.media = media;
      media.addEventListener('seeking', this._onMediaSeeking);
      this.state = _baseStreamController.State.IDLE;
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      this.media.removeEventListener('seeking', this._onMediaSeeking);
      this.media = null;
      this.state = _baseStreamController.State.STOPPED;
    }

    // If something goes wrong, proceed to next frag, if we were processing one.

  }, {
    key: 'onError',
    value: function onError(data) {
      var frag = data.frag;
      // don't handle error not related to subtitle fragment
      if (!frag || frag.type !== 'subtitle') {
        return;
      }
      this.state = _baseStreamController.State.IDLE;
    }

    // Got all new subtitle tracks.

  }, {
    key: 'onSubtitleTracksUpdated',
    value: function onSubtitleTracksUpdated(data) {
      var _this2 = this;

      _logger.logger.log('subtitle tracks updated');
      this.tracksBuffered = [];
      this.tracks = data.subtitleTracks;
      this.tracks.forEach(function (track) {
        _this2.tracksBuffered[track.id] = [];
      });
    }
  }, {
    key: 'onSubtitleTrackSwitch',
    value: function onSubtitleTrackSwitch(data) {
      this.currentTrackId = data.id;

      if (!this.tracks || this.currentTrackId === -1) {
        this.clearInterval();
        return;
      }

      // Check if track has the necessary details to load fragments
      var currentTrack = this.tracks[this.currentTrackId];
      if (currentTrack && currentTrack.details) {
        this.setInterval(TICK_INTERVAL);
      }
    }

    // Got a new set of subtitle fragments.

  }, {
    key: 'onSubtitleTrackLoaded',
    value: function onSubtitleTrackLoaded(data) {
      var id = data.id,
          details = data.details;
      var currentTrackId = this.currentTrackId,
          tracks = this.tracks;

      var currentTrack = tracks[currentTrackId];
      if (id >= tracks.length || id !== currentTrackId || !currentTrack) {
        return;
      }

      if (details.live) {
        (0, _levelHelper.mergeSubtitlePlaylists)(currentTrack.details, details, this.lastAVStart);
      }
      currentTrack.details = details;
      this.setInterval(TICK_INTERVAL);
    }
  }, {
    key: 'onKeyLoaded',
    value: function onKeyLoaded() {
      if (this.state === _baseStreamController.State.KEY_LOADING) {
        this.state = _baseStreamController.State.IDLE;
      }
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var fragCurrent = this.fragCurrent;
      var decryptData = data.frag.decryptdata;
      var fragLoaded = data.frag;
      var hls = this.hls;

      if (this.state === _baseStreamController.State.FRAG_LOADING && fragCurrent && data.frag.type === 'subtitle' && fragCurrent.sn === data.frag.sn) {
        // check to see if the payload needs to be decrypted
        if (data.payload.byteLength > 0 && decryptData && decryptData.key && decryptData.method === 'AES-128') {
          var startTime = performance.now();

          // decrypt the subtitles
          this.decrypter.decrypt(data.payload, decryptData.key.buffer, decryptData.iv.buffer, function (decryptedData) {
            var endTime = performance.now();
            hls.trigger(_events2.default.FRAG_DECRYPTED, { frag: fragLoaded, payload: decryptedData, stats: { tstart: startTime, tdecrypt: endTime } });
          });
        }
      }
    }
  }, {
    key: 'onLevelUpdated',
    value: function onLevelUpdated(_ref2) {
      var details = _ref2.details;

      var frags = details.fragments;
      this.lastAVStart = frags.length ? frags[0].start : 0;
    }
  }, {
    key: 'doTick',
    value: function doTick() {
      if (!this.media) {
        this.state = _baseStreamController.State.IDLE;
        return;
      }

      switch (this.state) {
        case _baseStreamController.State.IDLE:
          {
            var config = this.config,
                currentTrackId = this.currentTrackId,
                fragmentTracker = this.fragmentTracker,
                media = this.media,
                tracks = this.tracks;

            if (!tracks || !tracks[currentTrackId] || !tracks[currentTrackId].details) {
              break;
            }

            var maxBufferHole = config.maxBufferHole,
                maxFragLookUpTolerance = config.maxFragLookUpTolerance;

            var maxConfigBuffer = Math.min(config.maxBufferLength, config.maxMaxBufferLength);
            var bufferedInfo = _bufferHelper.BufferHelper.bufferedInfo(this._getBuffered(), media.currentTime, maxBufferHole);
            var bufferEnd = bufferedInfo.end,
                bufferLen = bufferedInfo.len;


            var trackDetails = tracks[currentTrackId].details;
            var fragments = trackDetails.fragments;
            var fragLen = fragments.length;
            var end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration;

            if (bufferLen > maxConfigBuffer) {
              return;
            }

            var foundFrag = void 0;
            var fragPrevious = this.fragPrevious;
            if (bufferEnd < end) {
              if (fragPrevious && trackDetails.hasProgramDateTime) {
                foundFrag = (0, _fragmentFinders.findFragmentByPDT)(fragments, fragPrevious.endProgramDateTime, maxFragLookUpTolerance);
              }
              if (!foundFrag) {
                foundFrag = (0, _fragmentFinders.findFragmentByPTS)(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance);
              }
            } else {
              foundFrag = fragments[fragLen - 1];
            }

            if (foundFrag && foundFrag.encrypted) {
              _logger.logger.log('Loading key for ' + foundFrag.sn);
              this.state = _baseStreamController.State.KEY_LOADING;
              this.hls.trigger(_events2.default.KEY_LOADING, { frag: foundFrag });
            } else if (foundFrag && fragmentTracker.getState(foundFrag) === _fragmentTracker.FragmentState.NOT_LOADED) {
              // only load if fragment is not loaded
              this.fragCurrent = foundFrag;
              this.state = _baseStreamController.State.FRAG_LOADING;
              this.hls.trigger(_events2.default.FRAG_LOADING, { frag: foundFrag });
            }
          }
      }
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.lastAVStart = 0;
      _get(SubtitleStreamController.prototype.__proto__ || Object.getPrototypeOf(SubtitleStreamController.prototype), 'stopLoad', this).call(this);
    }
  }, {
    key: '_getBuffered',
    value: function _getBuffered() {
      return this.tracksBuffered[this.currentTrackId] || [];
    }
  }, {
    key: 'onMediaSeeking',
    value: function onMediaSeeking() {
      this.fragPrevious = null;
    }
  }]);

  return SubtitleStreamController;
}(_baseStreamController2.default);

/***/ }),

/***/ "./src/hls.js/controller/subtitle-track-controller.js":
/*!************************************************************!*\
  !*** ./src/hls.js/controller/subtitle-track-controller.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _levelHelper = __webpack_require__(/*! ./level-helper */ "./src/hls.js/controller/level-helper.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SubtitleTrackController = function (_EventHandler) {
  _inherits(SubtitleTrackController, _EventHandler);

  function SubtitleTrackController(hls) {
    _classCallCheck(this, SubtitleTrackController);

    var _this = _possibleConstructorReturn(this, (SubtitleTrackController.__proto__ || Object.getPrototypeOf(SubtitleTrackController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADED, _events2.default.SUBTITLE_TRACK_LOADED));

    _this.tracks = [];
    _this.trackId = -1;
    _this.media = null;
    _this.stopped = true;

    /**
     * @member {boolean} subtitleDisplay Enable/disable subtitle display rendering
     */
    _this.subtitleDisplay = true;
    return _this;
  }

  _createClass(SubtitleTrackController, [{
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }

    // Listen for subtitle track change, then extract the current track ID.

  }, {
    key: 'onMediaAttached',
    value: function onMediaAttached(data) {
      var _this2 = this;

      this.media = data.media;
      if (!this.media) {
        return;
      }

      if (this.queuedDefaultTrack) {
        this.subtitleTrack = this.queuedDefaultTrack;
        delete this.queuedDefaultTrack;
      }

      this.trackChangeListener = this._onTextTracksChanged.bind(this);

      this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);
      if (this.useTextTrackPolling) {
        this.subtitlePollingInterval = setInterval(function () {
          _this2.trackChangeListener();
        }, 500);
      } else {
        this.media.textTracks.addEventListener('change', this.trackChangeListener);
      }
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      if (!this.media) {
        return;
      }

      if (this.useTextTrackPolling) {
        clearInterval(this.subtitlePollingInterval);
      } else {
        this.media.textTracks.removeEventListener('change', this.trackChangeListener);
      }

      this.media = null;
    }

    // Fired whenever a new manifest is loaded.

  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this3 = this;

      var tracks = data.subtitles || [];
      this.tracks = tracks;
      this.hls.trigger(_events2.default.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: tracks });

      // loop through available subtitle tracks and autoselect default if needed
      // TODO: improve selection logic to handle forced, etc
      tracks.forEach(function (track) {
        if (track.default) {
          // setting this.subtitleTrack will trigger internal logic
          // if media has not been attached yet, it will fail
          // we keep a reference to the default track id
          // and we'll set subtitleTrack when onMediaAttached is triggered
          if (_this3.media) {
            _this3.subtitleTrack = track.id;
          } else {
            _this3.queuedDefaultTrack = track.id;
          }
        }
      });
    }
  }, {
    key: 'onSubtitleTrackLoaded',
    value: function onSubtitleTrackLoaded(data) {
      var _this4 = this;

      var id = data.id,
          details = data.details;
      var trackId = this.trackId,
          tracks = this.tracks;

      var currentTrack = tracks[trackId];
      if (id >= tracks.length || id !== trackId || !currentTrack || this.stopped) {
        this._clearReloadTimer();
        return;
      }

      _logger.logger.log('subtitle track ' + id + ' loaded');
      if (details.live) {
        var reloadInterval = (0, _levelHelper.computeReloadInterval)(currentTrack.details, details, data.stats.trequest);
        _logger.logger.log('Reloading live subtitle playlist in ' + reloadInterval + 'ms');
        this.timer = setTimeout(function () {
          _this4._loadCurrentTrack();
        }, reloadInterval);
      } else {
        this._clearReloadTimer();
      }
    }
  }, {
    key: 'startLoad',
    value: function startLoad() {
      this.stopped = false;
      this._loadCurrentTrack();
    }
  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      this.stopped = true;
      this._clearReloadTimer();
    }

    /** get alternate subtitle tracks list from playlist **/

  }, {
    key: '_clearReloadTimer',
    value: function _clearReloadTimer() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    }
  }, {
    key: '_loadCurrentTrack',
    value: function _loadCurrentTrack() {
      var trackId = this.trackId,
          tracks = this.tracks,
          hls = this.hls;

      var currentTrack = tracks[trackId];
      if (trackId < 0 || !currentTrack || currentTrack.details && !currentTrack.details.live) {
        return;
      }
      _logger.logger.log('Loading subtitle track ' + trackId);
      hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: currentTrack.url, id: trackId });
    }

    /**
     * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.
     * This operates on the DOM textTracks.
     * A value of -1 will disable all subtitle tracks.
     * @param newId - The id of the next track to enable
     * @private
     */

  }, {
    key: '_toggleTrackModes',
    value: function _toggleTrackModes(newId) {
      var media = this.media,
          subtitleDisplay = this.subtitleDisplay,
          trackId = this.trackId;

      if (!media) {
        return;
      }

      var textTracks = filterSubtitleTracks(media.textTracks);
      if (newId === -1) {
        [].slice.call(textTracks).forEach(function (track) {
          track.mode = 'disabled';
        });
      } else {
        var oldTrack = textTracks[trackId];
        if (oldTrack) {
          oldTrack.mode = 'disabled';
        }
      }

      var nextTrack = textTracks[newId];
      if (nextTrack) {
        nextTrack.mode = subtitleDisplay ? 'showing' : 'hidden';
      }
    }

    /**
       * This method is responsible for validating the subtitle index and periodically reloading if live.
       * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.
       * @param newId - The id of the subtitle track to activate.
       */

  }, {
    key: '_setSubtitleTrackInternal',
    value: function _setSubtitleTrackInternal(newId) {
      var hls = this.hls,
          tracks = this.tracks;

      if (!Number.isFinite(newId) || newId < -1 || newId >= tracks.length) {
        return;
      }

      this.trackId = newId;
      _logger.logger.log('Switching to subtitle track ' + newId);
      hls.trigger(_events2.default.SUBTITLE_TRACK_SWITCH, { id: newId });
      this._loadCurrentTrack();
    }
  }, {
    key: '_onTextTracksChanged',
    value: function _onTextTracksChanged() {
      // Media is undefined when switching streams via loadSource()
      if (!this.media) {
        return;
      }

      var trackId = -1;
      var tracks = filterSubtitleTracks(this.media.textTracks);
      for (var id = 0; id < tracks.length; id++) {
        if (tracks[id].mode === 'hidden') {
          // Do not break in case there is a following track with showing.
          trackId = id;
        } else if (tracks[id].mode === 'showing') {
          trackId = id;
          break;
        }
      }

      // Setting current subtitleTrack will invoke code.
      this.subtitleTrack = trackId;
    }
  }, {
    key: 'subtitleTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected subtitle track (index in subtitle track lists) **/

  }, {
    key: 'subtitleTrack',
    get: function get() {
      return this.trackId;
    }

    /** select a subtitle track, based on its index in subtitle track lists**/
    ,
    set: function set(subtitleTrackId) {
      if (this.trackId !== subtitleTrackId) {
        this._toggleTrackModes(subtitleTrackId);
        this._setSubtitleTrackInternal(subtitleTrackId);
      }
    }
  }]);

  return SubtitleTrackController;
}(_eventHandler2.default);

function filterSubtitleTracks(textTrackList) {
  var tracks = [];
  for (var i = 0; i < textTrackList.length; i++) {
    var track = textTrackList[i];
    // Edge adds a track without a label; we don't want to use it
    if (track.kind === 'subtitles' && track.label) {
      tracks.push(textTrackList[i]);
    }
  }
  return tracks;
}

exports.default = SubtitleTrackController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/controller/timeline-controller.js":
/*!******************************************************!*\
  !*** ./src/hls.js/controller/timeline-controller.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _cea608Parser = __webpack_require__(/*! ../utils/cea-608-parser */ "./src/hls.js/utils/cea-608-parser.js");

var _cea608Parser2 = _interopRequireDefault(_cea608Parser);

var _outputFilter = __webpack_require__(/*! ../utils/output-filter */ "./src/hls.js/utils/output-filter.js");

var _outputFilter2 = _interopRequireDefault(_outputFilter);

var _webvttParser = __webpack_require__(/*! ../utils/webvtt-parser */ "./src/hls.js/utils/webvtt-parser.js");

var _webvttParser2 = _interopRequireDefault(_webvttParser);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _texttrackUtils = __webpack_require__(/*! ../utils/texttrack-utils */ "./src/hls.js/utils/texttrack-utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Timeline Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

function canReuseVttTextTrack(inUseTrack, manifestTrack) {
  return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
}

function intersection(x1, x2, y1, y2) {
  return Math.min(x2, y2) - Math.max(x1, y1);
}

var TimelineController = function (_EventHandler) {
  _inherits(TimelineController, _EventHandler);

  function TimelineController(hls) {
    _classCallCheck(this, TimelineController);

    var _this = _possibleConstructorReturn(this, (TimelineController.__proto__ || Object.getPrototypeOf(TimelineController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_USERDATA, _events2.default.FRAG_DECRYPTED, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.FRAG_LOADED, _events2.default.LEVEL_SWITCHING, _events2.default.INIT_PTS_FOUND));

    _this.hls = hls;
    _this.config = hls.config;
    _this.enabled = true;
    _this.Cues = hls.config.cueHandler;
    _this.textTracks = [];
    _this.tracks = [];
    _this.unparsedVttFrags = [];
    _this.initPTS = [];
    _this.cueRanges = [];
    _this.captionsTracks = {};

    _this.captionsProperties = {
      textTrack1: {
        label: _this.config.captionsTextTrack1Label,
        languageCode: _this.config.captionsTextTrack1LanguageCode
      },
      textTrack2: {
        label: _this.config.captionsTextTrack2Label,
        languageCode: _this.config.captionsTextTrack2LanguageCode
      }
    };

    if (_this.config.enableCEA708Captions) {
      var channel1 = new _outputFilter2.default(_this, 'textTrack1');
      var channel2 = new _outputFilter2.default(_this, 'textTrack2');

      _this.cea608Parser = new _cea608Parser2.default(0, channel1, channel2);
    }
    return _this;
  }

  _createClass(TimelineController, [{
    key: 'addCues',
    value: function addCues(trackName, startTime, endTime, screen) {
      // skip cues which overlap more than 50% with previously parsed time ranges
      var ranges = this.cueRanges;
      var merged = false;
      for (var i = ranges.length; i--;) {
        var cueRange = ranges[i];
        var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
        if (overlap >= 0) {
          cueRange[0] = Math.min(cueRange[0], startTime);
          cueRange[1] = Math.max(cueRange[1], endTime);
          merged = true;
          if (overlap / (endTime - startTime) > 0.5) {
            return;
          }
        }
      }
      if (!merged) {
        ranges.push([startTime, endTime]);
      }

      this.Cues.newCue(this.captionsTracks[trackName], startTime, endTime, screen);
    }

    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.

  }, {
    key: 'onInitPtsFound',
    value: function onInitPtsFound(data) {
      var _this2 = this;

      if (data.id === 'main') {
        this.initPTS[data.frag.cc] = data.initPTS;
      }

      // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.
      // Parse any unparsed fragments upon receiving the initial PTS.
      if (this.unparsedVttFrags.length) {
        var unparsedVttFrags = this.unparsedVttFrags;
        this.unparsedVttFrags = [];
        unparsedVttFrags.forEach(function (frag) {
          _this2.onFragLoaded(frag);
        });
      }
    }
  }, {
    key: 'getExistingTrack',
    value: function getExistingTrack(trackName) {
      var media = this.media;

      if (media) {
        for (var i = 0; i < media.textTracks.length; i++) {
          var textTrack = media.textTracks[i];
          if (textTrack[trackName]) {
            return textTrack;
          }
        }
      }
      return null;
    }
  }, {
    key: 'createCaptionsTrack',
    value: function createCaptionsTrack(trackName) {
      var _captionsProperties$t = this.captionsProperties[trackName],
          label = _captionsProperties$t.label,
          languageCode = _captionsProperties$t.languageCode;

      var captionsTracks = this.captionsTracks;
      if (!captionsTracks[trackName]) {
        // Enable reuse of existing text track.
        var existingTrack = this.getExistingTrack(trackName);
        if (!existingTrack) {
          var textTrack = this.createTextTrack('captions', label, languageCode);
          if (textTrack) {
            // Set a special property on the track so we know it's managed by Hls.js
            textTrack[trackName] = true;
            captionsTracks[trackName] = textTrack;
          }
        } else {
          captionsTracks[trackName] = existingTrack;
          (0, _texttrackUtils.clearCurrentCues)(captionsTracks[trackName]);
          (0, _texttrackUtils.sendAddTrackEvent)(captionsTracks[trackName], this.media);
        }
      }
    }
  }, {
    key: 'createTextTrack',
    value: function createTextTrack(kind, label, lang) {
      var media = this.media;
      if (media) {
        return media.addTextTrack(kind, label, lang);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onMediaAttaching',
    value: function onMediaAttaching(data) {
      this.media = data.media;
      this._cleanTracks();
    }
  }, {
    key: 'onMediaDetaching',
    value: function onMediaDetaching() {
      var captionsTracks = this.captionsTracks;

      Object.keys(captionsTracks).forEach(function (trackName) {
        (0, _texttrackUtils.clearCurrentCues)(captionsTracks[trackName]);
        delete captionsTracks[trackName];
      });
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading() {
      this.lastSn = -1; // Detect discontiguity in fragment parsing
      this.prevCC = -1;
      this.vttCCs = { // Detect discontinuity in subtitle manifests
        ccOffset: 0,
        presentationOffset: 0,
        0: {
          start: 0, prevCC: -1, new: false
        }
      };
      this._cleanTracks();
    }
  }, {
    key: '_cleanTracks',
    value: function _cleanTracks() {
      // clear outdated subtitles
      var media = this.media;
      if (media) {
        var textTracks = media.textTracks;
        if (textTracks) {
          for (var i = 0; i < textTracks.length; i++) {
            (0, _texttrackUtils.clearCurrentCues)(textTracks[i]);
          }
        }
      }
    }
  }, {
    key: 'onManifestLoaded',
    value: function onManifestLoaded(data) {
      var _this3 = this;

      this.textTracks = [];
      this.unparsedVttFrags = this.unparsedVttFrags || [];
      this.initPTS = [];
      this.cueRanges = [];

      if (this.config.enableWebVTT) {
        this.tracks = data.subtitles || [];
        var inUseTracks = this.media ? this.media.textTracks : [];

        this.tracks.forEach(function (track, index) {
          var textTrack = void 0;
          if (index < inUseTracks.length) {
            var inUseTrack = null;

            for (var i = 0; i < inUseTracks.length; i++) {
              if (canReuseVttTextTrack(inUseTracks[i], track)) {
                inUseTrack = inUseTracks[i];
                break;
              }
            }

            // Reuse tracks with the same label, but do not reuse 608/708 tracks
            if (inUseTrack) {
              textTrack = inUseTrack;
            }
          }
          if (!textTrack) {
            textTrack = _this3.createTextTrack('subtitles', track.name, track.lang);
          }

          if (track.default) {
            textTrack.mode = _this3.hls.subtitleDisplay ? 'showing' : 'hidden';
          } else {
            textTrack.mode = 'disabled';
          }

          _this3.textTracks.push(textTrack);
        });
      }
    }
  }, {
    key: 'onLevelSwitching',
    value: function onLevelSwitching() {
      this.enabled = this.hls.currentLevel.closedCaptions !== 'NONE';
    }
  }, {
    key: 'onFragLoaded',
    value: function onFragLoaded(data) {
      var frag = data.frag,
          payload = data.payload;
      if (frag.type === 'main') {
        var sn = frag.sn;
        // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack
        if (sn !== this.lastSn + 1) {
          var cea608Parser = this.cea608Parser;
          if (cea608Parser) {
            cea608Parser.reset();
          }
        }
        this.lastSn = sn;
      } // eslint-disable-line brace-style
      // If fragment is subtitle type, parse as WebVTT.
      else if (frag.type === 'subtitle') {
          if (payload.byteLength) {
            // We need an initial synchronisation PTS. Store fragments as long as none has arrived.
            if (!Number.isFinite(this.initPTS[frag.cc])) {
              this.unparsedVttFrags.push(data);
              if (this.initPTS.length) {
                // finish unsuccessfully, otherwise the subtitle-stream-controller could be blocked from loading new frags.
                this.hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
              }
              return;
            }

            var decryptData = frag.decryptdata;
            // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.
            if (decryptData == null || decryptData.key == null || decryptData.method !== 'AES-128') {
              this._parseVTTs(frag, payload);
            }
          } else {
            // In case there is no payload, finish unsuccessfully.
            this.hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
          }
        }
    }
  }, {
    key: '_parseVTTs',
    value: function _parseVTTs(frag, payload) {
      var vttCCs = this.vttCCs;
      if (!vttCCs[frag.cc]) {
        vttCCs[frag.cc] = { start: frag.start, prevCC: this.prevCC, new: true };
        this.prevCC = frag.cc;
      }
      var textTracks = this.textTracks,
          hls = this.hls;

      // Parse the WebVTT file contents.
      _webvttParser2.default.parse(payload, this.initPTS[frag.cc], vttCCs, frag.cc, function (cues) {
        var currentTrack = textTracks[frag.level];
        // WebVTTParser.parse is an async method and if the currently selected text track mode is set to "disabled"
        // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null
        // and trying to access getCueById method of cues will throw an exception
        if (currentTrack.mode === 'disabled') {
          hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
          return;
        }
        // Add cues and trigger event with success true.
        cues.forEach(function (cue) {
          // Sometimes there are cue overlaps on segmented vtts so the same
          // cue can appear more than once in different vtt files.
          // This avoid showing duplicated cues with same timecode and text.
          if (!currentTrack.cues.getCueById(cue.id)) {
            try {
              currentTrack.addCue(cue);
            } catch (err) {
              var textTrackCue = new window.TextTrackCue(cue.startTime, cue.endTime, cue.text);
              textTrackCue.id = cue.id;
              currentTrack.addCue(textTrackCue);
            }
          }
        });
        hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: true, frag: frag });
      }, function (e) {
        // Something went wrong while parsing. Trigger event with success false.
        _logger.logger.log('Failed to parse VTT cue: ' + e);
        hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
      });
    }
  }, {
    key: 'onFragDecrypted',
    value: function onFragDecrypted(data) {
      var decryptedData = data.payload,
          frag = data.frag;

      if (frag.type === 'subtitle') {
        if (!Number.isFinite(this.initPTS[frag.cc])) {
          this.unparsedVttFrags.push(data);
          return;
        }

        this._parseVTTs(frag, decryptedData);
      }
    }
  }, {
    key: 'onFragParsingUserdata',
    value: function onFragParsingUserdata(data) {
      // push all of the CEA-708 messages into the interpreter
      // immediately. It will create the proper timestamps based on our PTS value
      if (this.enabled && this.config.enableCEA708Captions) {
        for (var i = 0; i < data.samples.length; i++) {
          var ccdatas = this.extractCea608Data(data.samples[i].bytes);
          this.cea608Parser.addData(data.samples[i].pts, ccdatas);
        }
      }
    }
  }, {
    key: 'extractCea608Data',
    value: function extractCea608Data(byteArray) {
      var count = byteArray[0] & 31;
      var position = 2;
      var tmpByte = void 0,
          ccbyte1 = void 0,
          ccbyte2 = void 0,
          ccValid = void 0,
          ccType = void 0;
      var actualCCBytes = [];

      for (var j = 0; j < count; j++) {
        tmpByte = byteArray[position++];
        ccbyte1 = 0x7F & byteArray[position++];
        ccbyte2 = 0x7F & byteArray[position++];
        ccValid = (4 & tmpByte) !== 0;
        ccType = 3 & tmpByte;

        if (ccbyte1 === 0 && ccbyte2 === 0) {
          continue;
        }

        if (ccValid) {
          if (ccType === 0) {
            // || ccType === 1
            actualCCBytes.push(ccbyte1);
            actualCCBytes.push(ccbyte2);
          }
        }
      }
      return actualCCBytes;
    }
  }]);

  return TimelineController;
}(_eventHandler2.default);

exports.default = TimelineController;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/crypt/aes-crypto.js":
/*!****************************************!*\
  !*** ./src/hls.js/crypt/aes-crypto.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AESCrypto = function () {
  function AESCrypto(subtle, iv) {
    _classCallCheck(this, AESCrypto);

    this.subtle = subtle;
    this.aesIV = iv;
  }

  _createClass(AESCrypto, [{
    key: 'decrypt',
    value: function decrypt(data, key) {
      return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);
    }
  }]);

  return AESCrypto;
}();

exports.default = AESCrypto;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/crypt/aes-decryptor.js":
/*!*******************************************!*\
  !*** ./src/hls.js/crypt/aes-decryptor.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.removePadding = removePadding;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// PKCS7
function removePadding(buffer) {
  var outputBytes = buffer.byteLength;
  var paddingBytes = outputBytes && new DataView(buffer).getUint8(outputBytes - 1);
  if (paddingBytes) {
    return buffer.slice(0, outputBytes - paddingBytes);
  } else {
    return buffer;
  }
}

var AESDecryptor = function () {
  function AESDecryptor() {
    _classCallCheck(this, AESDecryptor);

    // Static after running initTable
    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.sBox = new Uint32Array(256);
    this.invSBox = new Uint32Array(256);

    // Changes during runtime
    this.key = new Uint32Array(0);

    this.initTable();
  }

  // Using view.getUint32() also swaps the byte order.


  _createClass(AESDecryptor, [{
    key: 'uint8ArrayToUint32Array_',
    value: function uint8ArrayToUint32Array_(arrayBuffer) {
      var view = new DataView(arrayBuffer);
      var newArray = new Uint32Array(4);
      for (var i = 0; i < 4; i++) {
        newArray[i] = view.getUint32(i * 4);
      }

      return newArray;
    }
  }, {
    key: 'initTable',
    value: function initTable() {
      var sBox = this.sBox;
      var invSBox = this.invSBox;
      var subMix = this.subMix;
      var subMix0 = subMix[0];
      var subMix1 = subMix[1];
      var subMix2 = subMix[2];
      var subMix3 = subMix[3];
      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var d = new Uint32Array(256);
      var x = 0;
      var xi = 0;
      var i = 0;
      for (i = 0; i < 256; i++) {
        if (i < 128) {
          d[i] = i << 1;
        } else {
          d[i] = i << 1 ^ 0x11b;
        }
      }

      for (i = 0; i < 256; i++) {
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        sBox[x] = sx;
        invSBox[sx] = x;

        // Compute multiplication
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];

        // Compute sub/invSub bytes, mix columns tables
        var t = d[sx] * 0x101 ^ sx * 0x1010100;
        subMix0[x] = t << 24 | t >>> 8;
        subMix1[x] = t << 16 | t >>> 16;
        subMix2[x] = t << 8 | t >>> 24;
        subMix3[x] = t;

        // Compute inv sub bytes, inv mix columns tables
        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        invSubMix0[sx] = t << 24 | t >>> 8;
        invSubMix1[sx] = t << 16 | t >>> 16;
        invSubMix2[sx] = t << 8 | t >>> 24;
        invSubMix3[sx] = t;

        // Compute next counter
        if (!x) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
    }
  }, {
    key: 'expandKey',
    value: function expandKey(keyBuffer) {
      // convert keyBuffer to Uint32Array
      var key = this.uint8ArrayToUint32Array_(keyBuffer);
      var sameKey = true;
      var offset = 0;

      while (offset < key.length && sameKey) {
        sameKey = key[offset] === this.key[offset];
        offset++;
      }

      if (sameKey) {
        return;
      }

      this.key = key;
      var keySize = this.keySize = key.length;

      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
        throw new Error('Invalid aes key size=' + keySize);
      }

      var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
      var ksRow = void 0;
      var invKsRow = void 0;

      var keySchedule = this.keySchedule = new Uint32Array(ksRows);
      var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
      var sbox = this.sBox;
      var rcon = this.rcon;

      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var prev = void 0;
      var t = void 0;

      for (ksRow = 0; ksRow < ksRows; ksRow++) {
        if (ksRow < keySize) {
          prev = keySchedule[ksRow] = key[ksRow];
          continue;
        }
        t = prev;

        if (ksRow % keySize === 0) {
          // Rot word
          t = t << 8 | t >>> 24;

          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];

          // Mix Rcon
          t ^= rcon[ksRow / keySize | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          // Sub word
          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
        }

        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
      }

      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        ksRow = ksRows - invKsRow;
        if (invKsRow & 3) {
          t = keySchedule[ksRow];
        } else {
          t = keySchedule[ksRow - 4];
        }

        if (invKsRow < 4 || ksRow <= 4) {
          invKeySchedule[invKsRow] = t;
        } else {
          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
        }

        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
      }
    }

    // Adding this as a method greatly improves performance.

  }, {
    key: 'networkToHostOrderSwap',
    value: function networkToHostOrderSwap(word) {
      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
    }
  }, {
    key: 'decrypt',
    value: function decrypt(inputArrayBuffer, offset, aesIV, removePKCS7Padding) {
      var nRounds = this.keySize + 6;
      var invKeySchedule = this.invKeySchedule;
      var invSBOX = this.invSBox;

      var invSubMix = this.invSubMix;
      var invSubMix0 = invSubMix[0];
      var invSubMix1 = invSubMix[1];
      var invSubMix2 = invSubMix[2];
      var invSubMix3 = invSubMix[3];

      var initVector = this.uint8ArrayToUint32Array_(aesIV);
      var initVector0 = initVector[0];
      var initVector1 = initVector[1];
      var initVector2 = initVector[2];
      var initVector3 = initVector[3];

      var inputInt32 = new Int32Array(inputArrayBuffer);
      var outputInt32 = new Int32Array(inputInt32.length);

      var t0 = void 0,
          t1 = void 0,
          t2 = void 0,
          t3 = void 0;
      var s0 = void 0,
          s1 = void 0,
          s2 = void 0,
          s3 = void 0;
      var inputWords0 = void 0,
          inputWords1 = void 0,
          inputWords2 = void 0,
          inputWords3 = void 0;

      var ksRow = void 0,
          i = void 0;
      var swapWord = this.networkToHostOrderSwap;

      while (offset < inputInt32.length) {
        inputWords0 = swapWord(inputInt32[offset]);
        inputWords1 = swapWord(inputInt32[offset + 1]);
        inputWords2 = swapWord(inputInt32[offset + 2]);
        inputWords3 = swapWord(inputInt32[offset + 3]);

        s0 = inputWords0 ^ invKeySchedule[0];
        s1 = inputWords3 ^ invKeySchedule[1];
        s2 = inputWords2 ^ invKeySchedule[2];
        s3 = inputWords1 ^ invKeySchedule[3];

        ksRow = 4;

        // Iterate through the rounds of decryption
        for (i = 1; i < nRounds; i++) {
          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
          // Update state
          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;

          ksRow = ksRow + 4;
        }

        // Shift rows, sub bytes, add round key
        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];
        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
        ksRow = ksRow + 3;

        // Write
        outputInt32[offset] = swapWord(t0 ^ initVector0);
        outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
        outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
        outputInt32[offset + 3] = swapWord(t1 ^ initVector3);

        // reset initVector to last 4 unsigned int
        initVector0 = inputWords0;
        initVector1 = inputWords1;
        initVector2 = inputWords2;
        initVector3 = inputWords3;

        offset = offset + 4;
      }

      return removePKCS7Padding ? removePadding(outputInt32.buffer) : outputInt32.buffer;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.key = undefined;
      this.keySize = undefined;
      this.ksRows = undefined;

      this.sBox = undefined;
      this.invSBox = undefined;
      this.subMix = undefined;
      this.invSubMix = undefined;
      this.keySchedule = undefined;
      this.invKeySchedule = undefined;

      this.rcon = undefined;
    }
  }]);

  return AESDecryptor;
}();

exports.default = AESDecryptor;

/***/ }),

/***/ "./src/hls.js/crypt/decrypter.js":
/*!***************************************!*\
  !*** ./src/hls.js/crypt/decrypter.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _aesCrypto = __webpack_require__(/*! ./aes-crypto */ "./src/hls.js/crypt/aes-crypto.js");

var _aesCrypto2 = _interopRequireDefault(_aesCrypto);

var _fastAesKey = __webpack_require__(/*! ./fast-aes-key */ "./src/hls.js/crypt/fast-aes-key.js");

var _fastAesKey2 = _interopRequireDefault(_fastAesKey);

var _aesDecryptor = __webpack_require__(/*! ./aes-decryptor */ "./src/hls.js/crypt/aes-decryptor.js");

var _aesDecryptor2 = _interopRequireDefault(_aesDecryptor);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _getSelfScope = __webpack_require__(/*! ../utils/get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// see https://stackoverflow.com/a/11237259/589493
var global = (0, _getSelfScope.getSelfScope)(); // safeguard for code that might run both on worker and main thread

var Decrypter = function () {
  function Decrypter(observer, config) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$removePKCS7Paddi = _ref.removePKCS7Padding,
        removePKCS7Padding = _ref$removePKCS7Paddi === undefined ? true : _ref$removePKCS7Paddi;

    _classCallCheck(this, Decrypter);

    this.logEnabled = true;
    this.observer = observer;
    this.config = config;
    this.removePKCS7Padding = removePKCS7Padding;
    // built in decryptor expects PKCS7 padding
    if (removePKCS7Padding) {
      try {
        var browserCrypto = global.crypto;
        if (browserCrypto) {
          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
        }
      } catch (e) {}
    }
    this.disableWebCrypto = !this.subtle;
  }

  _createClass(Decrypter, [{
    key: 'isSync',
    value: function isSync() {
      return this.disableWebCrypto && this.config.enableSoftwareAES;
    }
  }, {
    key: 'decrypt',
    value: function decrypt(data, key, iv, callback) {
      var _this = this;

      if (this.disableWebCrypto && this.config.enableSoftwareAES) {
        if (this.logEnabled) {
          _logger.logger.log('JS AES decrypt');
          this.logEnabled = false;
        }
        var decryptor = this.decryptor;
        if (!decryptor) {
          this.decryptor = decryptor = new _aesDecryptor2.default();
        }

        decryptor.expandKey(key);
        callback(decryptor.decrypt(data, 0, iv, this.removePKCS7Padding));
      } else {
        if (this.logEnabled) {
          _logger.logger.log('WebCrypto AES decrypt');
          this.logEnabled = false;
        }
        var subtle = this.subtle;
        if (this.key !== key) {
          this.key = key;
          this.fastAesKey = new _fastAesKey2.default(subtle, key);
        }

        this.fastAesKey.expandKey().then(function (aesKey) {
          // decrypt using web crypto
          var crypto = new _aesCrypto2.default(subtle, iv);
          crypto.decrypt(data, aesKey).catch(function (err) {
            _this.onWebCryptoError(err, data, key, iv, callback);
          }).then(function (result) {
            callback(result);
          });
        }).catch(function (err) {
          _this.onWebCryptoError(err, data, key, iv, callback);
        });
      }
    }
  }, {
    key: 'onWebCryptoError',
    value: function onWebCryptoError(err, data, key, iv, callback) {
      if (this.config.enableSoftwareAES) {
        _logger.logger.log('WebCrypto Error, disable WebCrypto API');
        this.disableWebCrypto = true;
        this.logEnabled = true;
        this.decrypt(data, key, iv, callback);
      } else {
        _logger.logger.error('decrypting error : ' + err.message);
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var decryptor = this.decryptor;
      if (decryptor) {
        decryptor.destroy();
        this.decryptor = undefined;
      }
    }
  }]);

  return Decrypter;
}();

exports.default = Decrypter;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/crypt/fast-aes-key.js":
/*!******************************************!*\
  !*** ./src/hls.js/crypt/fast-aes-key.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FastAESKey = function () {
  function FastAESKey(subtle, key) {
    _classCallCheck(this, FastAESKey);

    this.subtle = subtle;
    this.key = key;
  }

  _createClass(FastAESKey, [{
    key: 'expandKey',
    value: function expandKey() {
      return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);
    }
  }]);

  return FastAESKey;
}();

exports.default = FastAESKey;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/aacdemuxer.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/aacdemuxer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AAC demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _adts = __webpack_require__(/*! ./adts */ "./src/hls.js/demux/adts.js");

var ADTS = _interopRequireWildcard(_adts);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _id = __webpack_require__(/*! ../demux/id3 */ "./src/hls.js/demux/id3.js");

var _id2 = _interopRequireDefault(_id);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AACDemuxer = function () {
  function AACDemuxer(observer, remuxer, config) {
    _classCallCheck(this, AACDemuxer);

    this.observer = observer;
    this.config = config;
    this.remuxer = remuxer;
  }

  _createClass(AACDemuxer, [{
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this._audioTrack = { container: 'audio/adts', type: 'audio', id: 0, sequenceNumber: 0, isAAC: true, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
    }
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var track = this._audioTrack;
      var id3Data = _id2.default.getID3Data(data, 0) || [];
      var timestamp = _id2.default.getTimeStamp(id3Data);
      var pts = Number.isFinite(timestamp) ? timestamp * 90 : timeOffset * 90000;
      var frameIndex = 0;
      var stamp = pts;
      var length = data.length;
      var offset = id3Data.length;

      var id3Samples = [{ pts: stamp, dts: stamp, data: id3Data }];

      while (offset < length - 1) {
        if (ADTS.isHeader(data, offset) && offset + 5 < length) {
          ADTS.initTrackConfig(track, this.observer, data, offset, track.manifestCodec);
          var frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);
          if (frame) {
            offset += frame.length;
            stamp = frame.sample.pts;
            frameIndex++;
          } else {
            _logger.logger.log('Unable to parse AAC frame');
            break;
          }
        } else if (_id2.default.isHeader(data, offset)) {
          id3Data = _id2.default.getID3Data(data, offset);
          id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });
          offset += id3Data.length;
        } else {
          // nothing found, keep looking
          offset++;
        }
      }

      this.remuxer.remux(track, { samples: [] }, { samples: id3Samples, inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      if (!data) {
        return false;
      }

      // Check for the ADTS sync word
      // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
      // Layer bits (position 14 and 15) in header should be always 0 for ADTS
      // More info https://wiki.multimedia.cx/index.php?title=ADTS
      var id3Data = _id2.default.getID3Data(data, 0) || [];
      var offset = id3Data.length;

      for (var length = data.length; offset < length; offset++) {
        if (ADTS.probe(data, offset)) {
          _logger.logger.log('ADTS sync word found !');
          return true;
        }
      }
      return false;
    }
  }]);

  return AACDemuxer;
}();

exports.default = AACDemuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/adts.js":
/*!**********************************!*\
  !*** ./src/hls.js/demux/adts.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAudioConfig = getAudioConfig;
exports.isHeaderPattern = isHeaderPattern;
exports.getHeaderLength = getHeaderLength;
exports.getFullFrameLength = getFullFrameLength;
exports.isHeader = isHeader;
exports.probe = probe;
exports.initTrackConfig = initTrackConfig;
exports.getFrameDuration = getFrameDuration;
exports.parseFrameHeader = parseFrameHeader;
exports.appendFrame = appendFrame;

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _getSelfScope = __webpack_require__(/*! ../utils/get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *  ADTS parser helper
 */
function getAudioConfig(observer, data, offset, audioCodec) {
  var adtsObjectType = void 0,
      // :int
  adtsSampleingIndex = void 0,
      // :int
  adtsExtensionSampleingIndex = void 0,
      // :int
  adtsChanelConfig = void 0,
      // :int
  config = void 0,
      userAgent = navigator.userAgent.toLowerCase(),
      manifestCodec = audioCodec,
      adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
  // byte 2
  adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;
  adtsSampleingIndex = (data[offset + 2] & 0x3C) >>> 2;
  if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
    observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'invalid ADTS sampling index:' + adtsSampleingIndex });
    return;
  }
  adtsChanelConfig = (data[offset + 2] & 0x01) << 2;
  // byte 3
  adtsChanelConfig |= (data[offset + 3] & 0xC0) >>> 6;
  _logger.logger.log('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);
  // firefox: freq less than 24kHz = AAC SBR (HE-AAC)
  if (/firefox/i.test(userAgent)) {
    if (adtsSampleingIndex >= 6) {
      adtsObjectType = 5;
      config = new Array(4);
      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
      // there is a factor 2 between frame sample rate and output sample rate
      // multiply frequency by 2 (see table below, equivalent to substract 3)
      adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
    } else {
      adtsObjectType = 2;
      config = new Array(2);
      adtsExtensionSampleingIndex = adtsSampleingIndex;
    }
    // Android : always use AAC
  } else if (userAgent.indexOf('android') !== -1) {
    adtsObjectType = 2;
    config = new Array(2);
    adtsExtensionSampleingIndex = adtsSampleingIndex;
  } else {
    /*  for other browsers (Chrome/Vivaldi/Opera ...)
        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
    */
    adtsObjectType = 5;
    config = new Array(4);
    // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
    if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {
      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
      // there is a factor 2 between frame sample rate and output sample rate
      // multiply frequency by 2 (see table below, equivalent to substract 3)
      adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
    } else {
      // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
      // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
      if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChanelConfig === 1) {
        adtsObjectType = 2;
        config = new Array(2);
      }
      adtsExtensionSampleingIndex = adtsSampleingIndex;
    }
  }
  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
      ISO 14496-3 (AAC).pdf - Table 1.13 — Syntax of AudioSpecificConfig()
    Audio Profile / Audio Object Type
    0: Null
    1: AAC Main
    2: AAC LC (Low Complexity)
    3: AAC SSR (Scalable Sample Rate)
    4: AAC LTP (Long Term Prediction)
    5: SBR (Spectral Band Replication)
    6: AAC Scalable
   sampling freq
    0: 96000 Hz
    1: 88200 Hz
    2: 64000 Hz
    3: 48000 Hz
    4: 44100 Hz
    5: 32000 Hz
    6: 24000 Hz
    7: 22050 Hz
    8: 16000 Hz
    9: 12000 Hz
    10: 11025 Hz
    11: 8000 Hz
    12: 7350 Hz
    13: Reserved
    14: Reserved
    15: frequency is written explictly
    Channel Configurations
    These are the channel configurations:
    0: Defined in AOT Specifc Config
    1: 1 channel: front-center
    2: 2 channels: front-left, front-right
  */
  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
  config[0] = adtsObjectType << 3;
  // samplingFrequencyIndex
  config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
  config[1] |= (adtsSampleingIndex & 0x01) << 7;
  // channelConfiguration
  config[1] |= adtsChanelConfig << 3;
  if (adtsObjectType === 5) {
    // adtsExtensionSampleingIndex
    config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
    config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;
    // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
    //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
    config[2] |= 2 << 2;
    config[3] = 0;
  }
  return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: 'mp4a.40.' + adtsObjectType, manifestCodec: manifestCodec };
}

function isHeaderPattern(data, offset) {
  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;
}

function getHeaderLength(data, offset) {
  return data[offset + 1] & 0x01 ? 7 : 9;
}

function getFullFrameLength(data, offset) {
  return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
}

function isHeader(data, offset) {
  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
  // Layer bits (position 14 and 15) in header should be always 0 for ADTS
  // More info https://wiki.multimedia.cx/index.php?title=ADTS
  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
    return true;
  }

  return false;
}

function probe(data, offset) {
  // same as isHeader but we also check that ADTS frame follows last ADTS frame
  // or end of data is reached
  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
    // ADTS header Length
    var headerLength = getHeaderLength(data, offset);
    // ADTS frame Length
    var frameLength = headerLength;
    if (offset + 5 < data.length) {
      frameLength = getFullFrameLength(data, offset);
    }

    var newOffset = offset + frameLength;
    if (newOffset === data.length || newOffset + 1 < data.length && isHeaderPattern(data, newOffset)) {
      return true;
    }
  }
  return false;
}

function initTrackConfig(track, observer, data, offset, audioCodec) {
  if (!track.samplerate) {
    var config = getAudioConfig(observer, data, offset, audioCodec);
    track.config = config.config;
    track.samplerate = config.samplerate;
    track.channelCount = config.channelCount;
    track.codec = config.codec;
    track.manifestCodec = config.manifestCodec;
    _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
  }
}

function getFrameDuration(samplerate) {
  return 1024 * 90000 / samplerate;
}

function parseFrameHeader(data, offset, pts, frameIndex, frameDuration) {
  var headerLength = void 0,
      frameLength = void 0,
      stamp = void 0;
  var length = data.length;

  // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
  headerLength = getHeaderLength(data, offset);
  // retrieve frame size
  frameLength = getFullFrameLength(data, offset);
  frameLength -= headerLength;

  if (frameLength > 0 && offset + headerLength + frameLength <= length) {
    stamp = pts + frameIndex * frameDuration;
    // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
    return { headerLength: headerLength, frameLength: frameLength, stamp: stamp };
  }

  return undefined;
}

function appendFrame(track, data, offset, pts, frameIndex) {
  var frameDuration = getFrameDuration(track.samplerate);
  var header = parseFrameHeader(data, offset, pts, frameIndex, frameDuration);
  if (header) {
    var stamp = header.stamp;
    var headerLength = header.headerLength;
    var frameLength = header.frameLength;

    // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
    var aacSample = {
      unit: data.subarray(offset + headerLength, offset + headerLength + frameLength),
      pts: stamp,
      dts: stamp
    };

    track.samples.push(aacSample);
    track.len += frameLength;

    return { sample: aacSample, length: frameLength + headerLength };
  }

  return undefined;
}

/***/ }),

/***/ "./src/hls.js/demux/demuxer-inline.js":
/*!********************************************!*\
  !*** ./src/hls.js/demux/demuxer-inline.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * inline demuxer: probe fragments and instantiate
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _decrypter = __webpack_require__(/*! ../crypt/decrypter */ "./src/hls.js/crypt/decrypter.js");

var _decrypter2 = _interopRequireDefault(_decrypter);

var _aacdemuxer = __webpack_require__(/*! ../demux/aacdemuxer */ "./src/hls.js/demux/aacdemuxer.js");

var _aacdemuxer2 = _interopRequireDefault(_aacdemuxer);

var _mp4demuxer = __webpack_require__(/*! ../demux/mp4demuxer */ "./src/hls.js/demux/mp4demuxer.js");

var _mp4demuxer2 = _interopRequireDefault(_mp4demuxer);

var _tsdemuxer = __webpack_require__(/*! ../demux/tsdemuxer */ "./src/hls.js/demux/tsdemuxer.js");

var _tsdemuxer2 = _interopRequireDefault(_tsdemuxer);

var _mp3demuxer = __webpack_require__(/*! ../demux/mp3demuxer */ "./src/hls.js/demux/mp3demuxer.js");

var _mp3demuxer2 = _interopRequireDefault(_mp3demuxer);

var _mp4Remuxer = __webpack_require__(/*! ../remux/mp4-remuxer */ "./src/hls.js/remux/mp4-remuxer.js");

var _mp4Remuxer2 = _interopRequireDefault(_mp4Remuxer);

var _passthroughRemuxer = __webpack_require__(/*! ../remux/passthrough-remuxer */ "./src/hls.js/remux/passthrough-remuxer.js");

var _passthroughRemuxer2 = _interopRequireDefault(_passthroughRemuxer);

var _getSelfScope = __webpack_require__(/*! ../utils/get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// see https://stackoverflow.com/a/11237259/589493
var global = (0, _getSelfScope.getSelfScope)(); // safeguard for code that might run both on worker and main thread

var now = void 0;
// performance.now() not available on WebWorker, at least on Safari Desktop
try {
  now = global.performance.now.bind(global.performance);
} catch (err) {
  _logger.logger.debug('Unable to use Performance API on this environment');
  now = global.Date.now;
}

var DemuxerInline = function () {
  function DemuxerInline(observer, typeSupported, config, vendor) {
    _classCallCheck(this, DemuxerInline);

    this.observer = observer;
    this.typeSupported = typeSupported;
    this.config = config;
    this.vendor = vendor;
  }

  _createClass(DemuxerInline, [{
    key: 'destroy',
    value: function destroy() {
      var demuxer = this.demuxer;
      if (demuxer) {
        demuxer.destroy();
      }
    }
  }, {
    key: 'push',
    value: function push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
      var _this = this;

      if (data.byteLength > 0 && decryptdata != null && decryptdata.key != null && decryptdata.method === 'AES-128') {
        var decrypter = this.decrypter;
        if (decrypter == null) {
          decrypter = this.decrypter = new _decrypter2.default(this.observer, this.config);
        }

        var startTime = now();
        decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function (decryptedData) {
          var endTime = now();
          _this.observer.trigger(_events2.default.FRAG_DECRYPTED, { stats: { tstart: startTime, tdecrypt: endTime } });
          _this.pushDecrypted(new Uint8Array(decryptedData), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
        });
      } else {
        this.pushDecrypted(new Uint8Array(data), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
      }
    }
  }, {
    key: 'pushDecrypted',
    value: function pushDecrypted(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
      var demuxer = this.demuxer;
      if (!demuxer ||
      // in case of continuity change, or track switch
      // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)
      // so let's check that current demuxer is still valid
      (discontinuity || trackSwitch) && !this.probe(data)) {
        var observer = this.observer;
        var typeSupported = this.typeSupported;
        var config = this.config;
        // probing order is TS/AAC/MP3/MP4
        var muxConfig = [{ demux: _tsdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _mp4demuxer2.default, remux: _passthroughRemuxer2.default }, { demux: _aacdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _mp3demuxer2.default, remux: _mp4Remuxer2.default }];

        // probe for content type
        for (var i = 0, len = muxConfig.length; i < len; i++) {
          var mux = muxConfig[i];
          var probe = mux.demux.probe;
          if (probe(data)) {
            var _remuxer = this.remuxer = new mux.remux(observer, config, typeSupported, this.vendor);
            demuxer = new mux.demux(observer, _remuxer, config, typeSupported);
            this.probe = probe;
            break;
          }
        }
        if (!demuxer) {
          observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });
          return;
        }
        this.demuxer = demuxer;
      }
      var remuxer = this.remuxer;

      if (discontinuity || trackSwitch) {
        demuxer.resetInitSegment(initSegment, audioCodec, videoCodec, duration);
        remuxer.resetInitSegment();
      }
      if (discontinuity) {
        demuxer.resetTimeStamp(defaultInitPTS);
        remuxer.resetTimeStamp(defaultInitPTS);
      }
      if (typeof demuxer.setDecryptData === 'function') {
        demuxer.setDecryptData(decryptdata);
      }

      demuxer.append(data, timeOffset, contiguous, accurateTimeOffset);
    }
  }]);

  return DemuxerInline;
}();

exports.default = DemuxerInline;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/demuxer-worker.js":
/*!********************************************!*\
  !*** ./src/hls.js/demux/demuxer-worker.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _demuxerInline = __webpack_require__(/*! ../demux/demuxer-inline */ "./src/hls.js/demux/demuxer-inline.js");

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _events3 = __webpack_require__(/*! events */ "../../node_modules/events/events.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* demuxer web worker.
 *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
 *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
 */

var DemuxerWorker = function DemuxerWorker(self) {
  // observer setup
  var observer = new _events3.EventEmitter();
  observer.trigger = function trigger(event) {
    for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    observer.emit.apply(observer, [event, event].concat(data));
  };

  observer.off = function off(event) {
    for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      data[_key2 - 1] = arguments[_key2];
    }

    observer.removeListener.apply(observer, [event].concat(data));
  };

  var forwardMessage = function forwardMessage(ev, data) {
    self.postMessage({ event: ev, data: data });
  };

  self.addEventListener('message', function (ev) {
    var data = ev.data;
    // console.log('demuxer cmd:' + data.cmd);
    switch (data.cmd) {
      case 'init':
        var config = JSON.parse(data.config);
        self.demuxer = new _demuxerInline2.default(observer, data.typeSupported, config, data.vendor);

        (0, _logger.enableLogs)(config.debug);

        // signal end of worker init
        forwardMessage('init', null);
        break;
      case 'demux':
        self.demuxer.push(data.data, data.decryptdata, data.initSegment, data.audioCodec, data.videoCodec, data.timeOffset, data.discontinuity, data.trackSwitch, data.contiguous, data.duration, data.accurateTimeOffset, data.defaultInitPTS);
        break;
      default:
        break;
    }
  });

  // forward events to main thread
  observer.on(_events2.default.FRAG_DECRYPTED, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
  observer.on(_events2.default.FRAG_PARSED, forwardMessage);
  observer.on(_events2.default.ERROR, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
  observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);
  observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);

  // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)
  observer.on(_events2.default.FRAG_PARSING_DATA, function (ev, data) {
    var transferable = [];
    var message = { event: ev, data: data };
    if (data.data1) {
      message.data1 = data.data1.buffer;
      transferable.push(data.data1.buffer);
      delete data.data1;
    }
    if (data.data2) {
      message.data2 = data.data2.buffer;
      transferable.push(data.data2.buffer);
      delete data.data2;
    }
    self.postMessage(message, transferable);
  });
};

exports.default = DemuxerWorker;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/demuxer.js":
/*!*************************************!*\
  !*** ./src/hls.js/demux/demuxer.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! events */ "../../node_modules/events/events.js");

var _webworkifyWebpack = __webpack_require__(/*! webworkify-webpack */ "../../node_modules/webworkify-webpack/index.js");

var work = _interopRequireWildcard(_webworkifyWebpack);

var _events2 = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events3 = _interopRequireDefault(_events2);

var _demuxerInline = __webpack_require__(/*! ../demux/demuxer-inline */ "./src/hls.js/demux/demuxer-inline.js");

var _demuxerInline2 = _interopRequireDefault(_demuxerInline);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _mediasourceHelper = __webpack_require__(/*! ../utils/mediasource-helper */ "./src/hls.js/utils/mediasource-helper.js");

var _getSelfScope = __webpack_require__(/*! ../utils/get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

var _observer = __webpack_require__(/*! ../observer */ "./src/hls.js/observer.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// see https://stackoverflow.com/a/11237259/589493
var global = (0, _getSelfScope.getSelfScope)(); // safeguard for code that might run both on worker and main thread
var MediaSource = (0, _mediasourceHelper.getMediaSource)();

var Demuxer = function () {
  function Demuxer(hls, id) {
    var _this = this;

    _classCallCheck(this, Demuxer);

    this.hls = hls;
    this.id = id;

    var observer = this.observer = new _observer.Observer();
    var config = hls.config;

    var forwardMessage = function forwardMessage(ev, data) {
      data = data || {};
      data.frag = _this.frag;
      data.id = _this.id;
      hls.trigger(ev, data);
    };

    // forward events to main thread
    observer.on(_events3.default.FRAG_DECRYPTED, forwardMessage);
    observer.on(_events3.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
    observer.on(_events3.default.FRAG_PARSING_DATA, forwardMessage);
    observer.on(_events3.default.FRAG_PARSED, forwardMessage);
    observer.on(_events3.default.ERROR, forwardMessage);
    observer.on(_events3.default.FRAG_PARSING_METADATA, forwardMessage);
    observer.on(_events3.default.FRAG_PARSING_USERDATA, forwardMessage);
    observer.on(_events3.default.INIT_PTS_FOUND, forwardMessage);

    var typeSupported = {
      mp4: MediaSource.isTypeSupported('video/mp4'),
      mpeg: MediaSource.isTypeSupported('audio/mpeg'),
      mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"')
    };
    // navigator.vendor is not always available in Web Worker
    // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator
    var vendor = navigator.vendor;
    if (config.enableWorker && typeof Worker !== 'undefined') {
      _logger.logger.log('demuxing in webworker');
      var w = void 0;
      try {
        w = this.w = work(/*require.resolve*/(/*! ../demux/demuxer-worker.js */ "./src/hls.js/demux/demuxer-worker.js"));
        this.onwmsg = this.onWorkerMessage.bind(this);
        w.addEventListener('message', this.onwmsg);
        w.onerror = function (event) {
          hls.trigger(_events3.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });
        };
        w.postMessage({ cmd: 'init', typeSupported: typeSupported, vendor: vendor, id: id, config: JSON.stringify(config) });
      } catch (err) {
        _logger.logger.warn('Error in worker:', err);
        _logger.logger.error('Error while initializing DemuxerWorker, fallback on DemuxerInline');
        if (w) {
          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
          global.URL.revokeObjectURL(w.objectURL);
        }
        this.demuxer = new _demuxerInline2.default(observer, typeSupported, config, vendor);
        this.w = undefined;
      }
    } else {
      this.demuxer = new _demuxerInline2.default(observer, typeSupported, config, vendor);
    }
  }

  _createClass(Demuxer, [{
    key: 'destroy',
    value: function destroy() {
      var w = this.w;
      if (w) {
        w.removeEventListener('message', this.onwmsg);
        w.terminate();
        this.w = null;
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.destroy();
          this.demuxer = null;
        }
      }
      var observer = this.observer;
      if (observer) {
        observer.removeAllListeners();
        this.observer = null;
      }
    }
  }, {
    key: 'push',
    value: function push(data, initSegment, audioCodec, videoCodec, frag, duration, accurateTimeOffset, defaultInitPTS) {
      var w = this.w;
      var timeOffset = Number.isFinite(frag.startPTS) ? frag.startPTS : frag.start;
      var decryptdata = frag.decryptdata;
      var lastFrag = this.frag;
      var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
      var trackSwitch = !(lastFrag && frag.level === lastFrag.level);
      var nextSN = lastFrag && frag.sn === lastFrag.sn + 1;
      var contiguous = !trackSwitch && nextSN;
      if (discontinuity) {
        _logger.logger.log(this.id + ':discontinuity detected');
      }

      if (trackSwitch) {
        _logger.logger.log(this.id + ':switch detected');
      }

      this.frag = frag;
      if (w) {
        // post fragment payload as transferable objects for ArrayBuffer (no copy)
        w.postMessage({ cmd: 'demux', data: data, decryptdata: decryptdata, initSegment: initSegment, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, discontinuity: discontinuity, trackSwitch: trackSwitch, contiguous: contiguous, duration: duration, accurateTimeOffset: accurateTimeOffset, defaultInitPTS: defaultInitPTS }, data instanceof ArrayBuffer ? [data] : []);
      } else {
        var demuxer = this.demuxer;
        if (demuxer) {
          demuxer.push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
        }
      }
    }
  }, {
    key: 'onWorkerMessage',
    value: function onWorkerMessage(ev) {
      var data = ev.data,
          hls = this.hls;
      switch (data.event) {
        case 'init':
          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
          global.URL.revokeObjectURL(this.w.objectURL);
          break;
        // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects
        case _events3.default.FRAG_PARSING_DATA:
          data.data.data1 = new Uint8Array(data.data1);
          if (data.data2) {
            data.data.data2 = new Uint8Array(data.data2);
          }

        /* falls through */
        default:
          data.data = data.data || {};
          data.data.frag = this.frag;
          data.data.id = this.id;
          hls.trigger(data.event, data.data);
          break;
      }
    }
  }]);

  return Demuxer;
}();

exports.default = Demuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/exp-golomb.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/exp-golomb.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ExpGolomb = function () {
  function ExpGolomb(data) {
    _classCallCheck(this, ExpGolomb);

    this.data = data;
    // the number of bytes left to examine in this.data
    this.bytesAvailable = data.byteLength;
    // the current word being examined
    this.word = 0; // :uint
    // the number of bits left to examine in the current word
    this.bitsAvailable = 0; // :uint
  }

  // ():void


  _createClass(ExpGolomb, [{
    key: 'loadWord',
    value: function loadWord() {
      var data = this.data,
          bytesAvailable = this.bytesAvailable,
          position = data.byteLength - bytesAvailable,
          workingBytes = new Uint8Array(4),
          availableBytes = Math.min(4, bytesAvailable);
      if (availableBytes === 0) {
        throw new Error('no bytes available');
      }

      workingBytes.set(data.subarray(position, position + availableBytes));
      this.word = new DataView(workingBytes.buffer).getUint32(0);
      // track the amount of this.data that has been processed
      this.bitsAvailable = availableBytes * 8;
      this.bytesAvailable -= availableBytes;
    }

    // (count:int):void

  }, {
    key: 'skipBits',
    value: function skipBits(count) {
      var skipBytes = void 0; // :int
      if (this.bitsAvailable > count) {
        this.word <<= count;
        this.bitsAvailable -= count;
      } else {
        count -= this.bitsAvailable;
        skipBytes = count >> 3;
        count -= skipBytes >> 3;
        this.bytesAvailable -= skipBytes;
        this.loadWord();
        this.word <<= count;
        this.bitsAvailable -= count;
      }
    }

    // (size:int):uint

  }, {
    key: 'readBits',
    value: function readBits(size) {
      var bits = Math.min(this.bitsAvailable, size),
          // :uint
      valu = this.word >>> 32 - bits; // :uint
      if (size > 32) {
        _logger.logger.error('Cannot read more than 32 bits at a time');
      }

      this.bitsAvailable -= bits;
      if (this.bitsAvailable > 0) {
        this.word <<= bits;
      } else if (this.bytesAvailable > 0) {
        this.loadWord();
      }

      bits = size - bits;
      if (bits > 0 && this.bitsAvailable) {
        return valu << bits | this.readBits(bits);
      } else {
        return valu;
      }
    }

    // ():uint

  }, {
    key: 'skipLZ',
    value: function skipLZ() {
      var leadingZeroCount = void 0; // :uint
      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
        if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {
          // the first bit of working word is 1
          this.word <<= leadingZeroCount;
          this.bitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      // we exhausted word and still have not found a 1
      this.loadWord();
      return leadingZeroCount + this.skipLZ();
    }

    // ():void

  }, {
    key: 'skipUEG',
    value: function skipUEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():void

  }, {
    key: 'skipEG',
    value: function skipEG() {
      this.skipBits(1 + this.skipLZ());
    }

    // ():uint

  }, {
    key: 'readUEG',
    value: function readUEG() {
      var clz = this.skipLZ(); // :uint
      return this.readBits(clz + 1) - 1;
    }

    // ():int

  }, {
    key: 'readEG',
    value: function readEG() {
      var valu = this.readUEG(); // :int
      if (0x01 & valu) {
        // the number is odd if the low order bit is set
        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2
      } else {
        return -1 * (valu >>> 1); // divide by two then make it negative
      }
    }

    // Some convenience functions
    // :Boolean

  }, {
    key: 'readBoolean',
    value: function readBoolean() {
      return this.readBits(1) === 1;
    }

    // ():int

  }, {
    key: 'readUByte',
    value: function readUByte() {
      return this.readBits(8);
    }

    // ():int

  }, {
    key: 'readUShort',
    value: function readUShort() {
      return this.readBits(16);
    }
    // ():int

  }, {
    key: 'readUInt',
    value: function readUInt() {
      return this.readBits(32);
    }

    /**
     * Advance the ExpGolomb decoder past a scaling list. The scaling
     * list is optionally transmitted as part of a sequence parameter
     * set and is not relevant to transmuxing.
     * @param count {number} the number of entries in this scaling list
     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
     */

  }, {
    key: 'skipScalingList',
    value: function skipScalingList(count) {
      var lastScale = 8,
          nextScale = 8,
          j = void 0,
          deltaScale = void 0;
      for (j = 0; j < count; j++) {
        if (nextScale !== 0) {
          deltaScale = this.readEG();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    }

    /**
     * Read a sequence parameter set and return some interesting video
     * properties. A sequence parameter set is the H264 metadata that
     * describes the properties of upcoming video frames.
     * @param data {Uint8Array} the bytes of a sequence parameter set
     * @return {object} an object with configuration parsed from the
     * sequence parameter set, including the dimensions of the
     * associated video frames.
     */

  }, {
    key: 'readSPS',
    value: function readSPS() {
      var frameCropLeftOffset = 0,
          frameCropRightOffset = 0,
          frameCropTopOffset = 0,
          frameCropBottomOffset = 0,
          profileIdc = void 0,
          profileCompat = void 0,
          levelIdc = void 0,
          numRefFramesInPicOrderCntCycle = void 0,
          picWidthInMbsMinus1 = void 0,
          picHeightInMapUnitsMinus1 = void 0,
          frameMbsOnlyFlag = void 0,
          scalingListCount = void 0,
          i = void 0,
          readUByte = this.readUByte.bind(this),
          readBits = this.readBits.bind(this),
          readUEG = this.readUEG.bind(this),
          readBoolean = this.readBoolean.bind(this),
          skipBits = this.skipBits.bind(this),
          skipEG = this.skipEG.bind(this),
          skipUEG = this.skipUEG.bind(this),
          skipScalingList = this.skipScalingList.bind(this);

      readUByte();
      profileIdc = readUByte(); // profile_idc
      profileCompat = readBits(5); // constraint_set[0-4]_flag, u(5)
      skipBits(3); // reserved_zero_3bits u(3),
      levelIdc = readUByte(); // level_idc u(8)
      skipUEG(); // seq_parameter_set_id
      // some profiles have more optional data we don't need
      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
        var chromaFormatIdc = readUEG();
        if (chromaFormatIdc === 3) {
          skipBits(1);
        } // separate_colour_plane_flag

        skipUEG(); // bit_depth_luma_minus8
        skipUEG(); // bit_depth_chroma_minus8
        skipBits(1); // qpprime_y_zero_transform_bypass_flag
        if (readBoolean()) {
          // seq_scaling_matrix_present_flag
          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (i = 0; i < scalingListCount; i++) {
            if (readBoolean()) {
              // seq_scaling_list_present_flag[ i ]
              if (i < 6) {
                skipScalingList(16);
              } else {
                skipScalingList(64);
              }
            }
          }
        }
      }
      skipUEG(); // log2_max_frame_num_minus4
      var picOrderCntType = readUEG();
      if (picOrderCntType === 0) {
        readUEG(); // log2_max_pic_order_cnt_lsb_minus4
      } else if (picOrderCntType === 1) {
        skipBits(1); // delta_pic_order_always_zero_flag
        skipEG(); // offset_for_non_ref_pic
        skipEG(); // offset_for_top_to_bottom_field
        numRefFramesInPicOrderCntCycle = readUEG();
        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
          skipEG();
        } // offset_for_ref_frame[ i ]
      }
      skipUEG(); // max_num_ref_frames
      skipBits(1); // gaps_in_frame_num_value_allowed_flag
      picWidthInMbsMinus1 = readUEG();
      picHeightInMapUnitsMinus1 = readUEG();
      frameMbsOnlyFlag = readBits(1);
      if (frameMbsOnlyFlag === 0) {
        skipBits(1);
      } // mb_adaptive_frame_field_flag

      skipBits(1); // direct_8x8_inference_flag
      if (readBoolean()) {
        // frame_cropping_flag
        frameCropLeftOffset = readUEG();
        frameCropRightOffset = readUEG();
        frameCropTopOffset = readUEG();
        frameCropBottomOffset = readUEG();
      }
      var pixelRatio = [1, 1];
      if (readBoolean()) {
        // vui_parameters_present_flag
        if (readBoolean()) {
          // aspect_ratio_info_present_flag
          var aspectRatioIdc = readUByte();
          switch (aspectRatioIdc) {
            case 1:
              pixelRatio = [1, 1];break;
            case 2:
              pixelRatio = [12, 11];break;
            case 3:
              pixelRatio = [10, 11];break;
            case 4:
              pixelRatio = [16, 11];break;
            case 5:
              pixelRatio = [40, 33];break;
            case 6:
              pixelRatio = [24, 11];break;
            case 7:
              pixelRatio = [20, 11];break;
            case 8:
              pixelRatio = [32, 11];break;
            case 9:
              pixelRatio = [80, 33];break;
            case 10:
              pixelRatio = [18, 11];break;
            case 11:
              pixelRatio = [15, 11];break;
            case 12:
              pixelRatio = [64, 33];break;
            case 13:
              pixelRatio = [160, 99];break;
            case 14:
              pixelRatio = [4, 3];break;
            case 15:
              pixelRatio = [3, 2];break;
            case 16:
              pixelRatio = [2, 1];break;
            case 255:
              {
                pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
                break;
              }
          }
        }
      }
      return {
        width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
        pixelRatio: pixelRatio
      };
    }
  }, {
    key: 'readSliceType',
    value: function readSliceType() {
      // skip NALu type
      this.readUByte();
      // discard first_mb_in_slice
      this.readUEG();
      // return slice_type
      return this.readUEG();
    }
  }]);

  return ExpGolomb;
}();

exports.default = ExpGolomb;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/id3.js":
/*!*********************************!*\
  !*** ./src/hls.js/demux/id3.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * ID3 parser
 */
var ID3 = function () {
  function ID3() {
    _classCallCheck(this, ID3);
  }

  _createClass(ID3, null, [{
    key: 'isHeader',

    /**
     * Returns true if an ID3 header can be found at offset in data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {boolean} - True if an ID3 header is found
     */
    value: function isHeader(data, offset) {
      /*
      * http://id3.org/id3v2.3.0
      * [0]     = 'I'
      * [1]     = 'D'
      * [2]     = '3'
      * [3,4]   = {Version}
      * [5]     = {Flags}
      * [6-9]   = {ID3 Size}
      *
      * An ID3v2 tag can be detected with the following pattern:
      *  $49 44 33 yy yy xx zz zz zz zz
      * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80
      */
      if (offset + 10 <= data.length) {
        // look for 'ID3' identifier
        if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {
          // check version is within range
          if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
            // check size is within range
            if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
              return true;
            }
          }
        }
      }

      return false;
    }

    /**
     * Returns true if an ID3 footer can be found at offset in data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {boolean} - True if an ID3 footer is found
     */

  }, {
    key: 'isFooter',
    value: function isFooter(data, offset) {
      /*
      * The footer is a copy of the header, but with a different identifier
      */
      if (offset + 10 <= data.length) {
        // look for '3DI' identifier
        if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {
          // check version is within range
          if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
            // check size is within range
            if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
              return true;
            }
          }
        }
      }

      return false;
    }

    /**
     * Returns any adjacent ID3 tags found in data starting at offset, as one block of data
     * @param {Uint8Array} data - The data to search in
     * @param {number} offset - The offset at which to start searching
     * @return {Uint8Array} - The block of data containing any ID3 tags found
     */

  }, {
    key: 'getID3Data',
    value: function getID3Data(data, offset) {
      var front = offset;
      var length = 0;

      while (ID3.isHeader(data, offset)) {
        // ID3 header is 10 bytes
        length += 10;

        var size = ID3._readSize(data, offset + 6);
        length += size;

        if (ID3.isFooter(data, offset + 10)) {
          // ID3 footer is 10 bytes
          length += 10;
        }

        offset += length;
      }

      if (length > 0) {
        return data.subarray(front, front + length);
      }

      return undefined;
    }
  }, {
    key: '_readSize',
    value: function _readSize(data, offset) {
      var size = 0;
      size = (data[offset] & 0x7f) << 21;
      size |= (data[offset + 1] & 0x7f) << 14;
      size |= (data[offset + 2] & 0x7f) << 7;
      size |= data[offset + 3] & 0x7f;
      return size;
    }

    /**
     * Searches for the Elementary Stream timestamp found in the ID3 data chunk
     * @param {Uint8Array} data - Block of data containing one or more ID3 tags
     * @return {number} - The timestamp
     */

  }, {
    key: 'getTimeStamp',
    value: function getTimeStamp(data) {
      var frames = ID3.getID3Frames(data);
      for (var i = 0; i < frames.length; i++) {
        var frame = frames[i];
        if (ID3.isTimeStampFrame(frame)) {
          return ID3._readTimeStamp(frame);
        }
      }

      return undefined;
    }

    /**
     * Returns true if the ID3 frame is an Elementary Stream timestamp frame
     * @param {ID3 frame} frame
     */

  }, {
    key: 'isTimeStampFrame',
    value: function isTimeStampFrame(frame) {
      return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';
    }
  }, {
    key: '_getFrameData',
    value: function _getFrameData(data) {
      /*
      Frame ID       $xx xx xx xx (four characters)
      Size           $xx xx xx xx
      Flags          $xx xx
      */
      var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
      var size = ID3._readSize(data, 4);

      // skip frame id, size, and flags
      var offset = 10;

      return { type: type, size: size, data: data.subarray(offset, offset + size) };
    }

    /**
     * Returns an array of ID3 frames found in all the ID3 tags in the id3Data
     * @param {Uint8Array} id3Data - The ID3 data containing one or more ID3 tags
     * @return {ID3 frame[]} - Array of ID3 frame objects
     */

  }, {
    key: 'getID3Frames',
    value: function getID3Frames(id3Data) {
      var offset = 0;
      var frames = [];

      while (ID3.isHeader(id3Data, offset)) {
        var size = ID3._readSize(id3Data, offset + 6);
        // skip past ID3 header
        offset += 10;
        var end = offset + size;
        // loop through frames in the ID3 tag
        while (offset + 8 < end) {
          var frameData = ID3._getFrameData(id3Data.subarray(offset));
          var frame = ID3._decodeFrame(frameData);
          if (frame) {
            frames.push(frame);
          }

          // skip frame header and frame data
          offset += frameData.size + 10;
        }

        if (ID3.isFooter(id3Data, offset)) {
          offset += 10;
        }
      }

      return frames;
    }
  }, {
    key: '_decodeFrame',
    value: function _decodeFrame(frame) {
      if (frame.type === 'PRIV') {
        return ID3._decodePrivFrame(frame);
      } else if (frame.type[0] === 'T') {
        return ID3._decodeTextFrame(frame);
      } else if (frame.type[0] === 'W') {
        return ID3._decodeURLFrame(frame);
      }

      return undefined;
    }
  }, {
    key: '_readTimeStamp',
    value: function _readTimeStamp(timeStampFrame) {
      if (timeStampFrame.data.byteLength === 8) {
        var data = new Uint8Array(timeStampFrame.data);
        // timestamp is 33 bit expressed as a big-endian eight-octet number,
        // with the upper 31 bits set to zero.
        var pts33Bit = data[3] & 0x1;
        var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
        timestamp /= 45;

        if (pts33Bit) {
          timestamp += 47721858.84;
        } // 2^32 / 90

        return Math.round(timestamp);
      }

      return undefined;
    }
  }, {
    key: '_decodePrivFrame',
    value: function _decodePrivFrame(frame) {
      /*
      Format: <text string>\0<binary data>
      */
      if (frame.size < 2) {
        return undefined;
      }

      var owner = ID3._utf8ArrayToStr(frame.data, true);
      var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));

      return { key: frame.type, info: owner, data: privateData.buffer };
    }
  }, {
    key: '_decodeTextFrame',
    value: function _decodeTextFrame(frame) {
      if (frame.size < 2) {
        return undefined;
      }

      if (frame.type === 'TXXX') {
        /*
        Format:
        [0]   = {Text Encoding}
        [1-?] = {Description}\0{Value}
        */
        var index = 1;
        var description = ID3._utf8ArrayToStr(frame.data.subarray(index));

        index += description.length + 1;
        var value = ID3._utf8ArrayToStr(frame.data.subarray(index));

        return { key: frame.type, info: description, data: value };
      } else {
        /*
        Format:
        [0]   = {Text Encoding}
        [1-?] = {Value}
        */
        var text = ID3._utf8ArrayToStr(frame.data.subarray(1));
        return { key: frame.type, data: text };
      }
    }
  }, {
    key: '_decodeURLFrame',
    value: function _decodeURLFrame(frame) {
      if (frame.type === 'WXXX') {
        /*
        Format:
        [0]   = {Text Encoding}
        [1-?] = {Description}\0{URL}
        */
        if (frame.size < 2) {
          return undefined;
        }

        var index = 1;
        var description = ID3._utf8ArrayToStr(frame.data.subarray(index));

        index += description.length + 1;
        var value = ID3._utf8ArrayToStr(frame.data.subarray(index));

        return { key: frame.type, info: description, data: value };
      } else {
        /*
        Format:
        [0-?] = {URL}
        */
        var url = ID3._utf8ArrayToStr(frame.data);
        return { key: frame.type, data: url };
      }
    }

    // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197
    // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
    /* utf.js - UTF-8 <=> UTF-16 convertion
     *
     * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
     * Version: 1.0
     * LastModified: Dec 25 1999
     * This library is free.  You can redistribute it and/or modify it.
     */

  }, {
    key: '_utf8ArrayToStr',
    value: function _utf8ArrayToStr(array) {
      var exitOnNull = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var len = array.length;
      var c = void 0;
      var char2 = void 0;
      var char3 = void 0;
      var out = '';
      var i = 0;
      while (i < len) {
        c = array[i++];
        if (c === 0x00 && exitOnNull) {
          return out;
        } else if (c === 0x00 || c === 0x03) {
          // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it
          continue;
        }
        switch (c >> 4) {
          case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:
            // 0xxxxxxx
            out += String.fromCharCode(c);
            break;
          case 12:case 13:
            // 110x xxxx   10xx xxxx
            char2 = array[i++];
            out += String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F);
            break;
          case 14:
            // 1110 xxxx  10xx xxxx  10xx xxxx
            char2 = array[i++];
            char3 = array[i++];
            out += String.fromCharCode((c & 0x0F) << 12 | (char2 & 0x3F) << 6 | (char3 & 0x3F) << 0);
            break;
          default:
        }
      }
      return out;
    }
  }]);

  return ID3;
}();

var utf8ArrayToStr = ID3._utf8ArrayToStr;

exports.default = ID3;
exports.utf8ArrayToStr = utf8ArrayToStr;

/***/ }),

/***/ "./src/hls.js/demux/mp3demuxer.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/mp3demuxer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * MP3 demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _id = __webpack_require__(/*! ../demux/id3 */ "./src/hls.js/demux/id3.js");

var _id2 = _interopRequireDefault(_id);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _mpegaudio = __webpack_require__(/*! ./mpegaudio */ "./src/hls.js/demux/mpegaudio.js");

var _mpegaudio2 = _interopRequireDefault(_mpegaudio);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MP3Demuxer = function () {
  function MP3Demuxer(observer, remuxer, config) {
    _classCallCheck(this, MP3Demuxer);

    this.observer = observer;
    this.config = config;
    this.remuxer = remuxer;
  }

  _createClass(MP3Demuxer, [{
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this._audioTrack = { container: 'audio/mpeg', type: 'audio', id: -1, sequenceNumber: 0, isAAC: false, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
    }
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var id3Data = _id2.default.getID3Data(data, 0);
      var timestamp = _id2.default.getTimeStamp(id3Data);
      var pts = timestamp ? 90 * timestamp : timeOffset * 90000;
      var offset = id3Data.length;
      var length = data.length;
      var frameIndex = 0,
          stamp = 0;
      var track = this._audioTrack;

      var id3Samples = [{ pts: pts, dts: pts, data: id3Data }];

      while (offset < length) {
        if (_mpegaudio2.default.isHeader(data, offset)) {
          var frame = _mpegaudio2.default.appendFrame(track, data, offset, pts, frameIndex);
          if (frame) {
            offset += frame.length;
            stamp = frame.sample.pts;
            frameIndex++;
          } else {
            // logger.log('Unable to parse Mpeg audio frame');
            break;
          }
        } else if (_id2.default.isHeader(data, offset)) {
          id3Data = _id2.default.getID3Data(data, offset);
          id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });
          offset += id3Data.length;
        } else {
          // nothing found, keep looking
          offset++;
        }
      }

      this.remuxer.remux(track, { samples: [] }, { samples: id3Samples, inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      // check if data contains ID3 timestamp and MPEG sync word
      var offset = void 0,
          length = void 0;
      var id3Data = _id2.default.getID3Data(data, 0);
      if (id3Data && _id2.default.getTimeStamp(id3Data) !== undefined) {
        // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
        // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
        // More info http://www.mp3-tech.org/programmer/frame_header.html
        for (offset = id3Data.length, length = Math.min(data.length - 1, offset + 100); offset < length; offset++) {
          if (_mpegaudio2.default.probe(data, offset)) {
            _logger.logger.log('MPEG Audio sync word found !');
            return true;
          }
        }
      }
      return false;
    }
  }]);

  return MP3Demuxer;
}();

exports.default = MP3Demuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/mp4demuxer.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/mp4demuxer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * MP4 demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UINT32_MAX = Math.pow(2, 32) - 1;

var MP4Demuxer = function () {
  function MP4Demuxer(observer, remuxer) {
    _classCallCheck(this, MP4Demuxer);

    this.observer = observer;
    this.remuxer = remuxer;
  }

  _createClass(MP4Demuxer, [{
    key: 'resetTimeStamp',
    value: function resetTimeStamp(initPTS) {
      this.initPTS = initPTS;
    }
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      // jshint unused:false
      if (initSegment && initSegment.byteLength) {
        var initData = this.initData = MP4Demuxer.parseInitSegment(initSegment);

        // default audio codec if nothing specified
        // TODO : extract that from initsegment
        if (audioCodec == null) {
          audioCodec = 'mp4a.40.5';
        }

        if (videoCodec == null) {
          videoCodec = 'avc1.42e01e';
        }

        var tracks = {};
        if (initData.audio && initData.video) {
          tracks.audiovideo = { container: 'video/mp4', codec: audioCodec + ',' + videoCodec, initSegment: duration ? initSegment : null };
        } else {
          if (initData.audio) {
            tracks.audio = { container: 'audio/mp4', codec: audioCodec, initSegment: duration ? initSegment : null };
          }

          if (initData.video) {
            tracks.video = { container: 'video/mp4', codec: videoCodec, initSegment: duration ? initSegment : null };
          }
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, { tracks: tracks });
      } else {
        if (audioCodec) {
          this.audioCodec = audioCodec;
        }

        if (videoCodec) {
          this.videoCodec = videoCodec;
        }
      }
    }
  }, {
    key: 'append',


    // feed incoming data to the front of the parsing pipeline
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var initData = this.initData;
      if (!initData) {
        this.resetInitSegment(data, this.audioCodec, this.videoCodec, false);
        initData = this.initData;
      }
      var startDTS = void 0,
          initPTS = this.initPTS;
      if (initPTS === undefined) {
        var _startDTS = MP4Demuxer.getStartDTS(initData, data);
        this.initPTS = initPTS = _startDTS - timeOffset;
        this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });
      }
      MP4Demuxer.offsetStartDTS(initData, data, initPTS);
      startDTS = MP4Demuxer.getStartDTS(initData, data);
      this.remuxer.remux(initData.audio, initData.video, null, null, startDTS, contiguous, accurateTimeOffset, data);
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }], [{
    key: 'probe',
    value: function probe(data) {
      // ensure we find a moof box in the first 16 kB
      return MP4Demuxer.findBox({ data: data, start: 0, end: Math.min(data.length, 16384) }, ['moof']).length > 0;
    }
  }, {
    key: 'bin2str',
    value: function bin2str(buffer) {
      return String.fromCharCode.apply(null, buffer);
    }
  }, {
    key: 'readUint16',
    value: function readUint16(buffer, offset) {
      if (buffer.data) {
        offset += buffer.start;
        buffer = buffer.data;
      }

      var val = buffer[offset] << 8 | buffer[offset + 1];

      return val < 0 ? 65536 + val : val;
    }
  }, {
    key: 'readUint32',
    value: function readUint32(buffer, offset) {
      if (buffer.data) {
        offset += buffer.start;
        buffer = buffer.data;
      }

      var val = buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
      return val < 0 ? 4294967296 + val : val;
    }
  }, {
    key: 'writeUint32',
    value: function writeUint32(buffer, offset, value) {
      if (buffer.data) {
        offset += buffer.start;
        buffer = buffer.data;
      }
      buffer[offset] = value >> 24;
      buffer[offset + 1] = value >> 16 & 0xff;
      buffer[offset + 2] = value >> 8 & 0xff;
      buffer[offset + 3] = value & 0xff;
    }

    // Find the data for a box specified by its path

  }, {
    key: 'findBox',
    value: function findBox(data, path) {
      var results = [],
          i = void 0,
          size = void 0,
          type = void 0,
          end = void 0,
          subresults = void 0,
          start = void 0,
          endbox = void 0;

      if (data.data) {
        start = data.start;
        end = data.end;
        data = data.data;
      } else {
        start = 0;
        end = data.byteLength;
      }

      if (!path.length) {
        // short-circuit the search for empty paths
        return null;
      }

      for (i = start; i < end;) {
        size = MP4Demuxer.readUint32(data, i);
        type = MP4Demuxer.bin2str(data.subarray(i + 4, i + 8));
        endbox = size > 1 ? i + size : end;

        if (type === path[0]) {
          if (path.length === 1) {
            // this is the end of the path and we've found the box we were
            // looking for
            results.push({ data: data, start: i + 8, end: endbox });
          } else {
            // recursively search for the next box along the path
            subresults = MP4Demuxer.findBox({ data: data, start: i + 8, end: endbox }, path.slice(1));
            if (subresults.length) {
              results = results.concat(subresults);
            }
          }
        }
        i = endbox;
      }

      // we've finished searching all of data
      return results;
    }
  }, {
    key: 'parseSegmentIndex',
    value: function parseSegmentIndex(initSegment) {
      var moov = MP4Demuxer.findBox(initSegment, ['moov'])[0];
      var moovEndOffset = moov ? moov.end : null; // we need this in case we need to chop of garbage of the end of current data

      var index = 0;
      var sidx = MP4Demuxer.findBox(initSegment, ['sidx']);
      var references = void 0;

      if (!sidx || !sidx[0]) {
        return null;
      }

      references = [];
      sidx = sidx[0];

      var version = sidx.data[0];

      // set initial offset, we skip the reference ID (not needed)
      index = version === 0 ? 8 : 16;

      var timescale = MP4Demuxer.readUint32(sidx, index);
      index += 4;

      // TODO: parse earliestPresentationTime and firstOffset
      // usually zero in our case
      var earliestPresentationTime = 0;
      var firstOffset = 0;

      if (version === 0) {
        index += 8;
      } else {
        index += 16;
      }

      // skip reserved
      index += 2;

      var startByte = sidx.end + firstOffset;

      var referencesCount = MP4Demuxer.readUint16(sidx, index);
      index += 2;

      for (var i = 0; i < referencesCount; i++) {
        var referenceIndex = index;

        var referenceInfo = MP4Demuxer.readUint32(sidx, referenceIndex);
        referenceIndex += 4;

        var referenceSize = referenceInfo & 0x7FFFFFFF;
        var referenceType = (referenceInfo & 0x80000000) >>> 31;

        if (referenceType === 1) {
          console.warn('SIDX has hierarchical references (not supported)');
          return;
        }

        var subsegmentDuration = MP4Demuxer.readUint32(sidx, referenceIndex);
        referenceIndex += 4;

        references.push({
          referenceSize: referenceSize,
          subsegmentDuration: subsegmentDuration, // unscaled
          info: {
            duration: subsegmentDuration / timescale,
            start: startByte,
            end: startByte + referenceSize - 1
          }
        });

        startByte += referenceSize;

        // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits
        // for |sapDelta|.
        referenceIndex += 4;

        // skip to next ref
        index = referenceIndex;
      }

      return {
        earliestPresentationTime: earliestPresentationTime,
        timescale: timescale,
        version: version,
        referencesCount: referencesCount,
        references: references,
        moovEndOffset: moovEndOffset
      };
    }

    /**
     * Parses an MP4 initialization segment and extracts stream type and
     * timescale values for any declared tracks. Timescale values indicate the
     * number of clock ticks per second to assume for time-based values
     * elsewhere in the MP4.
     *
     * To determine the start time of an MP4, you need two pieces of
     * information: the timescale unit and the earliest base media decode
     * time. Multiple timescales can be specified within an MP4 but the
     * base media decode time is always expressed in the timescale from
     * the media header box for the track:
     * ```
     * moov > trak > mdia > mdhd.timescale
     * moov > trak > mdia > hdlr
     * ```
     * @param init {Uint8Array} the bytes of the init segment
     * @return {object} a hash of track type to timescale values or null if
     * the init segment is malformed.
     */

  }, {
    key: 'parseInitSegment',
    value: function parseInitSegment(initSegment) {
      var result = [];
      var traks = MP4Demuxer.findBox(initSegment, ['moov', 'trak']);

      traks.forEach(function (trak) {
        var tkhd = MP4Demuxer.findBox(trak, ['tkhd'])[0];
        if (tkhd) {
          var version = tkhd.data[tkhd.start];
          var index = version === 0 ? 12 : 20;
          var trackId = MP4Demuxer.readUint32(tkhd, index);

          var mdhd = MP4Demuxer.findBox(trak, ['mdia', 'mdhd'])[0];
          if (mdhd) {
            version = mdhd.data[mdhd.start];
            index = version === 0 ? 12 : 20;
            var timescale = MP4Demuxer.readUint32(mdhd, index);

            var hdlr = MP4Demuxer.findBox(trak, ['mdia', 'hdlr'])[0];
            if (hdlr) {
              var hdlrType = MP4Demuxer.bin2str(hdlr.data.subarray(hdlr.start + 8, hdlr.start + 12));
              var type = { 'soun': 'audio', 'vide': 'video' }[hdlrType];
              if (type) {
                // extract codec info. TODO : parse codec details to be able to build MIME type
                var codecBox = MP4Demuxer.findBox(trak, ['mdia', 'minf', 'stbl', 'stsd']);
                if (codecBox.length) {
                  codecBox = codecBox[0];
                  var codecType = MP4Demuxer.bin2str(codecBox.data.subarray(codecBox.start + 12, codecBox.start + 16));
                  _logger.logger.log('MP4Demuxer:' + type + ':' + codecType + ' found');
                }
                result[trackId] = { timescale: timescale, type: type };
                result[type] = { timescale: timescale, id: trackId };
              }
            }
          }
        }
      });
      return result;
    }

    /**
    * Determine the base media decode start time, in seconds, for an MP4
    * fragment. If multiple fragments are specified, the earliest time is
    * returned.
    *
    * The base media decode time can be parsed from track fragment
    * metadata:
    * ```
    * moof > traf > tfdt.baseMediaDecodeTime
    * ```
    * It requires the timescale value from the mdhd to interpret.
    *
    * @param timescale {object} a hash of track ids to timescale values.
    * @return {number} the earliest base media decode start time for the
    * fragment, in seconds
    */

  }, {
    key: 'getStartDTS',
    value: function getStartDTS(initData, fragment) {
      var trafs = void 0,
          baseTimes = void 0,
          result = void 0;

      // we need info from two childrend of each track fragment box
      trafs = MP4Demuxer.findBox(fragment, ['moof', 'traf']);

      // determine the start times for each track
      baseTimes = [].concat.apply([], trafs.map(function (traf) {
        return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
          var id = void 0,
              scale = void 0,
              baseTime = void 0;

          // get the track id from the tfhd
          id = MP4Demuxer.readUint32(tfhd, 4);
          // assume a 90kHz clock if no timescale was specified
          scale = initData[id].timescale || 90e3;

          // get the base media decode time from the tfdt
          baseTime = MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
            var version = void 0,
                result = void 0;

            version = tfdt.data[tfdt.start];
            result = MP4Demuxer.readUint32(tfdt, 4);
            if (version === 1) {
              result *= Math.pow(2, 32);

              result += MP4Demuxer.readUint32(tfdt, 8);
            }
            return result;
          })[0];
          // convert base time to seconds
          return baseTime / scale;
        });
      }));

      // return the minimum
      result = Math.min.apply(null, baseTimes);
      return isFinite(result) ? result : 0;
    }
  }, {
    key: 'offsetStartDTS',
    value: function offsetStartDTS(initData, fragment, timeOffset) {
      MP4Demuxer.findBox(fragment, ['moof', 'traf']).map(function (traf) {
        return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
          // get the track id from the tfhd
          var id = MP4Demuxer.readUint32(tfhd, 4);
          // assume a 90kHz clock if no timescale was specified
          var timescale = initData[id].timescale || 90e3;

          // get the base media decode time from the tfdt
          MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
            var version = tfdt.data[tfdt.start];
            var baseMediaDecodeTime = MP4Demuxer.readUint32(tfdt, 4);
            if (version === 0) {
              MP4Demuxer.writeUint32(tfdt, 4, baseMediaDecodeTime - timeOffset * timescale);
            } else {
              baseMediaDecodeTime *= Math.pow(2, 32);
              baseMediaDecodeTime += MP4Demuxer.readUint32(tfdt, 8);
              baseMediaDecodeTime -= timeOffset * timescale;
              baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
              var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
              var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
              MP4Demuxer.writeUint32(tfdt, 4, upper);
              MP4Demuxer.writeUint32(tfdt, 8, lower);
            }
          });
        });
      });
    }
  }]);

  return MP4Demuxer;
}();

exports.default = MP4Demuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/mpegaudio.js":
/*!***************************************!*\
  !*** ./src/hls.js/demux/mpegaudio.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 *  MPEG parser helper
 */

var MpegAudio = {

  BitratesMap: [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],

  SamplingRateMap: [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000],

  SamplesCoefficients: [
  // MPEG 2.5
  [0, // Reserved
  72, // Layer3
  144, // Layer2
  12 // Layer1
  ],
  // Reserved
  [0, // Reserved
  0, // Layer3
  0, // Layer2
  0 // Layer1
  ],
  // MPEG 2
  [0, // Reserved
  72, // Layer3
  144, // Layer2
  12 // Layer1
  ],
  // MPEG 1
  [0, // Reserved
  144, // Layer3
  144, // Layer2
  12 // Layer1
  ]],

  BytesInSlot: [0, // Reserved
  1, // Layer3
  1, // Layer2
  4 // Layer1
  ],

  appendFrame: function appendFrame(track, data, offset, pts, frameIndex) {
    // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference
    if (offset + 24 > data.length) {
      return undefined;
    }

    var header = this.parseHeader(data, offset);
    if (header && offset + header.frameLength <= data.length) {
      var frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;
      var stamp = pts + frameIndex * frameDuration;
      var sample = { unit: data.subarray(offset, offset + header.frameLength), pts: stamp, dts: stamp };

      track.config = [];
      track.channelCount = header.channelCount;
      track.samplerate = header.sampleRate;
      track.samples.push(sample);
      track.len += header.frameLength;

      return { sample: sample, length: header.frameLength };
    }

    return undefined;
  },

  parseHeader: function parseHeader(data, offset) {
    var headerB = data[offset + 1] >> 3 & 3;
    var headerC = data[offset + 1] >> 1 & 3;
    var headerE = data[offset + 2] >> 4 & 15;
    var headerF = data[offset + 2] >> 2 & 3;
    var headerG = data[offset + 2] >> 1 & 1;
    if (headerB !== 1 && headerE !== 0 && headerE !== 15 && headerF !== 3) {
      var columnInBitrates = headerB === 3 ? 3 - headerC : headerC === 3 ? 3 : 4;
      var bitRate = MpegAudio.BitratesMap[columnInBitrates * 14 + headerE - 1] * 1000;
      var columnInSampleRates = headerB === 3 ? 0 : headerB === 2 ? 1 : 2;
      var sampleRate = MpegAudio.SamplingRateMap[columnInSampleRates * 3 + headerF];
      var channelCount = data[offset + 3] >> 6 === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)
      var sampleCoefficient = MpegAudio.SamplesCoefficients[headerB][headerC];
      var bytesInSlot = MpegAudio.BytesInSlot[headerC];
      var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
      var frameLength = parseInt(sampleCoefficient * bitRate / sampleRate + headerG, 10) * bytesInSlot;

      return { sampleRate: sampleRate, channelCount: channelCount, frameLength: frameLength, samplesPerFrame: samplesPerFrame };
    }

    return undefined;
  },

  isHeaderPattern: function isHeaderPattern(data, offset) {
    return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;
  },

  isHeader: function isHeader(data, offset) {
    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
    // More info http://www.mp3-tech.org/programmer/frame_header.html
    if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
      return true;
    }

    return false;
  },

  probe: function probe(data, offset) {
    // same as isHeader but we also check that MPEG frame follows last MPEG frame
    // or end of data is reached
    if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
      // MPEG header Length
      var headerLength = 4;
      // MPEG frame Length
      var header = this.parseHeader(data, offset);
      var frameLength = headerLength;
      if (header && header.frameLength) {
        frameLength = header.frameLength;
      }

      var newOffset = offset + frameLength;
      if (newOffset === data.length || newOffset + 1 < data.length && this.isHeaderPattern(data, newOffset)) {
        return true;
      }
    }
    return false;
  }
};

exports.default = MpegAudio;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/demux/sample-aes.js":
/*!****************************************!*\
  !*** ./src/hls.js/demux/sample-aes.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * SAMPLE-AES decrypter
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _decrypter = __webpack_require__(/*! ../crypt/decrypter */ "./src/hls.js/crypt/decrypter.js");

var _decrypter2 = _interopRequireDefault(_decrypter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SampleAesDecrypter = function () {
  function SampleAesDecrypter(observer, config, decryptdata, discardEPB) {
    _classCallCheck(this, SampleAesDecrypter);

    this.decryptdata = decryptdata;
    this.discardEPB = discardEPB;
    this.decrypter = new _decrypter2.default(observer, config, { removePKCS7Padding: false });
  }

  _createClass(SampleAesDecrypter, [{
    key: 'decryptBuffer',
    value: function decryptBuffer(encryptedData, callback) {
      this.decrypter.decrypt(encryptedData, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, callback);
    }

    // AAC - encrypt all full 16 bytes blocks starting from offset 16

  }, {
    key: 'decryptAacSample',
    value: function decryptAacSample(samples, sampleIndex, callback, sync) {
      var curUnit = samples[sampleIndex].unit;
      var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
      var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);

      var localthis = this;
      this.decryptBuffer(encryptedBuffer, function (decryptedData) {
        decryptedData = new Uint8Array(decryptedData);
        curUnit.set(decryptedData, 16);

        if (!sync) {
          localthis.decryptAacSamples(samples, sampleIndex + 1, callback);
        }
      });
    }
  }, {
    key: 'decryptAacSamples',
    value: function decryptAacSamples(samples, sampleIndex, callback) {
      for (;; sampleIndex++) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }

        if (samples[sampleIndex].unit.length < 32) {
          continue;
        }

        var sync = this.decrypter.isSync();

        this.decryptAacSample(samples, sampleIndex, callback, sync);

        if (!sync) {
          return;
        }
      }
    }

    // AVC - encrypt one 16 bytes block out of ten, starting from offset 32

  }, {
    key: 'getAvcEncryptedData',
    value: function getAvcEncryptedData(decodedData) {
      var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
      var encryptedData = new Int8Array(encryptedDataLen);
      var outputPos = 0;
      for (var inputPos = 32; inputPos <= decodedData.length - 16; inputPos += 160, outputPos += 16) {
        encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
      }

      return encryptedData;
    }
  }, {
    key: 'getAvcDecryptedUnit',
    value: function getAvcDecryptedUnit(decodedData, decryptedData) {
      decryptedData = new Uint8Array(decryptedData);
      var inputPos = 0;
      for (var outputPos = 32; outputPos <= decodedData.length - 16; outputPos += 160, inputPos += 16) {
        decodedData.set(decryptedData.subarray(inputPos, inputPos + 16), outputPos);
      }

      return decodedData;
    }
  }, {
    key: 'decryptAvcSample',
    value: function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync) {
      var decodedData = this.discardEPB(curUnit.data);
      var encryptedData = this.getAvcEncryptedData(decodedData);
      var localthis = this;

      this.decryptBuffer(encryptedData.buffer, function (decryptedData) {
        curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedData);

        if (!sync) {
          localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
        }
      });
    }
  }, {
    key: 'decryptAvcSamples',
    value: function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
      for (;; sampleIndex++, unitIndex = 0) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }

        var curUnits = samples[sampleIndex].units;
        for (;; unitIndex++) {
          if (unitIndex >= curUnits.length) {
            break;
          }

          var curUnit = curUnits[unitIndex];
          if (curUnit.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
            continue;
          }

          var sync = this.decrypter.isSync();

          this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);

          if (!sync) {
            return;
          }
        }
      }
    }
  }]);

  return SampleAesDecrypter;
}();

exports.default = SampleAesDecrypter;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/demux/tsdemuxer.js":
/*!***************************************!*\
  !*** ./src/hls.js/demux/tsdemuxer.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * highly optimized TS demuxer:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * parse PAT, PMT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract PES packet from audio and video PIDs
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * trigger the remuxer upon parsing completion
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also controls the remuxing process :
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

// import Hex from '../utils/hex';


var _adts = __webpack_require__(/*! ./adts */ "./src/hls.js/demux/adts.js");

var ADTS = _interopRequireWildcard(_adts);

var _mpegaudio = __webpack_require__(/*! ./mpegaudio */ "./src/hls.js/demux/mpegaudio.js");

var _mpegaudio2 = _interopRequireDefault(_mpegaudio);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _expGolomb = __webpack_require__(/*! ./exp-golomb */ "./src/hls.js/demux/exp-golomb.js");

var _expGolomb2 = _interopRequireDefault(_expGolomb);

var _sampleAes = __webpack_require__(/*! ./sample-aes */ "./src/hls.js/demux/sample-aes.js");

var _sampleAes2 = _interopRequireDefault(_sampleAes);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// We are using fixed track IDs for driving the MP4 remuxer
// instead of following the TS PIDs.
// There is no reason not to do this and some browsers/SourceBuffer-demuxers
// may not like if there are TrackID "switches"
// See https://github.com/video-dev/hls.js/issues/1331
// Here we are mapping our internal track types to constant MP4 track IDs
// With MSE currently one can only have one track of each, and we are muxing
// whatever video/audio rendition in them.
var RemuxerTrackIdConfig = {
  video: 1,
  audio: 2,
  id3: 3,
  text: 4
};

var TSDemuxer = function () {
  function TSDemuxer(observer, remuxer, config, typeSupported) {
    _classCallCheck(this, TSDemuxer);

    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    this.remuxer = remuxer;
    this.sampleAes = null;
  }

  _createClass(TSDemuxer, [{
    key: 'setDecryptData',
    value: function setDecryptData(decryptdata) {
      if (decryptdata != null && decryptdata.key != null && decryptdata.method === 'SAMPLE-AES') {
        this.sampleAes = new _sampleAes2.default(this.observer, this.config, decryptdata, this.discardEPB);
      } else {
        this.sampleAes = null;
      }
    }
  }, {
    key: 'resetInitSegment',


    /**
     * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
     * Resets all internal track instances of the demuxer.
     *
     * @override Implements generic demuxing/remuxing interface (see DemuxerInline)
     * @param {object} initSegment
     * @param {string} audioCodec
     * @param {string} videoCodec
     * @param {number} duration (in TS timescale = 90kHz)
     */
    value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
      this.pmtParsed = false;
      this._pmtId = -1;

      this._avcTrack = TSDemuxer.createTrack('video', duration);
      this._audioTrack = TSDemuxer.createTrack('audio', duration);
      this._id3Track = TSDemuxer.createTrack('id3', duration);
      this._txtTrack = TSDemuxer.createTrack('text', duration);

      // flush any partial content
      this.aacOverFlow = null;
      this.aacLastPTS = null;
      this.avcSample = null;
      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this._duration = duration;
    }

    /**
     *
     * @override
     */

  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}

    // feed incoming data to the front of the parsing pipeline

  }, {
    key: 'append',
    value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
      var start = void 0,
          len = data.length,
          stt = void 0,
          pid = void 0,
          atf = void 0,
          offset = void 0,
          pes = void 0,
          unknownPIDs = false;
      this.contiguous = contiguous;
      var pmtParsed = this.pmtParsed,
          avcTrack = this._avcTrack,
          audioTrack = this._audioTrack,
          id3Track = this._id3Track,
          avcId = avcTrack.pid,
          audioId = audioTrack.pid,
          id3Id = id3Track.pid,
          pmtId = this._pmtId,
          avcData = avcTrack.pesData,
          audioData = audioTrack.pesData,
          id3Data = id3Track.pesData,
          parsePAT = this._parsePAT,
          parsePMT = this._parsePMT,
          parsePES = this._parsePES,
          parseAVCPES = this._parseAVCPES.bind(this),
          parseAACPES = this._parseAACPES.bind(this),
          parseMPEGPES = this._parseMPEGPES.bind(this),
          parseID3PES = this._parseID3PES.bind(this);

      var syncOffset = TSDemuxer._syncOffset(data);

      // don't parse last TS packet if incomplete
      len -= (len + syncOffset) % 188;

      // loop through TS packets
      for (start = syncOffset; start < len; start += 188) {
        if (data[start] === 0x47) {
          stt = !!(data[start + 1] & 0x40);
          // pid is a 13-bit field starting at the last bit of TS[1]
          pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
          atf = (data[start + 3] & 0x30) >> 4;
          // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
          if (atf > 1) {
            offset = start + 5 + data[start + 4];
            // continue if there is only adaptation field
            if (offset === start + 188) {
              continue;
            }
          } else {
            offset = start + 4;
          }
          switch (pid) {
            case avcId:
              if (stt) {
                if (avcData && (pes = parsePES(avcData)) && pes.pts !== undefined) {
                  parseAVCPES(pes, false);
                }

                avcData = { data: [], size: 0 };
              }
              if (avcData) {
                avcData.data.push(data.subarray(offset, start + 188));
                avcData.size += start + 188 - offset;
              }
              break;
            case audioId:
              if (stt) {
                if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {
                  if (audioTrack.isAAC) {
                    parseAACPES(pes);
                  } else {
                    parseMPEGPES(pes);
                  }
                }
                audioData = { data: [], size: 0 };
              }
              if (audioData) {
                audioData.data.push(data.subarray(offset, start + 188));
                audioData.size += start + 188 - offset;
              }
              break;
            case id3Id:
              if (stt) {
                if (id3Data && (pes = parsePES(id3Data)) && pes.pts !== undefined) {
                  parseID3PES(pes);
                }

                id3Data = { data: [], size: 0 };
              }
              if (id3Data) {
                id3Data.data.push(data.subarray(offset, start + 188));
                id3Data.size += start + 188 - offset;
              }
              break;
            case 0:
              if (stt) {
                offset += data[offset] + 1;
              }

              pmtId = this._pmtId = parsePAT(data, offset);
              break;
            case pmtId:
              if (stt) {
                offset += data[offset] + 1;
              }

              var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, this.sampleAes != null);

              // only update track id if track PID found while parsing PMT
              // this is to avoid resetting the PID to -1 in case
              // track PID transiently disappears from the stream
              // this could happen in case of transient missing audio samples for example
              // NOTE this is only the PID of the track as found in TS,
              // but we are not using this for MP4 track IDs.
              avcId = parsedPIDs.avc;
              if (avcId > 0) {
                avcTrack.pid = avcId;
              }

              audioId = parsedPIDs.audio;
              if (audioId > 0) {
                audioTrack.pid = audioId;
                audioTrack.isAAC = parsedPIDs.isAAC;
              }
              id3Id = parsedPIDs.id3;
              if (id3Id > 0) {
                id3Track.pid = id3Id;
              }

              if (unknownPIDs && !pmtParsed) {
                _logger.logger.log('reparse from beginning');
                unknownPIDs = false;
                // we set it to -188, the += 188 in the for loop will reset start to 0
                start = syncOffset - 188;
              }
              pmtParsed = this.pmtParsed = true;
              break;
            case 17:
            case 0x1fff:
              break;
            default:
              unknownPIDs = true;
              break;
          }
        } else {
          this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });
        }
      }
      // try to parse last PES packets
      if (avcData && (pes = parsePES(avcData)) && pes.pts !== undefined) {
        parseAVCPES(pes, true);
        avcTrack.pesData = null;
      } else {
        // either avcData null or PES truncated, keep it for next frag parsing
        avcTrack.pesData = avcData;
      }

      if (audioData && (pes = parsePES(audioData)) && pes.pts !== undefined) {
        if (audioTrack.isAAC) {
          parseAACPES(pes);
        } else {
          parseMPEGPES(pes);
        }

        audioTrack.pesData = null;
      } else {
        if (audioData && audioData.size) {
          _logger.logger.log('last AAC PES packet truncated,might overlap between fragments');
        }

        // either audioData null or PES truncated, keep it for next frag parsing
        audioTrack.pesData = audioData;
      }

      if (id3Data && (pes = parsePES(id3Data)) && pes.pts !== undefined) {
        parseID3PES(pes);
        id3Track.pesData = null;
      } else {
        // either id3Data null or PES truncated, keep it for next frag parsing
        id3Track.pesData = id3Data;
      }

      if (this.sampleAes == null) {
        this.remuxer.remux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
      } else {
        this.decryptAndRemux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'decryptAndRemux',
    value: function decryptAndRemux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      if (audioTrack.samples && audioTrack.isAAC) {
        var localthis = this;
        this.sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {
          localthis.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
        });
      } else {
        this.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'decryptAndRemuxAvc',
    value: function decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      if (videoTrack.samples) {
        var localthis = this;
        this.sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {
          localthis.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
        });
      } else {
        this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this._initPTS = this._initDTS = undefined;
      this._duration = 0;
    }
  }, {
    key: '_parsePAT',
    value: function _parsePAT(data, offset) {
      // skip the PSI header and parse the first PMT entry
      return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];
      // logger.log('PMT PID:'  + this._pmtId);
    }
  }, {
    key: '_parsePMT',
    value: function _parsePMT(data, offset, mpegSupported, isSampleAes) {
      var sectionLength = void 0,
          tableEnd = void 0,
          programInfoLength = void 0,
          pid = void 0,
          result = { audio: -1, avc: -1, id3: -1, isAAC: true };
      sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
      tableEnd = offset + 3 + sectionLength - 4;
      // to determine where the table is, we have to figure out how
      // long the program info descriptors are
      programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];
      // advance the offset to the first entry in the mapping table
      offset += 12 + programInfoLength;
      while (offset < tableEnd) {
        pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];
        switch (data[offset]) {
          case 0xcf:
            // SAMPLE-AES AAC
            if (!isSampleAes) {
              _logger.logger.log('unkown stream type:' + data[offset]);
              break;
            }
          /* falls through */

          // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
          case 0x0f:
            // logger.log('AAC PID:'  + pid);
            if (result.audio === -1) {
              result.audio = pid;
            }

            break;

          // Packetized metadata (ID3)
          case 0x15:
            // logger.log('ID3 PID:'  + pid);
            if (result.id3 === -1) {
              result.id3 = pid;
            }

            break;

          case 0xdb:
            // SAMPLE-AES AVC
            if (!isSampleAes) {
              _logger.logger.log('unkown stream type:' + data[offset]);
              break;
            }
          /* falls through */

          // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
          case 0x1b:
            // logger.log('AVC PID:'  + pid);
            if (result.avc === -1) {
              result.avc = pid;
            }

            break;

          // ISO/IEC 11172-3 (MPEG-1 audio)
          // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
          case 0x03:
          case 0x04:
            // logger.log('MPEG PID:'  + pid);
            if (!mpegSupported) {
              _logger.logger.log('MPEG audio found, not supported in this browser for now');
            } else if (result.audio === -1) {
              result.audio = pid;
              result.isAAC = false;
            }
            break;

          case 0x24:
            _logger.logger.warn('HEVC stream type found, not supported for now');
            break;

          default:
            _logger.logger.log('unkown stream type:' + data[offset]);
            break;
        }
        // move to the next table entry
        // skip past the elementary stream descriptors, if present
        offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;
      }
      return result;
    }
  }, {
    key: '_parsePES',
    value: function _parsePES(stream) {
      var i = 0,
          frag = void 0,
          pesFlags = void 0,
          pesPrefix = void 0,
          pesLen = void 0,
          pesHdrLen = void 0,
          pesData = void 0,
          pesPts = void 0,
          pesDts = void 0,
          payloadStartOffset = void 0,
          data = stream.data;
      // safety check
      if (!stream || stream.size === 0) {
        return null;
      }

      // we might need up to 19 bytes to read PES header
      // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
      // usually only one merge is needed (and this is rare ...)
      while (data[0].length < 19 && data.length > 1) {
        var newData = new Uint8Array(data[0].length + data[1].length);
        newData.set(data[0]);
        newData.set(data[1], data[0].length);
        data[0] = newData;
        data.splice(1, 1);
      }
      // retrieve PTS/DTS from first fragment
      frag = data[0];
      pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
      if (pesPrefix === 1) {
        pesLen = (frag[4] << 8) + frag[5];
        // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated
        // minus 6 : PES header size
        if (pesLen && pesLen > stream.size - 6) {
          return null;
        }

        pesFlags = frag[7];
        if (pesFlags & 0xC0) {
          /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
              as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
              as Bitwise operators treat their operands as a sequence of 32 bits */
          pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29
          (frag[10] & 0xFF) * 4194304 + // 1 << 22
          (frag[11] & 0xFE) * 16384 + // 1 << 14
          (frag[12] & 0xFF) * 128 + // 1 << 7
          (frag[13] & 0xFE) / 2;
          // check if greater than 2^32 -1
          if (pesPts > 4294967295) {
            // decrement 2^33
            pesPts -= 8589934592;
          }
          if (pesFlags & 0x40) {
            pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29
            (frag[15] & 0xFF) * 4194304 + // 1 << 22
            (frag[16] & 0xFE) * 16384 + // 1 << 14
            (frag[17] & 0xFF) * 128 + // 1 << 7
            (frag[18] & 0xFE) / 2;
            // check if greater than 2^32 -1
            if (pesDts > 4294967295) {
              // decrement 2^33
              pesDts -= 8589934592;
            }
            if (pesPts - pesDts > 60 * 90000) {
              _logger.logger.warn(Math.round((pesPts - pesDts) / 90000) + 's delta between PTS and DTS, align them');
              pesPts = pesDts;
            }
          } else {
            pesDts = pesPts;
          }
        }
        pesHdrLen = frag[8];
        // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension
        payloadStartOffset = pesHdrLen + 9;

        stream.size -= payloadStartOffset;
        // reassemble PES packet
        pesData = new Uint8Array(stream.size);
        for (var j = 0, dataLen = data.length; j < dataLen; j++) {
          frag = data[j];
          var len = frag.byteLength;
          if (payloadStartOffset) {
            if (payloadStartOffset > len) {
              // trim full frag if PES header bigger than frag
              payloadStartOffset -= len;
              continue;
            } else {
              // trim partial frag if PES header smaller than frag
              frag = frag.subarray(payloadStartOffset);
              len -= payloadStartOffset;
              payloadStartOffset = 0;
            }
          }
          pesData.set(frag, i);
          i += len;
        }
        if (pesLen) {
          // payload size : remove PES header + PES extension
          pesLen -= pesHdrLen + 3;
        }
        return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };
      } else {
        return null;
      }
    }
  }, {
    key: 'pushAccesUnit',
    value: function pushAccesUnit(avcSample, avcTrack) {
      if (avcSample.units.length && avcSample.frame) {
        var samples = avcTrack.samples;
        var nbSamples = samples.length;
        // only push AVC sample if starting with a keyframe is not mandatory OR
        //    if keyframe already found in this fragment OR
        //       keyframe found in last fragment (track.sps) AND
        //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
        if (!this.config.forceKeyFrameOnDiscontinuity || avcSample.key === true || avcTrack.sps && (nbSamples || this.contiguous)) {
          avcSample.id = nbSamples;
          samples.push(avcSample);
        } else {
          // dropped samples, track it
          avcTrack.dropped++;
        }
      }
      if (avcSample.debug.length) {
        _logger.logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);
      }
    }
  }, {
    key: '_parseAVCPES',
    value: function _parseAVCPES(pes, last) {
      var _this = this;

      // logger.log('parse new PES');
      var track = this._avcTrack,
          units = this._parseAVCNALu(pes.data),
          debug = false,
          expGolombDecoder = void 0,
          avcSample = this.avcSample,
          push = void 0,
          spsfound = false,
          i = void 0,
          pushAccesUnit = this.pushAccesUnit.bind(this),
          createAVCSample = function createAVCSample(key, pts, dts, debug) {
        return { key: key, pts: pts, dts: dts, units: [], debug: debug };
      };
      // free pes.data to save up some memory
      pes.data = null;

      // if new NAL units found and last sample still there, let's push ...
      // this helps parsing streams with missing AUD (only do this if AUD never found)
      if (avcSample && units.length && !track.audFound) {
        pushAccesUnit(avcSample, track);
        avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');
      }

      units.forEach(function (unit) {
        switch (unit.type) {
          // NDR
          case 1:
            push = true;
            if (!avcSample) {
              avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');
            }

            if (debug) {
              avcSample.debug += 'NDR ';
            }

            avcSample.frame = true;
            var data = unit.data;
            // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)
            if (spsfound && data.length > 4) {
              // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR
              var sliceType = new _expGolomb2.default(data).readSliceType();
              // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice
              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.
              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.
              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.
              // if (sliceType === 2 || sliceType === 7) {
              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                avcSample.key = true;
              }
            }
            break;
          // IDR
          case 5:
            push = true;
            // handle PES not starting with AUD
            if (!avcSample) {
              avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');
            }

            if (debug) {
              avcSample.debug += 'IDR ';
            }

            avcSample.key = true;
            avcSample.frame = true;
            break;
          // SEI
          case 6:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'SEI ';
            }

            expGolombDecoder = new _expGolomb2.default(_this.discardEPB(unit.data));

            // skip frameType
            expGolombDecoder.readUByte();

            var payloadType = 0;
            var payloadSize = 0;
            var endOfCaptions = false;
            var b = 0;

            while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
              payloadType = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadType += b;
              } while (b === 0xFF);

              // Parse payload size.
              payloadSize = 0;
              do {
                b = expGolombDecoder.readUByte();
                payloadSize += b;
              } while (b === 0xFF);

              // TODO: there can be more than one payload in an SEI packet...
              // TODO: need to read type and size in a while loop to get them all
              if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {
                endOfCaptions = true;

                var countryCode = expGolombDecoder.readUByte();

                if (countryCode === 181) {
                  var providerCode = expGolombDecoder.readUShort();

                  if (providerCode === 49) {
                    var userStructure = expGolombDecoder.readUInt();

                    if (userStructure === 0x47413934) {
                      var userDataType = expGolombDecoder.readUByte();

                      // Raw CEA-608 bytes wrapped in CEA-708 packet
                      if (userDataType === 3) {
                        var firstByte = expGolombDecoder.readUByte();
                        var secondByte = expGolombDecoder.readUByte();

                        var totalCCs = 31 & firstByte;
                        var byteArray = [firstByte, secondByte];

                        for (i = 0; i < totalCCs; i++) {
                          // 3 bytes per CC
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                        }

                        _this._insertSampleInOrder(_this._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });
                      }
                    }
                  }
                }
              } else if (payloadSize < expGolombDecoder.bytesAvailable) {
                for (i = 0; i < payloadSize; i++) {
                  expGolombDecoder.readUByte();
                }
              }
            }
            break;
          // SPS
          case 7:
            push = true;
            spsfound = true;
            if (debug && avcSample) {
              avcSample.debug += 'SPS ';
            }

            if (!track.sps) {
              expGolombDecoder = new _expGolomb2.default(unit.data);
              var config = expGolombDecoder.readSPS();
              track.width = config.width;
              track.height = config.height;
              track.pixelRatio = config.pixelRatio;
              track.sps = [unit.data];
              track.duration = _this._duration;
              var codecarray = unit.data.subarray(1, 4);
              var codecstring = 'avc1.';
              for (i = 0; i < 3; i++) {
                var h = codecarray[i].toString(16);
                if (h.length < 2) {
                  h = '0' + h;
                }

                codecstring += h;
              }
              track.codec = codecstring;
            }
            break;
          // PPS
          case 8:
            push = true;
            if (debug && avcSample) {
              avcSample.debug += 'PPS ';
            }

            if (!track.pps) {
              track.pps = [unit.data];
            }

            break;
          // AUD
          case 9:
            push = false;
            track.audFound = true;
            if (avcSample) {
              pushAccesUnit(avcSample, track);
            }

            avcSample = _this.avcSample = createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');
            break;
          // Filler Data
          case 12:
            push = false;
            break;
          default:
            push = false;
            if (avcSample) {
              avcSample.debug += 'unknown NAL ' + unit.type + ' ';
            }

            break;
        }
        if (avcSample && push) {
          var _units = avcSample.units;
          _units.push(unit);
        }
      });
      // if last PES packet, push samples
      if (last && avcSample) {
        pushAccesUnit(avcSample, track);
        this.avcSample = null;
      }
    }
  }, {
    key: '_insertSampleInOrder',
    value: function _insertSampleInOrder(arr, data) {
      var len = arr.length;
      if (len > 0) {
        if (data.pts >= arr[len - 1].pts) {
          arr.push(data);
        } else {
          for (var pos = len - 1; pos >= 0; pos--) {
            if (data.pts < arr[pos].pts) {
              arr.splice(pos, 0, data);
              break;
            }
          }
        }
      } else {
        arr.push(data);
      }
    }
  }, {
    key: '_getLastNalUnit',
    value: function _getLastNalUnit() {
      var avcSample = this.avcSample,
          lastUnit = void 0;
      // try to fallback to previous sample if current one is empty
      if (!avcSample || avcSample.units.length === 0) {
        var track = this._avcTrack,
            samples = track.samples;
        avcSample = samples[samples.length - 1];
      }
      if (avcSample) {
        var units = avcSample.units;
        lastUnit = units[units.length - 1];
      }
      return lastUnit;
    }
  }, {
    key: '_parseAVCNALu',
    value: function _parseAVCNALu(array) {
      var i = 0,
          len = array.byteLength,
          value = void 0,
          overflow = void 0,
          track = this._avcTrack,
          state = track.naluState || 0,
          lastState = state;
      var units = [],
          unit = void 0,
          unitType = void 0,
          lastUnitStart = -1,
          lastUnitType = void 0;
      // logger.log('PES:' + Hex.hexDump(array));

      if (state === -1) {
        // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
        lastUnitStart = 0;
        // NALu type is value read from offset 0
        lastUnitType = array[0] & 0x1f;
        state = 0;
        i = 1;
      }

      while (i < len) {
        value = array[i++];
        // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case
        if (!state) {
          state = value ? 0 : 1;
          continue;
        }
        if (state === 1) {
          state = value ? 0 : 2;
          continue;
        }
        // here we have state either equal to 2 or 3
        if (!value) {
          state = 3;
        } else if (value === 1) {
          if (lastUnitStart >= 0) {
            unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
            // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
            units.push(unit);
          } else {
            // lastUnitStart is undefined => this is the first start code found in this PES packet
            // first check if start code delimiter is overlapping between 2 PES packets,
            // ie it started in last packet (lastState not zero)
            // and ended at the beginning of this PES packet (i <= 4 - lastState)
            var lastUnit = this._getLastNalUnit();
            if (lastUnit) {
              if (lastState && i <= 4 - lastState) {
                // start delimiter overlapping between PES packets
                // strip start delimiter bytes from the end of last NAL unit
                // check if lastUnit had a state different from zero
                if (lastUnit.state) {
                  // strip last bytes
                  lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                }
              }
              // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
              overflow = i - state - 1;
              if (overflow > 0) {
                // logger.log('first NALU found with overflow:' + overflow);
                var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
                tmp.set(lastUnit.data, 0);
                tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
                lastUnit.data = tmp;
              }
            }
          }
          // check if we can read unit type
          if (i < len) {
            unitType = array[i] & 0x1f;
            // logger.log('find NALU @ offset:' + i + ',type:' + unitType);
            lastUnitStart = i;
            lastUnitType = unitType;
            state = 0;
          } else {
            // not enough byte to read unit type. let's read it on next PES parsing
            state = -1;
          }
        } else {
          state = 0;
        }
      }
      if (lastUnitStart >= 0 && state >= 0) {
        unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
        units.push(unit);
        // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
      }
      // no NALu found
      if (units.length === 0) {
        // append pes.data to previous NAL unit
        var _lastUnit = this._getLastNalUnit();
        if (_lastUnit) {
          var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);
          _tmp.set(_lastUnit.data, 0);
          _tmp.set(array, _lastUnit.data.byteLength);
          _lastUnit.data = _tmp;
        }
      }
      track.naluState = state;
      return units;
    }

    /**
     * remove Emulation Prevention bytes from a RBSP
     */

  }, {
    key: 'discardEPB',
    value: function discardEPB(data) {
      var length = data.byteLength,
          EPBPositions = [],
          i = 1,
          newLength = void 0,
          newData = void 0;

      // Find all `Emulation Prevention Bytes`
      while (i < length - 2) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
          EPBPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }

      // If no Emulation Prevention Bytes were found just return the original
      // array
      if (EPBPositions.length === 0) {
        return data;
      }

      // Create a new array to hold the NAL unit data
      newLength = length - EPBPositions.length;
      newData = new Uint8Array(newLength);
      var sourceIndex = 0;

      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === EPBPositions[0]) {
          // Skip this byte
          sourceIndex++;
          // Remove this position index
          EPBPositions.shift();
        }
        newData[i] = data[sourceIndex];
      }
      return newData;
    }
  }, {
    key: '_parseAACPES',
    value: function _parseAACPES(pes) {
      var track = this._audioTrack,
          data = pes.data,
          pts = pes.pts,
          startOffset = 0,
          aacOverFlow = this.aacOverFlow,
          aacLastPTS = this.aacLastPTS,
          frameDuration = void 0,
          frameIndex = void 0,
          offset = void 0,
          stamp = void 0,
          len = void 0;
      if (aacOverFlow) {
        var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
        tmp.set(aacOverFlow, 0);
        tmp.set(data, aacOverFlow.byteLength);
        // logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);
        data = tmp;
      }
      // look for ADTS header (0xFFFx)
      for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
        if (ADTS.isHeader(data, offset)) {
          break;
        }
      }
      // if ADTS header does not start straight from the beginning of the PES payload, raise an error
      if (offset) {
        var reason = void 0,
            fatal = void 0;
        if (offset < len - 1) {
          reason = 'AAC PES did not start with ADTS header,offset:' + offset;
          fatal = false;
        } else {
          reason = 'no ADTS header found in AAC PES';
          fatal = true;
        }
        _logger.logger.warn('parsing error:' + reason);
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });
        if (fatal) {
          return;
        }
      }

      ADTS.initTrackConfig(track, this.observer, data, offset, this.audioCodec);
      frameIndex = 0;
      frameDuration = ADTS.getFrameDuration(track.samplerate);

      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
      // first sample PTS should be equal to last sample PTS + frameDuration
      if (aacOverFlow && aacLastPTS) {
        var newPTS = aacLastPTS + frameDuration;
        if (Math.abs(newPTS - pts) > 1) {
          _logger.logger.log('AAC: align PTS for overlapping frames by ' + Math.round((newPTS - pts) / 90));
          pts = newPTS;
        }
      }

      // scan for aac samples
      while (offset < len) {
        if (ADTS.isHeader(data, offset) && offset + 5 < len) {
          var frame = ADTS.appendFrame(track, data, offset, pts, frameIndex);
          if (frame) {
            // logger.log(`${Math.round(frame.sample.pts)} : AAC`);
            offset += frame.length;
            stamp = frame.sample.pts;
            frameIndex++;
          } else {
            // logger.log('Unable to parse AAC frame');
            break;
          }
        } else {
          // nothing found, keep looking
          offset++;
        }
      }

      if (offset < len) {
        aacOverFlow = data.subarray(offset, len);
        // logger.log(`AAC: overflow detected:${len-offset}`);
      } else {
        aacOverFlow = null;
      }

      this.aacOverFlow = aacOverFlow;
      this.aacLastPTS = stamp;
    }
  }, {
    key: '_parseMPEGPES',
    value: function _parseMPEGPES(pes) {
      var data = pes.data;
      var length = data.length;
      var frameIndex = 0;
      var offset = 0;
      var pts = pes.pts;

      while (offset < length) {
        if (_mpegaudio2.default.isHeader(data, offset)) {
          var frame = _mpegaudio2.default.appendFrame(this._audioTrack, data, offset, pts, frameIndex);
          if (frame) {
            offset += frame.length;
            frameIndex++;
          } else {
            // logger.log('Unable to parse Mpeg audio frame');
            break;
          }
        } else {
          // nothing found, keep looking
          offset++;
        }
      }
    }
  }, {
    key: '_parseID3PES',
    value: function _parseID3PES(pes) {
      this._id3Track.samples.push(pes);
    }
  }], [{
    key: 'probe',
    value: function probe(data) {
      var syncOffset = TSDemuxer._syncOffset(data);
      if (syncOffset < 0) {
        return false;
      } else {
        if (syncOffset) {
          _logger.logger.warn('MPEG2-TS detected but first sync word found @ offset ' + syncOffset + ', junk ahead ?');
        }

        return true;
      }
    }
  }, {
    key: '_syncOffset',
    value: function _syncOffset(data) {
      // scan 1000 first bytes
      var scanwindow = Math.min(1000, data.length - 3 * 188);
      var i = 0;
      while (i < scanwindow) {
        // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
        if (data[i] === 0x47 && data[i + 188] === 0x47 && data[i + 2 * 188] === 0x47) {
          return i;
        } else {
          i++;
        }
      }
      return -1;
    }

    /**
     * Creates a track model internal to demuxer used to drive remuxing input
     *
     * @param {string} type 'audio' | 'video' | 'id3' | 'text'
     * @param {number} duration
     * @return {object} TSDemuxer's internal track model
     */

  }, {
    key: 'createTrack',
    value: function createTrack(type, duration) {
      return {
        container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,
        type: type,
        id: RemuxerTrackIdConfig[type],
        pid: -1,
        inputTimeScale: 90000,
        sequenceNumber: 0,
        samples: [],
        len: 0,
        dropped: type === 'video' ? 0 : undefined,
        isAAC: type === 'audio' ? true : undefined,
        duration: type === 'audio' ? duration : undefined
      };
    }
  }]);

  return TSDemuxer;
}();

exports.default = TSDemuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/errors.js":
/*!******************************!*\
  !*** ./src/hls.js/errors.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var ErrorTypes = exports.ErrorTypes = {
  // Identifier for a network error (loading error / timeout ...)
  NETWORK_ERROR: 'networkError',
  // Identifier for a media Error (video/parsing/mediasource error)
  MEDIA_ERROR: 'mediaError',
  // EME (encrypted media extensions) errors
  KEY_SYSTEM_ERROR: 'keySystemError',
  // Identifier for a mux Error (demuxing/remuxing)
  MUX_ERROR: 'muxError',
  // Identifier for all other errors
  OTHER_ERROR: 'otherError'
};

/**
 * @enum {ErrorDetails}
 * @typedef {string} ErrorDetail
 */
var ErrorDetails = exports.ErrorDetails = {
  KEY_SYSTEM_NO_KEYS: 'keySystemNoKeys',
  KEY_SYSTEM_NO_ACCESS: 'keySystemNoAccess',
  KEY_SYSTEM_NO_SESSION: 'keySystemNoSession',
  KEY_SYSTEM_LICENSE_REQUEST_FAILED: 'keySystemLicenseRequestFailed',
  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_ERROR: 'manifestLoadError',
  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',
  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
  MANIFEST_PARSING_ERROR: 'manifestParsingError',
  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
  MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',
  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_ERROR: 'levelLoadError',
  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',
  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
  LEVEL_SWITCH_ERROR: 'levelSwitchError',
  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',
  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',
  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  FRAG_LOAD_ERROR: 'fragLoadError',
  // Identifier for fragment load timeout error - data: { frag : fragment object}
  FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',
  // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }
  FRAG_DECRYPT_ERROR: 'fragDecryptError',
  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
  FRAG_PARSING_ERROR: 'fragParsingError',
  // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }
  REMUX_ALLOC_ERROR: 'remuxAllocError',
  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  KEY_LOAD_ERROR: 'keyLoadError',
  // Identifier for decrypt key load timeout error - data: { frag : fragment object}
  KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',
  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
  BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',
  // Identifier for a buffer append error - data: append error description
  BUFFER_APPEND_ERROR: 'bufferAppendError',
  // Identifier for a buffer appending error event - data: appending error description
  BUFFER_APPENDING_ERROR: 'bufferAppendingError',
  // Identifier for a buffer stalled error event
  BUFFER_STALLED_ERROR: 'bufferStalledError',
  // Identifier for a buffer full event
  BUFFER_FULL_ERROR: 'bufferFullError',
  // Identifier for a buffer seek over hole event
  BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',
  // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)
  BUFFER_NUDGE_ON_STALL: 'bufferNudgeOnStall',
  // Identifier for an internal exception happening inside hls.js while handling an event
  INTERNAL_EXCEPTION: 'internalException'
};

/***/ }),

/***/ "./src/hls.js/event-handler.js":
/*!*************************************!*\
  !*** ./src/hls.js/event-handler.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * All objects in the event handling chain should inherit from this class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = __webpack_require__(/*! ./utils/logger */ "./src/hls.js/utils/logger.js");

var _errors = __webpack_require__(/*! ./errors */ "./src/hls.js/errors.js");

var _events = __webpack_require__(/*! ./events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FORBIDDEN_EVENT_NAMES = {
  'hlsEventGeneric': true,
  'hlsHandlerDestroying': true,
  'hlsHandlerDestroyed': true
};

var EventHandler = function () {
  function EventHandler(hls) {
    _classCallCheck(this, EventHandler);

    this.hls = hls;
    this.onEvent = this.onEvent.bind(this);

    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      events[_key - 1] = arguments[_key];
    }

    this.handledEvents = events;
    this.useGenericHandler = true;

    this.registerListeners();
  }

  _createClass(EventHandler, [{
    key: 'destroy',
    value: function destroy() {
      this.onHandlerDestroying();
      this.unregisterListeners();
      this.onHandlerDestroyed();
    }
  }, {
    key: 'onHandlerDestroying',
    value: function onHandlerDestroying() {}
  }, {
    key: 'onHandlerDestroyed',
    value: function onHandlerDestroyed() {}
  }, {
    key: 'isEventHandler',
    value: function isEventHandler() {
      return _typeof(this.handledEvents) === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';
    }
  }, {
    key: 'registerListeners',
    value: function registerListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          if (FORBIDDEN_EVENT_NAMES[event]) {
            throw new Error('Forbidden event-name: ' + event);
          }

          this.hls.on(event, this.onEvent);
        }, this);
      }
    }
  }, {
    key: 'unregisterListeners',
    value: function unregisterListeners() {
      if (this.isEventHandler()) {
        this.handledEvents.forEach(function (event) {
          this.hls.off(event, this.onEvent);
        }, this);
      }
    }

    /**
     * arguments: event (string), data (any)
     */

  }, {
    key: 'onEvent',
    value: function onEvent(event, data) {
      this.onEventGeneric(event, data);
    }
  }, {
    key: 'onEventGeneric',
    value: function onEventGeneric(event, data) {
      var eventToFunction = function eventToFunction(event, data) {
        var funcName = 'on' + event.replace('hls', '');
        if (typeof this[funcName] !== 'function') {
          throw new Error('Event ' + event + ' has no generic handler in this ' + this.constructor.name + ' class (tried ' + funcName + ')');
        }

        return this[funcName].bind(this, data);
      };
      try {
        eventToFunction.call(this, event, data).call();
      } catch (err) {
        _logger.logger.error('An internal error happened while handling event ' + event + '. Error message: "' + err.message + '". Here is a stacktrace:', err);
        this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: event, err: err });
      }
    }
  }]);

  return EventHandler;
}();

exports.default = EventHandler;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/events.js":
/*!******************************!*\
  !*** ./src/hls.js/events.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @readonly
 * @enum {string}
 */
var HlsEvents = {
  // fired before MediaSource is attaching to media element - data: { media }
  MEDIA_ATTACHING: 'hlsMediaAttaching',
  // fired when MediaSource has been succesfully attached to media element - data: { }
  MEDIA_ATTACHED: 'hlsMediaAttached',
  // fired before detaching MediaSource from media element - data: { }
  MEDIA_DETACHING: 'hlsMediaDetaching',
  // fired when MediaSource has been detached from media element - data: { }
  MEDIA_DETACHED: 'hlsMediaDetached',
  // fired when we buffer is going to be reset - data: { }
  BUFFER_RESET: 'hlsBufferReset',
  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
  BUFFER_CODECS: 'hlsBufferCodecs',
  // fired when sourcebuffers have been created - data: { tracks : tracks }
  BUFFER_CREATED: 'hlsBufferCreated',
  // fired when we append a segment to the buffer - data: { segment: segment object }
  BUFFER_APPENDING: 'hlsBufferAppending',
  // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
  BUFFER_APPENDED: 'hlsBufferAppended',
  // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
  BUFFER_EOS: 'hlsBufferEos',
  // fired when the media buffer should be flushed - data { startOffset, endOffset }
  BUFFER_FLUSHING: 'hlsBufferFlushing',
  // fired when the media buffer has been flushed - data: { }
  BUFFER_FLUSHED: 'hlsBufferFlushed',
  // fired to signal that a manifest loading starts - data: { url : manifestURL}
  MANIFEST_LOADING: 'hlsManifestLoading',
  // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
  MANIFEST_LOADED: 'hlsManifestLoaded',
  // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
  MANIFEST_PARSED: 'hlsManifestParsed',
  // fired when a level switch is requested - data: { level : id of new level }
  LEVEL_SWITCHING: 'hlsLevelSwitching',
  // fired when a level switch is effective - data: { level : id of new level }
  LEVEL_SWITCHED: 'hlsLevelSwitched',
  // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
  LEVEL_LOADING: 'hlsLevelLoading',
  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
  LEVEL_LOADED: 'hlsLevelLoaded',
  // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
  LEVEL_UPDATED: 'hlsLevelUpdated',
  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
  // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
  // fired when an audio track switching is requested - data: { id : audio track id }
  AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',
  // fired when an audio track switch actually occurs - data: { id : audio track id }
  AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',
  // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
  // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
  // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
  SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',
  // fired when an subtitle track switch occurs - data: { id : subtitle track id }
  SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',
  // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
  SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',
  // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
  SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',
  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
  SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',
  // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
  INIT_PTS_FOUND: 'hlsInitPtsFound',
  // fired when a fragment loading starts - data: { frag : fragment object }
  FRAG_LOADING: 'hlsFragLoading',
  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
  // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
  FRAG_LOADED: 'hlsFragLoaded',
  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }
  FRAG_DECRYPTED: 'hlsFragDecrypted',
  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
  // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
  FRAG_PARSING_DATA: 'hlsFragParsingData',
  // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
  FRAG_PARSED: 'hlsFragParsed',
  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
  FRAG_BUFFERED: 'hlsFragBuffered',
  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
  FRAG_CHANGED: 'hlsFragChanged',
  // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
  FPS_DROP: 'hlsFpsDrop',
  // triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
  ERROR: 'hlsError',
  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
  DESTROYING: 'hlsDestroying',
  // fired when a decrypt key loading starts - data: { frag : fragment object }
  KEY_LOADING: 'hlsKeyLoading',
  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
  KEY_LOADED: 'hlsKeyLoaded',
  // fired upon stream controller state transitions - data: { previousState, nextState }
  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
};

exports.default = HlsEvents;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/hls.js":
/*!***************************!*\
  !*** ./src/hls.js/hls.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "../../node_modules/url-toolkit/src/url-toolkit.js");

var URLToolkit = _interopRequireWildcard(_urlToolkit);

var _errors = __webpack_require__(/*! ./errors */ "./src/hls.js/errors.js");

var _playlistLoader = __webpack_require__(/*! ./loader/playlist-loader */ "./src/hls.js/loader/playlist-loader.js");

var _playlistLoader2 = _interopRequireDefault(_playlistLoader);

var _fragmentLoader = __webpack_require__(/*! ./loader/fragment-loader */ "./src/hls.js/loader/fragment-loader.js");

var _fragmentLoader2 = _interopRequireDefault(_fragmentLoader);

var _keyLoader = __webpack_require__(/*! ./loader/key-loader */ "./src/hls.js/loader/key-loader.js");

var _keyLoader2 = _interopRequireDefault(_keyLoader);

var _fragmentTracker = __webpack_require__(/*! ./controller/fragment-tracker */ "./src/hls.js/controller/fragment-tracker.js");

var _streamController = __webpack_require__(/*! ./controller/stream-controller */ "./src/hls.js/controller/stream-controller.js");

var _streamController2 = _interopRequireDefault(_streamController);

var _levelController = __webpack_require__(/*! ./controller/level-controller */ "./src/hls.js/controller/level-controller.js");

var _levelController2 = _interopRequireDefault(_levelController);

var _id3TrackController = __webpack_require__(/*! ./controller/id3-track-controller */ "./src/hls.js/controller/id3-track-controller.js");

var _id3TrackController2 = _interopRequireDefault(_id3TrackController);

var _isSupported2 = __webpack_require__(/*! ./is-supported */ "./src/hls.js/is-supported.js");

var _logger = __webpack_require__(/*! ./utils/logger */ "./src/hls.js/utils/logger.js");

var _config = __webpack_require__(/*! ./config */ "./src/hls.js/config.js");

var _events = __webpack_require__(/*! ./events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _observer = __webpack_require__(/*! ./observer */ "./src/hls.js/observer.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @module Hls
 * @class
 * @constructor
 */
var Hls = function (_Observer) {
  _inherits(Hls, _Observer);

  _createClass(Hls, null, [{
    key: 'isSupported',


    /**
     * @type {boolean}
     */
    value: function isSupported() {
      return (0, _isSupported2.isSupported)();
    }

    /**
     * @type {HlsEvents}
     */

  }, {
    key: 'version',

    /**
     * @type {string}
     */
    get: function get() {
      return __VERSION__;
    }
  }, {
    key: 'Events',
    get: function get() {
      return _events2.default;
    }

    /**
     * @type {HlsErrorTypes}
     */

  }, {
    key: 'ErrorTypes',
    get: function get() {
      return _errors.ErrorTypes;
    }

    /**
     * @type {HlsErrorDetails}
     */

  }, {
    key: 'ErrorDetails',
    get: function get() {
      return _errors.ErrorDetails;
    }

    /**
     * @type {HlsConfig}
     */

  }, {
    key: 'DefaultConfig',
    get: function get() {
      if (!Hls.defaultConfig) {
        return _config.hlsDefaultConfig;
      }

      return Hls.defaultConfig;
    }

    /**
     * @type {HlsConfig}
     */
    ,
    set: function set(defaultConfig) {
      Hls.defaultConfig = defaultConfig;
    }

    /**
     * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.
     *
     * @constructs Hls
     * @param {HlsConfig} config
     */

  }]);

  function Hls() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Hls);

    var _this = _possibleConstructorReturn(this, (Hls.__proto__ || Object.getPrototypeOf(Hls)).call(this));

    var defaultConfig = Hls.DefaultConfig;

    if ((config.liveSyncDurationCount || config.liveMaxLatencyDurationCount) && (config.liveSyncDuration || config.liveMaxLatencyDuration)) {
      throw new Error('Illegal hls.js config: don\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');
    }

    for (var prop in defaultConfig) {
      if (prop in config) continue;
      config[prop] = defaultConfig[prop];
    }

    if (config.liveMaxLatencyDurationCount !== undefined && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
    }

    if (config.liveMaxLatencyDuration !== undefined && (config.liveMaxLatencyDuration <= config.liveSyncDuration || config.liveSyncDuration === undefined)) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
    }

    (0, _logger.enableLogs)(config.debug);
    _this.config = config;
    _this._autoLevelCapping = -1;

    // core controllers and network loaders

    /**
     * @member {AbrController} abrController
     */
    var abrController = _this.abrController = new config.abrController(_this);

    var bufferController = new config.bufferController(_this);
    var capLevelController = new config.capLevelController(_this);
    var fpsController = new config.fpsController(_this);
    var playListLoader = new _playlistLoader2.default(_this);
    var fragmentLoader = new _fragmentLoader2.default(_this);
    var keyLoader = new _keyLoader2.default(_this);
    var id3TrackController = new _id3TrackController2.default(_this);

    // network controllers

    /**
     * @member {LevelController} levelController
     */
    var levelController = _this.levelController = new _levelController2.default(_this);

    // FIXME: FragmentTracker must be defined before StreamController because the order of event handling is important
    var fragmentTracker = new _fragmentTracker.FragmentTracker(_this);

    /**
     * @member {StreamController} streamController
     */
    var streamController = _this.streamController = new _streamController2.default(_this, fragmentTracker);

    var networkControllers = [levelController, streamController];

    // optional audio stream controller
    /**
     * @var {ICoreComponent | Controller}
     */
    var Controller = config.audioStreamController;
    if (Controller) {
      networkControllers.push(new Controller(_this, fragmentTracker));
    }

    /**
     * @member {INetworkController[]} networkControllers
     */
    _this.networkControllers = networkControllers;

    /**
     * @var {ICoreComponent[]}
     */
    var coreComponents = [playListLoader, fragmentLoader, keyLoader, abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];

    // optional audio track and subtitle controller
    Controller = config.audioTrackController;
    if (Controller) {
      var audioTrackController = new Controller(_this);

      /**
       * @member {AudioTrackController} audioTrackController
       */
      _this.audioTrackController = audioTrackController;
      coreComponents.push(audioTrackController);
    }

    Controller = config.subtitleTrackController;
    if (Controller) {
      var subtitleTrackController = new Controller(_this);

      /**
       * @member {SubtitleTrackController} subtitleTrackController
       */
      _this.subtitleTrackController = subtitleTrackController;
      networkControllers.push(subtitleTrackController);
    }

    Controller = config.emeController;
    if (Controller) {
      var emeController = new Controller(_this);

      /**
       * @member {EMEController} emeController
       */
      _this.emeController = emeController;
      coreComponents.push(emeController);
    }

    // optional subtitle controllers
    Controller = config.subtitleStreamController;
    if (Controller) {
      networkControllers.push(new Controller(_this, fragmentTracker));
    }
    Controller = config.timelineController;
    if (Controller) {
      coreComponents.push(new Controller(_this));
    }

    /**
     * @member {ICoreComponent[]}
     */
    _this.coreComponents = coreComponents;
    return _this;
  }

  /**
   * Dispose of the instance
   */


  _createClass(Hls, [{
    key: 'destroy',
    value: function destroy() {
      _logger.logger.log('destroy');
      this.trigger(_events2.default.DESTROYING);
      this.detachMedia();
      this.coreComponents.concat(this.networkControllers).forEach(function (component) {
        component.destroy();
      });
      this.url = null;
      this.removeAllListeners();
      this._autoLevelCapping = -1;
    }

    /**
     * Attach a media element
     * @param {HTMLMediaElement} media
     */

  }, {
    key: 'attachMedia',
    value: function attachMedia(media) {
      _logger.logger.log('attachMedia');
      this.media = media;
      this.trigger(_events2.default.MEDIA_ATTACHING, { media: media });
    }

    /**
     * Detach from the media
     */

  }, {
    key: 'detachMedia',
    value: function detachMedia() {
      _logger.logger.log('detachMedia');
      this.trigger(_events2.default.MEDIA_DETACHING);
      this.media = null;
    }

    /**
     * Set the source URL. Can be relative or absolute.
     * @param {string} url
     */

  }, {
    key: 'loadSource',
    value: function loadSource(url) {
      url = URLToolkit.buildAbsoluteURL(window.location.href, url, { alwaysNormalize: true });
      _logger.logger.log('loadSource:' + url);
      this.url = url;
      // when attaching to a source URL, trigger a playlist load
      this.trigger(_events2.default.MANIFEST_LOADING, { url: url });
    }

    /**
     * Start loading data from the stream source.
     * Depending on default config, client starts loading automatically when a source is set.
     *
     * @param {number} startPosition Set the start position to stream from
     * @default -1 None (from earliest point)
     */

  }, {
    key: 'startLoad',
    value: function startLoad() {
      var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;

      _logger.logger.log('startLoad(' + startPosition + ')');
      this.networkControllers.forEach(function (controller) {
        controller.startLoad(startPosition);
      });
    }

    /**
     * Stop loading of any stream data.
     */

  }, {
    key: 'stopLoad',
    value: function stopLoad() {
      _logger.logger.log('stopLoad');
      this.networkControllers.forEach(function (controller) {
        controller.stopLoad();
      });
    }

    /**
     * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)
     */

  }, {
    key: 'swapAudioCodec',
    value: function swapAudioCodec() {
      _logger.logger.log('swapAudioCodec');
      this.streamController.swapAudioCodec();
    }

    /**
     * When the media-element fails, this allows to detach and then re-attach it
     * as one call (convenience method).
     *
     * Automatic recovery of media-errors by this process is configurable.
     */

  }, {
    key: 'recoverMediaError',
    value: function recoverMediaError() {
      _logger.logger.log('recoverMediaError');
      var media = this.media;
      this.detachMedia();
      this.attachMedia(media);
    }

    /**
     * @type {QualityLevel[]}
     */

  }, {
    key: 'levels',
    get: function get() {
      return this.levelController.levels;
    }

    /**
     * Index of quality level currently played
     * @type {number}
     */

  }, {
    key: 'currentLevel',
    get: function get() {
      return this.streamController.currentLevel;
    }

    /**
     * Set quality level index immediately .
     * This will flush the current buffer to replace the quality asap.
     * That means playback will interrupt at least shortly to re-buffer and re-sync eventually.
     * @type {number} -1 for automatic level selection
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set currentLevel:' + newLevel);
      this.loadLevel = newLevel;
      this.streamController.immediateLevelSwitch();
    }

    /**
     * Index of next quality level loaded as scheduled by stream controller.
     * @type {number}
     */

  }, {
    key: 'nextLevel',
    get: function get() {
      return this.streamController.nextLevel;
    }

    /**
     * Set quality level index for next loaded data.
     * This will switch the video quality asap, without interrupting playback.
     * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).
     * @type {number} -1 for automatic level selection
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set nextLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
      this.streamController.nextLevelSwitch();
    }

    /**
     * Return the quality level of the currently or last (of none is loaded currently) segment
     * @type {number}
     */

  }, {
    key: 'loadLevel',
    get: function get() {
      return this.levelController.level;
    }

    /**
     * Set quality level index for next loaded data in a conservative way.
     * This will switch the quality without flushing, but interrupt current loading.
     * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.
     * @type {number} newLevel -1 for automatic level selection
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set loadLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
    }

    /**
     * get next quality level loaded
     * @type {number}
     */

  }, {
    key: 'nextLoadLevel',
    get: function get() {
      return this.levelController.nextLoadLevel;
    }

    /**
     * Set quality level of next loaded segment in a fully "non-destructive" way.
     * Same as `loadLevel` but will wait for next switch (until current loading is done).
     * @type {number} level
     */
    ,
    set: function set(level) {
      this.levelController.nextLoadLevel = level;
    }

    /**
     * Return "first level": like a default level, if not set,
     * falls back to index of first level referenced in manifest
     * @type {number}
     */

  }, {
    key: 'firstLevel',
    get: function get() {
      return Math.max(this.levelController.firstLevel, this.minAutoLevel);
    }

    /**
     * Sets "first-level", see getter.
     * @type {number}
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set firstLevel:' + newLevel);
      this.levelController.firstLevel = newLevel;
    }

    /**
     * Return start level (level of first fragment that will be played back)
     * if not overrided by user, first level appearing in manifest will be used as start level
     * if -1 : automatic start level selection, playback will start from level matching download bandwidth
     * (determined from download of first segment)
     * @type {number}
     */

  }, {
    key: 'startLevel',
    get: function get() {
      return this.levelController.startLevel;
    }

    /**
     * set  start level (level of first fragment that will be played back)
     * if not overrided by user, first level appearing in manifest will be used as start level
     * if -1 : automatic start level selection, playback will start from level matching download bandwidth
     * (determined from download of first segment)
     * @type {number} newLevel
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set startLevel:' + newLevel);
      var hls = this;
      // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel
      if (newLevel !== -1) {
        newLevel = Math.max(newLevel, hls.minAutoLevel);
      }

      hls.levelController.startLevel = newLevel;
    }

    /**
     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
     * @type {number}
     */

  }, {
    key: 'autoLevelCapping',
    get: function get() {
      return this._autoLevelCapping;
    }

    /**
     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
     * @type {number}
     */
    ,
    set: function set(newLevel) {
      _logger.logger.log('set autoLevelCapping:' + newLevel);
      this._autoLevelCapping = newLevel;
    }

    /**
     * True when automatic level selection enabled
     * @type {boolean}
     */

  }, {
    key: 'autoLevelEnabled',
    get: function get() {
      return this.levelController.manualLevel === -1;
    }

    /**
     * Level set manually (if any)
     * @type {number}
     */

  }, {
    key: 'manualLevel',
    get: function get() {
      return this.levelController.manualLevel;
    }

    /**
     * min level selectable in auto mode according to config.minAutoBitrate
     * @type {number}
     */

  }, {
    key: 'minAutoLevel',
    get: function get() {
      var hls = this,
          levels = hls.levels,
          minAutoBitrate = hls.config.minAutoBitrate,
          len = levels ? levels.length : 0;
      for (var i = 0; i < len; i++) {
        var levelNextBitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate;
        if (levelNextBitrate > minAutoBitrate) {
          return i;
        }
      }
      return 0;
    }

    /**
     * max level selectable in auto mode according to autoLevelCapping
     * @type {number}
     */

  }, {
    key: 'maxAutoLevel',
    get: function get() {
      var hls = this;
      var levels = hls.levels;
      var autoLevelCapping = hls.autoLevelCapping;
      var maxAutoLevel = void 0;
      if (autoLevelCapping === -1 && levels && levels.length) {
        maxAutoLevel = levels.length - 1;
      } else {
        maxAutoLevel = autoLevelCapping;
      }

      return maxAutoLevel;
    }

    /**
     * next automatically selected quality level
     * @type {number}
     */

  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var hls = this;
      // ensure next auto level is between  min and max auto level
      return Math.min(Math.max(hls.abrController.nextAutoLevel, hls.minAutoLevel), hls.maxAutoLevel);
    }

    /**
     * this setter is used to force next auto level.
     * this is useful to force a switch down in auto mode:
     * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
     * forced value is valid for one fragment. upon succesful frag loading at forced level,
     * this value will be resetted to -1 by ABR controller.
     * @type {number}
     */
    ,
    set: function set(nextLevel) {
      var hls = this;
      hls.abrController.nextAutoLevel = Math.max(hls.minAutoLevel, nextLevel);
    }

    /**
     * @type {AudioTrack[]}
     */

  }, {
    key: 'audioTracks',
    get: function get() {
      var audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTracks : [];
    }

    /**
     * index of the selected audio track (index in audio track lists)
     * @type {number}
     */

  }, {
    key: 'audioTrack',
    get: function get() {
      var audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTrack : -1;
    }

    /**
     * selects an audio track, based on its index in audio track lists
     * @type {number}
     */
    ,
    set: function set(audioTrackId) {
      var audioTrackController = this.audioTrackController;
      if (audioTrackController) {
        audioTrackController.audioTrack = audioTrackId;
      }
    }

    /**
     * @type {Seconds}
     */

  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this.streamController.liveSyncPosition;
    }

    /**
     * get alternate subtitle tracks list from playlist
     * @type {SubtitleTrack[]}
     */

  }, {
    key: 'subtitleTracks',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
    }

    /**
     * index of the selected subtitle track (index in subtitle track lists)
     * @type {number}
     */

  }, {
    key: 'subtitleTrack',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
    }

    /**
     * select an subtitle track, based on its index in subtitle track lists
     * @type{number}
     */
    ,
    set: function set(subtitleTrackId) {
      var subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleTrack = subtitleTrackId;
      }
    }

    /**
     * @type {boolean}
     */

  }, {
    key: 'subtitleDisplay',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
    }

    /**
     * Enable/disable subtitle display rendering
     * @type {boolean}
     */
    ,
    set: function set(value) {
      var subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleDisplay = value;
      }
    }
  }]);

  return Hls;
}(_observer.Observer);

exports.default = Hls;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/is-supported.js":
/*!************************************!*\
  !*** ./src/hls.js/is-supported.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSupported = isSupported;

var _mediasourceHelper = __webpack_require__(/*! ./utils/mediasource-helper */ "./src/hls.js/utils/mediasource-helper.js");

function isSupported() {
  var mediaSource = (0, _mediasourceHelper.getMediaSource)();
  var sourceBuffer = window.SourceBuffer || window.WebKitSourceBuffer;
  var isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === 'function' && mediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');

  // if SourceBuffer is exposed ensure its API is valid
  // safari and old version of Chrome doe not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible
  var sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';
  return !!isTypeSupported && !!sourceBufferValidAPI;
}

/***/ }),

/***/ "./src/hls.js/loader/fragment-loader.js":
/*!**********************************************!*\
  !*** ./src/hls.js/loader/fragment-loader.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Fragment Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var FragmentLoader = function (_EventHandler) {
  _inherits(FragmentLoader, _EventHandler);

  function FragmentLoader(hls) {
    _classCallCheck(this, FragmentLoader);

    var _this = _possibleConstructorReturn(this, (FragmentLoader.__proto__ || Object.getPrototypeOf(FragmentLoader)).call(this, hls, _events2.default.FRAG_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(FragmentLoader, [{
    key: 'destroy',
    value: function destroy() {
      var loaders = this.loaders;
      for (var loaderName in loaders) {
        var loader = loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};

      _get(FragmentLoader.prototype.__proto__ || Object.getPrototypeOf(FragmentLoader.prototype), 'destroy', this).call(this);
    }
  }, {
    key: 'onFragLoading',
    value: function onFragLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loaders = this.loaders,
          config = this.hls.config,
          FragmentILoader = config.fLoader,
          DefaultILoader = config.loader;

      // reset fragment state
      frag.loaded = 0;

      var loader = loaders[type];
      if (loader) {
        _logger.logger.warn('abort previous fragment loader for type: ' + type);
        loader.abort();
      }

      loader = loaders[type] = frag.loader = config.fLoader ? new FragmentILoader(config) : new DefaultILoader(config);

      var loaderContext = void 0,
          loaderConfig = void 0,
          loaderCallbacks = void 0;

      loaderContext = { url: frag.url, frag: frag, responseType: 'arraybuffer', progressData: false };

      var start = frag.byteRangeStartOffset,
          end = frag.byteRangeEndOffset;

      if (Number.isFinite(start) && Number.isFinite(end)) {
        loaderContext.rangeStart = start;
        loaderContext.rangeEnd = end;
      }

      loaderConfig = {
        timeout: config.fragLoadingTimeOut,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: config.fragLoadingMaxRetryTimeout
      };

      loaderCallbacks = {
        onSuccess: this.loadsuccess.bind(this),
        onError: this.loaderror.bind(this),
        onTimeout: this.loadtimeout.bind(this),
        onProgress: this.loadprogress.bind(this)
      };

      loader.load(loaderContext, loaderConfig, loaderCallbacks);
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var payload = response.data,
          frag = context.frag;
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.FRAG_LOADED, { payload: payload, frag: frag, stats: stats, networkDetails: networkDetails });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var frag = context.frag;
      var loader = frag.loader;
      if (loader) {
        loader.abort();
      }

      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: context.frag, response: response, networkDetails: networkDetails });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var frag = context.frag;
      var loader = frag.loader;
      if (loader) {
        loader.abort();
      }

      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: context.frag, networkDetails: networkDetails });
    }

    // data will be used for progressive parsing

  }, {
    key: 'loadprogress',
    value: function loadprogress(stats, context, data) {
      var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      // jshint ignore:line
      var frag = context.frag;
      frag.loaded = stats.loaded;
      this.hls.trigger(_events2.default.FRAG_LOAD_PROGRESS, { frag: frag, stats: stats, networkDetails: networkDetails });
    }
  }]);

  return FragmentLoader;
}(_eventHandler2.default);

exports.default = FragmentLoader;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/fragment.js":
/*!***************************************!*\
  !*** ./src/hls.js/loader/fragment.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "../../node_modules/url-toolkit/src/url-toolkit.js");

var URLToolkit = _interopRequireWildcard(_urlToolkit);

var _levelKey = __webpack_require__(/*! ./level-key */ "./src/hls.js/loader/level-key.js");

var _levelKey2 = _interopRequireDefault(_levelKey);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Fragment = function () {
  function Fragment() {
    var _elementaryStreams;

    _classCallCheck(this, Fragment);

    this._url = null;
    this._byteRange = null;
    this._decryptdata = null;
    this.tagList = [];
    this.programDateTime = null;
    this.rawProgramDateTime = null;

    // Holds the types of data this fragment supports
    this._elementaryStreams = (_elementaryStreams = {}, _defineProperty(_elementaryStreams, Fragment.ElementaryStreamTypes.AUDIO, false), _defineProperty(_elementaryStreams, Fragment.ElementaryStreamTypes.VIDEO, false), _elementaryStreams);
  }

  /**
   * `type` property for this._elementaryStreams
   *
   * @enum
   */


  _createClass(Fragment, [{
    key: 'addElementaryStream',


    /**
     * @param {ElementaryStreamType} type
     */
    value: function addElementaryStream(type) {
      this._elementaryStreams[type] = true;
    }

    /**
     * @param {ElementaryStreamType} type
     */

  }, {
    key: 'hasElementaryStream',
    value: function hasElementaryStream(type) {
      return this._elementaryStreams[type] === true;
    }

    /**
     * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
     * @returns {Uint8Array}
     */

  }, {
    key: 'createInitializationVector',
    value: function createInitializationVector(segmentNumber) {
      var uint8View = new Uint8Array(16);

      for (var i = 12; i < 16; i++) {
        uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
      }

      return uint8View;
    }

    /**
     * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
     * @param levelkey - a playlist's encryption info
     * @param segmentNumber - the fragment's segment number
     * @returns {*} - an object to be applied as a fragment's decryptdata
     */

  }, {
    key: 'fragmentDecryptdataFromLevelkey',
    value: function fragmentDecryptdataFromLevelkey(levelkey, segmentNumber) {
      var decryptdata = levelkey;

      if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {
        decryptdata = new _levelKey2.default();
        decryptdata.method = levelkey.method;
        decryptdata.baseuri = levelkey.baseuri;
        decryptdata.reluri = levelkey.reluri;
        decryptdata.iv = this.createInitializationVector(segmentNumber);
      }

      return decryptdata;
    }
  }, {
    key: 'url',
    get: function get() {
      if (!this._url && this.relurl) {
        this._url = URLToolkit.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: true });
      }

      return this._url;
    },
    set: function set(value) {
      this._url = value;
    }
  }, {
    key: 'byteRange',
    get: function get() {
      if (!this._byteRange && !this.rawByteRange) {
        return [];
      }

      if (this._byteRange) {
        return this._byteRange;
      }

      var byteRange = [];
      if (this.rawByteRange) {
        var params = this.rawByteRange.split('@', 2);
        if (params.length === 1) {
          var lastByteRangeEndOffset = this.lastByteRangeEndOffset;
          byteRange[0] = lastByteRangeEndOffset || 0;
        } else {
          byteRange[0] = parseInt(params[1]);
        }
        byteRange[1] = parseInt(params[0]) + byteRange[0];
        this._byteRange = byteRange;
      }
      return byteRange;
    }

    /**
     * @type {number}
     */

  }, {
    key: 'byteRangeStartOffset',
    get: function get() {
      return this.byteRange[0];
    }
  }, {
    key: 'byteRangeEndOffset',
    get: function get() {
      return this.byteRange[1];
    }
  }, {
    key: 'decryptdata',
    get: function get() {
      if (!this._decryptdata) {
        this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn);
      }

      return this._decryptdata;
    }
  }, {
    key: 'endProgramDateTime',
    get: function get() {
      if (!Number.isFinite(this.programDateTime)) {
        return null;
      }

      var duration = !Number.isFinite(this.duration) ? 0 : this.duration;

      return this.programDateTime + duration * 1000;
    }
  }, {
    key: 'encrypted',
    get: function get() {
      return !!(this.decryptdata && this.decryptdata.uri !== null && this.decryptdata.key === null);
    }
  }], [{
    key: 'ElementaryStreamTypes',
    get: function get() {
      return {
        AUDIO: 'audio',
        VIDEO: 'video'
      };
    }
  }]);

  return Fragment;
}();

exports.default = Fragment;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/key-loader.js":
/*!*****************************************!*\
  !*** ./src/hls.js/loader/key-loader.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Decrypt key Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

var KeyLoader = function (_EventHandler) {
  _inherits(KeyLoader, _EventHandler);

  function KeyLoader(hls) {
    _classCallCheck(this, KeyLoader);

    var _this = _possibleConstructorReturn(this, (KeyLoader.__proto__ || Object.getPrototypeOf(KeyLoader)).call(this, hls, _events2.default.KEY_LOADING));

    _this.loaders = {};
    _this.decryptkey = null;
    _this.decrypturl = null;
    return _this;
  }

  _createClass(KeyLoader, [{
    key: 'destroy',
    value: function destroy() {
      for (var loaderName in this.loaders) {
        var loader = this.loaders[loaderName];
        if (loader) {
          loader.destroy();
        }
      }
      this.loaders = {};
      _eventHandler2.default.prototype.destroy.call(this);
    }
  }, {
    key: 'onKeyLoading',
    value: function onKeyLoading(data) {
      var frag = data.frag,
          type = frag.type,
          loader = this.loaders[type],
          decryptdata = frag.decryptdata,
          uri = decryptdata.uri;
      // if uri is different from previous one or if decrypt key not retrieved yet
      if (uri !== this.decrypturl || this.decryptkey === null) {
        var config = this.hls.config;

        if (loader) {
          _logger.logger.warn('abort previous key loader for type:' + type);
          loader.abort();
        }
        frag.loader = this.loaders[type] = new config.loader(config);
        this.decrypturl = uri;
        this.decryptkey = null;

        var loaderContext = void 0,
            loaderConfig = void 0,
            loaderCallbacks = void 0;
        loaderContext = { url: uri, frag: frag, responseType: 'arraybuffer' };
        // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,
        // key-loader will trigger an error and rely on stream-controller to handle retry logic.
        // this will also align retry logic with fragment-loader
        loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
        loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
        frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);
      } else if (this.decryptkey) {
        // we already loaded this key, return it
        decryptdata.key = this.decryptkey;
        this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
      }
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var frag = context.frag;
      this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);
      // detach fragment loader on load success
      frag.loader = undefined;
      this.loaders[frag.type] = undefined;
      this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }

      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_ERROR, fatal: false, frag: frag, response: response });
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var frag = context.frag,
          loader = frag.loader;
      if (loader) {
        loader.abort();
      }

      this.loaders[context.type] = undefined;
      this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: false, frag: frag });
    }
  }]);

  return KeyLoader;
}(_eventHandler2.default);

exports.default = KeyLoader;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/level-key.js":
/*!****************************************!*\
  !*** ./src/hls.js/loader/level-key.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "../../node_modules/url-toolkit/src/url-toolkit.js");

var URLToolkit = _interopRequireWildcard(_urlToolkit);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LevelKey = function () {
  function LevelKey() {
    _classCallCheck(this, LevelKey);

    this.method = null;
    this.key = null;
    this.iv = null;
    this._uri = null;
  }

  _createClass(LevelKey, [{
    key: 'uri',
    get: function get() {
      if (!this._uri && this.reluri) {
        this._uri = URLToolkit.buildAbsoluteURL(this.baseuri, this.reluri, { alwaysNormalize: true });
      }

      return this._uri;
    }
  }]);

  return LevelKey;
}();

exports.default = LevelKey;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/level.js":
/*!************************************!*\
  !*** ./src/hls.js/loader/level.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Level = function () {
  function Level(baseUrl) {
    _classCallCheck(this, Level);

    // Please keep properties in alphabetical order
    this.endCC = 0;
    this.endSN = 0;
    this.fragments = [];
    this.initSegment = null;
    this.live = true;
    this.needSidxRanges = false;
    this.startCC = 0;
    this.startSN = 0;
    this.startTimeOffset = null;
    this.targetduration = 0;
    this.totalduration = 0;
    this.type = null;
    this.url = baseUrl;
    this.version = null;
  }

  _createClass(Level, [{
    key: "hasProgramDateTime",
    get: function get() {
      return !!(this.fragments[0] && Number.isFinite(this.fragments[0].programDateTime));
    }
  }]);

  return Level;
}();

exports.default = Level;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/loader/m3u8-parser.js":
/*!******************************************!*\
  !*** ./src/hls.js/loader/m3u8-parser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _urlToolkit = __webpack_require__(/*! url-toolkit */ "../../node_modules/url-toolkit/src/url-toolkit.js");

var URLToolkit = _interopRequireWildcard(_urlToolkit);

var _fragment = __webpack_require__(/*! ./fragment */ "./src/hls.js/loader/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _level = __webpack_require__(/*! ./level */ "./src/hls.js/loader/level.js");

var _level2 = _interopRequireDefault(_level);

var _levelKey = __webpack_require__(/*! ./level-key */ "./src/hls.js/loader/level-key.js");

var _levelKey2 = _interopRequireDefault(_levelKey);

var _attrList = __webpack_require__(/*! ../utils/attr-list */ "./src/hls.js/utils/attr-list.js");

var _attrList2 = _interopRequireDefault(_attrList);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _codecs = __webpack_require__(/*! ../utils/codecs */ "./src/hls.js/utils/codecs.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * M3U8 parser
 * @module
 */

// https://regex101.com is your friend
var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;
var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;

var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
/|(?!#)([\S+ ?]+)/.source, // segment URI, group 3 => the URI (note newline is not eaten)
/|#EXT-X-BYTERANGE:*(.+)/.source, // next segment's byterange, group 4 => range spec (x@y)
/|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, // next segment's program date/time group 5 => the datetime spec
/|#.*/.source // All other non-segment oriented tags will match with all groups empty
].join(''), 'g');

var LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)([^:]*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/;

var MP4_REGEX_SUFFIX = /\.(mp4|m4s|m4v|m4a)$/i;

var M3U8Parser = function () {
  function M3U8Parser() {
    _classCallCheck(this, M3U8Parser);
  }

  _createClass(M3U8Parser, null, [{
    key: 'findGroup',
    value: function findGroup(groups, mediaGroupId) {
      if (!groups) {
        return null;
      }

      var matchingGroup = null;

      for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        if (group.id === mediaGroupId) {
          matchingGroup = group;
        }
      }

      return matchingGroup;
    }
  }, {
    key: 'convertAVC1ToAVCOTI',
    value: function convertAVC1ToAVCOTI(codec) {
      var result = void 0,
          avcdata = codec.split('.');
      if (avcdata.length > 2) {
        result = avcdata.shift() + '.';
        result += parseInt(avcdata.shift()).toString(16);
        result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);
      } else {
        result = codec;
      }
      return result;
    }
  }, {
    key: 'resolve',
    value: function resolve(url, baseUrl) {
      return URLToolkit.buildAbsoluteURL(baseUrl, url, { alwaysNormalize: true });
    }
  }, {
    key: 'parseMasterPlaylist',
    value: function parseMasterPlaylist(string, baseurl) {
      var levels = [],
          result = void 0;
      MASTER_PLAYLIST_REGEX.lastIndex = 0;

      function setCodecs(codecs, level) {
        ['video', 'audio'].forEach(function (type) {
          var filtered = codecs.filter(function (codec) {
            return (0, _codecs.isCodecType)(codec, type);
          });
          if (filtered.length) {
            var preferred = filtered.filter(function (codec) {
              return codec.lastIndexOf('avc1', 0) === 0 || codec.lastIndexOf('mp4a', 0) === 0;
            });
            level[type + 'Codec'] = preferred.length > 0 ? preferred[0] : filtered[0];

            // remove from list
            codecs = codecs.filter(function (codec) {
              return filtered.indexOf(codec) === -1;
            });
          }
        });

        level.unknownCodecs = codecs;
      }

      while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
        var level = {};

        var attrs = level.attrs = new _attrList2.default(result[1]);
        level.url = M3U8Parser.resolve(result[2], baseurl);

        var resolution = attrs.decimalResolution('RESOLUTION');
        if (resolution) {
          level.width = resolution.width;
          level.height = resolution.height;
        }
        level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');
        level.name = attrs.NAME;

        setCodecs([].concat((attrs.CODECS || '').split(/[ ,]+/)), level);

        if (level.videoCodec && level.videoCodec.indexOf('avc1') !== -1) {
          level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);
        }

        levels.push(level);
      }
      return levels;
    }
  }, {
    key: 'parseMasterPlaylistMedia',
    value: function parseMasterPlaylistMedia(string, baseurl, type) {
      var audioGroups = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

      var result = void 0;
      var medias = [];
      var id = 0;
      MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
      while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
        var media = {};
        var attrs = new _attrList2.default(result[1]);
        if (attrs.TYPE === type) {
          media.groupId = attrs['GROUP-ID'];
          media.name = attrs.NAME;
          media.type = type;
          media.default = attrs.DEFAULT === 'YES';
          media.autoselect = attrs.AUTOSELECT === 'YES';
          media.forced = attrs.FORCED === 'YES';
          if (attrs.URI) {
            media.url = M3U8Parser.resolve(attrs.URI, baseurl);
          }

          media.lang = attrs.LANGUAGE;
          if (!media.name) {
            media.name = media.lang;
          }

          if (audioGroups.length) {
            var groupCodec = M3U8Parser.findGroup(audioGroups, media.groupId);
            media.audioCodec = groupCodec ? groupCodec.codec : audioGroups[0].codec;
          }
          media.id = id++;
          medias.push(media);
        }
      }
      return medias;
    }
  }, {
    key: 'parseLevelPlaylist',
    value: function parseLevelPlaylist(string, baseurl, id, type, levelUrlId) {
      var currentSN = 0;
      var totalduration = 0;
      var level = new _level2.default(baseurl);
      var levelkey = new _levelKey2.default();
      var cc = 0;
      var prevFrag = null;
      var frag = new _fragment2.default();
      var result = void 0;
      var i = void 0;

      var firstPdtIndex = null;

      LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;

      while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
        var duration = result[1];
        if (duration) {
          // INF
          frag.duration = parseFloat(duration);
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          var title = (' ' + result[2]).slice(1);
          frag.title = title || null;
          frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);
        } else if (result[3]) {
          // url
          if (Number.isFinite(frag.duration)) {
            var sn = currentSN++;
            frag.type = type;
            frag.start = totalduration;
            frag.levelkey = levelkey;
            frag.sn = sn;
            frag.level = id;
            frag.cc = cc;
            frag.urlId = levelUrlId;
            frag.baseurl = baseurl;
            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
            frag.relurl = (' ' + result[3]).slice(1);
            assignProgramDateTime(frag, prevFrag);

            level.fragments.push(frag);
            prevFrag = frag;
            totalduration += frag.duration;

            frag = new _fragment2.default();
          }
        } else if (result[4]) {
          // X-BYTERANGE
          frag.rawByteRange = (' ' + result[4]).slice(1);
          if (prevFrag) {
            var lastByteRangeEndOffset = prevFrag.byteRangeEndOffset;
            if (lastByteRangeEndOffset) {
              frag.lastByteRangeEndOffset = lastByteRangeEndOffset;
            }
          }
        } else if (result[5]) {
          // PROGRAM-DATE-TIME
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          frag.rawProgramDateTime = (' ' + result[5]).slice(1);
          frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);
          if (firstPdtIndex === null) {
            firstPdtIndex = level.fragments.length;
          }
        } else {
          result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
          for (i = 1; i < result.length; i++) {
            if (result[i] !== undefined) {
              break;
            }
          }

          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          var value1 = (' ' + result[i + 1]).slice(1);
          var value2 = (' ' + result[i + 2]).slice(1);

          switch (result[i]) {
            case '#':
              frag.tagList.push(value2 ? [value1, value2] : [value1]);
              break;
            case 'PLAYLIST-TYPE':
              level.type = value1.toUpperCase();
              break;
            case 'MEDIA-SEQUENCE':
              currentSN = level.startSN = parseInt(value1);
              break;
            case 'TARGETDURATION':
              level.targetduration = parseFloat(value1);
              break;
            case 'VERSION':
              level.version = parseInt(value1);
              break;
            case 'EXTM3U':
              break;
            case 'ENDLIST':
              level.live = false;
              break;
            case 'DIS':
              cc++;
              frag.tagList.push(['DIS']);
              break;
            case 'DISCONTINUITY-SEQ':
              cc = parseInt(value1);
              break;
            case 'KEY':
              // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
              var decryptparams = value1;
              var keyAttrs = new _attrList2.default(decryptparams);
              var decryptmethod = keyAttrs.enumeratedString('METHOD'),
                  decrypturi = keyAttrs.URI,
                  decryptiv = keyAttrs.hexadecimalInteger('IV');
              if (decryptmethod) {
                levelkey = new _levelKey2.default();
                if (decrypturi && ['AES-128', 'SAMPLE-AES', 'SAMPLE-AES-CENC'].indexOf(decryptmethod) >= 0) {
                  levelkey.method = decryptmethod;
                  // URI to get the key
                  levelkey.baseuri = baseurl;
                  levelkey.reluri = decrypturi;
                  levelkey.key = null;
                  // Initialization Vector (IV)
                  levelkey.iv = decryptiv;
                }
              }
              break;
            case 'START':
              var startParams = value1;
              var startAttrs = new _attrList2.default(startParams);
              var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
              // TIME-OFFSET can be 0
              if (Number.isFinite(startTimeOffset)) {
                level.startTimeOffset = startTimeOffset;
              }

              break;
            case 'MAP':
              var mapAttrs = new _attrList2.default(value1);
              frag.relurl = mapAttrs.URI;
              frag.rawByteRange = mapAttrs.BYTERANGE;
              frag.baseurl = baseurl;
              frag.level = id;
              frag.type = type;
              frag.sn = 'initSegment';
              level.initSegment = frag;
              frag = new _fragment2.default();
              frag.rawProgramDateTime = level.initSegment.rawProgramDateTime;
              break;
            default:
              _logger.logger.warn('line parsed but not handled: ' + result);
              break;
          }
        }
      }
      frag = prevFrag;
      // logger.log('found ' + level.fragments.length + ' fragments');
      if (frag && !frag.relurl) {
        level.fragments.pop();
        totalduration -= frag.duration;
      }
      level.totalduration = totalduration;
      level.averagetargetduration = totalduration / level.fragments.length;
      level.endSN = currentSN - 1;
      level.startCC = level.fragments[0] ? level.fragments[0].cc : 0;
      level.endCC = cc;

      if (!level.initSegment && level.fragments.length) {
        // this is a bit lurky but HLS really has no other way to tell us
        // if the fragments are TS or MP4, except if we download them :/
        // but this is to be able to handle SIDX.
        if (level.fragments.every(function (frag) {
          return MP4_REGEX_SUFFIX.test(frag.relurl);
        })) {
          _logger.logger.warn('MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX');

          frag = new _fragment2.default();
          frag.relurl = level.fragments[0].relurl;
          frag.baseurl = baseurl;
          frag.level = id;
          frag.type = type;
          frag.sn = 'initSegment';

          level.initSegment = frag;
          level.needSidxRanges = true;
        }
      }

      /**
       * Backfill any missing PDT values
         "If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after
         one or more Media Segment URIs, the client SHOULD extrapolate
         backward from that tag (using EXTINF durations and/or media
         timestamps) to associate dates with those segments."
       * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs
       * computed.
       */
      if (firstPdtIndex) {
        backfillProgramDateTimes(level.fragments, firstPdtIndex);
      }

      return level;
    }
  }]);

  return M3U8Parser;
}();

exports.default = M3U8Parser;


function backfillProgramDateTimes(fragments, startIndex) {
  var fragPrev = fragments[startIndex];
  for (var i = startIndex - 1; i >= 0; i--) {
    var frag = fragments[i];
    frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;
    fragPrev = frag;
  }
}

function assignProgramDateTime(frag, prevFrag) {
  if (frag.rawProgramDateTime) {
    frag.programDateTime = Date.parse(frag.rawProgramDateTime);
  } else if (prevFrag && prevFrag.programDateTime) {
    frag.programDateTime = prevFrag.endProgramDateTime;
  }

  if (!Number.isFinite(frag.programDateTime)) {
    frag.programDateTime = null;
    frag.rawProgramDateTime = null;
  }
}
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/loader/playlist-loader.js":
/*!**********************************************!*\
  !*** ./src/hls.js/loader/playlist-loader.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _eventHandler = __webpack_require__(/*! ../event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

var _mp4demuxer = __webpack_require__(/*! ../demux/mp4demuxer */ "./src/hls.js/demux/mp4demuxer.js");

var _mp4demuxer2 = _interopRequireDefault(_mp4demuxer);

var _m3u8Parser = __webpack_require__(/*! ./m3u8-parser */ "./src/hls.js/loader/m3u8-parser.js");

var _m3u8Parser2 = _interopRequireDefault(_m3u8Parser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * PlaylistLoader - delegate for media manifest/playlist loading tasks. Takes care of parsing media to internal data-models.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Once loaded, dispatches events with parsed data-models of manifest/levels/audio/subtitle tracks.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Uses loader(s) set in config to do actual internal loading of resource tasks.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var _window = window,
    performance = _window.performance;

/**
 * `type` property values for this loaders' context object
 * @enum
 *
 */

var ContextType = {
  MANIFEST: 'manifest',
  LEVEL: 'level',
  AUDIO_TRACK: 'audioTrack',
  SUBTITLE_TRACK: 'subtitleTrack'
};

/**
 * @enum {string}
 */
var LevelType = {
  MAIN: 'main',
  AUDIO: 'audio',
  SUBTITLE: 'subtitle'
};

/**
 * @constructor
 */

var PlaylistLoader = function (_EventHandler) {
  _inherits(PlaylistLoader, _EventHandler);

  /**
   * @constructs
   * @param {Hls} hls
   */
  function PlaylistLoader(hls) {
    _classCallCheck(this, PlaylistLoader);

    var _this = _possibleConstructorReturn(this, (PlaylistLoader.__proto__ || Object.getPrototypeOf(PlaylistLoader)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.LEVEL_LOADING, _events2.default.AUDIO_TRACK_LOADING, _events2.default.SUBTITLE_TRACK_LOADING));

    _this.loaders = {};
    return _this;
  }

  _createClass(PlaylistLoader, [{
    key: 'createInternalLoader',


    /**
     * Returns defaults or configured loader-type overloads (pLoader and loader config params)
     * Default loader is XHRLoader (see utils)
     * @param {object} context
     * @returns {XHRLoader} or other compatible configured overload
     */
    value: function createInternalLoader(context) {
      var config = this.hls.config;
      var PLoader = config.pLoader;
      var Loader = config.loader;
      var InternalLoader = PLoader || Loader;

      var loader = new InternalLoader(config);

      context.loader = loader;
      this.loaders[context.type] = loader;

      return loader;
    }
  }, {
    key: 'getInternalLoader',
    value: function getInternalLoader(context) {
      return this.loaders[context.type];
    }
  }, {
    key: 'resetInternalLoader',
    value: function resetInternalLoader(contextType) {
      if (this.loaders[contextType]) {
        delete this.loaders[contextType];
      }
    }

    /**
     * Call `destroy` on all internal loader instances mapped (one per context type)
     */

  }, {
    key: 'destroyInternalLoaders',
    value: function destroyInternalLoaders() {
      for (var contextType in this.loaders) {
        var loader = this.loaders[contextType];
        if (loader) {
          loader.destroy();
        }

        this.resetInternalLoader(contextType);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.destroyInternalLoaders();

      _get(PlaylistLoader.prototype.__proto__ || Object.getPrototypeOf(PlaylistLoader.prototype), 'destroy', this).call(this);
    }
  }, {
    key: 'onManifestLoading',
    value: function onManifestLoading(data) {
      this.load(data.url, { type: ContextType.MANIFEST, level: 0, id: null });
    }
  }, {
    key: 'onLevelLoading',
    value: function onLevelLoading(data) {
      this.load(data.url, { type: ContextType.LEVEL, level: data.level, id: data.id });
    }
  }, {
    key: 'onAudioTrackLoading',
    value: function onAudioTrackLoading(data) {
      this.load(data.url, { type: ContextType.AUDIO_TRACK, level: null, id: data.id });
    }
  }, {
    key: 'onSubtitleTrackLoading',
    value: function onSubtitleTrackLoading(data) {
      this.load(data.url, { type: ContextType.SUBTITLE_TRACK, level: null, id: data.id });
    }
  }, {
    key: 'load',
    value: function load(url, context) {
      var config = this.hls.config;

      _logger.logger.debug('Loading playlist of type ' + context.type + ', level: ' + context.level + ', id: ' + context.id);

      // Check if a loader for this context already exists
      var loader = this.getInternalLoader(context);
      if (loader) {
        var loaderContext = loader.context;
        if (loaderContext && loaderContext.url === url) {
          // same URL can't overlap
          _logger.logger.trace('playlist request ongoing');
          return false;
        } else {
          _logger.logger.warn('aborting previous loader for type: ' + context.type);
          loader.abort();
        }
      }

      var maxRetry = void 0,
          timeout = void 0,
          retryDelay = void 0,
          maxRetryDelay = void 0;

      // apply different configs for retries depending on
      // context (manifest, level, audio/subs playlist)
      switch (context.type) {
        case ContextType.MANIFEST:
          maxRetry = config.manifestLoadingMaxRetry;
          timeout = config.manifestLoadingTimeOut;
          retryDelay = config.manifestLoadingRetryDelay;
          maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
          break;
        case ContextType.LEVEL:
          // Disable internal loader retry logic, since we are managing retries in Level Controller
          maxRetry = 0;
          timeout = config.levelLoadingTimeOut;
          // TODO Introduce retry settings for audio-track and subtitle-track, it should not use level retry config
          break;
        default:
          maxRetry = config.levelLoadingMaxRetry;
          timeout = config.levelLoadingTimeOut;
          retryDelay = config.levelLoadingRetryDelay;
          maxRetryDelay = config.levelLoadingMaxRetryTimeout;
          break;
      }

      loader = this.createInternalLoader(context);

      context.url = url;
      context.responseType = context.responseType || ''; // FIXME: (should not be necessary to do this)

      var loaderConfig = {
        timeout: timeout,
        maxRetry: maxRetry,
        retryDelay: retryDelay,
        maxRetryDelay: maxRetryDelay
      };

      var loaderCallbacks = {
        onSuccess: this.loadsuccess.bind(this),
        onError: this.loaderror.bind(this),
        onTimeout: this.loadtimeout.bind(this)
      };

      _logger.logger.debug('Calling internal loader delegate for URL: ' + url);

      loader.load(context, loaderConfig, loaderCallbacks);

      return true;
    }
  }, {
    key: 'loadsuccess',
    value: function loadsuccess(response, stats, context) {
      var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      if (context.isSidxRequest) {
        this._handleSidxRequest(response, context);
        this._handlePlaylistLoaded(response, stats, context, networkDetails);
        return;
      }

      this.resetInternalLoader(context.type);

      var string = response.data;

      stats.tload = performance.now();
      // stats.mtime = new Date(target.getResponseHeader('Last-Modified'));

      // Validate if it is an M3U8 at all
      if (string.indexOf('#EXTM3U') !== 0) {
        this._handleManifestParsingError(response, context, 'no EXTM3U delimiter', networkDetails);
        return;
      }

      // Check if chunk-list or master. handle empty chunk list case (first EXTINF not signaled, but TARGETDURATION present)
      if (string.indexOf('#EXTINF:') > 0 || string.indexOf('#EXT-X-TARGETDURATION:') > 0) {
        this._handleTrackOrLevelPlaylist(response, stats, context, networkDetails);
      } else {
        this._handleMasterPlaylist(response, stats, context, networkDetails);
      }
    }
  }, {
    key: 'loaderror',
    value: function loaderror(response, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      this._handleNetworkError(context, networkDetails, false, response);
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout(stats, context) {
      var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      this._handleNetworkError(context, networkDetails, true);
    }
  }, {
    key: '_handleMasterPlaylist',
    value: function _handleMasterPlaylist(response, stats, context, networkDetails) {
      var hls = this.hls;
      var string = response.data;

      var url = PlaylistLoader.getResponseUrl(response, context);

      var levels = _m3u8Parser2.default.parseMasterPlaylist(string, url);
      if (!levels.length) {
        this._handleManifestParsingError(response, context, 'no level found in manifest', networkDetails);
        return;
      }

      // multi level playlist, parse level info

      var audioGroups = levels.map(function (level) {
        return {
          id: level.attrs.AUDIO,
          codec: level.audioCodec
        };
      });

      var audioTracks = _m3u8Parser2.default.parseMasterPlaylistMedia(string, url, 'AUDIO', audioGroups);
      var subtitles = _m3u8Parser2.default.parseMasterPlaylistMedia(string, url, 'SUBTITLES');

      if (audioTracks.length) {
        // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
        var embeddedAudioFound = false;
        audioTracks.forEach(function (audioTrack) {
          if (!audioTrack.url) {
            embeddedAudioFound = true;
          }
        });

        // if no embedded audio track defined, but audio codec signaled in quality level,
        // we need to signal this main audio track this could happen with playlists with
        // alt audio rendition in which quality levels (main)
        // contains both audio+video. but with mixed audio track not signaled
        if (embeddedAudioFound === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
          _logger.logger.log('audio codec signaled in quality level, but no embedded audio track signaled, create one');
          audioTracks.unshift({
            type: 'main',
            name: 'main'
          });
        }
      }

      hls.trigger(_events2.default.MANIFEST_LOADED, {
        levels: levels,
        audioTracks: audioTracks,
        subtitles: subtitles,
        url: url,
        stats: stats,
        networkDetails: networkDetails
      });
    }
  }, {
    key: '_handleTrackOrLevelPlaylist',
    value: function _handleTrackOrLevelPlaylist(response, stats, context, networkDetails) {
      var hls = this.hls;

      var id = context.id,
          level = context.level,
          type = context.type;


      var url = PlaylistLoader.getResponseUrl(response, context);

      var levelUrlId = Number.isFinite(id) ? id : 0;
      var levelId = Number.isFinite(level) ? level : levelUrlId;
      var levelType = PlaylistLoader.mapContextToLevelType(context);

      var levelDetails = _m3u8Parser2.default.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId);

      // set stats on level structure
      levelDetails.tload = stats.tload;

      // We have done our first request (Manifest-type) and receive
      // not a master playlist but a chunk-list (track/level)
      // We fire the manifest-loaded event anyway with the parsed level-details
      // by creating a single-level structure for it.
      if (type === ContextType.MANIFEST) {
        var singleLevel = {
          url: url,
          details: levelDetails
        };

        hls.trigger(_events2.default.MANIFEST_LOADED, {
          levels: [singleLevel],
          audioTracks: [],
          url: url,
          stats: stats,
          networkDetails: networkDetails
        });
      }

      // save parsing time
      stats.tparsed = performance.now();

      // in case we need SIDX ranges
      // return early after calling load for
      // the SIDX box.
      if (levelDetails.needSidxRanges) {
        var sidxUrl = levelDetails.initSegment.url;
        this.load(sidxUrl, {
          isSidxRequest: true,
          type: type,
          level: level,
          levelDetails: levelDetails,
          id: id,
          rangeStart: 0,
          rangeEnd: 2048,
          responseType: 'arraybuffer'
        });
        return;
      }

      // extend the context with the new levelDetails property
      context.levelDetails = levelDetails;

      this._handlePlaylistLoaded(response, stats, context, networkDetails);
    }
  }, {
    key: '_handleSidxRequest',
    value: function _handleSidxRequest(response, context) {
      var sidxInfo = _mp4demuxer2.default.parseSegmentIndex(new Uint8Array(response.data));
      // if provided fragment does not contain sidx, early return
      if (!sidxInfo) {
        return;
      }
      var sidxReferences = sidxInfo.references;
      var levelDetails = context.levelDetails;
      sidxReferences.forEach(function (segmentRef, index) {
        var segRefInfo = segmentRef.info;
        var frag = levelDetails.fragments[index];

        if (frag.byteRange.length === 0) {
          frag.rawByteRange = String(1 + segRefInfo.end - segRefInfo.start) + '@' + String(segRefInfo.start);
        }
      });
      levelDetails.initSegment.rawByteRange = String(sidxInfo.moovEndOffset) + '@0';
    }
  }, {
    key: '_handleManifestParsingError',
    value: function _handleManifestParsingError(response, context, reason, networkDetails) {
      this.hls.trigger(_events2.default.ERROR, {
        type: _errors.ErrorTypes.NETWORK_ERROR,
        details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR,
        fatal: true,
        url: response.url,
        reason: reason,
        networkDetails: networkDetails
      });
    }
  }, {
    key: '_handleNetworkError',
    value: function _handleNetworkError(context, networkDetails) {
      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var response = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      _logger.logger.info('A network error occured while loading a ' + context.type + '-type playlist');

      var details = void 0;
      var fatal = void 0;

      var loader = this.getInternalLoader(context);

      switch (context.type) {
        case ContextType.MANIFEST:
          details = timeout ? _errors.ErrorDetails.MANIFEST_LOAD_TIMEOUT : _errors.ErrorDetails.MANIFEST_LOAD_ERROR;
          fatal = true;
          break;
        case ContextType.LEVEL:
          details = timeout ? _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT : _errors.ErrorDetails.LEVEL_LOAD_ERROR;
          fatal = false;
          break;
        case ContextType.AUDIO_TRACK:
          details = timeout ? _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
          fatal = false;
          break;
        default:
          // details = ...?
          fatal = false;
      }

      if (loader) {
        loader.abort();
        this.resetInternalLoader(context.type);
      }

      var errorData = {
        type: _errors.ErrorTypes.NETWORK_ERROR,
        details: details,
        fatal: fatal,
        url: loader.url,
        loader: loader,
        context: context,
        networkDetails: networkDetails
      };

      if (response) {
        errorData.response = response;
      }

      this.hls.trigger(_events2.default.ERROR, errorData);
    }
  }, {
    key: '_handlePlaylistLoaded',
    value: function _handlePlaylistLoaded(response, stats, context, networkDetails) {
      var type = context.type,
          level = context.level,
          id = context.id,
          levelDetails = context.levelDetails;


      if (!levelDetails.targetduration) {
        this._handleManifestParsingError(response, context, 'invalid target duration', networkDetails);
        return;
      }

      var canHaveLevels = PlaylistLoader.canHaveQualityLevels(context.type);
      if (canHaveLevels) {
        this.hls.trigger(_events2.default.LEVEL_LOADED, {
          details: levelDetails,
          level: level || 0,
          id: id || 0,
          stats: stats,
          networkDetails: networkDetails
        });
      } else {
        switch (type) {
          case ContextType.AUDIO_TRACK:
            this.hls.trigger(_events2.default.AUDIO_TRACK_LOADED, {
              details: levelDetails,
              id: id,
              stats: stats,
              networkDetails: networkDetails
            });
            break;
          case ContextType.SUBTITLE_TRACK:
            this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADED, {
              details: levelDetails,
              id: id,
              stats: stats,
              networkDetails: networkDetails
            });
            break;
        }
      }
    }
  }], [{
    key: 'canHaveQualityLevels',


    /**
     * @param {ContextType} type
     * @returns {boolean}
     */
    value: function canHaveQualityLevels(type) {
      return type !== ContextType.AUDIO_TRACK && type !== ContextType.SUBTITLE_TRACK;
    }

    /**
     * Map context.type to LevelType
     * @param {{type: ContextType}} context
     * @returns {LevelType}
     */

  }, {
    key: 'mapContextToLevelType',
    value: function mapContextToLevelType(context) {
      var type = context.type;


      switch (type) {
        case ContextType.AUDIO_TRACK:
          return LevelType.AUDIO;
        case ContextType.SUBTITLE_TRACK:
          return LevelType.SUBTITLE;
        default:
          return LevelType.MAIN;
      }
    }
  }, {
    key: 'getResponseUrl',
    value: function getResponseUrl(response, context) {
      var url = response.url;
      // responseURL not supported on some browsers (it is used to detect URL redirection)
      // data-uri mode also not supported (but no need to detect redirection)
      if (url === undefined || url.indexOf('data:') === 0) {
        // fallback to initial URL
        url = context.url;
      }
      return url;
    }
  }, {
    key: 'ContextType',
    get: function get() {
      return ContextType;
    }
  }, {
    key: 'LevelType',
    get: function get() {
      return LevelType;
    }
  }]);

  return PlaylistLoader;
}(_eventHandler2.default);

exports.default = PlaylistLoader;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/observer.js":
/*!********************************!*\
  !*** ./src/hls.js/observer.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Observer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventemitter = __webpack_require__(/*! eventemitter3 */ "../../node_modules/eventemitter3/index.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class
 *
 * Simple adapter sub-class of Nodejs-like EventEmitter.
 *
 * We simply want to pass along the event-name itself
 * in every call to a handler, which is the purpose of our `trigger` method
 * extending the standard API.
 *
 */
var Observer = exports.Observer = function (_EventEmitter) {
  _inherits(Observer, _EventEmitter);

  function Observer() {
    _classCallCheck(this, Observer);

    return _possibleConstructorReturn(this, (Observer.__proto__ || Object.getPrototypeOf(Observer)).apply(this, arguments));
  }

  _createClass(Observer, [{
    key: 'trigger',

    /**
     *
     * @param {string} event
     * @param {any} data
     */
    value: function trigger(event) {
      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      this.emit.apply(this, [event, event].concat(data));
    }
  }]);

  return Observer;
}(_eventemitter.EventEmitter);

/***/ }),

/***/ "./src/hls.js/remux/aac-helper.js":
/*!****************************************!*\
  !*** ./src/hls.js/remux/aac-helper.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  AAC helper
 */

var AAC = function () {
  function AAC() {
    _classCallCheck(this, AAC);
  }

  _createClass(AAC, null, [{
    key: 'getSilentFrame',
    value: function getSilentFrame(codec, channelCount) {
      switch (codec) {
        case 'mp4a.40.2':
          if (channelCount === 1) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
          } else if (channelCount === 2) {
            return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
          } else if (channelCount === 3) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
          } else if (channelCount === 4) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
          } else if (channelCount === 5) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
          } else if (channelCount === 6) {
            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
          }

          break;
        // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
        default:
          if (channelCount === 1) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          } else if (channelCount === 2) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          } else if (channelCount === 3) {
            // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
          }
          break;
      }
      return null;
    }
  }]);

  return AAC;
}();

exports.default = AAC;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/remux/mp4-generator.js":
/*!*******************************************!*\
  !*** ./src/hls.js/remux/mp4-generator.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generate MP4 Box
*/

var UINT32_MAX = Math.pow(2, 32) - 1;

var MP4 = function () {
  function MP4() {
    _classCallCheck(this, MP4);
  }

  _createClass(MP4, null, [{
    key: 'init',
    value: function init() {
      MP4.types = {
        avc1: [], // codingname
        avcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        '.mp3': [],
        mvex: [],
        mvhd: [],
        pasp: [],
        sdtp: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        tfdt: [],
        tfhd: [],
        traf: [],
        trak: [],
        trun: [],
        trex: [],
        tkhd: [],
        vmhd: [],
        smhd: []
      };

      var i = void 0;
      for (i in MP4.types) {
        if (MP4.types.hasOwnProperty(i)) {
          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
        }
      }

      var videoHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
      ]);

      var audioHdlr = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // pre_defined
      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
      ]);

      MP4.HDLR_TYPES = {
        'video': videoHdlr,
        'audio': audioHdlr
      };

      var dref = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01, // entry_count
      0x00, 0x00, 0x00, 0x0c, // entry_size
      0x75, 0x72, 0x6c, 0x20, // 'url' type
      0x00, // version 0
      0x00, 0x00, 0x01 // entry_flags
      ]);

      var stco = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00 // entry_count
      ]);

      MP4.STTS = MP4.STSC = MP4.STCO = stco;

      MP4.STSZ = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, // sample_size
      0x00, 0x00, 0x00, 0x00 // sample_count
      ]);
      MP4.VMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x01, // flags
      0x00, 0x00, // graphicsmode
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
      ]);
      MP4.SMHD = new Uint8Array([0x00, // version
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, // balance
      0x00, 0x00 // reserved
      ]);

      MP4.STSD = new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x01]); // entry_count

      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
      var minorVersion = new Uint8Array([0, 0, 0, 1]);

      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
    }
  }, {
    key: 'box',
    value: function box(type) {
      var payload = Array.prototype.slice.call(arguments, 1),
          size = 8,
          i = payload.length,
          len = i,
          result = void 0;
      // calculate the total size we need to allocate
      while (i--) {
        size += payload[i].byteLength;
      }

      result = new Uint8Array(size);
      result[0] = size >> 24 & 0xff;
      result[1] = size >> 16 & 0xff;
      result[2] = size >> 8 & 0xff;
      result[3] = size & 0xff;
      result.set(type, 4);
      // copy the payload into the result
      for (i = 0, size = 8; i < len; i++) {
        // copy payload[i] array @ offset size
        result.set(payload[i], size);
        size += payload[i].byteLength;
      }
      return result;
    }
  }, {
    key: 'hdlr',
    value: function hdlr(type) {
      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
    }
  }, {
    key: 'mdat',
    value: function mdat(data) {
      return MP4.box(MP4.types.mdat, data);
    }
  }, {
    key: 'mdhd',
    value: function mdhd(timescale, duration) {
      duration *= timescale;
      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return MP4.box(MP4.types.mdhd, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x55, 0xc4, // 'und' language (undetermined)
      0x00, 0x00]));
    }
  }, {
    key: 'mdia',
    value: function mdia(track) {
      return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
    }
  }, {
    key: 'mfhd',
    value: function mfhd(sequenceNumber) {
      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
      sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF // sequence_number
      ]));
    }
  }, {
    key: 'minf',
    value: function minf(track) {
      if (track.type === 'audio') {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
      } else {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
      }
    }
  }, {
    key: 'moof',
    value: function moof(sn, baseMediaDecodeTime, track) {
      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
    }
    /**
    * @param tracks... (optional) {array} the tracks associated with this movie
    */

  }, {
    key: 'moov',
    value: function moov(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trak(tracks[i]);
      }

      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
    }
  }, {
    key: 'mvex',
    value: function mvex(tracks) {
      var i = tracks.length,
          boxes = [];

      while (i--) {
        boxes[i] = MP4.trex(tracks[i]);
      }

      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
    }
  }, {
    key: 'mvhd',
    value: function mvhd(timescale, duration) {
      duration *= timescale;
      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      var bytes = new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x01, 0x00, 0x00, // 1.0 rate
      0x01, 0x00, // 1.0 volume
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      0xff, 0xff, 0xff, 0xff // next_track_ID
      ]);
      return MP4.box(MP4.types.mvhd, bytes);
    }
  }, {
    key: 'sdtp',
    value: function sdtp(track) {
      var samples = track.samples || [],
          bytes = new Uint8Array(4 + samples.length),
          flags = void 0,
          i = void 0;
      // leave the full box header (4 bytes) all zero
      // write the sample table
      for (i = 0; i < samples.length; i++) {
        flags = samples[i].flags;
        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
      }

      return MP4.box(MP4.types.sdtp, bytes);
    }
  }, {
    key: 'stbl',
    value: function stbl(track) {
      return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
    }
  }, {
    key: 'avc1',
    value: function avc1(track) {
      var sps = [],
          pps = [],
          i = void 0,
          data = void 0,
          len = void 0;
      // assemble the SPSs

      for (i = 0; i < track.sps.length; i++) {
        data = track.sps[i];
        len = data.byteLength;
        sps.push(len >>> 8 & 0xFF);
        sps.push(len & 0xFF);

        // SPS
        sps = sps.concat(Array.prototype.slice.call(data));
      }

      // assemble the PPSs
      for (i = 0; i < track.pps.length; i++) {
        data = track.pps[i];
        len = data.byteLength;
        pps.push(len >>> 8 & 0xFF);
        pps.push(len & 0xFF);

        pps = pps.concat(Array.prototype.slice.call(data));
      }

      var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version
      sps[3], // profile
      sps[4], // profile compat
      sps[5], // level
      0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes
      0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
      ].concat(sps).concat([track.pps.length // numOfPictureParameterSets
      ]).concat(pps))),
          // "PPS"
      width = track.width,
          height = track.height,
          hSpacing = track.pixelRatio[0],
          vSpacing = track.pixelRatio[1];

      return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, // pre_defined
      0x00, 0x00, // reserved
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
      width >> 8 & 0xFF, width & 0xff, // width
      height >> 8 & 0xFF, height & 0xff, // height
      0x00, 0x48, 0x00, 0x00, // horizresolution
      0x00, 0x48, 0x00, 0x00, // vertresolution
      0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // frame_count
      0x12, 0x64, 0x61, 0x69, 0x6C, // dailymotion/hls.js
      0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname
      0x00, 0x18, // depth = 24
      0x11, 0x11]), // pre_defined = -1
      avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB
      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate
      0x00, 0x2d, 0xc6, 0xc0])), // avgBitrate
      MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24, // hSpacing
      hSpacing >> 16 & 0xFF, hSpacing >> 8 & 0xFF, hSpacing & 0xFF, vSpacing >> 24, // vSpacing
      vSpacing >> 16 & 0xFF, vSpacing >> 8 & 0xFF, vSpacing & 0xFF])));
    }
  }, {
    key: 'esds',
    value: function esds(track) {
      var configlen = track.config.length;
      return new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags

      0x03, // descriptor_type
      0x17 + configlen, // length
      0x00, 0x01, // es_id
      0x00, // stream_priority

      0x04, // descriptor_type
      0x0f + configlen, // length
      0x40, // codec : mpeg4_audio
      0x15, // stream_type
      0x00, 0x00, 0x00, // buffer_size
      0x00, 0x00, 0x00, 0x00, // maxBitrate
      0x00, 0x00, 0x00, 0x00, // avgBitrate

      0x05 // descriptor_type
      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
    }
  }, {
    key: 'mp4a',
    value: function mp4a(track) {
      var samplerate = track.samplerate;
      return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      samplerate >> 8 & 0xFF, samplerate & 0xff, //
      0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
    }
  }, {
    key: 'mp3',
    value: function mp3(track) {
      var samplerate = track.samplerate;
      return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved
      0x00, 0x00, 0x00, // reserved
      0x00, 0x01, // data_reference_index
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, track.channelCount, // channelcount
      0x00, 0x10, // sampleSize:16bits
      0x00, 0x00, 0x00, 0x00, // reserved2
      samplerate >> 8 & 0xFF, samplerate & 0xff, //
      0x00, 0x00]));
    }
  }, {
    key: 'stsd',
    value: function stsd(track) {
      if (track.type === 'audio') {
        if (!track.isAAC && track.codec === 'mp3') {
          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
        }

        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
      } else {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
      }
    }
  }, {
    key: 'tkhd',
    value: function tkhd(track) {
      var id = track.id,
          duration = track.duration * track.timescale,
          width = track.width,
          height = track.height,
          upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)),
          lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return MP4.box(MP4.types.tkhd, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x07, // flags
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
      id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x00, // reserved
      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
      0x00, 0x00, // layer
      0x00, 0x00, // alternate_group
      0x00, 0x00, // non-audio track volume
      0x00, 0x00, // reserved
      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
      width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width
      height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height
      ]));
    }
  }, {
    key: 'traf',
    value: function traf(track, baseMediaDecodeTime) {
      var sampleDependencyTable = MP4.sdtp(track),
          id = track.id,
          upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)),
          lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF]) // track_ID
      ), MP4.box(MP4.types.tfdt, new Uint8Array([0x01, // version 1
      0x00, 0x00, 0x00, // flags
      upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0XFF, upperWordBaseMediaDecodeTime >> 8 & 0XFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0XFF, lowerWordBaseMediaDecodeTime >> 8 & 0XFF, lowerWordBaseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
      20 + // tfdt
      8 + // traf header
      16 + // mfhd
      8 + // moof header
      8), // mdat header
      sampleDependencyTable);
    }

    /**
     * Generate a track box.
     * @param track {object} a track definition
     * @return {Uint8Array} the track box
     */

  }, {
    key: 'trak',
    value: function trak(track) {
      track.duration = track.duration || 0xffffffff;
      return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
    }
  }, {
    key: 'trex',
    value: function trex(track) {
      var id = track.id;
      return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
      0x00, 0x00, 0x00, // flags
      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID
      0x00, 0x00, 0x00, 0x01, // default_sample_description_index
      0x00, 0x00, 0x00, 0x00, // default_sample_duration
      0x00, 0x00, 0x00, 0x00, // default_sample_size
      0x00, 0x01, 0x00, 0x01 // default_sample_flags
      ]));
    }
  }, {
    key: 'trun',
    value: function trun(track, offset) {
      var samples = track.samples || [],
          len = samples.length,
          arraylen = 12 + 16 * len,
          array = new Uint8Array(arraylen),
          i = void 0,
          sample = void 0,
          duration = void 0,
          size = void 0,
          flags = void 0,
          cts = void 0;
      offset += 8 + arraylen;
      array.set([0x00, // version 0
      0x00, 0x0f, 0x01, // flags
      len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count
      offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset
      ], 0);
      for (i = 0; i < len; i++) {
        sample = samples[i];
        duration = sample.duration;
        size = sample.size;
        flags = sample.flags;
        cts = sample.cts;
        array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration
        size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size
        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags
        cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset
        ], 12 + 16 * i);
      }
      return MP4.box(MP4.types.trun, array);
    }
  }, {
    key: 'initSegment',
    value: function initSegment(tracks) {
      if (!MP4.types) {
        MP4.init();
      }

      var movie = MP4.moov(tracks),
          result = void 0;
      result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
      result.set(MP4.FTYP);
      result.set(movie, MP4.FTYP.byteLength);
      return result;
    }
  }]);

  return MP4;
}();

exports.default = MP4;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/remux/mp4-remuxer.js":
/*!*****************************************!*\
  !*** ./src/hls.js/remux/mp4-remuxer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * fMP4 remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _aacHelper = __webpack_require__(/*! ./aac-helper */ "./src/hls.js/remux/aac-helper.js");

var _aacHelper2 = _interopRequireDefault(_aacHelper);

var _mp4Generator = __webpack_require__(/*! ./mp4-generator */ "./src/hls.js/remux/mp4-generator.js");

var _mp4Generator2 = _interopRequireDefault(_mp4Generator);

var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

var _errors = __webpack_require__(/*! ../errors */ "./src/hls.js/errors.js");

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 10 seconds
var MAX_SILENT_FRAME_DURATION = 10 * 1000;

var MP4Remuxer = function () {
  function MP4Remuxer(observer, config, typeSupported, vendor) {
    _classCallCheck(this, MP4Remuxer);

    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    var userAgent = navigator.userAgent;
    this.isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');
    this.ISGenerated = false;
  }

  _createClass(MP4Remuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp(defaultTimeStamp) {
      this._initPTS = this._initDTS = defaultTimeStamp;
    }
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment() {
      this.ISGenerated = false;
    }
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
      // generate Init Segment if needed
      if (!this.ISGenerated) {
        this.generateIS(audioTrack, videoTrack, timeOffset);
      }

      if (this.ISGenerated) {
        var nbAudioSamples = audioTrack.samples.length;
        var nbVideoSamples = videoTrack.samples.length;
        var audioTimeOffset = timeOffset;
        var videoTimeOffset = timeOffset;
        if (nbAudioSamples && nbVideoSamples) {
          // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)
          // if first audio DTS is not aligned with first video DTS then we need to take that into account
          // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small
          // drift between audio and video streams
          var audiovideoDeltaDts = (audioTrack.samples[0].pts - videoTrack.samples[0].pts) / videoTrack.inputTimeScale;
          audioTimeOffset += Math.max(0, audiovideoDeltaDts);
          videoTimeOffset += Math.max(0, -audiovideoDeltaDts);
        }
        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is
        // calculated in remuxAudio.
        // logger.log('nb AAC samples:' + audioTrack.samples.length);
        if (nbAudioSamples) {
          // if initSegment was generated without video samples, regenerate it again
          if (!audioTrack.timescale) {
            _logger.logger.warn('regenerate InitSegment as audio detected');
            this.generateIS(audioTrack, videoTrack, timeOffset);
          }
          var audioData = this.remuxAudio(audioTrack, audioTimeOffset, contiguous, accurateTimeOffset);
          // logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (nbVideoSamples) {
            var audioTrackLength = void 0;
            if (audioData) {
              audioTrackLength = audioData.endPTS - audioData.startPTS;
            }

            // if initSegment was generated without video samples, regenerate it again
            if (!videoTrack.timescale) {
              _logger.logger.warn('regenerate InitSegment as video detected');
              this.generateIS(audioTrack, videoTrack, timeOffset);
            }
            this.remuxVideo(videoTrack, videoTimeOffset, contiguous, audioTrackLength, accurateTimeOffset);
          }
        } else {
          // logger.log('nb AVC samples:' + videoTrack.samples.length);
          if (nbVideoSamples) {
            var videoData = this.remuxVideo(videoTrack, videoTimeOffset, contiguous, 0, accurateTimeOffset);
            if (videoData && audioTrack.codec) {
              this.remuxEmptyAudio(audioTrack, audioTimeOffset, contiguous, videoData);
            }
          }
        }
      }
      // logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (id3Track.samples.length) {
        this.remuxID3(id3Track, timeOffset);
      }

      // logger.log('nb ID3 samples:' + audioTrack.samples.length);
      if (textTrack.samples.length) {
        this.remuxText(textTrack, timeOffset);
      }

      // notify end of parsing
      this.observer.trigger(_events2.default.FRAG_PARSED);
    }
  }, {
    key: 'generateIS',
    value: function generateIS(audioTrack, videoTrack, timeOffset) {
      var observer = this.observer,
          audioSamples = audioTrack.samples,
          videoSamples = videoTrack.samples,
          typeSupported = this.typeSupported,
          container = 'audio/mp4',
          tracks = {},
          data = { tracks: tracks },
          computePTSDTS = this._initPTS === undefined,
          initPTS = void 0,
          initDTS = void 0;

      if (computePTSDTS) {
        initPTS = initDTS = Infinity;
      }

      if (audioTrack.config && audioSamples.length) {
        // let's use audio sampling rate as MP4 time scale.
        // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)
        // using audio sampling rate here helps having an integer MP4 frame duration
        // this avoids potential rounding issue and AV sync issue
        audioTrack.timescale = audioTrack.samplerate;
        _logger.logger.log('audio sampling rate : ' + audioTrack.samplerate);
        if (!audioTrack.isAAC) {
          if (typeSupported.mpeg) {
            // Chrome and Safari
            container = 'audio/mpeg';
            audioTrack.codec = '';
          } else if (typeSupported.mp3) {
            // Firefox
            audioTrack.codec = 'mp3';
          }
        }
        tracks.audio = {
          container: container,
          codec: audioTrack.codec,
          initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : _mp4Generator2.default.initSegment([audioTrack]),
          metadata: {
            channelCount: audioTrack.channelCount
          }
        };
        if (computePTSDTS) {
          // remember first PTS of this demuxing context. for audio, PTS = DTS
          initPTS = initDTS = audioSamples[0].pts - audioTrack.inputTimeScale * timeOffset;
        }
      }

      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
        // let's use input time scale as MP4 video timescale
        // we use input time scale straight away to avoid rounding issues on frame duration / cts computation
        var inputTimeScale = videoTrack.inputTimeScale;
        videoTrack.timescale = inputTimeScale;
        tracks.video = {
          container: 'video/mp4',
          codec: videoTrack.codec,
          initSegment: _mp4Generator2.default.initSegment([videoTrack]),
          metadata: {
            width: videoTrack.width,
            height: videoTrack.height
          }
        };
        if (computePTSDTS) {
          initPTS = Math.min(initPTS, videoSamples[0].pts - inputTimeScale * timeOffset);
          initDTS = Math.min(initDTS, videoSamples[0].dts - inputTimeScale * timeOffset);
          this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });
        }
      }

      if (Object.keys(tracks).length) {
        observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
        this.ISGenerated = true;
        if (computePTSDTS) {
          this._initPTS = initPTS;
          this._initDTS = initDTS;
        }
      } else {
        observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });
      }
    }
  }, {
    key: 'remuxVideo',
    value: function remuxVideo(track, timeOffset, contiguous, audioTrackLength, accurateTimeOffset) {
      var offset = 8;
      var mp4SampleDuration = void 0;
      var mdat = void 0;
      var moof = void 0;
      var firstPTS = void 0;
      var firstDTS = void 0;
      var lastPTS = void 0;
      var lastDTS = void 0;
      var timeScale = track.timescale;
      var inputSamples = track.samples;
      var outputSamples = [];
      var nbSamples = inputSamples.length;
      var ptsNormalize = this._PTSNormalize;
      var initPTS = this._initPTS;

      // if parsed fragment is contiguous with last one, let's use last DTS value as reference
      var nextAvcDts = this.nextAvcDts;

      var isSafari = this.isSafari;

      if (nbSamples === 0) {
        return;
      }

      // Safari does not like overlapping DTS on consecutive fragments. let's use nextAvcDts to overcome this if fragments are consecutive
      if (isSafari) {
        // also consider consecutive fragments as being contiguous (even if a level switch occurs),
        // for sake of clarity:
        // consecutive fragments are frags with
        //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
        //  - less than 200 ms PTS gaps (timeScale/5)
        contiguous |= inputSamples.length && nextAvcDts && (accurateTimeOffset && Math.abs(timeOffset - nextAvcDts / timeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAvcDts - initPTS) < timeScale / 5);
      }

      if (!contiguous) {
        // if not contiguous, let's use target timeOffset
        nextAvcDts = timeOffset * timeScale;
      }

      // PTS is coded on 33bits, and can loop from -2^32 to 2^32
      // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
      inputSamples.forEach(function (sample) {
        sample.pts = ptsNormalize(sample.pts - initPTS, nextAvcDts);
        sample.dts = ptsNormalize(sample.dts - initPTS, nextAvcDts);
      });

      // sort video samples by DTS then PTS then demux id order
      inputSamples.sort(function (a, b) {
        var deltadts = a.dts - b.dts;
        var deltapts = a.pts - b.pts;
        return deltadts || deltapts || a.id - b.id;
      });

      // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)
      var PTSDTSshift = inputSamples.reduce(function (prev, curr) {
        return Math.max(Math.min(prev, curr.pts - curr.dts), -18000);
      }, 0);
      if (PTSDTSshift < 0) {
        _logger.logger.warn('PTS < DTS detected in video samples, shifting DTS by ' + Math.round(PTSDTSshift / 90) + ' ms to overcome this issue');
        for (var i = 0; i < inputSamples.length; i++) {
          inputSamples[i].dts += PTSDTSshift;
        }
      }

      // compute first DTS and last DTS, normalize them against reference value
      var sample = inputSamples[0];
      firstDTS = Math.max(sample.dts, 0);
      firstPTS = Math.max(sample.pts, 0);

      // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)
      var delta = Math.round((firstDTS - nextAvcDts) / 90);
      // if fragment are contiguous, detect hole/overlapping between fragments
      if (contiguous) {
        if (delta) {
          if (delta > 1) {
            _logger.logger.log('AVC:' + delta + ' ms hole between fragments detected,filling it');
          } else if (delta < -1) {
            _logger.logger.log('AVC:' + -delta + ' ms overlapping between fragments detected');
          }

          // remove hole/gap : set DTS to next expected DTS
          firstDTS = nextAvcDts;
          inputSamples[0].dts = firstDTS;
          // offset PTS as well, ensure that PTS is smaller or equal than new DTS
          firstPTS = Math.max(firstPTS - delta, nextAvcDts);
          inputSamples[0].pts = firstPTS;
          _logger.logger.log('Video/PTS/DTS adjusted: ' + Math.round(firstPTS / 90) + '/' + Math.round(firstDTS / 90) + ',delta:' + delta + ' ms');
        }
      }

      // compute lastPTS/lastDTS
      sample = inputSamples[inputSamples.length - 1];
      lastDTS = Math.max(sample.dts, 0);
      lastPTS = Math.max(sample.pts, 0, lastDTS);

      // on Safari let's signal the same sample duration for all samples
      // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
      // set this constant duration as being the avg delta between consecutive DTS.
      if (isSafari) {
        mp4SampleDuration = Math.round((lastDTS - firstDTS) / (inputSamples.length - 1));
      }

      var nbNalu = 0,
          naluLen = 0;
      for (var _i = 0; _i < nbSamples; _i++) {
        // compute total/avc sample length and nb of NAL units
        var _sample = inputSamples[_i],
            units = _sample.units,
            nbUnits = units.length,
            sampleLen = 0;
        for (var j = 0; j < nbUnits; j++) {
          sampleLen += units[j].data.length;
        }

        naluLen += sampleLen;
        nbNalu += nbUnits;
        _sample.length = sampleLen;

        // normalize PTS/DTS
        if (isSafari) {
          // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
          _sample.dts = firstDTS + _i * mp4SampleDuration;
        } else {
          // ensure sample monotonic DTS
          _sample.dts = Math.max(_sample.dts, firstDTS);
        }
        // ensure that computed value is greater or equal than sample DTS
        _sample.pts = Math.max(_sample.pts, _sample.dts);
      }

      /* concatenate the video data and construct the mdat in place
        (need 8 more bytes to fill length and mpdat type) */
      var mdatSize = naluLen + 4 * nbNalu + 8;
      try {
        mdat = new Uint8Array(mdatSize);
      } catch (err) {
        this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating video mdat ' + mdatSize });
        return;
      }
      var view = new DataView(mdat.buffer);
      view.setUint32(0, mdatSize);
      mdat.set(_mp4Generator2.default.types.mdat, 4);

      for (var _i2 = 0; _i2 < nbSamples; _i2++) {
        var avcSample = inputSamples[_i2],
            avcSampleUnits = avcSample.units,
            mp4SampleLength = 0,
            compositionTimeOffset = void 0;
        // convert NALU bitstream to MP4 format (prepend NALU with size field)
        for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {
          var unit = avcSampleUnits[_j],
              unitData = unit.data,
              unitDataLen = unit.data.byteLength;
          view.setUint32(offset, unitDataLen);
          offset += 4;
          mdat.set(unitData, offset);
          offset += unitDataLen;
          mp4SampleLength += 4 + unitDataLen;
        }

        if (!isSafari) {
          // expected sample duration is the Decoding Timestamp diff of consecutive samples
          if (_i2 < nbSamples - 1) {
            mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;
          } else {
            var config = this.config,
                lastFrameDuration = avcSample.dts - inputSamples[_i2 > 0 ? _i2 - 1 : _i2].dts;
            if (config.stretchShortVideoTrack) {
              // In some cases, a segment's audio track duration may exceed the video track duration.
              // Since we've already remuxed audio, and we know how long the audio track is, we look to
              // see if the delta to the next segment is longer than maxBufferHole.
              // If so, playback would potentially get stuck, so we artificially inflate
              // the duration of the last frame to minimize any potential gap between segments.
              var maxBufferHole = config.maxBufferHole,
                  gapTolerance = Math.floor(maxBufferHole * timeScale),
                  deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;
              if (deltaToFrameEnd > gapTolerance) {
                // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
                // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.
                mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                if (mp4SampleDuration < 0) {
                  mp4SampleDuration = lastFrameDuration;
                }

                _logger.logger.log('It is approximately ' + deltaToFrameEnd / 90 + ' ms to the next segment; using duration ' + mp4SampleDuration / 90 + ' ms for the last video frame.');
              } else {
                mp4SampleDuration = lastFrameDuration;
              }
            } else {
              mp4SampleDuration = lastFrameDuration;
            }
          }
          compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);
        } else {
          compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / mp4SampleDuration));
        }

        // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');
        // console.log(`avcSample.dts: ${avcSample.dts / 90}, avcSample.pts: ${avcSample.pts / 90}, mp4SampleDuration: ${mp4SampleDuration / 90}`, avcSample)
        outputSamples.push({
          size: mp4SampleLength,
          // constant duration
          duration: mp4SampleDuration,
          cts: compositionTimeOffset,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: avcSample.key ? 2 : 1,
            isNonSync: avcSample.key ? 0 : 1
          }
        });
      }
      // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
      this.nextAvcDts = lastDTS + mp4SampleDuration;
      var dropped = track.dropped;
      track.len = 0;
      track.nbNalu = 0;
      track.dropped = 0;
      if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
        var flags = outputSamples[0].flags;
        // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
        // https://code.google.com/p/chromium/issues/detail?id=229412
        flags.dependsOn = 2;
        flags.isNonSync = 0;
      }
      track.samples = outputSamples;
      moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS, track);
      track.samples = [];

      var data = {
        data1: moof,
        data2: mdat,
        startPTS: firstPTS / timeScale,
        endPTS: (lastPTS + mp4SampleDuration) / timeScale,
        startDTS: firstDTS / timeScale,
        endDTS: this.nextAvcDts / timeScale,
        type: 'video',
        hasAudio: false,
        hasVideo: true,
        nb: outputSamples.length,
        dropped: dropped
      };
      this.observer.trigger(_events2.default.FRAG_PARSING_DATA, data);
      return data;
    }
  }, {
    key: 'remuxAudio',
    value: function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset) {
      var inputTimeScale = track.inputTimeScale;
      var mp4timeScale = track.timescale;
      var scaleFactor = inputTimeScale / mp4timeScale;
      var mp4SampleDuration = track.isAAC ? 1024 : 1152;
      var inputSampleDuration = mp4SampleDuration * scaleFactor;
      var ptsNormalize = this._PTSNormalize;
      var initPTS = this._initPTS;
      var rawMPEG = !track.isAAC && this.typeSupported.mpeg;

      var offset = void 0,
          mp4Sample = void 0,
          fillFrame = void 0,
          mdat = void 0,
          moof = void 0,
          firstPTS = void 0,
          lastPTS = void 0,
          inputSamples = track.samples,
          outputSamples = [],
          nextAudioPts = this.nextAudioPts;

      // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
      // for sake of clarity:
      // consecutive fragments are frags with
      //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
      //  - less than 20 audio frames distance
      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
      // this helps ensuring audio continuity
      // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame
      contiguous |= inputSamples.length && nextAudioPts && (accurateTimeOffset && Math.abs(timeOffset - nextAudioPts / inputTimeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAudioPts - initPTS) < 20 * inputSampleDuration);

      // compute normalized PTS
      inputSamples.forEach(function (sample) {
        sample.pts = sample.dts = ptsNormalize(sample.pts - initPTS, timeOffset * inputTimeScale);
      });

      // filter out sample with negative PTS that are not playable anyway
      // if we don't remove these negative samples, they will shift all audio samples forward.
      // leading to audio overlap between current / next fragment
      inputSamples = inputSamples.filter(function (sample) {
        return sample.pts >= 0;
      });

      // in case all samples have negative PTS, and have been filtered out, return now
      if (inputSamples.length === 0) {
        return;
      }

      if (!contiguous) {
        if (!accurateTimeOffset) {
          // if frag are mot contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS
          nextAudioPts = inputSamples[0].pts;
        } else {
          // if timeOffset is accurate, let's use it as predicted next audio PTS
          nextAudioPts = timeOffset * inputTimeScale;
        }
      }

      // If the audio track is missing samples, the frames seem to get "left-shifted" within the
      // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
      // In an effort to prevent this from happening, we inject frames here where there are gaps.
      // When possible, we inject a silent frame; when that's not possible, we duplicate the last
      // frame.

      if (track.isAAC) {
        var maxAudioFramesDrift = this.config.maxAudioFramesDrift;
        for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length;) {
          // First, let's see how far off this frame is from where we expect it to be
          var sample = inputSamples[i],
              delta;
          var pts = sample.pts;
          delta = pts - nextPts;

          var duration = Math.abs(1000 * delta / inputTimeScale);

          // If we're overlapping by more than a duration, drop this sample
          if (delta <= -maxAudioFramesDrift * inputSampleDuration) {
            _logger.logger.warn('Dropping 1 audio frame @ ' + (nextPts / inputTimeScale).toFixed(3) + 's due to ' + Math.round(duration) + ' ms overlap.');
            inputSamples.splice(i, 1);
            track.len -= sample.unit.length;
            // Don't touch nextPtsNorm or i
          } // eslint-disable-line brace-style

          // Insert missing frames if:
          // 1: We're more than maxAudioFramesDrift frame away
          // 2: Not more than MAX_SILENT_FRAME_DURATION away
          // 3: currentTime (aka nextPtsNorm) is not 0
          else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && nextPts) {
              var missing = Math.round(delta / inputSampleDuration);
              _logger.logger.warn('Injecting ' + missing + ' audio frame @ ' + (nextPts / inputTimeScale).toFixed(3) + 's due to ' + Math.round(1000 * delta / inputTimeScale) + ' ms gap.');
              for (var j = 0; j < missing; j++) {
                var newStamp = Math.max(nextPts, 0);
                fillFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                if (!fillFrame) {
                  _logger.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');
                  fillFrame = sample.unit.subarray();
                }
                inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });
                track.len += fillFrame.length;
                nextPts += inputSampleDuration;
                i++;
              }

              // Adjust sample to next expected pts
              sample.pts = sample.dts = nextPts;
              nextPts += inputSampleDuration;
              i++;
            } else {
              // Otherwise, just adjust pts
              if (Math.abs(delta) > 0.1 * inputSampleDuration) {
                // logger.log(`Invalid frame delta ${Math.round(delta + inputSampleDuration)} at PTS ${Math.round(pts / 90)} (should be ${Math.round(inputSampleDuration)}).`);
              }
              sample.pts = sample.dts = nextPts;
              nextPts += inputSampleDuration;
              i++;
            }
        }
      }

      for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {
        var audioSample = inputSamples[_j2];
        var unit = audioSample.unit;
        var _pts = audioSample.pts;
        // logger.log(`Audio/PTS:${Math.round(pts/90)}`);
        // if not first sample
        if (lastPTS !== undefined) {
          mp4Sample.duration = Math.round((_pts - lastPTS) / scaleFactor);
        } else {
          var _delta = Math.round(1000 * (_pts - nextAudioPts) / inputTimeScale),
              numMissingFrames = 0;
          // if fragment are contiguous, detect hole/overlapping between fragments
          // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
          if (contiguous && track.isAAC) {
            // log delta
            if (_delta) {
              if (_delta > 0 && _delta < MAX_SILENT_FRAME_DURATION) {
                numMissingFrames = Math.round((_pts - nextAudioPts) / inputSampleDuration);
                _logger.logger.log(_delta + ' ms hole between AAC samples detected,filling it');
                if (numMissingFrames > 0) {
                  fillFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                  if (!fillFrame) {
                    fillFrame = unit.subarray();
                  }

                  track.len += numMissingFrames * fillFrame.length;
                }
                // if we have frame overlap, overlapping for more than half a frame duraion
              } else if (_delta < -12) {
                // drop overlapping audio frames... browser will deal with it
                _logger.logger.log('drop overlapping AAC sample, expected/parsed/delta:' + (nextAudioPts / inputTimeScale).toFixed(3) + 's/' + (_pts / inputTimeScale).toFixed(3) + 's/' + -_delta + 'ms');
                track.len -= unit.byteLength;
                continue;
              }
              // set PTS/DTS to expected PTS/DTS
              _pts = nextAudioPts;
            }
          }
          // remember first PTS of our audioSamples
          firstPTS = _pts;
          if (track.len > 0) {
            /* concatenate the audio data and construct the mdat in place
              (need 8 more bytes to fill length and mdat type) */
            var mdatSize = rawMPEG ? track.len : track.len + 8;
            offset = rawMPEG ? 0 : 8;
            try {
              mdat = new Uint8Array(mdatSize);
            } catch (err) {
              this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating audio mdat ' + mdatSize });
              return;
            }
            if (!rawMPEG) {
              var view = new DataView(mdat.buffer);
              view.setUint32(0, mdatSize);
              mdat.set(_mp4Generator2.default.types.mdat, 4);
            }
          } else {
            // no audio samples
            return;
          }
          for (var _i3 = 0; _i3 < numMissingFrames; _i3++) {
            fillFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
            if (!fillFrame) {
              _logger.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');
              fillFrame = unit.subarray();
            }
            mdat.set(fillFrame, offset);
            offset += fillFrame.byteLength;
            mp4Sample = {
              size: fillFrame.byteLength,
              cts: 0,
              duration: 1024,
              flags: {
                isLeading: 0,
                isDependedOn: 0,
                hasRedundancy: 0,
                degradPrio: 0,
                dependsOn: 1
              }
            };
            outputSamples.push(mp4Sample);
          }
        }
        mdat.set(unit, offset);
        var unitLen = unit.byteLength;
        offset += unitLen;
        // console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');
        mp4Sample = {
          size: unitLen,
          cts: 0,
          duration: 0,
          flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: 1
          }
        };
        outputSamples.push(mp4Sample);
        lastPTS = _pts;
      }
      var lastSampleDuration = 0;
      var nbSamples = outputSamples.length;
      // set last sample duration as being identical to previous sample
      if (nbSamples >= 2) {
        lastSampleDuration = outputSamples[nbSamples - 2].duration;
        mp4Sample.duration = lastSampleDuration;
      }
      if (nbSamples) {
        // next audio sample PTS should be equal to last sample PTS + duration
        this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSampleDuration;
        // logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));
        track.len = 0;
        track.samples = outputSamples;
        if (rawMPEG) {
          moof = new Uint8Array();
        } else {
          moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstPTS / scaleFactor, track);
        }

        track.samples = [];
        var start = firstPTS / inputTimeScale;
        var end = nextAudioPts / inputTimeScale;
        var audioData = {
          data1: moof,
          data2: mdat,
          startPTS: start,
          endPTS: end,
          startDTS: start,
          endDTS: end,
          type: 'audio',
          hasAudio: true,
          hasVideo: false,
          nb: nbSamples
        };
        this.observer.trigger(_events2.default.FRAG_PARSING_DATA, audioData);
        return audioData;
      }
      return null;
    }
  }, {
    key: 'remuxEmptyAudio',
    value: function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
      var inputTimeScale = track.inputTimeScale,
          mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale,
          scaleFactor = inputTimeScale / mp4timeScale,
          nextAudioPts = this.nextAudioPts,


      // sync with video's timestamp
      startDTS = (nextAudioPts !== undefined ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS,
          endDTS = videoData.endDTS * inputTimeScale + this._initDTS,

      // one sample's duration value
      sampleDuration = 1024,
          frameDuration = scaleFactor * sampleDuration,


      // samples count of this segment's duration
      nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),


      // silent frame
      silentFrame = _aacHelper2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);

      _logger.logger.warn('remux empty Audio');
      // Can't remux if we can't generate a silent frame...
      if (!silentFrame) {
        _logger.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');
        return;
      }

      var samples = [];
      for (var i = 0; i < nbSamples; i++) {
        var stamp = startDTS + i * frameDuration;
        samples.push({ unit: silentFrame, pts: stamp, dts: stamp });
        track.len += silentFrame.length;
      }
      track.samples = samples;

      this.remuxAudio(track, timeOffset, contiguous);
    }
  }, {
    key: 'remuxID3',
    value: function remuxID3(track) {
      var length = track.samples.length,
          sample = void 0;
      var inputTimeScale = track.inputTimeScale;
      var initPTS = this._initPTS;
      var initDTS = this._initDTS;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting id3 pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - initPTS) / inputTimeScale;
          sample.dts = (sample.dts - initDTS) / inputTimeScale;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_METADATA, {
          samples: track.samples
        });
      }

      track.samples = [];
    }
  }, {
    key: 'remuxText',
    value: function remuxText(track) {
      track.samples.sort(function (a, b) {
        return a.pts - b.pts;
      });

      var length = track.samples.length,
          sample = void 0;
      var inputTimeScale = track.inputTimeScale;
      var initPTS = this._initPTS;
      // consume samples
      if (length) {
        for (var index = 0; index < length; index++) {
          sample = track.samples[index];
          // setting text pts, dts to relative time
          // using this._initPTS and this._initDTS to calculate relative time
          sample.pts = (sample.pts - initPTS) / inputTimeScale;
        }
        this.observer.trigger(_events2.default.FRAG_PARSING_USERDATA, {
          samples: track.samples
        });
      }

      track.samples = [];
    }
  }, {
    key: '_PTSNormalize',
    value: function _PTSNormalize(value, reference) {
      var offset = void 0;
      if (reference === undefined) {
        return value;
      }

      if (reference < value) {
        // - 2^33
        offset = -8589934592;
      } else {
        // + 2^33
        offset = 8589934592;
      }
      /* PTS is 33bit (from 0 to 2^33 -1)
        if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
        PTS looping occured. fill the gap */
      while (Math.abs(value - reference) > 4294967296) {
        value += offset;
      }

      return value;
    }
  }]);

  return MP4Remuxer;
}();

exports.default = MP4Remuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/remux/passthrough-remuxer.js":
/*!*************************************************!*\
  !*** ./src/hls.js/remux/passthrough-remuxer.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * passthrough remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */


var _events = __webpack_require__(/*! ../events */ "./src/hls.js/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PassThroughRemuxer = function () {
  function PassThroughRemuxer(observer) {
    _classCallCheck(this, PassThroughRemuxer);

    this.observer = observer;
  }

  _createClass(PassThroughRemuxer, [{
    key: 'destroy',
    value: function destroy() {}
  }, {
    key: 'resetTimeStamp',
    value: function resetTimeStamp() {}
  }, {
    key: 'resetInitSegment',
    value: function resetInitSegment() {}
  }, {
    key: 'remux',
    value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset, rawData) {
      var observer = this.observer;
      var streamType = '';
      if (audioTrack) {
        streamType += 'audio';
      }

      if (videoTrack) {
        streamType += 'video';
      }

      observer.trigger(_events2.default.FRAG_PARSING_DATA, {
        data1: rawData,
        startPTS: timeOffset,
        startDTS: timeOffset,
        type: streamType,
        hasAudio: !!audioTrack,
        hasVideo: !!videoTrack,
        nb: 1,
        dropped: 0
      });
      // notify end of parsing
      observer.trigger(_events2.default.FRAG_PARSED);
    }
  }]);

  return PassThroughRemuxer;
}();

exports.default = PassThroughRemuxer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/task-loop.js":
/*!*********************************!*\
  !*** ./src/hls.js/task-loop.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventHandler = __webpack_require__(/*! ./event-handler */ "./src/hls.js/event-handler.js");

var _eventHandler2 = _interopRequireDefault(_eventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Sub-class specialization of EventHandler base class.
 *
 * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,
 * scheduled asynchroneously, avoiding recursive calls in the same tick.
 *
 * The task itself is implemented in `doTick`. It can be requested and called for single execution
 * using the `tick` method.
 *
 * It will be assured that the task execution method (`tick`) only gets called once per main loop "tick",
 * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.
 *
 * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,
 * and cancelled with `clearNextTick`.
 *
 * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).
 *
 * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.
 *
 * Further explanations:
 *
 * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously
 * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.
 *
 * When the task execution (`tick` method) is called in re-entrant way this is detected and
 * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further
 * task processing on the next main loop iteration (also known as "next tick" in the Node/JS runtime lingo).
 */

var TaskLoop = function (_EventHandler) {
  _inherits(TaskLoop, _EventHandler);

  function TaskLoop(hls) {
    var _ref;

    _classCallCheck(this, TaskLoop);

    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      events[_key - 1] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = TaskLoop.__proto__ || Object.getPrototypeOf(TaskLoop)).call.apply(_ref, [this, hls].concat(events)));

    _this._tickInterval = null;
    _this._tickTimer = null;
    _this._tickCallCount = 0;
    _this._boundTick = _this.tick.bind(_this);
    return _this;
  }

  /**
   * @override
   */


  _createClass(TaskLoop, [{
    key: 'onHandlerDestroying',
    value: function onHandlerDestroying() {
      // clear all timers before unregistering from event bus
      this.clearNextTick();
      this.clearInterval();
    }

    /**
     * @returns {boolean}
     */

  }, {
    key: 'hasInterval',
    value: function hasInterval() {
      return !!this._tickInterval;
    }

    /**
     * @returns {boolean}
     */

  }, {
    key: 'hasNextTick',
    value: function hasNextTick() {
      return !!this._tickTimer;
    }

    /**
     * @param {number} millis Interval time (ms)
     * @returns {boolean} True when interval has been scheduled, false when already scheduled (no effect)
     */

  }, {
    key: 'setInterval',
    value: function (_setInterval) {
      function setInterval(_x) {
        return _setInterval.apply(this, arguments);
      }

      setInterval.toString = function () {
        return _setInterval.toString();
      };

      return setInterval;
    }(function (millis) {
      if (!this._tickInterval) {
        this._tickInterval = setInterval(this._boundTick, millis);
        return true;
      }
      return false;
    })

    /**
     * @returns {boolean} True when interval was cleared, false when none was set (no effect)
     */

  }, {
    key: 'clearInterval',
    value: function (_clearInterval) {
      function clearInterval() {
        return _clearInterval.apply(this, arguments);
      }

      clearInterval.toString = function () {
        return _clearInterval.toString();
      };

      return clearInterval;
    }(function () {
      if (this._tickInterval) {
        clearInterval(this._tickInterval);
        this._tickInterval = null;
        return true;
      }
      return false;
    })

    /**
     * @returns {boolean} True when timeout was cleared, false when none was set (no effect)
     */

  }, {
    key: 'clearNextTick',
    value: function clearNextTick() {
      if (this._tickTimer) {
        clearTimeout(this._tickTimer);
        this._tickTimer = null;
        return true;
      }
      return false;
    }

    /**
     * Will call the subclass doTick implementation in this main loop tick
     * or in the next one (via setTimeout(,0)) in case it has already been called
     * in this tick (in case this is a re-entrant call).
     */

  }, {
    key: 'tick',
    value: function tick() {
      this._tickCallCount++;
      if (this._tickCallCount === 1) {
        this.doTick();
        // re-entrant call to tick from previous doTick call stack
        // -> schedule a call on the next main loop iteration to process this task processing request
        if (this._tickCallCount > 1) {
          // make sure only one timer exists at any time at max
          this.clearNextTick();
          this._tickTimer = setTimeout(this._boundTick, 0);
        }
        this._tickCallCount = 0;
      }
    }

    /**
     * For subclass to implement task logic
     * @abstract
     */

  }, {
    key: 'doTick',
    value: function doTick() {}
  }]);

  return TaskLoop;
}(_eventHandler2.default);

exports.default = TaskLoop;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/attr-list.js":
/*!***************************************!*\
  !*** ./src/hls.js/utils/attr-list.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/; // eslint-disable-line no-useless-escape
var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g; // eslint-disable-line no-useless-escape

// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js

var AttrList = function () {
  function AttrList(attrs) {
    _classCallCheck(this, AttrList);

    if (typeof attrs === 'string') {
      attrs = AttrList.parseAttrList(attrs);
    }

    for (var attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        this[attr] = attrs[attr];
      }
    }
  }

  _createClass(AttrList, [{
    key: 'decimalInteger',
    value: function decimalInteger(attrName) {
      var intValue = parseInt(this[attrName], 10);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }

      return intValue;
    }
  }, {
    key: 'hexadecimalInteger',
    value: function hexadecimalInteger(attrName) {
      if (this[attrName]) {
        var stringValue = (this[attrName] || '0x').slice(2);
        stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;

        var value = new Uint8Array(stringValue.length / 2);
        for (var i = 0; i < stringValue.length / 2; i++) {
          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
        }

        return value;
      } else {
        return null;
      }
    }
  }, {
    key: 'hexadecimalIntegerAsNumber',
    value: function hexadecimalIntegerAsNumber(attrName) {
      var intValue = parseInt(this[attrName], 16);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }

      return intValue;
    }
  }, {
    key: 'decimalFloatingPoint',
    value: function decimalFloatingPoint(attrName) {
      return parseFloat(this[attrName]);
    }
  }, {
    key: 'enumeratedString',
    value: function enumeratedString(attrName) {
      return this[attrName];
    }
  }, {
    key: 'decimalResolution',
    value: function decimalResolution(attrName) {
      var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
      if (res === null) {
        return undefined;
      }

      return {
        width: parseInt(res[1], 10),
        height: parseInt(res[2], 10)
      };
    }
  }], [{
    key: 'parseAttrList',
    value: function parseAttrList(input) {
      var match = void 0,
          attrs = {};
      ATTR_LIST_REGEX.lastIndex = 0;
      while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
        var value = match[2],
            quote = '"';

        if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
          value = value.slice(1, -1);
        }

        attrs[match[1]] = value;
      }
      return attrs;
    }
  }]);

  return AttrList;
}();

exports.default = AttrList;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/binary-search.js":
/*!*******************************************!*\
  !*** ./src/hls.js/utils/binary-search.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var BinarySearch = {
  /**
     * Searches for an item in an array which matches a certain condition.
     * This requires the condition to only match one item in the array,
     * and for the array to be ordered.
     *
     * @param {Array} list The array to search.
     * @param {Function} comparisonFunction
     *      Called and provided a candidate item as the first argument.
     *      Should return:
     *          > -1 if the item should be located at a lower index than the provided item.
     *          > 1 if the item should be located at a higher index than the provided item.
     *          > 0 if the item is the item you're looking for.
     *
     * @return {*} The object if it is found or null otherwise.
     */
  search: function search(list, comparisonFunction) {
    var minIndex = 0;
    var maxIndex = list.length - 1;
    var currentIndex = null;
    var currentElement = null;

    while (minIndex <= maxIndex) {
      currentIndex = (minIndex + maxIndex) / 2 | 0;
      currentElement = list[currentIndex];

      var comparisonResult = comparisonFunction(currentElement);
      if (comparisonResult > 0) {
        minIndex = currentIndex + 1;
      } else if (comparisonResult < 0) {
        maxIndex = currentIndex - 1;
      } else {
        return currentElement;
      }
    }

    return null;
  }
};

exports.default = BinarySearch;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/utils/buffer-helper.js":
/*!*******************************************!*\
  !*** ./src/hls.js/utils/buffer-helper.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module BufferHelper
 *
 * Providing methods dealing with buffer length retrieval for example.
 *
 * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.
 *
 * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered
*/

var BufferHelper = exports.BufferHelper = function () {
  function BufferHelper() {
    _classCallCheck(this, BufferHelper);
  }

  _createClass(BufferHelper, null, [{
    key: "isBuffered",

    /**
     * Return true if `media`'s buffered include `position`
     * @param {HTMLMediaElement|SourceBuffer} media
     * @param {number} position
     * @returns {boolean}
     */
    value: function isBuffered(media, position) {
      try {
        if (media) {
          var buffered = media.buffered;
          for (var i = 0; i < buffered.length; i++) {
            if (position >= buffered.start(i) && position <= buffered.end(i)) {
              return true;
            }
          }
        }
      } catch (error) {
        // this is to catch
        // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
        // This SourceBuffer has been removed from the parent media source
      }
      return false;
    }
  }, {
    key: "bufferInfo",
    value: function bufferInfo(media, pos, maxHoleDuration) {
      try {
        if (media) {
          var vbuffered = media.buffered,
              buffered = [],
              i = void 0;
          for (i = 0; i < vbuffered.length; i++) {
            buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });
          }

          return this.bufferedInfo(buffered, pos, maxHoleDuration);
        }
      } catch (error) {
        // this is to catch
        // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
        // This SourceBuffer has been removed from the parent media source
      }
      return { len: 0, start: pos, end: pos, nextStart: undefined };
    }
  }, {
    key: "bufferedInfo",
    value: function bufferedInfo(buffered, pos, maxHoleDuration) {
      var buffered2 = [],

      // bufferStart and bufferEnd are buffer boundaries around current video position
      bufferLen = void 0,
          bufferStart = void 0,
          bufferEnd = void 0,
          bufferStartNext = void 0,
          i = void 0;
      // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
      buffered.sort(function (a, b) {
        var diff = a.start - b.start;
        if (diff) {
          return diff;
        } else {
          return b.end - a.end;
        }
      });
      // there might be some small holes between buffer time range
      // consider that holes smaller than maxHoleDuration are irrelevant and build another
      // buffer time range representations that discards those holes
      for (i = 0; i < buffered.length; i++) {
        var buf2len = buffered2.length;
        if (buf2len) {
          var buf2end = buffered2[buf2len - 1].end;
          // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
          if (buffered[i].start - buf2end < maxHoleDuration) {
            // merge overlapping time ranges
            // update lastRange.end only if smaller than item.end
            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
            if (buffered[i].end > buf2end) {
              buffered2[buf2len - 1].end = buffered[i].end;
            }
          } else {
            // big hole
            buffered2.push(buffered[i]);
          }
        } else {
          // first value
          buffered2.push(buffered[i]);
        }
      }
      for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {
        var start = buffered2[i].start,
            end = buffered2[i].end;
        // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
        if (pos + maxHoleDuration >= start && pos < end) {
          // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
          bufferStart = start;
          bufferEnd = end;
          bufferLen = bufferEnd - pos;
        } else if (pos + maxHoleDuration < start) {
          bufferStartNext = start;
          break;
        }
      }
      return { len: bufferLen, start: bufferStart, end: bufferEnd, nextStart: bufferStartNext };
    }
  }]);

  return BufferHelper;
}();

/***/ }),

/***/ "./src/hls.js/utils/cea-608-parser.js":
/*!********************************************!*\
  !*** ./src/hls.js/utils/cea-608-parser.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *
 * This code was ported from the dash.js project at:
 *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
 *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
 *
 * The original copyright appears below:
 *
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2015-2016, DASH Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  1. Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  2. Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
     *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
     */

var specialCea608CharsCodes = {
  0x2a: 0xe1, // lowercase a, acute accent
  0x5c: 0xe9, // lowercase e, acute accent
  0x5e: 0xed, // lowercase i, acute accent
  0x5f: 0xf3, // lowercase o, acute accent
  0x60: 0xfa, // lowercase u, acute accent
  0x7b: 0xe7, // lowercase c with cedilla
  0x7c: 0xf7, // division symbol
  0x7d: 0xd1, // uppercase N tilde
  0x7e: 0xf1, // lowercase n tilde
  0x7f: 0x2588, // Full block
  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
  // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
  0x80: 0xae, // Registered symbol (R)
  0x81: 0xb0, // degree sign
  0x82: 0xbd, // 1/2 symbol
  0x83: 0xbf, // Inverted (open) question mark
  0x84: 0x2122, // Trademark symbol (TM)
  0x85: 0xa2, // Cents symbol
  0x86: 0xa3, // Pounds sterling
  0x87: 0x266a, // Music 8'th note
  0x88: 0xe0, // lowercase a, grave accent
  0x89: 0x20, // transparent space (regular)
  0x8a: 0xe8, // lowercase e, grave accent
  0x8b: 0xe2, // lowercase a, circumflex accent
  0x8c: 0xea, // lowercase e, circumflex accent
  0x8d: 0xee, // lowercase i, circumflex accent
  0x8e: 0xf4, // lowercase o, circumflex accent
  0x8f: 0xfb, // lowercase u, circumflex accent
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
  0x90: 0xc1, // capital letter A with acute
  0x91: 0xc9, // capital letter E with acute
  0x92: 0xd3, // capital letter O with acute
  0x93: 0xda, // capital letter U with acute
  0x94: 0xdc, // capital letter U with diaresis
  0x95: 0xfc, // lowercase letter U with diaeresis
  0x96: 0x2018, // opening single quote
  0x97: 0xa1, // inverted exclamation mark
  0x98: 0x2a, // asterisk
  0x99: 0x2019, // closing single quote
  0x9a: 0x2501, // box drawings heavy horizontal
  0x9b: 0xa9, // copyright sign
  0x9c: 0x2120, // Service mark
  0x9d: 0x2022, // (round) bullet
  0x9e: 0x201c, // Left double quotation mark
  0x9f: 0x201d, // Right double quotation mark
  0xa0: 0xc0, // uppercase A, grave accent
  0xa1: 0xc2, // uppercase A, circumflex
  0xa2: 0xc7, // uppercase C with cedilla
  0xa3: 0xc8, // uppercase E, grave accent
  0xa4: 0xca, // uppercase E, circumflex
  0xa5: 0xcb, // capital letter E with diaresis
  0xa6: 0xeb, // lowercase letter e with diaresis
  0xa7: 0xce, // uppercase I, circumflex
  0xa8: 0xcf, // uppercase I, with diaresis
  0xa9: 0xef, // lowercase i, with diaresis
  0xaa: 0xd4, // uppercase O, circumflex
  0xab: 0xd9, // uppercase U, grave accent
  0xac: 0xf9, // lowercase u, grave accent
  0xad: 0xdb, // uppercase U, circumflex
  0xae: 0xab, // left-pointing double angle quotation mark
  0xaf: 0xbb, // right-pointing double angle quotation mark
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
  0xb0: 0xc3, // Uppercase A, tilde
  0xb1: 0xe3, // Lowercase a, tilde
  0xb2: 0xcd, // Uppercase I, acute accent
  0xb3: 0xcc, // Uppercase I, grave accent
  0xb4: 0xec, // Lowercase i, grave accent
  0xb5: 0xd2, // Uppercase O, grave accent
  0xb6: 0xf2, // Lowercase o, grave accent
  0xb7: 0xd5, // Uppercase O, tilde
  0xb8: 0xf5, // Lowercase o, tilde
  0xb9: 0x7b, // Open curly brace
  0xba: 0x7d, // Closing curly brace
  0xbb: 0x5c, // Backslash
  0xbc: 0x5e, // Caret
  0xbd: 0x5f, // Underscore
  0xbe: 0x7c, // Pipe (vertical line)
  0xbf: 0x223c, // Tilde operator
  0xc0: 0xc4, // Uppercase A, umlaut
  0xc1: 0xe4, // Lowercase A, umlaut
  0xc2: 0xd6, // Uppercase O, umlaut
  0xc3: 0xf6, // Lowercase o, umlaut
  0xc4: 0xdf, // Esszett (sharp S)
  0xc5: 0xa5, // Yen symbol
  0xc6: 0xa4, // Generic currency sign
  0xc7: 0x2503, // Box drawings heavy vertical
  0xc8: 0xc5, // Uppercase A, ring
  0xc9: 0xe5, // Lowercase A, ring
  0xca: 0xd8, // Uppercase O, stroke
  0xcb: 0xf8, // Lowercase o, strok
  0xcc: 0x250f, // Box drawings heavy down and right
  0xcd: 0x2513, // Box drawings heavy down and left
  0xce: 0x2517, // Box drawings heavy up and right
  0xcf: 0x251b // Box drawings heavy up and left
};

/**
 * Utils
 */
var getCharForByte = function getCharForByte(byte) {
  var charCode = byte;
  if (specialCea608CharsCodes.hasOwnProperty(byte)) {
    charCode = specialCea608CharsCodes[byte];
  }

  return String.fromCharCode(charCode);
};

var NR_ROWS = 15,
    NR_COLS = 100;
// Tables to look up row from PAC data
var rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };
var rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };
var rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };
var rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };

var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];

/**
 * Simple logger class to be able to write with time-stamps and filter on level.
 */
var logger = {
  verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },
  time: null,
  verboseLevel: 0, // Only write errors
  setTime: function setTime(newTime) {
    this.time = newTime;
  },
  log: function log(severity, msg) {
    var minLevel = this.verboseFilter[severity];
    if (this.verboseLevel >= minLevel) {
      // console.log(this.time + ' [' + severity + '] ' + msg);
    }
  }
};

var numArrayToHexArray = function numArrayToHexArray(numArray) {
  var hexArray = [];
  for (var j = 0; j < numArray.length; j++) {
    hexArray.push(numArray[j].toString(16));
  }

  return hexArray;
};

var PenState = function () {
  function PenState(foreground, underline, italics, background, flash) {
    _classCallCheck(this, PenState);

    this.foreground = foreground || 'white';
    this.underline = underline || false;
    this.italics = italics || false;
    this.background = background || 'black';
    this.flash = flash || false;
  }

  _createClass(PenState, [{
    key: 'reset',
    value: function reset() {
      this.foreground = 'white';
      this.underline = false;
      this.italics = false;
      this.background = 'black';
      this.flash = false;
    }
  }, {
    key: 'setStyles',
    value: function setStyles(styles) {
      var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];
      for (var i = 0; i < attribs.length; i++) {
        var style = attribs[i];
        if (styles.hasOwnProperty(style)) {
          this[style] = styles[style];
        }
      }
    }
  }, {
    key: 'isDefault',
    value: function isDefault() {
      return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;
    }
  }, {
    key: 'equals',
    value: function equals(other) {
      return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
    }
  }, {
    key: 'copy',
    value: function copy(newPenState) {
      this.foreground = newPenState.foreground;
      this.underline = newPenState.underline;
      this.italics = newPenState.italics;
      this.background = newPenState.background;
      this.flash = newPenState.flash;
    }
  }, {
    key: 'toString',
    value: function toString() {
      return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;
    }
  }]);

  return PenState;
}();

/**
 * Unicode character with styling and background.
 * @constructor
 */


var StyledUnicodeChar = function () {
  function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
    _classCallCheck(this, StyledUnicodeChar);

    this.uchar = uchar || ' '; // unicode character
    this.penState = new PenState(foreground, underline, italics, background, flash);
  }

  _createClass(StyledUnicodeChar, [{
    key: 'reset',
    value: function reset() {
      this.uchar = ' ';
      this.penState.reset();
    }
  }, {
    key: 'setChar',
    value: function setChar(uchar, newPenState) {
      this.uchar = uchar;
      this.penState.copy(newPenState);
    }
  }, {
    key: 'setPenState',
    value: function setPenState(newPenState) {
      this.penState.copy(newPenState);
    }
  }, {
    key: 'equals',
    value: function equals(other) {
      return this.uchar === other.uchar && this.penState.equals(other.penState);
    }
  }, {
    key: 'copy',
    value: function copy(newChar) {
      this.uchar = newChar.uchar;
      this.penState.copy(newChar.penState);
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      return this.uchar === ' ' && this.penState.isDefault();
    }
  }]);

  return StyledUnicodeChar;
}();

/**
 * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
 * @constructor
 */


var Row = function () {
  function Row() {
    _classCallCheck(this, Row);

    this.chars = [];
    for (var i = 0; i < NR_COLS; i++) {
      this.chars.push(new StyledUnicodeChar());
    }

    this.pos = 0;
    this.currPenState = new PenState();
  }

  _createClass(Row, [{
    key: 'equals',
    value: function equals(other) {
      var equal = true;
      for (var i = 0; i < NR_COLS; i++) {
        if (!this.chars[i].equals(other.chars[i])) {
          equal = false;
          break;
        }
      }
      return equal;
    }
  }, {
    key: 'copy',
    value: function copy(other) {
      for (var i = 0; i < NR_COLS; i++) {
        this.chars[i].copy(other.chars[i]);
      }
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      var empty = true;
      for (var i = 0; i < NR_COLS; i++) {
        if (!this.chars[i].isEmpty()) {
          empty = false;
          break;
        }
      }
      return empty;
    }

    /**
       *  Set the cursor to a valid column.
       */

  }, {
    key: 'setCursor',
    value: function setCursor(absPos) {
      if (this.pos !== absPos) {
        this.pos = absPos;
      }

      if (this.pos < 0) {
        logger.log('ERROR', 'Negative cursor position ' + this.pos);
        this.pos = 0;
      } else if (this.pos > NR_COLS) {
        logger.log('ERROR', 'Too large cursor position ' + this.pos);
        this.pos = NR_COLS;
      }
    }

    /**
       * Move the cursor relative to current position.
       */

  }, {
    key: 'moveCursor',
    value: function moveCursor(relPos) {
      var newPos = this.pos + relPos;
      if (relPos > 1) {
        for (var i = this.pos + 1; i < newPos + 1; i++) {
          this.chars[i].setPenState(this.currPenState);
        }
      }
      this.setCursor(newPos);
    }

    /**
       * Backspace, move one step back and clear character.
       */

  }, {
    key: 'backSpace',
    value: function backSpace() {
      this.moveCursor(-1);
      this.chars[this.pos].setChar(' ', this.currPenState);
    }
  }, {
    key: 'insertChar',
    value: function insertChar(byte) {
      if (byte >= 0x90) {
        // Extended char
        this.backSpace();
      }
      var char = getCharForByte(byte);
      if (this.pos >= NR_COLS) {
        logger.log('ERROR', 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');
        return;
      }
      this.chars[this.pos].setChar(char, this.currPenState);
      this.moveCursor(1);
    }
  }, {
    key: 'clearFromPos',
    value: function clearFromPos(startPos) {
      var i = void 0;
      for (i = startPos; i < NR_COLS; i++) {
        this.chars[i].reset();
      }
    }
  }, {
    key: 'clear',
    value: function clear() {
      this.clearFromPos(0);
      this.pos = 0;
      this.currPenState.reset();
    }
  }, {
    key: 'clearToEndOfRow',
    value: function clearToEndOfRow() {
      this.clearFromPos(this.pos);
    }
  }, {
    key: 'getTextString',
    value: function getTextString() {
      var chars = [];
      var empty = true;
      for (var i = 0; i < NR_COLS; i++) {
        var char = this.chars[i].uchar;
        if (char !== ' ') {
          empty = false;
        }

        chars.push(char);
      }
      if (empty) {
        return '';
      } else {
        return chars.join('');
      }
    }
  }, {
    key: 'setPenStyles',
    value: function setPenStyles(styles) {
      this.currPenState.setStyles(styles);
      var currChar = this.chars[this.pos];
      currChar.setPenState(this.currPenState);
    }
  }]);

  return Row;
}();

/**
 * Keep a CEA-608 screen of 32x15 styled characters
 * @constructor
*/


var CaptionScreen = function () {
  function CaptionScreen() {
    _classCallCheck(this, CaptionScreen);

    this.rows = [];
    for (var i = 0; i < NR_ROWS; i++) {
      this.rows.push(new Row());
    } // Note that we use zero-based numbering (0-14)

    this.currRow = NR_ROWS - 1;
    this.nrRollUpRows = null;
    this.reset();
  }

  _createClass(CaptionScreen, [{
    key: 'reset',
    value: function reset() {
      for (var i = 0; i < NR_ROWS; i++) {
        this.rows[i].clear();
      }

      this.currRow = NR_ROWS - 1;
    }
  }, {
    key: 'equals',
    value: function equals(other) {
      var equal = true;
      for (var i = 0; i < NR_ROWS; i++) {
        if (!this.rows[i].equals(other.rows[i])) {
          equal = false;
          break;
        }
      }
      return equal;
    }
  }, {
    key: 'copy',
    value: function copy(other) {
      for (var i = 0; i < NR_ROWS; i++) {
        this.rows[i].copy(other.rows[i]);
      }
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      var empty = true;
      for (var i = 0; i < NR_ROWS; i++) {
        if (!this.rows[i].isEmpty()) {
          empty = false;
          break;
        }
      }
      return empty;
    }
  }, {
    key: 'backSpace',
    value: function backSpace() {
      var row = this.rows[this.currRow];
      row.backSpace();
    }
  }, {
    key: 'clearToEndOfRow',
    value: function clearToEndOfRow() {
      var row = this.rows[this.currRow];
      row.clearToEndOfRow();
    }

    /**
       * Insert a character (without styling) in the current row.
       */

  }, {
    key: 'insertChar',
    value: function insertChar(char) {
      var row = this.rows[this.currRow];
      row.insertChar(char);
    }
  }, {
    key: 'setPen',
    value: function setPen(styles) {
      var row = this.rows[this.currRow];
      row.setPenStyles(styles);
    }
  }, {
    key: 'moveCursor',
    value: function moveCursor(relPos) {
      var row = this.rows[this.currRow];
      row.moveCursor(relPos);
    }
  }, {
    key: 'setCursor',
    value: function setCursor(absPos) {
      logger.log('INFO', 'setCursor: ' + absPos);
      var row = this.rows[this.currRow];
      row.setCursor(absPos);
    }
  }, {
    key: 'setPAC',
    value: function setPAC(pacData) {
      logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));
      var newRow = pacData.row - 1;
      if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
        newRow = this.nrRollUpRows - 1;
      }

      // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows
      if (this.nrRollUpRows && this.currRow !== newRow) {
        // clear all rows first
        for (var i = 0; i < NR_ROWS; i++) {
          this.rows[i].clear();
        }

        // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location
        // topRowIndex - the start of rows to copy (inclusive index)
        var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
        // We only copy if the last position was already shown.
        // We use the cueStartTime value to check this.
        var lastOutputScreen = this.lastOutputScreen;
        if (lastOutputScreen) {
          var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
          if (prevLineTime && prevLineTime < logger.time) {
            for (var _i = 0; _i < this.nrRollUpRows; _i++) {
              this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);
            }
          }
        }
      }

      this.currRow = newRow;
      var row = this.rows[this.currRow];
      if (pacData.indent !== null) {
        var indent = pacData.indent;
        var prevPos = Math.max(indent - 1, 0);
        row.setCursor(pacData.indent);
        pacData.color = row.chars[prevPos].penState.foreground;
      }
      var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };
      this.setPen(styles);
    }

    /**
       * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
       */

  }, {
    key: 'setBkgData',
    value: function setBkgData(bkgData) {
      logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));
      this.backSpace();
      this.setPen(bkgData);
      this.insertChar(0x20); // Space
    }
  }, {
    key: 'setRollUpRows',
    value: function setRollUpRows(nrRows) {
      this.nrRollUpRows = nrRows;
    }
  }, {
    key: 'rollUp',
    value: function rollUp() {
      if (this.nrRollUpRows === null) {
        logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');
        return; // Not properly setup
      }
      logger.log('TEXT', this.getDisplayText());
      var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
      var topRow = this.rows.splice(topRowIndex, 1)[0];
      topRow.clear();
      this.rows.splice(this.currRow, 0, topRow);
      logger.log('INFO', 'Rolling up');
      // logger.log('TEXT', this.get_display_text())
    }

    /**
      * Get all non-empty rows with as unicode text.
      */

  }, {
    key: 'getDisplayText',
    value: function getDisplayText(asOneRow) {
      asOneRow = asOneRow || false;
      var displayText = [];
      var text = '';
      var rowNr = -1;
      for (var i = 0; i < NR_ROWS; i++) {
        var rowText = this.rows[i].getTextString();
        if (rowText) {
          rowNr = i + 1;
          if (asOneRow) {
            displayText.push('Row ' + rowNr + ': \'' + rowText + '\'');
          } else {
            displayText.push(rowText.trim());
          }
        }
      }
      if (displayText.length > 0) {
        if (asOneRow) {
          text = '[' + displayText.join(' | ') + ']';
        } else {
          text = displayText.join('\n');
        }
      }
      return text;
    }
  }, {
    key: 'getTextAndFormat',
    value: function getTextAndFormat() {
      return this.rows;
    }
  }]);

  return CaptionScreen;
}();

// var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];

var Cea608Channel = function () {
  function Cea608Channel(channelNumber, outputFilter) {
    _classCallCheck(this, Cea608Channel);

    this.chNr = channelNumber;
    this.outputFilter = outputFilter;
    this.mode = null;
    this.verbose = 0;
    this.displayedMemory = new CaptionScreen();
    this.nonDisplayedMemory = new CaptionScreen();
    this.lastOutputScreen = new CaptionScreen();
    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
    this.writeScreen = this.displayedMemory;
    this.mode = null;
    this.cueStartTime = null; // Keeps track of where a cue started.
  }

  _createClass(Cea608Channel, [{
    key: 'reset',
    value: function reset() {
      this.mode = null;
      this.displayedMemory.reset();
      this.nonDisplayedMemory.reset();
      this.lastOutputScreen.reset();
      this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
      this.writeScreen = this.displayedMemory;
      this.mode = null;
      this.cueStartTime = null;
      this.lastCueEndTime = null;
    }
  }, {
    key: 'getHandler',
    value: function getHandler() {
      return this.outputFilter;
    }
  }, {
    key: 'setHandler',
    value: function setHandler(newHandler) {
      this.outputFilter = newHandler;
    }
  }, {
    key: 'setPAC',
    value: function setPAC(pacData) {
      this.writeScreen.setPAC(pacData);
    }
  }, {
    key: 'setBkgData',
    value: function setBkgData(bkgData) {
      this.writeScreen.setBkgData(bkgData);
    }
  }, {
    key: 'setMode',
    value: function setMode(newMode) {
      if (newMode === this.mode) {
        return;
      }

      this.mode = newMode;
      logger.log('INFO', 'MODE=' + newMode);
      if (this.mode === 'MODE_POP-ON') {
        this.writeScreen = this.nonDisplayedMemory;
      } else {
        this.writeScreen = this.displayedMemory;
        this.writeScreen.reset();
      }
      if (this.mode !== 'MODE_ROLL-UP') {
        this.displayedMemory.nrRollUpRows = null;
        this.nonDisplayedMemory.nrRollUpRows = null;
      }
      this.mode = newMode;
    }
  }, {
    key: 'insertChars',
    value: function insertChars(chars) {
      for (var i = 0; i < chars.length; i++) {
        this.writeScreen.insertChar(chars[i]);
      }

      var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
      logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));
      if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
        logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
        this.outputDataUpdate();
      }
    }
  }, {
    key: 'ccRCL',
    value: function ccRCL() {
      // Resume Caption Loading (switch mode to Pop On)
      logger.log('INFO', 'RCL - Resume Caption Loading');
      this.setMode('MODE_POP-ON');
    }
  }, {
    key: 'ccBS',
    value: function ccBS() {
      // BackSpace
      logger.log('INFO', 'BS - BackSpace');
      if (this.mode === 'MODE_TEXT') {
        return;
      }

      this.writeScreen.backSpace();
      if (this.writeScreen === this.displayedMemory) {
        this.outputDataUpdate();
      }
    }
  }, {
    key: 'ccAOF',
    value: function ccAOF() {// Reserved (formerly Alarm Off)

    }
  }, {
    key: 'ccAON',
    value: function ccAON() {// Reserved (formerly Alarm On)

    }
  }, {
    key: 'ccDER',
    value: function ccDER() {
      // Delete to End of Row
      logger.log('INFO', 'DER- Delete to End of Row');
      this.writeScreen.clearToEndOfRow();
      this.outputDataUpdate();
    }
  }, {
    key: 'ccRU',
    value: function ccRU(nrRows) {
      // Roll-Up Captions-2,3,or 4 Rows
      logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');
      this.writeScreen = this.displayedMemory;
      this.setMode('MODE_ROLL-UP');
      this.writeScreen.setRollUpRows(nrRows);
    }
  }, {
    key: 'ccFON',
    value: function ccFON() {
      // Flash On
      logger.log('INFO', 'FON - Flash On');
      this.writeScreen.setPen({ flash: true });
    }
  }, {
    key: 'ccRDC',
    value: function ccRDC() {
      // Resume Direct Captioning (switch mode to PaintOn)
      logger.log('INFO', 'RDC - Resume Direct Captioning');
      this.setMode('MODE_PAINT-ON');
    }
  }, {
    key: 'ccTR',
    value: function ccTR() {
      // Text Restart in text mode (not supported, however)
      logger.log('INFO', 'TR');
      this.setMode('MODE_TEXT');
    }
  }, {
    key: 'ccRTD',
    value: function ccRTD() {
      // Resume Text Display in Text mode (not supported, however)
      logger.log('INFO', 'RTD');
      this.setMode('MODE_TEXT');
    }
  }, {
    key: 'ccEDM',
    value: function ccEDM() {
      // Erase Displayed Memory
      logger.log('INFO', 'EDM - Erase Displayed Memory');
      this.displayedMemory.reset();
      this.outputDataUpdate(true);
    }
  }, {
    key: 'ccCR',
    value: function ccCR() {
      // Carriage Return
      logger.log('CR - Carriage Return');
      this.writeScreen.rollUp();
      this.outputDataUpdate(true);
    }
  }, {
    key: 'ccENM',
    value: function ccENM() {
      // Erase Non-Displayed Memory
      logger.log('INFO', 'ENM - Erase Non-displayed Memory');
      this.nonDisplayedMemory.reset();
    }
  }, {
    key: 'ccEOC',
    value: function ccEOC() {
      // End of Caption (Flip Memories)
      logger.log('INFO', 'EOC - End Of Caption');
      if (this.mode === 'MODE_POP-ON') {
        var tmp = this.displayedMemory;
        this.displayedMemory = this.nonDisplayedMemory;
        this.nonDisplayedMemory = tmp;
        this.writeScreen = this.nonDisplayedMemory;
        logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());
      }
      this.outputDataUpdate(true);
    }
  }, {
    key: 'ccTO',
    value: function ccTO(nrCols) {
      // Tab Offset 1,2, or 3 columns
      logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');
      this.writeScreen.moveCursor(nrCols);
    }
  }, {
    key: 'ccMIDROW',
    value: function ccMIDROW(secondByte) {
      // Parse MIDROW command
      var styles = { flash: false };
      styles.underline = secondByte % 2 === 1;
      styles.italics = secondByte >= 0x2e;
      if (!styles.italics) {
        var colorIndex = Math.floor(secondByte / 2) - 0x10;
        var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
        styles.foreground = colors[colorIndex];
      } else {
        styles.foreground = 'white';
      }
      logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));
      this.writeScreen.setPen(styles);
    }
  }, {
    key: 'outputDataUpdate',
    value: function outputDataUpdate() {
      var dispatch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var t = logger.time;
      if (t === null) {
        return;
      }

      if (this.outputFilter) {
        if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
          // Start of a new cue
          this.cueStartTime = t;
        } else {
          if (!this.displayedMemory.equals(this.lastOutputScreen)) {
            if (this.outputFilter.newCue) {
              this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);
              if (dispatch === true && this.outputFilter.dispatchCue) {
                this.outputFilter.dispatchCue();
              }
            }
            this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;
          }
        }
        this.lastOutputScreen.copy(this.displayedMemory);
      }
    }
  }, {
    key: 'cueSplitAtTime',
    value: function cueSplitAtTime(t) {
      if (this.outputFilter) {
        if (!this.displayedMemory.isEmpty()) {
          if (this.outputFilter.newCue) {
            this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
          }

          this.cueStartTime = t;
        }
      }
    }
  }]);

  return Cea608Channel;
}();

var Cea608Parser = function () {
  function Cea608Parser(field, out1, out2) {
    _classCallCheck(this, Cea608Parser);

    this.field = field || 1;
    this.outputs = [out1, out2];
    this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];
    this.currChNr = -1; // Will be 1 or 2
    this.lastCmdA = null; // First byte of last command
    this.lastCmdB = null; // Second byte of last command
    this.bufferedData = [];
    this.startTime = null;
    this.lastTime = null;
    this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };
  }

  _createClass(Cea608Parser, [{
    key: 'getHandler',
    value: function getHandler(index) {
      return this.channels[index].getHandler();
    }
  }, {
    key: 'setHandler',
    value: function setHandler(index, newHandler) {
      this.channels[index].setHandler(newHandler);
    }

    /**
       * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
       */

  }, {
    key: 'addData',
    value: function addData(t, byteList) {
      var cmdFound = void 0,
          a = void 0,
          b = void 0,
          charsFound = false;

      this.lastTime = t;
      logger.setTime(t);

      for (var i = 0; i < byteList.length; i += 2) {
        a = byteList[i] & 0x7f;
        b = byteList[i + 1] & 0x7f;
        if (a === 0 && b === 0) {
          this.dataCounters.padding += 2;
          continue;
        } else {
          logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
        }
        cmdFound = this.parseCmd(a, b);
        if (!cmdFound) {
          cmdFound = this.parseMidrow(a, b);
        }

        if (!cmdFound) {
          cmdFound = this.parsePAC(a, b);
        }

        if (!cmdFound) {
          cmdFound = this.parseBackgroundAttributes(a, b);
        }

        if (!cmdFound) {
          charsFound = this.parseChars(a, b);
          if (charsFound) {
            if (this.currChNr && this.currChNr >= 0) {
              var channel = this.channels[this.currChNr - 1];
              channel.insertChars(charsFound);
            } else {
              logger.log('WARNING', 'No channel found yet. TEXT-MODE?');
            }
          }
        }
        if (cmdFound) {
          this.dataCounters.cmd += 2;
        } else if (charsFound) {
          this.dataCounters.char += 2;
        } else {
          this.dataCounters.other += 2;
          logger.log('WARNING', 'Couldn\'t parse cleaned data ' + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
        }
      }
    }

    /**
       * Parse Command.
       * @returns {Boolean} Tells if a command was found
       */

  }, {
    key: 'parseCmd',
    value: function parseCmd(a, b) {
      var chNr = null;

      var cond1 = (a === 0x14 || a === 0x1C) && b >= 0x20 && b <= 0x2F;
      var cond2 = (a === 0x17 || a === 0x1F) && b >= 0x21 && b <= 0x23;
      if (!(cond1 || cond2)) {
        return false;
      }

      if (a === this.lastCmdA && b === this.lastCmdB) {
        this.lastCmdA = null;
        this.lastCmdB = null; // Repeated commands are dropped (once)
        logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
        return true;
      }

      if (a === 0x14 || a === 0x17) {
        chNr = 1;
      } else {
        chNr = 2;
      } // (a === 0x1C || a=== 0x1f)

      var channel = this.channels[chNr - 1];

      if (a === 0x14 || a === 0x1C) {
        if (b === 0x20) {
          channel.ccRCL();
        } else if (b === 0x21) {
          channel.ccBS();
        } else if (b === 0x22) {
          channel.ccAOF();
        } else if (b === 0x23) {
          channel.ccAON();
        } else if (b === 0x24) {
          channel.ccDER();
        } else if (b === 0x25) {
          channel.ccRU(2);
        } else if (b === 0x26) {
          channel.ccRU(3);
        } else if (b === 0x27) {
          channel.ccRU(4);
        } else if (b === 0x28) {
          channel.ccFON();
        } else if (b === 0x29) {
          channel.ccRDC();
        } else if (b === 0x2A) {
          channel.ccTR();
        } else if (b === 0x2B) {
          channel.ccRTD();
        } else if (b === 0x2C) {
          channel.ccEDM();
        } else if (b === 0x2D) {
          channel.ccCR();
        } else if (b === 0x2E) {
          channel.ccENM();
        } else if (b === 0x2F) {
          channel.ccEOC();
        }
      } else {
        // a == 0x17 || a == 0x1F
        channel.ccTO(b - 0x20);
      }
      this.lastCmdA = a;
      this.lastCmdB = b;
      this.currChNr = chNr;
      return true;
    }

    /**
       * Parse midrow styling command
       * @returns {Boolean}
       */

  }, {
    key: 'parseMidrow',
    value: function parseMidrow(a, b) {
      var chNr = null;

      if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {
        if (a === 0x11) {
          chNr = 1;
        } else {
          chNr = 2;
        }

        if (chNr !== this.currChNr) {
          logger.log('ERROR', 'Mismatch channel in midrow parsing');
          return false;
        }
        var channel = this.channels[chNr - 1];
        channel.ccMIDROW(b);
        logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
        return true;
      }
      return false;
    }
    /**
       * Parse Preable Access Codes (Table 53).
       * @returns {Boolean} Tells if PAC found
       */

  }, {
    key: 'parsePAC',
    value: function parsePAC(a, b) {
      var chNr = null;
      var row = null;

      var case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1F) && b >= 0x40 && b <= 0x7F;
      var case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5F;
      if (!(case1 || case2)) {
        return false;
      }

      if (a === this.lastCmdA && b === this.lastCmdB) {
        this.lastCmdA = null;
        this.lastCmdB = null;
        return true; // Repeated commands are dropped (once)
      }

      chNr = a <= 0x17 ? 1 : 2;

      if (b >= 0x40 && b <= 0x5F) {
        row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
      } else {
        // 0x60 <= b <= 0x7F
        row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
      }
      var pacData = this.interpretPAC(row, b);
      var channel = this.channels[chNr - 1];
      channel.setPAC(pacData);
      this.lastCmdA = a;
      this.lastCmdB = b;
      this.currChNr = chNr;
      return true;
    }

    /**
       * Interpret the second byte of the pac, and return the information.
       * @returns {Object} pacData with style parameters.
       */

  }, {
    key: 'interpretPAC',
    value: function interpretPAC(row, byte) {
      var pacIndex = byte;
      var pacData = { color: null, italics: false, indent: null, underline: false, row: row };

      if (byte > 0x5F) {
        pacIndex = byte - 0x60;
      } else {
        pacIndex = byte - 0x40;
      }

      pacData.underline = (pacIndex & 1) === 1;
      if (pacIndex <= 0xd) {
        pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
      } else if (pacIndex <= 0xf) {
        pacData.italics = true;
        pacData.color = 'white';
      } else {
        pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;
      }
      return pacData; // Note that row has zero offset. The spec uses 1.
    }

    /**
       * Parse characters.
       * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
       */

  }, {
    key: 'parseChars',
    value: function parseChars(a, b) {
      var channelNr = null,
          charCodes = null,
          charCode1 = null;

      if (a >= 0x19) {
        channelNr = 2;
        charCode1 = a - 8;
      } else {
        channelNr = 1;
        charCode1 = a;
      }
      if (charCode1 >= 0x11 && charCode1 <= 0x13) {
        // Special character
        var oneCode = b;
        if (charCode1 === 0x11) {
          oneCode = b + 0x50;
        } else if (charCode1 === 0x12) {
          oneCode = b + 0x70;
        } else {
          oneCode = b + 0x90;
        }

        logger.log('INFO', 'Special char \'' + getCharForByte(oneCode) + '\' in channel ' + channelNr);
        charCodes = [oneCode];
      } else if (a >= 0x20 && a <= 0x7f) {
        charCodes = b === 0 ? [a] : [a, b];
      }
      if (charCodes) {
        var hexCodes = numArrayToHexArray(charCodes);
        logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));
        this.lastCmdA = null;
        this.lastCmdB = null;
      }
      return charCodes;
    }

    /**
      * Parse extended background attributes as well as new foreground color black.
      * @returns{Boolean} Tells if background attributes are found
      */

  }, {
    key: 'parseBackgroundAttributes',
    value: function parseBackgroundAttributes(a, b) {
      var bkgData = void 0,
          index = void 0,
          chNr = void 0,
          channel = void 0;

      var case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;
      var case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;
      if (!(case1 || case2)) {
        return false;
      }

      bkgData = {};
      if (a === 0x10 || a === 0x18) {
        index = Math.floor((b - 0x20) / 2);
        bkgData.background = backgroundColors[index];
        if (b % 2 === 1) {
          bkgData.background = bkgData.background + '_semi';
        }
      } else if (b === 0x2d) {
        bkgData.background = 'transparent';
      } else {
        bkgData.foreground = 'black';
        if (b === 0x2f) {
          bkgData.underline = true;
        }
      }
      chNr = a < 0x18 ? 1 : 2;
      channel = this.channels[chNr - 1];
      channel.setBkgData(bkgData);
      this.lastCmdA = null;
      this.lastCmdB = null;
      return true;
    }

    /**
       * Reset state of parser and its channels.
       */

  }, {
    key: 'reset',
    value: function reset() {
      for (var i = 0; i < this.channels.length; i++) {
        if (this.channels[i]) {
          this.channels[i].reset();
        }
      }
      this.lastCmdA = null;
      this.lastCmdB = null;
    }

    /**
       * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
       */

  }, {
    key: 'cueSplitAtTime',
    value: function cueSplitAtTime(t) {
      for (var i = 0; i < this.channels.length; i++) {
        if (this.channels[i]) {
          this.channels[i].cueSplitAtTime(t);
        }
      }
    }
  }]);

  return Cea608Parser;
}();

exports.default = Cea608Parser;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/codecs.js":
/*!************************************!*\
  !*** ./src/hls.js/utils/codecs.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// from http://mp4ra.org/codecs.html
var sampleEntryCodesISO = {
  audio: {
    'a3ds': true,
    'ac-3': true,
    'ac-4': true,
    'alac': true,
    'alaw': true,
    'dra1': true,
    'dts+': true,
    'dts-': true,
    'dtsc': true,
    'dtse': true,
    'dtsh': true,
    'ec-3': true,
    'enca': true,
    'g719': true,
    'g726': true,
    'm4ae': true,
    'mha1': true,
    'mha2': true,
    'mhm1': true,
    'mhm2': true,
    'mlpa': true,
    'mp4a': true,
    'raw ': true,
    'Opus': true,
    'samr': true,
    'sawb': true,
    'sawp': true,
    'sevc': true,
    'sqcp': true,
    'ssmv': true,
    'twos': true,
    'ulaw': true
  },
  video: {
    'avc1': true,
    'avc2': true,
    'avc3': true,
    'avc4': true,
    'avcp': true,
    'drac': true,
    'dvav': true,
    'dvhe': true,
    'encv': true,
    'hev1': true,
    'hvc1': true,
    'mjp2': true,
    'mp4v': true,
    'mvc1': true,
    'mvc2': true,
    'mvc3': true,
    'mvc4': true,
    'resv': true,
    'rv60': true,
    's263': true,
    'svc1': true,
    'svc2': true,
    'vc-1': true,
    'vp08': true,
    'vp09': true
  }
};

function isCodecType(codec, type) {
  var typeCodes = sampleEntryCodesISO[type];
  return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;
}

function isCodecSupportedInMp4(codec, type) {
  return window.MediaSource.isTypeSupported((type || 'video') + '/mp4;codecs="' + codec + '"');
}

exports.isCodecType = isCodecType;
exports.isCodecSupportedInMp4 = isCodecSupportedInMp4;

/***/ }),

/***/ "./src/hls.js/utils/cues.js":
/*!**********************************!*\
  !*** ./src/hls.js/utils/cues.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.newCue = newCue;

var _vttparser = __webpack_require__(/*! ./vttparser */ "./src/hls.js/utils/vttparser.js");

function newCue(track, startTime, endTime, captionScreen) {
  var row = void 0;
  var cue = void 0;
  var indenting = void 0;
  var indent = void 0;
  var text = void 0;
  var VTTCue = window.VTTCue || window.TextTrackCue;

  for (var r = 0; r < captionScreen.rows.length; r++) {
    row = captionScreen.rows[r];
    indenting = true;
    indent = 0;
    text = '';

    if (!row.isEmpty()) {
      for (var c = 0; c < row.chars.length; c++) {
        if (row.chars[c].uchar.match(/\s/) && indenting) {
          indent++;
        } else {
          text += row.chars[c].uchar;
          indenting = false;
        }
      }
      // To be used for cleaning-up orphaned roll-up captions
      row.cueStartTime = startTime;

      // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
      if (startTime === endTime) {
        endTime += 0.0001;
      }

      cue = new VTTCue(startTime, endTime, (0, _vttparser.fixLineBreaks)(text.trim()));

      if (indent >= 16) {
        indent--;
      } else {
        indent++;
      }

      // VTTCue.line get's flakey when using controls, so let's now include line 13&14
      // also, drop line 1 since it's to close to the top
      if (navigator.userAgent.match(/Firefox\//)) {
        cue.line = r + 1;
      } else {
        cue.line = r > 7 ? r - 2 : r + 1;
      }

      cue.align = 'left';
      // Clamp the position between 0 and 100 - if out of these bounds, Firefox throws an exception and captions break
      cue.position = Math.max(0, Math.min(100, 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0)));
      track.addCue(cue);
    }
  }
}

/***/ }),

/***/ "./src/hls.js/utils/discontinuities.js":
/*!*********************************************!*\
  !*** ./src/hls.js/utils/discontinuities.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findFirstFragWithCC = findFirstFragWithCC;
exports.findFragWithCC = findFragWithCC;
exports.shouldAlignOnDiscontinuities = shouldAlignOnDiscontinuities;
exports.findDiscontinuousReferenceFrag = findDiscontinuousReferenceFrag;
exports.adjustPts = adjustPts;
exports.alignStream = alignStream;
exports.alignDiscontinuities = alignDiscontinuities;
exports.alignPDT = alignPDT;

var _binarySearch = __webpack_require__(/*! ./binary-search */ "./src/hls.js/utils/binary-search.js");

var _binarySearch2 = _interopRequireDefault(_binarySearch);

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function findFirstFragWithCC(fragments, cc) {
  var firstFrag = null;

  for (var i = 0; i < fragments.length; i += 1) {
    var currentFrag = fragments[i];
    if (currentFrag && currentFrag.cc === cc) {
      firstFrag = currentFrag;
      break;
    }
  }

  return firstFrag;
}

function findFragWithCC(fragments, CC) {
  return _binarySearch2.default.search(fragments, function (candidate) {
    if (candidate.cc < CC) {
      return 1;
    } else if (candidate.cc > CC) {
      return -1;
    } else {
      return 0;
    }
  });
}

function shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {
  var shouldAlign = false;
  if (lastLevel && lastLevel.details && details) {
    if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {
      shouldAlign = true;
    }
  }
  return shouldAlign;
}

// Find the first frag in the previous level which matches the CC of the first frag of the new level
function findDiscontinuousReferenceFrag(prevDetails, curDetails) {
  var prevFrags = prevDetails.fragments;
  var curFrags = curDetails.fragments;

  if (!curFrags.length || !prevFrags.length) {
    _logger.logger.log('No fragments to align');
    return;
  }

  var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);

  if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {
    _logger.logger.log('No frag in previous level to align on');
    return;
  }

  return prevStartFrag;
}

function adjustPts(sliding, details) {
  details.fragments.forEach(function (frag) {
    if (frag) {
      var start = frag.start + sliding;
      frag.start = frag.startPTS = start;
      frag.endPTS = start + frag.duration;
    }
  });
  details.PTSKnown = true;
}

/**
 * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a
 * contiguous stream with the last fragments.
 * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to
 * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time
 * and an extra download.
 * @param lastFrag
 * @param lastLevel
 * @param details
 */
function alignStream(lastFrag, lastLevel, details) {
  alignDiscontinuities(lastFrag, details, lastLevel);
  if (!details.PTSKnown && lastLevel) {
    // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.
    // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same
    // discontinuity sequence.
    alignPDT(details, lastLevel.details);
  }
}

/**
 * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same
 * discontinuity sequence.
 * @param lastLevel - The details of the last loaded level
 * @param details - The details of the new level
 */
function alignDiscontinuities(lastFrag, details, lastLevel) {
  if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {
    var referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);
    if (referenceFrag) {
      _logger.logger.log('Adjusting PTS using last level due to CC increase within current level');
      adjustPts(referenceFrag.start, details);
    }
  }
}

/**
 * Computes the PTS of a new level's fragments using the difference in Program Date Time from the last level.
 * @param details - The details of the new level
 * @param lastDetails - The details of the last loaded level
 */
function alignPDT(details, lastDetails) {
  if (lastDetails && lastDetails.fragments.length) {
    if (!details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {
      return;
    }
    // if last level sliding is 1000 and its first frag PROGRAM-DATE-TIME is 2017-08-20 1:10:00 AM
    // and if new details first frag PROGRAM DATE-TIME is 2017-08-20 1:10:08 AM
    // then we can deduce that playlist B sliding is 1000+8 = 1008s
    var lastPDT = lastDetails.fragments[0].programDateTime;
    var newPDT = details.fragments[0].programDateTime;
    // date diff is in ms. frag.start is in seconds
    var sliding = (newPDT - lastPDT) / 1000 + lastDetails.fragments[0].start;
    if (Number.isFinite(sliding)) {
      _logger.logger.log('adjusting PTS using programDateTime delta, sliding:' + sliding.toFixed(3));
      adjustPts(sliding, details);
    }
  }
}

/***/ }),

/***/ "./src/hls.js/utils/ewma-bandwidth-estimator.js":
/*!******************************************************!*\
  !*** ./src/hls.js/utils/ewma-bandwidth-estimator.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EWMA Bandwidth Estimator
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  - heavily inspired from shaka-player
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Tracks bandwidth samples and estimates available bandwidth.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Based on the minimum of two exponentially-weighted moving averages with
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * different half-lives.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _ewma = __webpack_require__(/*! ../utils/ewma */ "./src/hls.js/utils/ewma.js");

var _ewma2 = _interopRequireDefault(_ewma);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EwmaBandWidthEstimator = function () {
  function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {
    _classCallCheck(this, EwmaBandWidthEstimator);

    this.hls = hls;
    this.defaultEstimate_ = defaultEstimate;
    this.minWeight_ = 0.001;
    this.minDelayMs_ = 50;
    this.slow_ = new _ewma2.default(slow);
    this.fast_ = new _ewma2.default(fast);
  }

  _createClass(EwmaBandWidthEstimator, [{
    key: 'sample',
    value: function sample(durationMs, numBytes) {
      durationMs = Math.max(durationMs, this.minDelayMs_);
      var bandwidth = 8000 * numBytes / durationMs,

      // console.log('instant bw:'+ Math.round(bandwidth));
      // we weight sample using loading duration....
      weight = durationMs / 1000;
      this.fast_.sample(weight, bandwidth);
      this.slow_.sample(weight, bandwidth);
    }
  }, {
    key: 'canEstimate',
    value: function canEstimate() {
      var fast = this.fast_;
      return fast && fast.getTotalWeight() >= this.minWeight_;
    }
  }, {
    key: 'getEstimate',
    value: function getEstimate() {
      if (this.canEstimate()) {
        // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
        // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
        // Take the minimum of these two estimates.  This should have the effect of
        // adapting down quickly, but up more slowly.
        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
      } else {
        return this.defaultEstimate_;
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {}
  }]);

  return EwmaBandWidthEstimator;
}();

exports.default = EwmaBandWidthEstimator;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/ewma.js":
/*!**********************************!*\
  !*** ./src/hls.js/utils/ewma.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * compute an Exponential Weighted moving average
 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
 *  - heavily inspired from shaka-player
 */

var EWMA = function () {
  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  function EWMA(halfLife) {
    _classCallCheck(this, EWMA);

    // Larger values of alpha expire historical data more slowly.
    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
    this.estimate_ = 0;
    this.totalWeight_ = 0;
  }

  _createClass(EWMA, [{
    key: "sample",
    value: function sample(weight, value) {
      var adjAlpha = Math.pow(this.alpha_, weight);
      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
      this.totalWeight_ += weight;
    }
  }, {
    key: "getTotalWeight",
    value: function getTotalWeight() {
      return this.totalWeight_;
    }
  }, {
    key: "getEstimate",
    value: function getEstimate() {
      if (this.alpha_) {
        var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
        return this.estimate_ / zeroFactor;
      } else {
        return this.estimate_;
      }
    }
  }]);

  return EWMA;
}();

exports.default = EWMA;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/utils/get-self-scope.js":
/*!********************************************!*\
  !*** ./src/hls.js/utils/get-self-scope.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSelfScope = getSelfScope;
function getSelfScope() {
  // see https://stackoverflow.com/a/11237259/589493
  if (typeof window === 'undefined') {
    /* eslint-disable-next-line no-undef */
    return self;
  } else {
    return window;
  }
}

/***/ }),

/***/ "./src/hls.js/utils/logger.js":
/*!************************************!*\
  !*** ./src/hls.js/utils/logger.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logger = exports.enableLogs = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _getSelfScope = __webpack_require__(/*! ./get-self-scope */ "./src/hls.js/utils/get-self-scope.js");

function noop() {}

var fakeLogger = {
  trace: noop,
  debug: noop,
  log: noop,
  warn: noop,
  info: noop,
  error: noop
};

var exportedLogger = fakeLogger;

// let lastCallTime;
// function formatMsgWithTimeInfo(type, msg) {
//   const now = Date.now();
//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
//   lastCallTime = now;
//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
//   return msg;
// }

function formatMsg(type, msg) {
  msg = '[' + type + '] > ' + msg;
  return msg;
}

var global = (0, _getSelfScope.getSelfScope)();

function consolePrintFn(type) {
  var func = global.console[type];
  if (func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args[0]) {
        args[0] = formatMsg(type, args[0]);
      }

      func.apply(global.console, args);
    };
  }
  return noop;
}

function exportLoggerFunctions(debugConfig) {
  for (var _len2 = arguments.length, functions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    functions[_key2 - 1] = arguments[_key2];
  }

  functions.forEach(function (type) {
    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
  });
}

var enableLogs = exports.enableLogs = function enableLogs(debugConfig) {
  if (debugConfig === true || (typeof debugConfig === 'undefined' ? 'undefined' : _typeof(debugConfig)) === 'object') {
    exportLoggerFunctions(debugConfig,
    // Remove out from list here to hard-disable a log-level
    // 'trace',
    'debug', 'log', 'info', 'warn', 'error');
    // Some browsers don't allow to use bind on console object anyway
    // fallback to default if needed
    try {
      exportedLogger.log();
    } catch (e) {
      exportedLogger = fakeLogger;
    }
  } else {
    exportedLogger = fakeLogger;
  }
};

var logger = exports.logger = exportedLogger;

/***/ }),

/***/ "./src/hls.js/utils/mediakeys-helper.js":
/*!**********************************************!*\
  !*** ./src/hls.js/utils/mediakeys-helper.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var requestMediaKeySystemAccess = function () {
  if (typeof window !== 'undefined' && window.navigator && window.navigator.requestMediaKeySystemAccess) {
    return window.navigator.requestMediaKeySystemAccess.bind(window.navigator);
  } else {
    return null;
  }
}();

exports.requestMediaKeySystemAccess = requestMediaKeySystemAccess;

/***/ }),

/***/ "./src/hls.js/utils/mediasource-helper.js":
/*!************************************************!*\
  !*** ./src/hls.js/utils/mediasource-helper.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMediaSource = getMediaSource;
/**
 * MediaSource helper
 */

function getMediaSource() {
  if (typeof window !== 'undefined') {
    return window.MediaSource || window.WebKitMediaSource;
  }
}

/***/ }),

/***/ "./src/hls.js/utils/output-filter.js":
/*!*******************************************!*\
  !*** ./src/hls.js/utils/output-filter.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var OutputFilter = function () {
  function OutputFilter(timelineController, trackName) {
    _classCallCheck(this, OutputFilter);

    this.timelineController = timelineController;
    this.trackName = trackName;
    this.startTime = null;
    this.endTime = null;
    this.screen = null;
  }

  _createClass(OutputFilter, [{
    key: "dispatchCue",
    value: function dispatchCue() {
      if (this.startTime === null) {
        return;
      }

      this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen);
      this.startTime = null;
    }
  }, {
    key: "newCue",
    value: function newCue(startTime, endTime, screen) {
      if (this.startTime === null || this.startTime > startTime) {
        this.startTime = startTime;
      }

      this.endTime = endTime;
      this.screen = screen;
      this.timelineController.createCaptionsTrack(this.trackName);
    }
  }]);

  return OutputFilter;
}();

exports.default = OutputFilter;
module.exports = exports["default"];

/***/ }),

/***/ "./src/hls.js/utils/texttrack-utils.js":
/*!*********************************************!*\
  !*** ./src/hls.js/utils/texttrack-utils.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sendAddTrackEvent = sendAddTrackEvent;
exports.clearCurrentCues = clearCurrentCues;
function sendAddTrackEvent(track, videoEl) {
  var event = null;
  try {
    event = new window.Event('addtrack');
  } catch (err) {
    // for IE11
    event = document.createEvent('Event');
    event.initEvent('addtrack', false, false);
  }
  event.track = track;
  videoEl.dispatchEvent(event);
}

function clearCurrentCues(track) {
  if (track && track.cues) {
    while (track.cues.length > 0) {
      track.removeCue(track.cues[0]);
    }
  }
}

/***/ }),

/***/ "./src/hls.js/utils/time-ranges.js":
/*!*****************************************!*\
  !*** ./src/hls.js/utils/time-ranges.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 *  TimeRanges to string helper
 */

var TimeRanges = {
  toString: function toString(r) {
    var log = '',
        len = r.length;
    for (var i = 0; i < len; i++) {
      log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';
    }

    return log;
  }
};

exports.default = TimeRanges;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/vttcue.js":
/*!************************************!*\
  !*** ./src/hls.js/utils/vttcue.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

exports.default = function () {
  if (typeof window !== 'undefined' && window.VTTCue) {
    return window.VTTCue;
  }

  var autoKeyword = 'auto';
  var directionSetting = {
    '': true,
    lr: true,
    rl: true
  };
  var alignSetting = {
    start: true,
    middle: true,
    end: true,
    left: true,
    right: true
  };

  function findDirectionSetting(value) {
    if (typeof value !== 'string') {
      return false;
    }

    var dir = directionSetting[value.toLowerCase()];
    return dir ? value.toLowerCase() : false;
  }

  function findAlignSetting(value) {
    if (typeof value !== 'string') {
      return false;
    }

    var align = alignSetting[value.toLowerCase()];
    return align ? value.toLowerCase() : false;
  }

  function extend(obj) {
    var i = 1;
    for (; i < arguments.length; i++) {
      var cobj = arguments[i];
      for (var p in cobj) {
        obj[p] = cobj[p];
      }
    }

    return obj;
  }

  function VTTCue(startTime, endTime, text) {
    var cue = this;
    var isIE8 = function () {
      if (typeof navigator === 'undefined') {
        return;
      }

      return (/MSIE\s8\.0/.test(navigator.userAgent)
      );
    }();
    var baseObj = {};

    if (isIE8) {
      cue = document.createElement('custom');
    } else {
      baseObj.enumerable = true;
    }

    /**
     * Shim implementation specific properties. These properties are not in
     * the spec.
     */

    // Lets us know when the VTTCue's data has changed in such a way that we need
    // to recompute its display state. This lets us compute its display state
    // lazily.
    cue.hasBeenReset = false;

    /**
     * VTTCue and TextTrackCue properties
     * http://dev.w3.org/html5/webvtt/#vttcue-interface
     */

    var _id = '';
    var _pauseOnExit = false;
    var _startTime = startTime;
    var _endTime = endTime;
    var _text = text;
    var _region = null;
    var _vertical = '';
    var _snapToLines = true;
    var _line = 'auto';
    var _lineAlign = 'start';
    var _position = 50;
    var _positionAlign = 'middle';
    var _size = 50;
    var _align = 'middle';

    Object.defineProperty(cue, 'id', extend({}, baseObj, {
      get: function get() {
        return _id;
      },
      set: function set(value) {
        _id = '' + value;
      }
    }));

    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {
      get: function get() {
        return _pauseOnExit;
      },
      set: function set(value) {
        _pauseOnExit = !!value;
      }
    }));

    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {
      get: function get() {
        return _startTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('Start time must be set to a number.');
        }

        _startTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {
      get: function get() {
        return _endTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('End time must be set to a number.');
        }

        _endTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'text', extend({}, baseObj, {
      get: function get() {
        return _text;
      },
      set: function set(value) {
        _text = '' + value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'region', extend({}, baseObj, {
      get: function get() {
        return _region;
      },
      set: function set(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {
      get: function get() {
        return _vertical;
      },
      set: function set(value) {
        var setting = findDirectionSetting(value);
        // Have to check for false because the setting an be an empty string.
        if (setting === false) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _vertical = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {
      get: function get() {
        return _snapToLines;
      },
      set: function set(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'line', extend({}, baseObj, {
      get: function get() {
        return _line;
      },
      set: function set(value) {
        if (typeof value !== 'number' && value !== autoKeyword) {
          throw new SyntaxError('An invalid number or illegal string was specified.');
        }

        _line = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {
      get: function get() {
        return _lineAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'position', extend({}, baseObj, {
      get: function get() {
        return _position;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Position must be between 0 and 100.');
        }

        _position = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {
      get: function get() {
        return _positionAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _positionAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'size', extend({}, baseObj, {
      get: function get() {
        return _size;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Size must be between 0 and 100.');
        }

        _size = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'align', extend({}, baseObj, {
      get: function get() {
        return _align;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _align = setting;
        this.hasBeenReset = true;
      }
    }));

    /**
     * Other <track> spec defined properties
     */

    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
    cue.displayState = undefined;

    if (isIE8) {
      return cue;
    }
  }

  /**
   * VTTCue methods
   */

  VTTCue.prototype.getCueAsHTML = function () {
    // Assume WebVTT.convertCueToDOMTree is on the global.
    var WebVTT = window.WebVTT;
    return WebVTT.convertCueToDOMTree(window, this.text);
  };

  return VTTCue;
}();

module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/vttparser.js":
/*!***************************************!*\
  !*** ./src/hls.js/utils/vttparser.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fixLineBreaks = undefined;

var _vttcue = __webpack_require__(/*! ./vttcue */ "./src/hls.js/utils/vttcue.js");

var _vttcue2 = _interopRequireDefault(_vttcue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StringDecoder = function StringDecoder() {
  return {
    decode: function decode(data) {
      if (!data) {
        return '';
      }

      if (typeof data !== 'string') {
        throw new Error('Error - expected string data.');
      }

      return decodeURIComponent(encodeURIComponent(data));
    }
  };
}; /*
    * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js#L1716
    */

function VTTParser() {
  this.window = window;
  this.state = 'INITIAL';
  this.buffer = '';
  this.decoder = new StringDecoder();
  this.regionList = [];
}

// Try to parse input as a time stamp.
function parseTimeStamp(input) {
  function computeSeconds(h, m, s, f) {
    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
  }

  var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
  if (!m) {
    return null;
  }

  if (m[3]) {
    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
    return computeSeconds(m[1], m[2], m[3].replace(':', ''), m[4]);
  } else if (m[1] > 59) {
    // Timestamp takes the form of [hours]:[minutes].[milliseconds]
    // First position is hours as it's over 59.
    return computeSeconds(m[1], m[2], 0, m[4]);
  } else {
    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
    return computeSeconds(0, m[1], m[2], m[4]);
  }
}

// A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.
function Settings() {
  this.values = Object.create(null);
}

Settings.prototype = {
  // Only accept the first assignment to any key.
  set: function set(k, v) {
    if (!this.get(k) && v !== '') {
      this.values[k] = v;
    }
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function get(k, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k) ? this.values[k] : dflt[defaultKey];
    }

    return this.has(k) ? this.values[k] : dflt;
  },
  // Check whether we have a value for a key.
  has: function has(k) {
    return k in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function alt(k, v, a) {
    for (var n = 0; n < a.length; ++n) {
      if (v === a[n]) {
        this.set(k, v);
        break;
      }
    }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function integer(k, v) {
    if (/^-?\d+$/.test(v)) {
      // integer
      this.set(k, parseInt(v, 10));
    }
  },
  // Accept a setting if its a valid percentage.
  percent: function percent(k, v) {
    var m = void 0;
    if (m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
      v = parseFloat(v);
      if (v >= 0 && v <= 100) {
        this.set(k, v);
        return true;
      }
    }
    return false;
  }
};

// Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.
function parseOptions(input, callback, keyValueDelim, groupDelim) {
  var groups = groupDelim ? input.split(groupDelim) : [input];
  for (var i in groups) {
    if (typeof groups[i] !== 'string') {
      continue;
    }

    var kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) {
      continue;
    }

    var k = kv[0];
    var v = kv[1];
    callback(k, v);
  }
}

var defaults = new _vttcue2.default(0, 0, 0);
// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244
//  Safari doesn't yet support this change, but FF and Chrome do.
var center = defaults.align === 'middle' ? 'middle' : 'center';

function parseCue(input, cue, regionList) {
  // Remember the original input if we need to throw an error.
  var oInput = input;
  // 4.1 WebVTT timestamp
  function consumeTimeStamp() {
    var ts = parseTimeStamp(input);
    if (ts === null) {
      throw new Error('Malformed timestamp: ' + oInput);
    }

    // Remove time stamp from input.
    input = input.replace(/^[^\sa-zA-Z-]+/, '');
    return ts;
  }

  // 4.4.2 WebVTT cue settings
  function consumeCueSettings(input, cue) {
    var settings = new Settings();

    parseOptions(input, function (k, v) {
      switch (k) {
        case 'region':
          // Find the last region we parsed with the same region id.
          for (var i = regionList.length - 1; i >= 0; i--) {
            if (regionList[i].id === v) {
              settings.set(k, regionList[i].region);
              break;
            }
          }
          break;
        case 'vertical':
          settings.alt(k, v, ['rl', 'lr']);
          break;
        case 'line':
          var vals = v.split(','),
              vals0 = vals[0];
          settings.integer(k, vals0);
          if (settings.percent(k, vals0)) {
            settings.set('snapToLines', false);
          }

          settings.alt(k, vals0, ['auto']);
          if (vals.length === 2) {
            settings.alt('lineAlign', vals[1], ['start', center, 'end']);
          }

          break;
        case 'position':
          vals = v.split(',');
          settings.percent(k, vals[0]);
          if (vals.length === 2) {
            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);
          }

          break;
        case 'size':
          settings.percent(k, v);
          break;
        case 'align':
          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);
          break;
      }
    }, /:/, /\s/);

    // Apply default values for any missing fields.
    cue.region = settings.get('region', null);
    cue.vertical = settings.get('vertical', '');
    var line = settings.get('line', 'auto');
    if (line === 'auto' && defaults.line === -1) {
      // set numeric line number for Safari
      line = -1;
    }
    cue.line = line;
    cue.lineAlign = settings.get('lineAlign', 'start');
    cue.snapToLines = settings.get('snapToLines', true);
    cue.size = settings.get('size', 100);
    cue.align = settings.get('align', center);
    var position = settings.get('position', 'auto');
    if (position === 'auto' && defaults.position === 50) {
      // set numeric position for Safari
      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;
    }
    cue.position = position;
  }

  function skipWhitespace() {
    input = input.replace(/^\s+/, '');
  }

  // 4.1 WebVTT cue timings.
  skipWhitespace();
  cue.startTime = consumeTimeStamp(); // (1) collect cue start time
  skipWhitespace();
  if (input.substr(0, 3) !== '-->') {
    // (3) next characters must match '-->'
    throw new Error('Malformed time stamp (time stamps must be separated by \'-->\'): ' + oInput);
  }
  input = input.substr(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp(); // (5) collect cue end time

  // 4.1 WebVTT cue settings list.
  skipWhitespace();
  consumeCueSettings(input, cue);
}

function fixLineBreaks(input) {
  return input.replace(/<br(?: \/)?>/gi, '\n');
}

VTTParser.prototype = {
  parse: function parse(data) {
    var self = this;

    // If there is no data then we won't decode it, but will just try to parse
    // whatever is in buffer already. This may occur in circumstances, for
    // example when flush() is called.
    if (data) {
      // Try to decode the data that we received.
      self.buffer += self.decoder.decode(data, { stream: true });
    }

    function collectNextLine() {
      var buffer = self.buffer;
      var pos = 0;

      buffer = fixLineBreaks(buffer);

      while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
        ++pos;
      }

      var line = buffer.substr(0, pos);
      // Advance the buffer early in case we fail below.
      if (buffer[pos] === '\r') {
        ++pos;
      }

      if (buffer[pos] === '\n') {
        ++pos;
      }

      self.buffer = buffer.substr(pos);
      return line;
    }

    // 3.2 WebVTT metadata header syntax
    function parseHeader(input) {
      parseOptions(input, function (k, v) {
        switch (k) {
          case 'Region':
            // 3.3 WebVTT region metadata header syntax
            // console.log('parse region', v);
            // parseRegion(v);
            break;
        }
      }, /:/);
    }

    // 5.1 WebVTT file parsing.
    try {
      var line = void 0;
      if (self.state === 'INITIAL') {
        // We can't start parsing until we have the first line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        line = collectNextLine();
        // strip of UTF-8 BOM if any
        // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8
        var m = line.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
        if (!m || !m[0]) {
          throw new Error('Malformed WebVTT signature.');
        }

        self.state = 'HEADER';
      }

      var alreadyCollectedLine = false;
      while (self.buffer) {
        // We can't parse a line until we have the full line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        if (!alreadyCollectedLine) {
          line = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }

        switch (self.state) {
          case 'HEADER':
            // 13-18 - Allow a header (metadata) under the WEBVTT line.
            if (/:/.test(line)) {
              parseHeader(line);
            } else if (!line) {
              // An empty line terminates the header and starts the body (cues).
              self.state = 'ID';
            }
            continue;
          case 'NOTE':
            // Ignore NOTE blocks.
            if (!line) {
              self.state = 'ID';
            }

            continue;
          case 'ID':
            // Check for the start of NOTE blocks.
            if (/^NOTE($|[ \t])/.test(line)) {
              self.state = 'NOTE';
              break;
            }
            // 19-29 - Allow any number of line terminators, then initialize new cue values.
            if (!line) {
              continue;
            }

            self.cue = new _vttcue2.default(0, 0, '');
            self.state = 'CUE';
            // 30-39 - Check if self line contains an optional identifier or timing data.
            if (line.indexOf('-->') === -1) {
              self.cue.id = line;
              continue;
            }
          // Process line as start of a cue.
          /* falls through */
          case 'CUE':
            // 40 - Collect cue timings and settings.
            try {
              parseCue(line, self.cue, self.regionList);
            } catch (e) {
              // In case of an error ignore rest of the cue.
              self.cue = null;
              self.state = 'BADCUE';
              continue;
            }
            self.state = 'CUETEXT';
            continue;
          case 'CUETEXT':
            var hasSubstring = line.indexOf('-->') !== -1;
            // 34 - If we have an empty line then report the cue.
            // 35 - If we have the special substring '-->' then report the cue,
            // but do not collect the line as we need to process the current
            // one as a new cue.
            if (!line || hasSubstring && (alreadyCollectedLine = true)) {
              // We are done parsing self cue.
              if (self.oncue) {
                self.oncue(self.cue);
              }

              self.cue = null;
              self.state = 'ID';
              continue;
            }
            if (self.cue.text) {
              self.cue.text += '\n';
            }

            self.cue.text += line;
            continue;
          case 'BADCUE':
            // BADCUE
            // 54-62 - Collect and discard the remaining cue.
            if (!line) {
              self.state = 'ID';
            }

            continue;
        }
      }
    } catch (e) {
      // If we are currently parsing a cue, report what we have.
      if (self.state === 'CUETEXT' && self.cue && self.oncue) {
        self.oncue(self.cue);
      }

      self.cue = null;
      // Enter BADWEBVTT state if header was not parsed correctly otherwise
      // another exception occurred so enter BADCUE state.
      self.state = self.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';
    }
    return this;
  },
  flush: function flush() {
    var self = this;
    try {
      // Finish decoding the stream.
      self.buffer += self.decoder.decode();
      // Synthesize the end of the current cue or region.
      if (self.cue || self.state === 'HEADER') {
        self.buffer += '\n\n';
        self.parse();
      }
      // If we've flushed, parsed, and we're still on the INITIAL state then
      // that means we don't have enough of the stream to parse the first
      // line.
      if (self.state === 'INITIAL') {
        throw new Error('Malformed WebVTT signature.');
      }
    } catch (e) {
      throw e;
    }
    if (self.onflush) {
      self.onflush();
    }

    return this;
  }
};

exports.fixLineBreaks = fixLineBreaks;
exports.default = VTTParser;

/***/ }),

/***/ "./src/hls.js/utils/webvtt-parser.js":
/*!*******************************************!*\
  !*** ./src/hls.js/utils/webvtt-parser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vttparser = __webpack_require__(/*! ./vttparser */ "./src/hls.js/utils/vttparser.js");

var _vttparser2 = _interopRequireDefault(_vttparser);

var _id = __webpack_require__(/*! ../demux/id3 */ "./src/hls.js/demux/id3.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// String.prototype.startsWith is not supported in IE11
var startsWith = function startsWith(inputString, searchString, position) {
  return inputString.substr(position || 0, searchString.length) === searchString;
};

var cueString2millis = function cueString2millis(timeString) {
  var ts = parseInt(timeString.substr(-3));
  var secs = parseInt(timeString.substr(-6, 2));
  var mins = parseInt(timeString.substr(-9, 2));
  var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(':'))) : 0;

  if (!Number.isFinite(ts) || !Number.isFinite(secs) || !Number.isFinite(mins) || !Number.isFinite(hours)) {
    return -1;
  }

  ts += 1000 * secs;
  ts += 60 * 1000 * mins;
  ts += 60 * 60 * 1000 * hours;

  return ts;
};

// From https://github.com/darkskyapp/string-hash
var hash = function hash(text) {
  var hash = 5381;
  var i = text.length;
  while (i) {
    hash = hash * 33 ^ text.charCodeAt(--i);
  }

  return (hash >>> 0).toString();
};

var calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {
  var currCC = vttCCs[cc];
  var prevCC = vttCCs[currCC.prevCC];

  // This is the first discontinuity or cues have been processed since the last discontinuity
  // Offset = current discontinuity time
  if (!prevCC || !prevCC.new && currCC.new) {
    vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
    currCC.new = false;
    return;
  }

  // There have been discontinuities since cues were last parsed.
  // Offset = time elapsed
  while (prevCC && prevCC.new) {
    vttCCs.ccOffset += currCC.start - prevCC.start;
    currCC.new = false;
    currCC = prevCC;
    prevCC = vttCCs[currCC.prevCC];
  }

  vttCCs.presentationOffset = presentationTime;
};

var WebVTTParser = {
  parse: function parse(vttByteArray, syncPTS, vttCCs, cc, callBack, errorCallBack) {
    // Convert byteArray into string, replacing any somewhat exotic linefeeds with "\n", then split on that character.
    var re = /\r\n|\n\r|\n|\r/g;
    // Uint8Array.prototype.reduce is not implemented in IE11
    var vttLines = (0, _id.utf8ArrayToStr)(new Uint8Array(vttByteArray)).trim().replace(re, '\n').split('\n');

    var cueTime = '00:00.000';
    var mpegTs = 0;
    var localTime = 0;
    var presentationTime = 0;
    var cues = [];
    var parsingError = void 0;
    var inHeader = true;
    // let VTTCue = VTTCue || window.TextTrackCue;

    // Create parser object using VTTCue with TextTrackCue fallback on certain browsers.
    var parser = new _vttparser2.default();

    parser.oncue = function (cue) {
      // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.
      var currCC = vttCCs[cc];
      var cueOffset = vttCCs.ccOffset;

      // Update offsets for new discontinuities
      if (currCC && currCC.new) {
        if (localTime !== undefined) {
          // When local time is provided, offset = discontinuity start time - local time
          cueOffset = vttCCs.ccOffset = currCC.start;
        } else {
          calculateOffset(vttCCs, cc, presentationTime);
        }
      }

      if (presentationTime) {
        // If we have MPEGTS, offset = presentation time + discontinuity offset
        cueOffset = presentationTime - vttCCs.presentationOffset;
      }

      cue.startTime += cueOffset - localTime;
      cue.endTime += cueOffset - localTime;

      // Create a unique hash id for a cue based on start/end times and text.
      // This helps timeline-controller to avoid showing repeated captions.
      cue.id = hash(cue.startTime.toString()) + hash(cue.endTime.toString()) + hash(cue.text);

      // Fix encoding of special characters. TODO: Test with all sorts of weird characters.
      cue.text = decodeURIComponent(encodeURIComponent(cue.text));
      if (cue.endTime > 0) {
        cues.push(cue);
      }
    };

    parser.onparsingerror = function (e) {
      parsingError = e;
    };

    parser.onflush = function () {
      if (parsingError && errorCallBack) {
        errorCallBack(parsingError);
        return;
      }
      callBack(cues);
    };

    // Go through contents line by line.
    vttLines.forEach(function (line) {
      if (inHeader) {
        // Look for X-TIMESTAMP-MAP in header.
        if (startsWith(line, 'X-TIMESTAMP-MAP=')) {
          // Once found, no more are allowed anyway, so stop searching.
          inHeader = false;
          // Extract LOCAL and MPEGTS.
          line.substr(16).split(',').forEach(function (timestamp) {
            if (startsWith(timestamp, 'LOCAL:')) {
              cueTime = timestamp.substr(6);
            } else if (startsWith(timestamp, 'MPEGTS:')) {
              mpegTs = parseInt(timestamp.substr(7));
            }
          });
          try {
            // Calculate subtitle offset in milliseconds.
            if (syncPTS + (vttCCs[cc].start * 90000 || 0) < 0) {
              syncPTS += 8589934592;
            }
            // Adjust MPEGTS by sync PTS.
            mpegTs -= syncPTS;
            // Convert cue time to seconds
            localTime = cueString2millis(cueTime) / 1000;
            // Convert MPEGTS to seconds from 90kHz.
            presentationTime = mpegTs / 90000;

            if (localTime === -1) {
              parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
            }
          } catch (e) {
            parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
          }
          // Return without parsing X-TIMESTAMP-MAP line.
          return;
        } else if (line === '') {
          inHeader = false;
        }
      }
      // Parse line by default.
      parser.parse(line + '\n');
    });

    parser.flush();
  }
};

exports.default = WebVTTParser;
module.exports = exports['default'];

/***/ }),

/***/ "./src/hls.js/utils/xhr-loader.js":
/*!****************************************!*\
  !*** ./src/hls.js/utils/xhr-loader.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * XHR based logger
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _logger = __webpack_require__(/*! ../utils/logger */ "./src/hls.js/utils/logger.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _window = window,
    performance = _window.performance,
    XMLHttpRequest = _window.XMLHttpRequest;

var XhrLoader = function () {
  function XhrLoader(config) {
    _classCallCheck(this, XhrLoader);

    if (config && config.xhrSetup) {
      this.xhrSetup = config.xhrSetup;
    }
  }

  _createClass(XhrLoader, [{
    key: 'destroy',
    value: function destroy() {
      this.abort();
      this.loader = null;
    }
  }, {
    key: 'abort',
    value: function abort() {
      var loader = this.loader;
      if (loader && loader.readyState !== 4) {
        this.stats.aborted = true;
        loader.abort();
      }

      window.clearTimeout(this.requestTimeout);
      this.requestTimeout = null;
      window.clearTimeout(this.retryTimeout);
      this.retryTimeout = null;
    }
  }, {
    key: 'load',
    value: function load(context, config, callbacks) {
      this.context = context;
      this.config = config;
      this.callbacks = callbacks;
      this.stats = { trequest: performance.now(), retry: 0 };
      this.retryDelay = config.retryDelay;
      this.loadInternal();
    }
  }, {
    key: 'loadInternal',
    value: function loadInternal() {
      var xhr = void 0,
          context = this.context;
      xhr = this.loader = new XMLHttpRequest();

      var stats = this.stats;
      stats.tfirst = 0;
      stats.loaded = 0;
      var xhrSetup = this.xhrSetup;

      try {
        if (xhrSetup) {
          try {
            xhrSetup(xhr, context.url);
          } catch (e) {
            // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader("Content-Language", "test");}
            // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN
            xhr.open('GET', context.url, true);
            xhrSetup(xhr, context.url);
          }
        }
        if (!xhr.readyState) {
          xhr.open('GET', context.url, true);
        }
      } catch (e) {
        // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
        this.callbacks.onError({ code: xhr.status, text: e.message }, context, xhr);
        return;
      }

      if (context.rangeEnd) {
        xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
      }

      xhr.onreadystatechange = this.readystatechange.bind(this);
      xhr.onprogress = this.loadprogress.bind(this);
      xhr.responseType = context.responseType;

      // setup timeout before we perform request
      this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
      xhr.send();
    }
  }, {
    key: 'readystatechange',
    value: function readystatechange(event) {
      var xhr = event.currentTarget,
          readyState = xhr.readyState,
          stats = this.stats,
          context = this.context,
          config = this.config;

      // don't proceed if xhr has been aborted
      if (stats.aborted) {
        return;
      }

      // >= HEADERS_RECEIVED
      if (readyState >= 2) {
        // clear xhr timeout and rearm it if readyState less than 4
        window.clearTimeout(this.requestTimeout);
        if (stats.tfirst === 0) {
          stats.tfirst = Math.max(performance.now(), stats.trequest);
        }

        if (readyState === 4) {
          var status = xhr.status;
          // http status between 200 to 299 are all successful
          if (status >= 200 && status < 300) {
            stats.tload = Math.max(stats.tfirst, performance.now());
            var data = void 0,
                len = void 0;
            if (context.responseType === 'arraybuffer') {
              data = xhr.response;
              len = data.byteLength;
            } else {
              data = xhr.responseText;
              len = data.length;
            }
            stats.loaded = stats.total = len;
            var response = { url: xhr.responseURL, data: data };
            this.callbacks.onSuccess(response, stats, context, xhr);
          } else {
            // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
            if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {
              _logger.logger.error(status + ' while loading ' + context.url);
              this.callbacks.onError({ code: status, text: xhr.statusText }, context, xhr);
            } else {
              // retry
              _logger.logger.warn(status + ' while loading ' + context.url + ', retrying in ' + this.retryDelay + '...');
              // aborts and resets internal state
              this.destroy();
              // schedule retry
              this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
              // set exponential backoff
              this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
              stats.retry++;
            }
          }
        } else {
          // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet
          this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout);
        }
      }
    }
  }, {
    key: 'loadtimeout',
    value: function loadtimeout() {
      _logger.logger.warn('timeout while loading ' + this.context.url);
      this.callbacks.onTimeout(this.stats, this.context, null);
    }
  }, {
    key: 'loadprogress',
    value: function loadprogress(event) {
      var xhr = event.currentTarget,
          stats = this.stats;

      stats.loaded = event.loaded;
      if (event.lengthComputable) {
        stats.total = event.total;
      }

      var onProgress = this.callbacks.onProgress;
      if (onProgress) {
        // third arg is to provide on progress data
        onProgress(stats, this.context, null, xhr);
      }
    }
  }]);

  return XhrLoader;
}();

exports.default = XhrLoader;
module.exports = exports['default'];

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _xgplayer = __webpack_require__(/*! xgplayer */ "xgplayer");

var _xgplayer2 = _interopRequireDefault(_xgplayer);

var _hls = __webpack_require__(/*! ./hls.js/hls */ "./src/hls.js/hls.js");

var _hls2 = _interopRequireDefault(_hls);

var _utils = __webpack_require__(/*! ./utils */ "./src/utils/index.js");

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HlsJsPlayer = function (_Player) {
  _inherits(HlsJsPlayer, _Player);

  function HlsJsPlayer(options) {
    _classCallCheck(this, HlsJsPlayer);

    var _this = _possibleConstructorReturn(this, (HlsJsPlayer.__proto__ || Object.getPrototypeOf(HlsJsPlayer)).call(this, options));

    _this.hlsOpts = options.hlsOpts || {};
    var util = _xgplayer2.default.util;
    var player = _this;
    _this.browser = _utils2.default.getBrowserVersion();
    if (player.config.useHls === undefined) {
      if (_xgplayer2.default.sniffer.device === 'mobile' && navigator.platform !== 'MacIntel' && navigator.platform !== 'Win32' || _this.browser.indexOf('Safari') > -1) {
        return _possibleConstructorReturn(_this);
      }
    } else if (!player.config.useHls) {
      return _possibleConstructorReturn(_this);
    }
    Number.isFinite = Number.isFinite || function (value) {
      return typeof value === "number" && isFinite(value);
    };

    var hls = void 0;
    hls = new _hls2.default(_this.hlsOpts);
    _this.hls = hls;

    Object.defineProperty(player, 'src', {
      get: function get() {
        return player.currentSrc;
      },
      set: function set(url) {
        util.removeClass(player.root, 'xgplayer-is-live');
        var liveDom = document.querySelector('.xgplayer-live');
        if (liveDom) {
          liveDom.parentNode.removeChild(liveDom);
        }
        // player.config.url = url
        var paused = player.paused;
        player.hls.stopLoad();
        player.hls.detachMedia();
        player.hls.destroy();
        player.hls = new _hls2.default(player.hlsOpts);
        player.register(url);
        if (!paused) {
          player.pause();
          player.once('pause', function () {
            player.hls.loadSource(url);
          });
          player.once('canplay', function () {
            player.play().catch(function (err) {});
          });
        } else {
          player.hls.loadSource(url);
        }
        player.hls.attachMedia(player.video);
        player.once('canplay', function () {
          player.currentTime = 0;
        });
      },

      configurable: true
    });
    _this.register(_this.config.url);
    _this.once('complete', function () {
      hls.attachMedia(player.video);
      player.once('canplay', function () {
        if (player.config.autoplay) {
          player.play().catch(function (err) {});
        }
      });
      if (player.config.isLive) {
        util.addClass(player.root, 'xgplayer-is-live');
        if (!util.findDom(player.root, '.xgplayer-live')) {
          var live = util.createDom('xg-live', '正在直播', {}, 'xgplayer-live');
          player.controls.appendChild(live);
        }
      }
    });
    _this.once('destroy', function () {
      hls.stopLoad();
    });
    return _this;
  }

  _createClass(HlsJsPlayer, [{
    key: 'register',
    value: function register(url) {
      var hls = this.hls;
      var util = _xgplayer2.default.util;
      var player = this;
      hls.on(_hls2.default.Events.MEDIA_ATTACHED, function () {
        hls.loadSource(url);
      });

      hls.on(_hls2.default.Events.LEVEL_LOADED, function (name, e) {
        if (!hls.inited) {
          hls.inited = true;
          if (e && e.details && e.details.live) {
            util.addClass(player.root, 'xgplayer-is-live');
            if (!util.findDom(player.root, '.xgplayer-live')) {
              var live = util.createDom('xg-live', '正在直播', {}, 'xgplayer-live');
              player.controls.appendChild(live);
            }
          }
        }
      });
      hls.on(_hls2.default.Events.ERROR, function (event, data) {
        player.emit('HLS_ERROR', {
          errorType: data.type,
          errorDetails: data.details,
          errorFatal: data.fatal
        });
        if (data.fatal) {
          switch (data.type) {
            case _hls2.default.ErrorTypes.NETWORK_ERROR:
              hls.startLoad();
              break;
            case _hls2.default.ErrorTypes.MEDIA_ERROR:
              hls.recoverMediaError();
              break;
            default:
              player.emit('error', data);
          }
        }
      });
      this._statistics();
    }
  }, {
    key: '_statistics',
    value: function _statistics() {
      var statsInfo = {
        speed: 0,
        playerType: "HlsPlayer"
      };

      var mediainfo = {
        videoDataRate: 0,
        audioDataRate: 0
      };
      var hls = this.hls;
      var player = this;

      hls.on(_hls2.default.Events.FRAG_LOAD_PROGRESS, function (flag, payload) {
        statsInfo.speed = payload.stats.loaded / 1000;
      });
      hls.on(_hls2.default.Events.FRAG_PARSING_DATA, function (flag, payload) {
        if (payload.type === 'video') {
          mediainfo.fps = parseInt(payload.nb / (payload.endPTS - payload.startPTS));
        }
      });

      hls.on(_hls2.default.Events.FRAG_PARSING_INIT_SEGMENT, function (flag, payload) {
        mediainfo.hasAudio = payload.tracks && payload.tracks.audio ? true : false;
        mediainfo.hasVideo = payload.tracks && payload.tracks.audio ? true : false;

        if (mediainfo.hasAudio) {
          var track = payload.tracks.audio;
          mediainfo.audioChannelCount = track.metadata && track.metadata.channelCount ? track.metadata.channelCount : 0;
          mediainfo.audioCodec = track.codec;
        }

        if (mediainfo.hasVideo) {
          var _track = payload.tracks.video;
          mediainfo.videoCodec = _track.codec;
          mediainfo.width = _track.metadata && _track.metadata.width ? _track.metadata.width : 0;
          mediainfo.height = _track.metadata && _track.metadata.height ? _track.metadata.height : 0;
        }
        mediainfo.duration = payload.frag && payload.frag.duration ? payload.frag.duration : 0;
        mediainfo.level = payload.frag && payload.frag.level ? payload.frag.level : 0;
        if (mediainfo.videoCodec || mediainfo.audioCodec) {
          mediainfo.mimeType = 'video/hls; codecs="' + mediainfo.videoCodec + ';' + mediainfo.audioCodec + '"';
        }

        player.mediainfo = mediainfo;
        player.emit("media_info", mediainfo);
      });

      this._statisticsTimmer = setInterval(function () {
        player.emit("statistics_info", statsInfo);
        statsInfo.speed = 0;
      }, 1000);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _get(HlsJsPlayer.prototype.__proto__ || Object.getPrototypeOf(HlsJsPlayer.prototype), 'destroy', this).call(this);
      clearInterval(this._statisticsTimmer);
    }
  }]);

  return HlsJsPlayer;
}(_xgplayer2.default);

HlsJsPlayer.isSupported = _hls2.default.isSupported;

exports.default = HlsJsPlayer;
module.exports = exports['default'];

/***/ }),

/***/ "./src/utils/index.js":
/*!****************************!*\
  !*** ./src/utils/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var util = {};

util.getBrowserVersion = function () {
  var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串
  if (userAgent.toLowerCase().indexOf("mobile") > -1) {
    return "Unknown";
  }
  if (userAgent.indexOf("Firefox") > -1) {
    var version = userAgent.match(/firefox\/[\d.]+/gi)[0].match(/[\d]+/)[0];
    return "Firefox " + version;
  } else if (userAgent.indexOf("Edge") > -1) {
    var _version = userAgent.match(/edge\/[\d.]+/gi)[0].match(/[\d]+/)[0];
    return "Edge " + _version;
  } else if (userAgent.indexOf("rv:11") > -1) {
    return "IE 11";
  } else if (userAgent.indexOf("Opera") > -1 || userAgent.indexOf("OPR") > -1) {
    if (userAgent.indexOf("Opera") > -1) {
      var _version2 = userAgent.match(/opera\/[\d.]+/gi)[0].match(/[\d]+/)[0];
      return "Opera " + _version2;
    }
    if (userAgent.indexOf("OPR") > -1) {
      var _version3 = userAgent.match(/opr\/[\d.]+/gi)[0].match(/[\d]+/)[0];
      return "Opera " + _version3;
    }
  } else if (userAgent.indexOf("Chrome") > -1) {
    var _version4 = userAgent.match(/chrome\/[\d.]+/gi)[0].match(/[\d]+/)[0];
    return "Chrome " + _version4;
  } else if (userAgent.indexOf("Safari") > -1) {
    var _version5 = userAgent.match(/safari\/[\d.]+/gi)[0].match(/[\d]+/)[0];
    return "Safari " + _version5;
  } else if (userAgent.indexOf("MSIE") > -1 || userAgent.indexOf("Trident") > -1) {
    if (userAgent.indexOf("MSIE") > -1) {
      var _version6 = userAgent.match(/msie [\d.]+/gi)[0].match(/[\d]+/)[0];
      return "IE " + _version6;
    }
    if (userAgent.indexOf("Trident") > -1) {
      var versionTrident = userAgent.match(/trident\/[\d.]+/gi)[0].match(/[\d]+/)[0];
      var _version7 = parseInt(versionTrident) + 4;
      return "IE " + _version7;
    }
  } else {
    return "Unknown";
  }
};

exports.default = util;
module.exports = exports["default"];

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./src/index.js */"./src/index.js");


/***/ }),

/***/ "xgplayer":
/*!*************************!*\
  !*** external "Player" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = window["Player"]; }());

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9IbHNKc1BsYXllci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8vVXNlcnMvbGVvbmFyZG8vRG9jdW1lbnRzL2Zyb250LWVuZC9wbGF5ZXIveGdwbGF5ZXIvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvL1VzZXJzL2xlb25hcmRvL0RvY3VtZW50cy9mcm9udC1lbmQvcGxheWVyL3hncGxheWVyL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy9Vc2Vycy9sZW9uYXJkby9Eb2N1bWVudHMvZnJvbnQtZW5kL3BsYXllci94Z3BsYXllci9ub2RlX21vZHVsZXMvdXJsLXRvb2xraXQvc3JjL3VybC10b29sa2l0LmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy9Vc2Vycy9sZW9uYXJkby9Eb2N1bWVudHMvZnJvbnQtZW5kL3BsYXllci94Z3BsYXllci9ub2RlX21vZHVsZXMvd2Vid29ya2lmeS13ZWJwYWNrL2luZGV4LmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb25maWcuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvYWJyLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9iYXNlLXN0cmVhbS1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2ZyYWdtZW50LWZpbmRlcnMuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9nYXAtY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9pZDMtdHJhY2stY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL2xldmVsLWhlbHBlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9zdHJlYW0tY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY29udHJvbGxlci9zdWJ0aXRsZS10cmFjay1jb250cm9sbGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9jb250cm9sbGVyL3RpbWVsaW5lLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NyeXB0L2Flcy1jcnlwdG8uanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NyeXB0L2Flcy1kZWNyeXB0b3IuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2NyeXB0L2RlY3J5cHRlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvY3J5cHQvZmFzdC1hZXMta2V5LmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9kZW11eC9hYWNkZW11eGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9kZW11eC9hZHRzLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9kZW11eC9kZW11eGVyLWlubGluZS5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvZGVtdXgvZGVtdXhlci13b3JrZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2RlbXV4L2RlbXV4ZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2RlbXV4L2V4cC1nb2xvbWIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2RlbXV4L2lkMy5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvZGVtdXgvbXAzZGVtdXhlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvZGVtdXgvbXA0ZGVtdXhlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvZGVtdXgvbXBlZ2F1ZGlvLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9kZW11eC9zYW1wbGUtYWVzLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9kZW11eC90c2RlbXV4ZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvZXZlbnQtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvZXZlbnRzLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9obHMuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2lzLXN1cHBvcnRlZC5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvbG9hZGVyL2ZyYWdtZW50LWxvYWRlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvbG9hZGVyL2ZyYWdtZW50LmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9sb2FkZXIva2V5LWxvYWRlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvbG9hZGVyL2xldmVsLWtleS5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvbG9hZGVyL2xldmVsLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9sb2FkZXIvbTN1OC1wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL2xvYWRlci9wbGF5bGlzdC1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL29ic2VydmVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9yZW11eC9hYWMtaGVscGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9yZW11eC9tcDQtZ2VuZXJhdG9yLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy9yZW11eC9tcDQtcmVtdXhlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlci5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvdGFzay1sb29wLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy9hdHRyLWxpc3QuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL2JpbmFyeS1zZWFyY2guanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL2J1ZmZlci1oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL2NlYS02MDgtcGFyc2VyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy9jb2RlY3MuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL2N1ZXMuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL2Rpc2NvbnRpbnVpdGllcy5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvdXRpbHMvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy9ld21hLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy9nZXQtc2VsZi1zY29wZS5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvdXRpbHMvbG9nZ2VyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy9tZWRpYWtleXMtaGVscGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL291dHB1dC1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL3RleHR0cmFjay11dGlscy5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvdXRpbHMvdGltZS1yYW5nZXMuanMiLCJ3ZWJwYWNrOi8vSGxzSnNQbGF5ZXIvLi9zcmMvaGxzLmpzL3V0aWxzL3Z0dGN1ZS5qcyIsIndlYnBhY2s6Ly9IbHNKc1BsYXllci8uL3NyYy9obHMuanMvdXRpbHMvdnR0cGFyc2VyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy93ZWJ2dHQtcGFyc2VyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2hscy5qcy91dGlscy94aHItbG9hZGVyLmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyLy4vc3JjL3V0aWxzL2luZGV4LmpzIiwid2VicGFjazovL0hsc0pzUGxheWVyL2V4dGVybmFsIFwiUGxheWVyXCIiXSwibmFtZXMiOlsiQ3VlcyIsImhsc0RlZmF1bHRDb25maWciLCJhdXRvU3RhcnRMb2FkIiwic3RhcnRQb3NpdGlvbiIsImRlZmF1bHRBdWRpb0NvZGVjIiwidW5kZWZpbmVkIiwiZGVidWciLCJjYXBMZXZlbE9uRlBTRHJvcCIsImNhcExldmVsVG9QbGF5ZXJTaXplIiwiaW5pdGlhbExpdmVNYW5pZmVzdFNpemUiLCJtYXhCdWZmZXJMZW5ndGgiLCJtYXhCdWZmZXJTaXplIiwibWF4QnVmZmVySG9sZSIsImxvd0J1ZmZlcldhdGNoZG9nUGVyaW9kIiwiaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kIiwibnVkZ2VPZmZzZXQiLCJudWRnZU1heFJldHJ5IiwibWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSIsImxpdmVTeW5jRHVyYXRpb25Db3VudCIsImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCIsIkluZmluaXR5IiwibGl2ZVN5bmNEdXJhdGlvbiIsImxpdmVNYXhMYXRlbmN5RHVyYXRpb24iLCJsaXZlRHVyYXRpb25JbmZpbml0eSIsImxpdmVCYWNrQnVmZmVyTGVuZ3RoIiwibWF4TWF4QnVmZmVyTGVuZ3RoIiwiZW5hYmxlV29ya2VyIiwiZW5hYmxlU29mdHdhcmVBRVMiLCJtYW5pZmVzdExvYWRpbmdUaW1lT3V0IiwibWFuaWZlc3RMb2FkaW5nTWF4UmV0cnkiLCJtYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5IiwibWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0Iiwic3RhcnRMZXZlbCIsImxldmVsTG9hZGluZ1RpbWVPdXQiLCJsZXZlbExvYWRpbmdNYXhSZXRyeSIsImxldmVsTG9hZGluZ1JldHJ5RGVsYXkiLCJsZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQiLCJmcmFnTG9hZGluZ1RpbWVPdXQiLCJmcmFnTG9hZGluZ01heFJldHJ5IiwiZnJhZ0xvYWRpbmdSZXRyeURlbGF5IiwiZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQiLCJzdGFydEZyYWdQcmVmZXRjaCIsImZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kIiwiZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQiLCJhcHBlbmRFcnJvck1heFJldHJ5IiwibG9hZGVyIiwiWGhyTG9hZGVyIiwiZkxvYWRlciIsInBMb2FkZXIiLCJ4aHJTZXR1cCIsImxpY2Vuc2VYaHJTZXR1cCIsImFickNvbnRyb2xsZXIiLCJBYnJDb250cm9sbGVyIiwiYnVmZmVyQ29udHJvbGxlciIsIkJ1ZmZlckNvbnRyb2xsZXIiLCJjYXBMZXZlbENvbnRyb2xsZXIiLCJDYXBMZXZlbENvbnRyb2xsZXIiLCJmcHNDb250cm9sbGVyIiwiRlBTQ29udHJvbGxlciIsInN0cmV0Y2hTaG9ydFZpZGVvVHJhY2siLCJtYXhBdWRpb0ZyYW1lc0RyaWZ0IiwiZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eSIsImFickV3bWFGYXN0TGl2ZSIsImFickV3bWFTbG93TGl2ZSIsImFickV3bWFGYXN0Vm9EIiwiYWJyRXdtYVNsb3dWb0QiLCJhYnJFd21hRGVmYXVsdEVzdGltYXRlIiwiYWJyQmFuZFdpZHRoRmFjdG9yIiwiYWJyQmFuZFdpZHRoVXBGYWN0b3IiLCJhYnJNYXhXaXRoUmVhbEJpdHJhdGUiLCJtYXhTdGFydmF0aW9uRGVsYXkiLCJtYXhMb2FkaW5nRGVsYXkiLCJtaW5BdXRvQml0cmF0ZSIsImVtZUVuYWJsZWQiLCJ3aWRldmluZUxpY2Vuc2VVcmwiLCJyZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jIiwicmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIiwic3VidGl0bGVTdHJlYW1Db250cm9sbGVyIiwiU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIiwic3VidGl0bGVUcmFja0NvbnRyb2xsZXIiLCJTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciIsInRpbWVsaW5lQ29udHJvbGxlciIsIlRpbWVsaW5lQ29udHJvbGxlciIsImN1ZUhhbmRsZXIiLCJlbmFibGVDRUE3MDhDYXB0aW9ucyIsImVuYWJsZVdlYlZUVCIsImNhcHRpb25zVGV4dFRyYWNrMUxhYmVsIiwiY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlIiwiY2FwdGlvbnNUZXh0VHJhY2syTGFiZWwiLCJjYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGUiLCJhdWRpb1N0cmVhbUNvbnRyb2xsZXIiLCJBdWRpb1N0cmVhbUNvbnRyb2xsZXIiLCJhdWRpb1RyYWNrQ29udHJvbGxlciIsIkF1ZGlvVHJhY2tDb250cm9sbGVyIiwiZW1lQ29udHJvbGxlciIsIkVNRUNvbnRyb2xsZXIiLCJ3aW5kb3ciLCJwZXJmb3JtYW5jZSIsImhscyIsIkV2ZW50IiwiRlJBR19MT0FESU5HIiwiRlJBR19MT0FERUQiLCJGUkFHX0JVRkZFUkVEIiwiRVJST1IiLCJsYXN0TG9hZGVkRnJhZ0xldmVsIiwiX25leHRBdXRvTGV2ZWwiLCJ0aW1lciIsIl9id0VzdGltYXRvciIsIm9uQ2hlY2siLCJfYWJhbmRvblJ1bGVzQ2hlY2siLCJiaW5kIiwiY2xlYXJUaW1lciIsIkV2ZW50SGFuZGxlciIsInByb3RvdHlwZSIsImRlc3Ryb3kiLCJjYWxsIiwiZGF0YSIsImZyYWciLCJ0eXBlIiwiZnJhZ0N1cnJlbnQiLCJzZXRJbnRlcnZhbCIsImNvbmZpZyIsImxldmVsIiwiaXNMaXZlIiwibGV2ZWxzIiwiZGV0YWlscyIsImxpdmUiLCJld21hRmFzdCIsImV3bWFTbG93IiwiRXdtYUJhbmRXaWR0aEVzdGltYXRvciIsInZpZGVvIiwibWVkaWEiLCJtaW5BdXRvTGV2ZWwiLCJzdGF0cyIsImFib3J0ZWQiLCJsb2dnZXIiLCJ3YXJuIiwicGF1c2VkIiwicGxheWJhY2tSYXRlIiwicmVhZHlTdGF0ZSIsImF1dG9MZXZlbCIsInJlcXVlc3REZWxheSIsIm5vdyIsInRyZXF1ZXN0IiwiTWF0aCIsImFicyIsImR1cmF0aW9uIiwibG9hZFJhdGUiLCJtYXgiLCJidyIsImxvYWRlZCIsImxldmVsQml0cmF0ZSIsInJlYWxCaXRyYXRlIiwiYml0cmF0ZSIsImV4cGVjdGVkTGVuIiwidG90YWwiLCJyb3VuZCIsInBvcyIsImN1cnJlbnRUaW1lIiwiZnJhZ0xvYWRlZERlbGF5IiwiYnVmZmVyU3RhcnZhdGlvbkRlbGF5IiwiQnVmZmVySGVscGVyIiwiYnVmZmVySW5mbyIsImVuZCIsImZyYWdMZXZlbE5leHRMb2FkZWREZWxheSIsIm5leHRMb2FkTGV2ZWwiLCJsZXZlbE5leHRCaXRyYXRlIiwidG9GaXhlZCIsInNhbXBsZSIsImFib3J0IiwidHJpZ2dlciIsIkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCIsIk51bWJlciIsImlzRmluaXRlIiwic24iLCJsb2FkZWRCeXRlcyIsImJ5dGVzIiwibG9hZGVkRHVyYXRpb24iLCJiaXRyYXRlVGVzdCIsInRwYXJzZWQiLCJ0YnVmZmVyZWQiLCJ0bG9hZCIsIm9uRnJhZ0J1ZmZlcmVkIiwiZnJhZ0xvYWRpbmdQcm9jZXNzaW5nTXMiLCJsb2ciLCJ0Zmlyc3QiLCJid0VzdGltYXRlIiwiZ2V0RXN0aW1hdGUiLCJiaXRyYXRlVGVzdERlbGF5IiwiRXJyb3JEZXRhaWxzIiwiRlJBR19MT0FEX0VSUk9SIiwiRlJBR19MT0FEX1RJTUVPVVQiLCJjbGVhckludGVydmFsIiwiY3VycmVudExldmVsIiwiY3VycmVudEZyYWdEdXJhdGlvbiIsImN1cnJlbnRCdyIsIm1heEF1dG9MZXZlbCIsIm1heEZldGNoRHVyYXRpb24iLCJid0ZhY3RvciIsImJ3VXBGYWN0b3IiLCJpIiwibGV2ZWxJbmZvIiwibGV2ZWxEZXRhaWxzIiwiYXZnRHVyYXRpb24iLCJ0b3RhbGR1cmF0aW9uIiwiZnJhZ21lbnRzIiwibGVuZ3RoIiwiYWRqdXN0ZWRidyIsImZldGNoRHVyYXRpb24iLCJ0cmFjZSIsImZvcmNlZEF1dG9MZXZlbCIsImJ3RXN0aW1hdG9yIiwiY2FuRXN0aW1hdGUiLCJuZXh0QUJSQXV0b0xldmVsIiwiX25leHRBQlJBdXRvTGV2ZWwiLCJtaW4iLCJuZXh0TGV2ZWwiLCJhdmdidyIsImJlc3RMZXZlbCIsIl9maW5kQmVzdExldmVsIiwiTGV2ZWxIZWxwZXIiLCJUSUNLX0lOVEVSVkFMIiwiZnJhZ21lbnRUcmFja2VyIiwiTUVESUFfQVRUQUNIRUQiLCJNRURJQV9ERVRBQ0hJTkciLCJBVURJT19UUkFDS1NfVVBEQVRFRCIsIkFVRElPX1RSQUNLX1NXSVRDSElORyIsIkFVRElPX1RSQUNLX0xPQURFRCIsIktFWV9MT0FERUQiLCJGUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UIiwiRlJBR19QQVJTSU5HX0RBVEEiLCJGUkFHX1BBUlNFRCIsIkJVRkZFUl9SRVNFVCIsIkJVRkZFUl9DUkVBVEVEIiwiQlVGRkVSX0FQUEVOREVEIiwiQlVGRkVSX0ZMVVNIRUQiLCJJTklUX1BUU19GT1VORCIsImF1ZGlvQ29kZWNTd2FwIiwiX3N0YXRlIiwiU3RhdGUiLCJTVE9QUEVEIiwiaW5pdFBUUyIsIndhaXRpbmdGcmFnbWVudCIsInZpZGVvVHJhY2tDQyIsImRlbXV4ZXJJZCIsImlkIiwiY2MiLCJzdGF0ZSIsIldBSVRJTkdfSU5JVF9QVFMiLCJ0aWNrIiwidHJhY2tzIiwibGFzdEN1cnJlbnRUaW1lIiwic3RvcExvYWQiLCJmcmFnTG9hZEVycm9yIiwiSURMRSIsIlNUQVJUSU5HIiwibmV4dExvYWRQb3NpdGlvbiIsInRyYWNrIiwidHJhY2tEZXRhaWxzIiwiUEFVU0VEIiwiQlVGRkVSX0ZMVVNISU5HIiwiV0FJVElOR19UUkFDSyIsImxvYWRlZG1ldGFkYXRhIiwic3RhcnRGcmFnUmVxdWVzdGVkIiwibWVkaWFCdWZmZXIiLCJ2aWRlb0J1ZmZlciIsIm1haW5CdWZmZXJJbmZvIiwiYnVmZmVyTGVuIiwibGVuIiwiYnVmZmVyRW5kIiwiZnJhZ1ByZXZpb3VzIiwibWF4Q29uZmlnQnVmZmVyIiwibWF4QnVmTGVuIiwiYXVkaW9Td2l0Y2giLCJ0cmFja0lkIiwiX3N0cmVhbUVuZGVkIiwiQlVGRkVSX0VPUyIsIkVOREVEIiwiZnJhZ0xlbiIsInN0YXJ0IiwiUFRTS25vd24iLCJuZXh0U3RhcnQiLCJpbml0U2VnbWVudCIsImxvYWRJZHgiLCJmcmFnTG9hZElkeCIsIm5leHRCdWZmZXJlZCIsImZvdW5kRnJhZyIsImZyYWdOZXh0IiwiZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0IiwiY2FuZGlkYXRlIiwiY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlIiwiQmluYXJ5U2VhcmNoIiwic2VhcmNoIiwiZW5kU04iLCJzdGFydFNOIiwiZW5jcnlwdGVkIiwiS0VZX0xPQURJTkciLCJnZXRTdGF0ZSIsIkZyYWdtZW50U3RhdGUiLCJOT1RfTE9BREVEIiwiRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkiLCJyZXRyeURhdGUiLCJpc1NlZWtpbmciLCJzZWVraW5nIiwid2FpdGluZ0ZyYWciLCJ3YWl0aW5nRnJhZ0NDIiwib25GcmFnTG9hZGVkIiwiUEFSU0lORyIsIlBBUlNFRCIsIm9udnNlZWtpbmciLCJvbk1lZGlhU2Vla2luZyIsIm9udmVuZGVkIiwib25NZWRpYUVuZGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsInN0YXJ0TG9hZCIsImVuZGVkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9udnNlZWtlZCIsImF1ZGlvVHJhY2tzIiwiYWx0QXVkaW8iLCJ1cmwiLCJkZW11eGVyIiwibmV3RGV0YWlscyIsInNsaWRpbmciLCJjdXJEZXRhaWxzIiwibWVyZ2VEZXRhaWxzIiwic3RhcnRUaW1lT2Zmc2V0IiwiZnJhZ0xvYWRlZCIsImF1ZGlvQ29kZWMiLCJwYXlsb2FkIiwiYXBwZW5kZWQiLCJEZW11eGVyIiwiaW5pdFNlZ21lbnREYXRhIiwicGVuZGluZ0J1ZmZlcmluZyIsImFjY3VyYXRlVGltZU9mZnNldCIsInB1c2giLCJmcmFnTmV3IiwiYXVkaW8iLCJsZXZlbENvZGVjIiwiY29kZWMiLCJCVUZGRVJfQ09ERUNTIiwiY29udGFpbmVyIiwiYXBwZW5kT2JqIiwicGFyZW50IiwiY29udGVudCIsInBlbmRpbmdEYXRhIiwiQlVGRkVSX0FQUEVORElORyIsImVuZFBUUyIsInN0YXJ0UFRTIiwiZW5kRFRTIiwic3RhcnREVFMiLCJhZGRFbGVtZW50YXJ5U3RyZWFtIiwiRnJhZ21lbnQiLCJFbGVtZW50YXJ5U3RyZWFtVHlwZXMiLCJBVURJTyIsIm5iIiwidXBkYXRlRnJhZ1BUU0RUUyIsImFwcGVuZE9uQnVmZmVyRmx1c2giLCJzdGFydE9mZnNldCIsImVuZE9mZnNldCIsIlBPU0lUSVZFX0lORklOSVRZIiwiQVVESU9fVFJBQ0tfU1dJVENIRUQiLCJFcnJvclR5cGVzIiwiTUVESUFfRVJST1IiLCJmYXRhbCIsImRhdGExIiwiZGF0YTIiLCJmb3JFYWNoIiwiYnVmZmVyIiwiX2NoZWNrQXBwZW5kZWRQYXJzZWQiLCJhdWRpb1RyYWNrIiwicGVuZGluZyIsIlRpbWVSYW5nZXMiLCJ0b1N0cmluZyIsImJ1ZmZlcmVkIiwibG9hZEVycm9yIiwiZGVsYXkiLCJwb3ciLCJlcnJvciIsIkFVRElPX1RSQUNLX0xPQURfRVJST1IiLCJBVURJT19UUkFDS19MT0FEX1RJTUVPVVQiLCJLRVlfTE9BRF9FUlJPUiIsIktFWV9MT0FEX1RJTUVPVVQiLCJCVUZGRVJfRlVMTF9FUlJPUiIsIm1lZGlhQnVmZmVyZWQiLCJpc0J1ZmZlcmVkIiwibmV4dFN0YXRlIiwicHJldmlvdXNTdGF0ZSIsIkJhc2VTdHJlYW1Db250cm9sbGVyIiwiTUFOSUZFU1RfTE9BRElORyIsIk1BTklGRVNUX1BBUlNFRCIsIkxFVkVMX0xPQURFRCIsIl90cmFja0lkIiwiX3NlbGVjdERlZmF1bHRUcmFjayIsInRyYWNrSWRCbGFja2xpc3QiLCJPYmplY3QiLCJjcmVhdGUiLCJhdWRpb0dyb3VwSWQiLCJoYXNJbnRlcnZhbCIsInVwZGF0ZVBlcmlvZE1zIiwidGFyZ2V0ZHVyYXRpb24iLCJncm91cElkIiwiYXVkaW9Hcm91cElkcyIsInVybElkIiwiX3NlbGVjdEluaXRpYWxBdWRpb1RyYWNrIiwiTkVUV09SS19FUlJPUiIsImNvbnRleHQiLCJfaGFuZGxlTG9hZEVycm9yIiwibmV3SWQiLCJfbG9hZFRyYWNrRGV0YWlsc0lmTmVlZGVkIiwiX3VwZGF0ZVRyYWNrIiwiY3VycmVudEF1ZGlvVHJhY2siLCJuYW1lIiwiZGVmYXVsdFRyYWNrcyIsImZpbHRlciIsImRlZmF1bHQiLCJ0cmFja0ZvdW5kIiwidHJhdmVyc2VUcmFja3MiLCJfc2V0QXVkaW9UcmFjayIsIl9uZWVkc1RyYWNrTG9hZGluZyIsIkFVRElPX1RSQUNLX0xPQURJTkciLCJwcmV2aW91c0lkIiwibGFuZ3VhZ2UiLCJuZXdUcmFjayIsIlRhc2tMb29wIiwiV0FJVElOR19MRVZFTCIsInJlbW92ZUZyYWdtZW50IiwiY2xlYXJOZXh0VGljayIsImJhY2t0cmFja2VkIiwiZnJhZ1N0YXRlIiwiUEFSVElBTCIsIk9LIiwidG9sZXJhbmNlIiwiZnJhZ1N0YXJ0T2Zmc2V0IiwiZnJhZ0VuZE9mZnNldCIsIk1lZGlhU291cmNlIiwiTUVESUFfQVRUQUNISU5HIiwiTEVWRUxfUFRTX1VQREFURUQiLCJMRVZFTF9VUERBVEVEIiwiX21zRHVyYXRpb24iLCJfbGV2ZWxEdXJhdGlvbiIsIl9sZXZlbFRhcmdldER1cmF0aW9uIiwiX2xpdmUiLCJfb2JqZWN0VXJsIiwiYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCIsIm9uc2J1ZSIsIm9uU0JVcGRhdGVFbmQiLCJvbnNiZSIsIm9uU0JVcGRhdGVFcnJvciIsInBlbmRpbmdUcmFja3MiLCJhdWRpb0J1ZmZlciIsInNvdXJjZUJ1ZmZlciIsImRlbHRhIiwidGltZXN0YW1wT2Zmc2V0IiwidXBkYXRpbmciLCJlcnIiLCJhdWRpb1RpbWVzdGFtcE9mZnNldCIsIm1zIiwibWVkaWFTb3VyY2UiLCJvbm1zbyIsIm9uTWVkaWFTb3VyY2VPcGVuIiwib25tc2UiLCJvbk1lZGlhU291cmNlRW5kZWQiLCJvbm1zYyIsIm9uTWVkaWFTb3VyY2VDbG9zZSIsInNyYyIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImVuZE9mU3RyZWFtIiwibWVzc2FnZSIsInJldm9rZU9iamVjdFVSTCIsInJlbW92ZUF0dHJpYnV0ZSIsImxvYWQiLCJmbHVzaFJhbmdlIiwic2VnbWVudHMiLCJNRURJQV9ERVRBQ0hFRCIsImNoZWNrUGVuZGluZ1RyYWNrcyIsInBlbmRpbmdUcmFja3NDb3VudCIsImtleXMiLCJjcmVhdGVTb3VyY2VCdWZmZXJzIiwiZG9BcHBlbmRpbmciLCJfbmVlZHNGbHVzaCIsImRvRmx1c2giLCJfbmVlZHNFb3MiLCJjaGVja0VvcyIsImFwcGVuZGluZyIsInJlZHVjZSIsImNvdW50ZXIiLCJzZWdtZW50IiwidGltZVJhbmdlcyIsInN0cmVhbVR5cGUiLCJfcGF1c2VkIiwic3RhcnRUaW1lIiwicGxheSIsImVuZFRpbWUiLCJ1cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbiIsImZsdXNoTGl2ZUJhY2tCdWZmZXIiLCJldmVudCIsIkJVRkZFUl9BUFBFTkRJTkdfRVJST1IiLCJzYiIsInJlbW92ZVNvdXJjZUJ1ZmZlciIsInRyYWNrTmFtZSIsIm1pbWVUeXBlIiwiYWRkU291cmNlQnVmZmVyIiwiY29kZSIsIkJVRkZFUl9BRERfQ09ERUNfRVJST1IiLCJkYXRhVHlwZSIsInNib2JqIiwiZSIsImZsdXNoQnVmZmVyQ291bnRlciIsImJ1ZmZlclR5cGVzIiwidGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uIiwiaW5kZXgiLCJidWZmZXJUeXBlIiwicmVtb3ZlQnVmZmVyUmFuZ2UiLCJhdmVyYWdldGFyZ2V0ZHVyYXRpb24iLCJyYW5nZSIsImZsdXNoQnVmZmVyIiwic2hpZnQiLCJhcHBlbmRCdWZmZXIiLCJhcHBlbmRFcnJvciIsInVuc2hpZnQiLCJCVUZGRVJfQVBQRU5EX0VSUk9SIiwidHlwZUluIiwiYnVmU3RhcnQiLCJidWZFbmQiLCJyZW1vdmVTdGFydCIsInJlbW92ZUVuZCIsInJlbW92ZSIsIkZQU19EUk9QX0xFVkVMX0NBUFBJTkciLCJhdXRvTGV2ZWxDYXBwaW5nIiwiZmlyc3RMZXZlbCIsInJlc3RyaWN0ZWRMZXZlbHMiLCJfc3RvcENhcHBpbmciLCJpc0xldmVsQWxsb3dlZCIsImRyb3BwZWRMZXZlbCIsIkhUTUxWaWRlb0VsZW1lbnQiLCJfc3RhcnRDYXBwaW5nIiwibGV2ZWxzTGVuZ3RoIiwiZ2V0TWF4TGV2ZWwiLCJzdHJlYW1Db250cm9sbGVyIiwibmV4dExldmVsU3dpdGNoIiwiY2FwTGV2ZWxJbmRleCIsInZhbGlkTGV2ZWxzIiwiZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZSIsIm1lZGlhV2lkdGgiLCJtZWRpYUhlaWdodCIsImRldGVjdFBsYXllclNpemUiLCJ3aWR0aCIsImNsaWVudFdpZHRoIiwib2Zmc2V0V2lkdGgiLCJjb250ZW50U2NhbGVGYWN0b3IiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJpbmRleE9mIiwiYXRHcmVhdGVzdEJhbmRpd2R0aCIsImN1ckxldmVsIiwibWF4TGV2ZWxJbmRleCIsInBpeGVsUmF0aW8iLCJkZXZpY2VQaXhlbFJhdGlvIiwiWE1MSHR0cFJlcXVlc3QiLCJNQVhfTElDRU5TRV9SRVFVRVNUX0ZBSUxVUkVTIiwiS2V5U3lzdGVtcyIsIldJREVWSU5FIiwiUExBWVJFQURZIiwiY3JlYXRlV2lkZXZpbmVNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zIiwiYXVkaW9Db2RlY3MiLCJ2aWRlb0NvZGVjcyIsImRybVN5c3RlbU9wdGlvbnMiLCJiYXNlQ29uZmlnIiwidmlkZW9DYXBhYmlsaXRpZXMiLCJjb250ZW50VHlwZSIsImdldFN1cHBvcnRlZE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMiLCJrZXlTeXN0ZW0iLCJFcnJvciIsIl93aWRldmluZUxpY2Vuc2VVcmwiLCJfbGljZW5zZVhoclNldHVwIiwiX2VtZUVuYWJsZWQiLCJfcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIiwiX21lZGlhS2V5c0xpc3QiLCJfbWVkaWEiLCJfaGFzU2V0TWVkaWFLZXlzIiwiX2lzTWVkaWFFbmNyeXB0ZWQiLCJfcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQiLCJLRVlfU1lTVEVNX0VSUk9SIiwiS0VZX1NZU1RFTV9MSUNFTlNFX1JFUVVFU1RfRkFJTEVEIiwibWVkaWFLZXlTeXN0ZW1Db25maWdzIiwidGhlbiIsIm1lZGlhS2V5U3lzdGVtQWNjZXNzIiwiX29uTWVkaWFLZXlTeXN0ZW1BY2Nlc3NPYnRhaW5lZCIsImNhdGNoIiwibWVkaWFLZXlzTGlzdEl0ZW0iLCJtZWRpYUtleXMiLCJtZWRpYUtleXNTZXNzaW9uIiwibWVkaWFLZXlzU2Vzc2lvbkluaXRpYWxpemVkIiwibWVkaWFLZXlTeXN0ZW1Eb21haW4iLCJjcmVhdGVNZWRpYUtleXMiLCJfb25NZWRpYUtleXNDcmVhdGVkIiwiY3JlYXRlU2Vzc2lvbiIsIl9vbk5ld01lZGlhS2V5U2Vzc2lvbiIsImtleVNlc3Npb24iLCJzZXNzaW9uSWQiLCJfb25LZXlTZXNzaW9uTWVzc2FnZSIsIl9yZXF1ZXN0TGljZW5zZSIsInVwZGF0ZSIsImluaXREYXRhVHlwZSIsImluaXREYXRhIiwiX21lZGlhRW5jcnlwdGlvbkluaXREYXRhVHlwZSIsIl9tZWRpYUVuY3J5cHRpb25Jbml0RGF0YSIsIl9hdHRlbXB0U2V0TWVkaWFLZXlzIiwiX2dlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uIiwia2V5c0xpc3RJdGVtIiwiS0VZX1NZU1RFTV9OT19LRVlTIiwic2V0TWVkaWFLZXlzIiwiS0VZX1NZU1RFTV9OT19BQ0NFU1MiLCJLRVlfU1lTVEVNX05PX1NFU1NJT04iLCJnZW5lcmF0ZVJlcXVlc3QiLCJrZXlNZXNzYWdlIiwiY2FsbGJhY2siLCJ4aHIiLCJvcGVuIiwicmVzcG9uc2VUeXBlIiwib25yZWFkeXN0YXRlY2hhbmdlIiwiX29uTGljZW5zZVJlcXVlc3RSZWFkeVN0YWdlQ2hhbmdlIiwic3RhdHVzIiwicmVzcG9uc2UiLCJzdGF0dXNUZXh0IiwiYXR0ZW1wdHNMZWZ0IiwiY2hhbGxlbmdlIiwiZ2V0TGljZW5zZVNlcnZlclVybCIsIl9jcmVhdGVMaWNlbnNlWGhyIiwic2VuZCIsIl9nZW5lcmF0ZUxpY2Vuc2VSZXF1ZXN0Q2hhbGxlbmdlIiwiX29uTWVkaWFFbmNyeXB0ZWQiLCJtYXAiLCJ2aWRlb0NvZGVjIiwiX2F0dGVtcHRLZXlTeXN0ZW1BY2Nlc3MiLCJpc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlIiwiZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkiLCJjaGVja0ZQU0ludGVydmFsIiwiZGVjb2RlZEZyYW1lcyIsImRyb3BwZWRGcmFtZXMiLCJsYXN0VGltZSIsImN1cnJlbnRQZXJpb2QiLCJjdXJyZW50RHJvcHBlZCIsImxhc3REcm9wcGVkRnJhbWVzIiwiY3VycmVudERlY29kZWQiLCJsYXN0RGVjb2RlZEZyYW1lcyIsImRyb3BwZWRGUFMiLCJGUFNfRFJPUCIsInRvdGFsRHJvcHBlZEZyYW1lcyIsInZpZGVvUGxheWJhY2tRdWFsaXR5IiwiY2hlY2tGUFMiLCJ0b3RhbFZpZGVvRnJhbWVzIiwiZHJvcHBlZFZpZGVvRnJhbWVzIiwid2Via2l0RGVjb2RlZEZyYW1lQ291bnQiLCJ3ZWJraXREcm9wcGVkRnJhbWVDb3VudCIsImZpbmRGcmFnbWVudEJ5UERUIiwiZmluZEZyYWdtZW50QnlQVFMiLCJwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0IiwiUERUVmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJwcm9ncmFtRGF0ZVRpbWUiLCJlbmRQcm9ncmFtRGF0ZVRpbWUiLCJzZWciLCJkZWx0YVBUUyIsInBkdEJ1ZmZlckVuZCIsIkFQUEVORElORyIsIkZyYWdtZW50VHJhY2tlciIsImJ1ZmZlclBhZGRpbmciLCJwb3NpdGlvbiIsImxldmVsVHlwZSIsImJ1ZmZlcmVkRnJhZ3MiLCJmcmFnbWVudEVudGl0eSIsImtleSIsImJvZHkiLCJidWZmZXJlZEZyYWdLZXkiLCJwb3AiLCJlbGVtZW50YXJ5U3RyZWFtIiwidGltZVJhbmdlIiwiZnJhZ21lbnRUaW1lcyIsInRpbWUiLCJlc0RhdGEiLCJpc1RpbWVCdWZmZXJlZCIsImZyYWdtZW50IiwiZnJhZ0tleSIsImdldEZyYWdtZW50S2V5IiwiaGFzRWxlbWVudGFyeVN0cmVhbSIsImdldEJ1ZmZlcmVkVGltZXMiLCJmcmFnbWVudFBhcnRpYWwiLCJwYXJ0aWFsIiwidGltZVBhZGRpbmciLCJiZXN0RnJhZ21lbnQiLCJiZXN0T3ZlcmxhcCIsImlzUGFydGlhbCIsImRldGVjdEV2aWN0ZWRGcmFnbWVudHMiLCJkZXRlY3RQYXJ0aWFsRnJhZ21lbnRzIiwic3RhbGxEZWJvdW5jZUludGVydmFsIiwianVtcFRocmVzaG9sZCIsIkdhcENvbnRyb2xsZXIiLCJzdGFsbFJlcG9ydGVkIiwidG5vdyIsInN0YWxsZWQiLCJudWRnZVJldHJ5Iiwic3RhbGxlZER1cmF0aW9uIiwiX3JlcG9ydFN0YWxsIiwiX3RyeUZpeEJ1ZmZlclN0YWxsIiwiZ2V0UGFydGlhbEZyYWdtZW50IiwiX3RyeVNraXBCdWZmZXJIb2xlIiwiX3RyeU51ZGdlQnVmZmVyIiwiQlVGRkVSX1NUQUxMRURfRVJST1IiLCJsYXN0RW5kVGltZSIsIkJVRkZFUl9TRUVLX09WRVJfSE9MRSIsInJlYXNvbiIsInRhcmdldFRpbWUiLCJCVUZGRVJfTlVER0VfT05fU1RBTEwiLCJJRDNUcmFja0NvbnRyb2xsZXIiLCJGUkFHX1BBUlNJTkdfTUVUQURBVEEiLCJpZDNUcmFjayIsInRleHRUcmFja3MiLCJ0ZXh0VHJhY2siLCJraW5kIiwibGFiZWwiLCJhZGRUZXh0VHJhY2siLCJzYW1wbGVzIiwiZ2V0SUQzVHJhY2siLCJtb2RlIiwiQ3VlIiwiV2ViS2l0RGF0YUN1ZSIsIlZUVEN1ZSIsIlRleHRUcmFja0N1ZSIsImZyYW1lcyIsIklEMyIsImdldElEM0ZyYW1lcyIsInB0cyIsImoiLCJmcmFtZSIsImlzVGltZVN0YW1wRnJhbWUiLCJjdWUiLCJ2YWx1ZSIsImFkZEN1ZSIsImNocm9tZU9yRmlyZWZveCIsIkxldmVsQ29udHJvbGxlciIsIk1BTklGRVNUX0xPQURFRCIsImNhbmxvYWQiLCJjdXJyZW50TGV2ZWxJbmRleCIsIm1hbnVhbExldmVsSW5kZXgiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidG9Mb3dlckNhc2UiLCJjbGVhclRpbWVvdXQiLCJfbGV2ZWxzIiwibGV2ZWxSZXRyeUNvdW50IiwibG9hZExldmVsIiwiYml0cmF0ZVN0YXJ0IiwibGV2ZWxTZXQiLCJsZXZlbEZyb21TZXQiLCJ2aWRlb0NvZGVjRm91bmQiLCJhdWRpb0NvZGVjRm91bmQiLCJhdHRyaWJ1dGVzIiwiYXR0cnMiLCJmcmFnbWVudEVycm9yIiwiU1VCVElUTEVTIiwic29ydCIsImEiLCJiIiwiX2ZpcnN0TGV2ZWwiLCJzb21lIiwidCIsIk1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IiLCJuZXdMZXZlbCIsImxldmVsUHJvcGVydGllcyIsIkxFVkVMX1NXSVRDSElORyIsIkxFVkVMX0xPQURJTkciLCJPVEhFUl9FUlJPUiIsIkxFVkVMX1NXSVRDSF9FUlJPUiIsImxldmVsRXJyb3IiLCJsZXZlbEluZGV4IiwiTEVWRUxfTE9BRF9FUlJPUiIsIkxFVkVMX0xPQURfVElNRU9VVCIsIlJFTVVYX0FMTE9DX0VSUk9SIiwicmVjb3ZlckxldmVsIiwiZXJyb3JFdmVudCIsImVycm9yRGV0YWlscyIsInJlZHVuZGFudExldmVscyIsInNldFRpbWVvdXQiLCJsZXZlbFJldHJ5IiwibmV4dEF1dG9MZXZlbCIsInJlbG9hZEludGVydmFsIiwibGV2ZWxPYmplY3QiLCJzZXRMZXZlbEludGVybmFsIiwiX3N0YXJ0TGV2ZWwiLCJjb25maWdTdGFydExldmVsIiwiYWRkR3JvdXBJZCIsInVwZGF0ZVBUUyIsIm1lcmdlU3VidGl0bGVQbGF5bGlzdHMiLCJtYXBGcmFnbWVudEludGVyc2VjdGlvbiIsImFkanVzdFNsaWRpbmciLCJjb21wdXRlUmVsb2FkSW50ZXJ2YWwiLCJ0ZXh0R3JvdXBJZHMiLCJmcm9tSWR4IiwidG9JZHgiLCJmcmFnRnJvbSIsImZyYWdUbyIsImZyYWdUb1BUUyIsIm1heFN0YXJ0UFRTIiwiZHJpZnQiLCJmcmFnSWR4Iiwib2xkRGV0YWlscyIsImNjT2Zmc2V0IiwiUFRTRnJhZyIsIm9sZEZyYWciLCJuZXdGcmFnIiwiZHJvcHBlZCIsIm5ld0ZyYWdtZW50cyIsIm9sZFBsYXlsaXN0IiwibmV3UGxheWxpc3QiLCJyZWZlcmVuY2VTdGFydCIsImxhc3RJbmRleCIsImZyYWdzIiwiaW50ZXJzZWN0aW9uRm4iLCJvbGRGcmFnbWVudHMiLCJjdXJyZW50UGxheWxpc3QiLCJsYXN0UmVxdWVzdFRpbWUiLCJtaW5SZWxvYWRJbnRlcnZhbCIsIlN0cmVhbUNvbnRyb2xsZXIiLCJnYXBDb250cm9sbGVyIiwiZm9yY2VTdGFydExvYWQiLCJfZG9UaWNrSWRsZSIsIl9jaGVja0J1ZmZlciIsIl9jaGVja0ZyYWdtZW50Q2hhbmdlZCIsImxldmVsTGFzdExvYWRlZCIsIl9mZXRjaFBheWxvYWRPckVvcyIsIl9lbnN1cmVGcmFnbWVudEF0TGl2ZVBvaW50IiwiX2ZpbmRGcmFnbWVudCIsIl9sb2FkS2V5IiwiX2xvYWRGcmFnbWVudCIsIm1heExhdGVuY3kiLCJsaXZlU3luY1Bvc2l0aW9uIiwiY29tcHV0ZUxpdmVQb3NpdGlvbiIsImhhc1Byb2dyYW1EYXRlVGltZSIsInRhcmdldFNOIiwibG9va3VwVG9sZXJhbmNlIiwiY3VyU05JZHgiLCJzYW1lTGV2ZWwiLCJwcmV2RnJhZyIsIm5leHRGcmFnIiwiYXV0b0xldmVsRW5hYmxlZCIsIl9yZWR1Y2VNYXhCdWZmZXJMZW5ndGgiLCJnZXRCdWZmZXJlZEZyYWciLCJQbGF5bGlzdExvYWRlciIsIkxldmVsVHlwZSIsIk1BSU4iLCJmcmFnUGxheWluZ0N1cnJlbnQiLCJmcmFnUGxheWluZyIsIkZSQUdfQ0hBTkdFRCIsImZyYWdQbGF5aW5nTGV2ZWwiLCJMRVZFTF9TV0lUQ0hFRCIsImltbWVkaWF0ZVN3aXRjaCIsInByZXZpb3VzbHlQYXVzZWQiLCJwYXVzZSIsImZsdXNoTWFpbkJ1ZmZlciIsImZldGNoZGVsYXkiLCJuZXh0QnVmZmVyZWRGcmFnIiwibmV4dExldmVsSWQiLCJmcmFnTGFzdEticHMiLCJmb2xsb3dpbmdCdWZmZXJlZEZyYWciLCJmbHVzaFNjb3BlIiwib25NZWRpYVNlZWtlZCIsInJlbW92ZUFsbEZyYWdtZW50cyIsImFhYyIsImhlYWFjIiwiYXVkaW9Db2RlY1N3aXRjaCIsIm5ld0xldmVsSWQiLCJsYXN0TGV2ZWwiLCJfZ2V0QXVkaW9Db2RlYyIsInVhIiwibWV0YWRhdGEiLCJjaGFubmVsQ291bnQiLCJoYXNBdWRpbyIsImhhc1ZpZGVvIiwiVklERU8iLCJtZWRpYVRyYWNrIiwiYWx0ZXJuYXRlIiwibWluTGVuZ3RoIiwiX3NlZWtUb1N0YXJ0UG9zIiwiaW1tZWRpYXRlTGV2ZWxTd2l0Y2hFbmQiLCJwb2xsIiwidGFyZ2V0TGF0ZW5jeSIsIlNUUkVBTV9TVEFURV9UUkFOU0lUSU9OIiwiX2xpdmVTeW5jUG9zaXRpb24iLCJTVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCIsIlNVQlRJVExFX1RSQUNLX1NXSVRDSCIsIlNVQlRJVExFX1RSQUNLX0xPQURFRCIsIlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VEIiwidHJhY2tzQnVmZmVyZWQiLCJjdXJyZW50VHJhY2tJZCIsImRlY3J5cHRlciIsIkRlY3J5cHRlciIsImxhc3RBVlN0YXJ0IiwiX29uTWVkaWFTZWVraW5nIiwic3VjY2VzcyIsImZyYWdTdGFydCIsImZyYWdFbmQiLCJzdWJ0aXRsZVRyYWNrcyIsImN1cnJlbnRUcmFjayIsImRlY3J5cHREYXRhIiwiZGVjcnlwdGRhdGEiLCJieXRlTGVuZ3RoIiwibWV0aG9kIiwiZGVjcnlwdCIsIml2IiwiZGVjcnlwdGVkRGF0YSIsIkZSQUdfREVDUllQVEVEIiwidHN0YXJ0IiwidGRlY3J5cHQiLCJidWZmZXJlZEluZm8iLCJfZ2V0QnVmZmVyZWQiLCJzdG9wcGVkIiwic3VidGl0bGVEaXNwbGF5IiwicXVldWVkRGVmYXVsdFRyYWNrIiwic3VidGl0bGVUcmFjayIsInRyYWNrQ2hhbmdlTGlzdGVuZXIiLCJfb25UZXh0VHJhY2tzQ2hhbmdlZCIsInVzZVRleHRUcmFja1BvbGxpbmciLCJzdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCIsInN1YnRpdGxlcyIsIl9jbGVhclJlbG9hZFRpbWVyIiwiX2xvYWRDdXJyZW50VHJhY2siLCJTVUJUSVRMRV9UUkFDS19MT0FESU5HIiwiZmlsdGVyU3VidGl0bGVUcmFja3MiLCJzbGljZSIsIm9sZFRyYWNrIiwibmV4dFRyYWNrIiwic3VidGl0bGVUcmFja0lkIiwiX3RvZ2dsZVRyYWNrTW9kZXMiLCJfc2V0U3VidGl0bGVUcmFja0ludGVybmFsIiwidGV4dFRyYWNrTGlzdCIsImNhblJldXNlVnR0VGV4dFRyYWNrIiwiaW5Vc2VUcmFjayIsIm1hbmlmZXN0VHJhY2siLCJ0ZXh0VHJhY2sxIiwidGV4dFRyYWNrMiIsImludGVyc2VjdGlvbiIsIngxIiwieDIiLCJ5MSIsInkyIiwiRlJBR19QQVJTSU5HX1VTRVJEQVRBIiwiZW5hYmxlZCIsInVucGFyc2VkVnR0RnJhZ3MiLCJjdWVSYW5nZXMiLCJjYXB0aW9uc1RyYWNrcyIsImNhcHRpb25zUHJvcGVydGllcyIsImxhbmd1YWdlQ29kZSIsImNoYW5uZWwxIiwiT3V0cHV0RmlsdGVyIiwiY2hhbm5lbDIiLCJjZWE2MDhQYXJzZXIiLCJDZWE2MDhQYXJzZXIiLCJzY3JlZW4iLCJyYW5nZXMiLCJtZXJnZWQiLCJjdWVSYW5nZSIsIm92ZXJsYXAiLCJuZXdDdWUiLCJleGlzdGluZ1RyYWNrIiwiZ2V0RXhpc3RpbmdUcmFjayIsImNyZWF0ZVRleHRUcmFjayIsImxhbmciLCJfY2xlYW5UcmFja3MiLCJsYXN0U24iLCJwcmV2Q0MiLCJ2dHRDQ3MiLCJwcmVzZW50YXRpb25PZmZzZXQiLCJuZXciLCJpblVzZVRyYWNrcyIsImNsb3NlZENhcHRpb25zIiwicmVzZXQiLCJfcGFyc2VWVFRzIiwiV2ViVlRUUGFyc2VyIiwicGFyc2UiLCJjdWVzIiwiZ2V0Q3VlQnlJZCIsInRleHRUcmFja0N1ZSIsInRleHQiLCJjY2RhdGFzIiwiZXh0cmFjdENlYTYwOERhdGEiLCJhZGREYXRhIiwiYnl0ZUFycmF5IiwiY291bnQiLCJ0bXBCeXRlIiwiY2NieXRlMSIsImNjYnl0ZTIiLCJjY1ZhbGlkIiwiY2NUeXBlIiwiYWN0dWFsQ0NCeXRlcyIsIkFFU0NyeXB0byIsInN1YnRsZSIsImFlc0lWIiwicmVtb3ZlUGFkZGluZyIsIm91dHB1dEJ5dGVzIiwicGFkZGluZ0J5dGVzIiwiRGF0YVZpZXciLCJnZXRVaW50OCIsIkFFU0RlY3J5cHRvciIsInJjb24iLCJzdWJNaXgiLCJVaW50MzJBcnJheSIsImludlN1Yk1peCIsInNCb3giLCJpbnZTQm94IiwiaW5pdFRhYmxlIiwiYXJyYXlCdWZmZXIiLCJ2aWV3IiwibmV3QXJyYXkiLCJnZXRVaW50MzIiLCJzdWJNaXgwIiwic3ViTWl4MSIsInN1Yk1peDIiLCJzdWJNaXgzIiwiaW52U3ViTWl4MCIsImludlN1Yk1peDEiLCJpbnZTdWJNaXgyIiwiaW52U3ViTWl4MyIsImQiLCJ4IiwieGkiLCJzeCIsIng0IiwieDgiLCJrZXlCdWZmZXIiLCJ1aW50OEFycmF5VG9VaW50MzJBcnJheV8iLCJzYW1lS2V5Iiwib2Zmc2V0Iiwia2V5U2l6ZSIsImtzUm93cyIsImtzUm93IiwiaW52S3NSb3ciLCJrZXlTY2hlZHVsZSIsImludktleVNjaGVkdWxlIiwic2JveCIsInByZXYiLCJ3b3JkIiwiaW5wdXRBcnJheUJ1ZmZlciIsInJlbW92ZVBLQ1M3UGFkZGluZyIsIm5Sb3VuZHMiLCJpbnZTQk9YIiwiaW5pdFZlY3RvciIsImluaXRWZWN0b3IwIiwiaW5pdFZlY3RvcjEiLCJpbml0VmVjdG9yMiIsImluaXRWZWN0b3IzIiwiaW5wdXRJbnQzMiIsIkludDMyQXJyYXkiLCJvdXRwdXRJbnQzMiIsInQwIiwidDEiLCJ0MiIsInQzIiwiczAiLCJzMSIsInMyIiwiczMiLCJpbnB1dFdvcmRzMCIsImlucHV0V29yZHMxIiwiaW5wdXRXb3JkczIiLCJpbnB1dFdvcmRzMyIsInN3YXBXb3JkIiwibmV0d29ya1RvSG9zdE9yZGVyU3dhcCIsImdsb2JhbCIsIm9ic2VydmVyIiwibG9nRW5hYmxlZCIsImJyb3dzZXJDcnlwdG8iLCJjcnlwdG8iLCJ3ZWJraXRTdWJ0bGUiLCJkaXNhYmxlV2ViQ3J5cHRvIiwiZGVjcnlwdG9yIiwiZXhwYW5kS2V5IiwiZmFzdEFlc0tleSIsIkZhc3RBRVNLZXkiLCJhZXNLZXkiLCJvbldlYkNyeXB0b0Vycm9yIiwicmVzdWx0IiwiRlJBR19ERUNSWVBUX0VSUk9SIiwiaW1wb3J0S2V5IiwiQURUUyIsIkFBQ0RlbXV4ZXIiLCJyZW11eGVyIiwiX2F1ZGlvVHJhY2siLCJzZXF1ZW5jZU51bWJlciIsImlzQUFDIiwibWFuaWZlc3RDb2RlYyIsImlucHV0VGltZVNjYWxlIiwidGltZU9mZnNldCIsImNvbnRpZ3VvdXMiLCJpZDNEYXRhIiwiZ2V0SUQzRGF0YSIsInRpbWVzdGFtcCIsImdldFRpbWVTdGFtcCIsImZyYW1lSW5kZXgiLCJzdGFtcCIsImlkM1NhbXBsZXMiLCJkdHMiLCJpc0hlYWRlciIsImluaXRUcmFja0NvbmZpZyIsImFwcGVuZEZyYW1lIiwicmVtdXgiLCJwcm9iZSIsImdldEF1ZGlvQ29uZmlnIiwiaXNIZWFkZXJQYXR0ZXJuIiwiZ2V0SGVhZGVyTGVuZ3RoIiwiZ2V0RnVsbEZyYW1lTGVuZ3RoIiwiZ2V0RnJhbWVEdXJhdGlvbiIsInBhcnNlRnJhbWVIZWFkZXIiLCJhZHRzT2JqZWN0VHlwZSIsImFkdHNTYW1wbGVpbmdJbmRleCIsImFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCIsImFkdHNDaGFuZWxDb25maWciLCJhZHRzU2FtcGxlaW5nUmF0ZXMiLCJGUkFHX1BBUlNJTkdfRVJST1IiLCJzYW1wbGVyYXRlIiwiaGVhZGVyTGVuZ3RoIiwiZnJhbWVMZW5ndGgiLCJuZXdPZmZzZXQiLCJmcmFtZUR1cmF0aW9uIiwiaGVhZGVyIiwiYWFjU2FtcGxlIiwidW5pdCIsInN1YmFycmF5IiwiRGF0ZSIsIkRlbXV4ZXJJbmxpbmUiLCJ0eXBlU3VwcG9ydGVkIiwidmVuZG9yIiwiZGlzY29udGludWl0eSIsInRyYWNrU3dpdGNoIiwiZGVmYXVsdEluaXRQVFMiLCJwdXNoRGVjcnlwdGVkIiwiVWludDhBcnJheSIsIm11eENvbmZpZyIsImRlbXV4IiwiVFNEZW11eGVyIiwiTVA0UmVtdXhlciIsIk1QNERlbXV4ZXIiLCJQYXNzVGhyb3VnaFJlbXV4ZXIiLCJNUDNEZW11eGVyIiwibXV4IiwicmVzZXRJbml0U2VnbWVudCIsInJlc2V0VGltZVN0YW1wIiwic2V0RGVjcnlwdERhdGEiLCJhcHBlbmQiLCJEZW11eGVyV29ya2VyIiwic2VsZiIsIkV2ZW50RW1pdHRlciIsImVtaXQiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsImZvcndhcmRNZXNzYWdlIiwiZXYiLCJwb3N0TWVzc2FnZSIsImNtZCIsIkpTT04iLCJvbiIsInRyYW5zZmVyYWJsZSIsIndvcmsiLCJPYnNlcnZlciIsIm1wNCIsImlzVHlwZVN1cHBvcnRlZCIsIm1wZWciLCJtcDMiLCJXb3JrZXIiLCJ3IiwicmVxdWlyZSIsIm9ud21zZyIsIm9uV29ya2VyTWVzc2FnZSIsIm9uZXJyb3IiLCJJTlRFUk5BTF9FWENFUFRJT04iLCJmaWxlbmFtZSIsImxpbmVubyIsInN0cmluZ2lmeSIsIm9iamVjdFVSTCIsInRlcm1pbmF0ZSIsInJlbW92ZUFsbExpc3RlbmVycyIsImxhc3RGcmFnIiwibmV4dFNOIiwiQXJyYXlCdWZmZXIiLCJFeHBHb2xvbWIiLCJieXRlc0F2YWlsYWJsZSIsImJpdHNBdmFpbGFibGUiLCJ3b3JraW5nQnl0ZXMiLCJhdmFpbGFibGVCeXRlcyIsInNldCIsInNraXBCeXRlcyIsImxvYWRXb3JkIiwic2l6ZSIsImJpdHMiLCJ2YWx1IiwicmVhZEJpdHMiLCJsZWFkaW5nWmVyb0NvdW50Iiwic2tpcExaIiwic2tpcEJpdHMiLCJjbHoiLCJyZWFkVUVHIiwibGFzdFNjYWxlIiwibmV4dFNjYWxlIiwiZGVsdGFTY2FsZSIsInJlYWRFRyIsImZyYW1lQ3JvcExlZnRPZmZzZXQiLCJmcmFtZUNyb3BSaWdodE9mZnNldCIsImZyYW1lQ3JvcFRvcE9mZnNldCIsImZyYW1lQ3JvcEJvdHRvbU9mZnNldCIsInByb2ZpbGVJZGMiLCJwcm9maWxlQ29tcGF0IiwibGV2ZWxJZGMiLCJudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUiLCJwaWNXaWR0aEluTWJzTWludXMxIiwicGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSIsImZyYW1lTWJzT25seUZsYWciLCJzY2FsaW5nTGlzdENvdW50IiwicmVhZFVCeXRlIiwicmVhZEJvb2xlYW4iLCJza2lwRUciLCJza2lwVUVHIiwic2tpcFNjYWxpbmdMaXN0IiwiY2hyb21hRm9ybWF0SWRjIiwicGljT3JkZXJDbnRUeXBlIiwiYXNwZWN0UmF0aW9JZGMiLCJjZWlsIiwiZnJvbnQiLCJfcmVhZFNpemUiLCJpc0Zvb3RlciIsIl9yZWFkVGltZVN0YW1wIiwiaW5mbyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImZyYW1lRGF0YSIsIl9nZXRGcmFtZURhdGEiLCJfZGVjb2RlRnJhbWUiLCJfZGVjb2RlUHJpdkZyYW1lIiwiX2RlY29kZVRleHRGcmFtZSIsIl9kZWNvZGVVUkxGcmFtZSIsInRpbWVTdGFtcEZyYW1lIiwicHRzMzNCaXQiLCJvd25lciIsIl91dGY4QXJyYXlUb1N0ciIsInByaXZhdGVEYXRhIiwiZGVzY3JpcHRpb24iLCJhcnJheSIsImV4aXRPbk51bGwiLCJjIiwiY2hhcjIiLCJjaGFyMyIsIm91dCIsInV0ZjhBcnJheVRvU3RyIiwiTXBlZ0F1ZGlvIiwiVUlOVDMyX01BWCIsInBhcnNlSW5pdFNlZ21lbnQiLCJhdWRpb3ZpZGVvIiwiZ2V0U3RhcnREVFMiLCJvZmZzZXRTdGFydERUUyIsImZpbmRCb3giLCJhcHBseSIsInZhbCIsInBhdGgiLCJyZXN1bHRzIiwic3VicmVzdWx0cyIsImVuZGJveCIsInJlYWRVaW50MzIiLCJiaW4yc3RyIiwiY29uY2F0IiwibW9vdiIsIm1vb3ZFbmRPZmZzZXQiLCJzaWR4IiwicmVmZXJlbmNlcyIsInZlcnNpb24iLCJ0aW1lc2NhbGUiLCJlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUiLCJmaXJzdE9mZnNldCIsInN0YXJ0Qnl0ZSIsInJlZmVyZW5jZXNDb3VudCIsInJlYWRVaW50MTYiLCJyZWZlcmVuY2VJbmRleCIsInJlZmVyZW5jZUluZm8iLCJyZWZlcmVuY2VTaXplIiwicmVmZXJlbmNlVHlwZSIsImNvbnNvbGUiLCJzdWJzZWdtZW50RHVyYXRpb24iLCJ0cmFrcyIsInRraGQiLCJ0cmFrIiwibWRoZCIsImhkbHIiLCJoZGxyVHlwZSIsImNvZGVjQm94IiwiY29kZWNUeXBlIiwidHJhZnMiLCJiYXNlVGltZXMiLCJ0cmFmIiwidGZoZCIsInNjYWxlIiwiYmFzZVRpbWUiLCJ0ZmR0IiwiYmFzZU1lZGlhRGVjb2RlVGltZSIsIndyaXRlVWludDMyIiwidXBwZXIiLCJmbG9vciIsImxvd2VyIiwiQml0cmF0ZXNNYXAiLCJTYW1wbGluZ1JhdGVNYXAiLCJTYW1wbGVzQ29lZmZpY2llbnRzIiwiQnl0ZXNJblNsb3QiLCJwYXJzZUhlYWRlciIsInNhbXBsZXNQZXJGcmFtZSIsInNhbXBsZVJhdGUiLCJoZWFkZXJCIiwiaGVhZGVyQyIsImhlYWRlckUiLCJoZWFkZXJGIiwiaGVhZGVyRyIsImNvbHVtbkluQml0cmF0ZXMiLCJiaXRSYXRlIiwiY29sdW1uSW5TYW1wbGVSYXRlcyIsInNhbXBsZUNvZWZmaWNpZW50IiwiYnl0ZXNJblNsb3QiLCJwYXJzZUludCIsIlNhbXBsZUFlc0RlY3J5cHRlciIsImRpc2NhcmRFUEIiLCJlbmNyeXB0ZWREYXRhIiwic2FtcGxlSW5kZXgiLCJzeW5jIiwiY3VyVW5pdCIsImVuY3J5cHRlZEJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJsb2NhbHRoaXMiLCJkZWNyeXB0QnVmZmVyIiwiZGVjcnlwdEFhY1NhbXBsZXMiLCJpc1N5bmMiLCJkZWNyeXB0QWFjU2FtcGxlIiwiZGVjb2RlZERhdGEiLCJlbmNyeXB0ZWREYXRhTGVuIiwiSW50OEFycmF5Iiwib3V0cHV0UG9zIiwiaW5wdXRQb3MiLCJ1bml0SW5kZXgiLCJnZXRBdmNFbmNyeXB0ZWREYXRhIiwiZ2V0QXZjRGVjcnlwdGVkVW5pdCIsImRlY3J5cHRBdmNTYW1wbGVzIiwiY3VyVW5pdHMiLCJ1bml0cyIsImRlY3J5cHRBdmNTYW1wbGUiLCJSZW11eGVyVHJhY2tJZENvbmZpZyIsImlkMyIsInNhbXBsZUFlcyIsInBtdFBhcnNlZCIsIl9wbXRJZCIsIl9hdmNUcmFjayIsImNyZWF0ZVRyYWNrIiwiX2lkM1RyYWNrIiwiX3R4dFRyYWNrIiwiYWFjT3ZlckZsb3ciLCJhYWNMYXN0UFRTIiwiYXZjU2FtcGxlIiwiX2R1cmF0aW9uIiwic3R0IiwicGlkIiwiYXRmIiwicGVzIiwidW5rbm93blBJRHMiLCJhdmNUcmFjayIsImF2Y0lkIiwiYXVkaW9JZCIsImlkM0lkIiwicG10SWQiLCJhdmNEYXRhIiwicGVzRGF0YSIsImF1ZGlvRGF0YSIsInBhcnNlUEFUIiwiX3BhcnNlUEFUIiwicGFyc2VQTVQiLCJfcGFyc2VQTVQiLCJwYXJzZVBFUyIsIl9wYXJzZVBFUyIsInBhcnNlQVZDUEVTIiwiX3BhcnNlQVZDUEVTIiwicGFyc2VBQUNQRVMiLCJfcGFyc2VBQUNQRVMiLCJwYXJzZU1QRUdQRVMiLCJfcGFyc2VNUEVHUEVTIiwicGFyc2VJRDNQRVMiLCJfcGFyc2VJRDNQRVMiLCJzeW5jT2Zmc2V0IiwiX3N5bmNPZmZzZXQiLCJwYXJzZWRQSURzIiwiYXZjIiwiZGVjcnlwdEFuZFJlbXV4IiwidmlkZW9UcmFjayIsImRlY3J5cHRBbmRSZW11eEF2YyIsIl9pbml0UFRTIiwiX2luaXREVFMiLCJtcGVnU3VwcG9ydGVkIiwiaXNTYW1wbGVBZXMiLCJzZWN0aW9uTGVuZ3RoIiwidGFibGVFbmQiLCJwcm9ncmFtSW5mb0xlbmd0aCIsInN0cmVhbSIsInBlc0ZsYWdzIiwicGVzUHJlZml4IiwicGVzTGVuIiwicGVzSGRyTGVuIiwicGVzUHRzIiwicGVzRHRzIiwicGF5bG9hZFN0YXJ0T2Zmc2V0IiwibmV3RGF0YSIsInNwbGljZSIsImRhdGFMZW4iLCJuYlNhbXBsZXMiLCJzcHMiLCJsYXN0IiwiX3BhcnNlQVZDTkFMdSIsImV4cEdvbG9tYkRlY29kZXIiLCJzcHNmb3VuZCIsInB1c2hBY2Nlc1VuaXQiLCJjcmVhdGVBVkNTYW1wbGUiLCJhdWRGb3VuZCIsInNsaWNlVHlwZSIsInJlYWRTbGljZVR5cGUiLCJwYXlsb2FkVHlwZSIsInBheWxvYWRTaXplIiwiZW5kT2ZDYXB0aW9ucyIsImNvdW50cnlDb2RlIiwicHJvdmlkZXJDb2RlIiwicmVhZFVTaG9ydCIsInVzZXJTdHJ1Y3R1cmUiLCJyZWFkVUludCIsInVzZXJEYXRhVHlwZSIsImZpcnN0Qnl0ZSIsInNlY29uZEJ5dGUiLCJ0b3RhbENDcyIsIl9pbnNlcnRTYW1wbGVJbk9yZGVyIiwicmVhZFNQUyIsImNvZGVjYXJyYXkiLCJjb2RlY3N0cmluZyIsImgiLCJwcHMiLCJhcnIiLCJsYXN0VW5pdCIsIm92ZXJmbG93IiwibmFsdVN0YXRlIiwibGFzdFN0YXRlIiwidW5pdFR5cGUiLCJsYXN0VW5pdFN0YXJ0IiwibGFzdFVuaXRUeXBlIiwiX2dldExhc3ROYWxVbml0IiwidG1wIiwiRVBCUG9zaXRpb25zIiwibmV3TGVuZ3RoIiwic291cmNlSW5kZXgiLCJuZXdQVFMiLCJzY2Fud2luZG93IiwiTVVYX0VSUk9SIiwiTUFOSUZFU1RfTE9BRF9FUlJPUiIsIk1BTklGRVNUX0xPQURfVElNRU9VVCIsIk1BTklGRVNUX1BBUlNJTkdfRVJST1IiLCJGT1JCSURERU5fRVZFTlRfTkFNRVMiLCJvbkV2ZW50IiwiZXZlbnRzIiwiaGFuZGxlZEV2ZW50cyIsInVzZUdlbmVyaWNIYW5kbGVyIiwicmVnaXN0ZXJMaXN0ZW5lcnMiLCJvbkhhbmRsZXJEZXN0cm95aW5nIiwidW5yZWdpc3Rlckxpc3RlbmVycyIsIm9uSGFuZGxlckRlc3Ryb3llZCIsImlzRXZlbnRIYW5kbGVyIiwib25FdmVudEdlbmVyaWMiLCJldmVudFRvRnVuY3Rpb24iLCJmdW5jTmFtZSIsInJlcGxhY2UiLCJjb25zdHJ1Y3RvciIsIkhsc0V2ZW50cyIsIkZSQUdfTE9BRF9QUk9HUkVTUyIsIkRFU1RST1lJTkciLCJVUkxUb29sa2l0IiwiSGxzIiwiX19WRVJTSU9OX18iLCJkZWZhdWx0Q29uZmlnIiwiRGVmYXVsdENvbmZpZyIsInByb3AiLCJfYXV0b0xldmVsQ2FwcGluZyIsInBsYXlMaXN0TG9hZGVyIiwiZnJhZ21lbnRMb2FkZXIiLCJGcmFnbWVudExvYWRlciIsImtleUxvYWRlciIsIktleUxvYWRlciIsImlkM1RyYWNrQ29udHJvbGxlciIsImxldmVsQ29udHJvbGxlciIsIm5ldHdvcmtDb250cm9sbGVycyIsIkNvbnRyb2xsZXIiLCJjb3JlQ29tcG9uZW50cyIsImRldGFjaE1lZGlhIiwiY29tcG9uZW50IiwiYnVpbGRBYnNvbHV0ZVVSTCIsImxvY2F0aW9uIiwiaHJlZiIsImFsd2F5c05vcm1hbGl6ZSIsImNvbnRyb2xsZXIiLCJzd2FwQXVkaW9Db2RlYyIsImF0dGFjaE1lZGlhIiwiaW1tZWRpYXRlTGV2ZWxTd2l0Y2giLCJtYW51YWxMZXZlbCIsImF1ZGlvVHJhY2tJZCIsImlzU3VwcG9ydGVkIiwiU291cmNlQnVmZmVyIiwiV2ViS2l0U291cmNlQnVmZmVyIiwic291cmNlQnVmZmVyVmFsaWRBUEkiLCJsb2FkZXJzIiwibG9hZGVyTmFtZSIsIkZyYWdtZW50SUxvYWRlciIsIkRlZmF1bHRJTG9hZGVyIiwibG9hZGVyQ29udGV4dCIsImxvYWRlckNvbmZpZyIsImxvYWRlckNhbGxiYWNrcyIsInByb2dyZXNzRGF0YSIsImJ5dGVSYW5nZVN0YXJ0T2Zmc2V0IiwiYnl0ZVJhbmdlRW5kT2Zmc2V0IiwicmFuZ2VTdGFydCIsInJhbmdlRW5kIiwidGltZW91dCIsIm1heFJldHJ5IiwicmV0cnlEZWxheSIsIm1heFJldHJ5RGVsYXkiLCJvblN1Y2Nlc3MiLCJsb2Fkc3VjY2VzcyIsIm9uRXJyb3IiLCJsb2FkZXJyb3IiLCJvblRpbWVvdXQiLCJsb2FkdGltZW91dCIsIm9uUHJvZ3Jlc3MiLCJsb2FkcHJvZ3Jlc3MiLCJuZXR3b3JrRGV0YWlscyIsIl91cmwiLCJfYnl0ZVJhbmdlIiwiX2RlY3J5cHRkYXRhIiwidGFnTGlzdCIsInJhd1Byb2dyYW1EYXRlVGltZSIsIl9lbGVtZW50YXJ5U3RyZWFtcyIsInNlZ21lbnROdW1iZXIiLCJ1aW50OFZpZXciLCJsZXZlbGtleSIsInVyaSIsIkxldmVsS2V5IiwiYmFzZXVyaSIsInJlbHVyaSIsImNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yIiwicmVsdXJsIiwiYmFzZXVybCIsInJhd0J5dGVSYW5nZSIsImJ5dGVSYW5nZSIsInBhcmFtcyIsInNwbGl0IiwibGFzdEJ5dGVSYW5nZUVuZE9mZnNldCIsImZyYWdtZW50RGVjcnlwdGRhdGFGcm9tTGV2ZWxrZXkiLCJkZWNyeXB0a2V5IiwiZGVjcnlwdHVybCIsIl91cmkiLCJMZXZlbCIsImJhc2VVcmwiLCJlbmRDQyIsIm5lZWRTaWR4UmFuZ2VzIiwic3RhcnRDQyIsIk1BU1RFUl9QTEFZTElTVF9SRUdFWCIsIk1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWCIsIkxFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QiLCJSZWdFeHAiLCJzb3VyY2UiLCJqb2luIiwiTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyIsIk1QNF9SRUdFWF9TVUZGSVgiLCJNM1U4UGFyc2VyIiwiZ3JvdXBzIiwibWVkaWFHcm91cElkIiwibWF0Y2hpbmdHcm91cCIsImdyb3VwIiwiYXZjZGF0YSIsInN1YnN0ciIsInN0cmluZyIsInNldENvZGVjcyIsImNvZGVjcyIsImZpbHRlcmVkIiwicHJlZmVycmVkIiwibGFzdEluZGV4T2YiLCJ1bmtub3duQ29kZWNzIiwiZXhlYyIsIkF0dHJMaXN0IiwicmVzb2x2ZSIsInJlc29sdXRpb24iLCJkZWNpbWFsUmVzb2x1dGlvbiIsImRlY2ltYWxJbnRlZ2VyIiwiTkFNRSIsIkNPREVDUyIsImNvbnZlcnRBVkMxVG9BVkNPVEkiLCJhdWRpb0dyb3VwcyIsIm1lZGlhcyIsIlRZUEUiLCJERUZBVUxUIiwiYXV0b3NlbGVjdCIsIkFVVE9TRUxFQ1QiLCJmb3JjZWQiLCJGT1JDRUQiLCJVUkkiLCJMQU5HVUFHRSIsImdyb3VwQ29kZWMiLCJmaW5kR3JvdXAiLCJsZXZlbFVybElkIiwiY3VycmVudFNOIiwiZmlyc3RQZHRJbmRleCIsInBhcnNlRmxvYXQiLCJ0aXRsZSIsImFzc2lnblByb2dyYW1EYXRlVGltZSIsIm1hdGNoIiwidmFsdWUxIiwidmFsdWUyIiwidG9VcHBlckNhc2UiLCJkZWNyeXB0cGFyYW1zIiwia2V5QXR0cnMiLCJkZWNyeXB0bWV0aG9kIiwiZW51bWVyYXRlZFN0cmluZyIsImRlY3J5cHR1cmkiLCJkZWNyeXB0aXYiLCJoZXhhZGVjaW1hbEludGVnZXIiLCJzdGFydFBhcmFtcyIsInN0YXJ0QXR0cnMiLCJkZWNpbWFsRmxvYXRpbmdQb2ludCIsIm1hcEF0dHJzIiwiQllURVJBTkdFIiwiZXZlcnkiLCJiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMiLCJzdGFydEluZGV4IiwiZnJhZ1ByZXYiLCJDb250ZXh0VHlwZSIsIk1BTklGRVNUIiwiTEVWRUwiLCJBVURJT19UUkFDSyIsIlNVQlRJVExFX1RSQUNLIiwiU1VCVElUTEUiLCJQTG9hZGVyIiwiTG9hZGVyIiwiSW50ZXJuYWxMb2FkZXIiLCJjb250ZXh0VHlwZSIsInJlc2V0SW50ZXJuYWxMb2FkZXIiLCJkZXN0cm95SW50ZXJuYWxMb2FkZXJzIiwiZ2V0SW50ZXJuYWxMb2FkZXIiLCJjcmVhdGVJbnRlcm5hbExvYWRlciIsImlzU2lkeFJlcXVlc3QiLCJfaGFuZGxlU2lkeFJlcXVlc3QiLCJfaGFuZGxlUGxheWxpc3RMb2FkZWQiLCJfaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IiLCJfaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QiLCJfaGFuZGxlTWFzdGVyUGxheWxpc3QiLCJfaGFuZGxlTmV0d29ya0Vycm9yIiwiZ2V0UmVzcG9uc2VVcmwiLCJwYXJzZU1hc3RlclBsYXlsaXN0IiwicGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhIiwiZW1iZWRkZWRBdWRpb0ZvdW5kIiwibGV2ZWxJZCIsIm1hcENvbnRleHRUb0xldmVsVHlwZSIsInBhcnNlTGV2ZWxQbGF5bGlzdCIsInNpbmdsZUxldmVsIiwic2lkeFVybCIsInNpZHhJbmZvIiwicGFyc2VTZWdtZW50SW5kZXgiLCJzaWR4UmVmZXJlbmNlcyIsInNlZ21lbnRSZWYiLCJzZWdSZWZJbmZvIiwiZXJyb3JEYXRhIiwiY2FuSGF2ZUxldmVscyIsImNhbkhhdmVRdWFsaXR5TGV2ZWxzIiwiQUFDIiwiTVA0IiwidHlwZXMiLCJhdmMxIiwiYXZjQyIsImJ0cnQiLCJkaW5mIiwiZHJlZiIsImVzZHMiLCJmdHlwIiwibWRhdCIsIm1kaWEiLCJtZmhkIiwibWluZiIsIm1vb2YiLCJtcDRhIiwibXZleCIsIm12aGQiLCJwYXNwIiwic2R0cCIsInN0YmwiLCJzdGNvIiwic3RzYyIsInN0c2QiLCJzdHN6Iiwic3R0cyIsInRydW4iLCJ0cmV4Iiwidm1oZCIsInNtaGQiLCJoYXNPd25Qcm9wZXJ0eSIsImNoYXJDb2RlQXQiLCJ2aWRlb0hkbHIiLCJhdWRpb0hkbHIiLCJIRExSX1RZUEVTIiwiU1RUUyIsIlNUU0MiLCJTVENPIiwiU1RTWiIsIlZNSEQiLCJTTUhEIiwiU1RTRCIsIm1ham9yQnJhbmQiLCJhdmMxQnJhbmQiLCJtaW5vclZlcnNpb24iLCJGVFlQIiwiYm94IiwiRElORiIsImFyZ3VtZW50cyIsInVwcGVyV29yZER1cmF0aW9uIiwibG93ZXJXb3JkRHVyYXRpb24iLCJib3hlcyIsImZsYWdzIiwiZGVwZW5kc09uIiwiaXNEZXBlbmRlZE9uIiwiaGFzUmVkdW5kYW5jeSIsImF2Y2MiLCJoU3BhY2luZyIsInZTcGFjaW5nIiwiY29uZmlnbGVuIiwic2FtcGxlRGVwZW5kZW5jeVRhYmxlIiwidXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSIsImxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUiLCJhcnJheWxlbiIsImN0cyIsImlzTGVhZGluZyIsInBhZGRpbmdWYWx1ZSIsImlzTm9uU3luYyIsImRlZ3JhZFByaW8iLCJpbml0IiwibW92aWUiLCJNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OIiwiaXNTYWZhcmkiLCJJU0dlbmVyYXRlZCIsImRlZmF1bHRUaW1lU3RhbXAiLCJnZW5lcmF0ZUlTIiwibmJBdWRpb1NhbXBsZXMiLCJuYlZpZGVvU2FtcGxlcyIsImF1ZGlvVGltZU9mZnNldCIsInZpZGVvVGltZU9mZnNldCIsImF1ZGlvdmlkZW9EZWx0YUR0cyIsInJlbXV4QXVkaW8iLCJhdWRpb1RyYWNrTGVuZ3RoIiwicmVtdXhWaWRlbyIsInZpZGVvRGF0YSIsInJlbXV4RW1wdHlBdWRpbyIsInJlbXV4SUQzIiwicmVtdXhUZXh0IiwiYXVkaW9TYW1wbGVzIiwidmlkZW9TYW1wbGVzIiwiY29tcHV0ZVBUU0RUUyIsImluaXREVFMiLCJtcDRTYW1wbGVEdXJhdGlvbiIsImZpcnN0UFRTIiwiZmlyc3REVFMiLCJsYXN0UFRTIiwibGFzdERUUyIsInRpbWVTY2FsZSIsImlucHV0U2FtcGxlcyIsIm91dHB1dFNhbXBsZXMiLCJwdHNOb3JtYWxpemUiLCJfUFRTTm9ybWFsaXplIiwibmV4dEF2Y0R0cyIsImRlbHRhZHRzIiwiZGVsdGFwdHMiLCJQVFNEVFNzaGlmdCIsImN1cnIiLCJuYk5hbHUiLCJuYWx1TGVuIiwibmJVbml0cyIsInNhbXBsZUxlbiIsIm1kYXRTaXplIiwic2V0VWludDMyIiwiYXZjU2FtcGxlVW5pdHMiLCJtcDRTYW1wbGVMZW5ndGgiLCJjb21wb3NpdGlvblRpbWVPZmZzZXQiLCJ1bml0RGF0YSIsInVuaXREYXRhTGVuIiwibGFzdEZyYW1lRHVyYXRpb24iLCJnYXBUb2xlcmFuY2UiLCJkZWx0YVRvRnJhbWVFbmQiLCJuZXh0QXVkaW9QdHMiLCJtcDR0aW1lU2NhbGUiLCJzY2FsZUZhY3RvciIsImlucHV0U2FtcGxlRHVyYXRpb24iLCJyYXdNUEVHIiwibXA0U2FtcGxlIiwiZmlsbEZyYW1lIiwibmV4dFB0cyIsIm1pc3NpbmciLCJuZXdTdGFtcCIsImdldFNpbGVudEZyYW1lIiwiYXVkaW9TYW1wbGUiLCJudW1NaXNzaW5nRnJhbWVzIiwidW5pdExlbiIsImxhc3RTYW1wbGVEdXJhdGlvbiIsInNhbXBsZUR1cmF0aW9uIiwic2lsZW50RnJhbWUiLCJyZWZlcmVuY2UiLCJyYXdEYXRhIiwiX3RpY2tJbnRlcnZhbCIsIl90aWNrVGltZXIiLCJfdGlja0NhbGxDb3VudCIsIl9ib3VuZFRpY2siLCJtaWxsaXMiLCJkb1RpY2siLCJERUNJTUFMX1JFU09MVVRJT05fUkVHRVgiLCJBVFRSX0xJU1RfUkVHRVgiLCJwYXJzZUF0dHJMaXN0IiwiYXR0ciIsImF0dHJOYW1lIiwiaW50VmFsdWUiLCJNQVhfU0FGRV9JTlRFR0VSIiwic3RyaW5nVmFsdWUiLCJyZXMiLCJpbnB1dCIsInF1b3RlIiwibGlzdCIsImNvbXBhcmlzb25GdW5jdGlvbiIsIm1pbkluZGV4IiwibWF4SW5kZXgiLCJjdXJyZW50SW5kZXgiLCJjdXJyZW50RWxlbWVudCIsImNvbXBhcmlzb25SZXN1bHQiLCJtYXhIb2xlRHVyYXRpb24iLCJ2YnVmZmVyZWQiLCJidWZmZXJlZDIiLCJidWZmZXJTdGFydCIsImJ1ZmZlclN0YXJ0TmV4dCIsImRpZmYiLCJidWYybGVuIiwiYnVmMmVuZCIsInNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzIiwiZ2V0Q2hhckZvckJ5dGUiLCJieXRlIiwiY2hhckNvZGUiLCJOUl9ST1dTIiwiTlJfQ09MUyIsInJvd3NMb3dDaDEiLCJyb3dzSGlnaENoMSIsInJvd3NMb3dDaDIiLCJyb3dzSGlnaENoMiIsImJhY2tncm91bmRDb2xvcnMiLCJ2ZXJib3NlRmlsdGVyIiwidmVyYm9zZUxldmVsIiwic2V0VGltZSIsIm5ld1RpbWUiLCJzZXZlcml0eSIsIm1zZyIsIm1pbkxldmVsIiwibnVtQXJyYXlUb0hleEFycmF5IiwibnVtQXJyYXkiLCJoZXhBcnJheSIsIlBlblN0YXRlIiwiZm9yZWdyb3VuZCIsInVuZGVybGluZSIsIml0YWxpY3MiLCJiYWNrZ3JvdW5kIiwiZmxhc2giLCJzdHlsZXMiLCJhdHRyaWJzIiwic3R5bGUiLCJvdGhlciIsIm5ld1BlblN0YXRlIiwiU3R5bGVkVW5pY29kZUNoYXIiLCJ1Y2hhciIsInBlblN0YXRlIiwiY29weSIsImVxdWFscyIsIm5ld0NoYXIiLCJpc0RlZmF1bHQiLCJSb3ciLCJjaGFycyIsImN1cnJQZW5TdGF0ZSIsImVxdWFsIiwiZW1wdHkiLCJpc0VtcHR5IiwiYWJzUG9zIiwicmVsUG9zIiwibmV3UG9zIiwic2V0UGVuU3RhdGUiLCJzZXRDdXJzb3IiLCJtb3ZlQ3Vyc29yIiwic2V0Q2hhciIsImJhY2tTcGFjZSIsImNoYXIiLCJzdGFydFBvcyIsImNsZWFyRnJvbVBvcyIsInNldFN0eWxlcyIsImN1cnJDaGFyIiwiQ2FwdGlvblNjcmVlbiIsInJvd3MiLCJjdXJyUm93IiwibnJSb2xsVXBSb3dzIiwiY2xlYXIiLCJyb3ciLCJjbGVhclRvRW5kT2ZSb3ciLCJpbnNlcnRDaGFyIiwic2V0UGVuU3R5bGVzIiwicGFjRGF0YSIsIm5ld1JvdyIsInRvcFJvd0luZGV4IiwibGFzdE91dHB1dFNjcmVlbiIsInByZXZMaW5lVGltZSIsImN1ZVN0YXJ0VGltZSIsImluZGVudCIsInByZXZQb3MiLCJjb2xvciIsInNldFBlbiIsImJrZ0RhdGEiLCJuclJvd3MiLCJnZXREaXNwbGF5VGV4dCIsInRvcFJvdyIsImFzT25lUm93IiwiZGlzcGxheVRleHQiLCJyb3dOciIsInJvd1RleHQiLCJnZXRUZXh0U3RyaW5nIiwidHJpbSIsIkNlYTYwOENoYW5uZWwiLCJjaGFubmVsTnVtYmVyIiwib3V0cHV0RmlsdGVyIiwiY2hOciIsInZlcmJvc2UiLCJkaXNwbGF5ZWRNZW1vcnkiLCJub25EaXNwbGF5ZWRNZW1vcnkiLCJjdXJyUm9sbFVwUm93Iiwid3JpdGVTY3JlZW4iLCJsYXN0Q3VlRW5kVGltZSIsIm5ld0hhbmRsZXIiLCJzZXRQQUMiLCJzZXRCa2dEYXRhIiwibmV3TW9kZSIsIm91dHB1dERhdGFVcGRhdGUiLCJzZXRNb2RlIiwic2V0Um9sbFVwUm93cyIsInJvbGxVcCIsIm5yQ29scyIsImNvbG9ySW5kZXgiLCJjb2xvcnMiLCJkaXNwYXRjaCIsImRpc3BhdGNoQ3VlIiwiZmllbGQiLCJvdXQxIiwib3V0MiIsIm91dHB1dHMiLCJjaGFubmVscyIsImN1cnJDaE5yIiwibGFzdENtZEEiLCJsYXN0Q21kQiIsImJ1ZmZlcmVkRGF0YSIsImRhdGFDb3VudGVycyIsImdldEhhbmRsZXIiLCJzZXRIYW5kbGVyIiwiYnl0ZUxpc3QiLCJjbWRGb3VuZCIsImNoYXJzRm91bmQiLCJwYWRkaW5nIiwicGFyc2VDbWQiLCJwYXJzZU1pZHJvdyIsInBhcnNlUEFDIiwicGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyIsInBhcnNlQ2hhcnMiLCJjaGFubmVsIiwiaW5zZXJ0Q2hhcnMiLCJjb25kMSIsImNvbmQyIiwiY2NSQ0wiLCJjY0JTIiwiY2NBT0YiLCJjY0FPTiIsImNjREVSIiwiY2NSVSIsImNjRk9OIiwiY2NSREMiLCJjY1RSIiwiY2NSVEQiLCJjY0VETSIsImNjQ1IiLCJjY0VOTSIsImNjRU9DIiwiY2NUTyIsImNjTUlEUk9XIiwiY2FzZTEiLCJjYXNlMiIsImludGVycHJldFBBQyIsInBhY0luZGV4IiwiY2hhbm5lbE5yIiwiY2hhckNvZGVzIiwiY2hhckNvZGUxIiwib25lQ29kZSIsImhleENvZGVzIiwiY3VlU3BsaXRBdFRpbWUiLCJzYW1wbGVFbnRyeUNvZGVzSVNPIiwiaXNDb2RlY1R5cGUiLCJ0eXBlQ29kZXMiLCJpc0NvZGVjU3VwcG9ydGVkSW5NcDQiLCJjYXB0aW9uU2NyZWVuIiwiaW5kZW50aW5nIiwiciIsImxpbmUiLCJhbGlnbiIsImZpbmRGaXJzdEZyYWdXaXRoQ0MiLCJmaW5kRnJhZ1dpdGhDQyIsInNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMiLCJmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWciLCJhZGp1c3RQdHMiLCJhbGlnblN0cmVhbSIsImFsaWduRGlzY29udGludWl0aWVzIiwiYWxpZ25QRFQiLCJmaXJzdEZyYWciLCJjdXJyZW50RnJhZyIsIkNDIiwic2hvdWxkQWxpZ24iLCJwcmV2RGV0YWlscyIsInByZXZGcmFncyIsImN1ckZyYWdzIiwicHJldlN0YXJ0RnJhZyIsInJlZmVyZW5jZUZyYWciLCJsYXN0RGV0YWlscyIsImxhc3RQRFQiLCJuZXdQRFQiLCJzbG93IiwiZmFzdCIsImRlZmF1bHRFc3RpbWF0ZSIsImRlZmF1bHRFc3RpbWF0ZV8iLCJtaW5XZWlnaHRfIiwibWluRGVsYXlNc18iLCJzbG93XyIsIkVXTUEiLCJmYXN0XyIsImR1cmF0aW9uTXMiLCJudW1CeXRlcyIsImJhbmR3aWR0aCIsIndlaWdodCIsImdldFRvdGFsV2VpZ2h0IiwiaGFsZkxpZmUiLCJhbHBoYV8iLCJleHAiLCJlc3RpbWF0ZV8iLCJ0b3RhbFdlaWdodF8iLCJhZGpBbHBoYSIsInplcm9GYWN0b3IiLCJnZXRTZWxmU2NvcGUiLCJub29wIiwiZmFrZUxvZ2dlciIsImV4cG9ydGVkTG9nZ2VyIiwiZm9ybWF0TXNnIiwiY29uc29sZVByaW50Rm4iLCJmdW5jIiwiYXJncyIsImV4cG9ydExvZ2dlckZ1bmN0aW9ucyIsImRlYnVnQ29uZmlnIiwiZnVuY3Rpb25zIiwiZW5hYmxlTG9ncyIsImdldE1lZGlhU291cmNlIiwiV2ViS2l0TWVkaWFTb3VyY2UiLCJhZGRDdWVzIiwiY3JlYXRlQ2FwdGlvbnNUcmFjayIsInNlbmRBZGRUcmFja0V2ZW50IiwiY2xlYXJDdXJyZW50Q3VlcyIsInZpZGVvRWwiLCJkb2N1bWVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsInJlbW92ZUN1ZSIsImF1dG9LZXl3b3JkIiwiZGlyZWN0aW9uU2V0dGluZyIsImxyIiwicmwiLCJhbGlnblNldHRpbmciLCJtaWRkbGUiLCJsZWZ0IiwicmlnaHQiLCJmaW5kRGlyZWN0aW9uU2V0dGluZyIsImRpciIsImZpbmRBbGlnblNldHRpbmciLCJleHRlbmQiLCJvYmoiLCJjb2JqIiwicCIsImlzSUU4IiwiYmFzZU9iaiIsImNyZWF0ZUVsZW1lbnQiLCJlbnVtZXJhYmxlIiwiaGFzQmVlblJlc2V0IiwiX2lkIiwiX3BhdXNlT25FeGl0IiwiX3N0YXJ0VGltZSIsIl9lbmRUaW1lIiwiX3RleHQiLCJfcmVnaW9uIiwiX3ZlcnRpY2FsIiwiX3NuYXBUb0xpbmVzIiwiX2xpbmUiLCJfbGluZUFsaWduIiwiX3Bvc2l0aW9uIiwiX3Bvc2l0aW9uQWxpZ24iLCJfc2l6ZSIsIl9hbGlnbiIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiVHlwZUVycm9yIiwic2V0dGluZyIsIlN5bnRheEVycm9yIiwiZGlzcGxheVN0YXRlIiwiZ2V0Q3VlQXNIVE1MIiwiV2ViVlRUIiwiY29udmVydEN1ZVRvRE9NVHJlZSIsIlN0cmluZ0RlY29kZXIiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJWVFRQYXJzZXIiLCJkZWNvZGVyIiwicmVnaW9uTGlzdCIsInBhcnNlVGltZVN0YW1wIiwiY29tcHV0ZVNlY29uZHMiLCJtIiwicyIsImYiLCJTZXR0aW5ncyIsInZhbHVlcyIsImsiLCJ2IiwiZGZsdCIsImRlZmF1bHRLZXkiLCJoYXMiLCJhbHQiLCJuIiwiaW50ZWdlciIsInBlcmNlbnQiLCJwYXJzZU9wdGlvbnMiLCJrZXlWYWx1ZURlbGltIiwiZ3JvdXBEZWxpbSIsImt2IiwiZGVmYXVsdHMiLCJjZW50ZXIiLCJwYXJzZUN1ZSIsIm9JbnB1dCIsImNvbnN1bWVUaW1lU3RhbXAiLCJ0cyIsImNvbnN1bWVDdWVTZXR0aW5ncyIsInNldHRpbmdzIiwicmVnaW9uIiwidmFscyIsInZhbHMwIiwidmVydGljYWwiLCJsaW5lQWxpZ24iLCJzbmFwVG9MaW5lcyIsInNraXBXaGl0ZXNwYWNlIiwiZml4TGluZUJyZWFrcyIsImNvbGxlY3ROZXh0TGluZSIsImFscmVhZHlDb2xsZWN0ZWRMaW5lIiwiaGFzU3Vic3RyaW5nIiwib25jdWUiLCJmbHVzaCIsIm9uZmx1c2giLCJzdGFydHNXaXRoIiwiaW5wdXRTdHJpbmciLCJzZWFyY2hTdHJpbmciLCJjdWVTdHJpbmcybWlsbGlzIiwidGltZVN0cmluZyIsInNlY3MiLCJtaW5zIiwiaG91cnMiLCJoYXNoIiwiY2FsY3VsYXRlT2Zmc2V0IiwicHJlc2VudGF0aW9uVGltZSIsImN1cnJDQyIsInZ0dEJ5dGVBcnJheSIsInN5bmNQVFMiLCJjYWxsQmFjayIsImVycm9yQ2FsbEJhY2siLCJyZSIsInZ0dExpbmVzIiwiY3VlVGltZSIsIm1wZWdUcyIsImxvY2FsVGltZSIsInBhcnNpbmdFcnJvciIsImluSGVhZGVyIiwicGFyc2VyIiwiY3VlT2Zmc2V0Iiwib25wYXJzaW5nZXJyb3IiLCJyZXF1ZXN0VGltZW91dCIsInJldHJ5VGltZW91dCIsImNhbGxiYWNrcyIsInJldHJ5IiwibG9hZEludGVybmFsIiwic2V0UmVxdWVzdEhlYWRlciIsInJlYWR5c3RhdGVjaGFuZ2UiLCJvbnByb2dyZXNzIiwiY3VycmVudFRhcmdldCIsInJlc3BvbnNlVGV4dCIsInJlc3BvbnNlVVJMIiwibGVuZ3RoQ29tcHV0YWJsZSIsIkhsc0pzUGxheWVyIiwib3B0aW9ucyIsImhsc09wdHMiLCJ1dGlsIiwiUGxheWVyIiwicGxheWVyIiwiYnJvd3NlciIsInV0aWxzIiwiZ2V0QnJvd3NlclZlcnNpb24iLCJ1c2VIbHMiLCJzbmlmZmVyIiwiZGV2aWNlIiwicGxhdGZvcm0iLCJjdXJyZW50U3JjIiwicmVtb3ZlQ2xhc3MiLCJyb290IiwibGl2ZURvbSIsInF1ZXJ5U2VsZWN0b3IiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJyZWdpc3RlciIsIm9uY2UiLCJsb2FkU291cmNlIiwiY29uZmlndXJhYmxlIiwiYXV0b3BsYXkiLCJhZGRDbGFzcyIsImZpbmREb20iLCJjcmVhdGVEb20iLCJjb250cm9scyIsImFwcGVuZENoaWxkIiwiRXZlbnRzIiwiaW5pdGVkIiwiZXJyb3JUeXBlIiwiZXJyb3JGYXRhbCIsInJlY292ZXJNZWRpYUVycm9yIiwiX3N0YXRpc3RpY3MiLCJzdGF0c0luZm8iLCJzcGVlZCIsInBsYXllclR5cGUiLCJtZWRpYWluZm8iLCJ2aWRlb0RhdGFSYXRlIiwiYXVkaW9EYXRhUmF0ZSIsImZsYWciLCJmcHMiLCJhdWRpb0NoYW5uZWxDb3VudCIsIl9zdGF0aXN0aWNzVGltbWVyIiwidmVyc2lvblRyaWRlbnQiXSwibWFwcGluZ3MiOiI7O1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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TDtBQUFROXBCLDJCQUFhLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBYixDQUFxQjtBQUM3QixpQkFBSyxDQUFMO0FBQVFBLDJCQUFhLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBYixDQUF1QjtBQUMvQixpQkFBSyxDQUFMO0FBQVFBLDJCQUFhLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBYixDQUF1QjtBQUMvQixpQkFBSyxDQUFMO0FBQVFBLDJCQUFhLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBYixDQUF1QjtBQUMvQixpQkFBSyxDQUFMO0FBQVFBLDJCQUFhLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBYixDQUF1QjtBQUMvQixpQkFBSyxDQUFMO0FBQVFBLDJCQUFhLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBYixDQUF1QjtBQUMvQixpQkFBSyxDQUFMO0FBQVFBLDJCQUFhLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBYixDQUF1QjtBQUMvQixpQkFBSyxDQUFMO0FBQVFBLDJCQUFhLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBYixDQUF1QjtBQUMvQixpQkFBSyxDQUFMO0FBQVFBLDJCQUFhLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBYixDQUF1QjtBQUMvQixpQkFBSyxFQUFMO0FBQVNBLDJCQUFhLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBYixDQUF1QjtBQUNoQyxpQkFBSyxFQUFMO0FBQVNBLDJCQUFhLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBYixDQUF1QjtBQUNoQyxpQkFBSyxFQUFMO0FBQVNBLDJCQUFhLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBYixDQUF1QjtBQUNoQyxpQkFBSyxFQUFMO0FBQVNBLDJCQUFhLENBQUMsR0FBRCxFQUFNLEVBQU4sQ0FBYixDQUF3QjtBQUNqQyxpQkFBSyxFQUFMO0FBQVNBLDJCQUFhLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBYixDQUFxQjtBQUM5QixpQkFBSyxFQUFMO0FBQVNBLDJCQUFhLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBYixDQUFxQjtBQUM5QixpQkFBSyxF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VUE7QUFDTCxXQUFPLFNBQVA7QUFDRDtBQUNGLENBekNEOztrQkEyQ2U4NkIsSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0NmLGFBQWEsbUNBQW1DLEVBQUUsSSIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIFJlZmxlY3RBcHBseSh0aGlzLmxpc3RlbmVyLCB0aGlzLnRhcmdldCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIiwiLy8gc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxODA4XG5cbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbihmdW5jdGlvbihyb290KSB7IFxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICB2YXIgVVJMX1JFR0VYID0gL14oKD86W2EtekEtWjAtOStcXC0uXSs6KT8pKFxcL1xcL1teXFwvPyNdKik/KCg/OlteXFwvXFw/I10qXFwvKSouKj8pPz8oOy4qPyk/KFxcPy4qPyk/KCMuKj8pPyQvO1xuICB2YXIgRklSU1RfU0VHTUVOVF9SRUdFWCA9IC9eKFteXFwvPyNdKikoLiopJC87XG4gIHZhciBTTEFTSF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuKD89XFwvKS9nO1xuICB2YXIgU0xBU0hfRE9UX0RPVF9SRUdFWCA9IC8oPzpcXC98XilcXC5cXC5cXC8oPyFcXC5cXC5cXC8pLio/KD89XFwvKS9nO1xuXG4gIHZhciBVUkxUb29sa2l0ID0geyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAvLyBJZiBvcHRzLmFsd2F5c05vcm1hbGl6ZSBpcyB0cnVlIHRoZW4gdGhlIHBhdGggd2lsbCBhbHdheXMgYmUgbm9ybWFsaXplZCBldmVuIHdoZW4gaXQgc3RhcnRzIHdpdGggLyBvciAvL1xuICAgIC8vIEUuZ1xuICAgIC8vIFdpdGggb3B0cy5hbHdheXNOb3JtYWxpemUgPSBmYWxzZSAoZGVmYXVsdCwgc3BlYyBjb21wbGlhbnQpXG4gICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZi8uLi9nXG4gICAgLy8gV2l0aCBvcHRzLmFsd2F5c05vcm1hbGl6ZSA9IHRydWUgKG5vdCBzcGVjIGNvbXBsaWFudClcbiAgICAvLyBodHRwOi8vYS5jb20vYi9jZCArIC9lL2YvLi4vZyA9PiBodHRwOi8vYS5jb20vZS9nXG4gICAgYnVpbGRBYnNvbHV0ZVVSTDogZnVuY3Rpb24oYmFzZVVSTCwgcmVsYXRpdmVVUkwsIG9wdHMpIHtcbiAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgLy8gcmVtb3ZlIGFueSByZW1haW5pbmcgc3BhY2UgYW5kIENSTEZcbiAgICAgIGJhc2VVUkwgPSBiYXNlVVJMLnRyaW0oKTtcbiAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkwudHJpbSgpO1xuICAgICAgaWYgKCFyZWxhdGl2ZVVSTCkge1xuICAgICAgICAvLyAyYSkgSWYgdGhlIGVtYmVkZGVkIFVSTCBpcyBlbnRpcmVseSBlbXB0eSwgaXQgaW5oZXJpdHMgdGhlXG4gICAgICAgIC8vIGVudGlyZSBiYXNlIFVSTCAoaS5lLiwgaXMgc2V0IGVxdWFsIHRvIHRoZSBiYXNlIFVSTClcbiAgICAgICAgLy8gYW5kIHdlIGFyZSBkb25lLlxuICAgICAgICBpZiAoIW9wdHMuYWx3YXlzTm9ybWFsaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VVUkw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZSA9IFVSTFRvb2xraXQucGFyc2VVUkwoYmFzZVVSTCk7XG4gICAgICAgIGlmICghYmFzZVBhcnRzRm9yTm9ybWFsaXNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgoYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGgpO1xuICAgICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhiYXNlUGFydHNGb3JOb3JtYWxpc2UpO1xuICAgICAgfVxuICAgICAgdmFyIHJlbGF0aXZlUGFydHMgPSBVUkxUb29sa2l0LnBhcnNlVVJMKHJlbGF0aXZlVVJMKTtcbiAgICAgIGlmICghcmVsYXRpdmVQYXJ0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSByZWxhdGl2ZSBVUkwuJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVsYXRpdmVQYXJ0cy5zY2hlbWUpIHtcbiAgICAgICAgLy8gMmIpIElmIHRoZSBlbWJlZGRlZCBVUkwgc3RhcnRzIHdpdGggYSBzY2hlbWUgbmFtZSwgaXQgaXNcbiAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYXMgYW4gYWJzb2x1dGUgVVJMIGFuZCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuICAgICAgICAgIHJldHVybiByZWxhdGl2ZVVSTDtcbiAgICAgICAgfVxuICAgICAgICByZWxhdGl2ZVBhcnRzLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgocmVsYXRpdmVQYXJ0cy5wYXRoKTtcbiAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMocmVsYXRpdmVQYXJ0cyk7XG4gICAgICB9XG4gICAgICB2YXIgYmFzZVBhcnRzID0gVVJMVG9vbGtpdC5wYXJzZVVSTChiYXNlVVJMKTtcbiAgICAgIGlmICghYmFzZVBhcnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xuICAgICAgfVxuICAgICAgaWYgKCFiYXNlUGFydHMubmV0TG9jICYmIGJhc2VQYXJ0cy5wYXRoICYmIGJhc2VQYXJ0cy5wYXRoWzBdICE9PSAnLycpIHtcbiAgICAgICAgLy8gSWYgbmV0TG9jIG1pc3NpbmcgYW5kIHBhdGggZG9lc24ndCBzdGFydCB3aXRoICcvJywgYXNzdW1lIGV2ZXJ0aGluZyBiZWZvcmUgdGhlIGZpcnN0ICcvJyBpcyB0aGUgbmV0TG9jXG4gICAgICAgIC8vIFRoaXMgY2F1c2VzICdleGFtcGxlLmNvbS9hJyB0byBiZSBoYW5kbGVkIGFzICcvL2V4YW1wbGUuY29tL2EnIGluc3RlYWQgb2YgJy9leGFtcGxlLmNvbS9hJ1xuICAgICAgICB2YXIgcGF0aFBhcnRzID0gRklSU1RfU0VHTUVOVF9SRUdFWC5leGVjKGJhc2VQYXJ0cy5wYXRoKTtcbiAgICAgICAgYmFzZVBhcnRzLm5ldExvYyA9IHBhdGhQYXJ0c1sxXTtcbiAgICAgICAgYmFzZVBhcnRzLnBhdGggPSBwYXRoUGFydHNbMl07XG4gICAgICB9XG4gICAgICBpZiAoYmFzZVBhcnRzLm5ldExvYyAmJiAhYmFzZVBhcnRzLnBhdGgpIHtcbiAgICAgICAgYmFzZVBhcnRzLnBhdGggPSAnLyc7XG4gICAgICB9XG4gICAgICB2YXIgYnVpbHRQYXJ0cyA9IHtcbiAgICAgICAgLy8gMmMpIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgc2NoZW1lIG9mXG4gICAgICAgIC8vIHRoZSBiYXNlIFVSTC5cbiAgICAgICAgc2NoZW1lOiBiYXNlUGFydHMuc2NoZW1lLFxuICAgICAgICBuZXRMb2M6IHJlbGF0aXZlUGFydHMubmV0TG9jLFxuICAgICAgICBwYXRoOiBudWxsLFxuICAgICAgICBwYXJhbXM6IHJlbGF0aXZlUGFydHMucGFyYW1zLFxuICAgICAgICBxdWVyeTogcmVsYXRpdmVQYXJ0cy5xdWVyeSxcbiAgICAgICAgZnJhZ21lbnQ6IHJlbGF0aXZlUGFydHMuZnJhZ21lbnRcbiAgICAgIH07XG4gICAgICBpZiAoIXJlbGF0aXZlUGFydHMubmV0TG9jKSB7XG4gICAgICAgIC8vIDMpIElmIHRoZSBlbWJlZGRlZCBVUkwncyA8bmV0X2xvYz4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG4gICAgICAgIC8vIFN0ZXAgNy4gIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgPG5ldF9sb2M+XG4gICAgICAgIC8vIChpZiBhbnkpIG9mIHRoZSBiYXNlIFVSTC5cbiAgICAgICAgYnVpbHRQYXJ0cy5uZXRMb2MgPSBiYXNlUGFydHMubmV0TG9jO1xuICAgICAgICAvLyA0KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgcHJlY2VkZWQgYnkgYSBzbGFzaCBcIi9cIiwgdGhlXG4gICAgICAgIC8vIHBhdGggaXMgbm90IHJlbGF0aXZlIGFuZCB3ZSBza2lwIHRvIFN0ZXAgNy5cbiAgICAgICAgaWYgKHJlbGF0aXZlUGFydHMucGF0aFswXSAhPT0gJy8nKSB7XG4gICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhdGgpIHtcbiAgICAgICAgICAgIC8vIDUpIElmIHRoZSBlbWJlZGRlZCBVUkwgcGF0aCBpcyBlbXB0eSAoYW5kIG5vdCBwcmVjZWRlZCBieSBhXG4gICAgICAgICAgICAvLyBzbGFzaCksIHRoZW4gdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgYmFzZSBVUkwgcGF0aFxuICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gYmFzZVBhcnRzLnBhdGg7XG4gICAgICAgICAgICAvLyA1YSkgaWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxwYXJhbXM+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cGFyYW1zPiBvZiB0aGUgYmFzZVxuICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZFxuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhcmFtcykge1xuICAgICAgICAgICAgICBidWlsdFBhcnRzLnBhcmFtcyA9IGJhc2VQYXJ0cy5wYXJhbXM7XG4gICAgICAgICAgICAgIC8vIDViKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHF1ZXJ5PiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cbiAgICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cXVlcnk+IG9mIHRoZSBiYXNlXG4gICAgICAgICAgICAgIC8vIFVSTCAoaWYgYW55KSBhbmQgd2Ugc2tpcCB0byBzdGVwIDcuXG4gICAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5xdWVyeSkge1xuICAgICAgICAgICAgICAgIGJ1aWx0UGFydHMucXVlcnkgPSBiYXNlUGFydHMucXVlcnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gNikgVGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgYmFzZSBVUkwncyBwYXRoIChhbnl0aGluZ1xuICAgICAgICAgICAgLy8gZm9sbG93aW5nIHRoZSByaWdodG1vc3Qgc2xhc2ggXCIvXCIsIG9yIHRoZSBlbnRpcmUgcGF0aCBpZiBub1xuICAgICAgICAgICAgLy8gc2xhc2ggaXMgcHJlc2VudCkgaXMgcmVtb3ZlZCBhbmQgdGhlIGVtYmVkZGVkIFVSTCdzIHBhdGggaXNcbiAgICAgICAgICAgIC8vIGFwcGVuZGVkIGluIGl0cyBwbGFjZS5cbiAgICAgICAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgdmFyIG5ld1BhdGggPSBiYXNlVVJMUGF0aC5zdWJzdHJpbmcoMCwgYmFzZVVSTFBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpICsgcmVsYXRpdmVQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKG5ld1BhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJ1aWx0UGFydHMucGF0aCA9PT0gbnVsbCkge1xuICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBvcHRzLmFsd2F5c05vcm1hbGl6ZSA/IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChyZWxhdGl2ZVBhcnRzLnBhdGgpIDogcmVsYXRpdmVQYXJ0cy5wYXRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYnVpbHRQYXJ0cyk7XG4gICAgfSxcbiAgICBwYXJzZVVSTDogZnVuY3Rpb24odXJsKSB7XG4gICAgICB2YXIgcGFydHMgPSBVUkxfUkVHRVguZXhlYyh1cmwpO1xuICAgICAgaWYgKCFwYXJ0cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtZTogcGFydHNbMV0gfHwgJycsXG4gICAgICAgIG5ldExvYzogcGFydHNbMl0gfHwgJycsXG4gICAgICAgIHBhdGg6IHBhcnRzWzNdIHx8ICcnLFxuICAgICAgICBwYXJhbXM6IHBhcnRzWzRdIHx8ICcnLFxuICAgICAgICBxdWVyeTogcGFydHNbNV0gfHwgJycsXG4gICAgICAgIGZyYWdtZW50OiBwYXJ0c1s2XSB8fCAnJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZVBhdGg6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgb3BlcmF0aW9ucyBhcmVcbiAgICAgIC8vIHRoZW4gYXBwbGllZCwgaW4gb3JkZXIsIHRvIHRoZSBuZXcgcGF0aDpcbiAgICAgIC8vIDZhKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCIuL1wiLCB3aGVyZSBcIi5cIiBpcyBhIGNvbXBsZXRlIHBhdGhcbiAgICAgIC8vIHNlZ21lbnQsIGFyZSByZW1vdmVkLlxuICAgICAgLy8gNmIpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIi5cIiBhcyBhIGNvbXBsZXRlIHBhdGggc2VnbWVudCxcbiAgICAgIC8vIHRoYXQgXCIuXCIgaXMgcmVtb3ZlZC5cbiAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykucmVwbGFjZShTTEFTSF9ET1RfUkVHRVgsICcnKTtcbiAgICAgIC8vIDZjKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCI8c2VnbWVudD4vLi4vXCIsIHdoZXJlIDxzZWdtZW50PiBpcyBhXG4gICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgYXJlIHJlbW92ZWQuXG4gICAgICAvLyBSZW1vdmFsIG9mIHRoZXNlIHBhdGggc2VnbWVudHMgaXMgcGVyZm9ybWVkIGl0ZXJhdGl2ZWx5LFxuICAgICAgLy8gcmVtb3ZpbmcgdGhlIGxlZnRtb3N0IG1hdGNoaW5nIHBhdHRlcm4gb24gZWFjaCBpdGVyYXRpb24sXG4gICAgICAvLyB1bnRpbCBubyBtYXRjaGluZyBwYXR0ZXJuIHJlbWFpbnMuXG4gICAgICAvLyA2ZCkgSWYgdGhlIHBhdGggZW5kcyB3aXRoIFwiPHNlZ21lbnQ+Ly4uXCIsIHdoZXJlIDxzZWdtZW50PiBpcyBhXG4gICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgdGhhdFxuICAgICAgLy8gXCI8c2VnbWVudD4vLi5cIiBpcyByZW1vdmVkLlxuICAgICAgd2hpbGUgKHBhdGgubGVuZ3RoICE9PSAocGF0aCA9IHBhdGgucmVwbGFjZShTTEFTSF9ET1RfRE9UX1JFR0VYLCAnJykpLmxlbmd0aCkge30gLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICByZXR1cm4gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xuICAgIH0sXG4gICAgYnVpbGRVUkxGcm9tUGFydHM6IGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgICByZXR1cm4gcGFydHMuc2NoZW1lICsgcGFydHMubmV0TG9jICsgcGFydHMucGF0aCArIHBhcnRzLnBhcmFtcyArIHBhcnRzLnF1ZXJ5ICsgcGFydHMuZnJhZ21lbnQ7XG4gICAgfVxuICB9O1xuXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFVSTFRvb2xraXQ7XG4gIGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBVUkxUb29sa2l0OyB9KTtcbiAgZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG4gICAgZXhwb3J0c1tcIlVSTFRvb2xraXRcIl0gPSBVUkxUb29sa2l0O1xuICBlbHNlXG4gICAgcm9vdFtcIlVSTFRvb2xraXRcIl0gPSBVUkxUb29sa2l0O1xufSkodGhpcyk7XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuIiwiZnVuY3Rpb24gd2VicGFja0Jvb3RzdHJhcEZ1bmMgKG1vZHVsZXMpIHtcbi8qKioqKiovICAvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyAgdmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gIC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyAgZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyAgICAvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovICAgIGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gICAgICByZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gICAgLy8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovICAgIHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovICAgICAgaTogbW9kdWxlSWQsXG4vKioqKioqLyAgICAgIGw6IGZhbHNlLFxuLyoqKioqKi8gICAgICBleHBvcnRzOiB7fVxuLyoqKioqKi8gICAgfTtcblxuLyoqKioqKi8gICAgLy8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyAgICBtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gICAgLy8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gICAgbW9kdWxlLmwgPSB0cnVlO1xuXG4vKioqKioqLyAgICAvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gIH1cblxuLyoqKioqKi8gIC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gIC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gIC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbi8qKioqKiovICAvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovICAgIGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyAgICAgICAgZ2V0OiBnZXR0ZXJcbi8qKioqKiovICAgICAgfSk7XG4vKioqKioqLyAgICB9XG4vKioqKioqLyAgfTtcblxuLyoqKioqKi8gIC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gIH07XG5cbi8qKioqKiovICAvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gICAgdmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyAgICAgIGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyAgICAgIGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyAgICByZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gIH07XG5cbi8qKioqKiovICAvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbi8qKioqKiovICAvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL1wiO1xuXG4vKioqKioqLyAgLy8gb24gZXJyb3IgZnVuY3Rpb24gZm9yIGFzeW5jIGxvYWRpbmdcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLm9lID0gZnVuY3Rpb24oZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgdGhyb3cgZXJyOyB9O1xuXG4gIHZhciBmID0gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBFTlRSWV9NT0RVTEUpXG4gIHJldHVybiBmLmRlZmF1bHQgfHwgZiAvLyB0cnkgdG8gY2FsbCBkZWZhdWx0IGlmIGRlZmluZWQgdG8gYWxzbyBzdXBwb3J0IGJhYmVsIGVzbW9kdWxlIGV4cG9ydHNcbn1cblxudmFyIG1vZHVsZU5hbWVSZXFFeHAgPSAnW1xcXFwufFxcXFwtfFxcXFwrfFxcXFx3fFxcL3xAXSsnXG52YXIgZGVwZW5kZW5jeVJlZ0V4cCA9ICdcXFxcKFxcXFxzKihcXC9cXFxcKi4qP1xcXFwqXFwvKT9cXFxccyouKj8oJyArIG1vZHVsZU5hbWVSZXFFeHAgKyAnKS4qP1xcXFwpJyAvLyBhZGRpdGlvbmFsIGNoYXJzIHdoZW4gb3V0cHV0LnBhdGhpbmZvIGlzIHRydWVcblxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjU5MzY2MS8xMzA0NDJcbmZ1bmN0aW9uIHF1b3RlUmVnRXhwIChzdHIpIHtcbiAgcmV0dXJuIChzdHIgKyAnJykucmVwbGFjZSgvWy4/KiteJFtcXF1cXFxcKCl7fXwtXS9nLCAnXFxcXCQmJylcbn1cblxuZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgcmV0dXJuICFpc05hTigxICogbik7IC8vIDEgKiBuIGNvbnZlcnRzIGludGVnZXJzLCBpbnRlZ2VycyBhcyBzdHJpbmcgKFwiMTIzXCIpLCAxZTMgYW5kIFwiMWUzXCIgdG8gaW50ZWdlcnMgYW5kIHN0cmluZ3MgdG8gTmFOXG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZURlcGVuZGVuY2llcyAoc291cmNlcywgbW9kdWxlLCBxdWV1ZU5hbWUpIHtcbiAgdmFyIHJldHZhbCA9IHt9XG4gIHJldHZhbFtxdWV1ZU5hbWVdID0gW11cblxuICB2YXIgZm5TdHJpbmcgPSBtb2R1bGUudG9TdHJpbmcoKVxuICB2YXIgd3JhcHBlclNpZ25hdHVyZSA9IGZuU3RyaW5nLm1hdGNoKC9eZnVuY3Rpb25cXHM/XFx3KlxcKFxcdyssXFxzKlxcdyssXFxzKihcXHcrKVxcKS8pXG4gIGlmICghd3JhcHBlclNpZ25hdHVyZSkgcmV0dXJuIHJldHZhbFxuICB2YXIgd2VicGFja1JlcXVpcmVOYW1lID0gd3JhcHBlclNpZ25hdHVyZVsxXVxuXG4gIC8vIG1haW4gYnVuZGxlIGRlcHNcbiAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnKFxcXFxcXFxcbnxcXFxcVyknICsgcXVvdGVSZWdFeHAod2VicGFja1JlcXVpcmVOYW1lKSArIGRlcGVuZGVuY3lSZWdFeHAsICdnJylcbiAgdmFyIG1hdGNoXG4gIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKGZuU3RyaW5nKSkpIHtcbiAgICBpZiAobWF0Y2hbM10gPT09ICdkbGwtcmVmZXJlbmNlJykgY29udGludWVcbiAgICByZXR2YWxbcXVldWVOYW1lXS5wdXNoKG1hdGNoWzNdKVxuICB9XG5cbiAgLy8gZGxsIGRlcHNcbiAgcmUgPSBuZXcgUmVnRXhwKCdcXFxcKCcgKyBxdW90ZVJlZ0V4cCh3ZWJwYWNrUmVxdWlyZU5hbWUpICsgJ1xcXFwoXCIoZGxsLXJlZmVyZW5jZVxcXFxzKCcgKyBtb2R1bGVOYW1lUmVxRXhwICsgJykpXCJcXFxcKVxcXFwpJyArIGRlcGVuZGVuY3lSZWdFeHAsICdnJylcbiAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoZm5TdHJpbmcpKSkge1xuICAgIGlmICghc291cmNlc1ttYXRjaFsyXV0pIHtcbiAgICAgIHJldHZhbFtxdWV1ZU5hbWVdLnB1c2gobWF0Y2hbMV0pXG4gICAgICBzb3VyY2VzW21hdGNoWzJdXSA9IF9fd2VicGFja19yZXF1aXJlX18obWF0Y2hbMV0pLm1cbiAgICB9XG4gICAgcmV0dmFsW21hdGNoWzJdXSA9IHJldHZhbFttYXRjaFsyXV0gfHwgW11cbiAgICByZXR2YWxbbWF0Y2hbMl1dLnB1c2gobWF0Y2hbNF0pXG4gIH1cblxuICAvLyBjb252ZXJ0IDFlMyBiYWNrIHRvIDEwMDAgLSB0aGlzIGNhbiBiZSBpbXBvcnRhbnQgYWZ0ZXIgdWdsaWZ5LWpzIGNvbnZlcnRlZCAxMDAwIHRvIDFlM1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJldHZhbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmV0dmFsW2tleXNbaV1dLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAoaXNOdW1lcmljKHJldHZhbFtrZXlzW2ldXVtqXSkpIHtcbiAgICAgICAgcmV0dmFsW2tleXNbaV1dW2pdID0gMSAqIHJldHZhbFtrZXlzW2ldXVtqXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0dmFsXG59XG5cbmZ1bmN0aW9uIGhhc1ZhbHVlc0luUXVldWVzIChxdWV1ZXMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhxdWV1ZXMpXG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzVmFsdWVzLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzVmFsdWVzIHx8IHF1ZXVlc1trZXldLmxlbmd0aCA+IDBcbiAgfSwgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGdldFJlcXVpcmVkTW9kdWxlcyAoc291cmNlcywgbW9kdWxlSWQpIHtcbiAgdmFyIG1vZHVsZXNRdWV1ZSA9IHtcbiAgICBtYWluOiBbbW9kdWxlSWRdXG4gIH1cbiAgdmFyIHJlcXVpcmVkTW9kdWxlcyA9IHtcbiAgICBtYWluOiBbXVxuICB9XG4gIHZhciBzZWVuTW9kdWxlcyA9IHtcbiAgICBtYWluOiB7fVxuICB9XG5cbiAgd2hpbGUgKGhhc1ZhbHVlc0luUXVldWVzKG1vZHVsZXNRdWV1ZSkpIHtcbiAgICB2YXIgcXVldWVzID0gT2JqZWN0LmtleXMobW9kdWxlc1F1ZXVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcXVldWVOYW1lID0gcXVldWVzW2ldXG4gICAgICB2YXIgcXVldWUgPSBtb2R1bGVzUXVldWVbcXVldWVOYW1lXVxuICAgICAgdmFyIG1vZHVsZVRvQ2hlY2sgPSBxdWV1ZS5wb3AoKVxuICAgICAgc2Vlbk1vZHVsZXNbcXVldWVOYW1lXSA9IHNlZW5Nb2R1bGVzW3F1ZXVlTmFtZV0gfHwge31cbiAgICAgIGlmIChzZWVuTW9kdWxlc1txdWV1ZU5hbWVdW21vZHVsZVRvQ2hlY2tdIHx8ICFzb3VyY2VzW3F1ZXVlTmFtZV1bbW9kdWxlVG9DaGVja10pIGNvbnRpbnVlXG4gICAgICBzZWVuTW9kdWxlc1txdWV1ZU5hbWVdW21vZHVsZVRvQ2hlY2tdID0gdHJ1ZVxuICAgICAgcmVxdWlyZWRNb2R1bGVzW3F1ZXVlTmFtZV0gPSByZXF1aXJlZE1vZHVsZXNbcXVldWVOYW1lXSB8fCBbXVxuICAgICAgcmVxdWlyZWRNb2R1bGVzW3F1ZXVlTmFtZV0ucHVzaChtb2R1bGVUb0NoZWNrKVxuICAgICAgdmFyIG5ld01vZHVsZXMgPSBnZXRNb2R1bGVEZXBlbmRlbmNpZXMoc291cmNlcywgc291cmNlc1txdWV1ZU5hbWVdW21vZHVsZVRvQ2hlY2tdLCBxdWV1ZU5hbWUpXG4gICAgICB2YXIgbmV3TW9kdWxlc0tleXMgPSBPYmplY3Qua2V5cyhuZXdNb2R1bGVzKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuZXdNb2R1bGVzS2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICBtb2R1bGVzUXVldWVbbmV3TW9kdWxlc0tleXNbal1dID0gbW9kdWxlc1F1ZXVlW25ld01vZHVsZXNLZXlzW2pdXSB8fCBbXVxuICAgICAgICBtb2R1bGVzUXVldWVbbmV3TW9kdWxlc0tleXNbal1dID0gbW9kdWxlc1F1ZXVlW25ld01vZHVsZXNLZXlzW2pdXS5jb25jYXQobmV3TW9kdWxlc1tuZXdNb2R1bGVzS2V5c1tqXV0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcXVpcmVkTW9kdWxlc1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtb2R1bGVJZCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgc291cmNlcyA9IHtcbiAgICBtYWluOiBfX3dlYnBhY2tfbW9kdWxlc19fXG4gIH1cblxuICB2YXIgcmVxdWlyZWRNb2R1bGVzID0gb3B0aW9ucy5hbGwgPyB7IG1haW46IE9iamVjdC5rZXlzKHNvdXJjZXMubWFpbikgfSA6IGdldFJlcXVpcmVkTW9kdWxlcyhzb3VyY2VzLCBtb2R1bGVJZClcblxuICB2YXIgc3JjID0gJydcblxuICBPYmplY3Qua2V5cyhyZXF1aXJlZE1vZHVsZXMpLmZpbHRlcihmdW5jdGlvbiAobSkgeyByZXR1cm4gbSAhPT0gJ21haW4nIH0pLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgIHZhciBlbnRyeU1vZHVsZSA9IDBcbiAgICB3aGlsZSAocmVxdWlyZWRNb2R1bGVzW21vZHVsZV1bZW50cnlNb2R1bGVdKSB7XG4gICAgICBlbnRyeU1vZHVsZSsrXG4gICAgfVxuICAgIHJlcXVpcmVkTW9kdWxlc1ttb2R1bGVdLnB1c2goZW50cnlNb2R1bGUpXG4gICAgc291cmNlc1ttb2R1bGVdW2VudHJ5TW9kdWxlXSA9ICcoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXzsgfSknXG4gICAgc3JjID0gc3JjICsgJ3ZhciAnICsgbW9kdWxlICsgJyA9ICgnICsgd2VicGFja0Jvb3RzdHJhcEZ1bmMudG9TdHJpbmcoKS5yZXBsYWNlKCdFTlRSWV9NT0RVTEUnLCBKU09OLnN0cmluZ2lmeShlbnRyeU1vZHVsZSkpICsgJykoeycgKyByZXF1aXJlZE1vZHVsZXNbbW9kdWxlXS5tYXAoZnVuY3Rpb24gKGlkKSB7IHJldHVybiAnJyArIEpTT04uc3RyaW5naWZ5KGlkKSArICc6ICcgKyBzb3VyY2VzW21vZHVsZV1baWRdLnRvU3RyaW5nKCkgfSkuam9pbignLCcpICsgJ30pO1xcbidcbiAgfSlcblxuICBzcmMgPSBzcmMgKyAnbmV3ICgoJyArIHdlYnBhY2tCb290c3RyYXBGdW5jLnRvU3RyaW5nKCkucmVwbGFjZSgnRU5UUllfTU9EVUxFJywgSlNPTi5zdHJpbmdpZnkobW9kdWxlSWQpKSArICcpKHsnICsgcmVxdWlyZWRNb2R1bGVzLm1haW4ubWFwKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gJycgKyBKU09OLnN0cmluZ2lmeShpZCkgKyAnOiAnICsgc291cmNlcy5tYWluW2lkXS50b1N0cmluZygpIH0pLmpvaW4oJywnKSArICd9KSkoc2VsZik7J1xuXG4gIHZhciBibG9iID0gbmV3IHdpbmRvdy5CbG9iKFtzcmNdLCB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pXG4gIGlmIChvcHRpb25zLmJhcmUpIHsgcmV0dXJuIGJsb2IgfVxuXG4gIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93Lm1velVSTCB8fCB3aW5kb3cubXNVUkxcblxuICB2YXIgd29ya2VyVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICB2YXIgd29ya2VyID0gbmV3IHdpbmRvdy5Xb3JrZXIod29ya2VyVXJsKVxuICB3b3JrZXIub2JqZWN0VVJMID0gd29ya2VyVXJsXG5cbiAgcmV0dXJuIHdvcmtlclxufVxuIiwiLyoqXG4gKiBITFMgY29uZmlnXG4gKi9cblxuaW1wb3J0IEFickNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2Fici1jb250cm9sbGVyJztcbmltcG9ydCBCdWZmZXJDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9idWZmZXItY29udHJvbGxlcic7XG5pbXBvcnQgQ2FwTGV2ZWxDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9jYXAtbGV2ZWwtY29udHJvbGxlcic7XG5pbXBvcnQgRlBTQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvZnBzLWNvbnRyb2xsZXInO1xuaW1wb3J0IFhockxvYWRlciBmcm9tICcuL3V0aWxzL3hoci1sb2FkZXInO1xuLy8gaW1wb3J0IEZldGNoTG9hZGVyIGZyb20gJy4vdXRpbHMvZmV0Y2gtbG9hZGVyJztcblxuaW1wb3J0IEF1ZGlvVHJhY2tDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9hdWRpby10cmFjay1jb250cm9sbGVyJztcbmltcG9ydCBBdWRpb1N0cmVhbUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2F1ZGlvLXN0cmVhbS1jb250cm9sbGVyJztcblxuaW1wb3J0ICogYXMgQ3VlcyBmcm9tICcuL3V0aWxzL2N1ZXMnO1xuaW1wb3J0IFRpbWVsaW5lQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvdGltZWxpbmUtY29udHJvbGxlcic7XG5pbXBvcnQgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL3N1YnRpdGxlLXRyYWNrLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIH0gZnJvbSAnLi9jb250cm9sbGVyL3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCBFTUVDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9lbWUtY29udHJvbGxlcic7XG5cbmltcG9ydCB7IHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyB9IGZyb20gJy4vdXRpbHMvbWVkaWFrZXlzLWhlbHBlcic7XG5cbmV4cG9ydCB2YXIgaGxzRGVmYXVsdENvbmZpZyA9IHtcbiAgYXV0b1N0YXJ0TG9hZDogdHJ1ZSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBzdGFydFBvc2l0aW9uOiAtMSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBkZWZhdWx0QXVkaW9Db2RlYzogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGRlYnVnOiBmYWxzZSwgLy8gdXNlZCBieSBsb2dnZXJcbiAgY2FwTGV2ZWxPbkZQU0Ryb3A6IGZhbHNlLCAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGNhcExldmVsVG9QbGF5ZXJTaXplOiBmYWxzZSwgLy8gdXNlZCBieSBjYXAtbGV2ZWwtY29udHJvbGxlclxuICBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTogMSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhCdWZmZXJMZW5ndGg6IDMwLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEJ1ZmZlclNpemU6IDYwICogMTAwMCAqIDEwMDAsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4QnVmZmVySG9sZTogMC41LCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG5cbiAgbG93QnVmZmVyV2F0Y2hkb2dQZXJpb2Q6IDAuNSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBoaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2Q6IDMsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbnVkZ2VPZmZzZXQ6IDAuMSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBudWRnZU1heFJldHJ5OiAzLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2U6IDAuMjUsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50OiAzLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudDogSW5maW5pdHksIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbGl2ZVN5bmNEdXJhdGlvbjogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGxpdmVNYXhMYXRlbmN5RHVyYXRpb246IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBsaXZlRHVyYXRpb25JbmZpbml0eTogZmFsc2UsIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgbGl2ZUJhY2tCdWZmZXJMZW5ndGg6IEluZmluaXR5LCAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIG1heE1heEJ1ZmZlckxlbmd0aDogNjAwLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGVuYWJsZVdvcmtlcjogdHJ1ZSwgLy8gdXNlZCBieSBkZW11eGVyXG4gIGVuYWJsZVNvZnR3YXJlQUVTOiB0cnVlLCAvLyB1c2VkIGJ5IGRlY3J5cHRlclxuICBtYW5pZmVzdExvYWRpbmdUaW1lT3V0OiAxMDAwMCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk6IDEsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIG1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIHN0YXJ0TGV2ZWw6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBsZXZlbC1jb250cm9sbGVyXG4gIGxldmVsTG9hZGluZ1RpbWVPdXQ6IDEwMDAwLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBsZXZlbExvYWRpbmdNYXhSZXRyeTogNCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgbGV2ZWxMb2FkaW5nUmV0cnlEZWxheTogMTAwMCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgbGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCwgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgZnJhZ0xvYWRpbmdUaW1lT3V0OiAyMDAwMCwgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgZnJhZ0xvYWRpbmdNYXhSZXRyeTogNiwgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgZnJhZ0xvYWRpbmdSZXRyeURlbGF5OiAxMDAwLCAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBmcmFnTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gIHN0YXJ0RnJhZ1ByZWZldGNoOiBmYWxzZSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBmcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZDogNTAwMCwgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICBmcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZDogMC4yLCAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGFwcGVuZEVycm9yTWF4UmV0cnk6IDMsIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgbG9hZGVyOiBYaHJMb2FkZXIsXG4gIC8vIGxvYWRlcjogRmV0Y2hMb2FkZXIsXG4gIGZMb2FkZXI6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgcExvYWRlcjogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICB4aHJTZXR1cDogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IHhoci1sb2FkZXJcbiAgbGljZW5zZVhoclNldHVwOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgLy8gZmV0Y2hTZXR1cDogdW5kZWZpbmVkLFxuICBhYnJDb250cm9sbGVyOiBBYnJDb250cm9sbGVyLFxuICBidWZmZXJDb250cm9sbGVyOiBCdWZmZXJDb250cm9sbGVyLFxuICBjYXBMZXZlbENvbnRyb2xsZXI6IENhcExldmVsQ29udHJvbGxlcixcbiAgZnBzQ29udHJvbGxlcjogRlBTQ29udHJvbGxlcixcbiAgc3RyZXRjaFNob3J0VmlkZW9UcmFjazogZmFsc2UsIC8vIHVzZWQgYnkgbXA0LXJlbXV4ZXJcbiAgbWF4QXVkaW9GcmFtZXNEcmlmdDogMSwgLy8gdXNlZCBieSBtcDQtcmVtdXhlclxuICBmb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5OiB0cnVlLCAvLyB1c2VkIGJ5IHRzLWRlbXV4ZXJcbiAgYWJyRXdtYUZhc3RMaXZlOiAzLCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFTbG93TGl2ZTogOSwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hRmFzdFZvRDogMywgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hU2xvd1ZvRDogOSwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hRGVmYXVsdEVzdGltYXRlOiA1ZTUsIC8vIDUwMCBrYnBzICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickJhbmRXaWR0aEZhY3RvcjogMC45NSwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJCYW5kV2lkdGhVcEZhY3RvcjogMC43LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFick1heFdpdGhSZWFsQml0cmF0ZTogZmFsc2UsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgbWF4U3RhcnZhdGlvbkRlbGF5OiA0LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIG1heExvYWRpbmdEZWxheTogNCwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBtaW5BdXRvQml0cmF0ZTogMCwgLy8gdXNlZCBieSBobHNcbiAgZW1lRW5hYmxlZDogZmFsc2UsIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgd2lkZXZpbmVMaWNlbnNlVXJsOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYzpcbiAgICAgICAgICAgIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG59O1xuXG5cbiAgaGxzRGVmYXVsdENvbmZpZy5zdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIgPSBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI7XG4gIGhsc0RlZmF1bHRDb25maWcuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgaGxzRGVmYXVsdENvbmZpZy50aW1lbGluZUNvbnRyb2xsZXIgPSBUaW1lbGluZUNvbnRyb2xsZXI7XG4gIGhsc0RlZmF1bHRDb25maWcuY3VlSGFuZGxlciA9IEN1ZXM7IC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICBobHNEZWZhdWx0Q29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zID0gdHJ1ZTsgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gIGhsc0RlZmF1bHRDb25maWcuZW5hYmxlV2ViVlRUID0gdHJ1ZTsgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gIGhsc0RlZmF1bHRDb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFiZWwgPSAnRW5nbGlzaCc7IC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICBobHNEZWZhdWx0Q29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhbmd1YWdlQ29kZSA9ICdlbic7IC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICBobHNEZWZhdWx0Q29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhYmVsID0gJ1NwYW5pc2gnOyAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgaGxzRGVmYXVsdENvbmZpZy5jYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGUgPSAnZXMnOyAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcblxuXG4gIGhsc0RlZmF1bHRDb25maWcuYXVkaW9TdHJlYW1Db250cm9sbGVyID0gQXVkaW9TdHJlYW1Db250cm9sbGVyO1xuICBobHNEZWZhdWx0Q29uZmlnLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gQXVkaW9UcmFja0NvbnRyb2xsZXI7XG5cblxuICBobHNEZWZhdWx0Q29uZmlnLmVtZUNvbnRyb2xsZXIgPSBFTUVDb250cm9sbGVyO1xuXG4iLCIvKlxuICogc2ltcGxlIEFCUiBDb250cm9sbGVyXG4gKiAgLSBjb21wdXRlIG5leHQgbGV2ZWwgYmFzZWQgb24gbGFzdCBmcmFnbWVudCBidyBoZXVyaXN0aWNzXG4gKiAgLSBpbXBsZW1lbnQgYW4gYWJhbmRvbiBydWxlcyB0cmlnZ2VyZWQgaWYgd2UgaGF2ZSBsZXNzIHRoYW4gMiBmcmFnIGJ1ZmZlcmVkIGFuZCBpZiBjb21wdXRlZCBidyBzaG93cyB0aGF0IHdlIHJpc2sgYnVmZmVyIHN0YWxsaW5nXG4gKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHsgQnVmZmVySGVscGVyIH0gZnJvbSAnLi4vdXRpbHMvYnVmZmVyLWhlbHBlcic7XG5pbXBvcnQgeyBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCBFd21hQmFuZFdpZHRoRXN0aW1hdG9yIGZyb20gJy4uL3V0aWxzL2V3bWEtYmFuZHdpZHRoLWVzdGltYXRvcic7XG5cbmNvbnN0IHsgcGVyZm9ybWFuY2UgfSA9IHdpbmRvdztcblxuY2xhc3MgQWJyQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsIEV2ZW50LkZSQUdfTE9BRElORyxcbiAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxuICAgICAgRXZlbnQuRlJBR19CVUZGRVJFRCxcbiAgICAgIEV2ZW50LkVSUk9SKTtcbiAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSAwO1xuICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9id0VzdGltYXRvciA9IG51bGw7XG4gICAgdGhpcy5vbkNoZWNrID0gdGhpcy5fYWJhbmRvblJ1bGVzQ2hlY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgb25GcmFnTG9hZGluZyAoZGF0YSkge1xuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKGZyYWcudHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICBpZiAoIXRoaXMudGltZXIpIHtcbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLm9uQ2hlY2ssIDEwMCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGxhenkgaW5pdCBvZiBCd0VzdGltYXRvciwgcmF0aW9uYWxlIGlzIHRoYXQgd2UgdXNlIGRpZmZlcmVudCBwYXJhbXMgZm9yIExpdmUvVm9EXG4gICAgICAvLyBzbyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHN0cmVhbSBtYW5pZmVzdCAvIHBsYXlsaXN0IHR5cGUgdG8gaW5zdGFudGlhdGUgaXQuXG4gICAgICBpZiAoIXRoaXMuX2J3RXN0aW1hdG9yKSB7XG4gICAgICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBjb25zdCBjb25maWcgPSBobHMuY29uZmlnO1xuICAgICAgICBjb25zdCBsZXZlbCA9IGZyYWcubGV2ZWw7XG4gICAgICAgIGNvbnN0IGlzTGl2ZSA9IGhscy5sZXZlbHNbbGV2ZWxdLmRldGFpbHMubGl2ZTtcblxuICAgICAgICBsZXQgZXdtYUZhc3QsIGV3bWFTbG93O1xuICAgICAgICBpZiAoaXNMaXZlKSB7XG4gICAgICAgICAgZXdtYUZhc3QgPSBjb25maWcuYWJyRXdtYUZhc3RMaXZlO1xuICAgICAgICAgIGV3bWFTbG93ID0gY29uZmlnLmFickV3bWFTbG93TGl2ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBld21hRmFzdCA9IGNvbmZpZy5hYnJFd21hRmFzdFZvRDtcbiAgICAgICAgICBld21hU2xvdyA9IGNvbmZpZy5hYnJFd21hU2xvd1ZvRDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9id0VzdGltYXRvciA9IG5ldyBFd21hQmFuZFdpZHRoRXN0aW1hdG9yKGhscywgZXdtYVNsb3csIGV3bWFGYXN0LCBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2FiYW5kb25SdWxlc0NoZWNrICgpIHtcbiAgICAvKlxuICAgICAgbW9uaXRvciBmcmFnbWVudCByZXRyaWV2YWwgdGltZS4uLlxuICAgICAgd2UgY29tcHV0ZSBleHBlY3RlZCB0aW1lIG9mIGFycml2YWwgb2YgdGhlIGNvbXBsZXRlIGZyYWdtZW50LlxuICAgICAgd2UgY29tcGFyZSBpdCB0byBleHBlY3RlZCB0aW1lIG9mIGJ1ZmZlciBzdGFydmF0aW9uXG4gICAgKi9cbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCB2aWRlbyA9IGhscy5tZWRpYTtcbiAgICBjb25zdCBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcblxuICAgIGlmICghZnJhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGxvYWRlciA9IGZyYWcubG9hZGVyO1xuICAgIGNvbnN0IG1pbkF1dG9MZXZlbCA9IGhscy5taW5BdXRvTGV2ZWw7XG5cbiAgICAvLyBpZiBsb2FkZXIgaGFzIGJlZW4gZGVzdHJveWVkIG9yIGxvYWRpbmcgaGFzIGJlZW4gYWJvcnRlZCwgc3RvcCB0aW1lciBhbmQgcmV0dXJuXG4gICAgaWYgKCFsb2FkZXIgfHwgKGxvYWRlci5zdGF0cyAmJiBsb2FkZXIuc3RhdHMuYWJvcnRlZCkpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdmcmFnIGxvYWRlciBkZXN0cm95IG9yIGFib3J0ZWQsIGRpc2FybSBhYmFuZG9uUnVsZXMnKTtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgLy8gcmVzZXQgZm9yY2VkIGF1dG8gbGV2ZWwgdmFsdWUgc28gdGhhdCBuZXh0IGxldmVsIHdpbGwgYmUgc2VsZWN0ZWRcbiAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHN0YXRzID0gbG9hZGVyLnN0YXRzO1xuICAgIC8qIG9ubHkgbW9uaXRvciBmcmFnIHJldHJpZXZhbCB0aW1lIGlmXG4gICAgKHZpZGVvIG5vdCBwYXVzZWQgT1IgZmlyc3QgZnJhZ21lbnQgYmVpbmcgbG9hZGVkKHJlYWR5IHN0YXRlID09PSBIQVZFX05PVEhJTkcgPSAwKSkgQU5EIGF1dG9zd2l0Y2hpbmcgZW5hYmxlZCBBTkQgbm90IGxvd2VzdCBsZXZlbCAoPT4gbWVhbnMgdGhhdCB3ZSBoYXZlIHNldmVyYWwgbGV2ZWxzKSAqL1xuICAgIGlmICh2aWRlbyAmJiBzdGF0cyAmJiAoKCF2aWRlby5wYXVzZWQgJiYgKHZpZGVvLnBsYXliYWNrUmF0ZSAhPT0gMCkpIHx8ICF2aWRlby5yZWFkeVN0YXRlKSAmJiBmcmFnLmF1dG9MZXZlbCAmJiBmcmFnLmxldmVsKSB7XG4gICAgICBsZXQgcmVxdWVzdERlbGF5ID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGF0cy50cmVxdWVzdCxcbiAgICAgICAgcGxheWJhY2tSYXRlID0gTWF0aC5hYnModmlkZW8ucGxheWJhY2tSYXRlKTtcbiAgICAgIC8vIG1vbml0b3IgZnJhZ21lbnQgbG9hZCBwcm9ncmVzcyBhZnRlciBoYWxmIG9mIGV4cGVjdGVkIGZyYWdtZW50IGR1cmF0aW9uLHRvIHN0YWJpbGl6ZSBiaXRyYXRlXG4gICAgICBpZiAocmVxdWVzdERlbGF5ID4gKDUwMCAqIGZyYWcuZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpKSB7XG4gICAgICAgIGxldCBsZXZlbHMgPSBobHMubGV2ZWxzLFxuICAgICAgICAgIGxvYWRSYXRlID0gTWF0aC5tYXgoMSwgc3RhdHMuYncgPyBzdGF0cy5idyAvIDggOiBzdGF0cy5sb2FkZWQgKiAxMDAwIC8gcmVxdWVzdERlbGF5KSwgLy8gYnl0ZS9zOyBhdCBsZWFzdCAxIGJ5dGUvcyB0byBhdm9pZCBkaXZpc2lvbiBieSB6ZXJvXG4gICAgICAgICAgLy8gY29tcHV0ZSBleHBlY3RlZCBmcmFnbWVudCBsZW5ndGggdXNpbmcgZnJhZyBkdXJhdGlvbiBhbmQgbGV2ZWwgYml0cmF0ZS4gYWxzbyBlbnN1cmUgdGhhdCBleHBlY3RlZCBsZW4gaXMgZ3RlIHRoYW4gYWxyZWFkeSBsb2FkZWQgc2l6ZVxuICAgICAgICAgIGxldmVsID0gbGV2ZWxzW2ZyYWcubGV2ZWxdLFxuICAgICAgICAgIGxldmVsQml0cmF0ZSA9IGxldmVsLnJlYWxCaXRyYXRlID8gTWF0aC5tYXgobGV2ZWwucmVhbEJpdHJhdGUsIGxldmVsLmJpdHJhdGUpIDogbGV2ZWwuYml0cmF0ZSxcbiAgICAgICAgICBleHBlY3RlZExlbiA9IHN0YXRzLnRvdGFsID8gc3RhdHMudG90YWwgOiBNYXRoLm1heChzdGF0cy5sb2FkZWQsIE1hdGgucm91bmQoZnJhZy5kdXJhdGlvbiAqIGxldmVsQml0cmF0ZSAvIDgpKSxcbiAgICAgICAgICBwb3MgPSB2aWRlby5jdXJyZW50VGltZSxcbiAgICAgICAgICBmcmFnTG9hZGVkRGVsYXkgPSAoZXhwZWN0ZWRMZW4gLSBzdGF0cy5sb2FkZWQpIC8gbG9hZFJhdGUsXG4gICAgICAgICAgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gKEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHZpZGVvLCBwb3MsIGhscy5jb25maWcubWF4QnVmZmVySG9sZSkuZW5kIC0gcG9zKSAvIHBsYXliYWNrUmF0ZTtcbiAgICAgICAgLy8gY29uc2lkZXIgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9ubHkgaWYgd2UgaGF2ZSBsZXNzIHRoYW4gMiBmcmFnIGJ1ZmZlcmVkIEFORFxuICAgICAgICAvLyB0aW1lIHRvIGZpbmlzaCBsb2FkaW5nIGN1cnJlbnQgZnJhZ21lbnQgaXMgYmlnZ2VyIHRoYW4gYnVmZmVyIHN0YXJ2YXRpb24gZGVsYXlcbiAgICAgICAgLy8gaWUgaWYgd2UgcmlzayBidWZmZXIgc3RhcnZhdGlvbiBpZiBidyBkb2VzIG5vdCBpbmNyZWFzZSBxdWlja2x5XG4gICAgICAgIGlmICgoYnVmZmVyU3RhcnZhdGlvbkRlbGF5IDwgKDIgKiBmcmFnLmR1cmF0aW9uIC8gcGxheWJhY2tSYXRlKSkgJiYgKGZyYWdMb2FkZWREZWxheSA+IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkpIHtcbiAgICAgICAgICBsZXQgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5LCBuZXh0TG9hZExldmVsO1xuICAgICAgICAgIC8vIGxldHMgaXRlcmF0ZSB0aHJvdWdoIGxvd2VyIGxldmVsIGFuZCB0cnkgdG8gZmluZCB0aGUgYmlnZ2VzdCBvbmUgdGhhdCBjb3VsZCBhdm9pZCByZWJ1ZmZlcmluZ1xuICAgICAgICAgIC8vIHdlIHN0YXJ0IGZyb20gY3VycmVudCBsZXZlbCAtIDEgYW5kIHdlIHN0ZXAgZG93biAsIHVudGlsIHdlIGZpbmQgYSBtYXRjaGluZyBsZXZlbFxuICAgICAgICAgIGZvciAobmV4dExvYWRMZXZlbCA9IGZyYWcubGV2ZWwgLSAxOyBuZXh0TG9hZExldmVsID4gbWluQXV0b0xldmVsOyBuZXh0TG9hZExldmVsLS0pIHtcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgdGltZSB0byBsb2FkIG5leHQgZnJhZ21lbnQgYXQgbG93ZXIgbGV2ZWxcbiAgICAgICAgICAgIC8vIDAuOCA6IGNvbnNpZGVyIG9ubHkgODAlIG9mIGN1cnJlbnQgYncgdG8gYmUgY29uc2VydmF0aXZlXG4gICAgICAgICAgICAvLyA4ID0gYml0cyBwZXIgYnl0ZSAoYnBzL0JwcylcbiAgICAgICAgICAgIGxldCBsZXZlbE5leHRCaXRyYXRlID0gbGV2ZWxzW25leHRMb2FkTGV2ZWxdLnJlYWxCaXRyYXRlID8gTWF0aC5tYXgobGV2ZWxzW25leHRMb2FkTGV2ZWxdLnJlYWxCaXRyYXRlLCBsZXZlbHNbbmV4dExvYWRMZXZlbF0uYml0cmF0ZSkgOiBsZXZlbHNbbmV4dExvYWRMZXZlbF0uYml0cmF0ZTtcbiAgICAgICAgICAgIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA9IGZyYWcuZHVyYXRpb24gKiBsZXZlbE5leHRCaXRyYXRlIC8gKDggKiAwLjggKiBsb2FkUmF0ZSk7XG4gICAgICAgICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5IDwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICAgICAgICAgIC8vIHdlIGZvdW5kIGEgbG93ZXIgbGV2ZWwgdGhhdCBiZSByZWJ1ZmZlcmluZyBmcmVlIHdpdGggY3VycmVudCBlc3RpbWF0ZWQgYncgIVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb25seSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gaWYgaXQgdGFrZXMgbGVzcyB0aW1lIHRvIGxvYWQgbmV3IGZyYWdtZW50IGF0IGxvd2VzdCBsZXZlbCBpbnN0ZWFkXG4gICAgICAgICAgLy8gb2YgZmluaXNoaW5nIGxvYWRpbmcgY3VycmVudCBvbmUgLi4uXG4gICAgICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA8IGZyYWdMb2FkZWREZWxheSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYGxvYWRpbmcgdG9vIHNsb3csIGFib3J0IGZyYWdtZW50IGxvYWRpbmcgYW5kIHN3aXRjaCB0byBsZXZlbCAke25leHRMb2FkTGV2ZWx9OmZyYWdMb2FkZWREZWxheVske25leHRMb2FkTGV2ZWx9XTxmcmFnTG9hZGVkRGVsYXlbJHtmcmFnLmxldmVsIC0gMX1dO2J1ZmZlclN0YXJ2YXRpb25EZWxheToke2ZyYWdMZXZlbE5leHRMb2FkZWREZWxheS50b0ZpeGVkKDEpfTwke2ZyYWdMb2FkZWREZWxheS50b0ZpeGVkKDEpfToke2J1ZmZlclN0YXJ2YXRpb25EZWxheS50b0ZpeGVkKDEpfWApO1xuICAgICAgICAgICAgLy8gZm9yY2UgbmV4dCBsb2FkIGxldmVsIGluIGF1dG8gbW9kZVxuICAgICAgICAgICAgaGxzLm5leHRMb2FkTGV2ZWwgPSBuZXh0TG9hZExldmVsO1xuICAgICAgICAgICAgLy8gdXBkYXRlIGJ3IGVzdGltYXRlIGZvciB0aGlzIGZyYWdtZW50IGJlZm9yZSBjYW5jZWxsaW5nIGxvYWQgKHRoaXMgd2lsbCBoZWxwIHJlZHVjaW5nIHRoZSBidylcbiAgICAgICAgICAgIHRoaXMuX2J3RXN0aW1hdG9yLnNhbXBsZShyZXF1ZXN0RGVsYXksIHN0YXRzLmxvYWRlZCk7XG4gICAgICAgICAgICAvLyBhYm9ydCBmcmFnbWVudCBsb2FkaW5nXG4gICAgICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIC8vIHN0b3AgYWJhbmRvbiBydWxlcyB0aW1lclxuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHsgZnJhZzogZnJhZywgc3RhdHM6IHN0YXRzIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0xvYWRlZCAoZGF0YSkge1xuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKGZyYWcudHlwZSA9PT0gJ21haW4nICYmIE51bWJlci5pc0Zpbml0ZShmcmFnLnNuKSkge1xuICAgICAgLy8gc3RvcCBtb25pdG9yaW5nIGJ3IG9uY2UgZnJhZyBsb2FkZWRcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgLy8gc3RvcmUgbGV2ZWwgaWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBmcmFnbWVudCBsb2FkXG4gICAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSBmcmFnLmxldmVsO1xuICAgICAgLy8gcmVzZXQgZm9yY2VkIGF1dG8gbGV2ZWwgdmFsdWUgc28gdGhhdCBuZXh0IGxldmVsIHdpbGwgYmUgc2VsZWN0ZWRcbiAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcblxuICAgICAgLy8gY29tcHV0ZSBsZXZlbCBhdmVyYWdlIGJpdHJhdGVcbiAgICAgIGlmICh0aGlzLmhscy5jb25maWcuYWJyTWF4V2l0aFJlYWxCaXRyYXRlKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5obHMubGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgICAgICBsZXQgbG9hZGVkQnl0ZXMgPSAobGV2ZWwubG9hZGVkID8gbGV2ZWwubG9hZGVkLmJ5dGVzIDogMCkgKyBkYXRhLnN0YXRzLmxvYWRlZDtcbiAgICAgICAgbGV0IGxvYWRlZER1cmF0aW9uID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5kdXJhdGlvbiA6IDApICsgZGF0YS5mcmFnLmR1cmF0aW9uO1xuICAgICAgICBsZXZlbC5sb2FkZWQgPSB7IGJ5dGVzOiBsb2FkZWRCeXRlcywgZHVyYXRpb246IGxvYWRlZER1cmF0aW9uIH07XG4gICAgICAgIGxldmVsLnJlYWxCaXRyYXRlID0gTWF0aC5yb3VuZCg4ICogbG9hZGVkQnl0ZXMgLyBsb2FkZWREdXJhdGlvbik7XG4gICAgICB9XG4gICAgICAvLyBpZiBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdCxcbiAgICAgIGlmIChkYXRhLmZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgICAgbGV0IHN0YXRzID0gZGF0YS5zdGF0cztcbiAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHN0YXRzLnRsb2FkO1xuICAgICAgICB0aGlzLm9uRnJhZ0J1ZmZlcmVkKGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ0J1ZmZlcmVkIChkYXRhKSB7XG4gICAgY29uc3Qgc3RhdHMgPSBkYXRhLnN0YXRzO1xuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgLy8gb25seSB1cGRhdGUgc3RhdHMgb24gZmlyc3QgZnJhZyBidWZmZXJpbmdcbiAgICAvLyBpZiBzYW1lIGZyYWcgaXMgbG9hZGVkIG11bHRpcGxlIHRpbWVzLCBpdCBtaWdodCBiZSBpbiBicm93c2VyIGNhY2hlLCBhbmQgbG9hZGVkIHF1aWNrbHlcbiAgICAvLyBhbmQgbGVhZGluZyB0byB3cm9uZyBidyBlc3RpbWF0aW9uXG4gICAgLy8gb24gYml0cmF0ZSB0ZXN0LCBhbHNvIG9ubHkgdXBkYXRlIHN0YXRzIG9uY2UgKGlmIHRsb2FkID0gdGJ1ZmZlcmVkID09IG9uIEZSQUdfTE9BREVEKVxuICAgIGlmIChzdGF0cy5hYm9ydGVkICE9PSB0cnVlICYmIGZyYWcudHlwZSA9PT0gJ21haW4nICYmIE51bWJlci5pc0Zpbml0ZShmcmFnLnNuKSAmJiAoKCFmcmFnLmJpdHJhdGVUZXN0IHx8IHN0YXRzLnRsb2FkID09PSBzdGF0cy50YnVmZmVyZWQpKSkge1xuICAgICAgLy8gdXNlIHRwYXJzZWQtdHJlcXVlc3QgaW5zdGVhZCBvZiB0YnVmZmVyZWQtdHJlcXVlc3QgdG8gY29tcHV0ZSBmcmFnTG9hZGluZ1Byb2Nlc3Npbmc7IHJhdGlvbmFsZSBpcyB0aGF0ICBidWZmZXIgYXBwZW5kaW5nIG9ubHkgaGFwcGVucyBvbmNlIG1lZGlhIGlzIGF0dGFjaGVkXG4gICAgICAvLyBpbiBjYXNlIHdlIHVzZSBjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2ggd2hpbGUgbWVkaWEgaXMgbm90IGF0dGFjaGVkIHlldCwgZnJhZ21lbnQgbWlnaHQgYmUgcGFyc2VkIHdoaWxlIG1lZGlhIG5vdCBhdHRhY2hlZCB5ZXQsIGJ1dCBpdCB3aWxsIG9ubHkgYmUgYnVmZmVyZWQgb24gbWVkaWEgYXR0YWNoZWRcbiAgICAgIC8vIGFzIGEgY29uc2VxdWVuY2UgaXQgY291bGQgaGFwcGVuIHJlYWxseSBsYXRlIGluIHRoZSBwcm9jZXNzLiBtZWFuaW5nIHRoYXQgYXBwZW5kaW5nIGR1cmF0aW9uIG1pZ2h0IGFwcGVhcnMgaHVnZSAuLi4gbGVhZGluZyB0byB1bmRlcmVzdGltYXRlZCB0aHJvdWdocHV0IGVzdGltYXRpb25cbiAgICAgIGxldCBmcmFnTG9hZGluZ1Byb2Nlc3NpbmdNcyA9IHN0YXRzLnRwYXJzZWQgLSBzdGF0cy50cmVxdWVzdDtcbiAgICAgIGxvZ2dlci5sb2coYGxhdGVuY3kvbG9hZGluZy9wYXJzaW5nL2FwcGVuZC9rYnBzOiR7TWF0aC5yb3VuZChzdGF0cy50Zmlyc3QgLSBzdGF0cy50cmVxdWVzdCl9LyR7TWF0aC5yb3VuZChzdGF0cy50bG9hZCAtIHN0YXRzLnRmaXJzdCl9LyR7TWF0aC5yb3VuZChzdGF0cy50cGFyc2VkIC0gc3RhdHMudGxvYWQpfS8ke01hdGgucm91bmQoc3RhdHMudGJ1ZmZlcmVkIC0gc3RhdHMudHBhcnNlZCl9LyR7TWF0aC5yb3VuZCg4ICogc3RhdHMubG9hZGVkIC8gKHN0YXRzLnRidWZmZXJlZCAtIHN0YXRzLnRyZXF1ZXN0KSl9YCk7XG4gICAgICB0aGlzLl9id0VzdGltYXRvci5zYW1wbGUoZnJhZ0xvYWRpbmdQcm9jZXNzaW5nTXMsIHN0YXRzLmxvYWRlZCk7XG4gICAgICBzdGF0cy5id0VzdGltYXRlID0gdGhpcy5fYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKTtcbiAgICAgIC8vIGlmIGZyYWdtZW50IGhhcyBiZWVuIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0LCAoaGxzLnN0YXJ0TGV2ZWwgPSAtMSksIHN0b3JlIGJpdHJhdGUgdGVzdCBkZWxheSBkdXJhdGlvblxuICAgICAgaWYgKGZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gZnJhZ0xvYWRpbmdQcm9jZXNzaW5nTXMgLyAxMDAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkVycm9yIChkYXRhKSB7XG4gICAgLy8gc3RvcCB0aW1lciBpbiBjYXNlIG9mIGZyYWcgbG9hZGluZyBlcnJvclxuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgY2xlYXJUaW1lciAoKSB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgfVxuXG4gIC8vIHJldHVybiBuZXh0IGF1dG8gbGV2ZWxcbiAgZ2V0IG5leHRBdXRvTGV2ZWwgKCkge1xuICAgIGNvbnN0IGZvcmNlZEF1dG9MZXZlbCA9IHRoaXMuX25leHRBdXRvTGV2ZWw7XG4gICAgY29uc3QgYndFc3RpbWF0b3IgPSB0aGlzLl9id0VzdGltYXRvcjtcbiAgICAvLyBpbiBjYXNlIG5leHQgYXV0byBsZXZlbCBoYXMgYmVlbiBmb3JjZWQsIGFuZCBidyBub3QgYXZhaWxhYmxlIG9yIG5vdCByZWxpYWJsZSwgcmV0dXJuIGZvcmNlZCB2YWx1ZVxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xICYmICghYndFc3RpbWF0b3IgfHwgIWJ3RXN0aW1hdG9yLmNhbkVzdGltYXRlKCkpKSB7XG4gICAgICByZXR1cm4gZm9yY2VkQXV0b0xldmVsO1xuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgbmV4dCBsZXZlbCB1c2luZyBBQlIgbG9naWNcbiAgICBsZXQgbmV4dEFCUkF1dG9MZXZlbCA9IHRoaXMuX25leHRBQlJBdXRvTGV2ZWw7XG4gICAgLy8gaWYgZm9yY2VkIGF1dG8gbGV2ZWwgaGFzIGJlZW4gZGVmaW5lZCwgdXNlIGl0IHRvIGNhcCBBQlIgY29tcHV0ZWQgcXVhbGl0eSBsZXZlbFxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICBuZXh0QUJSQXV0b0xldmVsID0gTWF0aC5taW4oZm9yY2VkQXV0b0xldmVsLCBuZXh0QUJSQXV0b0xldmVsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dEFCUkF1dG9MZXZlbDtcbiAgfVxuICBnZXQgX25leHRBQlJBdXRvTGV2ZWwgKCkge1xuICAgIGxldCBobHMgPSB0aGlzLmhscywgbWF4QXV0b0xldmVsID0gaGxzLm1heEF1dG9MZXZlbCwgbGV2ZWxzID0gaGxzLmxldmVscywgY29uZmlnID0gaGxzLmNvbmZpZywgbWluQXV0b0xldmVsID0gaGxzLm1pbkF1dG9MZXZlbDtcbiAgICBjb25zdCB2aWRlbyA9IGhscy5tZWRpYSxcbiAgICAgIGN1cnJlbnRMZXZlbCA9IHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCxcbiAgICAgIGN1cnJlbnRGcmFnRHVyYXRpb24gPSB0aGlzLmZyYWdDdXJyZW50ID8gdGhpcy5mcmFnQ3VycmVudC5kdXJhdGlvbiA6IDAsXG4gICAgICBwb3MgPSAodmlkZW8gPyB2aWRlby5jdXJyZW50VGltZSA6IDApLFxuICAgICAgLy8gcGxheWJhY2tSYXRlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgcGxheWJhY2sgcmF0ZTsgaWYgdmlkZW8ucGxheWJhY2tSYXRlIGlzIDAsIHdlIHVzZSAxIHRvIGxvYWQgYXNcbiAgICAgIC8vIGlmIHdlJ3JlIHBsYXlpbmcgYmFjayBhdCB0aGUgbm9ybWFsIHJhdGUuXG4gICAgICBwbGF5YmFja1JhdGUgPSAoKHZpZGVvICYmICh2aWRlby5wbGF5YmFja1JhdGUgIT09IDApKSA/IE1hdGguYWJzKHZpZGVvLnBsYXliYWNrUmF0ZSkgOiAxLjApLFxuICAgICAgYXZnYncgPSB0aGlzLl9id0VzdGltYXRvciA/IHRoaXMuX2J3RXN0aW1hdG9yLmdldEVzdGltYXRlKCkgOiBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSxcbiAgICAgIC8vIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSBpcyB0aGUgd2FsbC1jbG9jayB0aW1lIGxlZnQgdW50aWwgdGhlIHBsYXliYWNrIGJ1ZmZlciBpcyBleGhhdXN0ZWQuXG4gICAgICBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSAoQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odmlkZW8sIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLmVuZCAtIHBvcykgLyBwbGF5YmFja1JhdGU7XG5cbiAgICAvLyBGaXJzdCwgbG9vayB0byBzZWUgaWYgd2UgY2FuIGZpbmQgYSBsZXZlbCBtYXRjaGluZyB3aXRoIG91ciBhdmcgYmFuZHdpZHRoIEFORCB0aGF0IGNvdWxkIGFsc28gZ3VhcmFudGVlIG5vIHJlYnVmZmVyaW5nIGF0IGFsbFxuICAgIGxldCBiZXN0TGV2ZWwgPSB0aGlzLl9maW5kQmVzdExldmVsKGN1cnJlbnRMZXZlbCwgY3VycmVudEZyYWdEdXJhdGlvbiwgYXZnYncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBidWZmZXJTdGFydmF0aW9uRGVsYXksIGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3IsIGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvciwgbGV2ZWxzKTtcbiAgICBpZiAoYmVzdExldmVsID49IDApIHtcbiAgICAgIHJldHVybiBiZXN0TGV2ZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci50cmFjZSgncmVidWZmZXJpbmcgZXhwZWN0ZWQgdG8gaGFwcGVuLCBsZXRzIHRyeSB0byBmaW5kIGEgcXVhbGl0eSBsZXZlbCBtaW5pbWl6aW5nIHRoZSByZWJ1ZmZlcmluZycpO1xuICAgICAgLy8gbm90IHBvc3NpYmxlIHRvIGdldCByaWQgb2YgcmVidWZmZXJpbmcgLi4uIGxldCdzIHRyeSB0byBmaW5kIGxldmVsIHRoYXQgd2lsbCBndWFyYW50ZWUgbGVzcyB0aGFuIG1heFN0YXJ2YXRpb25EZWxheSBvZiByZWJ1ZmZlcmluZ1xuICAgICAgLy8gaWYgbm8gbWF0Y2hpbmcgbGV2ZWwgZm91bmQsIGxvZ2ljIHdpbGwgcmV0dXJuIDBcbiAgICAgIGxldCBtYXhTdGFydmF0aW9uRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbiwgY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheSkgOiBjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5LFxuICAgICAgICBid0ZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3IsXG4gICAgICAgIGJ3VXBGYWN0b3IgPSBjb25maWcuYWJyQmFuZFdpZHRoVXBGYWN0b3I7XG4gICAgICBpZiAoYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID09PSAwKSB7XG4gICAgICAgIC8vIGluIGNhc2UgYnVmZmVyIGlzIGVtcHR5LCBsZXQncyBjaGVjayBpZiBwcmV2aW91cyBmcmFnbWVudCB3YXMgbG9hZGVkIHRvIHBlcmZvcm0gYSBiaXRyYXRlIHRlc3RcbiAgICAgICAgbGV0IGJpdHJhdGVUZXN0RGVsYXkgPSB0aGlzLmJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICAgIGlmIChiaXRyYXRlVGVzdERlbGF5KSB7XG4gICAgICAgICAgLy8gaWYgaXQgaXMgdGhlIGNhc2UsIHRoZW4gd2UgbmVlZCB0byBhZGp1c3Qgb3VyIG1heCBzdGFydmF0aW9uIGRlbGF5IHVzaW5nIG1heExvYWRpbmdEZWxheSBjb25maWcgdmFsdWVcbiAgICAgICAgICAvLyBtYXggdmlkZW8gbG9hZGluZyBkZWxheSB1c2VkIGluICBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uIDpcbiAgICAgICAgICAvLyBpbiB0aGF0IG1vZGUgQUJSIGNvbnRyb2xsZXIgd2lsbCBlbnN1cmUgdGhhdCB2aWRlbyBsb2FkaW5nIHRpbWUgKGllIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmaXJzdCBmcmFnbWVudCBhdCBsb3dlc3QgcXVhbGl0eSBsZXZlbCArXG4gICAgICAgICAgLy8gdGhlIHRpbWUgdG8gZmV0Y2ggdGhlIGZyYWdtZW50IGF0IHRoZSBhcHByb3ByaWF0ZSBxdWFsaXR5IGxldmVsIGlzIGxlc3MgdGhhbiBgYGBtYXhMb2FkaW5nRGVsYXlgYGAgKVxuICAgICAgICAgIC8vIGNhcCBtYXhMb2FkaW5nRGVsYXkgYW5kIGVuc3VyZSBpdCBpcyBub3QgYmlnZ2VyICd0aGFuIGJpdHJhdGUgdGVzdCcgZnJhZyBkdXJhdGlvblxuICAgICAgICAgIGNvbnN0IG1heExvYWRpbmdEZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb24gPyBNYXRoLm1pbihjdXJyZW50RnJhZ0R1cmF0aW9uLCBjb25maWcubWF4TG9hZGluZ0RlbGF5KSA6IGNvbmZpZy5tYXhMb2FkaW5nRGVsYXk7XG4gICAgICAgICAgbWF4U3RhcnZhdGlvbkRlbGF5ID0gbWF4TG9hZGluZ0RlbGF5IC0gYml0cmF0ZVRlc3REZWxheTtcbiAgICAgICAgICBsb2dnZXIudHJhY2UoYGJpdHJhdGUgdGVzdCB0b29rICR7TWF0aC5yb3VuZCgxMDAwICogYml0cmF0ZVRlc3REZWxheSl9bXMsIHNldCBmaXJzdCBmcmFnbWVudCBtYXggZmV0Y2hEdXJhdGlvbiB0byAke01hdGgucm91bmQoMTAwMCAqIG1heFN0YXJ2YXRpb25EZWxheSl9IG1zYCk7XG4gICAgICAgICAgLy8gZG9uJ3QgdXNlIGNvbnNlcnZhdGl2ZSBmYWN0b3Igb24gYml0cmF0ZSB0ZXN0XG4gICAgICAgICAgYndGYWN0b3IgPSBid1VwRmFjdG9yID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmVzdExldmVsID0gdGhpcy5fZmluZEJlc3RMZXZlbChjdXJyZW50TGV2ZWwsIGN1cnJlbnRGcmFnRHVyYXRpb24sIGF2Z2J3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ICsgbWF4U3RhcnZhdGlvbkRlbGF5LCBid0ZhY3RvciwgYndVcEZhY3RvciwgbGV2ZWxzKTtcbiAgICAgIHJldHVybiBNYXRoLm1heChiZXN0TGV2ZWwsIDApO1xuICAgIH1cbiAgfVxuXG4gIF9maW5kQmVzdExldmVsIChjdXJyZW50TGV2ZWwsIGN1cnJlbnRGcmFnRHVyYXRpb24sIGN1cnJlbnRCdywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIG1heEZldGNoRHVyYXRpb24sIGJ3RmFjdG9yLCBid1VwRmFjdG9yLCBsZXZlbHMpIHtcbiAgICBmb3IgKGxldCBpID0gbWF4QXV0b0xldmVsOyBpID49IG1pbkF1dG9MZXZlbDsgaS0tKSB7XG4gICAgICBsZXQgbGV2ZWxJbmZvID0gbGV2ZWxzW2ldO1xuXG4gICAgICBpZiAoIWxldmVsSW5mbykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGxldmVsRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzLFxuICAgICAgICBhdmdEdXJhdGlvbiA9IGxldmVsRGV0YWlscyA/IGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uIC8gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggOiBjdXJyZW50RnJhZ0R1cmF0aW9uLFxuICAgICAgICBsaXZlID0gbGV2ZWxEZXRhaWxzID8gbGV2ZWxEZXRhaWxzLmxpdmUgOiBmYWxzZSxcbiAgICAgICAgYWRqdXN0ZWRidztcbiAgICAgIC8vIGZvbGxvdyBhbGdvcml0aG0gY2FwdHVyZWQgZnJvbSBzdGFnZWZyaWdodCA6XG4gICAgICAvLyBodHRwczovL2FuZHJvaWQuZ29vZ2xlc291cmNlLmNvbS9wbGF0Zm9ybS9mcmFtZXdvcmtzL2F2LysvbWFzdGVyL21lZGlhL2xpYnN0YWdlZnJpZ2h0L2h0dHBsaXZlL0xpdmVTZXNzaW9uLmNwcFxuICAgICAgLy8gUGljayB0aGUgaGlnaGVzdCBiYW5kd2lkdGggc3RyZWFtIGJlbG93IG9yIGVxdWFsIHRvIGVzdGltYXRlZCBiYW5kd2lkdGguXG4gICAgICAvLyBjb25zaWRlciBvbmx5IDgwJSBvZiB0aGUgYXZhaWxhYmxlIGJhbmR3aWR0aCwgYnV0IGlmIHdlIGFyZSBzd2l0Y2hpbmcgdXAsXG4gICAgICAvLyBiZSBldmVuIG1vcmUgY29uc2VydmF0aXZlICg3MCUpIHRvIGF2b2lkIG92ZXJlc3RpbWF0aW5nIGFuZCBpbW1lZGlhdGVseVxuICAgICAgLy8gc3dpdGNoaW5nIGJhY2suXG4gICAgICBpZiAoaSA8PSBjdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgYWRqdXN0ZWRidyA9IGJ3RmFjdG9yICogY3VycmVudEJ3O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRqdXN0ZWRidyA9IGJ3VXBGYWN0b3IgKiBjdXJyZW50Qnc7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJpdHJhdGUgPSBsZXZlbHNbaV0ucmVhbEJpdHJhdGUgPyBNYXRoLm1heChsZXZlbHNbaV0ucmVhbEJpdHJhdGUsIGxldmVsc1tpXS5iaXRyYXRlKSA6IGxldmVsc1tpXS5iaXRyYXRlLFxuICAgICAgICBmZXRjaER1cmF0aW9uID0gYml0cmF0ZSAqIGF2Z0R1cmF0aW9uIC8gYWRqdXN0ZWRidztcblxuICAgICAgbG9nZ2VyLnRyYWNlKGBsZXZlbC9hZGp1c3RlZGJ3L2JpdHJhdGUvYXZnRHVyYXRpb24vbWF4RmV0Y2hEdXJhdGlvbi9mZXRjaER1cmF0aW9uOiAke2l9LyR7TWF0aC5yb3VuZChhZGp1c3RlZGJ3KX0vJHtiaXRyYXRlfS8ke2F2Z0R1cmF0aW9ufS8ke21heEZldGNoRHVyYXRpb259LyR7ZmV0Y2hEdXJhdGlvbn1gKTtcbiAgICAgIC8vIGlmIGFkanVzdGVkIGJ3IGlzIGdyZWF0ZXIgdGhhbiBsZXZlbCBiaXRyYXRlIEFORFxuICAgICAgaWYgKGFkanVzdGVkYncgPiBiaXRyYXRlICYmXG4gICAgICAvLyBmcmFnbWVudCBmZXRjaER1cmF0aW9uIHVua25vd24gT1IgbGl2ZSBzdHJlYW0gT1IgZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiBsZXNzIHRoYW4gbWF4IGFsbG93ZWQgZmV0Y2ggZHVyYXRpb24sIHRoZW4gdGhpcyBsZXZlbCBtYXRjaGVzXG4gICAgICAvLyB3ZSBkb24ndCBhY2NvdW50IGZvciBtYXggRmV0Y2ggRHVyYXRpb24gZm9yIGxpdmUgc3RyZWFtcywgdGhpcyBpcyB0byBhdm9pZCBzd2l0Y2hpbmcgZG93biB3aGVuIG5lYXIgdGhlIGVkZ2Ugb2YgbGl2ZSBzbGlkaW5nIHdpbmRvdyAuLi5cbiAgICAgIC8vIHNwZWNpYWwgY2FzZSB0byBzdXBwb3J0IHN0YXJ0TGV2ZWwgPSAtMSAoYml0cmF0ZVRlc3QpIG9uIGxpdmUgc3RyZWFtcyA6IGluIHRoYXQgY2FzZSB3ZSBzaG91bGQgbm90IGV4aXQgbG9vcCBzbyB0aGF0IF9maW5kQmVzdExldmVsIHdpbGwgcmV0dXJuIC0xXG4gICAgICAgICghZmV0Y2hEdXJhdGlvbiB8fMKgKGxpdmUgJiYgIXRoaXMuYml0cmF0ZVRlc3REZWxheSkgfHwgZmV0Y2hEdXJhdGlvbiA8IG1heEZldGNoRHVyYXRpb24pKSB7XG4gICAgICAgIC8vIGFzIHdlIGFyZSBsb29waW5nIGZyb20gaGlnaGVzdCB0byBsb3dlc3QsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGJlc3QgYWNoaWV2YWJsZSBxdWFsaXR5IGxldmVsXG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBub3QgZW5vdWdoIHRpbWUgYnVkZ2V0IGV2ZW4gd2l0aCBxdWFsaXR5IGxldmVsIDAgLi4uIHJlYnVmZmVyaW5nIG1pZ2h0IGhhcHBlblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHNldCBuZXh0QXV0b0xldmVsIChuZXh0TGV2ZWwpIHtcbiAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gbmV4dExldmVsO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFickNvbnRyb2xsZXI7XG4iLCIvKlxuICogQXVkaW8gU3RyZWFtIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBCaW5hcnlTZWFyY2ggZnJvbSAnLi4vdXRpbHMvYmluYXJ5LXNlYXJjaCc7XG5pbXBvcnQgeyBCdWZmZXJIZWxwZXIgfSBmcm9tICcuLi91dGlscy9idWZmZXItaGVscGVyJztcbmltcG9ydCBEZW11eGVyIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXInO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgKiBhcyBMZXZlbEhlbHBlciBmcm9tICcuL2xldmVsLWhlbHBlcic7XG5pbXBvcnQgVGltZVJhbmdlcyBmcm9tICcuLi91dGlscy90aW1lLXJhbmdlcyc7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IGZpbmRGcmFnV2l0aENDIH0gZnJvbSAnLi4vdXRpbHMvZGlzY29udGludWl0aWVzJztcbmltcG9ydCB7IEZyYWdtZW50U3RhdGUgfSBmcm9tICcuL2ZyYWdtZW50LXRyYWNrZXInO1xuaW1wb3J0IEZyYWdtZW50IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgQmFzZVN0cmVhbUNvbnRyb2xsZXIsIHsgU3RhdGUgfSBmcm9tICcuL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXInO1xuY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gd2luZG93O1xuXG5jb25zdCBUSUNLX0lOVEVSVkFMID0gMTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuXG5jbGFzcyBBdWRpb1N0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlU3RyZWFtQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMsIGZyYWdtZW50VHJhY2tlcikge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSEVELFxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tTX1VQREFURUQsXG4gICAgICBFdmVudC5BVURJT19UUkFDS19TV0lUQ0hJTkcsXG4gICAgICBFdmVudC5BVURJT19UUkFDS19MT0FERUQsXG4gICAgICBFdmVudC5LRVlfTE9BREVELFxuICAgICAgRXZlbnQuRlJBR19MT0FERUQsXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULFxuICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsXG4gICAgICBFdmVudC5GUkFHX1BBUlNFRCxcbiAgICAgIEV2ZW50LkVSUk9SLFxuICAgICAgRXZlbnQuQlVGRkVSX1JFU0VULFxuICAgICAgRXZlbnQuQlVGRkVSX0NSRUFURUQsXG4gICAgICBFdmVudC5CVUZGRVJfQVBQRU5ERUQsXG4gICAgICBFdmVudC5CVUZGRVJfRkxVU0hFRCxcbiAgICAgIEV2ZW50LklOSVRfUFRTX0ZPVU5EKTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IGZyYWdtZW50VHJhY2tlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dhcCA9IGZhbHNlO1xuICAgIHRoaXMuX3N0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IG51bGw7XG4gICAgdGhpcy52aWRlb1RyYWNrQ0MgPSBudWxsO1xuICB9XG5cbiAgLy8gU2lnbmFsIHRoYXQgdmlkZW8gUFRTIHdhcyBmb3VuZFxuICBvbkluaXRQdHNGb3VuZCAoZGF0YSkge1xuICAgIGxldCBkZW11eGVySWQgPSBkYXRhLmlkLCBjYyA9IGRhdGEuZnJhZy5jYywgaW5pdFBUUyA9IGRhdGEuaW5pdFBUUztcbiAgICBpZiAoZGVtdXhlcklkID09PSAnbWFpbicpIHtcbiAgICAgIC8vIEFsd2F5cyB1cGRhdGUgdGhlIG5ldyBJTklUIFBUU1xuICAgICAgLy8gQ2FuIGNoYW5nZSBkdWUgbGV2ZWwgc3dpdGNoXG4gICAgICB0aGlzLmluaXRQVFNbY2NdID0gaW5pdFBUUztcbiAgICAgIHRoaXMudmlkZW9UcmFja0NDID0gY2M7XG4gICAgICBsb2dnZXIubG9nKGBJbml0UFRTIGZvciBjYzogJHtjY30gZm91bmQgZnJvbSB2aWRlbyB0cmFjazogJHtpbml0UFRTfWApO1xuXG4gICAgICAvLyBJZiB3ZSBhcmUgd2FpdGluZyB3ZSBuZWVkIHRvIGRlbXV4L3JlbXV4IHRoZSB3YWl0aW5nIGZyYWdcbiAgICAgIC8vIFdpdGggdGhlIG5ldyBpbml0UFRTXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19JTklUX1BUUykge1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGFydExvYWQgKHN0YXJ0UG9zaXRpb24pIHtcbiAgICBpZiAodGhpcy50cmFja3MpIHtcbiAgICAgIGxldCBsYXN0Q3VycmVudFRpbWUgPSB0aGlzLmxhc3RDdXJyZW50VGltZTtcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgYXVkaW86b3ZlcnJpZGUgc3RhcnRQb3NpdGlvbiB3aXRoIGxhc3RDdXJyZW50VGltZSBAJHtsYXN0Q3VycmVudFRpbWUudG9GaXhlZCgzKX1gKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMuc3RhcnRQb3NpdGlvbiA/IHRoaXMuc3RhcnRQb3NpdGlvbiA6IHN0YXJ0UG9zaXRpb247XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVEFSVElORztcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB9XG4gIH1cblxuICBzZXQgc3RhdGUgKG5leHRTdGF0ZSkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBuZXh0U3RhdGUpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgdGhpcy5fc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICBsb2dnZXIubG9nKGBhdWRpbyBzdHJlYW06JHtwcmV2aW91c1N0YXRlfS0+JHtuZXh0U3RhdGV9YCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cblxuICBkb1RpY2sgKCkge1xuICAgIGxldCBwb3MsIHRyYWNrLCB0cmFja0RldGFpbHMsIGhscyA9IHRoaXMuaGxzLCBjb25maWcgPSBobHMuY29uZmlnO1xuICAgIC8vIGxvZ2dlci5sb2coJ2F1ZGlvU3RyZWFtOicgKyB0aGlzLnN0YXRlKTtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICBjYXNlIFN0YXRlLkVSUk9SOlxuICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgaW4gZXJyb3Igc3RhdGUgdG8gYXZvaWQgYnJlYWtpbmcgZnVydGhlciAuLi5cbiAgICBjYXNlIFN0YXRlLlBBVVNFRDpcbiAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGluIHBhdXNlZCBzdGF0ZSBlaXRoZXIgLi4uXG4gICAgY2FzZSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFN0YXRlLlNUQVJUSU5HOlxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfVFJBQ0s7XG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFN0YXRlLklETEU6XG4gICAgICBjb25zdCB0cmFja3MgPSB0aGlzLnRyYWNrcztcbiAgICAgIC8vIGF1ZGlvIHRyYWNrcyBub3QgcmVjZWl2ZWQgPT4gZXhpdCBsb29wXG4gICAgICBpZiAoIXRyYWNrcykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORFxuICAgICAgLy8gc3RhcnQgZnJhZ21lbnQgYWxyZWFkeSByZXF1ZXN0ZWQgT1Igc3RhcnQgZnJhZyBwcmVmZXRjaCBkaXNhYmxlXG4gICAgICAvLyBleGl0IGxvb3BcbiAgICAgIC8vID0+IGlmIG1lZGlhIG5vdCBhdHRhY2hlZCBidXQgc3RhcnQgZnJhZyBwcmVmZXRjaCBpcyBlbmFibGVkIGFuZCBzdGFydCBmcmFnIG5vdCByZXF1ZXN0ZWQgeWV0LCB3ZSB3aWxsIG5vdCBleGl0IGxvb3BcbiAgICAgIGlmICghdGhpcy5tZWRpYSAmJlxuICAgICAgICAgICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCB8fCAhY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gZGV0ZXJtaW5lIG5leHQgY2FuZGlkYXRlIGZyYWdtZW50IHRvIGJlIGxvYWRlZCwgYmFzZWQgb24gY3VycmVudCBwb3NpdGlvbiBhbmRcbiAgICAgIC8vICBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG4gICAgICAvLyBpZiB3ZSBoYXZlIG5vdCB5ZXQgbG9hZGVkIGFueSBmcmFnbWVudCwgc3RhcnQgbG9hZGluZyBmcm9tIHN0YXJ0IHBvc2l0aW9uXG4gICAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgICBwb3MgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gdGhpcy5uZXh0TG9hZFBvc2l0aW9uO1xuICAgICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhLFxuICAgICAgICB2aWRlb0J1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXIgPyB0aGlzLnZpZGVvQnVmZmVyIDogdGhpcy5tZWRpYSxcbiAgICAgICAgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBwb3MsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKSxcbiAgICAgICAgbWFpbkJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh2aWRlb0J1ZmZlciwgcG9zLCBjb25maWcubWF4QnVmZmVySG9sZSksXG4gICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuLFxuICAgICAgICBidWZmZXJFbmQgPSBidWZmZXJJbmZvLmVuZCxcbiAgICAgICAgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXMsXG4gICAgICAgIC8vIGVuc3VyZSB3ZSBidWZmZXIgYXQgbGVhc3QgY29uZmlnLm1heEJ1ZmZlckxlbmd0aCAoZGVmYXVsdCAzMHMpIG9yIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggKGRlZmF1bHQ6IDYwMHMpXG4gICAgICAgIC8vIHdoaWNoZXZlciBpcyBzbWFsbGVyLlxuICAgICAgICAvLyBvbmNlIHdlIHJlYWNoIHRoYXQgdGhyZXNob2xkLCBkb24ndCBidWZmZXIgbW9yZSB0aGFuIHZpZGVvIChtYWluQnVmZmVySW5mby5sZW4pXG4gICAgICAgIG1heENvbmZpZ0J1ZmZlciA9IE1hdGgubWluKGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgsIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgpLFxuICAgICAgICBtYXhCdWZMZW4gPSBNYXRoLm1heChtYXhDb25maWdCdWZmZXIsIG1haW5CdWZmZXJJbmZvLmxlbiksXG4gICAgICAgIGF1ZGlvU3dpdGNoID0gdGhpcy5hdWRpb1N3aXRjaCxcbiAgICAgICAgdHJhY2tJZCA9IHRoaXMudHJhY2tJZDtcblxuICAgICAgICAvLyBpZiBidWZmZXIgbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhCdWZMZW4gdHJ5IHRvIGxvYWQgYSBuZXcgZnJhZ21lbnRcbiAgICAgIGlmICgoYnVmZmVyTGVuIDwgbWF4QnVmTGVuIHx8IGF1ZGlvU3dpdGNoKSAmJiB0cmFja0lkIDwgdHJhY2tzLmxlbmd0aCkge1xuICAgICAgICB0cmFja0RldGFpbHMgPSB0cmFja3NbdHJhY2tJZF0uZGV0YWlscztcbiAgICAgICAgLy8gaWYgdHJhY2sgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciB0cmFjayByZXRyaWV2YWxcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFja0RldGFpbHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfVFJBQ0s7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWF1ZGlvU3dpdGNoICYmIHRoaXMuX3N0cmVhbUVuZGVkKGJ1ZmZlckluZm8sIHRyYWNrRGV0YWlscykpIHtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9FT1MsIHsgdHlwZTogJ2F1ZGlvJyB9KTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRU5ERUQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAgICAgbGV0IGZyYWdtZW50cyA9IHRyYWNrRGV0YWlscy5mcmFnbWVudHMsXG4gICAgICAgICAgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgc3RhcnQgPSBmcmFnbWVudHNbMF0uc3RhcnQsXG4gICAgICAgICAgZW5kID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXS5zdGFydCArIGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uZHVyYXRpb24sXG4gICAgICAgICAgZnJhZztcblxuICAgICAgICAgIC8vIFdoZW4gc3dpdGNoaW5nIGF1ZGlvIHRyYWNrLCByZWxvYWQgYXVkaW8gYXMgY2xvc2UgYXMgcG9zc2libGUgdG8gY3VycmVudFRpbWVcbiAgICAgICAgaWYgKGF1ZGlvU3dpdGNoKSB7XG4gICAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5saXZlICYmICF0cmFja0RldGFpbHMuUFRTS25vd24pIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ3N3aXRjaGluZyBhdWRpb3RyYWNrLCBsaXZlIHN0cmVhbSwgdW5rbm93biBQVFMsbG9hZCBmaXJzdCBmcmFnbWVudCcpO1xuICAgICAgICAgICAgYnVmZmVyRW5kID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyRW5kID0gcG9zO1xuICAgICAgICAgICAgLy8gaWYgY3VycmVudFRpbWUgKHBvcykgaXMgbGVzcyB0aGFuIGFsdCBhdWRpbyBwbGF5bGlzdCBzdGFydCB0aW1lLCBpdCBtZWFucyB0aGF0IGFsdCBhdWRpbyBpcyBhaGVhZCBvZiBjdXJyZW50VGltZVxuICAgICAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5QVFNLbm93biAmJiBwb3MgPCBzdGFydCkge1xuICAgICAgICAgICAgICAvLyBpZiBldmVyeXRoaW5nIGlzIGJ1ZmZlcmVkIGZyb20gcG9zIHRvIHN0YXJ0IG9yIGlmIGF1ZGlvIGJ1ZmZlciB1cGZyb250LCBsZXQncyBzZWVrIHRvIHN0YXJ0XG4gICAgICAgICAgICAgIGlmIChidWZmZXJJbmZvLmVuZCA+IHN0YXJ0IHx8IGJ1ZmZlckluZm8ubmV4dFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnYWx0IGF1ZGlvIHRyYWNrIGFoZWFkIG9mIG1haW4gdHJhY2ssIHNlZWsgdG8gc3RhcnQgb2YgYWx0IGF1ZGlvIHRyYWNrJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0ICsgMC4wNTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNrRGV0YWlscy5pbml0U2VnbWVudCAmJiAhdHJhY2tEZXRhaWxzLmluaXRTZWdtZW50LmRhdGEpIHtcbiAgICAgICAgICBmcmFnID0gdHJhY2tEZXRhaWxzLmluaXRTZWdtZW50O1xuICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYnJhY2Utc3R5bGVcbiAgICAgICAgLy8gaWYgYnVmZmVyRW5kIGJlZm9yZSBzdGFydCBvZiBwbGF5bGlzdCwgbG9hZCBmaXJzdCBmcmFnbWVudFxuICAgICAgICBlbHNlIGlmIChidWZmZXJFbmQgPD0gc3RhcnQpIHtcbiAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICAgIGlmICh0aGlzLnZpZGVvVHJhY2tDQyAhPT0gbnVsbCAmJiBmcmFnLmNjICE9PSB0aGlzLnZpZGVvVHJhY2tDQykge1xuICAgICAgICAgICAgLy8gRW5zdXJlIHdlIGZpbmQgYSBmcmFnbWVudCB3aGljaCBtYXRjaGVzIHRoZSBjb250aW51aXR5IG9mIHRoZSB2aWRlbyB0cmFja1xuICAgICAgICAgICAgZnJhZyA9IGZpbmRGcmFnV2l0aENDKGZyYWdtZW50cywgdGhpcy52aWRlb1RyYWNrQ0MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHJhY2tEZXRhaWxzLmxpdmUgJiYgZnJhZy5sb2FkSWR4ICYmIGZyYWcubG9hZElkeCA9PT0gdGhpcy5mcmFnTG9hZElkeCkge1xuICAgICAgICAgICAgLy8gd2UganVzdCBsb2FkZWQgdGhpcyBmaXJzdCBmcmFnbWVudCwgYW5kIHdlIGFyZSBzdGlsbCBsYWdnaW5nIGJlaGluZCB0aGUgc3RhcnQgb2YgdGhlIGxpdmUgcGxheWxpc3RcbiAgICAgICAgICAgIC8vIGxldCdzIGZvcmNlIHNlZWsgdG8gc3RhcnRcbiAgICAgICAgICAgIGNvbnN0IG5leHRCdWZmZXJlZCA9IGJ1ZmZlckluZm8ubmV4dFN0YXJ0ID8gYnVmZmVySW5mby5uZXh0U3RhcnQgOiBzdGFydDtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYG5vIGFsdCBhdWRpbyBhdmFpbGFibGUgQGN1cnJlbnRUaW1lOiR7dGhpcy5tZWRpYS5jdXJyZW50VGltZX0sIHNlZWtpbmcgQCR7bmV4dEJ1ZmZlcmVkICsgMC4wNX1gKTtcbiAgICAgICAgICAgIHRoaXMubWVkaWEuY3VycmVudFRpbWUgPSBuZXh0QnVmZmVyZWQgKyAwLjA1O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgZm91bmRGcmFnO1xuICAgICAgICAgIGxldCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICAgICAgY29uc3QgZnJhZ05leHQgPSBmcmFnUHJldmlvdXMgPyBmcmFnbWVudHNbZnJhZ1ByZXZpb3VzLnNuIC0gZnJhZ21lbnRzWzBdLnNuICsgMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgbGV0IGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdCA9IChjYW5kaWRhdGUpID0+IHtcbiAgICAgICAgICAgIC8vIG9mZnNldCBzaG91bGQgYmUgd2l0aGluIGZyYWdtZW50IGJvdW5kYXJ5IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2VcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gY29wZSB3aXRoIHNpdHVhdGlvbnMgbGlrZVxuICAgICAgICAgICAgLy8gYnVmZmVyRW5kID0gOS45OTFcbiAgICAgICAgICAgIC8vIGZyYWdbw5hdIDogWzAsMTBdXG4gICAgICAgICAgICAvLyBmcmFnWzFdIDogWzEwLDIwXVxuICAgICAgICAgICAgLy8gYnVmZmVyRW5kIGlzIHdpdGhpbiBmcmFnWzBdIHJhbmdlIC4uLiBhbHRob3VnaCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgaXMgdG8gcmV0dXJuIGZyYWdbMV0gaGVyZVxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgIGZyYWcgc3RhcnQgICAgICAgICAgICAgICBmcmFnIHN0YXJ0K2R1cmF0aW9uXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICA8LS0tPiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tPlxuICAgICAgICAgICAgLy8gIC4uLi0tLS0tLS0tPjwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT48LS0tLS0tLS0tLi4uLlxuICAgICAgICAgICAgLy8gcHJldmlvdXMgZnJhZyAgICAgICAgIG1hdGNoaW5nIGZyYWdtZW50ICAgICAgICAgbmV4dCBmcmFnXG4gICAgICAgICAgICAvLyAgcmV0dXJuIC0xICAgICAgICAgICAgIHJldHVybiAwICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZyhgbGV2ZWwvc24vc3RhcnQvZW5kL2J1ZkVuZDoke2xldmVsfS8ke2NhbmRpZGF0ZS5zbn0vJHtjYW5kaWRhdGUuc3RhcnR9LyR7KGNhbmRpZGF0ZS5zdGFydCtjYW5kaWRhdGUuZHVyYXRpb24pfS8ke2J1ZmZlckVuZH1gKTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgbG9va3VwIHRvbGVyYW5jZSB0byBiZSBzbWFsbCBlbm91Z2ggdG8gZGV0ZWN0IHRoZSBjdXJyZW50IHNlZ21lbnQgLSBlbnN1cmVzIHdlIGRvbid0IHNraXAgb3ZlciB2ZXJ5IHNtYWxsIHNlZ21lbnRzXG4gICAgICAgICAgICBsZXQgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmICgoY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlKSA8PSBidWZmZXJFbmQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5zdGFydCAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IGJ1ZmZlckVuZCAmJiBjYW5kaWRhdGUuc3RhcnQpIHtcbiAgICAgICAgICAgICAgLy8gaWYgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB3aWxsIGhhdmUgbmVnYXRpdmUgdmFsdWUgdGhlbiBkb24ndCByZXR1cm4gLTEgZm9yIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGJ1ZmZlckVuZCA8IGVuZCkge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlckVuZCA+IGVuZCAtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByZWZlciB0aGUgbmV4dCBmcmFnbWVudCBpZiBpdCdzIHdpdGhpbiB0b2xlcmFuY2VcbiAgICAgICAgICAgIGlmIChmcmFnTmV4dCAmJiAhZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGZyYWdOZXh0KSkge1xuICAgICAgICAgICAgICBmb3VuZEZyYWcgPSBmcmFnTmV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvdW5kRnJhZyA9IEJpbmFyeVNlYXJjaC5zZWFyY2goZnJhZ21lbnRzLCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByZWFjaCBlbmQgb2YgcGxheWxpc3RcbiAgICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmb3VuZEZyYWcpIHtcbiAgICAgICAgICAgIGZyYWcgPSBmb3VuZEZyYWc7XG4gICAgICAgICAgICBzdGFydCA9IGZvdW5kRnJhZy5zdGFydDtcbiAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2ZpbmQgU04gbWF0Y2hpbmcgd2l0aCBwb3M6JyArICBidWZmZXJFbmQgKyAnOicgKyBmcmFnLnNuKTtcbiAgICAgICAgICAgIGlmIChmcmFnUHJldmlvdXMgJiYgZnJhZy5sZXZlbCA9PT0gZnJhZ1ByZXZpb3VzLmxldmVsICYmIGZyYWcuc24gPT09IGZyYWdQcmV2aW91cy5zbikge1xuICAgICAgICAgICAgICBpZiAoZnJhZy5zbiA8IHRyYWNrRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbZnJhZy5zbiArIDEgLSB0cmFja0RldGFpbHMuc3RhcnRTTl07XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgU04ganVzdCBsb2FkZWQsIGxvYWQgbmV4dCBvbmU6ICR7ZnJhZy5zbn1gKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJyAgICAgIGxvYWRpbmcgZnJhZyAnICsgaSArJyxwb3MvYnVmRW5kOicgKyBwb3MudG9GaXhlZCgzKSArICcvJyArIGJ1ZmZlckVuZC50b0ZpeGVkKDMpKTtcbiAgICAgICAgICBpZiAoZnJhZy5lbmNyeXB0ZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYExvYWRpbmcga2V5IGZvciAke2ZyYWcuc259IG9mIFske3RyYWNrRGV0YWlscy5zdGFydFNOfSAsJHt0cmFja0RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuS0VZX0xPQURJTkc7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5LRVlfTE9BRElORywgeyBmcmFnOiBmcmFnIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBMb2FkaW5nICR7ZnJhZy5zbn0sIGNjOiAke2ZyYWcuY2N9IG9mIFske3RyYWNrRGV0YWlscy5zdGFydFNOfSAsJHt0cmFja0RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9LCBjdXJyZW50VGltZToke3Bvc30sYnVmZmVyRW5kOiR7YnVmZmVyRW5kLnRvRml4ZWQoMyl9YCk7XG4gICAgICAgICAgICAvLyBvbmx5IGxvYWQgaWYgZnJhZ21lbnQgaXMgbm90IGxvYWRlZCBvciBpZiBpbiBhdWRpbyBzd2l0Y2hcbiAgICAgICAgICAgIC8vIHdlIGZvcmNlIGEgZnJhZyBsb2FkaW5nIGluIGF1ZGlvIHN3aXRjaCBhcyBmcmFnbWVudCB0cmFja2VyIG1pZ2h0IG5vdCBoYXZlIGV2aWN0ZWQgcHJldmlvdXMgZnJhZ3MgaW4gY2FzZSBvZiBxdWljayBhdWRpbyBzd2l0Y2hcbiAgICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAgICAgICAgaWYgKGF1ZGlvU3dpdGNoIHx8IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpID09PSBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGZyYWcuc24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURJTkcsIHsgZnJhZyB9KTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU3RhdGUuV0FJVElOR19UUkFDSzpcbiAgICAgIHRyYWNrID0gdGhpcy50cmFja3NbdGhpcy50cmFja0lkXTtcbiAgICAgIC8vIGNoZWNrIGlmIHBsYXlsaXN0IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICBpZiAodHJhY2sgJiYgdHJhY2suZGV0YWlscykge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgIHZhciBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHZhciByZXRyeURhdGUgPSB0aGlzLnJldHJ5RGF0ZTtcbiAgICAgIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIHZhciBpc1NlZWtpbmcgPSBtZWRpYSAmJiBtZWRpYS5zZWVraW5nO1xuICAgICAgLy8gaWYgY3VycmVudCB0aW1lIGlzIGd0IHRoYW4gcmV0cnlEYXRlLCBvciBpZiBtZWRpYSBzZWVraW5nIGxldCdzIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgIGlmICghcmV0cnlEYXRlIHx8IChub3cgPj0gcmV0cnlEYXRlKSB8fCBpc1NlZWtpbmcpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnYXVkaW9TdHJlYW1Db250cm9sbGVyOiByZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZScpO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU3RhdGUuV0FJVElOR19JTklUX1BUUzpcbiAgICAgIGNvbnN0IHZpZGVvVHJhY2tDQyA9IHRoaXMudmlkZW9UcmFja0NDO1xuICAgICAgaWYgKHRoaXMuaW5pdFBUU1t2aWRlb1RyYWNrQ0NdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIEVuc3VyZSB3ZSBkb24ndCBnZXQgc3R1Y2sgaW4gdGhlIFdBSVRJTkdfSU5JVF9QVFMgc3RhdGUgaWYgdGhlIHdhaXRpbmcgZnJhZyBDQyBkb2Vzbid0IG1hdGNoIGFueSBpbml0UFRTXG4gICAgICBjb25zdCB3YWl0aW5nRnJhZyA9IHRoaXMud2FpdGluZ0ZyYWdtZW50O1xuICAgICAgaWYgKHdhaXRpbmdGcmFnKSB7XG4gICAgICAgIGNvbnN0IHdhaXRpbmdGcmFnQ0MgPSB3YWl0aW5nRnJhZy5mcmFnLmNjO1xuICAgICAgICBpZiAodmlkZW9UcmFja0NDICE9PSB3YWl0aW5nRnJhZ0NDKSB7XG4gICAgICAgICAgdHJhY2sgPSB0aGlzLnRyYWNrc1t0aGlzLnRyYWNrSWRdO1xuICAgICAgICAgIGlmICh0cmFjay5kZXRhaWxzICYmIHRyYWNrLmRldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFdhaXRpbmcgZnJhZ21lbnQgQ0MgKCR7d2FpdGluZ0ZyYWdDQ30pIGRvZXMgbm90IG1hdGNoIHZpZGVvIHRyYWNrIENDICgke3ZpZGVvVHJhY2tDQ30pYCk7XG4gICAgICAgICAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgICAgICB0aGlzLm9uRnJhZ0xvYWRlZCh0aGlzLndhaXRpbmdGcmFnbWVudCk7XG4gICAgICAgICAgdGhpcy53YWl0aW5nRnJhZ21lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTdGF0ZS5TVE9QUEVEOlxuICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HOlxuICAgIGNhc2UgU3RhdGUuUEFSU0lORzpcbiAgICBjYXNlIFN0YXRlLlBBUlNFRDpcbiAgICBjYXNlIFN0YXRlLkVOREVEOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFBdHRhY2hlZCAoZGF0YSkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9uTWVkaWFTZWVraW5nLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbnZlbmRlZCA9IHRoaXMub25NZWRpYUVuZGVkLmJpbmQodGhpcyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYgKHRoaXMudHJhY2tzICYmIGNvbmZpZy5hdXRvU3RhcnRMb2FkKSB7XG4gICAgICB0aGlzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgb25NZWRpYURldGFjaGluZyAoKSB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEuZW5kZWQpIHtcbiAgICAgIGxvZ2dlci5sb2coJ01TRSBkZXRhY2hpbmcgYW5kIHZpZGVvIGVuZGVkLCByZXNldCBzdGFydFBvc2l0aW9uJyk7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHZpZGVvIGxpc3RlbmVyc1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbnZzZWVrZWQgPSB0aGlzLm9udmVuZGVkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICB9XG5cbiAgb25BdWRpb1RyYWNrc1VwZGF0ZWQgKGRhdGEpIHtcbiAgICBsb2dnZXIubG9nKCdhdWRpbyB0cmFja3MgdXBkYXRlZCcpO1xuICAgIHRoaXMudHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcztcbiAgfVxuXG4gIG9uQXVkaW9UcmFja1N3aXRjaGluZyAoZGF0YSkge1xuICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICBsZXQgYWx0QXVkaW8gPSAhIWRhdGEudXJsO1xuICAgIHRoaXMudHJhY2tJZCA9IGRhdGEuaWQ7XG5cbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFVU0VEO1xuICAgIHRoaXMud2FpdGluZ0ZyYWdtZW50ID0gbnVsbDtcbiAgICAvLyBkZXN0cm95IHVzZWxlc3MgZGVtdXhlciB3aGVuIHN3aXRjaGluZyBhdWRpbyB0byBtYWluXG4gICAgaWYgKCFhbHRBdWRpbykge1xuICAgICAgaWYgKHRoaXMuZGVtdXhlcikge1xuICAgICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRlbXV4ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzd2l0Y2hpbmcgdG8gYXVkaW8gdHJhY2ssIHN0YXJ0IHRpbWVyIGlmIG5vdCBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgfVxuXG4gICAgLy8gc2hvdWxkIHdlIHN3aXRjaCB0cmFja3MgP1xuICAgIGlmIChhbHRBdWRpbykge1xuICAgICAgdGhpcy5hdWRpb1N3aXRjaCA9IHRydWU7XG4gICAgICAvLyBtYWluIGF1ZGlvIHRyYWNrIGFyZSBoYW5kbGVkIGJ5IHN0cmVhbS1jb250cm9sbGVyLCBqdXN0IGRvIHNvbWV0aGluZyBpZiBzd2l0Y2hpbmcgdG8gYWx0IGF1ZGlvIHRyYWNrXG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBvbkF1ZGlvVHJhY2tMb2FkZWQgKGRhdGEpIHtcbiAgICBsZXQgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscyxcbiAgICAgIHRyYWNrSWQgPSBkYXRhLmlkLFxuICAgICAgdHJhY2sgPSB0aGlzLnRyYWNrc1t0cmFja0lkXSxcbiAgICAgIGR1cmF0aW9uID0gbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uLFxuICAgICAgc2xpZGluZyA9IDA7XG5cbiAgICBsb2dnZXIubG9nKGB0cmFjayAke3RyYWNrSWR9IGxvYWRlZCBbJHtuZXdEZXRhaWxzLnN0YXJ0U059LCR7bmV3RGV0YWlscy5lbmRTTn1dLGR1cmF0aW9uOiR7ZHVyYXRpb259YCk7XG5cbiAgICBpZiAobmV3RGV0YWlscy5saXZlKSB7XG4gICAgICBsZXQgY3VyRGV0YWlscyA9IHRyYWNrLmRldGFpbHM7XG4gICAgICBpZiAoY3VyRGV0YWlscyAmJiBuZXdEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHdlIGFscmVhZHkgaGF2ZSBkZXRhaWxzIGZvciB0aGF0IGxldmVsLCBtZXJnZSB0aGVtXG4gICAgICAgIExldmVsSGVscGVyLm1lcmdlRGV0YWlscyhjdXJEZXRhaWxzLCBuZXdEZXRhaWxzKTtcbiAgICAgICAgc2xpZGluZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIHRoaXMubGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZUxpdmVQb3NpdGlvbihzbGlkaW5nLCBjdXJEZXRhaWxzKTtcbiAgICAgICAgaWYgKG5ld0RldGFpbHMuUFRTS25vd24pIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBsaXZlIGF1ZGlvIHBsYXlsaXN0IHNsaWRpbmc6JHtzbGlkaW5nLnRvRml4ZWQoMyl9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnbGl2ZSBhdWRpbyBwbGF5bGlzdCAtIG91dGRhdGVkIFBUUywgdW5rbm93biBzbGlkaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcbiAgICAgICAgbG9nZ2VyLmxvZygnbGl2ZSBhdWRpbyBwbGF5bGlzdCAtIGZpcnN0IGxvYWQsIHVua25vd24gc2xpZGluZycpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gZmFsc2U7XG4gICAgfVxuICAgIHRyYWNrLmRldGFpbHMgPSBuZXdEZXRhaWxzO1xuXG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvblxuICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICAvLyBjb21wdXRlIHN0YXJ0IHBvc2l0aW9uIGlmIHNldCB0byAtMS4gdXNlIGl0IHN0cmFpZ2h0IGF3YXkgaWYgdmFsdWUgaXMgZGVmaW5lZFxuICAgICAgaWYgKHRoaXMuc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgLy8gZmlyc3QsIGNoZWNrIGlmIHN0YXJ0IHRpbWUgb2Zmc2V0IGhhcyBiZWVuIHNldCBpbiBwbGF5bGlzdCwgaWYgeWVzLCB1c2UgdGhpcyB2YWx1ZVxuICAgICAgICBsZXQgc3RhcnRUaW1lT2Zmc2V0ID0gbmV3RGV0YWlscy5zdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coYHN0YXJ0IHRpbWUgb2Zmc2V0IGZvdW5kIGluIHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byAke3N0YXJ0VGltZU9mZnNldH1gKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgICAvLyBvbmx5IHN3aXRjaCBiYXRjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgdHJhY2sgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19UUkFDSykge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25LZXlMb2FkZWQgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5LRVlfTE9BRElORykge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdMb2FkZWQgKGRhdGEpIHtcbiAgICBsZXQgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50LFxuICAgICAgZnJhZ0xvYWRlZCA9IGRhdGEuZnJhZztcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HICYmXG4gICAgICAgIGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGZyYWdMb2FkZWQudHlwZSA9PT0gJ2F1ZGlvJyAmJlxuICAgICAgICBmcmFnTG9hZGVkLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICBmcmFnTG9hZGVkLnNuID09PSBmcmFnQ3VycmVudC5zbikge1xuICAgICAgbGV0IHRyYWNrID0gdGhpcy50cmFja3NbdGhpcy50cmFja0lkXSxcbiAgICAgICAgZGV0YWlscyA9IHRyYWNrLmRldGFpbHMsXG4gICAgICAgIGR1cmF0aW9uID0gZGV0YWlscy50b3RhbGR1cmF0aW9uLFxuICAgICAgICB0cmFja0lkID0gZnJhZ0N1cnJlbnQubGV2ZWwsXG4gICAgICAgIHNuID0gZnJhZ0N1cnJlbnQuc24sXG4gICAgICAgIGNjID0gZnJhZ0N1cnJlbnQuY2MsXG4gICAgICAgIGF1ZGlvQ29kZWMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCB0cmFjay5hdWRpb0NvZGVjIHx8ICdtcDRhLjQwLjInLFxuICAgICAgICBzdGF0cyA9IHRoaXMuc3RhdHMgPSBkYXRhLnN0YXRzO1xuICAgICAgaWYgKHNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuXG4gICAgICAgIHN0YXRzLnRwYXJzZWQgPSBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgZGV0YWlscy5pbml0U2VnbWVudC5kYXRhID0gZGF0YS5wYXlsb2FkO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfQlVGRkVSRUQsIHsgc3RhdHM6IHN0YXRzLCBmcmFnOiBmcmFnQ3VycmVudCwgaWQ6ICdhdWRpbycgfSk7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNJTkc7XG4gICAgICAgIC8vIHRyYW5zbXV4IHRoZSBNUEVHLVRTIGRhdGEgdG8gSVNPLUJNRkYgc2VnbWVudHNcbiAgICAgICAgdGhpcy5hcHBlbmRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuZGVtdXhlcikge1xuICAgICAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVyKHRoaXMuaGxzLCAnYXVkaW8nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdmlkZW8gaW5pdFBUU1xuICAgICAgICAvLyBJZiBub3Qgd2UgbmVlZCB0byB3YWl0IGZvciBpdFxuICAgICAgICBsZXQgaW5pdFBUUyA9IHRoaXMuaW5pdFBUU1tjY107XG4gICAgICAgIGxldCBpbml0U2VnbWVudERhdGEgPSBkZXRhaWxzLmluaXRTZWdtZW50ID8gZGV0YWlscy5pbml0U2VnbWVudC5kYXRhIDogW107XG4gICAgICAgIGlmIChkZXRhaWxzLmluaXRTZWdtZW50IHx8IGluaXRQVFMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgRGVtdXhpbmcgJHtzbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfWApO1xuICAgICAgICAgIC8vIHRpbWUgT2Zmc2V0IGlzIGFjY3VyYXRlIGlmIGxldmVsIFBUUyBpcyBrbm93biwgb3IgaWYgcGxheWxpc3QgaXMgbm90IHNsaWRpbmcgKG5vdCBsaXZlKVxuICAgICAgICAgIGxldCBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBmYWxzZTsgLy8gZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlO1xuICAgICAgICAgIHRoaXMuZGVtdXhlci5wdXNoKGRhdGEucGF5bG9hZCwgaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCBudWxsLCBmcmFnQ3VycmVudCwgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgaW5pdFBUUyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgdW5rbm93biB2aWRlbyBQVFMgZm9yIGNvbnRpbnVpdHkgY291bnRlciAke2NjfSwgd2FpdGluZyBmb3IgdmlkZW8gUFRTIGJlZm9yZSBkZW11eGluZyBhdWRpbyBmcmFnICR7c259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLHRyYWNrICR7dHJhY2tJZH1gKTtcbiAgICAgICAgICB0aGlzLndhaXRpbmdGcmFnbWVudCA9IGRhdGE7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdJbml0U2VnbWVudCAoZGF0YSkge1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBjb25zdCBmcmFnTmV3ID0gZGF0YS5mcmFnO1xuICAgIGlmIChmcmFnQ3VycmVudCAmJlxuICAgICAgICBkYXRhLmlkID09PSAnYXVkaW8nICYmXG4gICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIGxldCB0cmFja3MgPSBkYXRhLnRyYWNrcywgdHJhY2s7XG5cbiAgICAgIC8vIGRlbGV0ZSBhbnkgdmlkZW8gdHJhY2sgZm91bmQgb24gYXVkaW8gZGVtdXhlclxuICAgICAgaWYgKHRyYWNrcy52aWRlbykge1xuICAgICAgICBkZWxldGUgdHJhY2tzLnZpZGVvO1xuICAgICAgfVxuXG4gICAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuICAgICAgdHJhY2sgPSB0cmFja3MuYXVkaW87XG4gICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgdHJhY2subGV2ZWxDb2RlYyA9IHRyYWNrLmNvZGVjO1xuICAgICAgICB0cmFjay5pZCA9IGRhdGEuaWQ7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0NPREVDUywgdHJhY2tzKTtcbiAgICAgICAgbG9nZ2VyLmxvZyhgYXVkaW8gdHJhY2s6YXVkaW8sY29udGFpbmVyOiR7dHJhY2suY29udGFpbmVyfSxjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bJHt0cmFjay5sZXZlbENvZGVjfS8ke3RyYWNrLmNvZGVjfV1gKTtcbiAgICAgICAgbGV0IGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG4gICAgICAgIGlmIChpbml0U2VnbWVudCkge1xuICAgICAgICAgIGxldCBhcHBlbmRPYmogPSB7IHR5cGU6ICdhdWRpbycsIGRhdGE6IGluaXRTZWdtZW50LCBwYXJlbnQ6ICdhdWRpbycsIGNvbnRlbnQ6ICdpbml0U2VnbWVudCcgfTtcbiAgICAgICAgICBpZiAodGhpcy5hdWRpb1N3aXRjaCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGF0YSA9IFthcHBlbmRPYmpdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGFybSBwZW5kaW5nIEJ1ZmZlcmluZyBmbGFnIGJlZm9yZSBhcHBlbmRpbmcgYSBzZWdtZW50XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfQVBQRU5ESU5HLCBhcHBlbmRPYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdEYXRhIChkYXRhKSB7XG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdhdWRpbycgJiZcbiAgICAgICAgZGF0YS50eXBlID09PSAnYXVkaW8nICYmXG4gICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIGxldCB0cmFja0lkID0gdGhpcy50cmFja0lkLFxuICAgICAgICB0cmFjayA9IHRoaXMudHJhY2tzW3RyYWNrSWRdLFxuICAgICAgICBobHMgPSB0aGlzLmhscztcblxuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZGF0YS5lbmRQVFMpKSB7XG4gICAgICAgIGRhdGEuZW5kUFRTID0gZGF0YS5zdGFydFBUUyArIGZyYWdDdXJyZW50LmR1cmF0aW9uO1xuICAgICAgICBkYXRhLmVuZERUUyA9IGRhdGEuc3RhcnREVFMgKyBmcmFnQ3VycmVudC5kdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgZnJhZ0N1cnJlbnQuYWRkRWxlbWVudGFyeVN0cmVhbShGcmFnbWVudC5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8pO1xuXG4gICAgICBsb2dnZXIubG9nKGBwYXJzZWQgJHtkYXRhLnR5cGV9LFBUUzpbJHtkYXRhLnN0YXJ0UFRTLnRvRml4ZWQoMyl9LCR7ZGF0YS5lbmRQVFMudG9GaXhlZCgzKX1dLERUUzpbJHtkYXRhLnN0YXJ0RFRTLnRvRml4ZWQoMyl9LyR7ZGF0YS5lbmREVFMudG9GaXhlZCgzKX1dLG5iOiR7ZGF0YS5uYn1gKTtcbiAgICAgIExldmVsSGVscGVyLnVwZGF0ZUZyYWdQVFNEVFModHJhY2suZGV0YWlscywgZnJhZ0N1cnJlbnQsIGRhdGEuc3RhcnRQVFMsIGRhdGEuZW5kUFRTKTtcblxuICAgICAgbGV0IGF1ZGlvU3dpdGNoID0gdGhpcy5hdWRpb1N3aXRjaCwgbWVkaWEgPSB0aGlzLm1lZGlhLCBhcHBlbmRPbkJ1ZmZlckZsdXNoID0gZmFsc2U7XG4gICAgICAvLyBPbmx5IGZsdXNoIGF1ZGlvIGZyb20gb2xkIGF1ZGlvIHRyYWNrcyB3aGVuIFBUUyBpcyBrbm93biBvbiBuZXcgYXVkaW8gdHJhY2tcbiAgICAgIGlmIChhdWRpb1N3aXRjaCAmJiBtZWRpYSkge1xuICAgICAgICBpZiAobWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgICAgIGxldCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3N3aXRjaGluZyBhdWRpbyB0cmFjayA6IGN1cnJlbnRUaW1lOicgKyBjdXJyZW50VGltZSk7XG4gICAgICAgICAgaWYgKGN1cnJlbnRUaW1lID49IGRhdGEuc3RhcnRQVFMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ3N3aXRjaGluZyBhdWRpbyB0cmFjayA6IGZsdXNoaW5nIGFsbCBhdWRpbycpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJVRkZFUl9GTFVTSElORztcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9GTFVTSElORywgeyBzdGFydE9mZnNldDogMCwgZW5kT2Zmc2V0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHR5cGU6ICdhdWRpbycgfSk7XG4gICAgICAgICAgICBhcHBlbmRPbkJ1ZmZlckZsdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIExldHMgYW5ub3VuY2UgdGhhdCB0aGUgaW5pdGlhbCBhdWRpbyB0cmFjayBzd2l0Y2ggZmx1c2ggb2NjdXJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELCB7IGlkOiB0cmFja0lkIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBMZXRzIGFubm91bmNlIHRoYXQgdGhlIGluaXRpYWwgYXVkaW8gdHJhY2sgc3dpdGNoIGZsdXNoIG9jY3VyXG4gICAgICAgICAgdGhpcy5hdWRpb1N3aXRjaCA9IGZhbHNlO1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELCB7IGlkOiB0cmFja0lkIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBwZW5kaW5nRGF0YSA9IHRoaXMucGVuZGluZ0RhdGE7XG5cbiAgICAgIGlmICghcGVuZGluZ0RhdGEpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ0FwcGFyZW50bHkgYXR0ZW1wdCB0byBlbnF1ZXVlIG1lZGlhIHBheWxvYWQgd2l0aG91dCBjb2RlYyBpbml0aWFsaXphdGlvbiBkYXRhIHVwZnJvbnQnKTtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogbnVsbCwgZmF0YWw6IHRydWUgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmF1ZGlvU3dpdGNoKSB7XG4gICAgICAgIFtkYXRhLmRhdGExLCBkYXRhLmRhdGEyXS5mb3JFYWNoKGJ1ZmZlciA9PiB7XG4gICAgICAgICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBwZW5kaW5nRGF0YS5wdXNoKHsgdHlwZTogZGF0YS50eXBlLCBkYXRhOiBidWZmZXIsIHBhcmVudDogJ2F1ZGlvJywgY29udGVudDogJ2RhdGEnIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghYXBwZW5kT25CdWZmZXJGbHVzaCAmJiBwZW5kaW5nRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBwZW5kaW5nRGF0YS5mb3JFYWNoKGFwcGVuZE9iaiA9PiB7XG4gICAgICAgICAgICAvLyBvbmx5IGFwcGVuZCBpbiBQQVJTSU5HIHN0YXRlIChyYXRpb25hbGUgaXMgdGhhdCBhbiBhcHBlbmRpbmcgZXJyb3IgY291bGQgaGFwcGVuIHN5bmNocm9ub3VzbHkgb24gZmlyc3Qgc2VnbWVudCBhcHBlbmRpbmcpXG4gICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgaXQgaXMgdXNlbGVzcyB0byBhcHBlbmQgZm9sbG93aW5nIHNlZ21lbnRzXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICAgICAgICAvLyBhcm0gcGVuZGluZyBCdWZmZXJpbmcgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIGEgc2VnbWVudFxuICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsIGFwcGVuZE9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nRGF0YSA9IFtdO1xuICAgICAgICAgIHRoaXMuYXBwZW5kZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdQYXJzZWQgKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgY29uc3QgZnJhZ05ldyA9IGRhdGEuZnJhZztcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5pZCA9PT0gJ2F1ZGlvJyAmJlxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICB0aGlzLnN0YXRzLnRwYXJzZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTRUQ7XG4gICAgICB0aGlzLl9jaGVja0FwcGVuZGVkUGFyc2VkKCk7XG4gICAgfVxuICB9XG5cbiAgb25CdWZmZXJSZXNldCAoKSB7XG4gICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIHNvdXJjZWJ1ZmZlcnNcbiAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICB9XG5cbiAgb25CdWZmZXJDcmVhdGVkIChkYXRhKSB7XG4gICAgbGV0IGF1ZGlvVHJhY2sgPSBkYXRhLnRyYWNrcy5hdWRpbztcbiAgICBpZiAoYXVkaW9UcmFjaykge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IGF1ZGlvVHJhY2suYnVmZmVyO1xuICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChkYXRhLnRyYWNrcy52aWRlbykge1xuICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IGRhdGEudHJhY2tzLnZpZGVvLmJ1ZmZlcjtcbiAgICB9XG4gIH1cblxuICBvbkJ1ZmZlckFwcGVuZGVkIChkYXRhKSB7XG4gICAgaWYgKGRhdGEucGFyZW50ID09PSAnYXVkaW8nKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICBpZiAoc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcgfHwgc3RhdGUgPT09IFN0YXRlLlBBUlNFRCkge1xuICAgICAgICAvLyBjaGVjayBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gYXBwZW5kZWRcbiAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyaW5nID0gKGRhdGEucGVuZGluZyA+IDApO1xuICAgICAgICB0aGlzLl9jaGVja0FwcGVuZGVkUGFyc2VkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2NoZWNrQXBwZW5kZWRQYXJzZWQgKCkge1xuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEICYmICghdGhpcy5hcHBlbmRlZCB8fCAhdGhpcy5wZW5kaW5nQnVmZmVyaW5nKSkge1xuICAgICAgbGV0IGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50LCBzdGF0cyA9IHRoaXMuc3RhdHMsIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgICBzdGF0cy50YnVmZmVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19CVUZGRVJFRCwgeyBzdGF0czogc3RhdHMsIGZyYWc6IGZyYWcsIGlkOiAnYXVkaW8nIH0pO1xuICAgICAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgICAgIGxvZ2dlci5sb2coYGF1ZGlvIGJ1ZmZlcmVkIDogJHtUaW1lUmFuZ2VzLnRvU3RyaW5nKG1lZGlhLmJ1ZmZlcmVkKX1gKTtcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9Td2l0Y2ggJiYgdGhpcy5hcHBlbmRlZCkge1xuICAgICAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCwgeyBpZDogdGhpcy50cmFja0lkIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25FcnJvciAoZGF0YSkge1xuICAgIGxldCBmcmFnID0gZGF0YS5mcmFnO1xuICAgIC8vIGRvbid0IGhhbmRsZSBmcmFnIGVycm9yIG5vdCByZWxhdGVkIHRvIGF1ZGlvIGZyYWdtZW50XG4gICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgLy8gZG9uJ3QgaGFuZGxlIGZyYWcgZXJyb3Igbm90IHJlbGF0ZWQgdG8gYXVkaW8gZnJhZ21lbnRcbiAgICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gJ2F1ZGlvJykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhLmZhdGFsKSB7XG4gICAgICAgIGxldCBsb2FkRXJyb3IgPSB0aGlzLmZyYWdMb2FkRXJyb3I7XG4gICAgICAgIGlmIChsb2FkRXJyb3IpIHtcbiAgICAgICAgICBsb2FkRXJyb3IrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2FkRXJyb3IgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIGlmIChsb2FkRXJyb3IgPD0gY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnkpIHtcbiAgICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSBsb2FkRXJyb3I7XG4gICAgICAgICAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0XG4gICAgICAgICAgY29uc3QgZGVsYXkgPSBNYXRoLm1pbihNYXRoLnBvdygyLCBsb2FkRXJyb3IgLSAxKSAqIGNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCk7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYEF1ZGlvU3RyZWFtQ29udHJvbGxlcjogZnJhZyBsb2FkaW5nIGZhaWxlZCwgcmV0cnkgaW4gJHtkZWxheX0gbXNgKTtcbiAgICAgICAgICB0aGlzLnJldHJ5RGF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7XG4gICAgICAgICAgLy8gcmV0cnkgbG9hZGluZyBzdGF0ZVxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoYEF1ZGlvU3RyZWFtQ29udHJvbGxlcjogJHtkYXRhLmRldGFpbHN9IHJlYWNoZXMgbWF4IHJldHJ5LCByZWRpc3BhdGNoIGFzIGZhdGFsIC4uLmApO1xuICAgICAgICAgIC8vIHN3aXRjaCBlcnJvciB0byBmYXRhbFxuICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgIC8vICB3aGVuIGluIEVSUk9SIHN0YXRlLCBkb24ndCBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIGluIGNhc2UgYSBub24tZmF0YWwgZXJyb3IgaXMgcmVjZWl2ZWRcbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5FUlJPUikge1xuICAgICAgICAvLyBpZiBmYXRhbCBlcnJvciwgc3RvcCBwcm9jZXNzaW5nLCBvdGhlcndpc2UgbW92ZSB0byBJRExFIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGRhdGEuZmF0YWwgPyBTdGF0ZS5FUlJPUiA6IFN0YXRlLklETEU7XG4gICAgICAgIGxvZ2dlci53YXJuKGBBdWRpb1N0cmVhbUNvbnRyb2xsZXI6ICR7ZGF0YS5kZXRhaWxzfSB3aGlsZSBsb2FkaW5nIGZyYWcsIG5vdyBzd2l0Y2hpbmcgdG8gJHt0aGlzLnN0YXRlfSBzdGF0ZSAuLi5gKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgLy8gaWYgaW4gYXBwZW5kaW5nIHN0YXRlXG4gICAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdhdWRpbycgJiYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcgfHzCoHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCkpIHtcbiAgICAgICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyLFxuICAgICAgICAgIGN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYS5jdXJyZW50VGltZSxcbiAgICAgICAgICBtZWRpYUJ1ZmZlcmVkID0gbWVkaWEgJiYgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQobWVkaWEsIGN1cnJlbnRUaW1lKSAmJiBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSwgY3VycmVudFRpbWUgKyAwLjUpO1xuICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXG4gICAgICAgIGlmIChtZWRpYUJ1ZmZlcmVkKSB7XG4gICAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgaWYgKGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggPj0gY29uZmlnLm1heEJ1ZmZlckxlbmd0aCkge1xuICAgICAgICAgICAgLy8gcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIGFzIGl0IG1pZ2h0IGJlIHRvbyBoaWdoLiB3ZSBkbyB0aGlzIHRvIGF2b2lkIGxvb3AgZmx1c2hpbmcgLi4uXG4gICAgICAgICAgICBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoIC89IDI7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgQXVkaW9TdHJlYW1Db250cm9sbGVyOiByZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gJHtjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RofXNgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsIGJ1dCBicm93c2VyIGlzIHN0aWxsIGNvbXBsYWluaW5nIGFib3V0IGJ1ZmZlciBmdWxsIGVycm9yXG4gICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIG9uIElFL0VkZ2UsIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL3B1bGwvNzA4XG4gICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGZsdXNoIHRoZSB3aG9sZSBhdWRpbyBidWZmZXIgdG8gcmVjb3ZlclxuICAgICAgICAgIGxvZ2dlci53YXJuKCdBdWRpb1N0cmVhbUNvbnRyb2xsZXI6IGJ1ZmZlciBmdWxsIGVycm9yIGFsc28gbWVkaWEuY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCBhdWRpbyBidWZmZXInKTtcbiAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAvLyBmbHVzaCBldmVyeXRoaW5nXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkJVRkZFUl9GTFVTSElORztcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9GTFVTSElORywgeyBzdGFydE9mZnNldDogMCwgZW5kT2Zmc2V0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHR5cGU6ICdhdWRpbycgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBvbkJ1ZmZlckZsdXNoZWQgKCkge1xuICAgIGxldCBwZW5kaW5nRGF0YSA9IHRoaXMucGVuZGluZ0RhdGE7XG4gICAgaWYgKHBlbmRpbmdEYXRhICYmIHBlbmRpbmdEYXRhLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLmxvZygnQXVkaW9TdHJlYW1Db250cm9sbGVyOiBhcHBlbmRpbmcgcGVuZGluZyBhdWRpbyBkYXRhIGFmdGVyIGJ1ZmZlciBmbHVzaGVkJyk7XG4gICAgICBwZW5kaW5nRGF0YS5mb3JFYWNoKGFwcGVuZE9iaiA9PiB7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywgYXBwZW5kT2JqKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XG4gICAgICB0aGlzLnBlbmRpbmdEYXRhID0gW107XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0VEO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtb3ZlIHRvIElETEUgb25jZSBmbHVzaCBjb21wbGV0ZS4gdGhpcyBzaG91bGQgdHJpZ2dlciBuZXcgZnJhZ21lbnQgbG9hZGluZ1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAvLyByZXNldCByZWZlcmVuY2UgdG8gZnJhZ1xuICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgZGVmYXVsdCBBdWRpb1N0cmVhbUNvbnRyb2xsZXI7XG4iLCJpbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBUYXNrTG9vcCBmcm9tICcuLi90YXNrLWxvb3AnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5cbi8qKlxuICogQGNsYXNzIEF1ZGlvVHJhY2tDb250cm9sbGVyXG4gKiBAaW1wbGVtZW50cyB7RXZlbnRIYW5kbGVyfVxuICpcbiAqIEhhbmRsZXMgbWFpbiBtYW5pZmVzdCBhbmQgYXVkaW8tdHJhY2sgbWV0YWRhdGEgbG9hZGVkLFxuICogb3ducyBhbmQgZXhwb3NlcyB0aGUgc2VsZWN0YWJsZSBhdWRpby10cmFja3MgZGF0YS1tb2RlbHMuXG4gKlxuICogRXhwb3NlcyBpbnRlcm5hbCBpbnRlcmZhY2UgdG8gc2VsZWN0IGF2YWlsYWJsZSBhdWRpby10cmFja3MuXG4gKlxuICogSGFuZGxlcyBlcnJvcnMgb24gbG9hZGluZyBhdWRpby10cmFjayBwbGF5bGlzdHMuIE1hbmFnZXMgZmFsbGJhY2sgbWVjaGFuaXNtXG4gKiB3aXRoIHJlZHVuZGFudHMgdHJhY2tzIChncm91cC1JRHMpLlxuICpcbiAqIEhhbmRsZXMgbGV2ZWwtbG9hZGluZyBhbmQgZ3JvdXAtSUQgc3dpdGNoZXMgZm9yIHZpZGVvIChmYWxsYmFjayBvbiB2aWRlbyBsZXZlbHMpLFxuICogYW5kIGV2ZW50dWFsbHkgYWRhcHRzIHRoZSBhdWRpby10cmFjayBncm91cC1JRCB0byBtYXRjaC5cbiAqXG4gKiBAZmlyZXMgQVVESU9fVFJBQ0tfTE9BRElOR1xuICogQGZpcmVzIEFVRElPX1RSQUNLX1NXSVRDSElOR1xuICogQGZpcmVzIEFVRElPX1RSQUNLU19VUERBVEVEXG4gKiBAZmlyZXMgRVJST1JcbiAqXG4gKi9cbmNsYXNzIEF1ZGlvVHJhY2tDb250cm9sbGVyIGV4dGVuZHMgVGFza0xvb3Age1xuICBjb25zdHJ1Y3RvciAoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX1BBUlNFRCxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX0xPQURFRCxcbiAgICAgIEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSEVELFxuICAgICAgRXZlbnQuTEVWRUxfTE9BREVELFxuICAgICAgRXZlbnQuRVJST1JcbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBDdXJyZW50bHkgc2VsZWN0ZWQgaW5kZXggaW4gYHRyYWNrc2BcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHRyYWNrSWRcbiAgICAgKi9cbiAgICB0aGlzLl90cmFja0lkID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIElmIHNob3VsZCBzZWxlY3QgdHJhY2tzIGFjY29yZGluZyB0byBkZWZhdWx0IHRyYWNrIGF0dHJpYnV0ZVxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IF9zZWxlY3REZWZhdWx0VHJhY2tcbiAgICAgKi9cbiAgICB0aGlzLl9zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEFsbCB0cmFja3MgYXZhaWxhYmxlXG4gICAgICogQG1lbWJlciB7QXVkaW9UcmFja1tdfVxuICAgICAqL1xuICAgIHRoaXMudHJhY2tzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogTGlzdCBvZiBibGFja2xpc3RlZCBhdWRpbyB0cmFjayBJRHMgKHRoYXQgaGF2ZSBjYXVzZWQgZmFpbHVyZSlcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrSWRCbGFja2xpc3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIFRoZSBjdXJyZW50bHkgcnVubmluZyBncm91cCBJRCBmb3IgYXVkaW9cbiAgICAgKiAod2UgZ3JhYiB0aGlzIG9uIG1hbmlmZXN0LXBhcnNlZCBhbmQgbmV3IGxldmVsLWxvYWRlZClcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5hdWRpb0dyb3VwSWQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IGF1ZGlvIHRyYWNrcyBvbiBuZXcgbWFuaWZlc3QgbG9hZGluZy5cbiAgICovXG4gIG9uTWFuaWZlc3RMb2FkaW5nICgpIHtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuX3RyYWNrSWQgPSAtMTtcbiAgICB0aGlzLl9zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlIHRyYWNrcyBkYXRhIGZyb20gbWFuaWZlc3QgcGFyc2VkIGRhdGEuXG4gICAqXG4gICAqIFRyaWdnZXIgQVVESU9fVFJBQ0tTX1VQREFURUQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YVxuICAgKi9cbiAgb25NYW5pZmVzdFBhcnNlZCAoZGF0YSkge1xuICAgIGNvbnN0IHRyYWNrcyA9IHRoaXMudHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcyB8fCBbXTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLU19VUERBVEVELCB7IGF1ZGlvVHJhY2tzOiB0cmFja3MgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcmUgdHJhY2sgZGV0YWlscyBvZiBsb2FkZWQgdHJhY2sgaW4gb3VyIGRhdGEtbW9kZWwuXG4gICAqXG4gICAqIFNldC11cCBtZXRhZGF0YSB1cGRhdGUgaW50ZXJ2YWwgdGFzayBmb3IgbGl2ZS1tb2RlIHN0cmVhbXMuXG4gICAqXG4gICAqIEBwYXJhbSB7fSBkYXRhXG4gICAqL1xuICBvbkF1ZGlvVHJhY2tMb2FkZWQgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5pZCA+PSB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdJbnZhbGlkIGF1ZGlvIHRyYWNrIGlkOicsIGRhdGEuaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvZ2dlci5sb2coYGF1ZGlvVHJhY2sgJHtkYXRhLmlkfSBsb2FkZWRgKTtcblxuICAgIHRoaXMudHJhY2tzW2RhdGEuaWRdLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG5cbiAgICAvLyBjaGVjayBpZiBjdXJyZW50IHBsYXlsaXN0IGlzIGEgbGl2ZSBwbGF5bGlzdFxuICAgIC8vIGFuZCBpZiB3ZSBoYXZlIGFscmVhZHkgb3VyIHJlbG9hZCBpbnRlcnZhbCBzZXR1cFxuICAgIGlmIChkYXRhLmRldGFpbHMubGl2ZSAmJiAhdGhpcy5oYXNJbnRlcnZhbCgpKSB7XG4gICAgICAvLyBpZiBsaXZlIHBsYXlsaXN0IHdlIHdpbGwgaGF2ZSB0byByZWxvYWQgaXQgcGVyaW9kaWNhbGx5XG4gICAgICAvLyBzZXQgcmVsb2FkIHBlcmlvZCB0byBwbGF5bGlzdCB0YXJnZXQgZHVyYXRpb25cbiAgICAgIGNvbnN0IHVwZGF0ZVBlcmlvZE1zID0gZGF0YS5kZXRhaWxzLnRhcmdldGR1cmF0aW9uICogMTAwMDtcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwodXBkYXRlUGVyaW9kTXMpO1xuICAgIH1cblxuICAgIGlmICghZGF0YS5kZXRhaWxzLmxpdmUgJiYgdGhpcy5oYXNJbnRlcnZhbCgpKSB7XG4gICAgICAvLyBwbGF5bGlzdCBpcyBub3QgbGl2ZSBhbmQgdGltZXIgaXMgc2NoZWR1bGVkOiBjYW5jZWwgaXRcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGludGVybmFsIGdyb3VwIElEIHRvIGFueSBhdWRpby10cmFjayB3ZSBtYXkgaGF2ZSBzZXQgbWFudWFsbHlcbiAgICogb3IgYmVjYXVzZSBvZiBhIGZhaWx1cmUtaGFuZGxpbmcgZmFsbGJhY2suXG4gICAqXG4gICAqIFF1YWxpdHktbGV2ZWxzIHNob3VsZCB1cGRhdGUgdG8gdGhhdCBncm91cCBJRCBpbiB0aGlzIGNhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YVxuICAgKi9cbiAgb25BdWRpb1RyYWNrU3dpdGNoZWQgKGRhdGEpIHtcbiAgICBjb25zdCBhdWRpb0dyb3VwSWQgPSB0aGlzLnRyYWNrc1tkYXRhLmlkXS5ncm91cElkO1xuICAgIGlmIChhdWRpb0dyb3VwSWQgJiYgKHRoaXMuYXVkaW9Hcm91cElkICE9PSBhdWRpb0dyb3VwSWQpKSB7XG4gICAgICB0aGlzLmF1ZGlvR3JvdXBJZCA9IGF1ZGlvR3JvdXBJZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBhIGxldmVsIGdldHMgbG9hZGVkLCBpZiBpdCBoYXMgcmVkdW5kYW50IGF1ZGlvR3JvdXBJZHMgKGluIHRoZSBzYW1lIG9yZGluYWxpdHkgYXMgaXQncyByZWR1bmRhbnQgVVJMcylcbiAgICogd2UgYXJlIHNldHRpbmcgb3VyIGF1ZGlvLWdyb3VwIElEIGludGVybmFsbHkgdG8gdGhlIG9uZSBzZXQsIGlmIGl0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBncm91cCBJRCBjdXJyZW50bHkgc2V0LlxuICAgKlxuICAgKiBJZiBncm91cC1JRCBnb3QgdXBkYXRlLCB3ZSByZS1zZWxlY3QgdGhlIGFwcHJvcHJpYXRlIGF1ZGlvLXRyYWNrIHdpdGggdGhpcyBncm91cC1JRCBtYXRjaGluZyB0aGUgY3VycmVudGx5XG4gICAqIHNlbGVjdGVkIG9uZSAoYmFzZWQgb24gTkFNRSBwcm9wZXJ0eSkuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YVxuICAgKi9cbiAgb25MZXZlbExvYWRlZCAoZGF0YSkge1xuICAgIC8vIEZJWE1FOiBjcmFzaGVzIGJlY2F1c2UgY3VycmVudExldmVsIGlzIHVuZGVmaW5lZFxuICAgIC8vIGNvbnN0IGxldmVsSW5mbyA9IHRoaXMuaGxzLmxldmVsc1t0aGlzLmhscy5jdXJyZW50TGV2ZWxdO1xuXG4gICAgY29uc3QgbGV2ZWxJbmZvID0gdGhpcy5obHMubGV2ZWxzW2RhdGEubGV2ZWxdO1xuXG4gICAgaWYgKCFsZXZlbEluZm8uYXVkaW9Hcm91cElkcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGF1ZGlvR3JvdXBJZCA9IGxldmVsSW5mby5hdWRpb0dyb3VwSWRzW2xldmVsSW5mby51cmxJZF07XG4gICAgaWYgKHRoaXMuYXVkaW9Hcm91cElkICE9PSBhdWRpb0dyb3VwSWQpIHtcbiAgICAgIHRoaXMuYXVkaW9Hcm91cElkID0gYXVkaW9Hcm91cElkO1xuICAgICAgdGhpcy5fc2VsZWN0SW5pdGlhbEF1ZGlvVHJhY2soKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIG5ldHdvcmsgZXJyb3JzIGxvYWRpbmcgYXVkaW8gdHJhY2sgbWFuaWZlc3RzXG4gICAqIGFuZCBhbHNvIHBhdXNpbmcgb24gYW55IG5ldHdvayBlcnJvcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXJyb3JFdmVudERhdGF9IGRhdGFcbiAgICovXG4gIG9uRXJyb3IgKGRhdGEpIHtcbiAgICAvLyBPbmx5IGhhbmRsZSBuZXR3b3JrIGVycm9yc1xuICAgIGlmIChkYXRhLnR5cGUgIT09IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIGZhdGFsIG5ldHdvcmsgZXJyb3IsIGNhbmNlbCB1cGRhdGUgdGFza1xuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICB9XG5cbiAgICAvLyBJZiBub3QgYW4gYXVkaW8tdHJhY2sgbG9hZGluZyBlcnJvciBkb24ndCBoYW5kbGUgZnVydGhlclxuICAgIGlmIChkYXRhLmRldGFpbHMgIT09IEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9nZ2VyLndhcm4oJ05ldHdvcmsgZmFpbHVyZSBvbiBhdWRpby10cmFjayBpZDonLCBkYXRhLmNvbnRleHQuaWQpO1xuICAgIHRoaXMuX2hhbmRsZUxvYWRFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtBdWRpb1RyYWNrW119IEF1ZGlvLXRyYWNrIGxpc3Qgd2Ugb3duXG4gICAqL1xuICBnZXQgYXVkaW9UcmFja3MgKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfSBJbmRleCBpbnRvIGF1ZGlvLXRyYWNrcyBsaXN0IG9mIGN1cnJlbnRseSBzZWxlY3RlZCB0cmFjay5cbiAgICovXG4gIGdldCBhdWRpb1RyYWNrICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhY2tJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3QgY3VycmVudCB0cmFjayBieSBpbmRleFxuICAgKi9cbiAgc2V0IGF1ZGlvVHJhY2sgKG5ld0lkKSB7XG4gICAgdGhpcy5fc2V0QXVkaW9UcmFjayhuZXdJZCk7XG4gICAgLy8gSWYgYXVkaW8gdHJhY2sgaXMgc2VsZWN0ZWQgZnJvbSBBUEkgdGhlbiBkb24ndCBjaG9vc2UgZnJvbSB0aGUgbWFuaWZlc3QgZGVmYXVsdCB0cmFja1xuICAgIHRoaXMuX3NlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdJZFxuICAgKi9cbiAgX3NldEF1ZGlvVHJhY2sgKG5ld0lkKSB7XG4gICAgLy8gbm9vcCBvbiBzYW1lIGF1ZGlvIHRyYWNrIGlkIGFzIGFscmVhZHkgc2V0XG4gICAgaWYgKHRoaXMuX3RyYWNrSWQgPT09IG5ld0lkICYmIHRoaXMudHJhY2tzW3RoaXMuX3RyYWNrSWRdLmRldGFpbHMpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnU2FtZSBpZCBhcyBjdXJyZW50IGF1ZGlvLXRyYWNrIHBhc3NlZCwgYW5kIHRyYWNrIGRldGFpbHMgYXZhaWxhYmxlIC0+IG5vLW9wJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgaWYgKG5ld0lkIDwgMCB8fCBuZXdJZCA+PSB0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdJbnZhbGlkIGlkIHBhc3NlZCB0byBhdWRpby10cmFjayBjb250cm9sbGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXVkaW9UcmFjayA9IHRoaXMudHJhY2tzW25ld0lkXTtcblxuICAgIGxvZ2dlci5sb2coYE5vdyBzd2l0Y2hpbmcgdG8gYXVkaW8tdHJhY2sgaW5kZXggJHtuZXdJZH1gKTtcblxuICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgIHRoaXMuX3RyYWNrSWQgPSBuZXdJZDtcblxuICAgIGNvbnN0IHsgdXJsLCB0eXBlLCBpZCB9ID0gYXVkaW9UcmFjaztcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkFVRElPX1RSQUNLX1NXSVRDSElORywgeyBpZCwgdHlwZSwgdXJsIH0pO1xuICAgIHRoaXMuX2xvYWRUcmFja0RldGFpbHNJZk5lZWRlZChhdWRpb1RyYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGRvVGljayAoKSB7XG4gICAgdGhpcy5fdXBkYXRlVHJhY2sodGhpcy5fdHJhY2tJZCk7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGluaXRpYWwgdHJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZWxlY3RJbml0aWFsQXVkaW9UcmFjayAoKSB7XG4gICAgbGV0IHRyYWNrcyA9IHRoaXMudHJhY2tzO1xuICAgIGlmICghdHJhY2tzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRBdWRpb1RyYWNrID0gdGhpcy50cmFja3NbdGhpcy5fdHJhY2tJZF07XG5cbiAgICBsZXQgbmFtZSA9IG51bGw7XG4gICAgaWYgKGN1cnJlbnRBdWRpb1RyYWNrKSB7XG4gICAgICBuYW1lID0gY3VycmVudEF1ZGlvVHJhY2submFtZTtcbiAgICB9XG5cbiAgICAvLyBQcmUtc2VsZWN0IGRlZmF1bHQgdHJhY2tzIGlmIHRoZXJlIGFyZSBhbnlcbiAgICBpZiAodGhpcy5fc2VsZWN0RGVmYXVsdFRyYWNrKSB7XG4gICAgICBjb25zdCBkZWZhdWx0VHJhY2tzID0gdHJhY2tzLmZpbHRlcigodHJhY2spID0+IHRyYWNrLmRlZmF1bHQpO1xuICAgICAgaWYgKGRlZmF1bHRUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgIHRyYWNrcyA9IGRlZmF1bHRUcmFja3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybignTm8gZGVmYXVsdCBhdWRpbyB0cmFja3MgZGVmaW5lZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB0cmFja0ZvdW5kID0gZmFsc2U7XG5cbiAgICBjb25zdCB0cmF2ZXJzZVRyYWNrcyA9ICgpID0+IHtcbiAgICAgIC8vIFNlbGVjdCB0cmFjayB3aXRoIHJpZ2h0IGdyb3VwIElEXG4gICAgICB0cmFja3MuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgaWYgKHRyYWNrRm91bmQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgbmVlZCB0byBtYXRjaCB0aGUgKHByZS0pc2VsZWN0ZWQgZ3JvdXAgSURcbiAgICAgICAgLy8gYW5kIHRoZSBOQU1FIG9mIHRoZSBjdXJyZW50IHRyYWNrLlxuICAgICAgICBpZiAoKCF0aGlzLmF1ZGlvR3JvdXBJZCB8fCB0cmFjay5ncm91cElkID09PSB0aGlzLmF1ZGlvR3JvdXBJZCkgJiZcbiAgICAgICAgICAoIW5hbWUgfHwgbmFtZSA9PT0gdHJhY2submFtZSkpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwcmV2aW91cyB0cmFjayB0cnkgdG8gc3RheSB3aXRoIHRoZSBzYW1lIGBOQU1FYC5cbiAgICAgICAgICAvLyBJdCBzaG91bGQgYmUgdW5pcXVlIGFjcm9zcyB0cmFja3Mgb2Ygc2FtZSBncm91cCwgYW5kIGNvbnNpc3RlbnQgdGhyb3VnaCByZWR1bmRhbnQgdHJhY2sgZ3JvdXBzLlxuICAgICAgICAgIHRoaXMuX3NldEF1ZGlvVHJhY2sodHJhY2suaWQpO1xuICAgICAgICAgIHRyYWNrRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdHJhdmVyc2VUcmFja3MoKTtcblxuICAgIGlmICghdHJhY2tGb3VuZCkge1xuICAgICAgbmFtZSA9IG51bGw7XG4gICAgICB0cmF2ZXJzZVRyYWNrcygpO1xuICAgIH1cblxuICAgIGlmICghdHJhY2tGb3VuZCkge1xuICAgICAgbG9nZ2VyLmVycm9yKGBObyB0cmFjayBmb3VuZCBmb3IgcnVubmluZyBhdWRpbyBncm91cC1JRDogJHt0aGlzLmF1ZGlvR3JvdXBJZH1gKTtcblxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUixcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0F1ZGlvVHJhY2t9IGF1ZGlvVHJhY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBfbmVlZHNUcmFja0xvYWRpbmcgKGF1ZGlvVHJhY2spIHtcbiAgICBjb25zdCB7IGRldGFpbHMsIHVybCB9ID0gYXVkaW9UcmFjaztcblxuICAgIGlmICghZGV0YWlscyB8fCBkZXRhaWxzLmxpdmUpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGZhY2UgYW4gYXVkaW8gdHJhY2sgZW1iZWRkZWQgaW4gbWFpbiBwbGF5bGlzdCAoYXVkaW8gdHJhY2sgd2l0aG91dCBVUkkgYXR0cmlidXRlKVxuICAgICAgcmV0dXJuICEhdXJsO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0F1ZGlvVHJhY2t9IGF1ZGlvVHJhY2tcbiAgICovXG4gIF9sb2FkVHJhY2tEZXRhaWxzSWZOZWVkZWQgKGF1ZGlvVHJhY2spIHtcbiAgICBpZiAodGhpcy5fbmVlZHNUcmFja0xvYWRpbmcoYXVkaW9UcmFjaykpIHtcbiAgICAgIGNvbnN0IHsgdXJsLCBpZCB9ID0gYXVkaW9UcmFjaztcbiAgICAgIC8vIHRyYWNrIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgIGxvZ2dlci5sb2coYGxvYWRpbmcgYXVkaW8tdHJhY2sgcGxheWxpc3QgZm9yIGlkOiAke2lkfWApO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19MT0FESU5HLCB7IHVybCwgaWQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdJZFxuICAgKi9cbiAgX3VwZGF0ZVRyYWNrIChuZXdJZCkge1xuICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgIGlmIChuZXdJZCA8IDAgfHwgbmV3SWQgPj0gdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgdGhpcy5fdHJhY2tJZCA9IG5ld0lkO1xuICAgIGxvZ2dlci5sb2coYHRyeWluZyB0byB1cGRhdGUgYXVkaW8tdHJhY2sgJHtuZXdJZH1gKTtcbiAgICBjb25zdCBhdWRpb1RyYWNrID0gdGhpcy50cmFja3NbbmV3SWRdO1xuICAgIHRoaXMuX2xvYWRUcmFja0RldGFpbHNJZk5lZWRlZChhdWRpb1RyYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhbmRsZUxvYWRFcnJvciAoKSB7XG4gICAgLy8gRmlyc3QsIGxldCdzIGJsYWNrIGxpc3QgY3VycmVudCB0cmFjayBpZFxuICAgIHRoaXMudHJhY2tJZEJsYWNrbGlzdFt0aGlzLl90cmFja0lkXSA9IHRydWU7XG5cbiAgICAvLyBMZXQncyB0cnkgdG8gZmFsbCBiYWNrIG9uIGEgZnVuY3Rpb25hbCBhdWRpby10cmFjayB3aXRoIHRoZSBzYW1lIGdyb3VwIElEXG4gICAgY29uc3QgcHJldmlvdXNJZCA9IHRoaXMuX3RyYWNrSWQ7XG4gICAgY29uc3QgeyBuYW1lLCBsYW5ndWFnZSwgZ3JvdXBJZCB9ID0gdGhpcy50cmFja3NbcHJldmlvdXNJZF07XG5cbiAgICBsb2dnZXIud2FybihgTG9hZGluZyBmYWlsZWQgb24gYXVkaW8gdHJhY2sgaWQ6ICR7cHJldmlvdXNJZH0sIGdyb3VwLWlkOiAke2dyb3VwSWR9LCBuYW1lL2xhbmd1YWdlOiBcIiR7bmFtZX1cIiAvIFwiJHtsYW5ndWFnZX1cImApO1xuXG4gICAgLy8gRmluZCBhIG5vbi1ibGFja2xpc3RlZCB0cmFjayBJRCB3aXRoIHRoZSBzYW1lIE5BTUVcbiAgICAvLyBBdCBsZWFzdCBhIHRyYWNrIHRoYXQgaXMgbm90IGJsYWNrbGlzdGVkLCB0aHVzIG9uIGFub3RoZXIgZ3JvdXAtSUQuXG4gICAgbGV0IG5ld0lkID0gcHJldmlvdXNJZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy50cmFja0lkQmxhY2tsaXN0W2ldKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3VHJhY2sgPSB0aGlzLnRyYWNrc1tpXTtcbiAgICAgIGlmIChuZXdUcmFjay5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIG5ld0lkID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5ld0lkID09PSBwcmV2aW91c0lkKSB7XG4gICAgICBsb2dnZXIud2FybihgTm8gZmFsbGJhY2sgYXVkaW8tdHJhY2sgZm91bmQgZm9yIG5hbWUvbGFuZ3VhZ2U6IFwiJHtuYW1lfVwiIC8gXCIke2xhbmd1YWdlfVwiYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9nZ2VyLmxvZygnQXR0ZW1wdGluZyBhdWRpby10cmFjayBmYWxsYmFjayBpZDonLCBuZXdJZCwgJ2dyb3VwLWlkOicsIHRoaXMudHJhY2tzW25ld0lkXS5ncm91cElkKTtcblxuICAgIHRoaXMuX3NldEF1ZGlvVHJhY2sobmV3SWQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEF1ZGlvVHJhY2tDb250cm9sbGVyO1xuIiwiaW1wb3J0IFRhc2tMb29wIGZyb20gJy4uL3Rhc2stbG9vcCc7XG5pbXBvcnQgeyBGcmFnbWVudFN0YXRlIH0gZnJvbSAnLi9mcmFnbWVudC10cmFja2VyJztcbmltcG9ydCB7IEJ1ZmZlckhlbHBlciB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuZXhwb3J0IGNvbnN0IFN0YXRlID0ge1xuICBTVE9QUEVEOiAnU1RPUFBFRCcsXG4gIFNUQVJUSU5HOiAnU1RBUlRJTkcnLFxuICBJRExFOiAnSURMRScsXG4gIFBBVVNFRDogJ1BBVVNFRCcsXG4gIEtFWV9MT0FESU5HOiAnS0VZX0xPQURJTkcnLFxuICBGUkFHX0xPQURJTkc6ICdGUkFHX0xPQURJTkcnLFxuICBGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTogJ0ZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZJyxcbiAgV0FJVElOR19UUkFDSzogJ1dBSVRJTkdfVFJBQ0snLFxuICBQQVJTSU5HOiAnUEFSU0lORycsXG4gIFBBUlNFRDogJ1BBUlNFRCcsXG4gIEJVRkZFUl9GTFVTSElORzogJ0JVRkZFUl9GTFVTSElORycsXG4gIEVOREVEOiAnRU5ERUQnLFxuICBFUlJPUjogJ0VSUk9SJyxcbiAgV0FJVElOR19JTklUX1BUUzogJ1dBSVRJTkdfSU5JVF9QVFMnLFxuICBXQUlUSU5HX0xFVkVMOiAnV0FJVElOR19MRVZFTCdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VTdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgVGFza0xvb3Age1xuICBkb1RpY2sgKCkge31cblxuICBzdGFydExvYWQgKCkge31cblxuICBzdG9wTG9hZCAoKSB7XG4gICAgbGV0IGZyYWcgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGlmIChmcmFnKSB7XG4gICAgICBpZiAoZnJhZy5sb2FkZXIpIHtcbiAgICAgICAgZnJhZy5sb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZW11eGVyKSB7XG4gICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICB9XG5cbiAgX3N0cmVhbUVuZGVkIChidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpIHtcbiAgICBjb25zdCB7IGZyYWdDdXJyZW50LCBmcmFnbWVudFRyYWNrZXIgfSA9IHRoaXM7XG4gICAgLy8gd2UganVzdCBnb3QgZG9uZSBsb2FkaW5nIHRoZSBmaW5hbCBmcmFnbWVudCBhbmQgdGhlcmUgaXMgbm8gb3RoZXIgYnVmZmVyZWQgcmFuZ2UgYWZ0ZXIgLi4uXG4gICAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgaW4gY2FzZSB0aGVyZSBhcmUgYW55IGJ1ZmZlcmVkIHJhbmdlcyBhZnRlciwgaXQgbWVhbnMgdGhhdCB0aGVyZSBhcmUgdW5idWZmZXJlZCBwb3J0aW9uIGluIGJldHdlZW5cbiAgICAvLyBzbyB3ZSBzaG91bGQgbm90IHN3aXRjaCB0byBFTkRFRCBpbiB0aGF0IGNhc2UsIHRvIGJlIGFibGUgdG8gYnVmZmVyIHRoZW1cbiAgICAvLyBkb250IHN3aXRjaCB0byBFTkRFRCBpZiB3ZSBuZWVkIHRvIGJhY2t0cmFjayBsYXN0IGZyYWdtZW50XG4gICAgaWYgKCFsZXZlbERldGFpbHMubGl2ZSAmJiBmcmFnQ3VycmVudCAmJiAhZnJhZ0N1cnJlbnQuYmFja3RyYWNrZWQgJiYgZnJhZ0N1cnJlbnQuc24gPT09IGxldmVsRGV0YWlscy5lbmRTTiAmJiAhYnVmZmVySW5mby5uZXh0U3RhcnQpIHtcbiAgICAgIGNvbnN0IGZyYWdTdGF0ZSA9IGZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnQ3VycmVudCk7XG4gICAgICByZXR1cm4gZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwgfHwgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLk9LO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBvbk1lZGlhU2Vla2luZyAoKSB7XG4gICAgY29uc3QgeyBjb25maWcsIG1lZGlhLCBtZWRpYUJ1ZmZlciwgc3RhdGUgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogbnVsbDtcbiAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWFCdWZmZXIgfHwgbWVkaWEsIGN1cnJlbnRUaW1lLCB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcblxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoY3VycmVudFRpbWUpKSB7XG4gICAgICBsb2dnZXIubG9nKGBtZWRpYSBzZWVraW5nIHRvICR7Y3VycmVudFRpbWUudG9GaXhlZCgzKX1gKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORykge1xuICAgICAgbGV0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBzZWVraW5nIHRvIGEgdW5idWZmZXJlZCBhcmVhIEFORCBpZiBmcmFnIGxvYWRpbmcgaXMgaW4gcHJvZ3Jlc3NcbiAgICAgIGlmIChidWZmZXJJbmZvLmxlbiA9PT0gMCAmJiBmcmFnQ3VycmVudCkge1xuICAgICAgICBjb25zdCB0b2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICAgICAgY29uc3QgZnJhZ1N0YXJ0T2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgLSB0b2xlcmFuY2U7XG4gICAgICAgIGNvbnN0IGZyYWdFbmRPZmZzZXQgPSBmcmFnQ3VycmVudC5zdGFydCArIGZyYWdDdXJyZW50LmR1cmF0aW9uICsgdG9sZXJhbmNlO1xuICAgICAgICAvLyBjaGVjayBpZiB3ZSBzZWVrIHBvc2l0aW9uIHdpbGwgYmUgb3V0IG9mIGN1cnJlbnRseSBsb2FkZWQgZnJhZyByYW5nZSA6IGlmIG91dCBjYW5jZWwgZnJhZyBsb2FkLCBpZiBpbiwgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgZnJhZ1N0YXJ0T2Zmc2V0IHx8IGN1cnJlbnRUaW1lID4gZnJhZ0VuZE9mZnNldCkge1xuICAgICAgICAgIGlmIChmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ3NlZWtpbmcgb3V0c2lkZSBvZiBidWZmZXIgd2hpbGUgZnJhZ21lbnQgbG9hZCBpbiBwcm9ncmVzcywgY2FuY2VsIGZyYWdtZW50IGxvYWQnKTtcbiAgICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdzZWVraW5nIG91dHNpZGUgb2YgYnVmZmVyIGJ1dCB3aXRoaW4gY3VycmVudGx5IGxvYWRlZCBmcmFnbWVudCByYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcbiAgICAgIC8vIGlmIHNlZWtpbmcgdG8gdW5idWZmZXJlZCBhcmVhLCBjbGVhbiB1cCBmcmFnUHJldmlvdXNcbiAgICAgIGlmIChidWZmZXJJbmZvLmxlbiA9PT0gMCkge1xuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBjaGVjayBmb3IgcG90ZW50aWFsIG5ldyBmcmFnbWVudFxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICAgIGlmIChtZWRpYSkge1xuICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9XG5cbiAgICAvLyBpbiBjYXNlIHNlZWtpbmcgb2NjdXJzIGFsdGhvdWdoIG5vIG1lZGlhIGJ1ZmZlcmVkLCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiBhbmQgbmV4dExvYWRQb3NpdGlvbiB0byBzZWVrIHRhcmdldFxuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gY3VycmVudFRpbWU7XG4gICAgfVxuXG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBwcm9jZXNzaW5nXG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBvbk1lZGlhRW5kZWQgKCkge1xuICAgIC8vIHJlc2V0IHN0YXJ0UG9zaXRpb24gYW5kIGxhc3RDdXJyZW50VGltZSB0byByZXN0YXJ0IHBsYXliYWNrIEAgc3RyZWFtIGJlZ2lubmluZ1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgfVxuXG4gIG9uSGFuZGxlckRlc3Ryb3lpbmcgKCkge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICBzdXBlci5vbkhhbmRsZXJEZXN0cm95aW5nKCk7XG4gIH1cblxuICBvbkhhbmRsZXJEZXN0cm95ZWQgKCkge1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gbnVsbDtcbiAgfVxufVxuIiwiLypcbiAqIEJ1ZmZlciBDb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGdldE1lZGlhU291cmNlIH0gZnJvbSAnLi4vdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyJztcblxuY29uc3QgTWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSgpO1xuXG5jbGFzcyBCdWZmZXJDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscykge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSElORyxcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX1BBUlNFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9SRVNFVCxcbiAgICAgIEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsXG4gICAgICBFdmVudC5CVUZGRVJfQ09ERUNTLFxuICAgICAgRXZlbnQuQlVGRkVSX0VPUyxcbiAgICAgIEV2ZW50LkJVRkZFUl9GTFVTSElORyxcbiAgICAgIEV2ZW50LkxFVkVMX1BUU19VUERBVEVELFxuICAgICAgRXZlbnQuTEVWRUxfVVBEQVRFRCk7XG5cbiAgICAvLyB0aGUgdmFsdWUgdGhhdCB3ZSBoYXZlIHNldCBtZWRpYXNvdXJjZS5kdXJhdGlvbiB0b1xuICAgIC8vICh0aGUgYWN0dWFsIGR1cmF0aW9uIG1heSBiZSB0d2Vha2VkIHNsaWdobHkgYnkgdGhlIGJyb3dzZXIpXG4gICAgdGhpcy5fbXNEdXJhdGlvbiA9IG51bGw7XG4gICAgLy8gdGhlIHZhbHVlIHRoYXQgd2Ugd2FudCB0byBzZXQgbWVkaWFTb3VyY2UuZHVyYXRpb24gdG9cbiAgICB0aGlzLl9sZXZlbER1cmF0aW9uID0gbnVsbDtcbiAgICAvLyB0aGUgdGFyZ2V0IGR1cmF0aW9uIG9mIHRoZSBjdXJyZW50IG1lZGlhIHBsYXlsaXN0XG4gICAgdGhpcy5fbGV2ZWxUYXJnZXREdXJhdGlvbiA9IDEwO1xuICAgIC8vIGN1cnJlbnQgc3RyZWFtIHN0YXRlOiB0cnVlIC0gZm9yIGxpdmUgYnJvYWRjYXN0LCBmYWxzZSAtIGZvciBWb0QgY29udGVudFxuICAgIHRoaXMuX2xpdmUgPSBudWxsO1xuICAgIC8vIGNhY2hlIHRoZSBzZWxmIGdlbmVyYXRlZCBvYmplY3QgdXJsIHRvIGRldGVjdCBoaWphY2sgb2YgdmlkZW8gdGFnXG4gICAgdGhpcy5fb2JqZWN0VXJsID0gbnVsbDtcbiAgICAvLyBUaGUgbnVtYmVyIG9mIEJVRkZFUl9DT0RFQyBldmVudHMgcmVjZWl2ZWQgYmVmb3JlIGFueSBzb3VyY2VCdWZmZXJzIGFyZSBjcmVhdGVkXG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gMDtcblxuICAgIC8vIFNvdXJjZSBCdWZmZXIgbGlzdGVuZXJzXG4gICAgdGhpcy5vbnNidWUgPSB0aGlzLm9uU0JVcGRhdGVFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uc2JlID0gdGhpcy5vblNCVXBkYXRlRXJyb3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cblxuICBvbkxldmVsUHRzVXBkYXRlZCAoZGF0YSkge1xuICAgIGxldCB0eXBlID0gZGF0YS50eXBlO1xuICAgIGxldCBhdWRpb1RyYWNrID0gdGhpcy50cmFja3MuYXVkaW87XG5cbiAgICAvLyBBZGp1c3RpbmcgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgIChkZXNpcmVkIHBvaW50IGluIHRoZSB0aW1lbGluZSB3aGVyZSB0aGUgbmV4dCBmcmFtZXMgc2hvdWxkIGJlIGFwcGVuZGVkKVxuICAgIC8vIGluIENocm9tZSBicm93c2VyIHdoZW4gd2UgZGV0ZWN0IE1QRUcgYXVkaW8gY29udGFpbmVyIGFuZCB0aW1lIGRlbHRhIGJldHdlZW4gbGV2ZWwgUFRTIGFuZCBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGBcbiAgICAvLyBpcyBncmVhdGVyIHRoYW4gMTAwbXMgKHRoaXMgaXMgZW5vdWdoIHRvIGhhbmRsZSBzZWVrIGZvciBWT0Qgb3IgbGV2ZWwgY2hhbmdlIGZvciBMSVZFIHZpZGVvcykuIEF0IHRoZSB0aW1lIG9mIGNoYW5nZSB3ZSBpc3N1ZVxuICAgIC8vIGBTb3VyY2VCdWZmZXIuYWJvcnQoKWAgYW5kIGFkanVzdGluZyBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGAgaWYgYFNvdXJjZUJ1ZmZlci51cGRhdGluZ2AgaXMgZmFsc2Ugb3IgYXdhaXRpbmcgYHVwZGF0ZWVuZGBcbiAgICAvLyBldmVudCBpZiBTQiBpcyBpbiB1cGRhdGluZyBzdGF0ZS5cbiAgICAvLyBNb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzMzMiNpc3N1ZWNvbW1lbnQtMjU3OTg2NDg2XG5cbiAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiBhdWRpb1RyYWNrICYmIGF1ZGlvVHJhY2suY29udGFpbmVyID09PSAnYXVkaW8vbXBlZycpIHsgLy8gQ2hyb21lIGF1ZGlvIG1wMyB0cmFja1xuICAgICAgbGV0IGF1ZGlvQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIuYXVkaW87XG4gICAgICBsZXQgZGVsdGEgPSBNYXRoLmFicyhhdWRpb0J1ZmZlci50aW1lc3RhbXBPZmZzZXQgLSBkYXRhLnN0YXJ0KTtcblxuICAgICAgLy8gYWRqdXN0IHRpbWVzdGFtcCBvZmZzZXQgaWYgdGltZSBkZWx0YSBpcyBncmVhdGVyIHRoYW4gMTAwbXNcbiAgICAgIGlmIChkZWx0YSA+IDAuMSkge1xuICAgICAgICBsZXQgdXBkYXRpbmcgPSBhdWRpb0J1ZmZlci51cGRhdGluZztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF1ZGlvQnVmZmVyLmFib3J0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKCdjYW4gbm90IGFib3J0IGF1ZGlvIGJ1ZmZlcjogJyArIGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVwZGF0aW5nKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ2NoYW5nZSBtcGVnIGF1ZGlvIHRpbWVzdGFtcCBvZmZzZXQgZnJvbSAnICsgYXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0ICsgJyB0byAnICsgZGF0YS5zdGFydCk7XG4gICAgICAgICAgYXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0ID0gZGF0YS5zdGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0ID0gZGF0YS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uTWFuaWZlc3RQYXJzZWQgKGRhdGEpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGFsdCBhdWRpbyAyIEJVRkZFUl9DT0RFQ1MgZXZlbnRzIHdpbGwgYmUgdHJpZ2dlcmVkLCBvbmUgcGVyIHN0cmVhbSBjb250cm9sbGVyXG4gICAgLy8gc291cmNlYnVmZmVycyB3aWxsIGJlIGNyZWF0ZWQgYWxsIGF0IG9uY2Ugd2hlbiB0aGUgZXhwZWN0ZWQgbmIgb2YgdHJhY2tzIHdpbGwgYmUgcmVhY2hlZFxuICAgIC8vIGluIGNhc2UgYWx0IGF1ZGlvIGlzIG5vdCB1c2VkLCBvbmx5IG9uZSBCVUZGRVJfQ09ERUMgZXZlbnQgd2lsbCBiZSBmaXJlZCBmcm9tIG1haW4gc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAvLyBpdCB3aWxsIGNvbnRhaW4gdGhlIGV4cGVjdGVkIG5iIG9mIHNvdXJjZSBidWZmZXJzLCBubyBuZWVkIHRvIGNvbXB1dGUgaXRcbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSBkYXRhLmFsdEF1ZGlvID8gMiA6IDE7XG4gICAgbG9nZ2VyLmxvZyhgJHt0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWR9IGJ1ZmZlckNvZGVjIGV2ZW50KHMpIGV4cGVjdGVkYCk7XG4gIH1cblxuICBvbk1lZGlhQXR0YWNoaW5nIChkYXRhKSB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAvLyBzZXR1cCB0aGUgbWVkaWEgc291cmNlXG4gICAgICBsZXQgbXMgPSB0aGlzLm1lZGlhU291cmNlID0gbmV3IE1lZGlhU291cmNlKCk7XG4gICAgICAvLyBNZWRpYSBTb3VyY2UgbGlzdGVuZXJzXG4gICAgICB0aGlzLm9ubXNvID0gdGhpcy5vbk1lZGlhU291cmNlT3Blbi5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5vbm1zZSA9IHRoaXMub25NZWRpYVNvdXJjZUVuZGVkLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLm9ubXNjID0gdGhpcy5vbk1lZGlhU291cmNlQ2xvc2UuYmluZCh0aGlzKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLm9ubXNvKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5vbm1zZSk7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMub25tc2MpO1xuICAgICAgLy8gbGluayB2aWRlbyBhbmQgbWVkaWEgU291cmNlXG4gICAgICBtZWRpYS5zcmMgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChtcyk7XG4gICAgICAvLyBjYWNoZSB0aGUgbG9jYWxseSBnZW5lcmF0ZWQgb2JqZWN0IHVybFxuICAgICAgdGhpcy5fb2JqZWN0VXJsID0gbWVkaWEuc3JjO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFEZXRhY2hpbmcgKCkge1xuICAgIGxvZ2dlci5sb2coJ21lZGlhIHNvdXJjZSBkZXRhY2hpbmcnKTtcbiAgICBsZXQgbXMgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIGlmIChtcykge1xuICAgICAgaWYgKG1zLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIGVuZE9mU3RyZWFtIGNvdWxkIHRyaWdnZXIgZXhjZXB0aW9uIGlmIGFueSBzb3VyY2VidWZmZXIgaXMgaW4gdXBkYXRpbmcgc3RhdGVcbiAgICAgICAgICAvLyB3ZSBkb24ndCByZWFsbHkgY2FyZSBhYm91dCBjaGVja2luZyBzb3VyY2VidWZmZXIgc3RhdGUgaGVyZSxcbiAgICAgICAgICAvLyBhcyB3ZSBhcmUgYW55d2F5IGRldGFjaGluZyB0aGUgTWVkaWFTb3VyY2VcbiAgICAgICAgICAvLyBsZXQncyBqdXN0IGF2b2lkIHRoaXMgZXhjZXB0aW9uIHRvIHByb3BhZ2F0ZVxuICAgICAgICAgIG1zLmVuZE9mU3RyZWFtKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBvbk1lZGlhRGV0YWNoaW5nOiR7ZXJyLm1lc3NhZ2V9IHdoaWxlIGNhbGxpbmcgZW5kT2ZTdHJlYW1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMub25tc28pO1xuICAgICAgbXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlZW5kZWQnLCB0aGlzLm9ubXNlKTtcbiAgICAgIG1zLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5vbm1zYyk7XG5cbiAgICAgIC8vIERldGFjaCBwcm9wZXJseSB0aGUgTWVkaWFTb3VyY2UgZnJvbSB0aGUgSFRNTE1lZGlhRWxlbWVudCBhc1xuICAgICAgLy8gc3VnZ2VzdGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvbWVkaWEtc291cmNlL2lzc3Vlcy81My5cbiAgICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMuX29iamVjdFVybCk7XG5cbiAgICAgICAgLy8gY2xlYW4gdXAgdmlkZW8gdGFnIHNyYyBvbmx5IGlmIGl0J3Mgb3VyIG93biB1cmwuIHNvbWUgZXh0ZXJuYWwgbGlicmFyaWVzIG1pZ2h0XG4gICAgICAgIC8vIGhpamFjayB0aGUgdmlkZW8gdGFnIGFuZCBjaGFuZ2UgaXRzICdzcmMnIHdpdGhvdXQgZGVzdHJveWluZyB0aGUgSGxzIGluc3RhbmNlIGZpcnN0XG4gICAgICAgIGlmICh0aGlzLm1lZGlhLnNyYyA9PT0gdGhpcy5fb2JqZWN0VXJsKSB7XG4gICAgICAgICAgdGhpcy5tZWRpYS5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgIHRoaXMubWVkaWEubG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci53YXJuKCdtZWRpYS5zcmMgd2FzIGNoYW5nZWQgYnkgYSB0aGlyZCBwYXJ0eSAtIHNraXAgY2xlYW51cCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWVkaWFTb3VyY2UgPSBudWxsO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICB0aGlzLl9vYmplY3RVcmwgPSBudWxsO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICAgICAgdGhpcy5zb3VyY2VCdWZmZXIgPSB7fTtcbiAgICAgIHRoaXMuZmx1c2hSYW5nZSA9IFtdO1xuICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgICAgdGhpcy5hcHBlbmRlZCA9IDA7XG4gICAgfVxuICAgIHRoaXMub25tc28gPSB0aGlzLm9ubXNlID0gdGhpcy5vbm1zYyA9IG51bGw7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5NRURJQV9ERVRBQ0hFRCk7XG4gIH1cblxuICBvbk1lZGlhU291cmNlT3BlbiAoKSB7XG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIG9wZW5lZCcpO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTUVESUFfQVRUQUNIRUQsIHsgbWVkaWE6IHRoaXMubWVkaWEgfSk7XG4gICAgbGV0IG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICBpZiAobWVkaWFTb3VyY2UpIHtcbiAgICAgIC8vIG9uY2UgcmVjZWl2ZWQsIGRvbid0IGxpc3RlbiBhbnltb3JlIHRvIHNvdXJjZW9wZW4gZXZlbnRcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLm9ubXNvKTtcbiAgICB9XG4gICAgdGhpcy5jaGVja1BlbmRpbmdUcmFja3MoKTtcbiAgfVxuXG4gIGNoZWNrUGVuZGluZ1RyYWNrcyAoKSB7XG4gICAgbGV0IHsgYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCwgcGVuZGluZ1RyYWNrcyB9ID0gdGhpcztcbiAgICAvLyBDaGVjayBpZiB3ZSd2ZSByZWNlaXZlZCBhbGwgb2YgdGhlIGV4cGVjdGVkIGJ1ZmZlckNvZGVjIGV2ZW50cy4gV2hlbiBub25lIHJlbWFpbiwgY3JlYXRlIGFsbCB0aGUgc291cmNlQnVmZmVycyBhdCBvbmNlLlxuICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIE1TRSBzcGVjIGFsbG93cyBpbXBsZW1lbnRhdGlvbnMgdG8gdGhyb3cgUXVvdGFFeGNlZWRlZEVycm9ycyBpZiBjcmVhdGluZyBuZXcgc291cmNlQnVmZmVycyBhZnRlclxuICAgIC8vIGRhdGEgaGFzIGJlZW4gYXBwZW5kZWQgdG8gZXhpc3Rpbmcgb25lcy5cbiAgICAvLyAyIHRyYWNrcyBpcyB0aGUgbWF4IChvbmUgZm9yIGF1ZGlvLCBvbmUgZm9yIHZpZGVvKS4gSWYgd2UndmUgcmVhY2ggdGhpcyBtYXggZ28gYWhlYWQgYW5kIGNyZWF0ZSB0aGUgYnVmZmVycy5cbiAgICBcbiAgICBjb25zdCBwZW5kaW5nVHJhY2tzQ291bnQgPSBPYmplY3Qua2V5cyhwZW5kaW5nVHJhY2tzKS5sZW5ndGg7XG4gICAgaWYgKChwZW5kaW5nVHJhY2tzQ291bnQgJiYgIWJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQpIHx8IHBlbmRpbmdUcmFja3NDb3VudCA9PT0gMikge1xuICAgICAgLy8gb2ssIGxldCdzIGNyZWF0ZSB0aGVtIG5vdyAhXG4gICAgICB0aGlzLmNyZWF0ZVNvdXJjZUJ1ZmZlcnMocGVuZGluZ1RyYWNrcyk7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICAgIC8vIGFwcGVuZCBhbnkgcGVuZGluZyBzZWdtZW50cyBub3cgIVxuICAgICAgdGhpcy5kb0FwcGVuZGluZygpO1xuICAgIH0gXG4gIH1cblxuICBvbk1lZGlhU291cmNlQ2xvc2UgKCkge1xuICAgIGxvZ2dlci5sb2coJ21lZGlhIHNvdXJjZSBjbG9zZWQnKTtcbiAgfVxuXG4gIG9uTWVkaWFTb3VyY2VFbmRlZCAoKSB7XG4gICAgbG9nZ2VyLmxvZygnbWVkaWEgc291cmNlIGVuZGVkJyk7XG4gIH1cblxuICBvblNCVXBkYXRlRW5kICgpIHtcbiAgICAvLyB1cGRhdGUgdGltZXN0YW1wT2Zmc2V0XG4gICAgaWYgKHRoaXMuYXVkaW9UaW1lc3RhbXBPZmZzZXQpIHtcbiAgICAgIGxldCBhdWRpb0J1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyLmF1ZGlvO1xuICAgICAgbG9nZ2VyLndhcm4oYGNoYW5nZSBtcGVnIGF1ZGlvIHRpbWVzdGFtcCBvZmZzZXQgZnJvbSAke2F1ZGlvQnVmZmVyLnRpbWVzdGFtcE9mZnNldH0gdG8gJHt0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0fWApO1xuICAgICAgYXVkaW9CdWZmZXIudGltZXN0YW1wT2Zmc2V0ID0gdGhpcy5hdWRpb1RpbWVzdGFtcE9mZnNldDtcbiAgICAgIGRlbGV0ZSB0aGlzLmF1ZGlvVGltZXN0YW1wT2Zmc2V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9uZWVkc0ZsdXNoKSB7XG4gICAgICB0aGlzLmRvRmx1c2goKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbmVlZHNFb3MpIHtcbiAgICAgIHRoaXMuY2hlY2tFb3MoKTtcbiAgICB9XG5cbiAgICB0aGlzLmFwcGVuZGluZyA9IGZhbHNlO1xuICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAvLyBjb3VudCBuYiBvZiBwZW5kaW5nIHNlZ21lbnRzIHdhaXRpbmcgZm9yIGFwcGVuZGluZyBvbiB0aGlzIHNvdXJjZWJ1ZmZlclxuICAgIGxldCBwZW5kaW5nID0gdGhpcy5zZWdtZW50cy5yZWR1Y2UoKGNvdW50ZXIsIHNlZ21lbnQpID0+IChzZWdtZW50LnBhcmVudCA9PT0gcGFyZW50KSA/IGNvdW50ZXIgKyAxIDogY291bnRlciwgMCk7XG5cbiAgICAvLyB0aGlzLnNvdXJjZUJ1ZmZlciBpcyBiZXR0ZXIgdG8gdXNlIHRoYW4gbWVkaWEuYnVmZmVyZWQgYXMgaXQgaXMgY2xvc2VyIHRvIHRoZSBQVFMgZGF0YSBmcm9tIHRoZSBmcmFnbWVudHNcbiAgICBsZXQgdGltZVJhbmdlcyA9IHt9O1xuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgIGZvciAobGV0IHN0cmVhbVR5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICB0aW1lUmFuZ2VzW3N0cmVhbVR5cGVdID0gc291cmNlQnVmZmVyW3N0cmVhbVR5cGVdLmJ1ZmZlcmVkO1xuICAgIH1cblxuICAgIC8vIOWvu+aJvuWPr+aSreaUvueahOi1t+Wni+eCueOAguWmguaenOayoeacieiHquWKqOaSreaUvu+8jOmcgOimgeaJi+WKqFNlZWtcbiAgICBpZih0aGlzLl9wYXVzZWQgPT09IGZhbHNlIFxuICAgICAgJiYgdGltZVJhbmdlc1tcInZpZGVvXCJdICYmIHRpbWVSYW5nZXNbXCJ2aWRlb1wiXS5sZW5ndGggPiAwXG4gICAgICAmJiB0aW1lUmFuZ2VzW1wiYXVkaW9cIl0gJiYgdGltZVJhbmdlc1tcImF1ZGlvXCJdLmxlbmd0aCA+IDApIHtcbiAgICAgIFxuICAgICAgaWYodGltZVJhbmdlc1tcInZpZGVvXCJdLmVuZCgwKSAtIHRpbWVSYW5nZXNbXCJ2aWRlb1wiXS5zdGFydCgwKSA+IDFcbiAgICAgICYmIHRpbWVSYW5nZXNbXCJhdWRpb1wiXS5lbmQoMCkgLSB0aW1lUmFuZ2VzW1wiYXVkaW9cIl0uc3RhcnQoMCkgPiAxKSB7XG4gICAgICAgIC8vIFNlZWsgdG8gdGhlIHBvaW50IHRoYXQgY2FuIHBsYXk7XG4gICAgICAgIGxldCBzdGFydFRpbWUgPSBNYXRoLm1heCh0aW1lUmFuZ2VzW1widmlkZW9cIl0uc3RhcnQoMCksdGltZVJhbmdlc1tcImF1ZGlvXCJdLnN0YXJ0KDApKVxuICAgICAgICB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLm1lZGlhLnBsYXkoKTtcbiAgICAgICAgZGVsZXRlIHRoaXNbXCJfcGF1c2VkXCJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHJ5IHRvIHNlZWsgbW9yZVxuICAgICAgICBsZXQgZW5kVGltZSA9IE1hdGgubWF4KHRpbWVSYW5nZXNbXCJ2aWRlb1wiXS5lbmQoMCksdGltZVJhbmdlc1tcImF1ZGlvXCJdLmVuZCgwKSlcbiAgICAgICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IGVuZFRpbWU7XG4gICAgICAgIHRoaXMubWVkaWEucGxheSgpO1xuICAgICAgfSBcbiAgICAgIFxuICAgIH1cblxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVOREVELCB7IHBhcmVudCwgcGVuZGluZywgdGltZVJhbmdlcyB9KTtcbiAgICAvLyBkb24ndCBhcHBlbmQgaW4gZmx1c2hpbmcgbW9kZVxuICAgIGlmICghdGhpcy5fbmVlZHNGbHVzaCkge1xuICAgICAgdGhpcy5kb0FwcGVuZGluZygpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcblxuICAgIC8vIGFwcGVuZGluZyBnb2VzIGZpcnN0XG4gICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgIHRoaXMuZmx1c2hMaXZlQmFja0J1ZmZlcigpO1xuICAgIH1cbiAgfVxuXG4gIG9uU0JVcGRhdGVFcnJvciAoZXZlbnQpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ3NvdXJjZUJ1ZmZlciBlcnJvcjonLCBldmVudCk7XG4gICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jc291cmNlYnVmZmVyLWFwcGVuZC1lcnJvclxuICAgIC8vIHRoaXMgZXJyb3IgbWlnaHQgbm90IGFsd2F5cyBiZSBmYXRhbCAoaXQgaXMgZmF0YWwgaWYgZGVjb2RlIGVycm9yIGlzIHNldCwgaW4gdGhhdCBjYXNlXG4gICAgLy8gaXQgd2lsbCBiZSBmb2xsb3dlZCBieSBhIG1lZGlhRWxlbWVudCBlcnJvciAuLi4pXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUiwgZmF0YWw6IGZhbHNlIH0pO1xuICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gZG8gbW9yZSB0aGFuIHRoYXQsIGFzIGFjY29yZGluIHRvIHRoZSBzcGVjLCB1cGRhdGVlbmQgd2lsbCBiZSBmaXJlZCBqdXN0IGFmdGVyXG4gIH1cblxuICBvbkJ1ZmZlclJlc2V0ICgpIHtcbiAgICBsZXQgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgZm9yIChsZXQgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgIGxldCBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubWVkaWFTb3VyY2UucmVtb3ZlU291cmNlQnVmZmVyKHNiKTtcbiAgICAgICAgc2IucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgdGhpcy5vbnNidWUpO1xuICAgICAgICBzYi5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMub25zYmUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc291cmNlQnVmZmVyID0ge307XG4gICAgdGhpcy5mbHVzaFJhbmdlID0gW107XG4gICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgIHRoaXMuYXBwZW5kZWQgPSAwO1xuICB9XG5cbiAgb25CdWZmZXJDb2RlY3MgKHRyYWNrcykge1xuICAgIC8vIGlmIHNvdXJjZSBidWZmZXIocykgbm90IGNyZWF0ZWQgeWV0LCBhcHBlbmRlZCBidWZmZXIgdHJhY2tzIGluIHRoaXMucGVuZGluZ1RyYWNrc1xuICAgIC8vIGlmIHNvdXJjZWJ1ZmZlcnMgYWxyZWFkeSBjcmVhdGVkLCBkbyBub3RoaW5nIC4uLlxuICAgIC8qKiDpnIDopoHmlL7ov4d0cmFja3MsIOacieaWsOeahHRyYWNr6ZyA6KaB6YeN5paw5YqgYnVmZmVyIOS9v+W+l+eUu+mdouWIsOi+vuaXtu+8jOWPr+S7peaSreaUvueUu+mdolxuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcikubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfSovXG5cbiAgICBPYmplY3Qua2V5cyh0cmFja3MpLmZvckVhY2godHJhY2tOYW1lID0+IHtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrc1t0cmFja05hbWVdID0gdHJhY2tzW3RyYWNrTmFtZV07XG4gICAgfSk7XG4gICAgY29uc3QgeyBtZWRpYVNvdXJjZSB9ID0gdGhpcztcbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSBNYXRoLm1heCh0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgLSAxLCAwKTtcbiAgICBpZiAobWVkaWFTb3VyY2UgJiYgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZVNvdXJjZUJ1ZmZlcnMgKHRyYWNrcykge1xuICAgIGxldCBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlciwgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIGZvciAobGV0IHRyYWNrTmFtZSBpbiB0cmFja3MpIHtcbiAgICAgIGlmICghc291cmNlQnVmZmVyW3RyYWNrTmFtZV0pIHtcbiAgICAgICAgbGV0IHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICAgIC8vIHVzZSBsZXZlbENvZGVjIGFzIGZpcnN0IHByaW9yaXR5XG4gICAgICAgIGxldCBjb2RlYyA9IHRyYWNrLmxldmVsQ29kZWMgfHwgdHJhY2suY29kZWM7XG4gICAgICAgIGxldCBtaW1lVHlwZSA9IGAke3RyYWNrLmNvbnRhaW5lcn07Y29kZWNzPSR7Y29kZWN9YDtcbiAgICAgICAgbG9nZ2VyLmxvZyhgY3JlYXRpbmcgc291cmNlQnVmZmVyKCR7bWltZVR5cGV9KWApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCBzYiA9IHNvdXJjZUJ1ZmZlclt0cmFja05hbWVdID0gbWVkaWFTb3VyY2UuYWRkU291cmNlQnVmZmVyKG1pbWVUeXBlKTtcbiAgICAgICAgICBzYi5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCB0aGlzLm9uc2J1ZSk7XG4gICAgICAgICAgc2IuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLm9uc2JlKTtcbiAgICAgICAgICB0aGlzLnRyYWNrc1t0cmFja05hbWVdID0geyBjb2RlYzogY29kZWMsIGNvbnRhaW5lcjogdHJhY2suY29udGFpbmVyIH07XG4gICAgICAgICAgdHJhY2suYnVmZmVyID0gc2I7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmKGVyci5jb2RlID09IDIyKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKFwiRm91bmQgbmV3IHRyYWNrLCB0cnkgdG8gcmVidWlsZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gc2V0dXAgdGhlIG1lZGlhIHNvdXJjZVxuICAgICAgICAgICAgbGV0IG1zID0gdGhpcy5tZWRpYVNvdXJjZSA9IG5ldyBNZWRpYVNvdXJjZSgpO1xuICAgICAgICAgICAgLy8gTWVkaWEgU291cmNlIGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy5vbm1zbyA9IHRoaXMub25NZWRpYVNvdXJjZU9wZW4uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub25tc2UgPSB0aGlzLm9uTWVkaWFTb3VyY2VFbmRlZC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbm1zYyA9IHRoaXMub25NZWRpYVNvdXJjZUNsb3NlLmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgIGZvcihsZXQgaT0wO2k8T2JqZWN0LmtleXModGhpcy50cmFja3MpLmxlbmd0aDtpKyspIHtcbiAgICAgICAgICAgICAgbGV0IHRyYWNrID0gdGhpcy50cmFja3NbT2JqZWN0LmtleXModGhpcy50cmFja3MpW2ldXTtcbiAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzW09iamVjdC5rZXlzKHRoaXMudHJhY2tzKVtpXV0gPSB0cmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhY2tzID0ge307XG4gICAgICAgICAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHt9O1xuICAgICAgICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMub25tc28pO1xuICAgICAgICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlZW5kZWQnLCB0aGlzLm9ubXNlKTtcbiAgICAgICAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5vbm1zYyk7XG4gICAgICAgICAgICAvLyBsaW5rIHZpZGVvIGFuZCBtZWRpYSBTb3VyY2VcbiAgICAgICAgICAgIHRoaXMubWVkaWEuc3JjID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobXMpO1xuICAgICAgICAgICAgLy8gY2FjaGUgdGhlIGxvY2FsbHkgZ2VuZXJhdGVkIG9iamVjdCB1cmxcbiAgICAgICAgICAgIHRoaXMuX29iamVjdFVybCA9IG1lZGlhLnNyYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBlcnJvciB3aGlsZSB0cnlpbmcgdG8gYWRkIHNvdXJjZUJ1ZmZlcjoke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUiwgZmF0YWw6IGZhbHNlLCBlcnI6IGVyciwgbWltZVR5cGU6IG1pbWVUeXBlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0NSRUFURUQsIHsgdHJhY2tzOiB0cmFja3MgfSk7XG4gIH1cblxuICBvbkJ1ZmZlckFwcGVuZGluZyAoZGF0YSkge1xuICAgIGlmICghdGhpcy5fbmVlZHNGbHVzaCkge1xuICAgICAgaWYgKCF0aGlzLnNlZ21lbnRzKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBbIGRhdGEgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMucHVzaChkYXRhKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kb0FwcGVuZGluZygpO1xuICAgIH1cbiAgfVxuXG4gIG9uQnVmZmVyQXBwZW5kRmFpbCAoZGF0YSkge1xuICAgIGxvZ2dlci5lcnJvcignc291cmNlQnVmZmVyIGVycm9yOicsIGRhdGEuZXZlbnQpO1xuICAgIC8vIGFjY29yZGluZyB0byBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3NvdXJjZWJ1ZmZlci1hcHBlbmQtZXJyb3JcbiAgICAvLyB0aGlzIGVycm9yIG1pZ2h0IG5vdCBhbHdheXMgYmUgZmF0YWwgKGl0IGlzIGZhdGFsIGlmIGRlY29kZSBlcnJvciBpcyBzZXQsIGluIHRoYXQgY2FzZVxuICAgIC8vIGl0IHdpbGwgYmUgZm9sbG93ZWQgYnkgYSBtZWRpYUVsZW1lbnQgZXJyb3IgLi4uKVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSB9KTtcbiAgfVxuXG4gIC8vIG9uIEJVRkZFUl9FT1MgbWFyayBtYXRjaGluZyBzb3VyY2VidWZmZXIocykgYXMgZW5kZWQgYW5kIHRyaWdnZXIgY2hlY2tFb3MoKVxuICBvbkJ1ZmZlckVvcyAoZGF0YSkge1xuICAgIGxldCBzYiA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgIGxldCBkYXRhVHlwZSA9IGRhdGEudHlwZTtcbiAgICBmb3IgKGxldCB0eXBlIGluIHNiKSB7XG4gICAgICBpZiAoIWRhdGFUeXBlIHx8IHR5cGUgPT09IGRhdGFUeXBlKSB7XG4gICAgICAgIGlmICghc2JbdHlwZV0uZW5kZWQpIHtcbiAgICAgICAgICBzYlt0eXBlXS5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgJHt0eXBlfSBzb3VyY2VCdWZmZXIgbm93IEVPU2ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2hlY2tFb3MoKTtcbiAgfVxuXG4gIC8vIGlmIGFsbCBzb3VyY2UgYnVmZmVycyBhcmUgbWFya2VkIGFzIGVuZGVkLCBzaWduYWwgZW5kT2ZTdHJlYW0oKSB0byBNZWRpYVNvdXJjZS5cbiAgY2hlY2tFb3MgKCkge1xuICAgIGxldCBzYiA9IHRoaXMuc291cmNlQnVmZmVyLCBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2U7XG4gICAgaWYgKCFtZWRpYVNvdXJjZSB8fCBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcbiAgICAgIHRoaXMuX25lZWRzRW9zID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IHR5cGUgaW4gc2IpIHtcbiAgICAgIGxldCBzYm9iaiA9IHNiW3R5cGVdO1xuICAgICAgaWYgKCFzYm9iai5lbmRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzYm9iai51cGRhdGluZykge1xuICAgICAgICB0aGlzLl9uZWVkc0VvcyA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9nZ2VyLmxvZygnYWxsIG1lZGlhIGRhdGEgYXJlIGF2YWlsYWJsZSwgc2lnbmFsIGVuZE9mU3RyZWFtKCkgdG8gTWVkaWFTb3VyY2UgYW5kIHN0b3AgbG9hZGluZyBmcmFnbWVudCcpO1xuICAgIC8vIE5vdGlmeSB0aGUgbWVkaWEgZWxlbWVudCB0aGF0IGl0IG5vdyBoYXMgYWxsIG9mIHRoZSBtZWRpYSBkYXRhXG4gICAgdHJ5IHtcbiAgICAgIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLndhcm4oJ2V4Y2VwdGlvbiB3aGlsZSBjYWxsaW5nIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCknKTtcbiAgICB9XG4gICAgdGhpcy5fbmVlZHNFb3MgPSBmYWxzZTtcbiAgfVxuXG4gIG9uQnVmZmVyRmx1c2hpbmcgKGRhdGEpIHtcbiAgICB0aGlzLmZsdXNoUmFuZ2UucHVzaCh7IHN0YXJ0OiBkYXRhLnN0YXJ0T2Zmc2V0LCBlbmQ6IGRhdGEuZW5kT2Zmc2V0LCB0eXBlOiBkYXRhLnR5cGUgfSk7XG4gICAgLy8gYXR0ZW1wdCBmbHVzaCBpbW1lZGlhdGVseVxuICAgIHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyID0gMDtcbiAgICB0aGlzLmRvRmx1c2goKTtcbiAgfVxuXG4gIGZsdXNoTGl2ZUJhY2tCdWZmZXIgKCkge1xuICAgIC8vIGNsZWFyIGJhY2sgYnVmZmVyIGZvciBsaXZlIG9ubHlcbiAgICBpZiAoIXRoaXMuX2xpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsaXZlQmFja0J1ZmZlckxlbmd0aCA9IHRoaXMuaGxzLmNvbmZpZy5saXZlQmFja0J1ZmZlckxlbmd0aDtcbiAgICBpZiAoIWlzRmluaXRlKGxpdmVCYWNrQnVmZmVyTGVuZ3RoKSB8fCBsaXZlQmFja0J1ZmZlckxlbmd0aCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IHRoaXMubWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3Qgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgY29uc3QgYnVmZmVyVHlwZXMgPSBPYmplY3Qua2V5cyhzb3VyY2VCdWZmZXIpO1xuICAgIGNvbnN0IHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbiA9IGN1cnJlbnRUaW1lIC0gTWF0aC5tYXgobGl2ZUJhY2tCdWZmZXJMZW5ndGgsIHRoaXMuX2xldmVsVGFyZ2V0RHVyYXRpb24pO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSBidWZmZXJUeXBlcy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICBjb25zdCBidWZmZXJUeXBlID0gYnVmZmVyVHlwZXNbaW5kZXhdLCBidWZmZXJlZCA9IHNvdXJjZUJ1ZmZlcltidWZmZXJUeXBlXS5idWZmZXJlZDtcblxuICAgICAgLy8gd2hlbiB0YXJnZXQgYnVmZmVyIHN0YXJ0IGV4Y2VlZHMgYWN0dWFsIGJ1ZmZlciBzdGFydFxuICAgICAgaWYgKGJ1ZmZlcmVkLmxlbmd0aCA+IDAgJiYgdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uID4gYnVmZmVyZWQuc3RhcnQoMCkpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGJ1ZmZlciB1cCB1bnRpbCBjdXJyZW50IHRpbWUgbWludXMgbWluaW11bSBiYWNrIGJ1ZmZlciBsZW5ndGggKHJlbW92aW5nIGJ1ZmZlciB0b28gY2xvc2UgdG8gY3VycmVudFxuICAgICAgICAvLyB0aW1lIHdpbGwgbGVhZCB0byBwbGF5YmFjayBmcmVlemluZylcbiAgICAgICAgLy8gY3JlZGl0cyBmb3IgbGV2ZWwgdGFyZ2V0IGR1cmF0aW9uIC0gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvaHR0cC1zdHJlYW1pbmcvYmxvYi8zMTMyOTMzYjZhYTk5ZGRlZmFiMjljMTA0NDc2MjRlZmQ2ZmQ2ZTUyL3NyYy9zZWdtZW50LWxvYWRlci5qcyNMOTFcbiAgICAgICAgdGhpcy5yZW1vdmVCdWZmZXJSYW5nZShidWZmZXJUeXBlLCBzb3VyY2VCdWZmZXJbYnVmZmVyVHlwZV0sIDAsIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25MZXZlbFVwZGF0ZWQgKHsgZGV0YWlscyB9KSB7XG4gICAgaWYgKGRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX2xldmVsRHVyYXRpb24gPSBkZXRhaWxzLnRvdGFsZHVyYXRpb24gKyBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgIHRoaXMuX2xldmVsVGFyZ2V0RHVyYXRpb24gPSBkZXRhaWxzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiB8fCBkZXRhaWxzLnRhcmdldGR1cmF0aW9uIHx8IDEwO1xuICAgICAgdGhpcy5fbGl2ZSA9IGRldGFpbHMubGl2ZTtcbiAgICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiB0byBjdXJyZW50IGxldmVsIGR1cmF0aW9uIG9yIG92ZXJyaWRlIHRvIEluZmluaXR5IGlmIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyXG4gICAqICdsaXZlRHVyYXRpb25JbmZpbml0eWAgaXMgc2V0IHRvIGB0cnVlYFxuICAgKiBNb3JlIGRldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8zNTVcbiAgICovXG4gIHVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uICgpIHtcbiAgICBsZXQgeyBjb25maWcgfSA9IHRoaXMuaGxzO1xuICAgIGxldCBkdXJhdGlvbjtcblxuICAgIGlmICh0aGlzLl9sZXZlbER1cmF0aW9uID09PSBudWxsIHx8XG4gICAgICAhdGhpcy5tZWRpYSB8fFxuICAgICAgIXRoaXMubWVkaWFTb3VyY2UgfHxcbiAgICAgICF0aGlzLnNvdXJjZUJ1ZmZlciB8fFxuICAgICAgdGhpcy5tZWRpYS5yZWFkeVN0YXRlID09PSAwIHx8XG4gICAgICB0aGlzLm1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IHR5cGUgaW4gdGhpcy5zb3VyY2VCdWZmZXIpIHtcbiAgICAgIGlmICh0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXS51cGRhdGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBjYW4ndCBzZXQgZHVyYXRpb24gd2hpbHN0IGEgYnVmZmVyIGlzIHVwZGF0aW5nXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkdXJhdGlvbiA9IHRoaXMubWVkaWEuZHVyYXRpb247XG4gICAgLy8gaW5pdGlhbGlzZSB0byB0aGUgdmFsdWUgdGhhdCB0aGUgbWVkaWEgc291cmNlIGlzIHJlcG9ydGluZ1xuICAgIGlmICh0aGlzLl9tc0R1cmF0aW9uID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9tc0R1cmF0aW9uID0gdGhpcy5tZWRpYVNvdXJjZS5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGl2ZSA9PT0gdHJ1ZSAmJiBjb25maWcubGl2ZUR1cmF0aW9uSW5maW5pdHkgPT09IHRydWUpIHtcbiAgICAgIC8vIE92ZXJyaWRlIGR1cmF0aW9uIHRvIEluZmluaXR5XG4gICAgICBsb2dnZXIubG9nKCdNZWRpYSBTb3VyY2UgZHVyYXRpb24gaXMgc2V0IHRvIEluZmluaXR5Jyk7XG4gICAgICB0aGlzLl9tc0R1cmF0aW9uID0gdGhpcy5tZWRpYVNvdXJjZS5kdXJhdGlvbiA9IEluZmluaXR5O1xuICAgIH0gZWxzZSBpZiAoKHRoaXMuX2xldmVsRHVyYXRpb24gPiB0aGlzLl9tc0R1cmF0aW9uICYmIHRoaXMuX2xldmVsRHVyYXRpb24gPiBkdXJhdGlvbikgfHwgIU51bWJlci5pc0Zpbml0ZShkdXJhdGlvbikpIHtcbiAgICAgIC8vIGxldmVsRHVyYXRpb24gd2FzIHRoZSBsYXN0IHZhbHVlIHdlIHNldC5cbiAgICAgIC8vIG5vdCB1c2luZyBtZWRpYVNvdXJjZS5kdXJhdGlvbiBhcyB0aGUgYnJvd3NlciBtYXkgdHdlYWsgdGhpcyB2YWx1ZVxuICAgICAgLy8gb25seSB1cGRhdGUgTWVkaWEgU291cmNlIGR1cmF0aW9uIGlmIGl0cyB2YWx1ZSBpbmNyZWFzZSwgdGhpcyBpcyB0byBhdm9pZFxuICAgICAgLy8gZmx1c2hpbmcgYWxyZWFkeSBidWZmZXJlZCBwb3J0aW9uIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gcXVhbGl0eSBsZXZlbFxuICAgICAgbG9nZ2VyLmxvZyhgVXBkYXRpbmcgTWVkaWEgU291cmNlIGR1cmF0aW9uIHRvICR7dGhpcy5fbGV2ZWxEdXJhdGlvbi50b0ZpeGVkKDMpfWApO1xuICAgICAgdGhpcy5fbXNEdXJhdGlvbiA9IHRoaXMubWVkaWFTb3VyY2UuZHVyYXRpb24gPSB0aGlzLl9sZXZlbER1cmF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIGRvRmx1c2ggKCkge1xuICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgYnVmZmVyIHJhbmdlcyB0byBmbHVzaFxuICAgIHdoaWxlICh0aGlzLmZsdXNoUmFuZ2UubGVuZ3RoKSB7XG4gICAgICBsZXQgcmFuZ2UgPSB0aGlzLmZsdXNoUmFuZ2VbMF07XG4gICAgICAvLyBmbHVzaEJ1ZmZlciB3aWxsIGFib3J0IGFueSBidWZmZXIgYXBwZW5kIGluIHByb2dyZXNzIGFuZCBmbHVzaCBBdWRpby9WaWRlbyBCdWZmZXJcbiAgICAgIGlmICh0aGlzLmZsdXNoQnVmZmVyKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIHJhbmdlLnR5cGUpKSB7XG4gICAgICAgIC8vIHJhbmdlIGZsdXNoZWQsIHJlbW92ZSBmcm9tIGZsdXNoIGFycmF5XG4gICAgICAgIHRoaXMuZmx1c2hSYW5nZS5zaGlmdCgpO1xuICAgICAgICB0aGlzLmZsdXNoQnVmZmVyQ291bnRlciA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9uZWVkc0ZsdXNoID0gdHJ1ZTtcbiAgICAgICAgLy8gYXZvaWQgbG9vcGluZywgd2FpdCBmb3IgU0IgdXBkYXRlIGVuZCB0byByZXRyaWdnZXIgYSBmbHVzaFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmZsdXNoUmFuZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBldmVyeXRoaW5nIGZsdXNoZWRcbiAgICAgIHRoaXMuX25lZWRzRmx1c2ggPSBmYWxzZTtcblxuICAgICAgLy8gbGV0J3MgcmVjb21wdXRlIHRoaXMuYXBwZW5kZWQsIHdoaWNoIGlzIHVzZWQgdG8gYXZvaWQgZmx1c2ggbG9vcGluZ1xuICAgICAgbGV0IGFwcGVuZGVkID0gMDtcbiAgICAgIGxldCBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gc291cmNlQnVmZmVyKSB7XG4gICAgICAgICAgYXBwZW5kZWQgKz0gc291cmNlQnVmZmVyW3R5cGVdLmJ1ZmZlcmVkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gZXJyb3IgY291bGQgYmUgdGhyb3duIHdoaWxlIGFjY2Vzc2luZyBidWZmZXJlZCwgaW4gY2FzZSBzb3VyY2VidWZmZXIgaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkIGZyb20gTWVkaWFTb3VyY2VcbiAgICAgICAgLy8gdGhpcyBpcyBoYXJtZXNzIGF0IHRoaXMgc3RhZ2UsIGNhdGNoIHRoaXMgdG8gYXZvaWQgcmVwb3J0aW5nIGFuIGludGVybmFsIGV4Y2VwdGlvblxuICAgICAgICBsb2dnZXIuZXJyb3IoJ2Vycm9yIHdoaWxlIGFjY2Vzc2luZyBzb3VyY2VCdWZmZXIuYnVmZmVyZWQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kZWQgPSBhcHBlbmRlZDtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNIRUQpO1xuICAgIH1cbiAgfVxuXG4gIGRvQXBwZW5kaW5nICgpIHtcbiAgICBcbiAgICBsZXQgeyBobHMsIHNlZ21lbnRzLCBzb3VyY2VCdWZmZXIgfSA9IHRoaXM7XG4gICAgaWYgKE9iamVjdC5rZXlzKHNvdXJjZUJ1ZmZlcikubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYS5lcnJvcikge1xuICAgICAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgICAgIGxvZ2dlci5lcnJvcigndHJ5aW5nIHRvIGFwcGVuZCBhbHRob3VnaCBhIG1lZGlhIGVycm9yIG9jY3VyZWQsIGZsdXNoIHNlZ21lbnQgYW5kIGFib3J0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmFwcGVuZGluZykge1xuICAgICAgICAvLyBsb2dnZXIubG9nKGBzYiBhcHBlbmRpbmcgaW4gcHJvZ3Jlc3NgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICBsZXQgc2VnbWVudCA9IHNlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHR5cGUgPSBzZWdtZW50LnR5cGUsIHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICAgIGlmIChzYikge1xuICAgICAgICAgICAgaWYgKCFzYi51cGRhdGluZykge1xuICAgICAgICAgICAgICAvLyByZXNldCBzb3VyY2VCdWZmZXIgZW5kZWQgZmxhZyBiZWZvcmUgYXBwZW5kaW5nIHNlZ21lbnRcbiAgICAgICAgICAgICAgc2IuZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZyhgYXBwZW5kaW5nICR7c2VnbWVudC5jb250ZW50fSAke3R5cGV9IFNCLCBzaXplOiR7c2VnbWVudC5kYXRhLmxlbmd0aH0sICR7c2VnbWVudC5wYXJlbnR9YCk7XG4gICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gc2VnbWVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgIHNiLmFwcGVuZEJ1ZmZlcihzZWdtZW50LmRhdGEpO1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yID0gMDtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRlZCsrO1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWdtZW50cy51bnNoaWZ0KHNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIHdlIGRvbid0IGhhdmUgYW55IHNvdXJjZSBidWZmZXIgbWF0Y2hpbmcgd2l0aCB0aGlzIHNlZ21lbnQgdHlwZSxcbiAgICAgICAgICAgIC8vIGl0IG1lYW5zIHRoYXQgTWVkaWFzb3VyY2UgZmFpbHMgdG8gY3JlYXRlIHNvdXJjZWJ1ZmZlclxuICAgICAgICAgICAgLy8gZGlzY2FyZCB0aGlzIHNlZ21lbnQsIGFuZCB0cmlnZ2VyIHVwZGF0ZSBlbmRcbiAgICAgICAgICAgIHRoaXMub25TQlVwZGF0ZUVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSBhbnkgZXJyb3Igb2NjdXJlZCB3aGlsZSBhcHBlbmRpbmcsIHB1dCBiYWNrIHNlZ21lbnQgaW4gc2VnbWVudHMgdGFibGVcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoYGVycm9yIHdoaWxlIHRyeWluZyB0byBhcHBlbmQgYnVmZmVyOiR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgc2VnbWVudHMudW5zaGlmdChzZWdtZW50KTtcbiAgICAgICAgICBsZXQgZXZlbnQgPSB7IHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIHBhcmVudDogc2VnbWVudC5wYXJlbnQgfTtcbiAgICAgICAgICBpZiAoZXJyLmNvZGUgIT09IDIyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRFcnJvcikge1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXZlbnQuZGV0YWlscyA9IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SO1xuICAgICAgICAgICAgLyogd2l0aCBVSEQgY29udGVudCwgd2UgY291bGQgZ2V0IGxvb3Agb2YgcXVvdGEgZXhjZWVkZWQgZXJyb3IgdW50aWxcbiAgICAgICAgICAgICAgYnJvd3NlciBpcyBhYmxlIHRvIGV2aWN0IHNvbWUgZGF0YSBmcm9tIHNvdXJjZWJ1ZmZlci4gcmV0cnlpbmcgaGVscCByZWNvdmVyaW5nIHRoaXNcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRFcnJvciA+IGhscy5jb25maWcuYXBwZW5kRXJyb3JNYXhSZXRyeSkge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBmYWlsICR7aGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5fSB0aW1lcyB0byBhcHBlbmQgc2VnbWVudCBpbiBzb3VyY2VCdWZmZXJgKTtcbiAgICAgICAgICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgICBldmVudC5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCBldmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBldmVudC5mYXRhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBRdW90YUV4Y2VlZGVkRXJyb3I6IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjcXVvdGFleGNlZWRlZGVycm9yXG4gICAgICAgICAgICAvLyBsZXQncyBzdG9wIGFwcGVuZGluZyBhbnkgc2VnbWVudHMsIGFuZCByZXBvcnQgQlVGRkVSX0ZVTExfRVJST1IgZXJyb3JcbiAgICAgICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I7XG4gICAgICAgICAgICBldmVudC5mYXRhbCA9IGZhbHNlO1xuICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICAgIGZsdXNoIHNwZWNpZmllZCBidWZmZXJlZCByYW5nZSxcbiAgICByZXR1cm4gdHJ1ZSBvbmNlIHJhbmdlIGhhcyBiZWVuIGZsdXNoZWQuXG4gICAgYXMgc291cmNlQnVmZmVyLnJlbW92ZSgpIGlzIGFzeW5jaHJvbm91cywgZmx1c2hCdWZmZXIgd2lsbCBiZSByZXRyaWdnZXJlZCBvbiBzb3VyY2VCdWZmZXIgdXBkYXRlIGVuZFxuICAqL1xuICBmbHVzaEJ1ZmZlciAoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdHlwZUluKSB7XG4gICAgbGV0IHNiO1xuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgIGlmIChPYmplY3Qua2V5cyhzb3VyY2VCdWZmZXIpLmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLmxvZyhgZmx1c2hCdWZmZXIscG9zL3N0YXJ0L2VuZDogJHt0aGlzLm1lZGlhLmN1cnJlbnRUaW1lLnRvRml4ZWQoMyl9LyR7c3RhcnRPZmZzZXR9LyR7ZW5kT2Zmc2V0fWApO1xuICAgICAgLy8gc2FmZWd1YXJkIHRvIGF2b2lkIGluZmluaXRlIGxvb3BpbmcgOiBkb24ndCB0cnkgdG8gZmx1c2ggbW9yZSB0aGFuIHRoZSBuYiBvZiBhcHBlbmRlZCBzZWdtZW50c1xuICAgICAgaWYgKHRoaXMuZmx1c2hCdWZmZXJDb3VudGVyIDwgdGhpcy5hcHBlbmRlZCkge1xuICAgICAgICBmb3IgKGxldCB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAgIC8vIGNoZWNrIGlmIHNvdXJjZWJ1ZmZlciB0eXBlIGlzIGRlZmluZWQgKHR5cGVJbik6IGlmIHllcywgbGV0J3Mgb25seSBmbHVzaCB0aGlzIG9uZVxuICAgICAgICAgIC8vIGlmIG5vLCBsZXQncyBmbHVzaCBhbGwgc291cmNlYnVmZmVyc1xuICAgICAgICAgIGlmICh0eXBlSW4gJiYgdHlwZSAhPT0gdHlwZUluKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgICAvLyB3ZSBhcmUgZ29pbmcgdG8gZmx1c2ggYnVmZmVyLCBtYXJrIHNvdXJjZSBidWZmZXIgYXMgJ25vdCBlbmRlZCdcbiAgICAgICAgICBzYi5lbmRlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmICghc2IudXBkYXRpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbW92ZUJ1ZmZlclJhbmdlKHR5cGUsIHNiLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSkge1xuICAgICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyQ291bnRlcisrO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdjYW5ub3QgZmx1c2gsIHNiIHVwZGF0aW5nIGluIHByb2dyZXNzJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybignYWJvcnQgZmx1c2hpbmcgdG9vIG1hbnkgcmV0cmllcycpO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLmxvZygnYnVmZmVyIGZsdXNoZWQnKTtcbiAgICB9XG4gICAgLy8gZXZlcnl0aGluZyBmbHVzaGVkICFcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGZpcnN0IGJ1ZmZlcmVkIHJhbmdlIGZyb20gcHJvdmlkZWQgc291cmNlIGJ1ZmZlciB0aGF0IGxpZXMgd2l0aGluIGdpdmVuIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0cy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgVHlwZSBvZiB0aGUgc291cmNlIGJ1ZmZlciwgbG9nZ2luZyBwdXJwb3NlcyBvbmx5LlxuICAgKiBAcGFyYW0gc2IgVGFyZ2V0IFNvdXJjZUJ1ZmZlciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHN0YXJ0T2Zmc2V0XG4gICAqIEBwYXJhbSBlbmRPZmZzZXRcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgd2hlbiBzb3VyY2UgYnVmZmVyIHJlbW92ZSByZXF1ZXN0ZWQuXG4gICAqL1xuICByZW1vdmVCdWZmZXJSYW5nZSAodHlwZSwgc2IsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICB0cnkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYi5idWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYnVmU3RhcnQgPSBzYi5idWZmZXJlZC5zdGFydChpKTtcbiAgICAgICAgbGV0IGJ1ZkVuZCA9IHNiLmJ1ZmZlcmVkLmVuZChpKTtcbiAgICAgICAgbGV0IHJlbW92ZVN0YXJ0ID0gTWF0aC5tYXgoYnVmU3RhcnQsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgbGV0IHJlbW92ZUVuZCA9IE1hdGgubWluKGJ1ZkVuZCwgZW5kT2Zmc2V0KTtcblxuICAgICAgICAvKiBzb21ldGltZXMgc291cmNlYnVmZmVyLnJlbW92ZSgpIGRvZXMgbm90IGZsdXNoXG4gICAgICAgICAgdGhlIGV4YWN0IGV4cGVjdGVkIHRpbWUgcmFuZ2UuXG4gICAgICAgICAgdG8gYXZvaWQgcm91bmRpbmcgaXNzdWVzL2luZmluaXRlIGxvb3AsXG4gICAgICAgICAgb25seSBmbHVzaCBidWZmZXIgcmFuZ2Ugb2YgbGVuZ3RoIGdyZWF0ZXIgdGhhbiA1MDBtcy5cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKE1hdGgubWluKHJlbW92ZUVuZCwgYnVmRW5kKSAtIHJlbW92ZVN0YXJ0ID4gMC41KSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgc2IgcmVtb3ZlICR7dHlwZX0gWyR7cmVtb3ZlU3RhcnR9LCR7cmVtb3ZlRW5kfV0sIG9mIFske2J1ZlN0YXJ0fSwke2J1ZkVuZH1dLCBwb3M6JHt0aGlzLm1lZGlhLmN1cnJlbnRUaW1lfWApO1xuICAgICAgICAgIHNiLnJlbW92ZShyZW1vdmVTdGFydCwgcmVtb3ZlRW5kKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIud2FybigncmVtb3ZlQnVmZmVyUmFuZ2UgZmFpbGVkJywgZXJyb3IpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdWZmZXJDb250cm9sbGVyO1xuIiwiLypcbiAqIGNhcCBzdHJlYW0gbGV2ZWwgdG8gbWVkaWEgc2l6ZSBkaW1lbnNpb24gY29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuXG5jbGFzcyBDYXBMZXZlbENvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuRlBTX0RST1BfTEVWRUxfQ0FQUElORyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX1BBUlNFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9DT0RFQ1MsXG4gICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcpO1xuXG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IG51bGw7XG4gICAgdGhpcy5sZXZlbHMgPSBbXTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGlmICh0aGlzLmhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUpIHtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgdGhpcy5fc3RvcENhcHBpbmcoKTtcbiAgICB9XG4gIH1cblxuICBvbkZwc0Ryb3BMZXZlbENhcHBpbmcgKGRhdGEpIHtcbiAgICAvLyBEb24ndCBhZGQgYSByZXN0cmljdGVkIGxldmVsIG1vcmUgdGhhbiBvbmNlXG4gICAgaWYgKENhcExldmVsQ29udHJvbGxlci5pc0xldmVsQWxsb3dlZChkYXRhLmRyb3BwZWRMZXZlbCwgdGhpcy5yZXN0cmljdGVkTGV2ZWxzKSkge1xuICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLnB1c2goZGF0YS5kcm9wcGVkTGV2ZWwpO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFBdHRhY2hpbmcgKGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XG4gIH1cblxuICBvbk1hbmlmZXN0UGFyc2VkIChkYXRhKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSBkYXRhLmZpcnN0TGV2ZWw7XG4gICAgaWYgKGhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgZGF0YS52aWRlbykge1xuICAgICAgLy8gU3RhcnQgY2FwcGluZyBpbW1lZGlhdGVseSBpZiB0aGUgbWFuaWZlc3QgaGFzIHNpZ25hbGVkIHZpZGVvIGNvZGVjc1xuICAgICAgdGhpcy5fc3RhcnRDYXBwaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gT25seSBhY3RpdmF0ZSBjYXBwaW5nIHdoZW4gcGxheWluZyBhIHZpZGVvIHN0cmVhbTsgb3RoZXJ3aXNlLCBtdWx0aS1iaXRyYXRlIGF1ZGlvLW9ubHkgc3RyZWFtcyB3aWxsIGJlIHJlc3RyaWN0ZWRcbiAgLy8gdG8gdGhlIGZpcnN0IGxldmVsXG4gIG9uQnVmZmVyQ29kZWNzIChkYXRhKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKGhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgZGF0YS52aWRlbykge1xuICAgICAgLy8gSWYgdGhlIG1hbmlmZXN0IGRpZCBub3Qgc2lnbmFsIGEgdmlkZW8gY29kZWMgY2FwcGluZyBoYXMgYmVlbiBkZWZlcnJlZCB1bnRpbCB3ZSdyZSBjZXJ0YWluIHZpZGVvIGlzIHByZXNlbnRcbiAgICAgIHRoaXMuX3N0YXJ0Q2FwcGluZygpO1xuICAgIH1cbiAgfVxuXG4gIG9uTGV2ZWxzVXBkYXRlZCAoZGF0YSkge1xuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gIH1cblxuICBvbk1lZGlhRGV0YWNoaW5nICgpIHtcbiAgICB0aGlzLl9zdG9wQ2FwcGluZygpO1xuICB9XG5cbiAgZGV0ZWN0UGxheWVyU2l6ZSAoKSB7XG4gICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgIGxldCBsZXZlbHNMZW5ndGggPSB0aGlzLmxldmVscyA/IHRoaXMubGV2ZWxzLmxlbmd0aCA6IDA7XG4gICAgICBpZiAobGV2ZWxzTGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IHRoaXMuZ2V0TWF4TGV2ZWwobGV2ZWxzTGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmIChobHMuYXV0b0xldmVsQ2FwcGluZyA+IHRoaXMuYXV0b0xldmVsQ2FwcGluZykge1xuICAgICAgICAgIC8vIGlmIGF1dG8gbGV2ZWwgY2FwcGluZyBoYXMgYSBoaWdoZXIgdmFsdWUgZm9yIHRoZSBwcmV2aW91cyBvbmUsIGZsdXNoIHRoZSBidWZmZXIgdXNpbmcgbmV4dExldmVsU3dpdGNoXG4gICAgICAgICAgLy8gdXN1YWxseSBoYXBwZW4gd2hlbiB0aGUgdXNlciBnbyB0byB0aGUgZnVsbHNjcmVlbiBtb2RlLlxuICAgICAgICAgIGhscy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IGhscy5hdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICogcmV0dXJucyBsZXZlbCBzaG91bGQgYmUgdGhlIG9uZSB3aXRoIHRoZSBkaW1lbnNpb25zIGVxdWFsIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbWVkaWEgKHBsYXllcikgZGltZW5zaW9ucyAoc28gdGhlIHZpZGVvIHdpbGwgYmUgZG93bnNjYWxlZClcbiAgKi9cbiAgZ2V0TWF4TGV2ZWwgKGNhcExldmVsSW5kZXgpIHtcbiAgICBpZiAoIXRoaXMubGV2ZWxzKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsaWRMZXZlbHMgPSB0aGlzLmxldmVscy5maWx0ZXIoKGxldmVsLCBpbmRleCkgPT5cbiAgICAgIENhcExldmVsQ29udHJvbGxlci5pc0xldmVsQWxsb3dlZChpbmRleCwgdGhpcy5yZXN0cmljdGVkTGV2ZWxzKSAmJiBpbmRleCA8PSBjYXBMZXZlbEluZGV4XG4gICAgKTtcblxuICAgIHJldHVybiBDYXBMZXZlbENvbnRyb2xsZXIuZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZSh2YWxpZExldmVscywgdGhpcy5tZWRpYVdpZHRoLCB0aGlzLm1lZGlhSGVpZ2h0KTtcbiAgfVxuXG4gIF9zdGFydENhcHBpbmcgKCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAvLyBEb24ndCByZXNldCBjYXBwaW5nIGlmIHN0YXJ0ZWQgdHdpY2U7IHRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgbWFuaWZlc3Qgc2lnbmFscyBhIHZpZGVvIGNvZGVjXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB0aGlzLmhscy5maXJzdExldmVsID0gdGhpcy5nZXRNYXhMZXZlbCh0aGlzLmZpcnN0TGV2ZWwpO1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKHRoaXMuZGV0ZWN0UGxheWVyU2l6ZS5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICB0aGlzLmRldGVjdFBsYXllclNpemUoKTtcbiAgfVxuXG4gIF9zdG9wQ2FwcGluZyAoKSB7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgdGhpcy5maXJzdExldmVsID0gbnVsbDtcbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIHRoaXMudGltZXIgPSBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZ2V0IG1lZGlhV2lkdGggKCkge1xuICAgIGxldCB3aWR0aDtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICB3aWR0aCA9IG1lZGlhLndpZHRoIHx8IG1lZGlhLmNsaWVudFdpZHRoIHx8IG1lZGlhLm9mZnNldFdpZHRoO1xuICAgICAgd2lkdGggKj0gQ2FwTGV2ZWxDb250cm9sbGVyLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG5cbiAgZ2V0IG1lZGlhSGVpZ2h0ICgpIHtcbiAgICBsZXQgaGVpZ2h0O1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIGhlaWdodCA9IG1lZGlhLmhlaWdodCB8fCBtZWRpYS5jbGllbnRIZWlnaHQgfHwgbWVkaWEub2Zmc2V0SGVpZ2h0O1xuICAgICAgaGVpZ2h0ICo9IENhcExldmVsQ29udHJvbGxlci5jb250ZW50U2NhbGVGYWN0b3I7XG4gICAgfVxuICAgIHJldHVybiBoZWlnaHQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGNvbnRlbnRTY2FsZUZhY3RvciAoKSB7XG4gICAgbGV0IHBpeGVsUmF0aW8gPSAxO1xuICAgIHRyeSB7XG4gICAgICBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gcGl4ZWxSYXRpbztcbiAgfVxuXG4gIHN0YXRpYyBpc0xldmVsQWxsb3dlZCAobGV2ZWwsIHJlc3RyaWN0ZWRMZXZlbHMgPSBbXSkge1xuICAgIHJldHVybiByZXN0cmljdGVkTGV2ZWxzLmluZGV4T2YobGV2ZWwpID09PSAtMTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRNYXhMZXZlbEJ5TWVkaWFTaXplIChsZXZlbHMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIWxldmVscyB8fCAobGV2ZWxzICYmICFsZXZlbHMubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIExldmVscyBjYW4gaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zIGJ1dCBkaWZmZXJpbmcgYmFuZHdpZHRocyAtIHNpbmNlIGxldmVscyBhcmUgb3JkZXJlZCwgd2UgY2FuIGxvb2sgdG8gdGhlIG5leHRcbiAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSd2ZSBjaG9zZW4gdGhlIGdyZWF0ZXN0IGJhbmR3aWR0aCBmb3IgdGhlIG1lZGlhJ3MgZGltZW5zaW9uc1xuICAgIGNvbnN0IGF0R3JlYXRlc3RCYW5kaXdkdGggPSAoY3VyTGV2ZWwsIG5leHRMZXZlbCkgPT4ge1xuICAgICAgaWYgKCFuZXh0TGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJMZXZlbC53aWR0aCAhPT0gbmV4dExldmVsLndpZHRoIHx8IGN1ckxldmVsLmhlaWdodCAhPT0gbmV4dExldmVsLmhlaWdodDtcbiAgICB9O1xuXG4gICAgLy8gSWYgd2UgcnVuIHRocm91Z2ggdGhlIGxvb3Agd2l0aG91dCBicmVha2luZywgdGhlIG1lZGlhJ3MgZGltZW5zaW9ucyBhcmUgZ3JlYXRlciB0aGFuIGV2ZXJ5IGxldmVsLCBzbyBkZWZhdWx0IHRvXG4gICAgLy8gdGhlIG1heCBsZXZlbFxuICAgIGxldCBtYXhMZXZlbEluZGV4ID0gbGV2ZWxzLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICBpZiAoKGxldmVsLndpZHRoID49IHdpZHRoIHx8IGxldmVsLmhlaWdodCA+PSBoZWlnaHQpICYmIGF0R3JlYXRlc3RCYW5kaXdkdGgobGV2ZWwsIGxldmVsc1tpICsgMV0pKSB7XG4gICAgICAgIG1heExldmVsSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF4TGV2ZWxJbmRleDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYXBMZXZlbENvbnRyb2xsZXI7XG4iLCIvKipcbiAqIEBhdXRob3IgU3RlcGhhbiBIZXNzZSA8ZGlzcGFyYXRAZ21haWwuY29tPiB8IDx0Y2hha2FiYW1AZ21haWwuY29tPlxuICpcbiAqIERSTSBzdXBwb3J0IGZvciBIbHMuanNcbiAqL1xuXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jb25zdCB7IFhNTEh0dHBSZXF1ZXN0IH0gPSB3aW5kb3c7XG5cbmNvbnN0IE1BWF9MSUNFTlNFX1JFUVVFU1RfRkFJTFVSRVMgPSAzO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05hdmlnYXRvci9yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NcbiAqL1xuY29uc3QgS2V5U3lzdGVtcyA9IHtcbiAgV0lERVZJTkU6ICdjb20ud2lkZXZpbmUuYWxwaGEnLFxuICBQTEFZUkVBRFk6ICdjb20ubWljcm9zb2Z0LnBsYXlyZWFkeSdcbn07XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9uXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGF1ZGlvQ29kZWNzIExpc3Qgb2YgcmVxdWlyZWQgYXVkaW8gY29kZWNzIHRvIHN1cHBvcnRcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdmlkZW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCB2aWRlbyBjb2RlY3MgdG8gc3VwcG9ydFxuICogQHBhcmFtIHtvYmplY3R9IGRybVN5c3RlbU9wdGlvbnMgT3B0aW9uYWwgcGFyYW1ldGVycy9yZXF1aXJlbWVudHMgZm9yIHRoZSBrZXktc3lzdGVtXG4gKiBAcmV0dXJucyB7QXJyYXk8TWVkaWFTeXN0ZW1Db25maWd1cmF0aW9uPn0gQW4gYXJyYXkgb2Ygc3VwcG9ydGVkIGNvbmZpZ3VyYXRpb25zXG4gKi9cblxuY29uc3QgY3JlYXRlV2lkZXZpbmVNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zID0gZnVuY3Rpb24gKGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcywgZHJtU3lzdGVtT3B0aW9ucykgeyAvKiBqc2hpbnQgaWdub3JlOmxpbmUgKi9cbiAgY29uc3QgYmFzZUNvbmZpZyA9IHtcbiAgICAvLyBpbml0RGF0YVR5cGVzOiBbJ2tleWlkcycsICdtcDQnXSxcbiAgICAvLyBsYWJlbDogXCJcIixcbiAgICAvLyBwZXJzaXN0ZW50U3RhdGU6IFwibm90LWFsbG93ZWRcIiwgLy8gb3IgXCJyZXF1aXJlZFwiID9cbiAgICAvLyBkaXN0aW5jdGl2ZUlkZW50aWZpZXI6IFwibm90LWFsbG93ZWRcIiwgLy8gb3IgXCJyZXF1aXJlZFwiID9cbiAgICAvLyBzZXNzaW9uVHlwZXM6IFsndGVtcG9yYXJ5J10sXG4gICAgdmlkZW9DYXBhYmlsaXRpZXM6IFtcbiAgICAgIC8vIHsgY29udGVudFR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJFMDFFXCInIH1cbiAgICBdXG4gIH07XG5cbiAgdmlkZW9Db2RlY3MuZm9yRWFjaCgoY29kZWMpID0+IHtcbiAgICBiYXNlQ29uZmlnLnZpZGVvQ2FwYWJpbGl0aWVzLnB1c2goe1xuICAgICAgY29udGVudFR5cGU6IGB2aWRlby9tcDQ7IGNvZGVjcz1cIiR7Y29kZWN9XCJgXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBbXG4gICAgYmFzZUNvbmZpZ1xuICBdO1xufTtcblxuLyoqXG4gKiBUaGUgaWRlYSBoZXJlIGlzIHRvIGhhbmRsZSBrZXktc3lzdGVtIChhbmQgdGhlaXIgcmVzcGVjdGl2ZSBwbGF0Zm9ybXMpIHNwZWNpZmljIGNvbmZpZ3VyYXRpb24gZGlmZmVyZW5jZXNcbiAqIGluIG9yZGVyIHRvIHdvcmsgd2l0aCB0aGUgbG9jYWwgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIG1ldGhvZC5cbiAqXG4gKiBXZSBjYW4gYWxzbyBydWxlLW91dCBwbGF0Zm9ybS1yZWxhdGVkIGtleS1zeXN0ZW0gc3VwcG9ydCBhdCB0aGlzIHBvaW50IGJ5IHRocm93aW5nIGFuIGVycm9yIG9yIHJldHVybmluZyBudWxsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlTeXN0ZW0gSWRlbnRpZmllciBmb3IgdGhlIGtleS1zeXN0ZW0sIHNlZSBgS2V5U3lzdGVtc2AgZW51bVxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhdWRpb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIGF1ZGlvIGNvZGVjcyB0byBzdXBwb3J0XG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHZpZGVvQ29kZWNzIExpc3Qgb2YgcmVxdWlyZWQgdmlkZW8gY29kZWNzIHRvIHN1cHBvcnRcbiAqIEByZXR1cm5zIHtBcnJheTxNZWRpYVN5c3RlbUNvbmZpZ3VyYXRpb24+IHwgbnVsbH0gQSBub24tZW1wdHkgQXJyYXkgb2YgTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9uIG9iamVjdHMgb3IgYG51bGxgXG4gKi9cbmNvbnN0IGdldFN1cHBvcnRlZE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMgPSBmdW5jdGlvbiAoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MpIHtcbiAgc3dpdGNoIChrZXlTeXN0ZW0pIHtcbiAgY2FzZSBLZXlTeXN0ZW1zLldJREVWSU5FOlxuICAgIHJldHVybiBjcmVhdGVXaWRldmluZU1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMoYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKTtcbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBFcnJvcignVW5rbm93biBrZXktc3lzdGVtOiAnICsga2V5U3lzdGVtKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb250cm9sbGVyIHRvIGRlYWwgd2l0aCBlbmNyeXB0ZWQgbWVkaWEgZXh0ZW5zaW9ucyAoRU1FKVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRW5jcnlwdGVkX01lZGlhX0V4dGVuc2lvbnNfQVBJXG4gKlxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgRU1FQ29udHJvbGxlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RzXG4gICAgICogQHBhcmFtIHtIbHN9IGhscyBPdXIgSGxzLmpzIGluc3RhbmNlXG4gICAgICovXG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX1BBUlNFRFxuICAgICk7XG5cbiAgICB0aGlzLl93aWRldmluZUxpY2Vuc2VVcmwgPSBobHMuY29uZmlnLndpZGV2aW5lTGljZW5zZVVybDtcbiAgICB0aGlzLl9saWNlbnNlWGhyU2V0dXAgPSBobHMuY29uZmlnLmxpY2Vuc2VYaHJTZXR1cDtcbiAgICB0aGlzLl9lbWVFbmFibGVkID0gaGxzLmNvbmZpZy5lbWVFbmFibGVkO1xuXG4gICAgdGhpcy5fcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzID0gaGxzLmNvbmZpZy5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jO1xuXG4gICAgdGhpcy5fbWVkaWFLZXlzTGlzdCA9IFtdO1xuICAgIHRoaXMuX21lZGlhID0gbnVsbDtcblxuICAgIHRoaXMuX2hhc1NldE1lZGlhS2V5cyA9IGZhbHNlO1xuICAgIHRoaXMuX2lzTWVkaWFFbmNyeXB0ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVN5c3RlbSBJZGVudGlmaWVyIGZvciB0aGUga2V5LXN5c3RlbSwgc2VlIGBLZXlTeXN0ZW1zYCBlbnVtXG4gICAgICogQHJldHVybnMge3N0cmluZ30gTGljZW5zZSBzZXJ2ZXIgVVJMIGZvciBrZXktc3lzdGVtIChpZiBhbnkgY29uZmlndXJlZCwgb3RoZXJ3aXNlIGNhdXNlcyBlcnJvcilcbiAgICAgKi9cbiAgZ2V0TGljZW5zZVNlcnZlclVybCAoa2V5U3lzdGVtKSB7XG4gICAgbGV0IHVybDtcbiAgICBzd2l0Y2ggKGtleVN5c3RlbSkge1xuICAgIGNhc2UgS2V5U3lzdGVtcy5XSURFVklORTpcbiAgICAgIHVybCA9IHRoaXMuX3dpZGV2aW5lTGljZW5zZVVybDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB1cmwgPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihgTm8gbGljZW5zZSBzZXJ2ZXIgVVJMIGNvbmZpZ3VyZWQgZm9yIGtleS1zeXN0ZW0gXCIke2tleVN5c3RlbX1cImApO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgLyoqXG4gICAgICogUmVxdWVzdHMgYWNjZXNzIG9iamVjdCBhbmQgYWRkcyBpdCB0byBvdXIgbGlzdCB1cG9uIHN1Y2Nlc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlTeXN0ZW0gU3lzdGVtIElEIChzZWUgYEtleVN5c3RlbXNgKVxuICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXVkaW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCBhdWRpbyBjb2RlY3MgdG8gc3VwcG9ydFxuICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdmlkZW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCB2aWRlbyBjb2RlY3MgdG8gc3VwcG9ydFxuICAgICAqL1xuICBfYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyAoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MpIHtcbiAgICAvLyBUT0RPOiBhZGQgb3RoZXIgRFJNIFwib3B0aW9uc1wiXG5cbiAgICBjb25zdCBtZWRpYUtleVN5c3RlbUNvbmZpZ3MgPSBnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKTtcblxuICAgIGlmICghbWVkaWFLZXlTeXN0ZW1Db25maWdzKSB7XG4gICAgICBsb2dnZXIud2FybignQ2FuIG5vdCBjcmVhdGUgY29uZmlnIGZvciBrZXktc3lzdGVtIChtYXliZSBiZWNhdXNlIHBsYXRmb3JtIGlzIG5vdCBzdXBwb3J0ZWQpOicsIGtleVN5c3RlbSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9nZ2VyLmxvZygnUmVxdWVzdGluZyBlbmNyeXB0ZWQgbWVkaWEga2V5LXN5c3RlbSBhY2Nlc3MnKTtcblxuICAgIC8vIGV4cGVjdGluZyBpbnRlcmZhY2UgbGlrZSB3aW5kb3cubmF2aWdhdG9yLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc1xuICAgIHRoaXMucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbSwgbWVkaWFLZXlTeXN0ZW1Db25maWdzKVxuICAgICAgLnRoZW4oKG1lZGlhS2V5U3lzdGVtQWNjZXNzKSA9PiB7XG4gICAgICAgIHRoaXMuX29uTWVkaWFLZXlTeXN0ZW1BY2Nlc3NPYnRhaW5lZChrZXlTeXN0ZW0sIG1lZGlhS2V5U3lzdGVtQWNjZXNzKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBvYnRhaW4ga2V5LXN5c3RlbSBcIiR7a2V5U3lzdGVtfVwiIGFjY2VzczpgLCBlcnIpO1xuICAgICAgfSk7XG4gIH1cblxuICBnZXQgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzICgpIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgZnVuY3Rpb24gY29uZmlndXJlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3M7XG4gIH1cblxuICAvKipcbiAgICAgKiBIYW5kbGVzIG9idGFpbmluZyBhY2Nlc3MgdG8gYSBrZXktc3lzdGVtXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5U3lzdGVtXG4gICAgICogQHBhcmFtIHtNZWRpYUtleVN5c3RlbUFjY2Vzc30gbWVkaWFLZXlTeXN0ZW1BY2Nlc3MgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhS2V5U3lzdGVtQWNjZXNzXG4gICAgICovXG4gIF9vbk1lZGlhS2V5U3lzdGVtQWNjZXNzT2J0YWluZWQgKGtleVN5c3RlbSwgbWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICBsb2dnZXIubG9nKGBBY2Nlc3MgZm9yIGtleS1zeXN0ZW0gXCIke2tleVN5c3RlbX1cIiBvYnRhaW5lZGApO1xuXG4gICAgY29uc3QgbWVkaWFLZXlzTGlzdEl0ZW0gPSB7XG4gICAgICBtZWRpYUtleXM6IG51bGwsXG4gICAgICBtZWRpYUtleXNTZXNzaW9uOiBudWxsLFxuICAgICAgbWVkaWFLZXlzU2Vzc2lvbkluaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgIG1lZGlhS2V5U3lzdGVtQWNjZXNzOiBtZWRpYUtleVN5c3RlbUFjY2VzcyxcbiAgICAgIG1lZGlhS2V5U3lzdGVtRG9tYWluOiBrZXlTeXN0ZW1cbiAgICB9O1xuXG4gICAgdGhpcy5fbWVkaWFLZXlzTGlzdC5wdXNoKG1lZGlhS2V5c0xpc3RJdGVtKTtcblxuICAgIG1lZGlhS2V5U3lzdGVtQWNjZXNzLmNyZWF0ZU1lZGlhS2V5cygpXG4gICAgICAudGhlbigobWVkaWFLZXlzKSA9PiB7XG4gICAgICAgIG1lZGlhS2V5c0xpc3RJdGVtLm1lZGlhS2V5cyA9IG1lZGlhS2V5cztcblxuICAgICAgICBsb2dnZXIubG9nKGBNZWRpYS1rZXlzIGNyZWF0ZWQgZm9yIGtleS1zeXN0ZW0gXCIke2tleVN5c3RlbX1cImApO1xuXG4gICAgICAgIHRoaXMuX29uTWVkaWFLZXlzQ3JlYXRlZCgpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBtZWRpYS1rZXlzOicsIGVycik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIEhhbmRsZXMga2V5LWNyZWF0aW9uIChyZXByZXNlbnRzIGFjY2VzcyB0byBDRE0pLiBXZSBhcmUgZ29pbmcgdG8gY3JlYXRlIGtleS1zZXNzaW9ucyB1cG9uIHRoaXNcbiAgICAgKiBmb3IgYWxsIGV4aXN0aW5nIGtleXMgd2hlcmUgbm8gc2Vzc2lvbiBleGlzdHMgeWV0LlxuICAgICAqL1xuICBfb25NZWRpYUtleXNDcmVhdGVkICgpIHtcbiAgICAvLyBjaGVjayBmb3IgYWxsIGtleS1saXN0IGl0ZW1zIGlmIGEgc2Vzc2lvbiBleGlzdHMsIG90aGVyd2lzZSwgY3JlYXRlIG9uZVxuICAgIHRoaXMuX21lZGlhS2V5c0xpc3QuZm9yRWFjaCgobWVkaWFLZXlzTGlzdEl0ZW0pID0+IHtcbiAgICAgIGlmICghbWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbikge1xuICAgICAgICBtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uID0gbWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzLmNyZWF0ZVNlc3Npb24oKTtcbiAgICAgICAgdGhpcy5fb25OZXdNZWRpYUtleVNlc3Npb24obWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5U2Vzc2lvblxuICAgICAqL1xuICBfb25OZXdNZWRpYUtleVNlc3Npb24gKGtleVNlc3Npb24pIHtcbiAgICBsb2dnZXIubG9nKGBOZXcga2V5LXN5c3RlbSBzZXNzaW9uICR7a2V5U2Vzc2lvbi5zZXNzaW9uSWR9YCk7XG5cbiAgICBrZXlTZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX29uS2V5U2Vzc2lvbk1lc3NhZ2Uoa2V5U2Vzc2lvbiwgZXZlbnQubWVzc2FnZSk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG5cbiAgX29uS2V5U2Vzc2lvbk1lc3NhZ2UgKGtleVNlc3Npb24sIG1lc3NhZ2UpIHtcbiAgICBsb2dnZXIubG9nKCdHb3QgRU1FIG1lc3NhZ2UgZXZlbnQsIGNyZWF0aW5nIGxpY2Vuc2UgcmVxdWVzdCcpO1xuXG4gICAgdGhpcy5fcmVxdWVzdExpY2Vuc2UobWVzc2FnZSwgKGRhdGEpID0+IHtcbiAgICAgIGxvZ2dlci5sb2coJ1JlY2VpdmVkIGxpY2Vuc2UgZGF0YSwgdXBkYXRpbmcga2V5LXNlc3Npb24nKTtcbiAgICAgIGtleVNlc3Npb24udXBkYXRlKGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgX29uTWVkaWFFbmNyeXB0ZWQgKGluaXREYXRhVHlwZSwgaW5pdERhdGEpIHtcbiAgICBsb2dnZXIubG9nKGBNZWRpYSBpcyBlbmNyeXB0ZWQgdXNpbmcgXCIke2luaXREYXRhVHlwZX1cIiBpbml0IGRhdGEgdHlwZWApO1xuXG4gICAgdGhpcy5faXNNZWRpYUVuY3J5cHRlZCA9IHRydWU7XG4gICAgdGhpcy5fbWVkaWFFbmNyeXB0aW9uSW5pdERhdGFUeXBlID0gaW5pdERhdGFUeXBlO1xuICAgIHRoaXMuX21lZGlhRW5jcnlwdGlvbkluaXREYXRhID0gaW5pdERhdGE7XG5cbiAgICB0aGlzLl9hdHRlbXB0U2V0TWVkaWFLZXlzKCk7XG4gICAgdGhpcy5fZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24oKTtcbiAgfVxuXG4gIF9hdHRlbXB0U2V0TWVkaWFLZXlzICgpIHtcbiAgICBpZiAoIXRoaXMuX2hhc1NldE1lZGlhS2V5cykge1xuICAgICAgLy8gRklYTUU6IHNlZSBpZiB3ZSBjYW4vd2FudC9uZWVkLXRvIHJlYWxseSB0byBkZWFsIHdpdGggc2V2ZXJhbCBwb3RlbnRpYWwga2V5LXNlc3Npb25zP1xuICAgICAgY29uc3Qga2V5c0xpc3RJdGVtID0gdGhpcy5fbWVkaWFLZXlzTGlzdFswXTtcbiAgICAgIGlmICgha2V5c0xpc3RJdGVtIHx8ICFrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignRmF0YWw6IE1lZGlhIGlzIGVuY3J5cHRlZCBidXQgbm8gQ0RNIGFjY2VzcyBvciBubyBrZXlzIGhhdmUgYmVlbiBvYnRhaW5lZCB5ZXQnKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19LRVlTLFxuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvZ2dlci5sb2coJ1NldHRpbmcga2V5cyBmb3IgZW5jcnlwdGVkIG1lZGlhJyk7XG5cbiAgICAgIHRoaXMuX21lZGlhLnNldE1lZGlhS2V5cyhrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzKTtcbiAgICAgIHRoaXMuX2hhc1NldE1lZGlhS2V5cyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgX2dlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uICgpIHtcbiAgICAvLyBGSVhNRTogc2VlIGlmIHdlIGNhbi93YW50L25lZWQtdG8gcmVhbGx5IHRvIGRlYWwgd2l0aCBzZXZlcmFsIHBvdGVudGlhbCBrZXktc2Vzc2lvbnM/XG4gICAgY29uc3Qga2V5c0xpc3RJdGVtID0gdGhpcy5fbWVkaWFLZXlzTGlzdFswXTtcbiAgICBpZiAoIWtleXNMaXN0SXRlbSkge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYXRhbDogTWVkaWEgaXMgZW5jcnlwdGVkIGJ1dCBub3QgYW55IGtleS1zeXN0ZW0gYWNjZXNzIGhhcyBiZWVuIG9idGFpbmVkIHlldCcpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX0FDQ0VTUyxcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbkluaXRpYWxpemVkKSB7XG4gICAgICBsb2dnZXIud2FybignS2V5LVNlc3Npb24gYWxyZWFkeSBpbml0aWFsaXplZCBidXQgcmVxdWVzdGVkIGFnYWluJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qga2V5U2Vzc2lvbiA9IGtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uO1xuICAgIGlmICgha2V5U2Vzc2lvbikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYXRhbDogTWVkaWEgaXMgZW5jcnlwdGVkIGJ1dCBubyBrZXktc2Vzc2lvbiBleGlzdGluZycpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX1NFU1NJT04sXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBpbml0RGF0YVR5cGUgPSB0aGlzLl9tZWRpYUVuY3J5cHRpb25Jbml0RGF0YVR5cGU7XG4gICAgY29uc3QgaW5pdERhdGEgPSB0aGlzLl9tZWRpYUVuY3J5cHRpb25Jbml0RGF0YTtcblxuICAgIGxvZ2dlci5sb2coYEdlbmVyYXRpbmcga2V5LXNlc3Npb24gcmVxdWVzdCBmb3IgXCIke2luaXREYXRhVHlwZX1cIiBpbml0IGRhdGEgdHlwZWApO1xuXG4gICAga2V5c0xpc3RJdGVtLm1lZGlhS2V5c1Nlc3Npb25Jbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICBrZXlTZXNzaW9uLmdlbmVyYXRlUmVxdWVzdChpbml0RGF0YVR5cGUsIGluaXREYXRhKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ0tleS1zZXNzaW9uIGdlbmVyYXRpb24gc3VjY2VlZGVkJyk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIGtleS1zZXNzaW9uIHJlcXVlc3Q6JywgZXJyKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19TRVNTSU9OLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBMaWNlbnNlIHNlcnZlciBVUkxcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBrZXlNZXNzYWdlIE1lc3NhZ2UgZGF0YSBpc3N1ZWQgYnkga2V5LXN5c3RlbVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCB3aGVuIFhIUiBoYXMgc3VjY2VlZGVkXG4gICAgICogQHJldHVybnMge1hNTEh0dHBSZXF1ZXN0fSBVbnNlbnQgKGJ1dCBvcGVuZWQgc3RhdGUpIFhIUiBvYmplY3RcbiAgICAgKi9cbiAgX2NyZWF0ZUxpY2Vuc2VYaHIgKHVybCwga2V5TWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBjb25zdCBsaWNlbnNlWGhyU2V0dXAgPSB0aGlzLl9saWNlbnNlWGhyU2V0dXA7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKGxpY2Vuc2VYaHJTZXR1cCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxpY2Vuc2VYaHJTZXR1cCh4aHIsIHVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBsZXQncyB0cnkgdG8gb3BlbiBiZWZvcmUgcnVubmluZyBzZXR1cFxuICAgICAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgICBsaWNlbnNlWGhyU2V0dXAoeGhyLCB1cmwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBpZiBsaWNlbnNlWGhyU2V0dXAgZGlkIG5vdCB5ZXQgY2FsbCBvcGVuLCBsZXQncyBkbyBpdCBub3dcbiAgICAgIGlmICgheGhyLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgeGhyLm9wZW4oJ1BPU1QnLCB1cmwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElFMTEgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiB4aHIub3BlbiBpZiBhdHRlbXB0aW5nIHRvIGFjY2VzcyBhbiBIVFRQIHJlc291cmNlIG92ZXIgSFRUUFNcbiAgICAgIGxvZ2dlci5lcnJvcignRXJyb3Igc2V0dGluZyB1cCBrZXktc3lzdGVtIGxpY2Vuc2UgWEhSJywgZSk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCxcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPVxuICAgICAgICB0aGlzLl9vbkxpY2Vuc2VSZXF1ZXN0UmVhZHlTdGFnZUNoYW5nZS5iaW5kKHRoaXMsIHhociwgdXJsLCBrZXlNZXNzYWdlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHhocjtcbiAgfVxuXG4gIC8qKlxuICAgICAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R9IHhoclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgTGljZW5zZSBzZXJ2ZXIgVVJMXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0ga2V5TWVzc2FnZSBNZXNzYWdlIGRhdGEgaXNzdWVkIGJ5IGtleS1zeXN0ZW1cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgd2hlbiBYSFIgaGFzIHN1Y2NlZWRlZFxuICAgICAqXG4gICAgICovXG4gIF9vbkxpY2Vuc2VSZXF1ZXN0UmVhZHlTdGFnZUNoYW5nZSAoeGhyLCB1cmwsIGtleU1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgc3dpdGNoICh4aHIucmVhZHlTdGF0ZSkge1xuICAgIGNhc2UgNDpcbiAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgPSAwO1xuICAgICAgICBsb2dnZXIubG9nKCdMaWNlbnNlIHJlcXVlc3Qgc3VjY2VlZGVkJyk7XG4gICAgICAgIGNhbGxiYWNrKHhoci5yZXNwb25zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIuZXJyb3IoYExpY2Vuc2UgUmVxdWVzdCBYSFIgZmFpbGVkICgke3VybH0pLiBTdGF0dXM6ICR7eGhyLnN0YXR1c30gKCR7eGhyLnN0YXR1c1RleHR9KWApO1xuXG4gICAgICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50Kys7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA8PSBNQVhfTElDRU5TRV9SRVFVRVNUX0ZBSUxVUkVTKSB7XG4gICAgICAgICAgY29uc3QgYXR0ZW1wdHNMZWZ0ID0gTUFYX0xJQ0VOU0VfUkVRVUVTVF9GQUlMVVJFUyAtIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ICsgMTtcbiAgICAgICAgICBsb2dnZXIud2FybihgUmV0cnlpbmcgbGljZW5zZSByZXF1ZXN0LCAke2F0dGVtcHRzTGVmdH0gYXR0ZW1wdHMgbGVmdGApO1xuICAgICAgICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlKGtleU1lc3NhZ2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0ga2V5c0xpc3RJdGVtXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0ga2V5TWVzc2FnZVxuICAgICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gQ2hhbGxlbmdlIGRhdGEgcG9zdGVkIHRvIGxpY2Vuc2Ugc2VydmVyXG4gICAgICovXG4gIF9nZW5lcmF0ZUxpY2Vuc2VSZXF1ZXN0Q2hhbGxlbmdlIChrZXlzTGlzdEl0ZW0sIGtleU1lc3NhZ2UpIHtcbiAgICBsZXQgY2hhbGxlbmdlO1xuXG4gICAgaWYgKGtleXNMaXN0SXRlbS5tZWRpYUtleVN5c3RlbURvbWFpbiA9PT0gS2V5U3lzdGVtcy5QTEFZUkVBRFkpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignUGxheVJlYWR5IGlzIG5vdCBzdXBwb3J0ZWQgKHlldCknKTtcblxuICAgICAgLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0RWRnZS9EZW1vcy9ibG9iL21hc3Rlci9lbWUvc2NyaXB0cy9kZW1vLmpzXG4gICAgICAvKlxuICAgICAgICBpZiAodGhpcy5saWNlbnNlVHlwZSAhPT0gdGhpcy5MSUNFTlNFX1RZUEVfV0lERVZJTkUpIHtcbiAgICAgICAgICAgIC8vIEZvciBQbGF5UmVhZHkgQ0RNcywgd2UgbmVlZCB0byBkaWcgdGhlIENoYWxsZW5nZSBvdXQgb2YgdGhlIFhNTC5cbiAgICAgICAgICAgIHZhciBrZXlNZXNzYWdlWG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShrZXlNZXNzYWdlKSksICdhcHBsaWNhdGlvbi94bWwnKTtcbiAgICAgICAgICAgIGlmIChrZXlNZXNzYWdlWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdDaGFsbGVuZ2UnKVswXSkge1xuICAgICAgICAgICAgICAgIGNoYWxsZW5nZSA9IGF0b2Ioa2V5TWVzc2FnZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnQ2hhbGxlbmdlJylbMF0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQ2Fubm90IGZpbmQgPENoYWxsZW5nZT4gaW4ga2V5IG1lc3NhZ2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhlYWRlck5hbWVzID0ga2V5TWVzc2FnZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbmFtZScpO1xuICAgICAgICAgICAgdmFyIGhlYWRlclZhbHVlcyA9IGtleU1lc3NhZ2VYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZhbHVlJyk7XG4gICAgICAgICAgICBpZiAoaGVhZGVyTmFtZXMubGVuZ3RoICE9PSBoZWFkZXJWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ01pc21hdGNoZWQgaGVhZGVyIDxuYW1lPi88dmFsdWU+IHBhaXIgaW4ga2V5IG1lc3NhZ2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkZXJOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlck5hbWVzW2ldLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlLCBoZWFkZXJWYWx1ZXNbaV0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICovXG4gICAgfSBlbHNlIGlmIChrZXlzTGlzdEl0ZW0ubWVkaWFLZXlTeXN0ZW1Eb21haW4gPT09IEtleVN5c3RlbXMuV0lERVZJTkUpIHtcbiAgICAgIC8vIEZvciBXaWRldmluZSBDRE1zLCB0aGUgY2hhbGxlbmdlIGlzIHRoZSBrZXlNZXNzYWdlLlxuICAgICAgY2hhbGxlbmdlID0ga2V5TWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmVycm9yKCdVbnN1cHBvcnRlZCBrZXktc3lzdGVtOicsIGtleXNMaXN0SXRlbS5tZWRpYUtleVN5c3RlbURvbWFpbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYWxsZW5nZTtcbiAgfVxuXG4gIF9yZXF1ZXN0TGljZW5zZSAoa2V5TWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBsb2dnZXIubG9nKCdSZXF1ZXN0aW5nIGNvbnRlbnQgbGljZW5zZSBmb3Iga2V5LXN5c3RlbScpO1xuXG4gICAgY29uc3Qga2V5c0xpc3RJdGVtID0gdGhpcy5fbWVkaWFLZXlzTGlzdFswXTtcbiAgICBpZiAoIWtleXNMaXN0SXRlbSkge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYXRhbCBlcnJvcjogTWVkaWEgaXMgZW5jcnlwdGVkIGJ1dCBubyBrZXktc3lzdGVtIGFjY2VzcyBoYXMgYmVlbiBvYnRhaW5lZCB5ZXQnKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19BQ0NFU1MsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB1cmwgPSB0aGlzLmdldExpY2Vuc2VTZXJ2ZXJVcmwoa2V5c0xpc3RJdGVtLm1lZGlhS2V5U3lzdGVtRG9tYWluKTtcbiAgICBjb25zdCB4aHIgPSB0aGlzLl9jcmVhdGVMaWNlbnNlWGhyKHVybCwga2V5TWVzc2FnZSwgY2FsbGJhY2spO1xuXG4gICAgbG9nZ2VyLmxvZyhgU2VuZGluZyBsaWNlbnNlIHJlcXVlc3QgdG8gVVJMOiAke3VybH1gKTtcblxuICAgIHhoci5zZW5kKHRoaXMuX2dlbmVyYXRlTGljZW5zZVJlcXVlc3RDaGFsbGVuZ2Uoa2V5c0xpc3RJdGVtLCBrZXlNZXNzYWdlKSk7XG4gIH1cblxuICBvbk1lZGlhQXR0YWNoZWQgKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuX2VtZUVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZWRpYSA9IGRhdGEubWVkaWE7XG5cbiAgICAvLyBrZWVwIHJlZmVyZW5jZSBvZiBtZWRpYVxuICAgIHRoaXMuX21lZGlhID0gbWVkaWE7XG5cbiAgICAvLyBGSVhNRTogYWxzbyBoYW5kbGUgZGV0YWNoaW5nIG1lZGlhICFcblxuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VuY3J5cHRlZCcsIChlKSA9PiB7XG4gICAgICB0aGlzLl9vbk1lZGlhRW5jcnlwdGVkKGUuaW5pdERhdGFUeXBlLCBlLmluaXREYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG9uTWFuaWZlc3RQYXJzZWQgKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuX2VtZUVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhdWRpb0NvZGVjcyA9IGRhdGEubGV2ZWxzLm1hcCgobGV2ZWwpID0+IGxldmVsLmF1ZGlvQ29kZWMpO1xuICAgIGNvbnN0IHZpZGVvQ29kZWNzID0gZGF0YS5sZXZlbHMubWFwKChsZXZlbCkgPT4gbGV2ZWwudmlkZW9Db2RlYyk7XG5cbiAgICB0aGlzLl9hdHRlbXB0S2V5U3lzdGVtQWNjZXNzKEtleVN5c3RlbXMuV0lERVZJTkUsIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRU1FQ29udHJvbGxlcjtcbiIsIi8qXG4gKiBGUFMgQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gd2luZG93O1xuXG5jbGFzcyBGUFNDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscykge1xuICAgIHN1cGVyKGhscywgRXZlbnQuTUVESUFfQVRUQUNISU5HKTtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgIH1cblxuICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IGZhbHNlO1xuICB9XG5cbiAgb25NZWRpYUF0dGFjaGluZyAoZGF0YSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBpZiAoY29uZmlnLmNhcExldmVsT25GUFNEcm9wKSB7XG4gICAgICBjb25zdCB2aWRlbyA9IHRoaXMudmlkZW8gPSBkYXRhLm1lZGlhIGluc3RhbmNlb2Ygd2luZG93LkhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgdmlkZW8uZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrRlBTSW50ZXJ2YWwuYmluZCh0aGlzKSwgY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kKTtcbiAgICB9XG4gIH1cblxuICBjaGVja0ZQUyAodmlkZW8sIGRlY29kZWRGcmFtZXMsIGRyb3BwZWRGcmFtZXMpIHtcbiAgICBsZXQgY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAoZGVjb2RlZEZyYW1lcykge1xuICAgICAgaWYgKHRoaXMubGFzdFRpbWUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRQZXJpb2QgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWUsXG4gICAgICAgICAgY3VycmVudERyb3BwZWQgPSBkcm9wcGVkRnJhbWVzIC0gdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyxcbiAgICAgICAgICBjdXJyZW50RGVjb2RlZCA9IGRlY29kZWRGcmFtZXMgLSB0aGlzLmxhc3REZWNvZGVkRnJhbWVzLFxuICAgICAgICAgIGRyb3BwZWRGUFMgPSAxMDAwICogY3VycmVudERyb3BwZWQgLyBjdXJyZW50UGVyaW9kLFxuICAgICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUFNfRFJPUCwgeyBjdXJyZW50RHJvcHBlZDogY3VycmVudERyb3BwZWQsIGN1cnJlbnREZWNvZGVkOiBjdXJyZW50RGVjb2RlZCwgdG90YWxEcm9wcGVkRnJhbWVzOiBkcm9wcGVkRnJhbWVzIH0pO1xuICAgICAgICBpZiAoZHJvcHBlZEZQUyA+IDApIHtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdjaGVja0ZQUyA6IGRyb3BwZWRGUFMvZGVjb2RlZEZQUzonICsgZHJvcHBlZEZQUy8oMTAwMCAqIGN1cnJlbnREZWNvZGVkIC8gY3VycmVudFBlcmlvZCkpO1xuICAgICAgICAgIGlmIChjdXJyZW50RHJvcHBlZCA+IGhscy5jb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQgKiBjdXJyZW50RGVjb2RlZCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRMZXZlbCA9IGhscy5jdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICBsb2dnZXIud2FybignZHJvcCBGUFMgcmF0aW8gZ3JlYXRlciB0aGFuIG1heCBhbGxvd2VkIHZhbHVlIGZvciBjdXJyZW50TGV2ZWw6ICcgKyBjdXJyZW50TGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA+IDAgJiYgKGhscy5hdXRvTGV2ZWxDYXBwaW5nID09PSAtMSB8fCBobHMuYXV0b0xldmVsQ2FwcGluZyA+PSBjdXJyZW50TGV2ZWwpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbCAtIDE7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHsgbGV2ZWw6IGN1cnJlbnRMZXZlbCwgZHJvcHBlZExldmVsOiBobHMuY3VycmVudExldmVsIH0pO1xuICAgICAgICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IGN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgICAgaGxzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICB0aGlzLmxhc3REcm9wcGVkRnJhbWVzID0gZHJvcHBlZEZyYW1lcztcbiAgICAgIHRoaXMubGFzdERlY29kZWRGcmFtZXMgPSBkZWNvZGVkRnJhbWVzO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrRlBTSW50ZXJ2YWwgKCkge1xuICAgIGNvbnN0IHZpZGVvID0gdGhpcy52aWRlbztcbiAgICBpZiAodmlkZW8pIHtcbiAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUpIHtcbiAgICAgICAgbGV0IHZpZGVvUGxheWJhY2tRdWFsaXR5ID0gdmlkZW8uZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkoKTtcbiAgICAgICAgdGhpcy5jaGVja0ZQUyh2aWRlbywgdmlkZW9QbGF5YmFja1F1YWxpdHkudG90YWxWaWRlb0ZyYW1lcywgdmlkZW9QbGF5YmFja1F1YWxpdHkuZHJvcHBlZFZpZGVvRnJhbWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvLndlYmtpdERlY29kZWRGcmFtZUNvdW50LCB2aWRlby53ZWJraXREcm9wcGVkRnJhbWVDb3VudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZQU0NvbnRyb2xsZXI7XG4iLCJpbXBvcnQgQmluYXJ5U2VhcmNoIGZyb20gJy4uL3V0aWxzL2JpbmFyeS1zZWFyY2gnO1xuXG4vKipcbiAqIFJldHVybnMgZmlyc3QgZnJhZ21lbnQgd2hvc2UgZW5kUGR0IHZhbHVlIGV4Y2VlZHMgdGhlIGdpdmVuIFBEVC5cbiAqIEBwYXJhbSB7QXJyYXk8RnJhZ21lbnQ+fSBmcmFnbWVudHMgLSBUaGUgYXJyYXkgb2YgY2FuZGlkYXRlIGZyYWdtZW50c1xuICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gW1BEVFZhbHVlID0gbnVsbF0gLSBUaGUgUERUIHZhbHVlIHdoaWNoIG11c3QgYmUgZXhjZWVkZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0L2VuZCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMgeyp8bnVsbH0gZnJhZ21lbnQgLSBUaGUgYmVzdCBtYXRjaGluZyBmcmFnbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEZyYWdtZW50QnlQRFQgKGZyYWdtZW50cywgUERUVmFsdWUsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZyYWdtZW50cykgfHwgIWZyYWdtZW50cy5sZW5ndGggfHwgIU51bWJlci5pc0Zpbml0ZShQRFRWYWx1ZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGlmIGxlc3MgdGhhbiBzdGFydFxuICBpZiAoUERUVmFsdWUgPCBmcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoUERUVmFsdWUgPj0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXS5lbmRQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHx8IDA7XG4gIGZvciAobGV0IHNlZyA9IDA7IHNlZyA8IGZyYWdtZW50cy5sZW5ndGg7ICsrc2VnKSB7XG4gICAgbGV0IGZyYWcgPSBmcmFnbWVudHNbc2VnXTtcbiAgICBpZiAocGR0V2l0aGluVG9sZXJhbmNlVGVzdChQRFRWYWx1ZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZykpIHtcbiAgICAgIHJldHVybiBmcmFnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEZpbmRzIGEgZnJhZ21lbnQgYmFzZWQgb24gdGhlIFNOIG9mIHRoZSBwcmV2aW91cyBmcmFnbWVudDsgb3IgYmFzZWQgb24gdGhlIG5lZWRzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAqIFRoaXMgbWV0aG9kIGNvbXBlbnNhdGVzIGZvciBzbWFsbCBidWZmZXIgZ2FwcyBieSBhcHBseWluZyBhIHRvbGVyYW5jZSB0byB0aGUgc3RhcnQgb2YgYW55IGNhbmRpZGF0ZSBmcmFnbWVudCwgdGh1c1xuICogYnJlYWtpbmcgYW55IHRyYXBzIHdoaWNoIHdvdWxkIGNhdXNlIHRoZSBzYW1lIGZyYWdtZW50IHRvIGJlIGNvbnRpbnVvdXNseSBzZWxlY3RlZCB3aXRoaW4gYSBzbWFsbCByYW5nZS5cbiAqIEBwYXJhbSB7Kn0gZnJhZ1ByZXZpb3VzIC0gVGhlIGxhc3QgZnJhZyBzdWNjZXNzZnVsbHkgYXBwZW5kZWRcbiAqIEBwYXJhbSB7QXJyYXk8RnJhZ21lbnQ+fSBmcmFnbWVudHMgLSBUaGUgYXJyYXkgb2YgY2FuZGlkYXRlIGZyYWdtZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IFtidWZmZXJFbmQgPSAwXSAtIFRoZSBlbmQgb2YgdGhlIGNvbnRpZ3VvdXMgYnVmZmVyZWQgcmFuZ2UgdGhlIHBsYXloZWFkIGlzIGN1cnJlbnRseSB3aXRoaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0L2VuZCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMgeyp9IGZvdW5kRnJhZyAtIFRoZSBiZXN0IG1hdGNoaW5nIGZyYWdtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRnJhZ21lbnRCeVBUUyAoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCA9IDAsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwKSB7XG4gIGNvbnN0IGZyYWdOZXh0ID0gZnJhZ1ByZXZpb3VzID8gZnJhZ21lbnRzW2ZyYWdQcmV2aW91cy5zbiAtIGZyYWdtZW50c1swXS5zbiArIDFdIDogbnVsbDtcbiAgLy8gUHJlZmVyIHRoZSBuZXh0IGZyYWdtZW50IGlmIGl0J3Mgd2l0aGluIHRvbGVyYW5jZVxuICBpZiAoZnJhZ05leHQgJiYgIWZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWdOZXh0KSkge1xuICAgIHJldHVybiBmcmFnTmV4dDtcbiAgfVxuICByZXR1cm4gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdC5iaW5kKG51bGwsIGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkpO1xufVxuXG4vKipcbiAqIFRoZSB0ZXN0IGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGZpbmRGcmFnbWVudEJ5U24ncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXG4gKiBAcGFyYW0geyp9IGNhbmRpZGF0ZSAtIFRoZSBmcmFnbWVudCB0byB0ZXN0XG4gKiBAcGFyYW0ge251bWJlcn0gW2J1ZmZlckVuZCA9IDBdIC0gVGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5IHdpdGhpblxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gMCBpZiBpdCBtYXRjaGVzLCAxIGlmIHRvbyBsb3csIC0xIGlmIHRvbyBoaWdoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QgKGJ1ZmZlckVuZCA9IDAsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwLCBjYW5kaWRhdGUpIHtcbiAgLy8gb2Zmc2V0IHNob3VsZCBiZSB3aXRoaW4gZnJhZ21lbnQgYm91bmRhcnkgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZVxuICAvLyB0aGlzIGlzIHRvIGNvcGUgd2l0aCBzaXR1YXRpb25zIGxpa2VcbiAgLy8gYnVmZmVyRW5kID0gOS45OTFcbiAgLy8gZnJhZ1vDmF0gOiBbMCwxMF1cbiAgLy8gZnJhZ1sxXSA6IFsxMCwyMF1cbiAgLy8gYnVmZmVyRW5kIGlzIHdpdGhpbiBmcmFnWzBdIHJhbmdlIC4uLiBhbHRob3VnaCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgaXMgdG8gcmV0dXJuIGZyYWdbMV0gaGVyZVxuICAvLyAgICAgICAgICAgICAgZnJhZyBzdGFydCAgICAgICAgICAgICAgIGZyYWcgc3RhcnQrZHVyYXRpb25cbiAgLy8gICAgICAgICAgICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gIC8vICAgICAgICAgICAgICA8LS0tPiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tPlxuICAvLyAgLi4uLS0tLS0tLS0+PC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPjwtLS0tLS0tLS0uLi4uXG4gIC8vIHByZXZpb3VzIGZyYWcgICAgICAgICBtYXRjaGluZyBmcmFnbWVudCAgICAgICAgIG5leHQgZnJhZ1xuICAvLyAgcmV0dXJuIC0xICAgICAgICAgICAgIHJldHVybiAwICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAvLyBsb2dnZXIubG9nKGBsZXZlbC9zbi9zdGFydC9lbmQvYnVmRW5kOiR7bGV2ZWx9LyR7Y2FuZGlkYXRlLnNufS8ke2NhbmRpZGF0ZS5zdGFydH0vJHsoY2FuZGlkYXRlLnN0YXJ0K2NhbmRpZGF0ZS5kdXJhdGlvbil9LyR7YnVmZmVyRW5kfWApO1xuICAvLyBTZXQgdGhlIGxvb2t1cCB0b2xlcmFuY2UgdG8gYmUgc21hbGwgZW5vdWdoIHRvIGRldGVjdCB0aGUgY3VycmVudCBzZWdtZW50IC0gZW5zdXJlcyB3ZSBkb24ndCBza2lwIG92ZXIgdmVyeSBzbWFsbCBzZWdtZW50c1xuICBsZXQgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uICsgKGNhbmRpZGF0ZS5kZWx0YVBUUyA/IGNhbmRpZGF0ZS5kZWx0YVBUUyA6IDApKTtcbiAgaWYgKGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA8PSBidWZmZXJFbmQpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChjYW5kaWRhdGUuc3RhcnQgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBidWZmZXJFbmQgJiYgY2FuZGlkYXRlLnN0YXJ0KSB7XG4gICAgLy8gaWYgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB3aWxsIGhhdmUgbmVnYXRpdmUgdmFsdWUgdGhlbiBkb24ndCByZXR1cm4gLTEgZm9yIGZpcnN0IGVsZW1lbnRcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBUaGUgdGVzdCBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBmaW5kRnJhZ21lbnRCeVBkdCdzIEJpbmFyeVNlYXJjaCB0byBsb29rIGZvciB0aGUgYmVzdCBtYXRjaCB0byB0aGUgY3VycmVudCBidWZmZXIgY29uZGl0aW9ucy5cbiAqIFRoaXMgZnVuY3Rpb24gdGVzdHMgdGhlIGNhbmRpZGF0ZSdzIHByb2dyYW0gZGF0ZSB0aW1lIHZhbHVlcywgYXMgcmVwcmVzZW50ZWQgaW4gVW5peCB0aW1lXG4gKiBAcGFyYW0geyp9IGNhbmRpZGF0ZSAtIFRoZSBmcmFnbWVudCB0byB0ZXN0XG4gKiBAcGFyYW0ge251bWJlcn0gW3BkdEJ1ZmZlckVuZCA9IDBdIC0gVGhlIFVuaXggdGltZSByZXByZXNlbnRpbmcgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGNvbnRpZ3VvdXMsIGZhbHNlIG90aGVyd2lzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGR0V2l0aGluVG9sZXJhbmNlVGVzdCAocGR0QnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUpIHtcbiAgbGV0IGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA9IE1hdGgubWluKG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZS5kdXJhdGlvbiArIChjYW5kaWRhdGUuZGVsdGFQVFMgPyBjYW5kaWRhdGUuZGVsdGFQVFMgOiAwKSkgKiAxMDAwO1xuICByZXR1cm4gY2FuZGlkYXRlLmVuZFByb2dyYW1EYXRlVGltZSAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IHBkdEJ1ZmZlckVuZDtcbn1cbiIsImltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcblxuZXhwb3J0IGNvbnN0IEZyYWdtZW50U3RhdGUgPSB7XG4gIE5PVF9MT0FERUQ6ICdOT1RfTE9BREVEJyxcbiAgQVBQRU5ESU5HOiAnQVBQRU5ESU5HJyxcbiAgUEFSVElBTDogJ1BBUlRJQUwnLFxuICBPSzogJ09LJ1xufTtcblxuZXhwb3J0IGNsYXNzIEZyYWdtZW50VHJhY2tlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5CVUZGRVJfQVBQRU5ERUQsXG4gICAgICBFdmVudC5GUkFHX0JVRkZFUkVELFxuICAgICAgRXZlbnQuRlJBR19MT0FERURcbiAgICApO1xuXG4gICAgdGhpcy5idWZmZXJQYWRkaW5nID0gMC4yO1xuXG4gICAgdGhpcy5mcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMudGltZVJhbmdlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy50aW1lUmFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIEZyYWdtZW50IHRoYXQgbWF0Y2ggdGhlIHBvc2l0aW9uIGFuZCBsZXZlbFR5cGUuXG4gICAqIElmIG5vdCBmb3VuZCBhbnkgRnJhZ21lbnQsIHJldHVybiBudWxsXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblxuICAgKiBAcGFyYW0ge0xldmVsVHlwZX0gbGV2ZWxUeXBlXG4gICAqIEByZXR1cm5zIHtGcmFnbWVudHxudWxsfVxuICAgKi9cbiAgZ2V0QnVmZmVyZWRGcmFnIChwb3NpdGlvbiwgbGV2ZWxUeXBlKSB7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gdGhpcy5mcmFnbWVudHM7XG4gICAgY29uc3QgYnVmZmVyZWRGcmFncyA9IE9iamVjdC5rZXlzKGZyYWdtZW50cykuZmlsdGVyKGtleSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IGZyYWdtZW50c1trZXldO1xuICAgICAgaWYgKGZyYWdtZW50RW50aXR5LmJvZHkudHlwZSAhPT0gbGV2ZWxUeXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuICAgICAgcmV0dXJuIGZyYWcuc3RhcnRQVFMgPD0gcG9zaXRpb24gJiYgcG9zaXRpb24gPD0gZnJhZy5lbmRQVFM7XG4gICAgfSk7XG4gICAgaWYgKGJ1ZmZlcmVkRnJhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvcHVsbC8xNTQ1I2Rpc2N1c3Npb25fcjE2NjIyOTU2NlxuICAgICAgY29uc3QgYnVmZmVyZWRGcmFnS2V5ID0gYnVmZmVyZWRGcmFncy5wb3AoKTtcbiAgICAgIHJldHVybiBmcmFnbWVudHNbYnVmZmVyZWRGcmFnS2V5XS5ib2R5O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJ0aWFsIGZyYWdtZW50cyBlZmZlY3RlZCBieSBjb2RlZCBmcmFtZSBldmljdGlvbiB3aWxsIGJlIHJlbW92ZWRcbiAgICogVGhlIGJyb3dzZXIgd2lsbCB1bmxvYWQgcGFydHMgb2YgdGhlIGJ1ZmZlciB0byBmcmVlIHVwIG1lbW9yeSBmb3IgbmV3IGJ1ZmZlciBkYXRhXG4gICAqIEZyYWdtZW50cyB3aWxsIG5lZWQgdG8gYmUgcmVsb2FkZWQgd2hlbiB0aGUgYnVmZmVyIGlzIGZyZWVkIHVwLCByZW1vdmluZyBwYXJ0aWFsIGZyYWdtZW50cyB3aWxsIGFsbG93IHRoZW0gdG8gcmVsb2FkKHNpbmNlIHRoZXJlIG1pZ2h0IGJlIHBhcnRzIHRoYXQgYXJlIHN0aWxsIHBsYXlhYmxlKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZWxlbWVudGFyeVN0cmVhbSBUaGUgZWxlbWVudGFyeVN0cmVhbSBvZiBtZWRpYSB0aGlzIGlzIChlZy4gdmlkZW8vYXVkaW8pXG4gICAqIEBwYXJhbSB7VGltZVJhbmdlc30gdGltZVJhbmdlIFRpbWVSYW5nZSBvYmplY3QgZnJvbSBhIHNvdXJjZUJ1ZmZlclxuICAgKi9cbiAgZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyAoZWxlbWVudGFyeVN0cmVhbSwgdGltZVJhbmdlKSB7XG4gICAgbGV0IGZyYWdtZW50VGltZXMsIHRpbWU7XG4gICAgLy8gQ2hlY2sgaWYgYW55IGZsYWdnZWQgZnJhZ21lbnRzIGhhdmUgYmVlbiB1bmxvYWRlZFxuICAgIE9iamVjdC5rZXlzKHRoaXMuZnJhZ21lbnRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2tleV07XG4gICAgICBpZiAoZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3QgZXNEYXRhID0gZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICAgIGlmIChlc0RhdGEpIHtcbiAgICAgICAgICBmcmFnbWVudFRpbWVzID0gZXNEYXRhLnRpbWU7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFnbWVudFRpbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aW1lID0gZnJhZ21lbnRUaW1lc1tpXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNUaW1lQnVmZmVyZWQodGltZS5zdGFydFBUUywgdGltZS5lbmRQVFMsIHRpbWVSYW5nZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIC8vIFVucmVnaXN0ZXIgcGFydGlhbCBmcmFnbWVudCBhcyBpdCBuZWVkcyB0byBsb2FkIGFnYWluIHRvIGJlIHJldXNlZFxuICAgICAgICAgICAgICB0aGlzLnJlbW92ZUZyYWdtZW50KGZyYWdtZW50RW50aXR5LmJvZHkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGZyYWdtZW50IHBhc3NlZCBpbiBpcyBsb2FkZWQgaW4gdGhlIGJ1ZmZlciBwcm9wZXJseVxuICAgKiBQYXJ0aWFsbHkgbG9hZGVkIGZyYWdtZW50cyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmcmFnbWVudCBDaGVjayB0aGUgZnJhZ21lbnQgYWdhaW5zdCBhbGwgc291cmNlQnVmZmVycyBsb2FkZWRcbiAgICovXG4gIGRldGVjdFBhcnRpYWxGcmFnbWVudHMgKGZyYWdtZW50KSB7XG4gICAgbGV0IGZyYWdLZXkgPSB0aGlzLmdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICBsZXQgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICBpZiAoZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkID0gdHJ1ZTtcblxuICAgICAgT2JqZWN0LmtleXModGhpcy50aW1lUmFuZ2VzKS5mb3JFYWNoKGVsZW1lbnRhcnlTdHJlYW0gPT4ge1xuICAgICAgICBpZiAoZnJhZ21lbnQuaGFzRWxlbWVudGFyeVN0cmVhbShlbGVtZW50YXJ5U3RyZWFtKSkge1xuICAgICAgICAgIGxldCB0aW1lUmFuZ2UgPSB0aGlzLnRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIG1hbGZvcm1lZCBmcmFnbWVudHNcbiAgICAgICAgICAvLyBHYXBzIG5lZWQgdG8gYmUgY2FsY3VsYXRlZCBmb3IgZWFjaCBlbGVtZW50YXJ5U3RyZWFtXG4gICAgICAgICAgZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV0gPSB0aGlzLmdldEJ1ZmZlcmVkVGltZXMoZnJhZ21lbnQuc3RhcnRQVFMsIGZyYWdtZW50LmVuZFBUUywgdGltZVJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0QnVmZmVyZWRUaW1lcyAoc3RhcnRQVFMsIGVuZFBUUywgdGltZVJhbmdlKSB7XG4gICAgbGV0IGZyYWdtZW50VGltZXMgPSBbXTtcbiAgICBsZXQgc3RhcnRUaW1lLCBlbmRUaW1lO1xuICAgIGxldCBmcmFnbWVudFBhcnRpYWwgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVSYW5nZS5sZW5ndGg7IGkrKykge1xuICAgICAgc3RhcnRUaW1lID0gdGltZVJhbmdlLnN0YXJ0KGkpIC0gdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgZW5kVGltZSA9IHRpbWVSYW5nZS5lbmQoaSkgKyB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBpZiAoc3RhcnRQVFMgPj0gc3RhcnRUaW1lICYmIGVuZFBUUyA8PSBlbmRUaW1lKSB7XG4gICAgICAgIC8vIEZyYWdtZW50IGlzIGVudGlyZWx5IGNvbnRhaW5lZCBpbiBidWZmZXJcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgb3RoZXIgdGltZVJhbmdlIHRpbWVzIHNpbmNlIGl0J3MgY29tcGxldGVseSBwbGF5YWJsZVxuICAgICAgICBmcmFnbWVudFRpbWVzLnB1c2goe1xuICAgICAgICAgIHN0YXJ0UFRTOiBNYXRoLm1heChzdGFydFBUUywgdGltZVJhbmdlLnN0YXJ0KGkpKSxcbiAgICAgICAgICBlbmRQVFM6IE1hdGgubWluKGVuZFBUUywgdGltZVJhbmdlLmVuZChpKSlcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChzdGFydFBUUyA8IGVuZFRpbWUgJiYgZW5kUFRTID4gc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBpbnRlcnNlY3Rpb24gd2l0aCBidWZmZXJcbiAgICAgICAgLy8gR2V0IHBsYXlhYmxlIHNlY3Rpb25zIG9mIHRoZSBmcmFnbWVudFxuICAgICAgICBmcmFnbWVudFRpbWVzLnB1c2goe1xuICAgICAgICAgIHN0YXJ0UFRTOiBNYXRoLm1heChzdGFydFBUUywgdGltZVJhbmdlLnN0YXJ0KGkpKSxcbiAgICAgICAgICBlbmRQVFM6IE1hdGgubWluKGVuZFBUUywgdGltZVJhbmdlLmVuZChpKSlcbiAgICAgICAgfSk7XG4gICAgICAgIGZyYWdtZW50UGFydGlhbCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVuZFBUUyA8PSBzdGFydFRpbWUpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0aW1lOiBmcmFnbWVudFRpbWVzLFxuICAgICAgcGFydGlhbDogZnJhZ21lbnRQYXJ0aWFsXG4gICAgfTtcbiAgfVxuXG4gIGdldEZyYWdtZW50S2V5IChmcmFnbWVudCkge1xuICAgIHJldHVybiBgJHtmcmFnbWVudC50eXBlfV8ke2ZyYWdtZW50LmxldmVsfV8ke2ZyYWdtZW50LnVybElkfV8ke2ZyYWdtZW50LnNufWA7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcGFydGlhbCBmcmFnbWVudCBmb3IgYSBjZXJ0YWluIHRpbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVcbiAgICogQHJldHVybnMge09iamVjdH0gZnJhZ21lbnQgUmV0dXJucyBhIHBhcnRpYWwgZnJhZ21lbnQgYXQgYSB0aW1lIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gcGFydGlhbCBmcmFnbWVudFxuICAgKi9cbiAgZ2V0UGFydGlhbEZyYWdtZW50ICh0aW1lKSB7XG4gICAgbGV0IHRpbWVQYWRkaW5nLCBzdGFydFRpbWUsIGVuZFRpbWU7XG4gICAgbGV0IGJlc3RGcmFnbWVudCA9IG51bGw7XG4gICAgbGV0IGJlc3RPdmVybGFwID0gMDtcbiAgICBPYmplY3Qua2V5cyh0aGlzLmZyYWdtZW50cykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1trZXldO1xuICAgICAgaWYgKHRoaXMuaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSkge1xuICAgICAgICBzdGFydFRpbWUgPSBmcmFnbWVudEVudGl0eS5ib2R5LnN0YXJ0UFRTIC0gdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgICBlbmRUaW1lID0gZnJhZ21lbnRFbnRpdHkuYm9keS5lbmRQVFMgKyB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICAgIGlmICh0aW1lID49IHN0YXJ0VGltZSAmJiB0aW1lIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIGZyYWdtZW50IHRoYXQgaGFzIHRoZSBtb3N0IHBhZGRpbmcgZnJvbSBzdGFydCBhbmQgZW5kIHRpbWVcbiAgICAgICAgICB0aW1lUGFkZGluZyA9IE1hdGgubWluKHRpbWUgLSBzdGFydFRpbWUsIGVuZFRpbWUgLSB0aW1lKTtcbiAgICAgICAgICBpZiAoYmVzdE92ZXJsYXAgPD0gdGltZVBhZGRpbmcpIHtcbiAgICAgICAgICAgIGJlc3RGcmFnbWVudCA9IGZyYWdtZW50RW50aXR5LmJvZHk7XG4gICAgICAgICAgICBiZXN0T3ZlcmxhcCA9IHRpbWVQYWRkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBiZXN0RnJhZ21lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGZyYWdtZW50IFRoZSBmcmFnbWVudCB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZXR1cm5zIHRoZSBmcmFnbWVudCBzdGF0ZSB3aGVuIGEgZnJhZ21lbnQgbmV2ZXIgbG9hZGVkIG9yIGlmIGl0IHBhcnRpYWxseSBsb2FkZWRcbiAgICovXG4gIGdldFN0YXRlIChmcmFnbWVudCkge1xuICAgIGxldCBmcmFnS2V5ID0gdGhpcy5nZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgbGV0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgbGV0IHN0YXRlID0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEO1xuXG4gICAgaWYgKGZyYWdtZW50RW50aXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQpIHtcbiAgICAgICAgc3RhdGUgPSBGcmFnbWVudFN0YXRlLkFQUEVORElORztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpID09PSB0cnVlKSB7XG4gICAgICAgIHN0YXRlID0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSBGcmFnbWVudFN0YXRlLk9LO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGlzUGFydGlhbCAoZnJhZ21lbnRFbnRpdHkpIHtcbiAgICByZXR1cm4gZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgPT09IHRydWUgJiZcbiAgICAgICgoZnJhZ21lbnRFbnRpdHkucmFuZ2UudmlkZW8gIT09IHVuZGVmaW5lZCAmJiBmcmFnbWVudEVudGl0eS5yYW5nZS52aWRlby5wYXJ0aWFsID09PSB0cnVlKSB8fFxuICAgICAgICAoZnJhZ21lbnRFbnRpdHkucmFuZ2UuYXVkaW8gIT09IHVuZGVmaW5lZCAmJiBmcmFnbWVudEVudGl0eS5yYW5nZS5hdWRpby5wYXJ0aWFsID09PSB0cnVlKSk7XG4gIH1cblxuICBpc1RpbWVCdWZmZXJlZCAoc3RhcnRQVFMsIGVuZFBUUywgdGltZVJhbmdlKSB7XG4gICAgbGV0IHN0YXJ0VGltZSwgZW5kVGltZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVSYW5nZS5sZW5ndGg7IGkrKykge1xuICAgICAgc3RhcnRUaW1lID0gdGltZVJhbmdlLnN0YXJ0KGkpIC0gdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgZW5kVGltZSA9IHRpbWVSYW5nZS5lbmQoaSkgKyB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBpZiAoc3RhcnRQVFMgPj0gc3RhcnRUaW1lICYmIGVuZFBUUyA8PSBlbmRUaW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kUFRTIDw9IHN0YXJ0VGltZSkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIHRoZSByZXN0IG9mIHRoZSB0aW1lUmFuZ2UgYXMgaXQgaXMgaW4gb3JkZXJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBpcyBjb21wbGV0ZWRcbiAgICovXG4gIG9uRnJhZ0xvYWRlZCAoZSkge1xuICAgIGNvbnN0IGZyYWdtZW50ID0gZS5mcmFnO1xuICAgIC8vIGRvbid0IHRyYWNrIGluaXRzZWdtZW50IChmb3Igd2hpY2ggc24gaXMgbm90IGEgbnVtYmVyKVxuICAgIC8vIGRvbid0IHRyYWNrIGZyYWdzIHVzZWQgZm9yIGJpdHJhdGVUZXN0LCB0aGV5J3JlIGlycmVsZXZhbnQuXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJhZ21lbnQuc24pIHx8IGZyYWdtZW50LmJpdHJhdGVUZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5mcmFnbWVudHNbdGhpcy5nZXRGcmFnbWVudEtleShmcmFnbWVudCldID0ge1xuICAgICAgYm9keTogZnJhZ21lbnQsXG4gICAgICByYW5nZTogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGJ1ZmZlcmVkOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgd2hlbiB0aGUgYnVmZmVyIGlzIHVwZGF0ZWRcbiAgICovXG4gIG9uQnVmZmVyQXBwZW5kZWQgKGUpIHtcbiAgICAvLyBTdG9yZSB0aGUgbGF0ZXN0IHRpbWVSYW5nZXMgbG9hZGVkIGluIHRoZSBidWZmZXJcbiAgICB0aGlzLnRpbWVSYW5nZXMgPSBlLnRpbWVSYW5nZXM7XG4gICAgT2JqZWN0LmtleXModGhpcy50aW1lUmFuZ2VzKS5mb3JFYWNoKGVsZW1lbnRhcnlTdHJlYW0gPT4ge1xuICAgICAgbGV0IHRpbWVSYW5nZSA9IHRoaXMudGltZVJhbmdlc1tlbGVtZW50YXJ5U3RyZWFtXTtcbiAgICAgIHRoaXMuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhlbGVtZW50YXJ5U3RyZWFtLCB0aW1lUmFuZ2UpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIGFmdGVyIGEgZnJhZ21lbnQgaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIHNvdXJjZSBidWZmZXJcbiAgICovXG4gIG9uRnJhZ0J1ZmZlcmVkIChlKSB7XG4gICAgdGhpcy5kZXRlY3RQYXJ0aWFsRnJhZ21lbnRzKGUuZnJhZyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgZnJhZ21lbnQgdHJhY2tlciBoYXMgdGhlIGZyYWdtZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZnJhZ21lbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBoYXNGcmFnbWVudCAoZnJhZ21lbnQpIHtcbiAgICBjb25zdCBmcmFnS2V5ID0gdGhpcy5nZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgZnJhZ21lbnQgZnJvbSBmcmFnbWVudCB0cmFja2VyIHVudGlsIGl0IGlzIGxvYWRlZCBhZ2FpblxuICAgKiBAcGFyYW0ge09iamVjdH0gZnJhZ21lbnQgVGhlIGZyYWdtZW50IHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlRnJhZ21lbnQgKGZyYWdtZW50KSB7XG4gICAgbGV0IGZyYWdLZXkgPSB0aGlzLmdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICBkZWxldGUgdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBmcmFnbWVudHMgZnJvbSBmcmFnbWVudCB0cmFja2VyLlxuICAgKi9cbiAgcmVtb3ZlQWxsRnJhZ21lbnRzICgpIHtcbiAgICB0aGlzLmZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEJ1ZmZlckhlbHBlciB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY29uc3Qgc3RhbGxEZWJvdW5jZUludGVydmFsID0gMTAwMDtcbmNvbnN0IGp1bXBUaHJlc2hvbGQgPSAwLjU7IC8vIHRvbGVyYW5jZSBuZWVkZWQgYXMgc29tZSBicm93c2VycyBzdGFsbHMgcGxheWJhY2sgYmVmb3JlIHJlYWNoaW5nIGJ1ZmZlcmVkIHJhbmdlIGVuZFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYXBDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZywgbWVkaWEsIGZyYWdtZW50VHJhY2tlciwgaGxzKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcGxheWhlYWQgaXMgc3R1Y2sgd2l0aGluIGEgZ2FwLCBhbmQgaWYgc28sIGF0dGVtcHRzIHRvIGZyZWUgaXQuXG4gICAqIEEgZ2FwIGlzIGFuIHVuYnVmZmVyZWQgcmFuZ2UgYmV0d2VlbiB0d28gYnVmZmVyZWQgcmFuZ2VzIChvciB0aGUgc3RhcnQgYW5kIHRoZSBmaXJzdCBidWZmZXJlZCByYW5nZSkuXG4gICAqIEBwYXJhbSBsYXN0Q3VycmVudFRpbWVcbiAgICogQHBhcmFtIGJ1ZmZlcmVkXG4gICAqL1xuICBwb2xsIChsYXN0Q3VycmVudFRpbWUsIGJ1ZmZlcmVkKSB7XG4gICAgY29uc3QgeyBjb25maWcsIG1lZGlhIH0gPSB0aGlzO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3QgdG5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcblxuICAgIGlmIChjdXJyZW50VGltZSAhPT0gbGFzdEN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBUaGUgcGxheWhlYWQgaXMgbm93IG1vdmluZywgYnV0IHdhcyBwcmV2aW91c2x5IHN0YWxsZWRcbiAgICAgIGlmICh0aGlzLnN0YWxsUmVwb3J0ZWQpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYHBsYXliYWNrIG5vdCBzdHVjayBhbnltb3JlIEAke2N1cnJlbnRUaW1lfSwgYWZ0ZXIgJHtNYXRoLnJvdW5kKHRub3cgLSB0aGlzLnN0YWxsZWQpfW1zYCk7XG4gICAgICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgIHRoaXMubnVkZ2VSZXRyeSA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1lZGlhLmVuZGVkIHx8ICFtZWRpYS5idWZmZXJlZC5sZW5ndGggfHwgbWVkaWEucmVhZHlTdGF0ZSA+IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWVkaWEuc2Vla2luZyAmJiBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSwgY3VycmVudFRpbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhlIHBsYXloZWFkIGlzbid0IG1vdmluZyBidXQgaXQgc2hvdWxkIGJlXG4gICAgLy8gQWxsb3cgc29tZSBzbGFjayB0aW1lIHRvIGZvciBzbWFsbCBzdGFsbHMgdG8gcmVzb2x2ZSB0aGVtc2VsdmVzXG4gICAgY29uc3Qgc3RhbGxlZER1cmF0aW9uID0gdG5vdyAtIHRoaXMuc3RhbGxlZDtcbiAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCBjb25maWcubWF4QnVmZmVySG9sZSk7XG4gICAgaWYgKCF0aGlzLnN0YWxsZWQpIHtcbiAgICAgIHRoaXMuc3RhbGxlZCA9IHRub3c7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChzdGFsbGVkRHVyYXRpb24gPj0gc3RhbGxEZWJvdW5jZUludGVydmFsKSB7XG4gICAgICAvLyBSZXBvcnQgc3RhbGxpbmcgYWZ0ZXIgdHJ5aW5nIHRvIGZpeFxuICAgICAgdGhpcy5fcmVwb3J0U3RhbGwoYnVmZmVySW5mby5sZW4pO1xuICAgIH1cblxuICAgIHRoaXMuX3RyeUZpeEJ1ZmZlclN0YWxsKGJ1ZmZlckluZm8sIHN0YWxsZWREdXJhdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0cyBhbmQgYXR0ZW1wdHMgdG8gZml4IGtub3duIGJ1ZmZlciBzdGFsbGluZyBpc3N1ZXMuXG4gICAqIEBwYXJhbSBidWZmZXJJbmZvIC0gVGhlIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgYnVmZmVyLlxuICAgKiBAcGFyYW0gc3RhbGxlZER1cmF0aW9uIC0gVGhlIGFtb3VudCBvZiB0aW1lIEhscy5qcyBoYXMgYmVlbiBzdGFsbGluZyBmb3IuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdHJ5Rml4QnVmZmVyU3RhbGwgKGJ1ZmZlckluZm8sIHN0YWxsZWREdXJhdGlvbikge1xuICAgIGNvbnN0IHsgY29uZmlnLCBmcmFnbWVudFRyYWNrZXIsIG1lZGlhIH0gPSB0aGlzO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG5cbiAgICBjb25zdCBwYXJ0aWFsID0gZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChjdXJyZW50VGltZSk7XG4gICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgIC8vIFRyeSB0byBza2lwIG92ZXIgdGhlIGJ1ZmZlciBob2xlIGNhdXNlZCBieSBhIHBhcnRpYWwgZnJhZ21lbnRcbiAgICAgIC8vIFRoaXMgbWV0aG9kIGlzbid0IGxpbWl0ZWQgYnkgdGhlIHNpemUgb2YgdGhlIGdhcCBiZXR3ZWVuIGJ1ZmZlcmVkIHJhbmdlc1xuICAgICAgdGhpcy5fdHJ5U2tpcEJ1ZmZlckhvbGUocGFydGlhbCk7XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlckluZm8ubGVuID4ganVtcFRocmVzaG9sZCAmJiBzdGFsbGVkRHVyYXRpb24gPiBjb25maWcuaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kICogMTAwMCkge1xuICAgICAgLy8gVHJ5IHRvIG51ZGdlIGN1cnJlbnRUaW1lIG92ZXIgYSBidWZmZXIgaG9sZSBpZiB3ZSd2ZSBiZWVuIHN0YWxsaW5nIGZvciB0aGUgY29uZmlndXJlZCBhbW91bnQgb2Ygc2Vjb25kc1xuICAgICAgLy8gV2Ugb25seSB0cnkgdG8ganVtcCB0aGUgaG9sZSBpZiBpdCdzIHVuZGVyIHRoZSBjb25maWd1cmVkIHNpemVcbiAgICAgIC8vIFJlc2V0IHN0YWxsZWQgc28gdG8gcmVhcm0gd2F0Y2hkb2cgdGltZXJcbiAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICB0aGlzLl90cnlOdWRnZUJ1ZmZlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhIEJVRkZFUl9TVEFMTEVEX0VSUk9SIGV2ZW50LCBidXQgb25seSBvbmNlIHBlciBzdGFsbCBwZXJpb2QuXG4gICAqIEBwYXJhbSBidWZmZXJMZW4gLSBUaGUgcGxheWhlYWQgZGlzdGFuY2UgZnJvbSB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlciBzZWdtZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlcG9ydFN0YWxsIChidWZmZXJMZW4pIHtcbiAgICBjb25zdCB7IGhscywgbWVkaWEsIHN0YWxsUmVwb3J0ZWQgfSA9IHRoaXM7XG4gICAgaWYgKCFzdGFsbFJlcG9ydGVkKSB7XG4gICAgICAvLyBSZXBvcnQgc3RhbGxlZCBlcnJvciBvbmNlXG4gICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSB0cnVlO1xuICAgICAgbG9nZ2VyLndhcm4oYFBsYXliYWNrIHN0YWxsaW5nIGF0IEAke21lZGlhLmN1cnJlbnRUaW1lfSBkdWUgdG8gbG93IGJ1ZmZlcmApO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGJ1ZmZlcjogYnVmZmVyTGVuXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZml4IGJ1ZmZlciBzdGFsbHMgYnkganVtcGluZyBvdmVyIGtub3duIGdhcHMgY2F1c2VkIGJ5IHBhcnRpYWwgZnJhZ21lbnRzXG4gICAqIEBwYXJhbSBwYXJ0aWFsIC0gVGhlIHBhcnRpYWwgZnJhZ21lbnQgZm91bmQgYXQgdGhlIGN1cnJlbnQgdGltZSAod2hlcmUgcGxheWJhY2sgaXMgc3RhbGxpbmcpLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyeVNraXBCdWZmZXJIb2xlIChwYXJ0aWFsKSB7XG4gICAgY29uc3QgeyBobHMsIG1lZGlhIH0gPSB0aGlzO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgbGV0IGxhc3RFbmRUaW1lID0gMDtcbiAgICAvLyBDaGVjayBpZiBjdXJyZW50VGltZSBpcyBiZXR3ZWVuIHVuYnVmZmVyZWQgcmVnaW9ucyBvZiBwYXJ0aWFsIGZyYWdtZW50c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVkaWEuYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzdGFydFRpbWUgPSBtZWRpYS5idWZmZXJlZC5zdGFydChpKTtcbiAgICAgIGlmIChjdXJyZW50VGltZSA+PSBsYXN0RW5kVGltZSAmJiBjdXJyZW50VGltZSA8IHN0YXJ0VGltZSkge1xuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IE1hdGgubWF4KHN0YXJ0VGltZSwgbWVkaWEuY3VycmVudFRpbWUgKyAwLjEpO1xuICAgICAgICBsb2dnZXIud2Fybihgc2tpcHBpbmcgaG9sZSwgYWRqdXN0aW5nIGN1cnJlbnRUaW1lIGZyb20gJHtjdXJyZW50VGltZX0gdG8gJHttZWRpYS5jdXJyZW50VGltZX1gKTtcbiAgICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU0VFS19PVkVSX0hPTEUsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIHJlYXNvbjogYGZyYWdtZW50IGxvYWRlZCB3aXRoIGJ1ZmZlciBob2xlcywgc2Vla2luZyBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7bWVkaWEuY3VycmVudFRpbWV9YCxcbiAgICAgICAgICBmcmFnOiBwYXJ0aWFsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsYXN0RW5kVGltZSA9IG1lZGlhLmJ1ZmZlcmVkLmVuZChpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZml4IGJ1ZmZlciBzdGFsbHMgYnkgYWR2YW5jaW5nIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUgYnkgYSBzbWFsbCBhbW91bnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdHJ5TnVkZ2VCdWZmZXIgKCkge1xuICAgIGNvbnN0IHsgY29uZmlnLCBobHMsIG1lZGlhIH0gPSB0aGlzO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3QgbnVkZ2VSZXRyeSA9ICh0aGlzLm51ZGdlUmV0cnkgfHwgMCkgKyAxO1xuICAgIHRoaXMubnVkZ2VSZXRyeSA9IG51ZGdlUmV0cnk7XG5cbiAgICBpZiAobnVkZ2VSZXRyeSA8IGNvbmZpZy5udWRnZU1heFJldHJ5KSB7XG4gICAgICBjb25zdCB0YXJnZXRUaW1lID0gY3VycmVudFRpbWUgKyBudWRnZVJldHJ5ICogY29uZmlnLm51ZGdlT2Zmc2V0O1xuICAgICAgbG9nZ2VyLmxvZyhgYWRqdXN0IGN1cnJlbnRUaW1lIGZyb20gJHtjdXJyZW50VGltZX0gdG8gJHt0YXJnZXRUaW1lfWApO1xuICAgICAgLy8gcGxheWJhY2sgc3RhbGxlZCBpbiBidWZmZXJlZCBhcmVhIC4uLiBsZXQncyBudWRnZSBjdXJyZW50VGltZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpc1xuICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSB0YXJnZXRUaW1lO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9OVURHRV9PTl9TVEFMTCxcbiAgICAgICAgZmF0YWw6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmVycm9yKGBzdGlsbCBzdHVjayBpbiBoaWdoIGJ1ZmZlciBAJHtjdXJyZW50VGltZX0gYWZ0ZXIgJHtjb25maWcubnVkZ2VNYXhSZXRyeX0sIHJhaXNlIGZhdGFsIGVycm9yYCk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBpZDMgbWV0YWRhdGEgdHJhY2sgY29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IElEMyBmcm9tICcuLi9kZW11eC9pZDMnO1xuaW1wb3J0IHsgc2VuZEFkZFRyYWNrRXZlbnQsIGNsZWFyQ3VycmVudEN1ZXMgfSBmcm9tICcuLi91dGlscy90ZXh0dHJhY2stdXRpbHMnO1xuXG5jbGFzcyBJRDNUcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUVESUFfQVRUQUNIRUQsXG4gICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfTUVUQURBVEEpO1xuICAgIHRoaXMuaWQzVHJhY2sgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tZWRpYSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLy8gQWRkIElEMyBtZXRhdGFkYXRhIHRleHQgdHJhY2suXG4gIG9uTWVkaWFBdHRhY2hlZCAoZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuXG4gICAgfVxuICB9XG5cbiAgb25NZWRpYURldGFjaGluZyAoKSB7XG4gICAgY2xlYXJDdXJyZW50Q3Vlcyh0aGlzLmlkM1RyYWNrKTtcbiAgICB0aGlzLmlkM1RyYWNrID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWVkaWEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXRJRDNUcmFjayAodGV4dFRyYWNrcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHRleHRUcmFjayA9IHRleHRUcmFja3NbaV07XG4gICAgICBpZiAodGV4dFRyYWNrLmtpbmQgPT09ICdtZXRhZGF0YScgJiYgdGV4dFRyYWNrLmxhYmVsID09PSAnaWQzJykge1xuICAgICAgICAvLyBzZW5kICdhZGR0cmFjaycgd2hlbiByZXVzaW5nIHRoZSB0ZXh0VHJhY2sgZm9yIG1ldGFkYXRhLFxuICAgICAgICAvLyBzYW1lIGFzIHdoYXQgd2UgZG8gZm9yIGNhcHRpb25zXG4gICAgICAgIHNlbmRBZGRUcmFja0V2ZW50KHRleHRUcmFjaywgdGhpcy5tZWRpYSk7XG5cbiAgICAgICAgcmV0dXJuIHRleHRUcmFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVkaWEuYWRkVGV4dFRyYWNrKCdtZXRhZGF0YScsICdpZDMnKTtcbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdNZXRhZGF0YSAoZGF0YSkge1xuICAgIGNvbnN0IGZyYWdtZW50ID0gZGF0YS5mcmFnO1xuICAgIGNvbnN0IHNhbXBsZXMgPSBkYXRhLnNhbXBsZXM7XG5cbiAgICAvLyBjcmVhdGUgdHJhY2sgZHluYW1pY2FsbHlcbiAgICBpZiAoIXRoaXMuaWQzVHJhY2spIHtcbiAgICAgIHRoaXMuaWQzVHJhY2sgPSB0aGlzLmdldElEM1RyYWNrKHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG4gICAgICB0aGlzLmlkM1RyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgICB9XG5cbiAgICAvLyBBdHRlbXB0IHRvIHJlY3JlYXRlIFNhZmFyaSBmdW5jdGlvbmFsaXR5IGJ5IGNyZWF0aW5nXG4gICAgLy8gV2ViS2l0RGF0YUN1ZSBvYmplY3RzIHdoZW4gYXZhaWxhYmxlIGFuZCBzdG9yZSB0aGUgZGVjb2RlZFxuICAgIC8vIElEMyBkYXRhIGluIHRoZSB2YWx1ZSBwcm9wZXJ0eSBvZiB0aGUgY3VlXG4gICAgbGV0IEN1ZSA9IHdpbmRvdy5XZWJLaXREYXRhQ3VlIHx8IHdpbmRvdy5WVFRDdWUgfHwgd2luZG93LlRleHRUcmFja0N1ZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZnJhbWVzID0gSUQzLmdldElEM0ZyYW1lcyhzYW1wbGVzW2ldLmRhdGEpO1xuICAgICAgaWYgKGZyYW1lcykge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBzYW1wbGVzW2ldLnB0cztcbiAgICAgICAgbGV0IGVuZFRpbWUgPSBpIDwgc2FtcGxlcy5sZW5ndGggLSAxID8gc2FtcGxlc1tpICsgMV0ucHRzIDogZnJhZ21lbnQuZW5kUFRTO1xuXG4gICAgICAgIC8vIEdpdmUgYSBzbGlnaHQgYnVtcCB0byB0aGUgZW5kVGltZSBpZiBpdCdzIGVxdWFsIHRvIHN0YXJ0VGltZSB0byBhdm9pZCBhIFN5bnRheEVycm9yIGluIElFXG4gICAgICAgIGlmIChzdGFydFRpbWUgPT09IGVuZFRpbWUpIHtcbiAgICAgICAgICBlbmRUaW1lICs9IDAuMDAwMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZnJhbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgZnJhbWUgPSBmcmFtZXNbal07XG4gICAgICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgcHV0IHRoZSB0aW1lc3RhbXAgZnJhbWUgaW4gdGhlIFRleHRUcmFja1xuICAgICAgICAgIGlmICghSUQzLmlzVGltZVN0YW1wRnJhbWUoZnJhbWUpKSB7XG4gICAgICAgICAgICBjb25zdCBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgJycpO1xuICAgICAgICAgICAgY3VlLnZhbHVlID0gZnJhbWU7XG4gICAgICAgICAgICB0aGlzLmlkM1RyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJRDNUcmFja0NvbnRyb2xsZXI7XG4iLCIvKlxuICogTGV2ZWwgQ29udHJvbGxlclxuKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4uL2V2ZW50LWhhbmRsZXInO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBpc0NvZGVjU3VwcG9ydGVkSW5NcDQgfSBmcm9tICcuLi91dGlscy9jb2RlY3MnO1xuaW1wb3J0IHsgYWRkR3JvdXBJZCwgY29tcHV0ZVJlbG9hZEludGVydmFsIH0gZnJvbSAnLi9sZXZlbC1oZWxwZXInO1xuXG5jb25zdCB7IHBlcmZvcm1hbmNlIH0gPSB3aW5kb3c7XG5sZXQgY2hyb21lT3JGaXJlZm94O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZXZlbENvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BREVELFxuICAgICAgRXZlbnQuTEVWRUxfTE9BREVELFxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENIRUQsXG4gICAgICBFdmVudC5GUkFHX0xPQURFRCxcbiAgICAgIEV2ZW50LkVSUk9SKTtcblxuICAgIHRoaXMuY2FubG9hZCA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSBudWxsO1xuICAgIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IC0xO1xuICAgIHRoaXMudGltZXIgPSBudWxsO1xuXG4gICAgY2hyb21lT3JGaXJlZm94ID0gL2Nocm9tZXxmaXJlZm94Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICBvbkhhbmRsZXJEZXN0cm95aW5nICgpIHtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICB0aGlzLm1hbnVhbExldmVsSW5kZXggPSAtMTtcbiAgfVxuXG4gIGNsZWFyVGltZXIgKCkge1xuICAgIGlmICh0aGlzLnRpbWVyICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBzdGFydExvYWQgKCkge1xuICAgIGxldCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG5cbiAgICB0aGlzLmNhbmxvYWQgPSB0cnVlO1xuICAgIHRoaXMubGV2ZWxSZXRyeUNvdW50ID0gMDtcblxuICAgIC8vIGNsZWFuIHVwIGxpdmUgbGV2ZWwgZGV0YWlscyB0byBmb3JjZSByZWxvYWQgdGhlbSwgYW5kIHJlc2V0IGxvYWQgZXJyb3JzXG4gICAgaWYgKGxldmVscykge1xuICAgICAgbGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgICAgICBpZiAobGV2ZWxEZXRhaWxzICYmIGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgbGV2ZWwuZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHNwZWVkIHVwIGxpdmUgcGxheWxpc3QgcmVmcmVzaCBpZiB0aW1lciBleGlzdHNcbiAgICBpZiAodGhpcy50aW1lciAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5sb2FkTGV2ZWwoKTtcbiAgICB9XG4gIH1cblxuICBzdG9wTG9hZCAoKSB7XG4gICAgdGhpcy5jYW5sb2FkID0gZmFsc2U7XG4gIH1cblxuICBvbk1hbmlmZXN0TG9hZGVkIChkYXRhKSB7XG4gICAgbGV0IGxldmVscyA9IFtdO1xuICAgIGxldCBhdWRpb1RyYWNrcyA9IFtdO1xuICAgIGxldCBiaXRyYXRlU3RhcnQ7XG4gICAgbGV0IGxldmVsU2V0ID0ge307XG4gICAgbGV0IGxldmVsRnJvbVNldCA9IG51bGw7XG4gICAgbGV0IHZpZGVvQ29kZWNGb3VuZCA9IGZhbHNlO1xuICAgIGxldCBhdWRpb0NvZGVjRm91bmQgPSBmYWxzZTtcblxuICAgIC8vIHJlZ3JvdXAgcmVkdW5kYW50IGxldmVscyB0b2dldGhlclxuICAgIGRhdGEubGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGxldmVsLmF0dHJzO1xuICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IgPSBmYWxzZTtcblxuICAgICAgdmlkZW9Db2RlY0ZvdW5kID0gdmlkZW9Db2RlY0ZvdW5kIHx8ICEhbGV2ZWwudmlkZW9Db2RlYztcbiAgICAgIGF1ZGlvQ29kZWNGb3VuZCA9IGF1ZGlvQ29kZWNGb3VuZCB8fCAhIWxldmVsLmF1ZGlvQ29kZWM7XG5cbiAgICAgIC8vIGVyYXNlIGF1ZGlvIGNvZGVjIGluZm8gaWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG1wNGEuNDAuMzQuXG4gICAgICAvLyBkZW11eGVyIHdpbGwgYXV0b2RldGVjdCBjb2RlYyBhbmQgZmFsbGJhY2sgdG8gbXBlZy9hdWRpb1xuICAgICAgaWYgKGNocm9tZU9yRmlyZWZveCAmJiBsZXZlbC5hdWRpb0NvZGVjICYmIGxldmVsLmF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4zNCcpICE9PSAtMSkge1xuICAgICAgICBsZXZlbC5hdWRpb0NvZGVjID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBsZXZlbEZyb21TZXQgPSBsZXZlbFNldFtsZXZlbC5iaXRyYXRlXTsgLy8gRklYTUU6IHdlIHdvdWxkIGFsc28gaGF2ZSB0byBtYXRjaCB0aGUgcmVzb2x1dGlvbiBoZXJlXG5cbiAgICAgIGlmICghbGV2ZWxGcm9tU2V0KSB7XG4gICAgICAgIGxldmVsLnVybCA9IFtsZXZlbC51cmxdO1xuICAgICAgICBsZXZlbC51cmxJZCA9IDA7XG4gICAgICAgIGxldmVsU2V0W2xldmVsLmJpdHJhdGVdID0gbGV2ZWw7XG4gICAgICAgIGxldmVscy5wdXNoKGxldmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsRnJvbVNldC51cmwucHVzaChsZXZlbC51cmwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0cmlidXRlcy5BVURJTykge1xuICAgICAgICAgIGF1ZGlvQ29kZWNGb3VuZCA9IHRydWU7XG4gICAgICAgICAgYWRkR3JvdXBJZChsZXZlbEZyb21TZXQgfHwgbGV2ZWwsICdhdWRpbycsIGF0dHJpYnV0ZXMuQVVESU8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLlNVQlRJVExFUykge1xuICAgICAgICAgIGFkZEdyb3VwSWQobGV2ZWxGcm9tU2V0IHx8IGxldmVsLCAndGV4dCcsIGF0dHJpYnV0ZXMuU1VCVElUTEVTKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gcmVtb3ZlIGF1ZGlvLW9ubHkgbGV2ZWwgaWYgd2UgYWxzbyBoYXZlIGxldmVscyB3aXRoIGF1ZGlvK3ZpZGVvIGNvZGVjcyBzaWduYWxsZWRcbiAgICBpZiAodmlkZW9Db2RlY0ZvdW5kICYmIGF1ZGlvQ29kZWNGb3VuZCkge1xuICAgICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcigoeyB2aWRlb0NvZGVjIH0pID0+ICEhdmlkZW9Db2RlYyk7XG4gICAgfVxuXG4gICAgLy8gb25seSBrZWVwIGxldmVscyB3aXRoIHN1cHBvcnRlZCBhdWRpby92aWRlbyBjb2RlY3NcbiAgICBsZXZlbHMgPSBsZXZlbHMuZmlsdGVyKCh7IGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMgfSkgPT4ge1xuICAgICAgcmV0dXJuICghYXVkaW9Db2RlYyB8fCBpc0NvZGVjU3VwcG9ydGVkSW5NcDQoYXVkaW9Db2RlYywgJ2F1ZGlvJykpICYmICghdmlkZW9Db2RlYyB8fCBpc0NvZGVjU3VwcG9ydGVkSW5NcDQodmlkZW9Db2RlYywgJ3ZpZGVvJykpO1xuICAgIH0pO1xuXG4gICAgaWYgKGRhdGEuYXVkaW9UcmFja3MpIHtcbiAgICAgIGF1ZGlvVHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcy5maWx0ZXIodHJhY2sgPT4gIXRyYWNrLmF1ZGlvQ29kZWMgfHwgaXNDb2RlY1N1cHBvcnRlZEluTXA0KHRyYWNrLmF1ZGlvQ29kZWMsICdhdWRpbycpKTtcbiAgICAgIC8vIFJlYXNzaWduIGlkJ3MgYWZ0ZXIgZmlsdGVyaW5nIHNpbmNlIHRoZXkncmUgdXNlZCBhcyBhcnJheSBpbmRpY2VzXG4gICAgICBhdWRpb1RyYWNrcy5mb3JFYWNoKCh0cmFjaywgaW5kZXgpID0+IHtcbiAgICAgICAgdHJhY2suaWQgPSBpbmRleDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChsZXZlbHMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gc3RhcnQgYml0cmF0ZSBpcyB0aGUgZmlyc3QgYml0cmF0ZSBvZiB0aGUgbWFuaWZlc3RcbiAgICAgIGJpdHJhdGVTdGFydCA9IGxldmVsc1swXS5iaXRyYXRlO1xuICAgICAgLy8gc29ydCBsZXZlbCBvbiBiaXRyYXRlXG4gICAgICBsZXZlbHMuc29ydCgoYSwgYikgPT4gYS5iaXRyYXRlIC0gYi5iaXRyYXRlKTtcbiAgICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcbiAgICAgIC8vIGZpbmQgaW5kZXggb2YgZmlyc3QgbGV2ZWwgaW4gc29ydGVkIGxldmVsc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxldmVsc1tpXS5iaXRyYXRlID09PSBiaXRyYXRlU3RhcnQpIHtcbiAgICAgICAgICB0aGlzLl9maXJzdExldmVsID0gaTtcbiAgICAgICAgICBsb2dnZXIubG9nKGBtYW5pZmVzdCBsb2FkZWQsJHtsZXZlbHMubGVuZ3RofSBsZXZlbChzKSBmb3VuZCwgZmlyc3QgYml0cmF0ZToke2JpdHJhdGVTdGFydH1gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBdWRpbyBpcyBvbmx5IGFsdGVybmF0ZSBpZiBtYW5pZmVzdCBpbmNsdWRlIGEgVVJJIGFsb25nIHdpdGggdGhlIGF1ZGlvIGdyb3VwIHRhZ1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5NQU5JRkVTVF9QQVJTRUQsIHtcbiAgICAgICAgbGV2ZWxzLFxuICAgICAgICBhdWRpb1RyYWNrcyxcbiAgICAgICAgZmlyc3RMZXZlbDogdGhpcy5fZmlyc3RMZXZlbCxcbiAgICAgICAgc3RhdHM6IGRhdGEuc3RhdHMsXG4gICAgICAgIGF1ZGlvOiBhdWRpb0NvZGVjRm91bmQsXG4gICAgICAgIHZpZGVvOiB2aWRlb0NvZGVjRm91bmQsXG4gICAgICAgIGFsdEF1ZGlvOiBhdWRpb1RyYWNrcy5zb21lKHQgPT4gISF0LnVybClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLFxuICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgdXJsOiB0aGlzLmhscy51cmwsXG4gICAgICAgIHJlYXNvbjogJ25vIGxldmVsIHdpdGggY29tcGF0aWJsZSBjb2RlY3MgZm91bmQgaW4gbWFuaWZlc3QnXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBnZXQgbGV2ZWxzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGV2ZWxzO1xuICB9XG5cbiAgZ2V0IGxldmVsICgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50TGV2ZWxJbmRleDtcbiAgfVxuXG4gIHNldCBsZXZlbCAobmV3TGV2ZWwpIHtcbiAgICBsZXQgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzO1xuICAgIGlmIChsZXZlbHMpIHtcbiAgICAgIG5ld0xldmVsID0gTWF0aC5taW4obmV3TGV2ZWwsIGxldmVscy5sZW5ndGggLSAxKTtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRMZXZlbEluZGV4ICE9PSBuZXdMZXZlbCB8fCAhbGV2ZWxzW25ld0xldmVsXS5kZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuc2V0TGV2ZWxJbnRlcm5hbChuZXdMZXZlbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0TGV2ZWxJbnRlcm5hbCAobmV3TGV2ZWwpIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgaWYgKG5ld0xldmVsID49IDAgJiYgbmV3TGV2ZWwgPCBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgaWYgKHRoaXMuY3VycmVudExldmVsSW5kZXggIT09IG5ld0xldmVsKSB7XG4gICAgICAgIGxvZ2dlci5sb2coYHN3aXRjaGluZyB0byBsZXZlbCAke25ld0xldmVsfWApO1xuICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gbmV3TGV2ZWw7XG4gICAgICAgIGNvbnN0IGxldmVsUHJvcGVydGllcyA9IGxldmVsc1tuZXdMZXZlbF07XG4gICAgICAgIGxldmVsUHJvcGVydGllcy5sZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5MRVZFTF9TV0lUQ0hJTkcsIGxldmVsUHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBsZXZlbCA9IGxldmVsc1tuZXdMZXZlbF07XG4gICAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuXG4gICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGxvYWQgcGxheWxpc3QgZm9yIHRoaXMgbGV2ZWxcbiAgICAgIGlmICghbGV2ZWxEZXRhaWxzIHx8IGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICAgIC8vIGxldmVsIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgICAgbGV0IHVybElkID0gbGV2ZWwudXJsSWQ7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX0xPQURJTkcsIHsgdXJsOiBsZXZlbC51cmxbdXJsSWRdLCBsZXZlbDogbmV3TGV2ZWwsIGlkOiB1cmxJZCB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW52YWxpZCBsZXZlbCBpZCBnaXZlbiwgdHJpZ2dlciBlcnJvclxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkxFVkVMX1NXSVRDSF9FUlJPUixcbiAgICAgICAgbGV2ZWw6IG5ld0xldmVsLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIHJlYXNvbjogJ2ludmFsaWQgbGV2ZWwgaWR4J1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IG1hbnVhbExldmVsICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4O1xuICB9XG5cbiAgc2V0IG1hbnVhbExldmVsIChuZXdMZXZlbCkge1xuICAgIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IG5ld0xldmVsO1xuICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG5cbiAgICBpZiAobmV3TGV2ZWwgIT09IC0xKSB7XG4gICAgICB0aGlzLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGZpcnN0TGV2ZWwgKCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xuICB9XG5cbiAgc2V0IGZpcnN0TGV2ZWwgKG5ld0xldmVsKSB7XG4gICAgdGhpcy5fZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgZ2V0IHN0YXJ0TGV2ZWwgKCkge1xuICAgIC8vIGhscy5zdGFydExldmVsIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBjb25maWcuc3RhcnRMZXZlbFxuICAgIC8vIGlmIG5vbmUgb2YgdGhlc2UgdmFsdWVzIGFyZSBkZWZpbmVkLCBmYWxsYmFjayBvbiB0aGlzLl9maXJzdExldmVsIChmaXJzdCBxdWFsaXR5IGxldmVsIGFwcGVhcmluZyBpbiB2YXJpYW50IG1hbmlmZXN0KVxuICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBjb25maWdTdGFydExldmVsID0gdGhpcy5obHMuY29uZmlnLnN0YXJ0TGV2ZWw7XG4gICAgICBpZiAoY29uZmlnU3RhcnRMZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjb25maWdTdGFydExldmVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGFydExldmVsO1xuICAgIH1cbiAgfVxuXG4gIHNldCBzdGFydExldmVsIChuZXdMZXZlbCkge1xuICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIG9uRXJyb3IgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SKSB7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGxldmVsRXJyb3IgPSBmYWxzZSwgZnJhZ21lbnRFcnJvciA9IGZhbHNlO1xuICAgIGxldCBsZXZlbEluZGV4O1xuXG4gICAgLy8gdHJ5IHRvIHJlY292ZXIgbm90IGZhdGFsIGVycm9yc1xuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICBsZXZlbEluZGV4ID0gZGF0YS5mcmFnLmxldmVsO1xuICAgICAgZnJhZ21lbnRFcnJvciA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SOlxuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgIGxldmVsSW5kZXggPSBkYXRhLmNvbnRleHQubGV2ZWw7XG4gICAgICBsZXZlbEVycm9yID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SOlxuICAgICAgbGV2ZWxJbmRleCA9IGRhdGEubGV2ZWw7XG4gICAgICBsZXZlbEVycm9yID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChsZXZlbEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucmVjb3ZlckxldmVsKGRhdGEsIGxldmVsSW5kZXgsIGxldmVsRXJyb3IsIGZyYWdtZW50RXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTd2l0Y2ggdG8gYSByZWR1bmRhbnQgc3RyZWFtIGlmIGFueSBhdmFpbGFibGUuXG4gICAqIElmIHJlZHVuZGFudCBzdHJlYW0gaXMgbm90IGF2YWlsYWJsZSwgZW1lcmdlbmN5IHN3aXRjaCBkb3duIGlmIEFCUiBtb2RlIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlcnJvckV2ZW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbEluZGV4IGN1cnJlbnQgbGV2ZWwgaW5kZXhcbiAgICogQHBhcmFtIHtCb29sZWFufSBsZXZlbEVycm9yXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZnJhZ21lbnRFcnJvclxuICAgKi9cbiAgLy8gRklYTUUgRmluZCBhIGJldHRlciBhYnN0cmFjdGlvbiB3aGVyZSBmcmFnbWVudC9sZXZlbCByZXRyeSBtYW5hZ2VtZW50IGlzIHdlbGwgZGVjb3VwbGVkXG4gIHJlY292ZXJMZXZlbCAoZXJyb3JFdmVudCwgbGV2ZWxJbmRleCwgbGV2ZWxFcnJvciwgZnJhZ21lbnRFcnJvcikge1xuICAgIGxldCB7IGNvbmZpZyB9ID0gdGhpcy5obHM7XG4gICAgbGV0IHsgZGV0YWlsczogZXJyb3JEZXRhaWxzIH0gPSBlcnJvckV2ZW50O1xuICAgIGxldCBsZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbEluZGV4XTtcbiAgICBsZXQgcmVkdW5kYW50TGV2ZWxzLCBkZWxheSwgbmV4dExldmVsO1xuXG4gICAgbGV2ZWwubG9hZEVycm9yKys7XG4gICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IGZyYWdtZW50RXJyb3I7XG5cbiAgICBpZiAobGV2ZWxFcnJvcikge1xuICAgICAgaWYgKCh0aGlzLmxldmVsUmV0cnlDb3VudCArIDEpIDw9IGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeSkge1xuICAgICAgICAvLyBleHBvbmVudGlhbCBiYWNrb2ZmIGNhcHBlZCB0byBtYXggcmV0cnkgdGltZW91dFxuICAgICAgICBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsIHRoaXMubGV2ZWxSZXRyeUNvdW50KSAqIGNvbmZpZy5sZXZlbExvYWRpbmdSZXRyeURlbGF5LCBjb25maWcubGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0KTtcbiAgICAgICAgLy8gU2NoZWR1bGUgbGV2ZWwgcmVsb2FkXG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMubG9hZExldmVsKCksIGRlbGF5KTtcbiAgICAgICAgLy8gYm9vbGVhbiB1c2VkIHRvIGluZm9ybSBzdHJlYW0gY29udHJvbGxlciBub3QgdG8gc3dpdGNoIGJhY2sgdG8gSURMRSBvbiBub24gZmF0YWwgZXJyb3JcbiAgICAgICAgZXJyb3JFdmVudC5sZXZlbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sZXZlbFJldHJ5Q291bnQrKztcbiAgICAgICAgbG9nZ2VyLndhcm4oYGxldmVsIGNvbnRyb2xsZXIsICR7ZXJyb3JEZXRhaWxzfSwgcmV0cnkgaW4gJHtkZWxheX0gbXMsIGN1cnJlbnQgcmV0cnkgY291bnQgaXMgJHt0aGlzLmxldmVsUmV0cnlDb3VudH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgbGV2ZWwgY29udHJvbGxlciwgY2Fubm90IHJlY292ZXIgZnJvbSAke2Vycm9yRGV0YWlsc30gZXJyb3JgKTtcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IG51bGw7XG4gICAgICAgIC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgLy8gc3dpdGNoIGVycm9yIHRvIGZhdGFsXG4gICAgICAgIGVycm9yRXZlbnQuZmF0YWwgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJ5IGFueSByZWR1bmRhbnQgc3RyZWFtcyBpZiBhdmFpbGFibGUgZm9yIGJvdGggZXJyb3JzOiBsZXZlbCBhbmQgZnJhZ21lbnRcbiAgICAvLyBJZiBsZXZlbC5sb2FkRXJyb3IgcmVhY2hlcyByZWR1bmRhbnRMZXZlbHMgaXQgbWVhbnMgdGhhdCB3ZSB0cmllZCB0aGVtIGFsbCwgbm8gaG9wZSAgPT4gbGV0J3Mgc3dpdGNoIGRvd25cbiAgICBpZiAobGV2ZWxFcnJvciB8fCBmcmFnbWVudEVycm9yKSB7XG4gICAgICByZWR1bmRhbnRMZXZlbHMgPSBsZXZlbC51cmwubGVuZ3RoO1xuXG4gICAgICBpZiAocmVkdW5kYW50TGV2ZWxzID4gMSAmJiBsZXZlbC5sb2FkRXJyb3IgPCByZWR1bmRhbnRMZXZlbHMpIHtcbiAgICAgICAgbGV2ZWwudXJsSWQgPSAobGV2ZWwudXJsSWQgKyAxKSAlIHJlZHVuZGFudExldmVscztcbiAgICAgICAgbGV2ZWwuZGV0YWlscyA9IHVuZGVmaW5lZDtcblxuICAgICAgICBsb2dnZXIud2FybihgbGV2ZWwgY29udHJvbGxlciwgJHtlcnJvckRldGFpbHN9IGZvciBsZXZlbCAke2xldmVsSW5kZXh9OiBzd2l0Y2hpbmcgdG8gcmVkdW5kYW50IFVSTC1pZCAke2xldmVsLnVybElkfWApO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdDdXJyZW50IGF1ZGlvIHRyYWNrIGdyb3VwIElEOicsIHRoaXMuaGxzLmF1ZGlvVHJhY2tzW3RoaXMuaGxzLmF1ZGlvVHJhY2tdLmdyb3VwSWQpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnTmV3IHZpZGVvIHF1YWxpdHkgbGV2ZWwgYXVkaW8gZ3JvdXAgaWQ6JywgbGV2ZWwuYXR0cnMuQVVESU8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2VhcmNoIGZvciBhdmFpbGFibGUgbGV2ZWxcbiAgICAgICAgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBXaGVuIGxvd2VzdCBsZXZlbCBoYXMgYmVlbiByZWFjaGVkLCBsZXQncyBzdGFydCBodW50IGZyb20gdGhlIHRvcFxuICAgICAgICAgIG5leHRMZXZlbCA9IChsZXZlbEluZGV4ID09PSAwKSA/IHRoaXMuX2xldmVscy5sZW5ndGggLSAxIDogbGV2ZWxJbmRleCAtIDE7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYGxldmVsIGNvbnRyb2xsZXIsICR7ZXJyb3JEZXRhaWxzfTogc3dpdGNoIHRvICR7bmV4dExldmVsfWApO1xuICAgICAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gbmV4dExldmVsO1xuICAgICAgICB9IGVsc2UgaWYgKGZyYWdtZW50RXJyb3IpIHtcbiAgICAgICAgICAvLyBBbGxvdyBmcmFnbWVudCByZXRyeSBhcyBsb25nIGFzIGNvbmZpZ3VyYXRpb24gYWxsb3dzLlxuICAgICAgICAgIC8vIHJlc2V0IHRoaXMuX2xldmVsIHNvIHRoYXQgYW5vdGhlciBjYWxsIHRvIHNldCBsZXZlbCgpIHdpbGwgdHJpZ2dlciBhZ2FpbiBhIGZyYWcgbG9hZFxuICAgICAgICAgIGxvZ2dlci53YXJuKGBsZXZlbCBjb250cm9sbGVyLCAke2Vycm9yRGV0YWlsc306IHJlbG9hZCBhIGZyYWdtZW50YCk7XG4gICAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZXNldCBlcnJvcnMgb24gdGhlIHN1Y2Nlc3NmdWwgbG9hZCBvZiBhIGZyYWdtZW50XG4gIG9uRnJhZ0xvYWRlZCAoeyBmcmFnIH0pIHtcbiAgICBpZiAoZnJhZyAhPT0gdW5kZWZpbmVkICYmIGZyYWcudHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICBjb25zdCBsZXZlbCA9IHRoaXMuX2xldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgIGlmIChsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IgPSBmYWxzZTtcbiAgICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICAgICAgdGhpcy5sZXZlbFJldHJ5Q291bnQgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uTGV2ZWxMb2FkZWQgKGRhdGEpIHtcbiAgICBjb25zdCB7IGxldmVsLCBkZXRhaWxzIH0gPSBkYXRhO1xuICAgIC8vIG9ubHkgcHJvY2VzcyBsZXZlbCBsb2FkZWQgZXZlbnRzIG1hdGNoaW5nIHdpdGggZXhwZWN0ZWQgbGV2ZWxcbiAgICBpZiAobGV2ZWwgIT09IHRoaXMuY3VycmVudExldmVsSW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJMZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbF07XG4gICAgLy8gcmVzZXQgbGV2ZWwgbG9hZCBlcnJvciBjb3VudGVyIG9uIHN1Y2Nlc3NmdWwgbGV2ZWwgbG9hZGVkIG9ubHkgaWYgdGhlcmUgaXMgbm8gaXNzdWVzIHdpdGggZnJhZ21lbnRzXG4gICAgaWYgKCFjdXJMZXZlbC5mcmFnbWVudEVycm9yKSB7XG4gICAgICBjdXJMZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgdGhpcy5sZXZlbFJldHJ5Q291bnQgPSAwO1xuICAgIH1cbiAgICAvLyBpZiBjdXJyZW50IHBsYXlsaXN0IGlzIGEgbGl2ZSBwbGF5bGlzdCwgYXJtIGEgdGltZXIgdG8gcmVsb2FkIGl0XG4gICAgaWYgKGRldGFpbHMubGl2ZSkge1xuICAgICAgY29uc3QgcmVsb2FkSW50ZXJ2YWwgPSBjb21wdXRlUmVsb2FkSW50ZXJ2YWwoY3VyTGV2ZWwuZGV0YWlscywgZGV0YWlscywgZGF0YS5zdGF0cy50cmVxdWVzdCk7XG4gICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0LCByZWxvYWQgaW4gJHtNYXRoLnJvdW5kKHJlbG9hZEludGVydmFsKX0gbXNgKTtcbiAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMubG9hZExldmVsKCksIHJlbG9hZEludGVydmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgfVxuICB9XG5cbiAgb25BdWRpb1RyYWNrU3dpdGNoZWQgKGRhdGEpIHtcbiAgICBjb25zdCBhdWRpb0dyb3VwSWQgPSB0aGlzLmhscy5hdWRpb1RyYWNrc1tkYXRhLmlkXS5ncm91cElkO1xuXG4gICAgY29uc3QgY3VycmVudExldmVsID0gdGhpcy5obHMubGV2ZWxzW3RoaXMuY3VycmVudExldmVsSW5kZXhdO1xuICAgIGlmICghY3VycmVudExldmVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWRzKSB7XG4gICAgICBsZXQgdXJsSWQgPSAtMTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50TGV2ZWwuYXVkaW9Hcm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY3VycmVudExldmVsLmF1ZGlvR3JvdXBJZHNbaV0gPT09IGF1ZGlvR3JvdXBJZCkge1xuICAgICAgICAgIHVybElkID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodXJsSWQgIT09IGN1cnJlbnRMZXZlbC51cmxJZCkge1xuICAgICAgICBjdXJyZW50TGV2ZWwudXJsSWQgPSB1cmxJZDtcbiAgICAgICAgdGhpcy5zdGFydExvYWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsb2FkTGV2ZWwgKCkge1xuICAgIGxvZ2dlci5kZWJ1ZygnY2FsbCB0byBsb2FkTGV2ZWwnKTtcblxuICAgIGlmICh0aGlzLmN1cnJlbnRMZXZlbEluZGV4ICE9PSBudWxsICYmIHRoaXMuY2FubG9hZCkge1xuICAgICAgY29uc3QgbGV2ZWxPYmplY3QgPSB0aGlzLl9sZXZlbHNbdGhpcy5jdXJyZW50TGV2ZWxJbmRleF07XG5cbiAgICAgIGlmICh0eXBlb2YgbGV2ZWxPYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGxldmVsT2JqZWN0LnVybC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleDtcbiAgICAgICAgY29uc3QgaWQgPSBsZXZlbE9iamVjdC51cmxJZDtcbiAgICAgICAgY29uc3QgdXJsID0gbGV2ZWxPYmplY3QudXJsW2lkXTtcblxuICAgICAgICBsb2dnZXIubG9nKGBBdHRlbXB0IGxvYWRpbmcgbGV2ZWwgaW5kZXggJHtsZXZlbH0gd2l0aCBVUkwtaWQgJHtpZH1gKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnQ3VycmVudCBhdWRpbyB0cmFjayBncm91cCBJRDonLCB0aGlzLmhscy5hdWRpb1RyYWNrc1t0aGlzLmhscy5hdWRpb1RyYWNrXS5ncm91cElkKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ05ldyB2aWRlbyBxdWFsaXR5IGxldmVsIGF1ZGlvIGdyb3VwIGlkOicsIGxldmVsT2JqZWN0LmF0dHJzLkFVRElPLCBsZXZlbCk7XG5cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5MRVZFTF9MT0FESU5HLCB7IHVybCwgbGV2ZWwsIGlkIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBuZXh0TG9hZExldmVsICgpIHtcbiAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHRoaXMubWFudWFsTGV2ZWxJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgc2V0IG5leHRMb2FkTGV2ZWwgKG5leHRMZXZlbCkge1xuICAgIHRoaXMubGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgTGV2ZWxIZWxwZXJcbiAqXG4gKiBQcm92aWRpbmcgbWV0aG9kcyBkZWFsaW5nIHdpdGggcGxheWxpc3Qgc2xpZGluZyBhbmQgZHJpZnRcbiAqXG4gKiBUT0RPOiBDcmVhdGUgYW4gYWN0dWFsIGBMZXZlbGAgY2xhc3MvbW9kZWwgdGhhdCBkZWFscyB3aXRoIGFsbCB0aGlzIGxvZ2ljIGluIGFuIG9iamVjdC1vcmllbnRlZC1tYW5uZXIuXG4gKlxuICogKi9cblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEdyb3VwSWQgKGxldmVsLCB0eXBlLCBpZCkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgY2FzZSAnYXVkaW8nOlxuICAgIGlmICghbGV2ZWwuYXVkaW9Hcm91cElkcykge1xuICAgICAgbGV2ZWwuYXVkaW9Hcm91cElkcyA9IFtdO1xuICAgIH1cbiAgICBsZXZlbC5hdWRpb0dyb3VwSWRzLnB1c2goaWQpO1xuICAgIGJyZWFrO1xuICBjYXNlICd0ZXh0JzpcbiAgICBpZiAoIWxldmVsLnRleHRHcm91cElkcykge1xuICAgICAgbGV2ZWwudGV4dEdyb3VwSWRzID0gW107XG4gICAgfVxuICAgIGxldmVsLnRleHRHcm91cElkcy5wdXNoKGlkKTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlUFRTIChmcmFnbWVudHMsIGZyb21JZHgsIHRvSWR4KSB7XG4gIGxldCBmcmFnRnJvbSA9IGZyYWdtZW50c1tmcm9tSWR4XSwgZnJhZ1RvID0gZnJhZ21lbnRzW3RvSWR4XSwgZnJhZ1RvUFRTID0gZnJhZ1RvLnN0YXJ0UFRTO1xuICAvLyBpZiB3ZSBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuICBpZiAoTnVtYmVyLmlzRmluaXRlKGZyYWdUb1BUUykpIHtcbiAgICAvLyB1cGRhdGUgZnJhZ21lbnQgZHVyYXRpb24uXG4gICAgLy8gaXQgaGVscHMgdG8gZml4IGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0IHJlcG9ydGVkIGR1cmF0aW9uIGFuZCBmcmFnbWVudCByZWFsIGR1cmF0aW9uXG4gICAgaWYgKHRvSWR4ID4gZnJvbUlkeCkge1xuICAgICAgZnJhZ0Zyb20uZHVyYXRpb24gPSBmcmFnVG9QVFMgLSBmcmFnRnJvbS5zdGFydDtcbiAgICAgIGlmIChmcmFnRnJvbS5kdXJhdGlvbiA8IDApIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYG5lZ2F0aXZlIGR1cmF0aW9uIGNvbXB1dGVkIGZvciBmcmFnICR7ZnJhZ0Zyb20uc259LGxldmVsICR7ZnJhZ0Zyb20ubGV2ZWx9LCB0aGVyZSBzaG91bGQgYmUgc29tZSBkdXJhdGlvbiBkcmlmdCBiZXR3ZWVuIHBsYXlsaXN0IGFuZCBmcmFnbWVudCFgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZ1RvLmR1cmF0aW9uID0gZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG9QVFM7XG4gICAgICBpZiAoZnJhZ1RvLmR1cmF0aW9uIDwgMCkge1xuICAgICAgICBsb2dnZXIud2FybihgbmVnYXRpdmUgZHVyYXRpb24gY29tcHV0ZWQgZm9yIGZyYWcgJHtmcmFnVG8uc259LGxldmVsICR7ZnJhZ1RvLmxldmVsfSwgdGhlcmUgc2hvdWxkIGJlIHNvbWUgZHVyYXRpb24gZHJpZnQgYmV0d2VlbiBwbGF5bGlzdCBhbmQgZnJhZ21lbnQhYCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHdlIGRvbnQga25vdyBzdGFydFBUU1t0b0lkeF1cbiAgICBpZiAodG9JZHggPiBmcm9tSWR4KSB7XG4gICAgICBmcmFnVG8uc3RhcnQgPSBmcmFnRnJvbS5zdGFydCArIGZyYWdGcm9tLmR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnVG8uc3RhcnQgPSBNYXRoLm1heChmcmFnRnJvbS5zdGFydCAtIGZyYWdUby5kdXJhdGlvbiwgMCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVGcmFnUFRTRFRTIChkZXRhaWxzLCBmcmFnLCBzdGFydFBUUywgZW5kUFRTLCBzdGFydERUUywgZW5kRFRTKSB7XG4gIC8vIHVwZGF0ZSBmcmFnIFBUUy9EVFNcbiAgbGV0IG1heFN0YXJ0UFRTID0gc3RhcnRQVFM7XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoZnJhZy5zdGFydFBUUykpIHtcbiAgICAvLyBkZWx0YSBQVFMgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW9cbiAgICBsZXQgZGVsdGFQVFMgPSBNYXRoLmFicyhmcmFnLnN0YXJ0UFRTIC0gc3RhcnRQVFMpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGZyYWcuZGVsdGFQVFMpKSB7XG4gICAgICBmcmFnLmRlbHRhUFRTID0gZGVsdGFQVFM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcuZGVsdGFQVFMgPSBNYXRoLm1heChkZWx0YVBUUywgZnJhZy5kZWx0YVBUUyk7XG4gICAgfVxuXG4gICAgbWF4U3RhcnRQVFMgPSBNYXRoLm1heChzdGFydFBUUywgZnJhZy5zdGFydFBUUyk7XG4gICAgc3RhcnRQVFMgPSBNYXRoLm1pbihzdGFydFBUUywgZnJhZy5zdGFydFBUUyk7XG4gICAgZW5kUFRTID0gTWF0aC5tYXgoZW5kUFRTLCBmcmFnLmVuZFBUUyk7XG4gICAgc3RhcnREVFMgPSBNYXRoLm1pbihzdGFydERUUywgZnJhZy5zdGFydERUUyk7XG4gICAgZW5kRFRTID0gTWF0aC5tYXgoZW5kRFRTLCBmcmFnLmVuZERUUyk7XG4gIH1cblxuICBjb25zdCBkcmlmdCA9IHN0YXJ0UFRTIC0gZnJhZy5zdGFydDtcbiAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydFBUUztcbiAgZnJhZy5tYXhTdGFydFBUUyA9IG1heFN0YXJ0UFRTO1xuICBmcmFnLmVuZFBUUyA9IGVuZFBUUztcbiAgZnJhZy5zdGFydERUUyA9IHN0YXJ0RFRTO1xuICBmcmFnLmVuZERUUyA9IGVuZERUUztcbiAgZnJhZy5kdXJhdGlvbiA9IGVuZFBUUyAtIHN0YXJ0UFRTO1xuXG4gIGNvbnN0IHNuID0gZnJhZy5zbjtcbiAgLy8gZXhpdCBpZiBzbiBvdXQgb2YgcmFuZ2VcbiAgaWYgKCFkZXRhaWxzIHx8IHNuIDwgZGV0YWlscy5zdGFydFNOIHx8IHNuID4gZGV0YWlscy5lbmRTTikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgbGV0IGZyYWdJZHgsIGZyYWdtZW50cywgaTtcbiAgZnJhZ0lkeCA9IHNuIC0gZGV0YWlscy5zdGFydFNOO1xuICBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcbiAgLy8gdXBkYXRlIGZyYWcgcmVmZXJlbmNlIGluIGZyYWdtZW50cyBhcnJheVxuICAvLyByYXRpb25hbGUgaXMgdGhhdCBmcmFnbWVudHMgYXJyYXkgbWlnaHQgbm90IGNvbnRhaW4gdGhpcyBmcmFnIG9iamVjdC5cbiAgLy8gdGhpcyB3aWxsIGhhcHBlbiBpZiBwbGF5bGlzdCBoYXMgYmVlbiByZWZyZXNoZWQgYmV0d2VlbiBmcmFnIGxvYWRpbmcgYW5kIGNhbGwgdG8gdXBkYXRlRnJhZ1BUU0RUUygpXG4gIC8vIGlmIHdlIGRvbid0IHVwZGF0ZSBmcmFnLCB3ZSB3b24ndCBiZSBhYmxlIHRvIHByb3BhZ2F0ZSBQVFMgaW5mbyBvbiB0aGUgcGxheWxpc3RcbiAgLy8gcmVzdWx0aW5nIGluIGludmFsaWQgc2xpZGluZyBjb21wdXRhdGlvblxuICBmcmFnbWVudHNbZnJhZ0lkeF0gPSBmcmFnO1xuICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtLTEgdG8gZnJhZyAwXG4gIGZvciAoaSA9IGZyYWdJZHg7IGkgPiAwOyBpLS0pIHtcbiAgICB1cGRhdGVQVFMoZnJhZ21lbnRzLCBpLCBpIC0gMSk7XG4gIH1cblxuICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtIHRvIGxhc3QgZnJhZ1xuICBmb3IgKGkgPSBmcmFnSWR4OyBpIDwgZnJhZ21lbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHVwZGF0ZVBUUyhmcmFnbWVudHMsIGksIGkgKyAxKTtcbiAgfVxuXG4gIGRldGFpbHMuUFRTS25vd24gPSB0cnVlO1xuICByZXR1cm4gZHJpZnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZURldGFpbHMgKG9sZERldGFpbHMsIG5ld0RldGFpbHMpIHtcbiAgLy8gcG90ZW50aWFsbHkgcmV0cmlldmUgY2FjaGVkIGluaXRzZWdtZW50XG4gIGlmIChuZXdEZXRhaWxzLmluaXRTZWdtZW50ICYmIG9sZERldGFpbHMuaW5pdFNlZ21lbnQpIHtcbiAgICBuZXdEZXRhaWxzLmluaXRTZWdtZW50ID0gb2xkRGV0YWlscy5pbml0U2VnbWVudDtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIG9sZC9uZXcgcGxheWxpc3RzIGhhdmUgZnJhZ21lbnRzIGluIGNvbW1vblxuICAvLyBsb29wIHRocm91Z2ggb3ZlcmxhcHBpbmcgU04gYW5kIHVwZGF0ZSBzdGFydFBUUyAsIGNjLCBhbmQgZHVyYXRpb24gaWYgYW55IGZvdW5kXG4gIGxldCBjY09mZnNldCA9IDA7XG4gIGxldCBQVFNGcmFnO1xuICBtYXBGcmFnbWVudEludGVyc2VjdGlvbihvbGREZXRhaWxzLCBuZXdEZXRhaWxzLCAob2xkRnJhZywgbmV3RnJhZykgPT4ge1xuICAgIGNjT2Zmc2V0ID0gb2xkRnJhZy5jYyAtIG5ld0ZyYWcuY2M7XG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShvbGRGcmFnLnN0YXJ0UFRTKSkge1xuICAgICAgbmV3RnJhZy5zdGFydCA9IG5ld0ZyYWcuc3RhcnRQVFMgPSBvbGRGcmFnLnN0YXJ0UFRTO1xuICAgICAgbmV3RnJhZy5lbmRQVFMgPSBvbGRGcmFnLmVuZFBUUztcbiAgICAgIG5ld0ZyYWcuZHVyYXRpb24gPSBvbGRGcmFnLmR1cmF0aW9uO1xuICAgICAgbmV3RnJhZy5iYWNrdHJhY2tlZCA9IG9sZEZyYWcuYmFja3RyYWNrZWQ7XG4gICAgICBuZXdGcmFnLmRyb3BwZWQgPSBvbGRGcmFnLmRyb3BwZWQ7XG4gICAgICBQVFNGcmFnID0gbmV3RnJhZztcbiAgICB9XG4gICAgLy8gUFRTIGlzIGtub3duIHdoZW4gdGhlcmUgYXJlIG92ZXJsYXBwaW5nIHNlZ21lbnRzXG4gICAgbmV3RGV0YWlscy5QVFNLbm93biA9IHRydWU7XG4gIH0pO1xuXG4gIGlmICghbmV3RGV0YWlscy5QVFNLbm93bikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjY09mZnNldCkge1xuICAgIGxvZ2dlci5sb2coJ2Rpc2NvbnRpbnVpdHkgc2xpZGluZyBmcm9tIHBsYXlsaXN0LCB0YWtlIGRyaWZ0IGludG8gYWNjb3VudCcpO1xuICAgIGNvbnN0IG5ld0ZyYWdtZW50cyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3RnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXdGcmFnbWVudHNbaV0uY2MgKz0gY2NPZmZzZXQ7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgYXQgbGVhc3Qgb25lIGZyYWdtZW50IGNvbnRhaW5zIFBUUyBpbmZvLCByZWNvbXB1dGUgUFRTIGluZm9ybWF0aW9uIGZvciBhbGwgZnJhZ21lbnRzXG4gIGlmIChQVFNGcmFnKSB7XG4gICAgdXBkYXRlRnJhZ1BUU0RUUyhuZXdEZXRhaWxzLCBQVFNGcmFnLCBQVFNGcmFnLnN0YXJ0UFRTLCBQVFNGcmFnLmVuZFBUUywgUFRTRnJhZy5zdGFydERUUywgUFRTRnJhZy5lbmREVFMpO1xuICB9IGVsc2Uge1xuICAgIC8vIGVuc3VyZSB0aGF0IGRlbHRhIGlzIHdpdGhpbiBvbGRGcmFnbWVudHMgcmFuZ2VcbiAgICAvLyBhbHNvIGFkanVzdCBzbGlkaW5nIGluIGNhc2UgZGVsdGEgaXMgMCAod2UgY291bGQgaGF2ZSBvbGQ9WzUwLTYwXSBhbmQgbmV3PW9sZD1bNTAtNjFdKVxuICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBhbHNvIG5lZWQgdG8gYWRqdXN0IHN0YXJ0IG9mZnNldCBvZiBhbGwgZnJhZ21lbnRzXG4gICAgYWRqdXN0U2xpZGluZyhvbGREZXRhaWxzLCBuZXdEZXRhaWxzKTtcbiAgfVxuICAvLyBpZiB3ZSBhcmUgaGVyZSwgaXQgbWVhbnMgd2UgaGF2ZSBmcmFnbWVudHMgb3ZlcmxhcHBpbmcgYmV0d2VlblxuICAvLyBvbGQgYW5kIG5ldyBsZXZlbC4gcmVsaWFibGUgUFRTIGluZm8gaXMgdGh1cyByZWx5aW5nIG9uIG9sZCBsZXZlbFxuICBuZXdEZXRhaWxzLlBUU0tub3duID0gb2xkRGV0YWlscy5QVFNLbm93bjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU3VidGl0bGVQbGF5bGlzdHMgKG9sZFBsYXlsaXN0LCBuZXdQbGF5bGlzdCwgcmVmZXJlbmNlU3RhcnQgPSAwKSB7XG4gIGxldCBsYXN0SW5kZXggPSAtMTtcbiAgbWFwRnJhZ21lbnRJbnRlcnNlY3Rpb24ob2xkUGxheWxpc3QsIG5ld1BsYXlsaXN0LCAob2xkRnJhZywgbmV3RnJhZywgaW5kZXgpID0+IHtcbiAgICBuZXdGcmFnLnN0YXJ0ID0gb2xkRnJhZy5zdGFydDtcbiAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgfSk7XG5cbiAgY29uc3QgZnJhZ3MgPSBuZXdQbGF5bGlzdC5mcmFnbWVudHM7XG4gIGlmIChsYXN0SW5kZXggPCAwKSB7XG4gICAgZnJhZ3MuZm9yRWFjaChmcmFnID0+IHtcbiAgICAgIGZyYWcuc3RhcnQgKz0gcmVmZXJlbmNlU3RhcnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IGxhc3RJbmRleCArIDE7IGkgPCBmcmFncy5sZW5ndGg7IGkrKykge1xuICAgIGZyYWdzW2ldLnN0YXJ0ID0gKGZyYWdzW2kgLSAxXS5zdGFydCArIGZyYWdzW2kgLSAxXS5kdXJhdGlvbik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcEZyYWdtZW50SW50ZXJzZWN0aW9uIChvbGRQbGF5bGlzdCwgbmV3UGxheWxpc3QsIGludGVyc2VjdGlvbkZuKSB7XG4gIGlmICghb2xkUGxheWxpc3QgfHwgIW5ld1BsYXlsaXN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChvbGRQbGF5bGlzdC5zdGFydFNOLCBuZXdQbGF5bGlzdC5zdGFydFNOKSAtIG5ld1BsYXlsaXN0LnN0YXJ0U047XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKG9sZFBsYXlsaXN0LmVuZFNOLCBuZXdQbGF5bGlzdC5lbmRTTikgLSBuZXdQbGF5bGlzdC5zdGFydFNOO1xuICBjb25zdCBkZWx0YSA9IG5ld1BsYXlsaXN0LnN0YXJ0U04gLSBvbGRQbGF5bGlzdC5zdGFydFNOO1xuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgIGNvbnN0IG9sZEZyYWcgPSBvbGRQbGF5bGlzdC5mcmFnbWVudHNbZGVsdGEgKyBpXTtcbiAgICBjb25zdCBuZXdGcmFnID0gbmV3UGxheWxpc3QuZnJhZ21lbnRzW2ldO1xuICAgIGlmICghb2xkRnJhZyB8fCAhbmV3RnJhZykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGludGVyc2VjdGlvbkZuKG9sZEZyYWcsIG5ld0ZyYWcsIGkpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGp1c3RTbGlkaW5nIChvbGRQbGF5bGlzdCwgbmV3UGxheWxpc3QpIHtcbiAgY29uc3QgZGVsdGEgPSBuZXdQbGF5bGlzdC5zdGFydFNOIC0gb2xkUGxheWxpc3Quc3RhcnRTTjtcbiAgY29uc3Qgb2xkRnJhZ21lbnRzID0gb2xkUGxheWxpc3QuZnJhZ21lbnRzO1xuICBjb25zdCBuZXdGcmFnbWVudHMgPSBuZXdQbGF5bGlzdC5mcmFnbWVudHM7XG5cbiAgaWYgKGRlbHRhIDwgMCB8fCBkZWx0YSA+IG9sZEZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdGcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBuZXdGcmFnbWVudHNbaV0uc3RhcnQgKz0gb2xkRnJhZ21lbnRzW2RlbHRhXS5zdGFydDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVJlbG9hZEludGVydmFsIChjdXJyZW50UGxheWxpc3QsIG5ld1BsYXlsaXN0LCBsYXN0UmVxdWVzdFRpbWUpIHtcbiAgbGV0IHJlbG9hZEludGVydmFsID0gMTAwMCAqIChuZXdQbGF5bGlzdC5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gPyBuZXdQbGF5bGlzdC5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gOiBuZXdQbGF5bGlzdC50YXJnZXRkdXJhdGlvbik7XG4gIGNvbnN0IG1pblJlbG9hZEludGVydmFsID0gcmVsb2FkSW50ZXJ2YWwgLyAyO1xuICBpZiAoY3VycmVudFBsYXlsaXN0ICYmIG5ld1BsYXlsaXN0LmVuZFNOID09PSBjdXJyZW50UGxheWxpc3QuZW5kU04pIHtcbiAgICAvLyBmb2xsb3cgSExTIFNwZWMsIElmIHRoZSBjbGllbnQgcmVsb2FkcyBhIFBsYXlsaXN0IGZpbGUgYW5kIGZpbmRzIHRoYXQgaXQgaGFzIG5vdFxuICAgIC8vIGNoYW5nZWQgdGhlbiBpdCBNVVNUIHdhaXQgZm9yIGEgcGVyaW9kIG9mIG9uZS1oYWxmIHRoZSB0YXJnZXRcbiAgICAvLyBkdXJhdGlvbiBiZWZvcmUgcmV0cnlpbmcuXG4gICAgcmVsb2FkSW50ZXJ2YWwgPSBtaW5SZWxvYWRJbnRlcnZhbDtcbiAgfVxuXG4gIGlmIChsYXN0UmVxdWVzdFRpbWUpIHtcbiAgICByZWxvYWRJbnRlcnZhbCA9IE1hdGgubWF4KG1pblJlbG9hZEludGVydmFsLCByZWxvYWRJbnRlcnZhbCAtICh3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLSBsYXN0UmVxdWVzdFRpbWUpKTtcbiAgfVxuICAvLyBpbiBhbnkgY2FzZSwgZG9uJ3QgcmVsb2FkIG1vcmUgdGhhbiBoYWxmIG9mIHRhcmdldCBkdXJhdGlvblxuICByZXR1cm4gTWF0aC5yb3VuZChyZWxvYWRJbnRlcnZhbCk7XG59XG4iLCIvKlxuICogU3RyZWFtIENvbnRyb2xsZXJcbiovXG5cbmltcG9ydCBCaW5hcnlTZWFyY2ggZnJvbSAnLi4vdXRpbHMvYmluYXJ5LXNlYXJjaCc7XG5pbXBvcnQgeyBCdWZmZXJIZWxwZXIgfSBmcm9tICcuLi91dGlscy9idWZmZXItaGVscGVyJztcbmltcG9ydCBEZW11eGVyIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXInO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBGcmFnbWVudFN0YXRlIH0gZnJvbSAnLi9mcmFnbWVudC10cmFja2VyJztcbmltcG9ydCBGcmFnbWVudCBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xuaW1wb3J0IFBsYXlsaXN0TG9hZGVyIGZyb20gJy4uL2xvYWRlci9wbGF5bGlzdC1sb2FkZXInO1xuaW1wb3J0ICogYXMgTGV2ZWxIZWxwZXIgZnJvbSAnLi9sZXZlbC1oZWxwZXInO1xuaW1wb3J0IFRpbWVSYW5nZXMgZnJvbSAnLi4vdXRpbHMvdGltZS1yYW5nZXMnO1xuaW1wb3J0IHsgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBhbGlnblN0cmVhbSB9IGZyb20gJy4uL3V0aWxzL2Rpc2NvbnRpbnVpdGllcyc7XG5pbXBvcnQgeyBmaW5kRnJhZ21lbnRCeVBEVCwgZmluZEZyYWdtZW50QnlQVFMgfSBmcm9tICcuL2ZyYWdtZW50LWZpbmRlcnMnO1xuaW1wb3J0IEdhcENvbnRyb2xsZXIgZnJvbSAnLi9nYXAtY29udHJvbGxlcic7XG5pbXBvcnQgQmFzZVN0cmVhbUNvbnRyb2xsZXIsIHsgU3RhdGUgfSBmcm9tICcuL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXInO1xuXG5jb25zdCBUSUNLX0lOVEVSVkFMID0gMTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuXG5jbGFzcyBTdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgQmFzZVN0cmVhbUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzLCBmcmFnbWVudFRyYWNrZXIpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURJTkcsXG4gICAgICBFdmVudC5NQU5JRkVTVF9QQVJTRUQsXG4gICAgICBFdmVudC5MRVZFTF9MT0FERUQsXG4gICAgICBFdmVudC5LRVlfTE9BREVELFxuICAgICAgRXZlbnQuRlJBR19MT0FERUQsXG4gICAgICBFdmVudC5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULFxuICAgICAgRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsXG4gICAgICBFdmVudC5GUkFHX1BBUlNFRCxcbiAgICAgIEV2ZW50LkVSUk9SLFxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENISU5HLFxuICAgICAgRXZlbnQuQVVESU9fVFJBQ0tfU1dJVENIRUQsXG4gICAgICBFdmVudC5CVUZGRVJfQ1JFQVRFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9BUFBFTkRFRCxcbiAgICAgIEV2ZW50LkJVRkZFUl9GTFVTSEVEKTtcblxuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy5fc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuZ2FwQ29udHJvbGxlciA9IG51bGw7XG4gIH1cblxuICBzdGFydExvYWQgKHN0YXJ0UG9zaXRpb24pIHtcbiAgICBpZiAodGhpcy5sZXZlbHMpIHtcbiAgICAgIGxldCBsYXN0Q3VycmVudFRpbWUgPSB0aGlzLmxhc3RDdXJyZW50VGltZSwgaGxzID0gdGhpcy5obHM7XG4gICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwpO1xuICAgICAgdGhpcy5sZXZlbCA9IC0xO1xuICAgICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIGxvYWQgbGV2ZWxcbiAgICAgICAgbGV0IHN0YXJ0TGV2ZWwgPSBobHMuc3RhcnRMZXZlbDtcbiAgICAgICAgaWYgKHN0YXJ0TGV2ZWwgPT09IC0xKSB7XG4gICAgICAgICAgLy8gLTEgOiBndWVzcyBzdGFydCBMZXZlbCBieSBkb2luZyBhIGJpdHJhdGUgdGVzdCBieSBsb2FkaW5nIGZpcnN0IGZyYWdtZW50IG9mIGxvd2VzdCBxdWFsaXR5IGxldmVsXG4gICAgICAgICAgc3RhcnRMZXZlbCA9IDA7XG4gICAgICAgICAgdGhpcy5iaXRyYXRlVGVzdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IG5ldyBsZXZlbCB0byBwbGF5bGlzdCBsb2FkZXIgOiB0aGlzIHdpbGwgdHJpZ2dlciBzdGFydCBsZXZlbCBsb2FkXG4gICAgICAgIC8vIGhscy5uZXh0TG9hZExldmVsIHJlbWFpbnMgdW50aWwgaXQgaXMgc2V0IHRvIGEgbmV3IHZhbHVlIG9yIHVudGlsIGEgbmV3IGZyYWcgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZFxuICAgICAgICB0aGlzLmxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWwgPSBzdGFydExldmVsO1xuICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBpZiBzdGFydFBvc2l0aW9uIHVuZGVmaW5lZCBidXQgbGFzdEN1cnJlbnRUaW1lIHNldCwgc2V0IHN0YXJ0UG9zaXRpb24gdG8gbGFzdCBjdXJyZW50VGltZVxuICAgICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgb3ZlcnJpZGUgc3RhcnRQb3NpdGlvbiB3aXRoIGxhc3RDdXJyZW50VGltZSBAJHtsYXN0Q3VycmVudFRpbWUudG9GaXhlZCgzKX1gKTtcbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IGxhc3RDdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm9yY2VTdGFydExvYWQgPSB0cnVlO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgfVxuICB9XG5cbiAgc3RvcExvYWQgKCkge1xuICAgIHRoaXMuZm9yY2VTdGFydExvYWQgPSBmYWxzZTtcbiAgICBzdXBlci5zdG9wTG9hZCgpO1xuICB9XG5cbiAgZG9UaWNrICgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICBjYXNlIFN0YXRlLkJVRkZFUl9GTFVTSElORzpcbiAgICAgIC8vIGluIGJ1ZmZlciBmbHVzaGluZyBzdGF0ZSwgcmVzZXQgZnJhZ0xvYWRFcnJvciBjb3VudGVyXG4gICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTdGF0ZS5JRExFOlxuICAgICAgdGhpcy5fZG9UaWNrSWRsZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTdGF0ZS5XQUlUSU5HX0xFVkVMOlxuICAgICAgdmFyIGxldmVsID0gdGhpcy5sZXZlbHNbdGhpcy5sZXZlbF07XG4gICAgICAvLyBjaGVjayBpZiBwbGF5bGlzdCBpcyBhbHJlYWR5IGxvYWRlZFxuICAgICAgaWYgKGxldmVsICYmIGxldmVsLmRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICB2YXIgbm93ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdmFyIHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlO1xuICAgICAgLy8gaWYgY3VycmVudCB0aW1lIGlzIGd0IHRoYW4gcmV0cnlEYXRlLCBvciBpZiBtZWRpYSBzZWVraW5nIGxldCdzIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgIGlmICghcmV0cnlEYXRlIHx8IChub3cgPj0gcmV0cnlEYXRlKSB8fCAodGhpcy5tZWRpYSAmJiB0aGlzLm1lZGlhLnNlZWtpbmcpKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ21lZGlhQ29udHJvbGxlcjogcmV0cnlEYXRlIHJlYWNoZWQsIHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUnKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFN0YXRlLkVSUk9SOlxuICAgIGNhc2UgU3RhdGUuU1RPUFBFRDpcbiAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElORzpcbiAgICBjYXNlIFN0YXRlLlBBUlNJTkc6XG4gICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XG4gICAgY2FzZSBTdGF0ZS5FTkRFRDpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gY2hlY2sgYnVmZmVyXG4gICAgdGhpcy5fY2hlY2tCdWZmZXIoKTtcbiAgICAvLyBjaGVjay91cGRhdGUgY3VycmVudCBmcmFnbWVudFxuICAgIHRoaXMuX2NoZWNrRnJhZ21lbnRDaGFuZ2VkKCk7XG4gIH1cblxuICAvLyBJcm9uaWNhbGx5IHRoZSBcImlkbGVcIiBzdGF0ZSBpcyB0aGUgb24gd2UgZG8gdGhlIG1vc3QgbG9naWMgaW4gaXQgc2VlbXMgLi4uLlxuICAvLyBOT1RFOiBNYXliZSB3ZSBjb3VsZCByYXRoZXIgc2NoZWR1bGUgYSBjaGVjayBmb3IgYnVmZmVyIGxlbmd0aCBhZnRlciBoYWxmIG9mIHRoZSBjdXJyZW50bHlcbiAgLy8gICAgICAgcGxheWVkIHNlZ21lbnQsIG9yIG9uIHBhdXNlL3BsYXkvc2VlayBpbnN0ZWFkIG9mIG5haXZlbHkgY2hlY2tpbmcgZXZlcnkgMTAwbXM/XG4gIF9kb1RpY2tJZGxlICgpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscyxcbiAgICAgIGNvbmZpZyA9IGhscy5jb25maWcsXG4gICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG5cbiAgICAvLyBpZiBzdGFydCBsZXZlbCBub3QgcGFyc2VkIHlldCBPUlxuICAgIC8vIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkQgc3RhcnQgZnJhZ21lbnQgYWxyZWFkeSByZXF1ZXN0ZWQgT1Igc3RhcnQgZnJhZyBwcmVmZXRjaCBkaXNhYmxlXG4gICAgLy8gZXhpdCBsb29wLCBhcyB3ZSBlaXRoZXIgbmVlZCBtb3JlIGluZm8gKGxldmVsIG5vdCBwYXJzZWQpIG9yIHdlIG5lZWQgbWVkaWEgdG8gYmUgYXR0YWNoZWQgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICBpZiAodGhpcy5sZXZlbExhc3RMb2FkZWQgPT09IHVuZGVmaW5lZCB8fCAoXG4gICAgICAhbWVkaWEgJiYgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkZWQgYW55IGZyYWdtZW50LCBzdGFydCBsb2FkaW5nIGZyb20gc3RhcnQgcG9zaXRpb25cbiAgICBsZXQgcG9zO1xuICAgIGlmICh0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICBwb3MgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zID0gdGhpcy5uZXh0TG9hZFBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8vIGRldGVybWluZSBuZXh0IGxvYWQgbGV2ZWxcbiAgICBsZXQgbGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCxcbiAgICAgIGxldmVsSW5mbyA9IHRoaXMubGV2ZWxzW2xldmVsXTtcblxuICAgIGlmICghbGV2ZWxJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGxldmVsQml0cmF0ZSA9IGxldmVsSW5mby5iaXRyYXRlLFxuICAgICAgbWF4QnVmTGVuO1xuXG4gICAgLy8gY29tcHV0ZSBtYXggQnVmZmVyIExlbmd0aCB0aGF0IHdlIGNvdWxkIGdldCBmcm9tIHRoaXMgbG9hZCBsZXZlbCwgYmFzZWQgb24gbGV2ZWwgYml0cmF0ZS4gZG9uJ3QgYnVmZmVyIG1vcmUgdGhhbiA2MCBNQiBhbmQgbW9yZSB0aGFuIDMwc1xuICAgIGlmIChsZXZlbEJpdHJhdGUpIHtcbiAgICAgIG1heEJ1ZkxlbiA9IE1hdGgubWF4KDggKiBjb25maWcubWF4QnVmZmVyU2l6ZSAvIGxldmVsQml0cmF0ZSwgY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heEJ1ZkxlbiA9IGNvbmZpZy5tYXhCdWZmZXJMZW5ndGg7XG4gICAgfVxuXG4gICAgbWF4QnVmTGVuID0gTWF0aC5taW4obWF4QnVmTGVuLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKTtcblxuICAgIC8vIGRldGVybWluZSBuZXh0IGNhbmRpZGF0ZSBmcmFnbWVudCB0byBiZSBsb2FkZWQsIGJhc2VkIG9uIGN1cnJlbnQgcG9zaXRpb24gYW5kIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAvLyBlbnN1cmUgdXAgdG8gYGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGhgIG9mIGJ1ZmZlciB1cGZyb250XG5cbiAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8odGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiBtZWRpYSwgcG9zLCBjb25maWcubWF4QnVmZmVySG9sZSksXG4gICAgICBidWZmZXJMZW4gPSBidWZmZXJJbmZvLmxlbjtcbiAgICAvLyBTdGF5IGlkbGUgaWYgd2UgYXJlIHN0aWxsIHdpdGggYnVmZmVyIG1hcmdpbnNcbiAgICBpZiAoYnVmZmVyTGVuID49IG1heEJ1Zkxlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudCAuLi5cbiAgICBsb2dnZXIudHJhY2UoYGJ1ZmZlciBsZW5ndGggb2YgJHtidWZmZXJMZW4udG9GaXhlZCgzKX0gaXMgYmVsb3cgbWF4IG9mICR7bWF4QnVmTGVuLnRvRml4ZWQoMyl9LiBjaGVja2luZyBmb3IgbW9yZSBwYXlsb2FkIC4uLmApO1xuXG4gICAgLy8gc2V0IG5leHQgbG9hZCBsZXZlbCA6IHRoaXMgd2lsbCB0cmlnZ2VyIGEgcGxheWxpc3QgbG9hZCBpZiBuZWVkZWRcbiAgICB0aGlzLmxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcblxuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzO1xuICAgIC8vIGlmIGxldmVsIGluZm8gbm90IHJldHJpZXZlZCB5ZXQsIHN3aXRjaCBzdGF0ZSBhbmQgd2FpdCBmb3IgbGV2ZWwgcmV0cmlldmFsXG4gICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCwgZW5zdXJlIHRoYXQgbmV3IHBsYXlsaXN0IGhhcyBiZWVuIHJlZnJlc2hlZCB0byBhdm9pZCBsb2FkaW5nL3RyeSB0byBsb2FkXG4gICAgLy8gYSB1c2VsZXNzIGFuZCBvdXRkYXRlZCBmcmFnbWVudCAodGhhdCBtaWdodCBldmVuIGludHJvZHVjZSBsb2FkIGVycm9yIGlmIGl0IGlzIGFscmVhZHkgb3V0IG9mIHRoZSBsaXZlIHBsYXlsaXN0KVxuICAgIGlmICghbGV2ZWxEZXRhaWxzIHx8IChsZXZlbERldGFpbHMubGl2ZSAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbGV2ZWwpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RyZWFtRW5kZWQoYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzKSkge1xuICAgICAgY29uc3QgZGF0YSA9IHt9O1xuICAgICAgaWYgKHRoaXMuYWx0QXVkaW8pIHtcbiAgICAgICAgZGF0YS50eXBlID0gJ3ZpZGVvJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5CVUZGRVJfRU9TLCBkYXRhKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gaWYgd2UgaGF2ZSB0aGUgbGV2ZWxEZXRhaWxzIGZvciB0aGUgc2VsZWN0ZWQgdmFyaWFudCwgbGV0cyBjb250aW51ZSBlbnJpY2hlbiBvdXIgc3RyZWFtIChsb2FkIGtleXMvZnJhZ21lbnRzIG9yIHRyaWdnZXIgRU9TLCBldGMuLilcbiAgICB0aGlzLl9mZXRjaFBheWxvYWRPckVvcyhwb3MsIGJ1ZmZlckluZm8sIGxldmVsRGV0YWlscyk7XG4gIH1cblxuICBfZmV0Y2hQYXlsb2FkT3JFb3MgKHBvcywgYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgY29uc3QgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXMsXG4gICAgICBsZXZlbCA9IHRoaXMubGV2ZWwsXG4gICAgICBmcmFnbWVudHMgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzLFxuICAgICAgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGg7XG5cbiAgICAvLyBlbXB0eSBwbGF5bGlzdFxuICAgIGlmIChmcmFnTGVuID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICBsZXQgc3RhcnQgPSBmcmFnbWVudHNbMF0uc3RhcnQsXG4gICAgICBlbmQgPSBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdLnN0YXJ0ICsgZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXS5kdXJhdGlvbixcbiAgICAgIGJ1ZmZlckVuZCA9IGJ1ZmZlckluZm8uZW5kLFxuICAgICAgZnJhZztcblxuICAgIGlmIChsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQgJiYgIWxldmVsRGV0YWlscy5pbml0U2VnbWVudC5kYXRhKSB7XG4gICAgICBmcmFnID0gbGV2ZWxEZXRhaWxzLmluaXRTZWdtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbiBjYXNlIG9mIGxpdmUgcGxheWxpc3Qgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCByZXF1ZXN0ZWQgcG9zaXRpb24gaXMgbm90IGxvY2F0ZWQgYmVmb3JlIHBsYXlsaXN0IHN0YXJ0XG4gICAgICBpZiAobGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgbGV0IGluaXRpYWxMaXZlTWFuaWZlc3RTaXplID0gdGhpcy5jb25maWcuaW5pdGlhbExpdmVNYW5pZmVzdFNpemU7XG4gICAgICAgIGlmIChmcmFnTGVuIDwgaW5pdGlhbExpdmVNYW5pZmVzdFNpemUpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgQ2FuIG5vdCBzdGFydCBwbGF5YmFjayBvZiBhIGxldmVsLCByZWFzb246IG5vdCBlbm91Z2ggZnJhZ21lbnRzICR7ZnJhZ0xlbn0gPCAke2luaXRpYWxMaXZlTWFuaWZlc3RTaXplfWApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYWcgPSB0aGlzLl9lbnN1cmVGcmFnbWVudEF0TGl2ZVBvaW50KGxldmVsRGV0YWlscywgYnVmZmVyRW5kLCBzdGFydCwgZW5kLCBmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgZnJhZ0xlbik7XG4gICAgICAgIC8vIGlmIGl0IGV4cGxpY2l0ZWx5IHJldHVybnMgbnVsbCBkb24ndCBsb2FkIGFueSBmcmFnbWVudCBhbmQgZXhpdCBmdW5jdGlvbiBub3dcbiAgICAgICAgaWYgKGZyYWcgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFZvRCBwbGF5bGlzdDogaWYgYnVmZmVyRW5kIGJlZm9yZSBzdGFydCBvZiBwbGF5bGlzdCwgbG9hZCBmaXJzdCBmcmFnbWVudFxuICAgICAgICBpZiAoYnVmZmVyRW5kIDwgc3RhcnQpIHtcbiAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZnJhZykge1xuICAgICAgZnJhZyA9IHRoaXMuX2ZpbmRGcmFnbWVudChzdGFydCwgZnJhZ1ByZXZpb3VzLCBmcmFnTGVuLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgZW5kLCBsZXZlbERldGFpbHMpO1xuICAgIH1cblxuICAgIGlmIChmcmFnKSB7XG4gICAgICBpZiAoZnJhZy5lbmNyeXB0ZWQpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgTG9hZGluZyBrZXkgZm9yICR7ZnJhZy5zbn0gb2YgWyR7bGV2ZWxEZXRhaWxzLnN0YXJ0U059ICwke2xldmVsRGV0YWlscy5lbmRTTn1dLGxldmVsICR7bGV2ZWx9YCk7XG4gICAgICAgIHRoaXMuX2xvYWRLZXkoZnJhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIubG9nKGBMb2FkaW5nICR7ZnJhZy5zbn0gb2YgWyR7bGV2ZWxEZXRhaWxzLnN0YXJ0U059ICwke2xldmVsRGV0YWlscy5lbmRTTn1dLGxldmVsICR7bGV2ZWx9LCBjdXJyZW50VGltZToke3Bvcy50b0ZpeGVkKDMpfSxidWZmZXJFbmQ6JHtidWZmZXJFbmQudG9GaXhlZCgzKX1gKTtcbiAgICAgICAgdGhpcy5fbG9hZEZyYWdtZW50KGZyYWcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9lbnN1cmVGcmFnbWVudEF0TGl2ZVBvaW50IChsZXZlbERldGFpbHMsIGJ1ZmZlckVuZCwgc3RhcnQsIGVuZCwgZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGZyYWdMZW4pIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWcsIG1lZGlhID0gdGhpcy5tZWRpYTtcblxuICAgIGxldCBmcmFnO1xuXG4gICAgLy8gY2hlY2sgaWYgcmVxdWVzdGVkIHBvc2l0aW9uIGlzIHdpdGhpbiBzZWVrYWJsZSBib3VuZGFyaWVzIDpcbiAgICAvLyBsb2dnZXIubG9nKGBzdGFydC9wb3MvYnVmRW5kL3NlZWtpbmc6JHtzdGFydC50b0ZpeGVkKDMpfS8ke3Bvcy50b0ZpeGVkKDMpfS8ke2J1ZmZlckVuZC50b0ZpeGVkKDMpfS8ke3RoaXMubWVkaWEuc2Vla2luZ31gKTtcbiAgICBsZXQgbWF4TGF0ZW5jeSA9IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA6IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG5cbiAgICBpZiAoYnVmZmVyRW5kIDwgTWF0aC5tYXgoc3RhcnQgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZW5kIC0gbWF4TGF0ZW5jeSkpIHtcbiAgICAgIGxldCBsaXZlU3luY1Bvc2l0aW9uID0gdGhpcy5saXZlU3luY1Bvc2l0aW9uID0gdGhpcy5jb21wdXRlTGl2ZVBvc2l0aW9uKHN0YXJ0LCBsZXZlbERldGFpbHMpO1xuICAgICAgbG9nZ2VyLmxvZyhgYnVmZmVyIGVuZDogJHtidWZmZXJFbmQudG9GaXhlZCgzKX0gaXMgbG9jYXRlZCB0b28gZmFyIGZyb20gdGhlIGVuZCBvZiBsaXZlIHNsaWRpbmcgcGxheWxpc3QsIHJlc2V0IGN1cnJlbnRUaW1lIHRvIDogJHtsaXZlU3luY1Bvc2l0aW9uLnRvRml4ZWQoMyl9YCk7XG4gICAgICBidWZmZXJFbmQgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgaWYgKG1lZGlhICYmIG1lZGlhLnJlYWR5U3RhdGUgJiYgbWVkaWEuZHVyYXRpb24gPiBsaXZlU3luY1Bvc2l0aW9uKSB7XG4gICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvLyBpZiBlbmQgb2YgYnVmZmVyIGdyZWF0ZXIgdGhhbiBsaXZlIGVkZ2UsIGRvbid0IGxvYWQgYW55IGZyYWdtZW50XG4gICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaWYgbGl2ZSBwbGF5bGlzdCBpbnRlcm1pdHRlbnRseSBzbGlkZXMgaW4gdGhlIHBhc3QuXG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MSwxODI1ODAxNjddXG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MiwxODI1ODAxNjldXG4gICAgLy8gTG9hZGluZyAxODI1ODAxNjggb2YgWzE4MjU4MDE2MiAsMTgyNTgwMTY5XSxsZXZlbCAxIC4uXG4gICAgLy8gTG9hZGluZyAxODI1ODAxNjkgb2YgWzE4MjU4MDE2MiAsMTgyNTgwMTY5XSxsZXZlbCAxIC4uXG4gICAgLy8gbGV2ZWwgMSBsb2FkZWQgWzE4MjU4MDE2MiwxODI1ODAxNjhdIDw9PT09PT09PT09PT09IGhlcmUgd2Ugc2hvdWxkIGhhdmUgYnVmZmVyRW5kID4gZW5kLiBpbiB0aGF0IGNhc2UgYnJlYWsgdG8gYXZvaWQgcmVsb2FkaW5nIDE4MjU4MDE2OFxuICAgIC8vIGxldmVsIDEgbG9hZGVkIFsxODI1ODAxNjQsMTgyNTgwMTcxXVxuICAgIC8vXG4gICAgLy8gZG9uJ3QgcmV0dXJuIG51bGwgaW4gY2FzZSBtZWRpYSBub3QgbG9hZGVkIHlldCAocmVhZHlzdGF0ZSA9PT0gMClcbiAgICBpZiAobGV2ZWxEZXRhaWxzLlBUU0tub3duICYmIGJ1ZmZlckVuZCA+IGVuZCAmJiBtZWRpYSAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgIWxldmVsRGV0YWlscy5QVFNLbm93bikge1xuICAgICAgLyogd2UgYXJlIHN3aXRjaGluZyBsZXZlbCBvbiBsaXZlIHBsYXlsaXN0LCBidXQgd2UgZG9uJ3QgaGF2ZSBhbnkgUFRTIGluZm8gZm9yIHRoYXQgcXVhbGl0eSBsZXZlbCAuLi5cbiAgICAgICAgIHRyeSB0byBsb2FkIGZyYWcgbWF0Y2hpbmcgd2l0aCBuZXh0IFNOLlxuICAgICAgICAgZXZlbiBpZiBTTiBhcmUgbm90IHN5bmNocm9uaXplZCBiZXR3ZWVuIHBsYXlsaXN0cywgbG9hZGluZyB0aGlzIGZyYWcgd2lsbCBoZWxwIHVzXG4gICAgICAgICBjb21wdXRlIHBsYXlsaXN0IHNsaWRpbmcgYW5kIGZpbmQgdGhlIHJpZ2h0IG9uZSBhZnRlciBpbiBjYXNlIGl0IHdhcyBub3QgdGhlIHJpZ2h0IGNvbnNlY3V0aXZlIG9uZSAqL1xuICAgICAgaWYgKGZyYWdQcmV2aW91cykge1xuICAgICAgICBpZiAobGV2ZWxEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICAgIC8vIFJlbGllcyBvbiBQRFQgaW4gb3JkZXIgdG8gc3dpdGNoIGJpdHJhdGVzIChTdXBwb3J0IEVYVC1YLURJU0NPTlRJTlVJVFkgd2l0aG91dCBFWFQtWC1ESVNDT05USU5VSVRZLVNFUVVFTkNFKVxuICAgICAgICAgIGxvZ2dlci5sb2coYGxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggc2FtZSBQRFQ6ICR7ZnJhZ1ByZXZpb3VzLnByb2dyYW1EYXRlVGltZX1gKTtcbiAgICAgICAgICBmcmFnID0gZmluZEZyYWdtZW50QnlQRFQoZnJhZ21lbnRzLCBmcmFnUHJldmlvdXMuZW5kUHJvZ3JhbURhdGVUaW1lLCBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVXNlcyBidWZmZXIgYW5kIHNlcXVlbmNlIG51bWJlciB0byBjYWxjdWxhdGUgc3dpdGNoIHNlZ21lbnQgKHJlcXVpcmVkIGlmIHVzaW5nIEVYVC1YLURJU0NPTlRJTlVJVFktU0VRVUVOQ0UpXG4gICAgICAgICAgY29uc3QgdGFyZ2V0U04gPSBmcmFnUHJldmlvdXMuc24gKyAxO1xuICAgICAgICAgIGlmICh0YXJnZXRTTiA+PSBsZXZlbERldGFpbHMuc3RhcnRTTiAmJiB0YXJnZXRTTiA8PSBsZXZlbERldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdOZXh0ID0gZnJhZ21lbnRzW3RhcmdldFNOIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U05dO1xuICAgICAgICAgICAgaWYgKGZyYWdQcmV2aW91cy5jYyA9PT0gZnJhZ05leHQuY2MpIHtcbiAgICAgICAgICAgICAgZnJhZyA9IGZyYWdOZXh0O1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIG5leHQgU046ICR7ZnJhZy5zbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbmV4dCBmcmFnIFNOIG5vdCBhdmFpbGFibGUgKG9yIG5vdCB3aXRoIHNhbWUgY29udGludWl0eSBjb3VudGVyKVxuICAgICAgICAgIC8vIGxvb2sgZm9yIGEgZnJhZyBzaGFyaW5nIHRoZSBzYW1lIENDXG4gICAgICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgICAgICBmcmFnID0gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmcmFnUHJldmlvdXMuY2MgLSBmcmFnLmNjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBsaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIHNhbWUgQ0M6ICR7ZnJhZy5zbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZnJhZykge1xuICAgICAgICAvKiB3ZSBoYXZlIG5vIGlkZWEgYWJvdXQgd2hpY2ggZnJhZ21lbnQgc2hvdWxkIGJlIGxvYWRlZC5cbiAgICAgICAgICAgc28gbGV0J3MgbG9hZCBtaWQgZnJhZ21lbnQuIGl0IHdpbGwgaGVscCBjb21wdXRpbmcgcGxheWxpc3Qgc2xpZGluZyBhbmQgZmluZCB0aGUgcmlnaHQgb25lXG4gICAgICAgICovXG4gICAgICAgIGZyYWcgPSBmcmFnbWVudHNbTWF0aC5taW4oZnJhZ0xlbiAtIDEsIE1hdGgucm91bmQoZnJhZ0xlbiAvIDIpKV07XG4gICAgICAgIGxvZ2dlci5sb2coYGxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgdW5rbm93biwgbG9hZCBtaWRkbGUgZnJhZyA6ICR7ZnJhZy5zbn1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuXG4gIF9maW5kRnJhZ21lbnQgKHN0YXJ0LCBmcmFnUHJldmlvdXMsIGZyYWdMZW4sIGZyYWdtZW50cywgYnVmZmVyRW5kLCBlbmQsIGxldmVsRGV0YWlscykge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBsZXQgZnJhZztcblxuICAgIGlmIChidWZmZXJFbmQgPCBlbmQpIHtcbiAgICAgIGNvbnN0IGxvb2t1cFRvbGVyYW5jZSA9IChidWZmZXJFbmQgPiBlbmQgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkgPyAwIDogY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICAvLyBSZW1vdmUgdGhlIHRvbGVyYW5jZSBpZiBpdCB3b3VsZCBwdXQgdGhlIGJ1ZmZlckVuZCBwYXN0IHRoZSBhY3R1YWwgZW5kIG9mIHN0cmVhbVxuICAgICAgLy8gVXNlcyBidWZmZXIgYW5kIHNlcXVlbmNlIG51bWJlciB0byBjYWxjdWxhdGUgc3dpdGNoIHNlZ21lbnQgKHJlcXVpcmVkIGlmIHVzaW5nIEVYVC1YLURJU0NPTlRJTlVJVFktU0VRVUVOQ0UpXG4gICAgICBmcmFnID0gZmluZEZyYWdtZW50QnlQVFMoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgbG9va3VwVG9sZXJhbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVhY2ggZW5kIG9mIHBsYXlsaXN0XG4gICAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXTtcbiAgICB9XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIGNvbnN0IGN1clNOSWR4ID0gZnJhZy5zbiAtIGxldmVsRGV0YWlscy5zdGFydFNOO1xuICAgICAgY29uc3Qgc2FtZUxldmVsID0gZnJhZ1ByZXZpb3VzICYmIGZyYWcubGV2ZWwgPT09IGZyYWdQcmV2aW91cy5sZXZlbDtcbiAgICAgIGNvbnN0IHByZXZGcmFnID0gZnJhZ21lbnRzW2N1clNOSWR4IC0gMV07XG4gICAgICBjb25zdCBuZXh0RnJhZyA9IGZyYWdtZW50c1tjdXJTTklkeCArIDFdO1xuICAgICAgLy8gbG9nZ2VyLmxvZygnZmluZCBTTiBtYXRjaGluZyB3aXRoIHBvczonICsgIGJ1ZmZlckVuZCArICc6JyArIGZyYWcuc24pO1xuICAgICAgaWYgKGZyYWdQcmV2aW91cyAmJiBmcmFnLnNuID09PSBmcmFnUHJldmlvdXMuc24pIHtcbiAgICAgICAgaWYgKHNhbWVMZXZlbCAmJiAhZnJhZy5iYWNrdHJhY2tlZCkge1xuICAgICAgICAgIGlmIChmcmFnLnNuIDwgbGV2ZWxEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgICBsZXQgZGVsdGFQVFMgPSBmcmFnUHJldmlvdXMuZGVsdGFQVFM7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNpZ25pZmljYW50IGRlbHRhIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvLCBsYXJnZXIgdGhhbiBtYXggYWxsb3dlZCBob2xlLFxuICAgICAgICAgICAgLy8gYW5kIGlmIHByZXZpb3VzIHJlbXV4ZWQgZnJhZ21lbnQgZGlkIG5vdCBzdGFydCB3aXRoIGEga2V5ZnJhbWUuIChmcmFnUHJldmlvdXMuZHJvcHBlZClcbiAgICAgICAgICAgIC8vIGxldCdzIHRyeSB0byBsb2FkIHByZXZpb3VzIGZyYWdtZW50IGFnYWluIHRvIGdldCBsYXN0IGtleWZyYW1lXG4gICAgICAgICAgICAvLyB0aGVuIHdlIHdpbGwgcmVsb2FkIGFnYWluIGN1cnJlbnQgZnJhZ21lbnQgKHRoYXQgd2F5IHdlIHNob3VsZCBiZSBhYmxlIHRvIGZpbGwgdGhlIGJ1ZmZlciBob2xlIC4uLilcbiAgICAgICAgICAgIGlmIChkZWx0YVBUUyAmJiBkZWx0YVBUUyA+IGNvbmZpZy5tYXhCdWZmZXJIb2xlICYmIGZyYWdQcmV2aW91cy5kcm9wcGVkICYmIGN1clNOSWR4KSB7XG4gICAgICAgICAgICAgIGZyYWcgPSBwcmV2RnJhZztcbiAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ1NOIGp1c3QgbG9hZGVkLCB3aXRoIGxhcmdlIFBUUyBnYXAgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW8sIG1heWJlIGZyYWcgaXMgbm90IHN0YXJ0aW5nIHdpdGggYSBrZXlmcmFtZSA/IGxvYWQgcHJldmlvdXMgb25lIHRvIHRyeSB0byBvdmVyY29tZSB0aGlzJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmcmFnID0gbmV4dEZyYWc7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coYFNOIGp1c3QgbG9hZGVkLCBsb2FkIG5leHQgb25lOiAke2ZyYWcuc259YCwgZnJhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmcmFnLmJhY2t0cmFja2VkKSB7XG4gICAgICAgICAgLy8gT25seSBiYWNrdHJhY2sgYSBtYXggb2YgMSBjb25zZWN1dGl2ZSBmcmFnbWVudCB0byBwcmV2ZW50IHNsaWRpbmcgYmFjayB0b28gZmFyIHdoZW4gbGl0dGxlIG9yIG5vIGZyYWdzIHN0YXJ0IHdpdGgga2V5ZnJhbWVzXG4gICAgICAgICAgaWYgKG5leHRGcmFnICYmIG5leHRGcmFnLmJhY2t0cmFja2VkKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgQWxyZWFkeSBiYWNrdHJhY2tlZCBmcm9tIGZyYWdtZW50ICR7bmV4dEZyYWcuc259LCB3aWxsIG5vdCBiYWNrdHJhY2sgdG8gZnJhZ21lbnQgJHtmcmFnLnNufS4gTG9hZGluZyBmcmFnbWVudCAke25leHRGcmFnLnNufWApO1xuICAgICAgICAgICAgZnJhZyA9IG5leHRGcmFnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBhIGZyYWdtZW50IGhhcyBkcm9wcGVkIGZyYW1lcyBhbmQgaXQncyBpbiBhIHNhbWUgbGV2ZWwvc2VxdWVuY2UsIGxvYWQgdGhlIHByZXZpb3VzIGZyYWdtZW50IHRvIHRyeSBhbmQgZmluZCB0aGUga2V5ZnJhbWVcbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBkcm9wcGVkIGNvdW50IG5vdyBzaW5jZSBpdCB3b24ndCBiZSByZXNldCB1bnRpbCB3ZSBwYXJzZSB0aGUgZnJhZ21lbnQgYWdhaW4sIHdoaWNoIHByZXZlbnRzIGluZmluaXRlIGJhY2t0cmFja2luZyBvbiB0aGUgc2FtZSBzZWdtZW50XG4gICAgICAgICAgICBsb2dnZXIud2FybignTG9hZGVkIGZyYWdtZW50IHdpdGggZHJvcHBlZCBmcmFtZXMsIGJhY2t0cmFja2luZyAxIHNlZ21lbnQgdG8gZmluZCBhIGtleWZyYW1lJyk7XG4gICAgICAgICAgICBmcmFnLmRyb3BwZWQgPSAwO1xuICAgICAgICAgICAgaWYgKHByZXZGcmFnKSB7XG4gICAgICAgICAgICAgIGZyYWcgPSBwcmV2RnJhZztcbiAgICAgICAgICAgICAgZnJhZy5iYWNrdHJhY2tlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1clNOSWR4KSB7XG4gICAgICAgICAgICAgIC8vIGNhbid0IGJhY2t0cmFjayBvbiB2ZXJ5IGZpcnN0IGZyYWdtZW50XG4gICAgICAgICAgICAgIGZyYWcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuXG4gIF9sb2FkS2V5IChmcmFnKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLktFWV9MT0FESU5HO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuS0VZX0xPQURJTkcsIHsgZnJhZyB9KTtcbiAgfVxuXG4gIF9sb2FkRnJhZ21lbnQgKGZyYWcpIHtcbiAgICAvLyBDaGVjayBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgbGV0IGZyYWdTdGF0ZSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuXG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgIC8vIERvbid0IHVwZGF0ZSBuZXh0TG9hZFBvc2l0aW9uIGZvciBmcmFnbWVudHMgd2hpY2ggYXJlIG5vdCBidWZmZXJlZFxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZnJhZy5zbikgJiYgIWZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIC8vIEFsbG93IGJhY2t0cmFja2VkIGZyYWdtZW50cyB0byBsb2FkXG4gICAgaWYgKGZyYWcuYmFja3RyYWNrZWQgfHwgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQgfHwgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwpIHtcbiAgICAgIGZyYWcuYXV0b0xldmVsID0gdGhpcy5obHMuYXV0b0xldmVsRW5hYmxlZDtcbiAgICAgIGZyYWcuYml0cmF0ZVRlc3QgPSB0aGlzLmJpdHJhdGVUZXN0O1xuXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRElORywgeyBmcmFnIH0pO1xuICAgICAgLy8gbGF6eSBkZW11eGVyIGluaXQsIGFzIHRoaXMgY291bGQgdGFrZSBzb21lIHRpbWUgLi4uIGRvIGl0IGR1cmluZyBmcmFnIGxvYWRpbmdcbiAgICAgIGlmICghdGhpcy5kZW11eGVyKSB7XG4gICAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVyKHRoaXMuaGxzLCAnbWFpbicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgIH0gZWxzZSBpZiAoZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLkFQUEVORElORykge1xuICAgICAgLy8gTG93ZXIgdGhlIGJ1ZmZlciBzaXplIGFuZCB0cnkgYWdhaW5cbiAgICAgIGlmICh0aGlzLl9yZWR1Y2VNYXhCdWZmZXJMZW5ndGgoZnJhZy5kdXJhdGlvbikpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0IHN0YXRlIChuZXh0U3RhdGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIHRoaXMuX3N0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgbG9nZ2VyLmxvZyhgbWFpbiBzdHJlYW06JHtwcmV2aW91c1N0YXRlfS0+JHtuZXh0U3RhdGV9YCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LlNUUkVBTV9TVEFURV9UUkFOU0lUSU9OLCB7IHByZXZpb3VzU3RhdGUsIG5leHRTdGF0ZSB9KTtcbiAgICB9XG4gIH1cblxuICBnZXQgc3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIGdldEJ1ZmZlcmVkRnJhZyAocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QnVmZmVyZWRGcmFnKHBvc2l0aW9uLCBQbGF5bGlzdExvYWRlci5MZXZlbFR5cGUuTUFJTik7XG4gIH1cblxuICBnZXQgY3VycmVudExldmVsICgpIHtcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgY29uc3QgZnJhZyA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBnZXQgbmV4dEJ1ZmZlcmVkRnJhZyAoKSB7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIC8vIGZpcnN0IGdldCBlbmQgcmFuZ2Ugb2YgY3VycmVudCBmcmFnbWVudFxuICAgICAgcmV0dXJuIHRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZvbGxvd2luZ0J1ZmZlcmVkRnJhZyAoZnJhZykge1xuICAgIGlmIChmcmFnKSB7XG4gICAgICAvLyB0cnkgdG8gZ2V0IHJhbmdlIG9mIG5leHQgZnJhZ21lbnQgKDUwMG1zIGFmdGVyIHRoaXMgcmFuZ2UpXG4gICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXJlZEZyYWcoZnJhZy5lbmRQVFMgKyAwLjUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldCBuZXh0TGV2ZWwgKCkge1xuICAgIGNvbnN0IGZyYWcgPSB0aGlzLm5leHRCdWZmZXJlZEZyYWc7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG5cbiAgX2NoZWNrRnJhZ21lbnRDaGFuZ2VkICgpIHtcbiAgICBsZXQgZnJhZ1BsYXlpbmdDdXJyZW50LCBjdXJyZW50VGltZSwgdmlkZW8gPSB0aGlzLm1lZGlhO1xuICAgIGlmICh2aWRlbyAmJiB2aWRlby5yZWFkeVN0YXRlICYmIHZpZGVvLnNlZWtpbmcgPT09IGZhbHNlKSB7XG4gICAgICBjdXJyZW50VGltZSA9IHZpZGVvLmN1cnJlbnRUaW1lO1xuICAgICAgLyogaWYgdmlkZW8gZWxlbWVudCBpcyBpbiBzZWVrZWQgc3RhdGUsIGN1cnJlbnRUaW1lIGNhbiBvbmx5IGluY3JlYXNlLlxuICAgICAgICAoYXNzdW1pbmcgdGhhdCBwbGF5YmFjayByYXRlIGlzIHBvc2l0aXZlIC4uLilcbiAgICAgICAgQXMgc29tZXRpbWVzIGN1cnJlbnRUaW1lIGp1bXBzIGJhY2sgdG8gemVybyBhZnRlciBhXG4gICAgICAgIG1lZGlhIGRlY29kZSBlcnJvciwgY2hlY2sgdGhpcywgdG8gYXZvaWQgc2Vla2luZyBiYWNrIHRvXG4gICAgICAgIHdyb25nIHBvc2l0aW9uIGFmdGVyIGEgbWVkaWEgZGVjb2RlIGVycm9yXG4gICAgICAqL1xuICAgICAgaWYgKGN1cnJlbnRUaW1lID4gdGhpcy5sYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIH1cblxuICAgICAgaWYgKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvLCBjdXJyZW50VGltZSkpIHtcbiAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcoY3VycmVudFRpbWUpO1xuICAgICAgfSBlbHNlIGlmIChCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh2aWRlbywgY3VycmVudFRpbWUgKyAwLjEpKSB7XG4gICAgICAgIC8qIGVuc3VyZSB0aGF0IEZSQUdfQ0hBTkdFRCBldmVudCBpcyB0cmlnZ2VyZWQgYXQgc3RhcnR1cCxcbiAgICAgICAgICB3aGVuIGZpcnN0IHZpZGVvIGZyYW1lIGlzIGRpc3BsYXllZCBhbmQgcGxheWJhY2sgaXMgcGF1c2VkLlxuICAgICAgICAgIGFkZCBhIHRvbGVyYW5jZSBvZiAxMDBtcywgaW4gY2FzZSBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCxcbiAgICAgICAgICBjaGVjayBpZiBjdXJyZW50IHBvcysxMDBtcyBpcyBidWZmZXJlZCBhbmQgdXNlIHRoYXQgYnVmZmVyIHJhbmdlXG4gICAgICAgICAgZm9yIEZSQUdfQ0hBTkdFRCBldmVudCByZXBvcnRpbmcgKi9cbiAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcoY3VycmVudFRpbWUgKyAwLjEpO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWdQbGF5aW5nQ3VycmVudCkge1xuICAgICAgICBsZXQgZnJhZ1BsYXlpbmcgPSBmcmFnUGxheWluZ0N1cnJlbnQ7XG4gICAgICAgIGlmIChmcmFnUGxheWluZyAhPT0gdGhpcy5mcmFnUGxheWluZykge1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19DSEFOR0VELCB7IGZyYWc6IGZyYWdQbGF5aW5nIH0pO1xuICAgICAgICAgIGNvbnN0IGZyYWdQbGF5aW5nTGV2ZWwgPSBmcmFnUGxheWluZy5sZXZlbDtcbiAgICAgICAgICBpZiAoIXRoaXMuZnJhZ1BsYXlpbmcgfHwgdGhpcy5mcmFnUGxheWluZy5sZXZlbCAhPT0gZnJhZ1BsYXlpbmdMZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5MRVZFTF9TV0lUQ0hFRCwgeyBsZXZlbDogZnJhZ1BsYXlpbmdMZXZlbCB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmZyYWdQbGF5aW5nID0gZnJhZ1BsYXlpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICAgIG9uIGltbWVkaWF0ZSBsZXZlbCBzd2l0Y2ggOlxuICAgICAtIHBhdXNlIHBsYXliYWNrIGlmIHBsYXlpbmdcbiAgICAgLSBjYW5jZWwgYW55IHBlbmRpbmcgbG9hZCByZXF1ZXN0XG4gICAgIC0gYW5kIHRyaWdnZXIgYSBidWZmZXIgZmx1c2hcbiAgKi9cbiAgaW1tZWRpYXRlTGV2ZWxTd2l0Y2ggKCkge1xuICAgIGxvZ2dlci5sb2coJ2ltbWVkaWF0ZUxldmVsU3dpdGNoJyk7XG4gICAgaWYgKCF0aGlzLmltbWVkaWF0ZVN3aXRjaCkge1xuICAgICAgdGhpcy5pbW1lZGlhdGVTd2l0Y2ggPSB0cnVlO1xuICAgICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYSwgcHJldmlvdXNseVBhdXNlZDtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBwcmV2aW91c2x5UGF1c2VkID0gbWVkaWEucGF1c2VkO1xuICAgICAgICBtZWRpYS5wYXVzZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG9uJ3QgcmVzdGFydCBwbGF5YmFjayBhZnRlciBpbnN0YW50IGxldmVsIHN3aXRjaCBpbiBjYXNlIG1lZGlhIG5vdCBhdHRhY2hlZFxuICAgICAgICBwcmV2aW91c2x5UGF1c2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJldmlvdXNseVBhdXNlZCA9IHByZXZpb3VzbHlQYXVzZWQ7XG4gICAgfVxuICAgIGxldCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgLy8gZmx1c2ggZXZlcnl0aGluZ1xuICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gIH1cblxuICAvKipcbiAgICogb24gaW1tZWRpYXRlIGxldmVsIHN3aXRjaCBlbmQsIGFmdGVyIG5ldyBmcmFnbWVudCBoYXMgYmVlbiBidWZmZXJlZDpcbiAgICogLSBudWRnZSB2aWRlbyBkZWNvZGVyIGJ5IHNsaWdodGx5IGFkanVzdGluZyB2aWRlbyBjdXJyZW50VGltZSAoaWYgY3VycmVudFRpbWUgYnVmZmVyZWQpXG4gICAqIC0gcmVzdW1lIHRoZSBwbGF5YmFjayBpZiBuZWVkZWRcbiAgICovXG4gIGltbWVkaWF0ZUxldmVsU3dpdGNoRW5kICgpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhICYmIG1lZGlhLmJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgdGhpcy5pbW1lZGlhdGVTd2l0Y2ggPSBmYWxzZTtcbiAgICAgIGlmIChCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSwgbWVkaWEuY3VycmVudFRpbWUpKSB7XG4gICAgICAgIC8vIG9ubHkgbnVkZ2UgaWYgY3VycmVudFRpbWUgaXMgYnVmZmVyZWRcbiAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgLT0gMC4wMDAxO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnByZXZpb3VzbHlQYXVzZWQpIHtcbiAgICAgICAgbWVkaWEucGxheSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiB0cnkgdG8gc3dpdGNoIEFTQVAgd2l0aG91dCBicmVha2luZyB2aWRlbyBwbGF5YmFjazpcbiAgICogaW4gb3JkZXIgdG8gZW5zdXJlIHNtb290aCBidXQgcXVpY2sgbGV2ZWwgc3dpdGNoaW5nLFxuICAgKiB3ZSBuZWVkIHRvIGZpbmQgdGhlIG5leHQgZmx1c2hhYmxlIGJ1ZmZlciByYW5nZVxuICAgKiB3ZSBzaG91bGQgdGFrZSBpbnRvIGFjY291bnQgbmV3IHNlZ21lbnQgZmV0Y2ggdGltZVxuICAgKi9cbiAgbmV4dExldmVsU3dpdGNoICgpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgLy8gZW5zdXJlIHRoYXQgbWVkaWEgaXMgZGVmaW5lZCBhbmQgdGhhdCBtZXRhZGF0YSBhcmUgYXZhaWxhYmxlICh0byByZXRyaWV2ZSBjdXJyZW50VGltZSlcbiAgICBpZiAobWVkaWEgJiYgbWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgbGV0IGZldGNoZGVsYXksIGZyYWdQbGF5aW5nQ3VycmVudCwgbmV4dEJ1ZmZlcmVkRnJhZztcbiAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICAgIGlmIChmcmFnUGxheWluZ0N1cnJlbnQgJiYgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0UFRTID4gMSkge1xuICAgICAgICAvLyBmbHVzaCBidWZmZXIgcHJlY2VkaW5nIGN1cnJlbnQgZnJhZ21lbnQgKGZsdXNoIHVudGlsIGN1cnJlbnQgZnJhZ21lbnQgc3RhcnQgb2Zmc2V0KVxuICAgICAgICAvLyBtaW51cyAxcyB0byBhdm9pZCB2aWRlbyBmcmVlemluZywgdGhhdCBjb3VsZCBoYXBwZW4gaWYgd2UgZmx1c2gga2V5ZnJhbWUgb2YgY3VycmVudCB2aWRlbyAuLi5cbiAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0UFRTIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoIW1lZGlhLnBhdXNlZCkge1xuICAgICAgICAvLyBhZGQgYSBzYWZldHkgZGVsYXkgb2YgMXNcbiAgICAgICAgbGV0IG5leHRMZXZlbElkID0gdGhpcy5obHMubmV4dExvYWRMZXZlbCwgbmV4dExldmVsID0gdGhpcy5sZXZlbHNbbmV4dExldmVsSWRdLCBmcmFnTGFzdEticHMgPSB0aGlzLmZyYWdMYXN0S2JwcztcbiAgICAgICAgaWYgKGZyYWdMYXN0S2JwcyAmJiB0aGlzLmZyYWdDdXJyZW50KSB7XG4gICAgICAgICAgZmV0Y2hkZWxheSA9IHRoaXMuZnJhZ0N1cnJlbnQuZHVyYXRpb24gKiBuZXh0TGV2ZWwuYml0cmF0ZSAvICgxMDAwICogZnJhZ0xhc3RLYnBzKSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmV0Y2hkZWxheSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgfVxuICAgICAgLy8gbG9nZ2VyLmxvZygnZmV0Y2hkZWxheTonK2ZldGNoZGVsYXkpO1xuICAgICAgLy8gZmluZCBidWZmZXIgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlYWNoZWQgb25jZSBuZXcgZnJhZ21lbnQgd2lsbCBiZSBmZXRjaGVkXG4gICAgICBuZXh0QnVmZmVyZWRGcmFnID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUgKyBmZXRjaGRlbGF5KTtcbiAgICAgIGlmIChuZXh0QnVmZmVyZWRGcmFnKSB7XG4gICAgICAgIC8vIHdlIGNhbiBmbHVzaCBidWZmZXIgcmFuZ2UgZm9sbG93aW5nIHRoaXMgb25lIHdpdGhvdXQgc3RhbGxpbmcgcGxheWJhY2tcbiAgICAgICAgbmV4dEJ1ZmZlcmVkRnJhZyA9IHRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKG5leHRCdWZmZXJlZEZyYWcpO1xuICAgICAgICBpZiAobmV4dEJ1ZmZlcmVkRnJhZykge1xuICAgICAgICAgIC8vIGlmIHdlIGFyZSBoZXJlLCB3ZSBjYW4gYWxzbyBjYW5jZWwgYW55IGxvYWRpbmcvZGVtdXhpbmcgaW4gcHJvZ3Jlc3MsIGFzIHRoZXkgYXJlIHVzZWxlc3NcbiAgICAgICAgICBsZXQgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICAgIGlmIChmcmFnQ3VycmVudCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIC8vIHN0YXJ0IGZsdXNoIHBvc2l0aW9uIGlzIHRoZSBzdGFydCBQVFMgb2YgbmV4dCBidWZmZXJlZCBmcmFnLlxuICAgICAgICAgIC8vIHdlIHVzZSBmcmFnLm5heFN0YXJ0UFRTIHdoaWNoIGlzIG1heChhdWRpbyBzdGFydFBUUywgdmlkZW8gc3RhcnRQVFMpLlxuICAgICAgICAgIC8vIGluIGNhc2UgdGhlcmUgaXMgYSBzbWFsbCBQVFMgRGVsdGEgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW8sIHVzaW5nIG1heFN0YXJ0UFRTIGF2b2lkcyBmbHVzaGluZyBsYXN0IHNhbXBsZXMgZnJvbSBjdXJyZW50IGZyYWdtZW50XG4gICAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIobmV4dEJ1ZmZlcmVkRnJhZy5tYXhTdGFydFBUUywgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZsdXNoTWFpbkJ1ZmZlciAoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5CVUZGRVJfRkxVU0hJTkc7XG4gICAgbGV0IGZsdXNoU2NvcGUgPSB7IHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCwgZW5kT2Zmc2V0OiBlbmRPZmZzZXQgfTtcbiAgICAvLyBpZiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tzIGFyZSB1c2VkLCBvbmx5IGZsdXNoIHZpZGVvLCBvdGhlcndpc2UgZmx1c2ggZXZlcnl0aGluZ1xuICAgIGlmICh0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICBmbHVzaFNjb3BlLnR5cGUgPSAndmlkZW8nO1xuICAgIH1cblxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0ZMVVNISU5HLCBmbHVzaFNjb3BlKTtcbiAgfVxuXG4gIG9uTWVkaWFBdHRhY2hlZCAoZGF0YSkge1xuICAgIGxldCBtZWRpYSA9IHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9uTWVkaWFTZWVraW5nLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbnZzZWVrZWQgPSB0aGlzLm9uTWVkaWFTZWVrZWQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9udmVuZGVkID0gdGhpcy5vbk1lZGlhRW5kZWQuYmluZCh0aGlzKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYgKHRoaXMubGV2ZWxzICYmIGNvbmZpZy5hdXRvU3RhcnRMb2FkKSB7XG4gICAgICB0aGlzLmhscy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgIH1cblxuICAgIHRoaXMuZ2FwQ29udHJvbGxlciA9IG5ldyBHYXBDb250cm9sbGVyKGNvbmZpZywgbWVkaWEsIHRoaXMuZnJhZ21lbnRUcmFja2VyLCB0aGlzLmhscyk7XG4gIH1cblxuICBvbk1lZGlhRGV0YWNoaW5nICgpIHtcbiAgICBsZXQgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSAmJiBtZWRpYS5lbmRlZCkge1xuICAgICAgbG9nZ2VyLmxvZygnTVNFIGRldGFjaGluZyBhbmQgdmlkZW8gZW5kZWQsIHJlc2V0IHN0YXJ0UG9zaXRpb24nKTtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB9XG5cbiAgICAvLyByZXNldCBmcmFnbWVudCBiYWNrdHJhY2tlZCBmbGFnXG4gICAgbGV0IGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgIGlmIChsZXZlbHMpIHtcbiAgICAgIGxldmVscy5mb3JFYWNoKGxldmVsID0+IHtcbiAgICAgICAgaWYgKGxldmVsLmRldGFpbHMpIHtcbiAgICAgICAgICBsZXZlbC5kZXRhaWxzLmZyYWdtZW50cy5mb3JFYWNoKGZyYWdtZW50ID0+IHtcbiAgICAgICAgICAgIGZyYWdtZW50LmJhY2t0cmFja2VkID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHZpZGVvIGxpc3RlbmVyc1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbnZzZWVrZWQgPSB0aGlzLm9udmVuZGVkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gIH1cblxuICBvbk1lZGlhU2Vla2VkICgpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWEsIGN1cnJlbnRUaW1lID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGN1cnJlbnRUaW1lKSkge1xuICAgICAgbG9nZ2VyLmxvZyhgbWVkaWEgc2Vla2VkIHRvICR7Y3VycmVudFRpbWUudG9GaXhlZCgzKX1gKTtcbiAgICB9XG5cbiAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIEZSQUdNRU5UX1BMQVlJTkcgdHJpZ2dlcmluZ1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgb25NYW5pZmVzdExvYWRpbmcgKCkge1xuICAgIC8vIHJlc2V0IGJ1ZmZlciBvbiBtYW5pZmVzdCBsb2FkaW5nXG4gICAgbG9nZ2VyLmxvZygndHJpZ2dlciBCVUZGRVJfUkVTRVQnKTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9SRVNFVCk7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgdGhpcy5zdGFsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICB9XG5cbiAgb25NYW5pZmVzdFBhcnNlZCAoZGF0YSkge1xuICAgIGxldCBhYWMgPSBmYWxzZSwgaGVhYWMgPSBmYWxzZSwgY29kZWM7XG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICAvLyBkZXRlY3QgaWYgd2UgaGF2ZSBkaWZmZXJlbnQga2luZCBvZiBhdWRpbyBjb2RlY3MgdXNlZCBhbW9uZ3N0IHBsYXlsaXN0c1xuICAgICAgY29kZWMgPSBsZXZlbC5hdWRpb0NvZGVjO1xuICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgIGlmIChjb2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTEpIHtcbiAgICAgICAgICBhYWMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgIGhlYWFjID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3aXRjaCA9IChhYWMgJiYgaGVhYWMpO1xuICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgIGxvZ2dlci5sb2coJ2JvdGggQUFDL0hFLUFBQyBhdWRpbyBmb3VuZCBpbiBsZXZlbHM7IGRlY2xhcmluZyBsZXZlbCBjb2RlYyBhcyBIRS1BQUMnKTtcbiAgICB9XG5cbiAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmIChjb25maWcuYXV0b1N0YXJ0TG9hZCB8fCB0aGlzLmZvcmNlU3RhcnRMb2FkKSB7XG4gICAgICB0aGlzLmhscy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIG9uTGV2ZWxMb2FkZWQgKGRhdGEpIHtcbiAgICBjb25zdCBuZXdEZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIGNvbnN0IG5ld0xldmVsSWQgPSBkYXRhLmxldmVsO1xuICAgIGNvbnN0IGxhc3RMZXZlbCA9IHRoaXMubGV2ZWxzW3RoaXMubGV2ZWxMYXN0TG9hZGVkXTtcbiAgICBjb25zdCBjdXJMZXZlbCA9IHRoaXMubGV2ZWxzW25ld0xldmVsSWRdO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uO1xuICAgIGxldCBzbGlkaW5nID0gMDtcblxuICAgIGxvZ2dlci5sb2coYGxldmVsICR7bmV3TGV2ZWxJZH0gbG9hZGVkIFske25ld0RldGFpbHMuc3RhcnRTTn0sJHtuZXdEZXRhaWxzLmVuZFNOfV0sZHVyYXRpb246JHtkdXJhdGlvbn1gKTtcblxuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgIGxldCBjdXJEZXRhaWxzID0gY3VyTGV2ZWwuZGV0YWlscztcbiAgICAgIGlmIChjdXJEZXRhaWxzICYmIG5ld0RldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gd2UgYWxyZWFkeSBoYXZlIGRldGFpbHMgZm9yIHRoYXQgbGV2ZWwsIG1lcmdlIHRoZW1cbiAgICAgICAgTGV2ZWxIZWxwZXIubWVyZ2VEZXRhaWxzKGN1ckRldGFpbHMsIG5ld0RldGFpbHMpO1xuICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICAgIHRoaXMubGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZUxpdmVQb3NpdGlvbihzbGlkaW5nLCBjdXJEZXRhaWxzKTtcbiAgICAgICAgaWYgKG5ld0RldGFpbHMuUFRTS25vd24gJiYgTnVtYmVyLmlzRmluaXRlKHNsaWRpbmcpKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgbGl2ZSBwbGF5bGlzdCBzbGlkaW5nOiR7c2xpZGluZy50b0ZpeGVkKDMpfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ2xpdmUgcGxheWxpc3QgLSBvdXRkYXRlZCBQVFMsIHVua25vd24gc2xpZGluZycpO1xuICAgICAgICAgIGFsaWduU3RyZWFtKHRoaXMuZnJhZ1ByZXZpb3VzLCBsYXN0TGV2ZWwsIG5ld0RldGFpbHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIubG9nKCdsaXZlIHBsYXlsaXN0IC0gZmlyc3QgbG9hZCwgdW5rbm93biBzbGlkaW5nJyk7XG4gICAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcbiAgICAgICAgYWxpZ25TdHJlYW0odGhpcy5mcmFnUHJldmlvdXMsIGxhc3RMZXZlbCwgbmV3RGV0YWlscyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gb3ZlcnJpZGUgbGV2ZWwgaW5mb1xuICAgIGN1ckxldmVsLmRldGFpbHMgPSBuZXdEZXRhaWxzO1xuICAgIHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gbmV3TGV2ZWxJZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkxFVkVMX1VQREFURUQsIHsgZGV0YWlsczogbmV3RGV0YWlscywgbGV2ZWw6IG5ld0xldmVsSWQgfSk7XG5cbiAgICBpZiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPT09IGZhbHNlKSB7XG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICAgIGlmICh0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xIHx8IHRoaXMubGFzdEN1cnJlbnRUaW1lID09PSAtMSkge1xuICAgICAgICAvLyBmaXJzdCwgY2hlY2sgaWYgc3RhcnQgdGltZSBvZmZzZXQgaGFzIGJlZW4gc2V0IGluIHBsYXlsaXN0LCBpZiB5ZXMsIHVzZSB0aGlzIHZhbHVlXG4gICAgICAgIGxldCBzdGFydFRpbWVPZmZzZXQgPSBuZXdEZXRhaWxzLnN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShzdGFydFRpbWVPZmZzZXQpKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0VGltZU9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYG5lZ2F0aXZlIHN0YXJ0IHRpbWUgb2Zmc2V0ICR7c3RhcnRUaW1lT2Zmc2V0fSwgY291bnQgZnJvbSBlbmQgb2YgbGFzdCBmcmFnbWVudGApO1xuICAgICAgICAgICAgc3RhcnRUaW1lT2Zmc2V0ID0gc2xpZGluZyArIGR1cmF0aW9uICsgc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2dnZXIubG9nKGBzdGFydCB0aW1lIG9mZnNldCBmb3VuZCBpbiBwbGF5bGlzdCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gdG8gJHtzdGFydFRpbWVPZmZzZXR9YCk7XG4gICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIGxpdmUgcGxheWxpc3QsIHNldCBzdGFydCBwb3NpdGlvbiB0byBiZSBmcmFnbWVudCBOLXRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCAodXN1YWxseSAzKVxuICAgICAgICAgIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZUxpdmVQb3NpdGlvbihzbGlkaW5nLCBuZXdEZXRhaWxzKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYGNvbmZpZ3VyZSBzdGFydFBvc2l0aW9uIHRvICR7dGhpcy5zdGFydFBvc2l0aW9ufWApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICB9XG4gICAgLy8gb25seSBzd2l0Y2ggYmF0Y2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIGxldmVsIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uS2V5TG9hZGVkICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuS0VZX0xPQURJTkcpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnTG9hZGVkIChkYXRhKSB7XG4gICAgY29uc3QgeyBmcmFnQ3VycmVudCwgaGxzLCBsZXZlbHMsIG1lZGlhIH0gPSB0aGlzO1xuICAgIGNvbnN0IGZyYWdMb2FkZWQgPSBkYXRhLmZyYWc7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyAmJlxuICAgICAgICBmcmFnQ3VycmVudCAmJlxuICAgICAgICBmcmFnTG9hZGVkLnR5cGUgPT09ICdtYWluJyAmJlxuICAgICAgICBmcmFnTG9hZGVkLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICBmcmFnTG9hZGVkLnNuID09PSBmcmFnQ3VycmVudC5zbikge1xuICAgICAgY29uc3Qgc3RhdHMgPSBkYXRhLnN0YXRzO1xuICAgICAgY29uc3QgY3VycmVudExldmVsID0gbGV2ZWxzW2ZyYWdDdXJyZW50LmxldmVsXTtcbiAgICAgIGNvbnN0IGRldGFpbHMgPSBjdXJyZW50TGV2ZWwuZGV0YWlscztcbiAgICAgIC8vIHJlc2V0IGZyYWcgYml0cmF0ZSB0ZXN0IGluIGFueSBjYXNlIGFmdGVyIGZyYWcgbG9hZGVkIGV2ZW50XG4gICAgICAvLyBpZiB0aGlzIGZyYWcgd2FzIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0IEFORCBpZiBobHMubmV4dExvYWRMZXZlbCBpcyBncmVhdGVyIHRoYW4gMFxuICAgICAgLy8gdGhlbiB0aGlzIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIGJlIGFibGUgdG8gbG9hZCBhIGZyYWdtZW50IGF0IGEgaGlnaGVyIHF1YWxpdHkgbGV2ZWxcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RhdHMgPSBzdGF0cztcblxuICAgICAgbG9nZ2VyLmxvZyhgTG9hZGVkICR7ZnJhZ0N1cnJlbnQuc259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLGxldmVsICR7ZnJhZ0N1cnJlbnQubGV2ZWx9YCk7XG4gICAgICBpZiAoZnJhZ0xvYWRlZC5iaXRyYXRlVGVzdCAmJiBobHMubmV4dExvYWRMZXZlbCkge1xuICAgICAgICAvLyBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIC4uLiB3ZSBqdXN0IGxvYWRlZCBhIGZyYWdtZW50IHRvIGRldGVybWluZSBhZGVxdWF0ZSBzdGFydCBiaXRyYXRlIGFuZCBpbml0aWFsaXplIGF1dG9zd2l0Y2ggYWxnb1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRlJBR19CVUZGRVJFRCwgeyBzdGF0czogc3RhdHMsIGZyYWc6IGZyYWdDdXJyZW50LCBpZDogJ21haW4nIH0pO1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH0gZWxzZSBpZiAoZnJhZ0xvYWRlZC5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgc3RhdHMudHBhcnNlZCA9IHN0YXRzLnRidWZmZXJlZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgZGV0YWlscy5pbml0U2VnbWVudC5kYXRhID0gZGF0YS5wYXlsb2FkO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7IHN0YXRzOiBzdGF0cywgZnJhZzogZnJhZ0N1cnJlbnQsIGlkOiAnbWFpbicgfSk7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgUGFyc2luZyAke2ZyYWdDdXJyZW50LnNufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSxsZXZlbCAke2ZyYWdDdXJyZW50LmxldmVsfSwgY2MgJHtmcmFnQ3VycmVudC5jY31gKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNJTkc7XG4gICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlcmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuYXBwZW5kZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBCaXRyYXRlIHRlc3QgZnJhZ3MgYXJlIG5vdCB1c3VhbGx5IGJ1ZmZlcmVkIHNvIHRoZSBmcmFnbWVudCB0cmFja2VyIGlnbm9yZXMgdGhlbS4gSWYgSGxzLmpzIGRlY2lkZXMgdG8gYnVmZmVyXG4gICAgICAgIC8vIGl0IChhbmQgdGhlcmVmb3JlIGVuZHMgdXAgYXQgdGhpcyBsaW5lKSwgdGhlbiB0aGUgZnJhZ21lbnQgdHJhY2tlciBuZWVkcyB0byBiZSBtYW51YWxseSBpbmZvcm1lZC5cbiAgICAgICAgaWYgKGZyYWdMb2FkZWQuYml0cmF0ZVRlc3QpIHtcbiAgICAgICAgICBmcmFnTG9hZGVkLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIub25GcmFnTG9hZGVkKHtcbiAgICAgICAgICAgIGZyYWc6IGZyYWdMb2FkZWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRpbWUgT2Zmc2V0IGlzIGFjY3VyYXRlIGlmIGxldmVsIFBUUyBpcyBrbm93biwgb3IgaWYgcGxheWxpc3QgaXMgbm90IHNsaWRpbmcgKG5vdCBsaXZlKSBhbmQgaWYgbWVkaWEgaXMgbm90IHNlZWtpbmcgKHRoaXMgaXMgdG8gb3ZlcmNvbWUgcG90ZW50aWFsIHRpbWVzdGFtcCBkcmlmdHMgYmV0d2VlbiBwbGF5bGlzdHMgYW5kIGZyYWdtZW50cylcbiAgICAgICAgY29uc3QgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gIShtZWRpYSAmJiBtZWRpYS5zZWVraW5nKSAmJiAoZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlKTtcbiAgICAgICAgY29uc3QgaW5pdFNlZ21lbnREYXRhID0gZGV0YWlscy5pbml0U2VnbWVudCA/IGRldGFpbHMuaW5pdFNlZ21lbnQuZGF0YSA6IFtdO1xuICAgICAgICBjb25zdCBhdWRpb0NvZGVjID0gdGhpcy5fZ2V0QXVkaW9Db2RlYyhjdXJyZW50TGV2ZWwpO1xuXG4gICAgICAgIC8vIHRyYW5zbXV4IHRoZSBNUEVHLVRTIGRhdGEgdG8gSVNPLUJNRkYgc2VnbWVudHNcbiAgICAgICAgY29uc3QgZGVtdXhlciA9IHRoaXMuZGVtdXhlciA9IHRoaXMuZGVtdXhlciB8fCBuZXcgRGVtdXhlcih0aGlzLmhscywgJ21haW4nKTtcbiAgICAgICAgZGVtdXhlci5wdXNoKFxuICAgICAgICAgIGRhdGEucGF5bG9hZCxcbiAgICAgICAgICBpbml0U2VnbWVudERhdGEsXG4gICAgICAgICAgYXVkaW9Db2RlYyxcbiAgICAgICAgICBjdXJyZW50TGV2ZWwudmlkZW9Db2RlYyxcbiAgICAgICAgICBmcmFnQ3VycmVudCxcbiAgICAgICAgICBkZXRhaWxzLnRvdGFsZHVyYXRpb24sXG4gICAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZnJhZ0xvYWRFcnJvciA9IDA7XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nSW5pdFNlZ21lbnQgKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgY29uc3QgZnJhZ05ldyA9IGRhdGEuZnJhZztcblxuICAgIGlmIChmcmFnQ3VycmVudCAmJlxuICAgICAgICBkYXRhLmlkID09PSAnbWFpbicgJiZcbiAgICAgICAgZnJhZ05ldy5zbiA9PT0gZnJhZ0N1cnJlbnQuc24gJiZcbiAgICAgICAgZnJhZ05ldy5sZXZlbCA9PT0gZnJhZ0N1cnJlbnQubGV2ZWwgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgbGV0IHRyYWNrcyA9IGRhdGEudHJhY2tzLCB0cmFja05hbWUsIHRyYWNrO1xuXG4gICAgICAvLyBpZiBhdWRpbyB0cmFjayBpcyBleHBlY3RlZCB0byBjb21lIGZyb20gYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIsIGRpc2NhcmQgYW55IGNvbWluZyBmcm9tIG1haW5cbiAgICAgIGlmICh0cmFja3MuYXVkaW8gJiYgdGhpcy5hbHRBdWRpbykge1xuICAgICAgICBkZWxldGUgdHJhY2tzLmF1ZGlvO1xuICAgICAgfVxuXG4gICAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuICAgICAgdHJhY2sgPSB0cmFja3MuYXVkaW87XG4gICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgbGV0IGF1ZGlvQ29kZWMgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXS5hdWRpb0NvZGVjLFxuICAgICAgICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoYXVkaW9Db2RlYyAmJiB0aGlzLmF1ZGlvQ29kZWNTd2FwKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnc3dhcHBpbmcgcGxheWxpc3QgYXVkaW8gY29kZWMnKTtcbiAgICAgICAgICBpZiAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpbiBjYXNlIEFBQyBhbmQgSEUtQUFDIGF1ZGlvIGNvZGVjcyBhcmUgc2lnbmFsbGVkIGluIG1hbmlmZXN0XG4gICAgICAgIC8vIGZvcmNlIEhFLUFBQyAsIGFzIGl0IHNlZW1zIHRoYXQgbW9zdCBicm93c2VycyBwcmVmZXJzIHRoYXQgd2F5LFxuICAgICAgICAvLyBleGNlcHQgZm9yIG1vbm8gc3RyZWFtcyBPUiBvbiBGRlxuICAgICAgICAvLyB0aGVzZSBjb25kaXRpb25zIG1pZ2h0IG5lZWQgdG8gYmUgcmV2aWV3ZWQgLi4uXG4gICAgICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgICAgICAvLyBkb24ndCBmb3JjZSBIRS1BQUMgaWYgbW9ubyBzdHJlYW1cbiAgICAgICAgICBpZiAodHJhY2subWV0YWRhdGEuY2hhbm5lbENvdW50ICE9PSAxICYmXG4gICAgICAgICAgICAvLyBkb24ndCBmb3JjZSBIRS1BQUMgaWYgZmlyZWZveFxuICAgICAgICAgICAgdWEuaW5kZXhPZignZmlyZWZveCcpID09PSAtMSkge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIRS1BQUMgaXMgYnJva2VuIG9uIEFuZHJvaWQsIGFsd2F5cyBzaWduYWwgYXVkaW8gY29kZWMgYXMgQUFDIGV2ZW4gaWYgdmFyaWFudCBtYW5pZmVzdCBzdGF0ZXMgb3RoZXJ3aXNlXG4gICAgICAgIGlmICh1YS5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xICYmIHRyYWNrLmNvbnRhaW5lciAhPT0gJ2F1ZGlvL21wZWcnKSB7IC8vIEV4Y2x1ZGUgbXBlZyBhdWRpb1xuICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgICBsb2dnZXIubG9nKGBBbmRyb2lkOiBmb3JjZSBhdWRpbyBjb2RlYyB0byAke2F1ZGlvQ29kZWN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2subGV2ZWxDb2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICAgIHRyYWNrLmlkID0gZGF0YS5pZDtcbiAgICAgIH1cbiAgICAgIHRyYWNrID0gdHJhY2tzLnZpZGVvO1xuICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgIHRyYWNrLmxldmVsQ29kZWMgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXS52aWRlb0NvZGVjO1xuICAgICAgICB0cmFjay5pZCA9IGRhdGEuaWQ7XG4gICAgICB9XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9DT0RFQ1MsIHRyYWNrcyk7XG4gICAgICAvLyBsb29wIHRocm91Z2ggdHJhY2tzIHRoYXQgYXJlIGdvaW5nIHRvIGJlIHByb3ZpZGVkIHRvIGJ1ZmZlckNvbnRyb2xsZXJcbiAgICAgIGZvciAodHJhY2tOYW1lIGluIHRyYWNrcykge1xuICAgICAgICB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICBsb2dnZXIubG9nKGBtYWluIHRyYWNrOiR7dHJhY2tOYW1lfSxjb250YWluZXI6JHt0cmFjay5jb250YWluZXJ9LGNvZGVjc1tsZXZlbC9wYXJzZWRdPVske3RyYWNrLmxldmVsQ29kZWN9LyR7dHJhY2suY29kZWN9XWApO1xuICAgICAgICBsZXQgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcbiAgICAgICAgaWYgKGluaXRTZWdtZW50KSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcbiAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQlVGRkVSX0FQUEVORElORywgeyB0eXBlOiB0cmFja05hbWUsIGRhdGE6IGluaXRTZWdtZW50LCBwYXJlbnQ6ICdtYWluJywgY29udGVudDogJ2luaXRTZWdtZW50JyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnUGFyc2luZ0RhdGEgKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgY29uc3QgZnJhZ05ldyA9IGRhdGEuZnJhZztcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5pZCA9PT0gJ21haW4nICYmXG4gICAgICAgIGZyYWdOZXcuc24gPT09IGZyYWdDdXJyZW50LnNuICYmXG4gICAgICAgIGZyYWdOZXcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsICYmXG4gICAgICAgICEoZGF0YS50eXBlID09PSAnYXVkaW8nICYmIHRoaXMuYWx0QXVkaW8pICYmIC8vIGZpbHRlciBvdXQgbWFpbiBhdWRpbyBpZiBhdWRpbyB0cmFjayBpcyBsb2FkZWQgdGhyb3VnaCBhdWRpbyBzdHJlYW0gY29udHJvbGxlclxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICBsZXQgbGV2ZWwgPSB0aGlzLmxldmVsc1t0aGlzLmxldmVsXSxcbiAgICAgICAgZnJhZyA9IGZyYWdDdXJyZW50O1xuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZGF0YS5lbmRQVFMpKSB7XG4gICAgICAgIGRhdGEuZW5kUFRTID0gZGF0YS5zdGFydFBUUyArIGZyYWdDdXJyZW50LmR1cmF0aW9uO1xuICAgICAgICBkYXRhLmVuZERUUyA9IGRhdGEuc3RhcnREVFMgKyBmcmFnQ3VycmVudC5kdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuaGFzQXVkaW8gPT09IHRydWUpIHtcbiAgICAgICAgZnJhZy5hZGRFbGVtZW50YXJ5U3RyZWFtKEZyYWdtZW50LkVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmhhc1ZpZGVvID09PSB0cnVlKSB7XG4gICAgICAgIGZyYWcuYWRkRWxlbWVudGFyeVN0cmVhbShGcmFnbWVudC5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8pO1xuICAgICAgfVxuXG4gICAgICBsb2dnZXIubG9nKGBQYXJzZWQgJHtkYXRhLnR5cGV9LFBUUzpbJHtkYXRhLnN0YXJ0UFRTLnRvRml4ZWQoMyl9LCR7ZGF0YS5lbmRQVFMudG9GaXhlZCgzKX1dLERUUzpbJHtkYXRhLnN0YXJ0RFRTLnRvRml4ZWQoMyl9LyR7ZGF0YS5lbmREVFMudG9GaXhlZCgzKX1dLG5iOiR7ZGF0YS5uYn0sZHJvcHBlZDoke2RhdGEuZHJvcHBlZCB8fCAwfWApO1xuXG4gICAgICAvLyBEZXRlY3QgZ2FwcyBpbiBhIGZyYWdtZW50ICBhbmQgdHJ5IHRvIGZpeCBpdCBieSBmaW5kaW5nIGEga2V5ZnJhbWUgaW4gdGhlIHByZXZpb3VzIGZyYWdtZW50IChzZWUgX2ZpbmRGcmFnbWVudHMpXG4gICAgICBpZiAoZGF0YS50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgIGZyYWcuZHJvcHBlZCA9IGRhdGEuZHJvcHBlZDtcbiAgICAgICAgaWYgKGZyYWcuZHJvcHBlZCkge1xuICAgICAgICAgIGlmICghZnJhZy5iYWNrdHJhY2tlZCkge1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICAgICAgICAgIGlmIChsZXZlbERldGFpbHMgJiYgZnJhZy5zbiA9PT0gbGV2ZWxEZXRhaWxzLnN0YXJ0U04pIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ21pc3NpbmcgdmlkZW8gZnJhbWUocykgb24gZmlyc3QgZnJhZywgYXBwZW5kaW5nIHdpdGggZ2FwJywgZnJhZy5zbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsb2dnZXIud2FybignbWlzc2luZyB2aWRlbyBmcmFtZShzKSwgYmFja3RyYWNraW5nIGZyYWdtZW50JywgZnJhZy5zbik7XG4gICAgICAgICAgICAgIC8vIFJldHVybiBiYWNrIHRvIHRoZSBJRExFIHN0YXRlIHdpdGhvdXQgYXBwZW5kaW5nIHRvIGJ1ZmZlclxuICAgICAgICAgICAgICAvLyBDYXVzZXMgZmluZEZyYWdtZW50cyB0byBiYWNrdHJhY2sgYSBzZWdtZW50IGFuZCBmaW5kIHRoZSBrZXlmcmFtZVxuICAgICAgICAgICAgICAvLyBBdWRpbyBmcmFnbWVudHMgYXJyaXZpbmcgYmVmb3JlIHZpZGVvIHNldHMgdGhlIG5leHRMb2FkUG9zaXRpb24sIGNhdXNpbmcgX2ZpbmRGcmFnbWVudHMgdG8gc2tpcCB0aGUgYmFja3RyYWNrZWQgZnJhZ21lbnRcbiAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgICAgICAgIGZyYWcuYmFja3RyYWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBkYXRhLnN0YXJ0UFRTO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybignQWxyZWFkeSBiYWNrdHJhY2tlZCBvbiB0aGlzIGZyYWdtZW50LCBhcHBlbmRpbmcgd2l0aCB0aGUgZ2FwJywgZnJhZy5zbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE9ubHkgcmVzZXQgdGhlIGJhY2t0cmFja2VkIGZsYWcgaWYgd2UndmUgbG9hZGVkIHRoZSBmcmFnIHdpdGhvdXQgYW55IGRyb3BwZWQgZnJhbWVzXG4gICAgICAgICAgZnJhZy5iYWNrdHJhY2tlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBkcmlmdCA9IExldmVsSGVscGVyLnVwZGF0ZUZyYWdQVFNEVFMobGV2ZWwuZGV0YWlscywgZnJhZywgZGF0YS5zdGFydFBUUywgZGF0YS5lbmRQVFMsIGRhdGEuc3RhcnREVFMsIGRhdGEuZW5kRFRTKSxcbiAgICAgICAgaGxzID0gdGhpcy5obHM7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5MRVZFTF9QVFNfVVBEQVRFRCwgeyBkZXRhaWxzOiBsZXZlbC5kZXRhaWxzLCBsZXZlbDogdGhpcy5sZXZlbCwgZHJpZnQ6IGRyaWZ0LCB0eXBlOiBkYXRhLnR5cGUsIHN0YXJ0OiBkYXRhLnN0YXJ0UFRTLCBlbmQ6IGRhdGEuZW5kUFRTIH0pO1xuICAgICAgLy8gaGFzIHJlbXV4ZXIgZHJvcHBlZCB2aWRlbyBmcmFtZXMgbG9jYXRlZCBiZWZvcmUgZmlyc3Qga2V5ZnJhbWUgP1xuICAgICAgW2RhdGEuZGF0YTEsIGRhdGEuZGF0YTJdLmZvckVhY2goYnVmZmVyID0+IHtcbiAgICAgICAgLy8gb25seSBhcHBlbmQgaW4gUEFSU0lORyBzdGF0ZSAocmF0aW9uYWxlIGlzIHRoYXQgYW4gYXBwZW5kaW5nIGVycm9yIGNvdWxkIGhhcHBlbiBzeW5jaHJvbm91c2x5IG9uIGZpcnN0IHNlZ21lbnQgYXBwZW5kaW5nKVxuICAgICAgICAvLyBpbiB0aGF0IGNhc2UgaXQgaXMgdXNlbGVzcyB0byBhcHBlbmQgZm9sbG93aW5nIHNlZ21lbnRzXG4gICAgICAgIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aCAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgLy8gYXJtIHBlbmRpbmcgQnVmZmVyaW5nIGZsYWcgYmVmb3JlIGFwcGVuZGluZyBhIHNlZ21lbnRcbiAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9BUFBFTkRJTkcsIHsgdHlwZTogZGF0YS50eXBlLCBkYXRhOiBidWZmZXIsIHBhcmVudDogJ21haW4nLCBjb250ZW50OiAnZGF0YScgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnUGFyc2VkIChkYXRhKSB7XG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGNvbnN0IGZyYWdOZXcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKGZyYWdDdXJyZW50ICYmXG4gICAgICAgIGRhdGEuaWQgPT09ICdtYWluJyAmJlxuICAgICAgICBmcmFnTmV3LnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICBmcmFnTmV3LmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCAmJlxuICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICB0aGlzLnN0YXRzLnRwYXJzZWQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0VEO1xuICAgICAgdGhpcy5fY2hlY2tBcHBlbmRlZFBhcnNlZCgpO1xuICAgIH1cbiAgfVxuXG4gIG9uQXVkaW9UcmFja1N3aXRjaGluZyAoZGF0YSkge1xuICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICBsZXQgYWx0QXVkaW8gPSAhIWRhdGEudXJsLFxuICAgICAgdHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgLy8gaWYgd2Ugc3dpdGNoIG9uIG1haW4gYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCBtZWRpYS5idWZmZXJlZFxuICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIHdlIHN3aXRjaCB0byBhbHQgYXVkaW86IGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyIGlzIGhhbmRsaW5nIGl0LlxuICAgIC8vIHdlIHdpbGwganVzdCBoYXZlIHRvIGNoYW5nZSBidWZmZXIgc2NoZWR1bGluZyBvbiBhdWRpb1RyYWNrU3dpdGNoZWRcbiAgICBpZiAoIWFsdEF1ZGlvKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYUJ1ZmZlciAhPT0gdGhpcy5tZWRpYSkge1xuICAgICAgICBsb2dnZXIubG9nKCdzd2l0Y2hpbmcgb24gbWFpbiBhdWRpbywgdXNlIG1lZGlhLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZycpO1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYTtcbiAgICAgICAgbGV0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgLy8gd2UgbmVlZCB0byByZWZpbGwgYXVkaW8gYnVmZmVyIGZyb20gbWFpbjogY2FuY2VsIGFueSBmcmFnIGxvYWRpbmcgdG8gc3BlZWQgdXAgYXVkaW8gc3dpdGNoXG4gICAgICAgIGlmIChmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdzd2l0Y2hpbmcgdG8gbWFpbiBhdWRpbyB0cmFjaywgY2FuY2VsIG1haW4gZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgIC8vIGRlc3Ryb3kgZGVtdXhlciB0byBmb3JjZSBpbml0IHNlZ21lbnQgZ2VuZXJhdGlvbiAoZm9sbG93aW5nIGF1ZGlvIHN3aXRjaClcbiAgICAgICAgaWYgKHRoaXMuZGVtdXhlcikge1xuICAgICAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIGxldCBobHMgPSB0aGlzLmhscztcbiAgICAgIC8vIHN3aXRjaGluZyB0byBtYWluIGF1ZGlvLCBmbHVzaCBhbGwgYXVkaW8gYW5kIHRyaWdnZXIgdHJhY2sgc3dpdGNoZWRcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50LkJVRkZFUl9GTFVTSElORywgeyBzdGFydE9mZnNldDogMCwgZW5kT2Zmc2V0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHR5cGU6ICdhdWRpbycgfSk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5BVURJT19UUkFDS19TV0lUQ0hFRCwgeyBpZDogdHJhY2tJZCB9KTtcbiAgICAgIHRoaXMuYWx0QXVkaW8gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hlZCAoZGF0YSkge1xuICAgIGxldCB0cmFja0lkID0gZGF0YS5pZCxcbiAgICAgIGFsdEF1ZGlvID0gISF0aGlzLmhscy5hdWRpb1RyYWNrc1t0cmFja0lkXS51cmw7XG4gICAgaWYgKGFsdEF1ZGlvKSB7XG4gICAgICBsZXQgdmlkZW9CdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyO1xuICAgICAgLy8gaWYgd2Ugc3dpdGNoZWQgb24gYWx0ZXJuYXRlIGF1ZGlvLCBlbnN1cmUgdGhhdCBtYWluIGZyYWdtZW50IHNjaGVkdWxpbmcgaXMgc3luY2VkIHdpdGggdmlkZW8gc291cmNlYnVmZmVyIGJ1ZmZlcmVkXG4gICAgICBpZiAodmlkZW9CdWZmZXIgJiYgdGhpcy5tZWRpYUJ1ZmZlciAhPT0gdmlkZW9CdWZmZXIpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnc3dpdGNoaW5nIG9uIGFsdGVybmF0ZSBhdWRpbywgdXNlIHZpZGVvLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZycpO1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdmlkZW9CdWZmZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWx0QXVkaW8gPSBhbHRBdWRpbztcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIG9uQnVmZmVyQ3JlYXRlZCAoZGF0YSkge1xuICAgIGxldCB0cmFja3MgPSBkYXRhLnRyYWNrcywgbWVkaWFUcmFjaywgbmFtZSwgYWx0ZXJuYXRlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgdHlwZSBpbiB0cmFja3MpIHtcbiAgICAgIGxldCB0cmFjayA9IHRyYWNrc1t0eXBlXTtcbiAgICAgIGlmICh0cmFjay5pZCA9PT0gJ21haW4nKSB7XG4gICAgICAgIG5hbWUgPSB0eXBlO1xuICAgICAgICBtZWRpYVRyYWNrID0gdHJhY2s7XG4gICAgICAgIC8vIGtlZXAgdmlkZW8gc291cmNlIGJ1ZmZlciByZWZlcmVuY2VcbiAgICAgICAgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICB0aGlzLnZpZGVvQnVmZmVyID0gdHJhY2tzW3R5cGVdLmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWx0ZXJuYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsdGVybmF0ZSAmJiBtZWRpYVRyYWNrKSB7XG4gICAgICBsb2dnZXIubG9nKGBhbHRlcm5hdGUgdHJhY2sgZm91bmQsIHVzZSAke25hbWV9LmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZ2ApO1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG1lZGlhVHJhY2suYnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYTtcbiAgICB9XG4gIH1cblxuICBvbkJ1ZmZlckFwcGVuZGVkIChkYXRhKSB7XG4gICAgaWYgKGRhdGEucGFyZW50ID09PSAnbWFpbicpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIGlmIChzdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fCBzdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiBhcHBlbmRlZFxuICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXJpbmcgPSAoZGF0YS5wZW5kaW5nID4gMCk7XG4gICAgICAgIHRoaXMuX2NoZWNrQXBwZW5kZWRQYXJzZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY2hlY2tBcHBlbmRlZFBhcnNlZCAoKSB7XG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQgJiYgKCF0aGlzLmFwcGVuZGVkIHx8ICF0aGlzLnBlbmRpbmdCdWZmZXJpbmcpKSB7XG4gICAgICBjb25zdCBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgICAgICBsb2dnZXIubG9nKGBtYWluIGJ1ZmZlcmVkIDogJHtUaW1lUmFuZ2VzLnRvU3RyaW5nKG1lZGlhLmJ1ZmZlcmVkKX1gKTtcbiAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgICAgIHN0YXRzLnRidWZmZXJlZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGdldCByaWQgb2YgdGhpcy5mcmFnTGFzdEticHNcbiAgICAgICAgdGhpcy5mcmFnTGFzdEticHMgPSBNYXRoLnJvdW5kKDggKiBzdGF0cy50b3RhbCAvIChzdGF0cy50YnVmZmVyZWQgLSBzdGF0cy50Zmlyc3QpKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0JVRkZFUkVELCB7IHN0YXRzOiBzdGF0cywgZnJhZzogZnJhZywgaWQ6ICdtYWluJyB9KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cblxuICBvbkVycm9yIChkYXRhKSB7XG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWcgfHzCoHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgLy8gZG9uJ3QgaGFuZGxlIGZyYWcgZXJyb3Igbm90IHJlbGF0ZWQgdG8gbWFpbiBmcmFnbWVudFxuICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gJ21haW4nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gMC41IDogdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgZW5kXG4gICAgbGV0IG1lZGlhQnVmZmVyZWQgPSAhIXRoaXMubWVkaWEgJiYgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodGhpcy5tZWRpYSwgdGhpcy5tZWRpYS5jdXJyZW50VGltZSkgJiYgQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodGhpcy5tZWRpYSwgdGhpcy5tZWRpYS5jdXJyZW50VGltZSArIDAuNSk7XG5cbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgaWYgKCFkYXRhLmZhdGFsKSB7XG4gICAgICAgIC8vIGtlZXAgcmV0cnlpbmcgdW50aWwgdGhlIGxpbWl0IHdpbGwgYmUgcmVhY2hlZFxuICAgICAgICBpZiAoKHRoaXMuZnJhZ0xvYWRFcnJvciArIDEpIDw9IHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnkpIHtcbiAgICAgICAgICAvLyBleHBvbmVudGlhbCBiYWNrb2ZmIGNhcHBlZCB0byBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXRcbiAgICAgICAgICBsZXQgZGVsYXkgPSBNYXRoLm1pbihNYXRoLnBvdygyLCB0aGlzLmZyYWdMb2FkRXJyb3IpICogdGhpcy5jb25maWcuZnJhZ0xvYWRpbmdSZXRyeURlbGF5LCB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCk7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYG1lZGlhQ29udHJvbGxlcjogZnJhZyBsb2FkaW5nIGZhaWxlZCwgcmV0cnkgaW4gJHtkZWxheX0gbXNgKTtcbiAgICAgICAgICB0aGlzLnJldHJ5RGF0ZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSArIGRlbGF5O1xuICAgICAgICAgIC8vIHJldHJ5IGxvYWRpbmcgc3RhdGVcbiAgICAgICAgICAvLyBpZiBsb2FkZWRtZXRhZGF0YSBpcyBub3Qgc2V0LCBpdCBtZWFucyB0aGF0IHdlIGFyZSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb24gZmlyc3QgZnJhZ1xuICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcbiAgICAgICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZnJhZ0xvYWRFcnJvcisrO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoYG1lZGlhQ29udHJvbGxlcjogJHtkYXRhLmRldGFpbHN9IHJlYWNoZXMgbWF4IHJldHJ5LCByZWRpc3BhdGNoIGFzIGZhdGFsIC4uLmApO1xuICAgICAgICAgIC8vIHN3aXRjaCBlcnJvciB0byBmYXRhbFxuICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FUlJPUjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuRVJST1IpIHtcbiAgICAgICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgICAgICAvLyBpZiBmYXRhbCBlcnJvciwgc3RvcCBwcm9jZXNzaW5nXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBzdHJlYW1Db250cm9sbGVyOiAke2RhdGEuZGV0YWlsc30sc3dpdGNoIHRvICR7dGhpcy5zdGF0ZX0gc3RhdGUgLi4uYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSBvZiBub24gZmF0YWwgZXJyb3Igd2hpbGUgbG9hZGluZyBsZXZlbCwgaWYgbGV2ZWwgY29udHJvbGxlciBpcyBub3QgcmV0cnlpbmcgdG8gbG9hZCBsZXZlbCAsIHN3aXRjaCBiYWNrIHRvIElETEVcbiAgICAgICAgICBpZiAoIWRhdGEubGV2ZWxSZXRyeSAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX0xFVkVMKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgLy8gaWYgaW4gYXBwZW5kaW5nIHN0YXRlXG4gICAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdtYWluJyAmJiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fMKgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0VEKSkge1xuICAgICAgICAvLyByZWR1Y2UgbWF4IGJ1ZiBsZW4gaWYgY3VycmVudCBwb3NpdGlvbiBpcyBidWZmZXJlZFxuICAgICAgICBpZiAobWVkaWFCdWZmZXJlZCkge1xuICAgICAgICAgIHRoaXMuX3JlZHVjZU1heEJ1ZmZlckxlbmd0aCh0aGlzLmNvbmZpZy5tYXhCdWZmZXJMZW5ndGgpO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLCBidXQgYnJvd3NlciBpcyBzdGlsbCBjb21wbGFpbmluZyBhYm91dCBidWZmZXIgZnVsbCBlcnJvclxuICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBvbiBJRS9FZGdlLCByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9wdWxsLzcwOFxuICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSBmbHVzaCB0aGUgd2hvbGUgYnVmZmVyIHRvIHJlY292ZXJcbiAgICAgICAgICBsb2dnZXIud2FybignYnVmZmVyIGZ1bGwgZXJyb3IgYWxzbyBtZWRpYS5jdXJyZW50VGltZSBpcyBub3QgYnVmZmVyZWQsIGZsdXNoIGV2ZXJ5dGhpbmcnKTtcbiAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAvLyBmbHVzaCBldmVyeXRoaW5nXG4gICAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIF9yZWR1Y2VNYXhCdWZmZXJMZW5ndGggKG1pbkxlbmd0aCkge1xuICAgIGxldCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCA+PSBtaW5MZW5ndGgpIHtcbiAgICAgIC8vIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCBhcyBpdCBtaWdodCBiZSB0b28gaGlnaC4gd2UgZG8gdGhpcyB0byBhdm9pZCBsb29wIGZsdXNoaW5nIC4uLlxuICAgICAgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCAvPSAyO1xuICAgICAgbG9nZ2VyLndhcm4oYG1haW46cmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIHRvICR7Y29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aH1zYCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgaGVhbHRoIG9mIHRoZSBidWZmZXIgYW5kIGF0dGVtcHRzIHRvIHJlc29sdmUgcGxheWJhY2sgc3RhbGxzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrQnVmZmVyICgpIHtcbiAgICBjb25zdCB7IG1lZGlhIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEgfHwgbWVkaWEucmVhZHlTdGF0ZSA9PT0gMCkge1xuICAgICAgLy8gRXhpdCBlYXJseSBpZiB3ZSBkb24ndCBoYXZlIG1lZGlhIG9yIGlmIHRoZSBtZWRpYSBoYXNuJ3QgYnVmZmVyZCBhbnl0aGluZyB5ZXQgKHJlYWR5U3RhdGUgMClcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogbWVkaWE7XG4gICAgY29uc3QgYnVmZmVyZWQgPSBtZWRpYUJ1ZmZlci5idWZmZXJlZDtcblxuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSAmJiBidWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSB0cnVlO1xuICAgICAgdGhpcy5fc2Vla1RvU3RhcnRQb3MoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaW1tZWRpYXRlU3dpdGNoKSB7XG4gICAgICB0aGlzLmltbWVkaWF0ZUxldmVsU3dpdGNoRW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2FwQ29udHJvbGxlci5wb2xsKHRoaXMubGFzdEN1cnJlbnRUaW1lLCBidWZmZXJlZCk7XG4gICAgfVxuICB9XG5cbiAgb25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQgKCkge1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIC8vIGlmIGxvYWRlZG1ldGFkYXRhIGlzIG5vdCBzZXQsIGl0IG1lYW5zIHRoYXQgd2UgYXJlIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBvbiBmaXJzdCBmcmFnXG4gICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICB9XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cblxuICBvbkJ1ZmZlckZsdXNoZWQgKCkge1xuICAgIC8qIGFmdGVyIHN1Y2Nlc3NmdWwgYnVmZmVyIGZsdXNoaW5nLCBmaWx0ZXIgZmx1c2hlZCBmcmFnbWVudHMgZnJvbSBidWZmZXJlZEZyYWdzXG4gICAgICB1c2UgbWVkaWFCdWZmZXJlZCBpbnN0ZWFkIG9mIG1lZGlhIChzbyB0aGF0IHdlIHdpbGwgY2hlY2sgYWdhaW5zdCB2aWRlby5idWZmZXJlZCByYW5nZXMgaW4gY2FzZSBvZiBhbHQgYXVkaW8gdHJhY2spXG4gICAgKi9cbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIC8vIGZpbHRlciBmcmFnbWVudHMgcG90ZW50aWFsbHkgZXZpY3RlZCBmcm9tIGJ1ZmZlci4gdGhpcyBpcyB0byBhdm9pZCBtZW1sZWFrIG9uIGxpdmUgc3RyZWFtc1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhGcmFnbWVudC5FbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8sIG1lZGlhLmJ1ZmZlcmVkKTtcbiAgICB9XG4gICAgLy8gbW92ZSB0byBJRExFIG9uY2UgZmx1c2ggY29tcGxldGUuIHRoaXMgc2hvdWxkIHRyaWdnZXIgbmV3IGZyYWdtZW50IGxvYWRpbmdcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAvLyByZXNldCByZWZlcmVuY2UgdG8gZnJhZ1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgfVxuXG4gIHN3YXBBdWRpb0NvZGVjICgpIHtcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gIXRoaXMuYXVkaW9Db2RlY1N3YXA7XG4gIH1cblxuICBjb21wdXRlTGl2ZVBvc2l0aW9uIChzbGlkaW5nLCBsZXZlbERldGFpbHMpIHtcbiAgICBsZXQgdGFyZ2V0TGF0ZW5jeSA9IHRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IHRoaXMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb24gOiB0aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgcmV0dXJuIHNsaWRpbmcgKyBNYXRoLm1heCgwLCBsZXZlbERldGFpbHMudG90YWxkdXJhdGlvbiAtIHRhcmdldExhdGVuY3kpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlZWtzIHRvIHRoZSBzZXQgc3RhcnRQb3NpdGlvbiBpZiBub3QgZXF1YWwgdG8gdGhlIG1lZGlhRWxlbWVudCdzIGN1cnJlbnQgdGltZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZWVrVG9TdGFydFBvcyAoKSB7XG4gICAgY29uc3QgeyBtZWRpYSB9ID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIC8vIG9ubHkgYWRqdXN0IGN1cnJlbnRUaW1lIGlmIGRpZmZlcmVudCBmcm9tIHN0YXJ0UG9zaXRpb24gb3IgaWYgc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWRcbiAgICAvLyBhdCB0aGF0IHN0YWdlLCB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgYnVmZmVyZWQgcmFuZ2UsIGFzIHdlIHJlYWNoIHRoYXQgY29kZSBhZnRlciBmaXJzdCBmcmFnbWVudCBoYXMgYmVlbiBidWZmZXJlZFxuICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSBtZWRpYS5zZWVraW5nID8gY3VycmVudFRpbWUgOiB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgLy8gaWYgY3VycmVudFRpbWUgbm90IG1hdGNoaW5nIHdpdGggZXhwZWN0ZWQgc3RhcnRQb3NpdGlvbiBvciBzdGFydFBvc2l0aW9uIG5vdCBidWZmZXJlZCBidXQgY2xvc2UgdG8gZmlyc3QgYnVmZmVyZWRcbiAgICBpZiAoY3VycmVudFRpbWUgIT09IHN0YXJ0UG9zaXRpb24pIHtcbiAgICAgIC8vIGlmIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkLCBsZXQncyBzZWVrIHRvIGJ1ZmZlcmVkLnN0YXJ0KDApXG4gICAgICBsb2dnZXIubG9nKGB0YXJnZXQgc3RhcnQgcG9zaXRpb24gbm90IGJ1ZmZlcmVkLCBzZWVrIHRvIGJ1ZmZlcmVkLnN0YXJ0KDApICR7c3RhcnRQb3NpdGlvbn0gZnJvbSBjdXJyZW50IHRpbWUgJHtjdXJyZW50VGltZX0gYCk7XG4gICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgX2dldEF1ZGlvQ29kZWMgKGN1cnJlbnRMZXZlbCkge1xuICAgIGxldCBhdWRpb0NvZGVjID0gdGhpcy5jb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG4gICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3YXApIHtcbiAgICAgIGxvZ2dlci5sb2coJ3N3YXBwaW5nIHBsYXlsaXN0IGF1ZGlvIGNvZGVjJyk7XG4gICAgICBpZiAoYXVkaW9Db2RlYykge1xuICAgICAgICBpZiAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGF1ZGlvQ29kZWM7XG4gIH1cblxuICBnZXQgbGl2ZVN5bmNQb3NpdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpdmVTeW5jUG9zaXRpb247XG4gIH1cblxuICBzZXQgbGl2ZVN5bmNQb3NpdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLl9saXZlU3luY1Bvc2l0aW9uID0gdmFsdWU7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFN0cmVhbUNvbnRyb2xsZXI7XG4iLCIvKipcbiAqIEBjbGFzcyBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJcbiAqL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgRGVjcnlwdGVyIGZyb20gJy4uL2NyeXB0L2RlY3J5cHRlcic7XG5pbXBvcnQgeyBCdWZmZXJIZWxwZXIgfSBmcm9tICcuLi91dGlscy9idWZmZXItaGVscGVyJztcbmltcG9ydCB7IGZpbmRGcmFnbWVudEJ5UERULCBmaW5kRnJhZ21lbnRCeVBUUyB9IGZyb20gJy4vZnJhZ21lbnQtZmluZGVycyc7XG5pbXBvcnQgeyBGcmFnbWVudFN0YXRlIH0gZnJvbSAnLi9mcmFnbWVudC10cmFja2VyJztcbmltcG9ydCBCYXNlU3RyZWFtQ29udHJvbGxlciwgeyBTdGF0ZSB9IGZyb20gJy4vYmFzZS1zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgeyBtZXJnZVN1YnRpdGxlUGxheWxpc3RzIH0gZnJvbSAnLi9sZXZlbC1oZWxwZXInO1xuXG5jb25zdCB7IHBlcmZvcm1hbmNlIH0gPSB3aW5kb3c7XG5jb25zdCBUSUNLX0lOVEVSVkFMID0gNTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuXG5leHBvcnQgY2xhc3MgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgQmFzZVN0cmVhbUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzLCBmcmFnbWVudFRyYWNrZXIpIHtcbiAgICBzdXBlcihobHMsXG4gICAgICBFdmVudC5NRURJQV9BVFRBQ0hFRCxcbiAgICAgIEV2ZW50Lk1FRElBX0RFVEFDSElORyxcbiAgICAgIEV2ZW50LkVSUk9SLFxuICAgICAgRXZlbnQuS0VZX0xPQURFRCxcbiAgICAgIEV2ZW50LkZSQUdfTE9BREVELFxuICAgICAgRXZlbnQuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsXG4gICAgICBFdmVudC5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsXG4gICAgICBFdmVudC5TVUJUSVRMRV9UUkFDS19MT0FERUQsXG4gICAgICBFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCxcbiAgICAgIEV2ZW50LkxFVkVMX1VQREFURUQpO1xuXG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy50cmFja3NCdWZmZXJlZCA9IFtdO1xuICAgIHRoaXMuY3VycmVudFRyYWNrSWQgPSAtMTtcbiAgICB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIoaGxzLCBobHMuY29uZmlnKTtcbiAgICAvLyBsYXN0QVZTdGFydCBzdG9yZXMgdGhlIHRpbWUgaW4gc2Vjb25kcyBmb3IgdGhlIHN0YXJ0IHRpbWUgb2YgYSBsZXZlbCBsb2FkXG4gICAgdGhpcy5sYXN0QVZTdGFydCA9IDA7XG4gICAgdGhpcy5fb25NZWRpYVNlZWtpbmcgPSB0aGlzLm9uTWVkaWFTZWVraW5nLmJpbmQodGhpcyk7XG4gIH1cblxuICBvblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZCAoZGF0YSkge1xuICAgIGNvbnN0IHsgZnJhZywgc3VjY2VzcyB9ID0gZGF0YTtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmZmVyZWQgPSB0aGlzLnRyYWNrc0J1ZmZlcmVkW3RoaXMuY3VycmVudFRyYWNrSWRdO1xuICAgIGlmICghYnVmZmVyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUvdXBkYXRlIGEgYnVmZmVyZWQgYXJyYXkgbWF0Y2hpbmcgdGhlIGludGVyZmFjZSB1c2VkIGJ5IEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm9cbiAgICAvLyBzbyB3ZSBjYW4gcmUtdXNlIHRoZSBsb2dpYyB1c2VkIHRvIGRldGVjdCBob3cgbXVjaCBoYXZlIGJlZW4gYnVmZmVyZWRcbiAgICBsZXQgdGltZVJhbmdlO1xuICAgIGNvbnN0IGZyYWdTdGFydCA9IGZyYWcuc3RhcnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGZyYWdTdGFydCA+PSBidWZmZXJlZFtpXS5zdGFydCAmJiBmcmFnU3RhcnQgPD0gYnVmZmVyZWRbaV0uZW5kKSB7XG4gICAgICAgIHRpbWVSYW5nZSA9IGJ1ZmZlcmVkW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmcmFnRW5kID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XG4gICAgaWYgKHRpbWVSYW5nZSkge1xuICAgICAgdGltZVJhbmdlLmVuZCA9IGZyYWdFbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVSYW5nZSA9IHtcbiAgICAgICAgc3RhcnQ6IGZyYWdTdGFydCxcbiAgICAgICAgZW5kOiBmcmFnRW5kXG4gICAgICB9O1xuICAgICAgYnVmZmVyZWQucHVzaCh0aW1lUmFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVkaWFBdHRhY2hlZCAoeyBtZWRpYSB9KSB7XG4gICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLl9vbk1lZGlhU2Vla2luZyk7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gIH1cblxuICBvbk1lZGlhRGV0YWNoaW5nICgpIHtcbiAgICB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLl9vbk1lZGlhU2Vla2luZyk7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gIH1cblxuICAvLyBJZiBzb21ldGhpbmcgZ29lcyB3cm9uZywgcHJvY2VlZCB0byBuZXh0IGZyYWcsIGlmIHdlIHdlcmUgcHJvY2Vzc2luZyBvbmUuXG4gIG9uRXJyb3IgKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAvLyBkb24ndCBoYW5kbGUgZXJyb3Igbm90IHJlbGF0ZWQgdG8gc3VidGl0bGUgZnJhZ21lbnRcbiAgICBpZiAoIWZyYWcgfHwgZnJhZy50eXBlICE9PSAnc3VidGl0bGUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICB9XG5cbiAgLy8gR290IGFsbCBuZXcgc3VidGl0bGUgdHJhY2tzLlxuICBvblN1YnRpdGxlVHJhY2tzVXBkYXRlZCAoZGF0YSkge1xuICAgIGxvZ2dlci5sb2coJ3N1YnRpdGxlIHRyYWNrcyB1cGRhdGVkJyk7XG4gICAgdGhpcy50cmFja3NCdWZmZXJlZCA9IFtdO1xuICAgIHRoaXMudHJhY2tzID0gZGF0YS5zdWJ0aXRsZVRyYWNrcztcbiAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgdGhpcy50cmFja3NCdWZmZXJlZFt0cmFjay5pZF0gPSBbXTtcbiAgICB9KTtcbiAgfVxuXG4gIG9uU3VidGl0bGVUcmFja1N3aXRjaCAoZGF0YSkge1xuICAgIHRoaXMuY3VycmVudFRyYWNrSWQgPSBkYXRhLmlkO1xuXG4gICAgaWYgKCF0aGlzLnRyYWNrcyB8fCB0aGlzLmN1cnJlbnRUcmFja0lkID09PSAtMSkge1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdHJhY2sgaGFzIHRoZSBuZWNlc3NhcnkgZGV0YWlscyB0byBsb2FkIGZyYWdtZW50c1xuICAgIGNvbnN0IGN1cnJlbnRUcmFjayA9IHRoaXMudHJhY2tzW3RoaXMuY3VycmVudFRyYWNrSWRdO1xuICAgIGlmIChjdXJyZW50VHJhY2sgJiYgY3VycmVudFRyYWNrLmRldGFpbHMpIHtcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgfVxuICB9XG5cbiAgLy8gR290IGEgbmV3IHNldCBvZiBzdWJ0aXRsZSBmcmFnbWVudHMuXG4gIG9uU3VidGl0bGVUcmFja0xvYWRlZCAoZGF0YSkge1xuICAgIGNvbnN0IHsgaWQsIGRldGFpbHMgfSA9IGRhdGE7XG4gICAgY29uc3QgeyBjdXJyZW50VHJhY2tJZCwgdHJhY2tzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFjayA9IHRyYWNrc1tjdXJyZW50VHJhY2tJZF07XG4gICAgaWYgKGlkID49IHRyYWNrcy5sZW5ndGggfHwgaWQgIT09IGN1cnJlbnRUcmFja0lkIHx8ICFjdXJyZW50VHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGV0YWlscy5saXZlKSB7XG4gICAgICBtZXJnZVN1YnRpdGxlUGxheWxpc3RzKGN1cnJlbnRUcmFjay5kZXRhaWxzLCBkZXRhaWxzLCB0aGlzLmxhc3RBVlN0YXJ0KTtcbiAgICB9XG4gICAgY3VycmVudFRyYWNrLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gIH1cblxuICBvbktleUxvYWRlZCAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLktFWV9MT0FESU5HKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gIH1cblxuICBvbkZyYWdMb2FkZWQgKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgY29uc3QgZGVjcnlwdERhdGEgPSBkYXRhLmZyYWcuZGVjcnlwdGRhdGE7XG4gICAgY29uc3QgZnJhZ0xvYWRlZCA9IGRhdGEuZnJhZztcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcblxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcgJiZcbiAgICAgICAgZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgZGF0YS5mcmFnLnR5cGUgPT09ICdzdWJ0aXRsZScgJiZcbiAgICAgICAgZnJhZ0N1cnJlbnQuc24gPT09IGRhdGEuZnJhZy5zbikge1xuICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSBwYXlsb2FkIG5lZWRzIHRvIGJlIGRlY3J5cHRlZFxuICAgICAgaWYgKGRhdGEucGF5bG9hZC5ieXRlTGVuZ3RoID4gMCAmJiAoZGVjcnlwdERhdGEgJiYgZGVjcnlwdERhdGEua2V5ICYmIGRlY3J5cHREYXRhLm1ldGhvZCA9PT0gJ0FFUy0xMjgnKSkge1xuICAgICAgICBsZXQgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgICAgLy8gZGVjcnlwdCB0aGUgc3VidGl0bGVzXG4gICAgICAgIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQoZGF0YS5wYXlsb2FkLCBkZWNyeXB0RGF0YS5rZXkuYnVmZmVyLCBkZWNyeXB0RGF0YS5pdi5idWZmZXIsIGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgICAgbGV0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudC5GUkFHX0RFQ1JZUFRFRCwgeyBmcmFnOiBmcmFnTG9hZGVkLCBwYXlsb2FkOiBkZWNyeXB0ZWREYXRhLCBzdGF0czogeyB0c3RhcnQ6IHN0YXJ0VGltZSwgdGRlY3J5cHQ6IGVuZFRpbWUgfSB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25MZXZlbFVwZGF0ZWQgKHsgZGV0YWlscyB9KSB7XG4gICAgY29uc3QgZnJhZ3MgPSBkZXRhaWxzLmZyYWdtZW50cztcbiAgICB0aGlzLmxhc3RBVlN0YXJ0ID0gZnJhZ3MubGVuZ3RoID8gZnJhZ3NbMF0uc3RhcnQgOiAwO1xuICB9XG5cbiAgZG9UaWNrICgpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgIGNhc2UgU3RhdGUuSURMRToge1xuICAgICAgY29uc3QgeyBjb25maWcsIGN1cnJlbnRUcmFja0lkLCBmcmFnbWVudFRyYWNrZXIsIG1lZGlhLCB0cmFja3MgfSA9IHRoaXM7XG4gICAgICBpZiAoIXRyYWNrcyB8fCAhdHJhY2tzW2N1cnJlbnRUcmFja0lkXSB8fCAhdHJhY2tzW2N1cnJlbnRUcmFja0lkXS5kZXRhaWxzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IG1heEJ1ZmZlckhvbGUsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgfSA9IGNvbmZpZztcbiAgICAgIGNvbnN0IG1heENvbmZpZ0J1ZmZlciA9IE1hdGgubWluKGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgsIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgpO1xuICAgICAgY29uc3QgYnVmZmVyZWRJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mbyh0aGlzLl9nZXRCdWZmZXJlZCgpLCBtZWRpYS5jdXJyZW50VGltZSwgbWF4QnVmZmVySG9sZSk7XG4gICAgICBjb25zdCB7IGVuZDogYnVmZmVyRW5kLCBsZW46IGJ1ZmZlckxlbiB9ID0gYnVmZmVyZWRJbmZvO1xuXG4gICAgICBjb25zdCB0cmFja0RldGFpbHMgPSB0cmFja3NbY3VycmVudFRyYWNrSWRdLmRldGFpbHM7XG4gICAgICBjb25zdCBmcmFnbWVudHMgPSB0cmFja0RldGFpbHMuZnJhZ21lbnRzO1xuICAgICAgY29uc3QgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgICBjb25zdCBlbmQgPSBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdLnN0YXJ0ICsgZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXS5kdXJhdGlvbjtcblxuICAgICAgaWYgKGJ1ZmZlckxlbiA+IG1heENvbmZpZ0J1ZmZlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBmb3VuZEZyYWc7XG4gICAgICBjb25zdCBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICAgIGlmIChidWZmZXJFbmQgPCBlbmQpIHtcbiAgICAgICAgaWYgKGZyYWdQcmV2aW91cyAmJiB0cmFja0RldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgICAgZm91bmRGcmFnID0gZmluZEZyYWdtZW50QnlQRFQoZnJhZ21lbnRzLCBmcmFnUHJldmlvdXMuZW5kUHJvZ3JhbURhdGVUaW1lLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvdW5kRnJhZykge1xuICAgICAgICAgIGZvdW5kRnJhZyA9IGZpbmRGcmFnbWVudEJ5UFRTKGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3VuZEZyYWcgPSBmcmFnbWVudHNbZnJhZ0xlbiAtIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm91bmRGcmFnICYmIGZvdW5kRnJhZy5lbmNyeXB0ZWQpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgTG9hZGluZyBrZXkgZm9yICR7Zm91bmRGcmFnLnNufWApO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuS0VZX0xPQURJTkc7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuS0VZX0xPQURJTkcsIHsgZnJhZzogZm91bmRGcmFnIH0pO1xuICAgICAgfSBlbHNlIGlmIChmb3VuZEZyYWcgJiYgZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZvdW5kRnJhZykgPT09IEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCkge1xuICAgICAgICAvLyBvbmx5IGxvYWQgaWYgZnJhZ21lbnQgaXMgbm90IGxvYWRlZFxuICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZm91bmRGcmFnO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkZSQUdfTE9BRElORywgeyBmcmFnOiBmb3VuZEZyYWcgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0b3BMb2FkICgpIHtcbiAgICB0aGlzLmxhc3RBVlN0YXJ0ID0gMDtcbiAgICBzdXBlci5zdG9wTG9hZCgpO1xuICB9XG5cbiAgX2dldEJ1ZmZlcmVkICgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXSB8fCBbXTtcbiAgfVxuXG4gIG9uTWVkaWFTZWVraW5nICgpIHtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gIH1cbn1cbiIsImltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBjb21wdXRlUmVsb2FkSW50ZXJ2YWwgfSBmcm9tICcuL2xldmVsLWhlbHBlcic7XG5cbmNsYXNzIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscykge1xuICAgIHN1cGVyKGhscyxcbiAgICAgIEV2ZW50Lk1FRElBX0FUVEFDSEVELFxuICAgICAgRXZlbnQuTUVESUFfREVUQUNISU5HLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BREVELFxuICAgICAgRXZlbnQuU1VCVElUTEVfVFJBQ0tfTE9BREVEKTtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufSBzdWJ0aXRsZURpc3BsYXkgRW5hYmxlL2Rpc2FibGUgc3VidGl0bGUgZGlzcGxheSByZW5kZXJpbmdcbiAgICAgKi9cbiAgICB0aGlzLnN1YnRpdGxlRGlzcGxheSA9IHRydWU7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8vIExpc3RlbiBmb3Igc3VidGl0bGUgdHJhY2sgY2hhbmdlLCB0aGVuIGV4dHJhY3QgdGhlIGN1cnJlbnQgdHJhY2sgSUQuXG4gIG9uTWVkaWFBdHRhY2hlZCAoZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnF1ZXVlZERlZmF1bHRUcmFjaykge1xuICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2s7XG4gICAgICBkZWxldGUgdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2s7XG4gICAgfVxuXG4gICAgdGhpcy50cmFja0NoYW5nZUxpc3RlbmVyID0gdGhpcy5fb25UZXh0VHJhY2tzQ2hhbmdlZC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nID0gISh0aGlzLm1lZGlhLnRleHRUcmFja3MgJiYgJ29uY2hhbmdlJyBpbiB0aGlzLm1lZGlhLnRleHRUcmFja3MpO1xuICAgIGlmICh0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcpIHtcbiAgICAgIHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHRoaXMudHJhY2tDaGFuZ2VMaXN0ZW5lcigpO1xuICAgICAgfSwgNTAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYS50ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMudHJhY2tDaGFuZ2VMaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiAgb25NZWRpYURldGFjaGluZyAoKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYS50ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMudHJhY2tDaGFuZ2VMaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gIH1cblxuICAvLyBGaXJlZCB3aGVuZXZlciBhIG5ldyBtYW5pZmVzdCBpcyBsb2FkZWQuXG4gIG9uTWFuaWZlc3RMb2FkZWQgKGRhdGEpIHtcbiAgICBsZXQgdHJhY2tzID0gZGF0YS5zdWJ0aXRsZXMgfHwgW107XG4gICAgdGhpcy50cmFja3MgPSB0cmFja3M7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgeyBzdWJ0aXRsZVRyYWNrczogdHJhY2tzIH0pO1xuXG4gICAgLy8gbG9vcCB0aHJvdWdoIGF2YWlsYWJsZSBzdWJ0aXRsZSB0cmFja3MgYW5kIGF1dG9zZWxlY3QgZGVmYXVsdCBpZiBuZWVkZWRcbiAgICAvLyBUT0RPOiBpbXByb3ZlIHNlbGVjdGlvbiBsb2dpYyB0byBoYW5kbGUgZm9yY2VkLCBldGNcbiAgICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBpZiAodHJhY2suZGVmYXVsdCkge1xuICAgICAgICAvLyBzZXR0aW5nIHRoaXMuc3VidGl0bGVUcmFjayB3aWxsIHRyaWdnZXIgaW50ZXJuYWwgbG9naWNcbiAgICAgICAgLy8gaWYgbWVkaWEgaGFzIG5vdCBiZWVuIGF0dGFjaGVkIHlldCwgaXQgd2lsbCBmYWlsXG4gICAgICAgIC8vIHdlIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGRlZmF1bHQgdHJhY2sgaWRcbiAgICAgICAgLy8gYW5kIHdlJ2xsIHNldCBzdWJ0aXRsZVRyYWNrIHdoZW4gb25NZWRpYUF0dGFjaGVkIGlzIHRyaWdnZXJlZFxuICAgICAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IHRyYWNrLmlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gdHJhY2suaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG9uU3VidGl0bGVUcmFja0xvYWRlZCAoZGF0YSkge1xuICAgIGNvbnN0IHsgaWQsIGRldGFpbHMgfSA9IGRhdGE7XG4gICAgY29uc3QgeyB0cmFja0lkLCB0cmFja3MgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRyYWNrID0gdHJhY2tzW3RyYWNrSWRdO1xuICAgIGlmIChpZCA+PSB0cmFja3MubGVuZ3RoIHx8IGlkICE9PSB0cmFja0lkIHx8ICFjdXJyZW50VHJhY2sgfHwgdGhpcy5zdG9wcGVkKSB7XG4gICAgICB0aGlzLl9jbGVhclJlbG9hZFRpbWVyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9nZ2VyLmxvZyhgc3VidGl0bGUgdHJhY2sgJHtpZH0gbG9hZGVkYCk7XG4gICAgaWYgKGRldGFpbHMubGl2ZSkge1xuICAgICAgY29uc3QgcmVsb2FkSW50ZXJ2YWwgPSBjb21wdXRlUmVsb2FkSW50ZXJ2YWwoY3VycmVudFRyYWNrLmRldGFpbHMsIGRldGFpbHMsIGRhdGEuc3RhdHMudHJlcXVlc3QpO1xuICAgICAgbG9nZ2VyLmxvZyhgUmVsb2FkaW5nIGxpdmUgc3VidGl0bGUgcGxheWxpc3QgaW4gJHtyZWxvYWRJbnRlcnZhbH1tc2ApO1xuICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9sb2FkQ3VycmVudFRyYWNrKCk7XG4gICAgICB9LCByZWxvYWRJbnRlcnZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NsZWFyUmVsb2FkVGltZXIoKTtcbiAgICB9XG4gIH1cblxuICBzdGFydExvYWQgKCkge1xuICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xvYWRDdXJyZW50VHJhY2soKTtcbiAgfVxuXG4gIHN0b3BMb2FkICgpIHtcbiAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICAgIHRoaXMuX2NsZWFyUmVsb2FkVGltZXIoKTtcbiAgfVxuXG4gIC8qKiBnZXQgYWx0ZXJuYXRlIHN1YnRpdGxlIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3QgKiovXG4gIGdldCBzdWJ0aXRsZVRyYWNrcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICB9XG5cbiAgLyoqIGdldCBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKSAqKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2sgKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gIH1cblxuICAvKiogc2VsZWN0IGEgc3VidGl0bGUgdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cyoqL1xuICBzZXQgc3VidGl0bGVUcmFjayAoc3VidGl0bGVUcmFja0lkKSB7XG4gICAgaWYgKHRoaXMudHJhY2tJZCAhPT0gc3VidGl0bGVUcmFja0lkKSB7XG4gICAgICB0aGlzLl90b2dnbGVUcmFja01vZGVzKHN1YnRpdGxlVHJhY2tJZCk7XG4gICAgICB0aGlzLl9zZXRTdWJ0aXRsZVRyYWNrSW50ZXJuYWwoc3VidGl0bGVUcmFja0lkKTtcbiAgICB9XG4gIH1cblxuICBfY2xlYXJSZWxvYWRUaW1lciAoKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIF9sb2FkQ3VycmVudFRyYWNrICgpIHtcbiAgICBjb25zdCB7IHRyYWNrSWQsIHRyYWNrcywgaGxzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFjayA9IHRyYWNrc1t0cmFja0lkXTtcbiAgICBpZiAodHJhY2tJZCA8IDAgfHwgIWN1cnJlbnRUcmFjayB8fCAoY3VycmVudFRyYWNrLmRldGFpbHMgJiYgIWN1cnJlbnRUcmFjay5kZXRhaWxzLmxpdmUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlci5sb2coYExvYWRpbmcgc3VidGl0bGUgdHJhY2sgJHt0cmFja0lkfWApO1xuICAgIGhscy50cmlnZ2VyKEV2ZW50LlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHsgdXJsOiBjdXJyZW50VHJhY2sudXJsLCBpZDogdHJhY2tJZCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgb2xkIHN1YnRpdGxlVHJhY2sgYW5kIHNldHMgY3VycmVudCBtb2RlIG9uIHRoZSBuZXh0IHN1YnRpdGxlVHJhY2suXG4gICAqIFRoaXMgb3BlcmF0ZXMgb24gdGhlIERPTSB0ZXh0VHJhY2tzLlxuICAgKiBBIHZhbHVlIG9mIC0xIHdpbGwgZGlzYWJsZSBhbGwgc3VidGl0bGUgdHJhY2tzLlxuICAgKiBAcGFyYW0gbmV3SWQgLSBUaGUgaWQgb2YgdGhlIG5leHQgdHJhY2sgdG8gZW5hYmxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdG9nZ2xlVHJhY2tNb2RlcyAobmV3SWQpIHtcbiAgICBjb25zdCB7IG1lZGlhLCBzdWJ0aXRsZURpc3BsYXksIHRyYWNrSWQgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRleHRUcmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyhtZWRpYS50ZXh0VHJhY2tzKTtcbiAgICBpZiAobmV3SWQgPT09IC0xKSB7XG4gICAgICBbXS5zbGljZS5jYWxsKHRleHRUcmFja3MpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICB0cmFjay5tb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvbGRUcmFjayA9IHRleHRUcmFja3NbdHJhY2tJZF07XG4gICAgICBpZiAob2xkVHJhY2spIHtcbiAgICAgICAgb2xkVHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbmV4dFRyYWNrID0gdGV4dFRyYWNrc1tuZXdJZF07XG4gICAgaWYgKG5leHRUcmFjaykge1xuICAgICAgbmV4dFRyYWNrLm1vZGUgPSBzdWJ0aXRsZURpc3BsYXkgPyAnc2hvd2luZycgOiAnaGlkZGVuJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyByZXNwb25zaWJsZSBmb3IgdmFsaWRhdGluZyB0aGUgc3VidGl0bGUgaW5kZXggYW5kIHBlcmlvZGljYWxseSByZWxvYWRpbmcgaWYgbGl2ZS5cbiAgICAgKiBEaXNwYXRjaGVzIHRoZSBTVUJUSVRMRV9UUkFDS19TV0lUQ0ggZXZlbnQsIHdoaWNoIGluc3RydWN0cyB0aGUgc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIgdG8gbG9hZCB0aGUgc2VsZWN0ZWQgdHJhY2suXG4gICAgICogQHBhcmFtIG5ld0lkIC0gVGhlIGlkIG9mIHRoZSBzdWJ0aXRsZSB0cmFjayB0byBhY3RpdmF0ZS5cbiAgICAgKi9cbiAgX3NldFN1YnRpdGxlVHJhY2tJbnRlcm5hbCAobmV3SWQpIHtcbiAgICBjb25zdCB7IGhscywgdHJhY2tzIH0gPSB0aGlzO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG5ld0lkKSB8fCBuZXdJZCA8IC0xIHx8IG5ld0lkID49IHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnRyYWNrSWQgPSBuZXdJZDtcbiAgICBsb2dnZXIubG9nKGBTd2l0Y2hpbmcgdG8gc3VidGl0bGUgdHJhY2sgJHtuZXdJZH1gKTtcbiAgICBobHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHsgaWQ6IG5ld0lkIH0pO1xuICAgIHRoaXMuX2xvYWRDdXJyZW50VHJhY2soKTtcbiAgfVxuXG4gIF9vblRleHRUcmFja3NDaGFuZ2VkICgpIHtcbiAgICAvLyBNZWRpYSBpcyB1bmRlZmluZWQgd2hlbiBzd2l0Y2hpbmcgc3RyZWFtcyB2aWEgbG9hZFNvdXJjZSgpXG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHRyYWNrSWQgPSAtMTtcbiAgICBsZXQgdHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3ModGhpcy5tZWRpYS50ZXh0VHJhY2tzKTtcbiAgICBmb3IgKGxldCBpZCA9IDA7IGlkIDwgdHJhY2tzLmxlbmd0aDsgaWQrKykge1xuICAgICAgaWYgKHRyYWNrc1tpZF0ubW9kZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgLy8gRG8gbm90IGJyZWFrIGluIGNhc2UgdGhlcmUgaXMgYSBmb2xsb3dpbmcgdHJhY2sgd2l0aCBzaG93aW5nLlxuICAgICAgICB0cmFja0lkID0gaWQ7XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrc1tpZF0ubW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgIHRyYWNrSWQgPSBpZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0dGluZyBjdXJyZW50IHN1YnRpdGxlVHJhY2sgd2lsbCBpbnZva2UgY29kZS5cbiAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSB0cmFja0lkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlclN1YnRpdGxlVHJhY2tzICh0ZXh0VHJhY2tMaXN0KSB7XG4gIGxldCB0cmFja3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0VHJhY2tMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdHJhY2sgPSB0ZXh0VHJhY2tMaXN0W2ldO1xuICAgIC8vIEVkZ2UgYWRkcyBhIHRyYWNrIHdpdGhvdXQgYSBsYWJlbDsgd2UgZG9uJ3Qgd2FudCB0byB1c2UgaXRcbiAgICBpZiAodHJhY2sua2luZCA9PT0gJ3N1YnRpdGxlcycgJiYgdHJhY2subGFiZWwpIHtcbiAgICAgIHRyYWNrcy5wdXNoKHRleHRUcmFja0xpc3RbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJhY2tzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiIsIi8qXG4gKiBUaW1lbGluZSBDb250cm9sbGVyXG4qL1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi4vZXZlbnQtaGFuZGxlcic7XG5pbXBvcnQgQ2VhNjA4UGFyc2VyIGZyb20gJy4uL3V0aWxzL2NlYS02MDgtcGFyc2VyJztcbmltcG9ydCBPdXRwdXRGaWx0ZXIgZnJvbSAnLi4vdXRpbHMvb3V0cHV0LWZpbHRlcic7XG5pbXBvcnQgV2ViVlRUUGFyc2VyIGZyb20gJy4uL3V0aWxzL3dlYnZ0dC1wYXJzZXInO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IHNlbmRBZGRUcmFja0V2ZW50LCBjbGVhckN1cnJlbnRDdWVzIH0gZnJvbSAnLi4vdXRpbHMvdGV4dHRyYWNrLXV0aWxzJztcblxuZnVuY3Rpb24gY2FuUmV1c2VWdHRUZXh0VHJhY2sgKGluVXNlVHJhY2ssIG1hbmlmZXN0VHJhY2spIHtcbiAgcmV0dXJuIGluVXNlVHJhY2sgJiYgaW5Vc2VUcmFjay5sYWJlbCA9PT0gbWFuaWZlc3RUcmFjay5uYW1lICYmICEoaW5Vc2VUcmFjay50ZXh0VHJhY2sxIHx8IGluVXNlVHJhY2sudGV4dFRyYWNrMik7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbiAoeDEsIHgyLCB5MSwgeTIpIHtcbiAgcmV0dXJuIE1hdGgubWluKHgyLCB5MikgLSBNYXRoLm1heCh4MSwgeTEpO1xufVxuXG5jbGFzcyBUaW1lbGluZUNvbnRyb2xsZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCBFdmVudC5NRURJQV9BVFRBQ0hJTkcsXG4gICAgICBFdmVudC5NRURJQV9ERVRBQ0hJTkcsXG4gICAgICBFdmVudC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsXG4gICAgICBFdmVudC5GUkFHX0RFQ1JZUFRFRCxcbiAgICAgIEV2ZW50Lk1BTklGRVNUX0xPQURJTkcsXG4gICAgICBFdmVudC5NQU5JRkVTVF9MT0FERUQsXG4gICAgICBFdmVudC5GUkFHX0xPQURFRCxcbiAgICAgIEV2ZW50LkxFVkVMX1NXSVRDSElORyxcbiAgICAgIEV2ZW50LklOSVRfUFRTX0ZPVU5EKTtcblxuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuQ3VlcyA9IGhscy5jb25maWcuY3VlSGFuZGxlcjtcbiAgICB0aGlzLnRleHRUcmFja3MgPSBbXTtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdO1xuICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICAgIHRoaXMuY3VlUmFuZ2VzID0gW107XG4gICAgdGhpcy5jYXB0aW9uc1RyYWNrcyA9IHt9O1xuXG4gICAgdGhpcy5jYXB0aW9uc1Byb3BlcnRpZXMgPSB7XG4gICAgICB0ZXh0VHJhY2sxOiB7XG4gICAgICAgIGxhYmVsOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazFMYWJlbCxcbiAgICAgICAgbGFuZ3VhZ2VDb2RlOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGVcbiAgICAgIH0sXG4gICAgICB0ZXh0VHJhY2syOiB7XG4gICAgICAgIGxhYmVsOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazJMYWJlbCxcbiAgICAgICAgbGFuZ3VhZ2VDb2RlOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGVcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zKSB7XG4gICAgICBsZXQgY2hhbm5lbDEgPSBuZXcgT3V0cHV0RmlsdGVyKHRoaXMsICd0ZXh0VHJhY2sxJyk7XG4gICAgICBsZXQgY2hhbm5lbDIgPSBuZXcgT3V0cHV0RmlsdGVyKHRoaXMsICd0ZXh0VHJhY2syJyk7XG5cbiAgICAgIHRoaXMuY2VhNjA4UGFyc2VyID0gbmV3IENlYTYwOFBhcnNlcigwLCBjaGFubmVsMSwgY2hhbm5lbDIpO1xuICAgIH1cbiAgfVxuXG4gIGFkZEN1ZXMgKHRyYWNrTmFtZSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pIHtcbiAgICAvLyBza2lwIGN1ZXMgd2hpY2ggb3ZlcmxhcCBtb3JlIHRoYW4gNTAlIHdpdGggcHJldmlvdXNseSBwYXJzZWQgdGltZSByYW5nZXNcbiAgICBjb25zdCByYW5nZXMgPSB0aGlzLmN1ZVJhbmdlcztcbiAgICBsZXQgbWVyZ2VkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IHJhbmdlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgIGxldCBjdWVSYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgIGxldCBvdmVybGFwID0gaW50ZXJzZWN0aW9uKGN1ZVJhbmdlWzBdLCBjdWVSYW5nZVsxXSwgc3RhcnRUaW1lLCBlbmRUaW1lKTtcbiAgICAgIGlmIChvdmVybGFwID49IDApIHtcbiAgICAgICAgY3VlUmFuZ2VbMF0gPSBNYXRoLm1pbihjdWVSYW5nZVswXSwgc3RhcnRUaW1lKTtcbiAgICAgICAgY3VlUmFuZ2VbMV0gPSBNYXRoLm1heChjdWVSYW5nZVsxXSwgZW5kVGltZSk7XG4gICAgICAgIG1lcmdlZCA9IHRydWU7XG4gICAgICAgIGlmICgob3ZlcmxhcCAvIChlbmRUaW1lIC0gc3RhcnRUaW1lKSkgPiAwLjUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtZXJnZWQpIHtcbiAgICAgIHJhbmdlcy5wdXNoKFtzdGFydFRpbWUsIGVuZFRpbWVdKTtcbiAgICB9XG5cbiAgICB0aGlzLkN1ZXMubmV3Q3VlKHRoaXMuY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pO1xuICB9XG5cbiAgLy8gVHJpZ2dlcmVkIHdoZW4gYW4gaW5pdGlhbCBQVFMgaXMgZm91bmQ7IHVzZWQgZm9yIHN5bmNocm9uaXNhdGlvbiBvZiBXZWJWVFQuXG4gIG9uSW5pdFB0c0ZvdW5kIChkYXRhKSB7XG4gICAgaWYgKGRhdGEuaWQgPT09ICdtYWluJykge1xuICAgICAgdGhpcy5pbml0UFRTW2RhdGEuZnJhZy5jY10gPSBkYXRhLmluaXRQVFM7XG4gICAgfVxuXG4gICAgLy8gRHVlIHRvIGFzeW5jaHJvbm91cyBwcm9jZXNzaW5nLCBpbml0aWFsIFBUUyBtYXkgYXJyaXZlIGxhdGVyIHRoYW4gdGhlIGZpcnN0IFZUVCBmcmFnbWVudHMgYXJlIGxvYWRlZC5cbiAgICAvLyBQYXJzZSBhbnkgdW5wYXJzZWQgZnJhZ21lbnRzIHVwb24gcmVjZWl2aW5nIHRoZSBpbml0aWFsIFBUUy5cbiAgICBpZiAodGhpcy51bnBhcnNlZFZ0dEZyYWdzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdW5wYXJzZWRWdHRGcmFncyA9IHRoaXMudW5wYXJzZWRWdHRGcmFncztcbiAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdO1xuICAgICAgdW5wYXJzZWRWdHRGcmFncy5mb3JFYWNoKGZyYWcgPT4ge1xuICAgICAgICB0aGlzLm9uRnJhZ0xvYWRlZChmcmFnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGdldEV4aXN0aW5nVHJhY2sgKHRyYWNrTmFtZSkge1xuICAgIGNvbnN0IHsgbWVkaWEgfSA9IHRoaXM7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lZGlhLnRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHRleHRUcmFjayA9IG1lZGlhLnRleHRUcmFja3NbaV07XG4gICAgICAgIGlmICh0ZXh0VHJhY2tbdHJhY2tOYW1lXSkge1xuICAgICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjcmVhdGVDYXB0aW9uc1RyYWNrICh0cmFja05hbWUpIHtcbiAgICBjb25zdCB7IGxhYmVsLCBsYW5ndWFnZUNvZGUgfSA9IHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzW3RyYWNrTmFtZV07XG4gICAgY29uc3QgY2FwdGlvbnNUcmFja3MgPSB0aGlzLmNhcHRpb25zVHJhY2tzO1xuICAgIGlmICghY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSkge1xuICAgICAgLy8gRW5hYmxlIHJldXNlIG9mIGV4aXN0aW5nIHRleHQgdHJhY2suXG4gICAgICBjb25zdCBleGlzdGluZ1RyYWNrID0gdGhpcy5nZXRFeGlzdGluZ1RyYWNrKHRyYWNrTmFtZSk7XG4gICAgICBpZiAoIWV4aXN0aW5nVHJhY2spIHtcbiAgICAgICAgY29uc3QgdGV4dFRyYWNrID0gdGhpcy5jcmVhdGVUZXh0VHJhY2soJ2NhcHRpb25zJywgbGFiZWwsIGxhbmd1YWdlQ29kZSk7XG4gICAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgICAvLyBTZXQgYSBzcGVjaWFsIHByb3BlcnR5IG9uIHRoZSB0cmFjayBzbyB3ZSBrbm93IGl0J3MgbWFuYWdlZCBieSBIbHMuanNcbiAgICAgICAgICB0ZXh0VHJhY2tbdHJhY2tOYW1lXSA9IHRydWU7XG4gICAgICAgICAgY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSA9IHRleHRUcmFjaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSA9IGV4aXN0aW5nVHJhY2s7XG4gICAgICAgIGNsZWFyQ3VycmVudEN1ZXMoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSk7XG4gICAgICAgIHNlbmRBZGRUcmFja0V2ZW50KGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0sIHRoaXMubWVkaWEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZVRleHRUcmFjayAoa2luZCwgbGFiZWwsIGxhbmcpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICByZXR1cm4gbWVkaWEuYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5nKTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIG9uTWVkaWFBdHRhY2hpbmcgKGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLl9jbGVhblRyYWNrcygpO1xuICB9XG5cbiAgb25NZWRpYURldGFjaGluZyAoKSB7XG4gICAgY29uc3QgeyBjYXB0aW9uc1RyYWNrcyB9ID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyhjYXB0aW9uc1RyYWNrcykuZm9yRWFjaCh0cmFja05hbWUgPT4ge1xuICAgICAgY2xlYXJDdXJyZW50Q3VlcyhjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdKTtcbiAgICAgIGRlbGV0ZSBjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdO1xuICAgIH0pO1xuICB9XG5cbiAgb25NYW5pZmVzdExvYWRpbmcgKCkge1xuICAgIHRoaXMubGFzdFNuID0gLTE7IC8vIERldGVjdCBkaXNjb250aWd1aXR5IGluIGZyYWdtZW50IHBhcnNpbmdcbiAgICB0aGlzLnByZXZDQyA9IC0xO1xuICAgIHRoaXMudnR0Q0NzID0geyAvLyBEZXRlY3QgZGlzY29udGludWl0eSBpbiBzdWJ0aXRsZSBtYW5pZmVzdHNcbiAgICAgIGNjT2Zmc2V0OiAwLFxuICAgICAgcHJlc2VudGF0aW9uT2Zmc2V0OiAwLFxuICAgICAgMDoge1xuICAgICAgICBzdGFydDogMCwgcHJldkNDOiAtMSwgbmV3OiBmYWxzZVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fY2xlYW5UcmFja3MoKTtcbiAgfVxuXG4gIF9jbGVhblRyYWNrcyAoKSB7XG4gICAgLy8gY2xlYXIgb3V0ZGF0ZWQgc3VidGl0bGVzXG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgY29uc3QgdGV4dFRyYWNrcyA9IG1lZGlhLnRleHRUcmFja3M7XG4gICAgICBpZiAodGV4dFRyYWNrcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjbGVhckN1cnJlbnRDdWVzKHRleHRUcmFja3NbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25NYW5pZmVzdExvYWRlZCAoZGF0YSkge1xuICAgIHRoaXMudGV4dFRyYWNrcyA9IFtdO1xuICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IHRoaXMudW5wYXJzZWRWdHRGcmFncyB8fCBbXTtcbiAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgICB0aGlzLmN1ZVJhbmdlcyA9IFtdO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZVdlYlZUVCkge1xuICAgICAgdGhpcy50cmFja3MgPSBkYXRhLnN1YnRpdGxlcyB8fCBbXTtcbiAgICAgIGNvbnN0IGluVXNlVHJhY2tzID0gdGhpcy5tZWRpYSA/IHRoaXMubWVkaWEudGV4dFRyYWNrcyA6IFtdO1xuXG4gICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKCh0cmFjaywgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IHRleHRUcmFjaztcbiAgICAgICAgaWYgKGluZGV4IDwgaW5Vc2VUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IGluVXNlVHJhY2sgPSBudWxsO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpblVzZVRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNhblJldXNlVnR0VGV4dFRyYWNrKGluVXNlVHJhY2tzW2ldLCB0cmFjaykpIHtcbiAgICAgICAgICAgICAgaW5Vc2VUcmFjayA9IGluVXNlVHJhY2tzW2ldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZXVzZSB0cmFja3Mgd2l0aCB0aGUgc2FtZSBsYWJlbCwgYnV0IGRvIG5vdCByZXVzZSA2MDgvNzA4IHRyYWNrc1xuICAgICAgICAgIGlmIChpblVzZVRyYWNrKSB7XG4gICAgICAgICAgICB0ZXh0VHJhY2sgPSBpblVzZVRyYWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRleHRUcmFjaykge1xuICAgICAgICAgIHRleHRUcmFjayA9IHRoaXMuY3JlYXRlVGV4dFRyYWNrKCdzdWJ0aXRsZXMnLCB0cmFjay5uYW1lLCB0cmFjay5sYW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFjay5kZWZhdWx0KSB7XG4gICAgICAgICAgdGV4dFRyYWNrLm1vZGUgPSB0aGlzLmhscy5zdWJ0aXRsZURpc3BsYXkgPyAnc2hvd2luZycgOiAnaGlkZGVuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0VHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRleHRUcmFja3MucHVzaCh0ZXh0VHJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgb25MZXZlbFN3aXRjaGluZyAoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gdGhpcy5obHMuY3VycmVudExldmVsLmNsb3NlZENhcHRpb25zICE9PSAnTk9ORSc7XG4gIH1cblxuICBvbkZyYWdMb2FkZWQgKGRhdGEpIHtcbiAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgIHBheWxvYWQgPSBkYXRhLnBheWxvYWQ7XG4gICAgaWYgKGZyYWcudHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICBsZXQgc24gPSBmcmFnLnNuO1xuICAgICAgLy8gaWYgdGhpcyBmcmFnIGlzbid0IGNvbnRpZ3VvdXMsIGNsZWFyIHRoZSBwYXJzZXIgc28gY3VlcyB3aXRoIGJhZCBzdGFydC9lbmQgdGltZXMgYXJlbid0IGFkZGVkIHRvIHRoZSB0ZXh0VHJhY2tcbiAgICAgIGlmIChzbiAhPT0gdGhpcy5sYXN0U24gKyAxKSB7XG4gICAgICAgIGNvbnN0IGNlYTYwOFBhcnNlciA9IHRoaXMuY2VhNjA4UGFyc2VyO1xuICAgICAgICBpZiAoY2VhNjA4UGFyc2VyKSB7XG4gICAgICAgICAgY2VhNjA4UGFyc2VyLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFNuID0gc247XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJyYWNlLXN0eWxlXG4gICAgLy8gSWYgZnJhZ21lbnQgaXMgc3VidGl0bGUgdHlwZSwgcGFyc2UgYXMgV2ViVlRULlxuICAgIGVsc2UgaWYgKGZyYWcudHlwZSA9PT0gJ3N1YnRpdGxlJykge1xuICAgICAgaWYgKHBheWxvYWQuYnl0ZUxlbmd0aCkge1xuICAgICAgICAvLyBXZSBuZWVkIGFuIGluaXRpYWwgc3luY2hyb25pc2F0aW9uIFBUUy4gU3RvcmUgZnJhZ21lbnRzIGFzIGxvbmcgYXMgbm9uZSBoYXMgYXJyaXZlZC5cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodGhpcy5pbml0UFRTW2ZyYWcuY2NdKSkge1xuICAgICAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncy5wdXNoKGRhdGEpO1xuICAgICAgICAgIGlmICh0aGlzLmluaXRQVFMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBmaW5pc2ggdW5zdWNjZXNzZnVsbHksIG90aGVyd2lzZSB0aGUgc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIgY291bGQgYmUgYmxvY2tlZCBmcm9tIGxvYWRpbmcgbmV3IGZyYWdzLlxuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgeyBzdWNjZXNzOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRlY3J5cHREYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICAgICAgLy8gSWYgdGhlIHN1YnRpdGxlcyBhcmUgbm90IGVuY3J5cHRlZCwgcGFyc2UgVlRUcyBub3cuIE90aGVyd2lzZSwgd2UgbmVlZCB0byB3YWl0LlxuICAgICAgICBpZiAoKGRlY3J5cHREYXRhID09IG51bGwpIHx8IChkZWNyeXB0RGF0YS5rZXkgPT0gbnVsbCkgfHwgKGRlY3J5cHREYXRhLm1ldGhvZCAhPT0gJ0FFUy0xMjgnKSkge1xuICAgICAgICAgIHRoaXMuX3BhcnNlVlRUcyhmcmFnLCBwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW4gY2FzZSB0aGVyZSBpcyBubyBwYXlsb2FkLCBmaW5pc2ggdW5zdWNjZXNzZnVsbHkuXG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHsgc3VjY2VzczogZmFsc2UsIGZyYWc6IGZyYWcgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3BhcnNlVlRUcyAoZnJhZywgcGF5bG9hZCkge1xuICAgIGxldCB2dHRDQ3MgPSB0aGlzLnZ0dENDcztcbiAgICBpZiAoIXZ0dENDc1tmcmFnLmNjXSkge1xuICAgICAgdnR0Q0NzW2ZyYWcuY2NdID0geyBzdGFydDogZnJhZy5zdGFydCwgcHJldkNDOiB0aGlzLnByZXZDQywgbmV3OiB0cnVlIH07XG4gICAgICB0aGlzLnByZXZDQyA9IGZyYWcuY2M7XG4gICAgfVxuICAgIGxldCB0ZXh0VHJhY2tzID0gdGhpcy50ZXh0VHJhY2tzLFxuICAgICAgaGxzID0gdGhpcy5obHM7XG5cbiAgICAvLyBQYXJzZSB0aGUgV2ViVlRUIGZpbGUgY29udGVudHMuXG4gICAgV2ViVlRUUGFyc2VyLnBhcnNlKHBheWxvYWQsIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSwgdnR0Q0NzLCBmcmFnLmNjLCBmdW5jdGlvbiAoY3Vlcykge1xuICAgICAgY29uc3QgY3VycmVudFRyYWNrID0gdGV4dFRyYWNrc1tmcmFnLmxldmVsXTtcbiAgICAgIC8vIFdlYlZUVFBhcnNlci5wYXJzZSBpcyBhbiBhc3luYyBtZXRob2QgYW5kIGlmIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dCB0cmFjayBtb2RlIGlzIHNldCB0byBcImRpc2FibGVkXCJcbiAgICAgIC8vIGJlZm9yZSBwYXJzaW5nIGlzIGRvbmUgdGhlbiBkb24ndCB0cnkgdG8gYWNjZXNzIGN1cnJlbnRUcmFjay5jdWVzLmdldEN1ZUJ5SWQgYXMgY3VlcyB3aWxsIGJlIG51bGxcbiAgICAgIC8vIGFuZCB0cnlpbmcgdG8gYWNjZXNzIGdldEN1ZUJ5SWQgbWV0aG9kIG9mIGN1ZXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb25cbiAgICAgIGlmIChjdXJyZW50VHJhY2subW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgeyBzdWNjZXNzOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gQWRkIGN1ZXMgYW5kIHRyaWdnZXIgZXZlbnQgd2l0aCBzdWNjZXNzIHRydWUuXG4gICAgICBjdWVzLmZvckVhY2goY3VlID0+IHtcbiAgICAgICAgLy8gU29tZXRpbWVzIHRoZXJlIGFyZSBjdWUgb3ZlcmxhcHMgb24gc2VnbWVudGVkIHZ0dHMgc28gdGhlIHNhbWVcbiAgICAgICAgLy8gY3VlIGNhbiBhcHBlYXIgbW9yZSB0aGFuIG9uY2UgaW4gZGlmZmVyZW50IHZ0dCBmaWxlcy5cbiAgICAgICAgLy8gVGhpcyBhdm9pZCBzaG93aW5nIGR1cGxpY2F0ZWQgY3VlcyB3aXRoIHNhbWUgdGltZWNvZGUgYW5kIHRleHQuXG4gICAgICAgIGlmICghY3VycmVudFRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChjdWUuaWQpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGN1cnJlbnRUcmFjay5hZGRDdWUoY3VlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRUcmFja0N1ZSA9IG5ldyB3aW5kb3cuVGV4dFRyYWNrQ3VlKGN1ZS5zdGFydFRpbWUsIGN1ZS5lbmRUaW1lLCBjdWUudGV4dCk7XG4gICAgICAgICAgICB0ZXh0VHJhY2tDdWUuaWQgPSBjdWUuaWQ7XG4gICAgICAgICAgICBjdXJyZW50VHJhY2suYWRkQ3VlKHRleHRUcmFja0N1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICApO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHsgc3VjY2VzczogdHJ1ZSwgZnJhZzogZnJhZyB9KTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBwYXJzaW5nLiBUcmlnZ2VyIGV2ZW50IHdpdGggc3VjY2VzcyBmYWxzZS5cbiAgICAgIGxvZ2dlci5sb2coYEZhaWxlZCB0byBwYXJzZSBWVFQgY3VlOiAke2V9YCk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudC5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgeyBzdWNjZXNzOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIG9uRnJhZ0RlY3J5cHRlZCAoZGF0YSkge1xuICAgIGxldCBkZWNyeXB0ZWREYXRhID0gZGF0YS5wYXlsb2FkLFxuICAgICAgZnJhZyA9IGRhdGEuZnJhZztcblxuICAgIGlmIChmcmFnLnR5cGUgPT09ICdzdWJ0aXRsZScpIHtcbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHRoaXMuaW5pdFBUU1tmcmFnLmNjXSkpIHtcbiAgICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzLnB1c2goZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcGFyc2VWVFRzKGZyYWcsIGRlY3J5cHRlZERhdGEpO1xuICAgIH1cbiAgfVxuXG4gIG9uRnJhZ1BhcnNpbmdVc2VyZGF0YSAoZGF0YSkge1xuICAgIC8vIHB1c2ggYWxsIG9mIHRoZSBDRUEtNzA4IG1lc3NhZ2VzIGludG8gdGhlIGludGVycHJldGVyXG4gICAgLy8gaW1tZWRpYXRlbHkuIEl0IHdpbGwgY3JlYXRlIHRoZSBwcm9wZXIgdGltZXN0YW1wcyBiYXNlZCBvbiBvdXIgUFRTIHZhbHVlXG4gICAgaWYgKHRoaXMuZW5hYmxlZCAmJiB0aGlzLmNvbmZpZy5lbmFibGVDRUE3MDhDYXB0aW9ucykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLnNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNjZGF0YXMgPSB0aGlzLmV4dHJhY3RDZWE2MDhEYXRhKGRhdGEuc2FtcGxlc1tpXS5ieXRlcyk7XG4gICAgICAgIHRoaXMuY2VhNjA4UGFyc2VyLmFkZERhdGEoZGF0YS5zYW1wbGVzW2ldLnB0cywgY2NkYXRhcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZXh0cmFjdENlYTYwOERhdGEgKGJ5dGVBcnJheSkge1xuICAgIGxldCBjb3VudCA9IGJ5dGVBcnJheVswXSAmIDMxO1xuICAgIGxldCBwb3NpdGlvbiA9IDI7XG4gICAgbGV0IHRtcEJ5dGUsIGNjYnl0ZTEsIGNjYnl0ZTIsIGNjVmFsaWQsIGNjVHlwZTtcbiAgICBsZXQgYWN0dWFsQ0NCeXRlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICB0bXBCeXRlID0gYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgY2NieXRlMSA9IDB4N0YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICBjY2J5dGUyID0gMHg3RiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgIGNjVmFsaWQgPSAoNCAmIHRtcEJ5dGUpICE9PSAwO1xuICAgICAgY2NUeXBlID0gMyAmIHRtcEJ5dGU7XG5cbiAgICAgIGlmIChjY2J5dGUxID09PSAwICYmIGNjYnl0ZTIgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjY1ZhbGlkKSB7XG4gICAgICAgIGlmIChjY1R5cGUgPT09IDApIHsgLy8gfHwgY2NUeXBlID09PSAxXG4gICAgICAgICAgYWN0dWFsQ0NCeXRlcy5wdXNoKGNjYnl0ZTEpO1xuICAgICAgICAgIGFjdHVhbENDQnl0ZXMucHVzaChjY2J5dGUyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWN0dWFsQ0NCeXRlcztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1lbGluZUNvbnRyb2xsZXI7XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBBRVNDcnlwdG8ge1xuICBjb25zdHJ1Y3RvciAoc3VidGxlLCBpdikge1xuICAgIHRoaXMuc3VidGxlID0gc3VidGxlO1xuICAgIHRoaXMuYWVzSVYgPSBpdjtcbiAgfVxuXG4gIGRlY3J5cHQgKGRhdGEsIGtleSkge1xuICAgIHJldHVybiB0aGlzLnN1YnRsZS5kZWNyeXB0KHsgbmFtZTogJ0FFUy1DQkMnLCBpdjogdGhpcy5hZXNJViB9LCBrZXksIGRhdGEpO1xuICB9XG59XG4iLCIvLyBQS0NTN1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVBhZGRpbmcgKGJ1ZmZlcikge1xuICBjb25zdCBvdXRwdXRCeXRlcyA9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICBjb25zdCBwYWRkaW5nQnl0ZXMgPSBvdXRwdXRCeXRlcyAmJiAobmV3IERhdGFWaWV3KGJ1ZmZlcikpLmdldFVpbnQ4KG91dHB1dEJ5dGVzIC0gMSk7XG4gIGlmIChwYWRkaW5nQnl0ZXMpIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIG91dHB1dEJ5dGVzIC0gcGFkZGluZ0J5dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG59XG5cbmNsYXNzIEFFU0RlY3J5cHRvciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvLyBTdGF0aWMgYWZ0ZXIgcnVubmluZyBpbml0VGFibGVcbiAgICB0aGlzLnJjb24gPSBbMHgwLCAweDEsIDB4MiwgMHg0LCAweDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xuICAgIHRoaXMuc3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpXTtcbiAgICB0aGlzLmludlN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KV07XG4gICAgdGhpcy5zQm94ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdGhpcy5pbnZTQm94ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG5cbiAgICAvLyBDaGFuZ2VzIGR1cmluZyBydW50aW1lXG4gICAgdGhpcy5rZXkgPSBuZXcgVWludDMyQXJyYXkoMCk7XG5cbiAgICB0aGlzLmluaXRUYWJsZSgpO1xuICB9XG5cbiAgLy8gVXNpbmcgdmlldy5nZXRVaW50MzIoKSBhbHNvIHN3YXBzIHRoZSBieXRlIG9yZGVyLlxuICB1aW50OEFycmF5VG9VaW50MzJBcnJheV8gKGFycmF5QnVmZmVyKSB7XG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICAgIGxldCBuZXdBcnJheSA9IG5ldyBVaW50MzJBcnJheSg0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgbmV3QXJyYXlbaV0gPSB2aWV3LmdldFVpbnQzMihpICogNCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG5cbiAgaW5pdFRhYmxlICgpIHtcbiAgICBsZXQgc0JveCA9IHRoaXMuc0JveDtcbiAgICBsZXQgaW52U0JveCA9IHRoaXMuaW52U0JveDtcbiAgICBsZXQgc3ViTWl4ID0gdGhpcy5zdWJNaXg7XG4gICAgbGV0IHN1Yk1peDAgPSBzdWJNaXhbMF07XG4gICAgbGV0IHN1Yk1peDEgPSBzdWJNaXhbMV07XG4gICAgbGV0IHN1Yk1peDIgPSBzdWJNaXhbMl07XG4gICAgbGV0IHN1Yk1peDMgPSBzdWJNaXhbM107XG4gICAgbGV0IGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgIGxldCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIGxldCBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xuICAgIGxldCBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgIGxldCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuXG4gICAgbGV0IGQgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHhpID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBpZiAoaSA8IDEyOCkge1xuICAgICAgICBkW2ldID0gaSA8PCAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZFtpXSA9IChpIDw8IDEpIF4gMHgxMWI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBsZXQgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KTtcbiAgICAgIHN4ID0gKHN4ID4+PiA4KSBeIChzeCAmIDB4ZmYpIF4gMHg2MztcbiAgICAgIHNCb3hbeF0gPSBzeDtcbiAgICAgIGludlNCb3hbc3hdID0geDtcblxuICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuICAgICAgbGV0IHgyID0gZFt4XTtcbiAgICAgIGxldCB4NCA9IGRbeDJdO1xuICAgICAgbGV0IHg4ID0gZFt4NF07XG5cbiAgICAgIC8vIENvbXB1dGUgc3ViL2ludlN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICBsZXQgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMCk7XG4gICAgICBzdWJNaXgwW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuICAgICAgc3ViTWl4MVt4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG4gICAgICBzdWJNaXgyW3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuICAgICAgc3ViTWl4M1t4XSA9IHQ7XG5cbiAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgdCA9ICh4OCAqIDB4MTAxMDEwMSkgXiAoeDQgKiAweDEwMDAxKSBeICh4MiAqIDB4MTAxKSBeICh4ICogMHgxMDEwMTAwKTtcbiAgICAgIGludlN1Yk1peDBbc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuICAgICAgaW52U3ViTWl4MVtzeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuICAgICAgaW52U3ViTWl4MltzeF0gPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG4gICAgICBpbnZTdWJNaXgzW3N4XSA9IHQ7XG5cbiAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG4gICAgICBpZiAoIXgpIHtcbiAgICAgICAgeCA9IHhpID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG4gICAgICAgIHhpIF49IGRbZFt4aV1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV4cGFuZEtleSAoa2V5QnVmZmVyKSB7XG4gICAgLy8gY29udmVydCBrZXlCdWZmZXIgdG8gVWludDMyQXJyYXlcbiAgICBsZXQga2V5ID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oa2V5QnVmZmVyKTtcbiAgICBsZXQgc2FtZUtleSA9IHRydWU7XG4gICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwga2V5Lmxlbmd0aCAmJiBzYW1lS2V5KSB7XG4gICAgICBzYW1lS2V5ID0gKGtleVtvZmZzZXRdID09PSB0aGlzLmtleVtvZmZzZXRdKTtcbiAgICAgIG9mZnNldCsrO1xuICAgIH1cblxuICAgIGlmIChzYW1lS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgbGV0IGtleVNpemUgPSB0aGlzLmtleVNpemUgPSBrZXkubGVuZ3RoO1xuXG4gICAgaWYgKGtleVNpemUgIT09IDQgJiYga2V5U2l6ZSAhPT0gNiAmJiBrZXlTaXplICE9PSA4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWVzIGtleSBzaXplPScgKyBrZXlTaXplKTtcbiAgICB9XG5cbiAgICBsZXQga3NSb3dzID0gdGhpcy5rc1Jvd3MgPSAoa2V5U2l6ZSArIDYgKyAxKSAqIDQ7XG4gICAgbGV0IGtzUm93O1xuICAgIGxldCBpbnZLc1JvdztcblxuICAgIGxldCBrZXlTY2hlZHVsZSA9IHRoaXMua2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKTtcbiAgICBsZXQgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlID0gbmV3IFVpbnQzMkFycmF5KGtzUm93cyk7XG4gICAgbGV0IHNib3ggPSB0aGlzLnNCb3g7XG4gICAgbGV0IHJjb24gPSB0aGlzLnJjb247XG5cbiAgICBsZXQgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgbGV0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgbGV0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgbGV0IGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgbGV0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG5cbiAgICBsZXQgcHJldjtcbiAgICBsZXQgdDtcblxuICAgIGZvciAoa3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xuICAgICAgaWYgKGtzUm93IDwga2V5U2l6ZSkge1xuICAgICAgICBwcmV2ID0ga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5W2tzUm93XTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0ID0gcHJldjtcblxuICAgICAgaWYgKGtzUm93ICUga2V5U2l6ZSA9PT0gMCkge1xuICAgICAgICAvLyBSb3Qgd29yZFxuICAgICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuXG4gICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgIHQgPSAoc2JveFt0ID4+PiAyNF0gPDwgMjQpIHwgKHNib3hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChzYm94Wyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgc2JveFt0ICYgMHhmZl07XG5cbiAgICAgICAgLy8gTWl4IFJjb25cbiAgICAgICAgdCBePSByY29uWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQ7XG4gICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PT0gNCkge1xuICAgICAgICAvLyBTdWIgd29yZFxuICAgICAgICB0ID0gKHNib3hbdCA+Pj4gMjRdIDw8IDI0KSB8IChzYm94Wyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoc2JveFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IHNib3hbdCAmIDB4ZmZdO1xuICAgICAgfVxuXG4gICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBwcmV2ID0gKGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0KSA+Pj4gMDtcbiAgICB9XG5cbiAgICBmb3IgKGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcbiAgICAgIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3c7XG4gICAgICBpZiAoaW52S3NSb3cgJiAzKSB7XG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZTdWJNaXgwW3Nib3hbdCA+Pj4gMjRdXSBeIGludlN1Yk1peDFbc2JveFsodCA+Pj4gMTYpICYgMHhmZl1dIF4gaW52U3ViTWl4MltzYm94Wyh0ID4+PiA4KSAmIDB4ZmZdXSBeIGludlN1Yk1peDNbc2JveFt0ICYgMHhmZl1dO1xuICAgICAgfVxuXG4gICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPj4+IDA7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkaW5nIHRoaXMgYXMgYSBtZXRob2QgZ3JlYXRseSBpbXByb3ZlcyBwZXJmb3JtYW5jZS5cbiAgbmV0d29ya1RvSG9zdE9yZGVyU3dhcCAod29yZCkge1xuICAgIHJldHVybiAod29yZCA8PCAyNCkgfCAoKHdvcmQgJiAweGZmMDApIDw8IDgpIHwgKCh3b3JkICYgMHhmZjAwMDApID4+IDgpIHwgKHdvcmQgPj4+IDI0KTtcbiAgfVxuXG4gIGRlY3J5cHQgKGlucHV0QXJyYXlCdWZmZXIsIG9mZnNldCwgYWVzSVYsIHJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgIGxldCBuUm91bmRzID0gdGhpcy5rZXlTaXplICsgNjtcbiAgICBsZXQgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlO1xuICAgIGxldCBpbnZTQk9YID0gdGhpcy5pbnZTQm94O1xuXG4gICAgbGV0IGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgIGxldCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIGxldCBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xuICAgIGxldCBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgIGxldCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuXG4gICAgbGV0IGluaXRWZWN0b3IgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhhZXNJVik7XG4gICAgbGV0IGluaXRWZWN0b3IwID0gaW5pdFZlY3RvclswXTtcbiAgICBsZXQgaW5pdFZlY3RvcjEgPSBpbml0VmVjdG9yWzFdO1xuICAgIGxldCBpbml0VmVjdG9yMiA9IGluaXRWZWN0b3JbMl07XG4gICAgbGV0IGluaXRWZWN0b3IzID0gaW5pdFZlY3RvclszXTtcblxuICAgIGxldCBpbnB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRBcnJheUJ1ZmZlcik7XG4gICAgbGV0IG91dHB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRJbnQzMi5sZW5ndGgpO1xuXG4gICAgbGV0IHQwLCB0MSwgdDIsIHQzO1xuICAgIGxldCBzMCwgczEsIHMyLCBzMztcbiAgICBsZXQgaW5wdXRXb3JkczAsIGlucHV0V29yZHMxLCBpbnB1dFdvcmRzMiwgaW5wdXRXb3JkczM7XG5cbiAgICBsZXQga3NSb3csIGk7XG4gICAgbGV0IHN3YXBXb3JkID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IGlucHV0SW50MzIubGVuZ3RoKSB7XG4gICAgICBpbnB1dFdvcmRzMCA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0XSk7XG4gICAgICBpbnB1dFdvcmRzMSA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgMV0pO1xuICAgICAgaW5wdXRXb3JkczIgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDJdKTtcbiAgICAgIGlucHV0V29yZHMzID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAzXSk7XG5cbiAgICAgIHMwID0gaW5wdXRXb3JkczAgXiBpbnZLZXlTY2hlZHVsZVswXTtcbiAgICAgIHMxID0gaW5wdXRXb3JkczMgXiBpbnZLZXlTY2hlZHVsZVsxXTtcbiAgICAgIHMyID0gaW5wdXRXb3JkczIgXiBpbnZLZXlTY2hlZHVsZVsyXTtcbiAgICAgIHMzID0gaW5wdXRXb3JkczEgXiBpbnZLZXlTY2hlZHVsZVszXTtcblxuICAgICAga3NSb3cgPSA0O1xuXG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHJvdW5kcyBvZiBkZWNyeXB0aW9uXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgblJvdW5kczsgaSsrKSB7XG4gICAgICAgIHQwID0gaW52U3ViTWl4MFtzMCA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczEgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMiA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMyAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgICB0MSA9IGludlN1Yk1peDBbczEgPj4+IDI0XSBeIGludlN1Yk1peDFbKHMyID4+IDE2KSAmIDB4ZmZdIF4gaW52U3ViTWl4MlsoczMgPj4gOCkgJiAweGZmXSBeIGludlN1Yk1peDNbczAgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XG4gICAgICAgIHQyID0gaW52U3ViTWl4MFtzMiA+Pj4gMjRdIF4gaW52U3ViTWl4MVsoczMgPj4gMTYpICYgMHhmZl0gXiBpbnZTdWJNaXgyWyhzMCA+PiA4KSAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMSAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgICAgdDMgPSBpbnZTdWJNaXgwW3MzID4+PiAyNF0gXiBpbnZTdWJNaXgxWyhzMCA+PiAxNikgJiAweGZmXSBeIGludlN1Yk1peDJbKHMxID4+IDgpICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MyICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuICAgICAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICAgICAgczAgPSB0MDtcbiAgICAgICAgczEgPSB0MTtcbiAgICAgICAgczIgPSB0MjtcbiAgICAgICAgczMgPSB0MztcblxuICAgICAgICBrc1JvdyA9IGtzUm93ICsgNDtcbiAgICAgIH1cblxuICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG4gICAgICB0MCA9ICgoaW52U0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSBeIChpbnZTQk9YWyhzMSA+PiAxNikgJiAweGZmXSA8PCAxNikgXiAoaW52U0JPWFsoczIgPj4gOCkgJiAweGZmXSA8PCA4KSBeIGludlNCT1hbczMgJiAweGZmXSkgXiBpbnZLZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICB0MSA9ICgoaW52U0JPWFtzMSA+Pj4gMjRdIDw8IDI0KSBeIChpbnZTQk9YWyhzMiA+PiAxNikgJiAweGZmXSA8PCAxNikgXiAoaW52U0JPWFsoczMgPj4gOCkgJiAweGZmXSA8PCA4KSBeIGludlNCT1hbczAgJiAweGZmXSkgXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xuICAgICAgdDIgPSAoKGludlNCT1hbczIgPj4+IDI0XSA8PCAyNCkgXiAoaW52U0JPWFsoczMgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF4gKGludlNCT1hbKHMwID4+IDgpICYgMHhmZl0gPDwgOCkgXiBpbnZTQk9YW3MxICYgMHhmZl0pIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgIHQzID0gKChpbnZTQk9YW3MzID4+PiAyNF0gPDwgMjQpIF4gKGludlNCT1hbKHMwID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeIChpbnZTQk9YWyhzMSA+PiA4KSAmIDB4ZmZdIDw8IDgpIF4gaW52U0JPWFtzMiAmIDB4ZmZdKSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgM107XG4gICAgICBrc1JvdyA9IGtzUm93ICsgMztcblxuICAgICAgLy8gV3JpdGVcbiAgICAgIG91dHB1dEludDMyW29mZnNldF0gPSBzd2FwV29yZCh0MCBeIGluaXRWZWN0b3IwKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDFdID0gc3dhcFdvcmQodDMgXiBpbml0VmVjdG9yMSk7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAyXSA9IHN3YXBXb3JkKHQyIF4gaW5pdFZlY3RvcjIpO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgM10gPSBzd2FwV29yZCh0MSBeIGluaXRWZWN0b3IzKTtcblxuICAgICAgLy8gcmVzZXQgaW5pdFZlY3RvciB0byBsYXN0IDQgdW5zaWduZWQgaW50XG4gICAgICBpbml0VmVjdG9yMCA9IGlucHV0V29yZHMwO1xuICAgICAgaW5pdFZlY3RvcjEgPSBpbnB1dFdvcmRzMTtcbiAgICAgIGluaXRWZWN0b3IyID0gaW5wdXRXb3JkczI7XG4gICAgICBpbml0VmVjdG9yMyA9IGlucHV0V29yZHMzO1xuXG4gICAgICBvZmZzZXQgPSBvZmZzZXQgKyA0O1xuICAgIH1cblxuICAgIHJldHVybiByZW1vdmVQS0NTN1BhZGRpbmcgPyByZW1vdmVQYWRkaW5nKG91dHB1dEludDMyLmJ1ZmZlcikgOiBvdXRwdXRJbnQzMi5idWZmZXI7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmtleSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmtleVNpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5rc1Jvd3MgPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLnNCb3ggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbnZTQm94ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3ViTWl4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW52U3ViTWl4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMua2V5U2NoZWR1bGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbnZLZXlTY2hlZHVsZSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMucmNvbiA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBRVNEZWNyeXB0b3I7XG4iLCJpbXBvcnQgQUVTQ3J5cHRvIGZyb20gJy4vYWVzLWNyeXB0byc7XG5pbXBvcnQgRmFzdEFFU0tleSBmcm9tICcuL2Zhc3QtYWVzLWtleSc7XG5pbXBvcnQgQUVTRGVjcnlwdG9yIGZyb20gJy4vYWVzLWRlY3J5cHRvcic7XG5cbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcblxuaW1wb3J0IHsgZ2V0U2VsZlNjb3BlIH0gZnJvbSAnLi4vdXRpbHMvZ2V0LXNlbGYtc2NvcGUnO1xuXG4vLyBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExMjM3MjU5LzU4OTQ5M1xuY29uc3QgZ2xvYmFsID0gZ2V0U2VsZlNjb3BlKCk7IC8vIHNhZmVndWFyZCBmb3IgY29kZSB0aGF0IG1pZ2h0IHJ1biBib3RoIG9uIHdvcmtlciBhbmQgbWFpbiB0aHJlYWRcblxuY2xhc3MgRGVjcnlwdGVyIHtcbiAgY29uc3RydWN0b3IgKG9ic2VydmVyLCBjb25maWcsIHsgcmVtb3ZlUEtDUzdQYWRkaW5nID0gdHJ1ZSB9ID0ge30pIHtcbiAgICB0aGlzLmxvZ0VuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZyA9IHJlbW92ZVBLQ1M3UGFkZGluZztcbiAgICAvLyBidWlsdCBpbiBkZWNyeXB0b3IgZXhwZWN0cyBQS0NTNyBwYWRkaW5nXG4gICAgaWYgKHJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYnJvd3NlckNyeXB0byA9IGdsb2JhbC5jcnlwdG87XG4gICAgICAgIGlmIChicm93c2VyQ3J5cHRvKSB7XG4gICAgICAgICAgdGhpcy5zdWJ0bGUgPSBicm93c2VyQ3J5cHRvLnN1YnRsZSB8fCBicm93c2VyQ3J5cHRvLndlYmtpdFN1YnRsZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlV2ViQ3J5cHRvID0gIXRoaXMuc3VidGxlO1xuICB9XG5cbiAgaXNTeW5jICgpIHtcbiAgICByZXR1cm4gKHRoaXMuZGlzYWJsZVdlYkNyeXB0byAmJiB0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUyk7XG4gIH1cblxuICBkZWNyeXB0IChkYXRhLCBrZXksIGl2LCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmRpc2FibGVXZWJDcnlwdG8gJiYgdGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMpIHtcbiAgICAgIGlmICh0aGlzLmxvZ0VuYWJsZWQpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnSlMgQUVTIGRlY3J5cHQnKTtcbiAgICAgICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgZGVjcnlwdG9yID0gdGhpcy5kZWNyeXB0b3I7XG4gICAgICBpZiAoIWRlY3J5cHRvcikge1xuICAgICAgICB0aGlzLmRlY3J5cHRvciA9IGRlY3J5cHRvciA9IG5ldyBBRVNEZWNyeXB0b3IoKTtcbiAgICAgIH1cblxuICAgICAgZGVjcnlwdG9yLmV4cGFuZEtleShrZXkpO1xuICAgICAgY2FsbGJhY2soZGVjcnlwdG9yLmRlY3J5cHQoZGF0YSwgMCwgaXYsIHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmxvZ0VuYWJsZWQpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnV2ViQ3J5cHRvIEFFUyBkZWNyeXB0Jyk7XG4gICAgICAgIHRoaXMubG9nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3VidGxlID0gdGhpcy5zdWJ0bGU7XG4gICAgICBpZiAodGhpcy5rZXkgIT09IGtleSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5mYXN0QWVzS2V5ID0gbmV3IEZhc3RBRVNLZXkoc3VidGxlLCBrZXkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZhc3RBZXNLZXkuZXhwYW5kS2V5KClcbiAgICAgICAgLnRoZW4oKGFlc0tleSkgPT4ge1xuICAgICAgICAgIC8vIGRlY3J5cHQgdXNpbmcgd2ViIGNyeXB0b1xuICAgICAgICAgIGxldCBjcnlwdG8gPSBuZXcgQUVTQ3J5cHRvKHN1YnRsZSwgaXYpO1xuICAgICAgICAgIGNyeXB0by5kZWNyeXB0KGRhdGEsIGFlc0tleSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMub25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICB0aGlzLm9uV2ViQ3J5cHRvRXJyb3IoZXJyLCBkYXRhLCBrZXksIGl2LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIG9uV2ViQ3J5cHRvRXJyb3IgKGVyciwgZGF0YSwga2V5LCBpdiwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMpIHtcbiAgICAgIGxvZ2dlci5sb2coJ1dlYkNyeXB0byBFcnJvciwgZGlzYWJsZSBXZWJDcnlwdG8gQVBJJyk7XG4gICAgICB0aGlzLmRpc2FibGVXZWJDcnlwdG8gPSB0cnVlO1xuICAgICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZGVjcnlwdChkYXRhLCBrZXksIGl2LCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5lcnJvcihgZGVjcnlwdGluZyBlcnJvciA6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUiwgZmF0YWw6IHRydWUsIHJlYXNvbjogZXJyLm1lc3NhZ2UgfSk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgbGV0IGRlY3J5cHRvciA9IHRoaXMuZGVjcnlwdG9yO1xuICAgIGlmIChkZWNyeXB0b3IpIHtcbiAgICAgIGRlY3J5cHRvci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmRlY3J5cHRvciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGVjcnlwdGVyO1xuIiwiY2xhc3MgRmFzdEFFU0tleSB7XG4gIGNvbnN0cnVjdG9yIChzdWJ0bGUsIGtleSkge1xuICAgIHRoaXMuc3VidGxlID0gc3VidGxlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICB9XG5cbiAgZXhwYW5kS2V5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCB0aGlzLmtleSwgeyBuYW1lOiAnQUVTLUNCQycgfSwgZmFsc2UsIFsnZW5jcnlwdCcsICdkZWNyeXB0J10pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZhc3RBRVNLZXk7XG4iLCIvKipcbiAqIEFBQyBkZW11eGVyXG4gKi9cbmltcG9ydCAqIGFzIEFEVFMgZnJvbSAnLi9hZHRzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgSUQzIGZyb20gJy4uL2RlbXV4L2lkMyc7XG5cbmNsYXNzIEFBQ0RlbXV4ZXIge1xuICBjb25zdHJ1Y3RvciAob2JzZXJ2ZXIsIHJlbXV4ZXIsIGNvbmZpZykge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnJlbXV4ZXIgPSByZW11eGVyO1xuICB9XG5cbiAgcmVzZXRJbml0U2VnbWVudCAoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHsgY29udGFpbmVyOiAnYXVkaW8vYWR0cycsIHR5cGU6ICdhdWRpbycsIGlkOiAwLCBzZXF1ZW5jZU51bWJlcjogMCwgaXNBQUM6IHRydWUsIHNhbXBsZXM6IFtdLCBsZW46IDAsIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsIGR1cmF0aW9uOiBkdXJhdGlvbiwgaW5wdXRUaW1lU2NhbGU6IDkwMDAwIH07XG4gIH1cblxuICByZXNldFRpbWVTdGFtcCAoKSB7XG4gIH1cblxuICBzdGF0aWMgcHJvYmUgKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgdGhlIEFEVFMgc3luYyB3b3JkXG4gICAgLy8gTG9vayBmb3IgQURUUyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTExIFgwMFggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxXG4gICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyAwIGZvciBBRFRTXG4gICAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gICAgY29uc3QgaWQzRGF0YSA9IElEMy5nZXRJRDNEYXRhKGRhdGEsIDApIHx8IFtdO1xuICAgIGxldCBvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICBpZiAoQURUUy5wcm9iZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0FEVFMgc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgYXBwZW5kIChkYXRhLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICBsZXQgdHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrO1xuICAgIGxldCBpZDNEYXRhID0gSUQzLmdldElEM0RhdGEoZGF0YSwgMCkgfHwgW107XG4gICAgbGV0IHRpbWVzdGFtcCA9IElEMy5nZXRUaW1lU3RhbXAoaWQzRGF0YSk7XG4gICAgbGV0IHB0cyA9IE51bWJlci5pc0Zpbml0ZSh0aW1lc3RhbXApID8gdGltZXN0YW1wICogOTAgOiB0aW1lT2Zmc2V0ICogOTAwMDA7XG4gICAgbGV0IGZyYW1lSW5kZXggPSAwO1xuICAgIGxldCBzdGFtcCA9IHB0cztcbiAgICBsZXQgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgbGV0IG9mZnNldCA9IGlkM0RhdGEubGVuZ3RoO1xuXG4gICAgbGV0IGlkM1NhbXBsZXMgPSBbeyBwdHM6IHN0YW1wLCBkdHM6IHN0YW1wLCBkYXRhOiBpZDNEYXRhIH1dO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCAtIDEpIHtcbiAgICAgIGlmIChBRFRTLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkgJiYgKG9mZnNldCArIDUpIDwgbGVuZ3RoKSB7XG4gICAgICAgIEFEVFMuaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCB0aGlzLm9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIHRyYWNrLm1hbmlmZXN0Q29kZWMpO1xuICAgICAgICBsZXQgZnJhbWUgPSBBRFRTLmFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCk7XG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgc3RhbXAgPSBmcmFtZS5zYW1wbGUucHRzO1xuICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdVbmFibGUgdG8gcGFyc2UgQUFDIGZyYW1lJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoSUQzLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgaWQzRGF0YSA9IElEMy5nZXRJRDNEYXRhKGRhdGEsIG9mZnNldCk7XG4gICAgICAgIGlkM1NhbXBsZXMucHVzaCh7IHB0czogc3RhbXAsIGR0czogc3RhbXAsIGRhdGE6IGlkM0RhdGEgfSk7XG4gICAgICAgIG9mZnNldCArPSBpZDNEYXRhLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlbXV4ZXIucmVtdXgodHJhY2ssXG4gICAgICB7IHNhbXBsZXM6IFtdIH0sXG4gICAgICB7IHNhbXBsZXM6IGlkM1NhbXBsZXMsIGlucHV0VGltZVNjYWxlOiA5MDAwMCB9LFxuICAgICAgeyBzYW1wbGVzOiBbXSB9LFxuICAgICAgdGltZU9mZnNldCxcbiAgICAgIGNvbnRpZ3VvdXMsXG4gICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQUFDRGVtdXhlcjtcbiIsIi8qKlxuICogIEFEVFMgcGFyc2VyIGhlbHBlclxuICovXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5cbmltcG9ydCB7IGdldFNlbGZTY29wZSB9IGZyb20gJy4uL3V0aWxzL2dldC1zZWxmLXNjb3BlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEF1ZGlvQ29uZmlnIChvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKSB7XG4gIGxldCBhZHRzT2JqZWN0VHlwZSwgLy8gOmludFxuICAgIGFkdHNTYW1wbGVpbmdJbmRleCwgLy8gOmludFxuICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCwgLy8gOmludFxuICAgIGFkdHNDaGFuZWxDb25maWcsIC8vIDppbnRcbiAgICBjb25maWcsXG4gICAgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLFxuICAgIG1hbmlmZXN0Q29kZWMgPSBhdWRpb0NvZGVjLFxuICAgIGFkdHNTYW1wbGVpbmdSYXRlcyA9IFtcbiAgICAgIDk2MDAwLCA4ODIwMCxcbiAgICAgIDY0MDAwLCA0ODAwMCxcbiAgICAgIDQ0MTAwLCAzMjAwMCxcbiAgICAgIDI0MDAwLCAyMjA1MCxcbiAgICAgIDE2MDAwLCAxMjAwMCxcbiAgICAgIDExMDI1LCA4MDAwLFxuICAgICAgNzM1MF07XG4gIC8vIGJ5dGUgMlxuICBhZHRzT2JqZWN0VHlwZSA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4QzApID4+PiA2KSArIDE7XG4gIGFkdHNTYW1wbGVpbmdJbmRleCA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4M0MpID4+PiAyKTtcbiAgaWYgKGFkdHNTYW1wbGVpbmdJbmRleCA+IGFkdHNTYW1wbGVpbmdSYXRlcy5sZW5ndGggLSAxKSB7XG4gICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogdHJ1ZSwgcmVhc29uOiBgaW52YWxpZCBBRFRTIHNhbXBsaW5nIGluZGV4OiR7YWR0c1NhbXBsZWluZ0luZGV4fWAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFkdHNDaGFuZWxDb25maWcgPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDAxKSA8PCAyKTtcbiAgLy8gYnl0ZSAzXG4gIGFkdHNDaGFuZWxDb25maWcgfD0gKChkYXRhW29mZnNldCArIDNdICYgMHhDMCkgPj4+IDYpO1xuICBsb2dnZXIubG9nKGBtYW5pZmVzdCBjb2RlYzoke2F1ZGlvQ29kZWN9LEFEVFMgZGF0YTp0eXBlOiR7YWR0c09iamVjdFR5cGV9LHNhbXBsZWluZ0luZGV4OiR7YWR0c1NhbXBsZWluZ0luZGV4fVske2FkdHNTYW1wbGVpbmdSYXRlc1thZHRzU2FtcGxlaW5nSW5kZXhdfUh6XSxjaGFubmVsQ29uZmlnOiR7YWR0c0NoYW5lbENvbmZpZ31gKTtcbiAgLy8gZmlyZWZveDogZnJlcSBsZXNzIHRoYW4gMjRrSHogPSBBQUMgU0JSIChIRS1BQUMpXG4gIGlmICgvZmlyZWZveC9pLnRlc3QodXNlckFnZW50KSkge1xuICAgIGlmIChhZHRzU2FtcGxlaW5nSW5kZXggPj0gNikge1xuICAgICAgYWR0c09iamVjdFR5cGUgPSA1O1xuICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleCAtIDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgICB9XG4gICAgLy8gQW5kcm9pZCA6IGFsd2F5cyB1c2UgQUFDXG4gIH0gZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEpIHtcbiAgICBhZHRzT2JqZWN0VHlwZSA9IDI7XG4gICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgfSBlbHNlIHtcbiAgICAvKiAgZm9yIG90aGVyIGJyb3dzZXJzIChDaHJvbWUvVml2YWxkaS9PcGVyYSAuLi4pXG4gICAgICAgIGFsd2F5cyBmb3JjZSBhdWRpbyB0eXBlIHRvIGJlIEhFLUFBQyBTQlIsIGFzIHNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgYXVkaW8gY29kZWMgc3dpdGNoIHByb3Blcmx5IChsaWtlIENocm9tZSAuLi4pXG4gICAgKi9cbiAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuICAgIC8vIGlmIChtYW5pZmVzdCBjb2RlYyBpcyBIRS1BQUMgb3IgSEUtQUFDdjIpIE9SIChtYW5pZmVzdCBjb2RlYyBub3Qgc3BlY2lmaWVkIEFORCBmcmVxdWVuY3kgbGVzcyB0aGFuIDI0a0h6KVxuICAgIGlmICgoYXVkaW9Db2RlYyAmJiAoKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yOScpICE9PSAtMSkgfHxcbiAgICAgIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkpKSB8fFxuICAgICAgKCFhdWRpb0NvZGVjICYmIGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2KSkge1xuICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleCAtIDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIChtYW5pZmVzdCBjb2RlYyBpcyBBQUMpIEFORCAoZnJlcXVlbmN5IGxlc3MgdGhhbiAyNGtIeiBBTkQgbmIgY2hhbm5lbCBpcyAxKSBPUiAobWFuaWZlc3QgY29kZWMgbm90IHNwZWNpZmllZCBhbmQgbW9ubyBhdWRpbylcbiAgICAgIC8vIENocm9tZSBmYWlscyB0byBwbGF5IGJhY2sgd2l0aCBsb3cgZnJlcXVlbmN5IEFBQyBMQyBtb25vIHdoZW4gaW5pdGlhbGl6ZWQgd2l0aCBIRS1BQUMuICBUaGlzIGlzIG5vdCBhIHByb2JsZW0gd2l0aCBzdGVyZW8uXG4gICAgICBpZiAoYXVkaW9Db2RlYyAmJiBhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMSAmJiAoKGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2ICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpIHx8XG4gICAgICAgICAgICAvdml2YWxkaS9pLnRlc3QodXNlckFnZW50KSkgfHxcbiAgICAgICAgKCFhdWRpb0NvZGVjICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpKSB7XG4gICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgfVxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4O1xuICAgIH1cbiAgfVxuICAvKiByZWZlciB0byBodHRwOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1NUEVHLTRfQXVkaW8jQXVkaW9fU3BlY2lmaWNfQ29uZmlnXG4gICAgICBJU08gMTQ0OTYtMyAoQUFDKS5wZGYgLSBUYWJsZSAxLjEzIOKAlCBTeW50YXggb2YgQXVkaW9TcGVjaWZpY0NvbmZpZygpXG4gICAgQXVkaW8gUHJvZmlsZSAvIEF1ZGlvIE9iamVjdCBUeXBlXG4gICAgMDogTnVsbFxuICAgIDE6IEFBQyBNYWluXG4gICAgMjogQUFDIExDIChMb3cgQ29tcGxleGl0eSlcbiAgICAzOiBBQUMgU1NSIChTY2FsYWJsZSBTYW1wbGUgUmF0ZSlcbiAgICA0OiBBQUMgTFRQIChMb25nIFRlcm0gUHJlZGljdGlvbilcbiAgICA1OiBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pXG4gICAgNjogQUFDIFNjYWxhYmxlXG4gICBzYW1wbGluZyBmcmVxXG4gICAgMDogOTYwMDAgSHpcbiAgICAxOiA4ODIwMCBIelxuICAgIDI6IDY0MDAwIEh6XG4gICAgMzogNDgwMDAgSHpcbiAgICA0OiA0NDEwMCBIelxuICAgIDU6IDMyMDAwIEh6XG4gICAgNjogMjQwMDAgSHpcbiAgICA3OiAyMjA1MCBIelxuICAgIDg6IDE2MDAwIEh6XG4gICAgOTogMTIwMDAgSHpcbiAgICAxMDogMTEwMjUgSHpcbiAgICAxMTogODAwMCBIelxuICAgIDEyOiA3MzUwIEh6XG4gICAgMTM6IFJlc2VydmVkXG4gICAgMTQ6IFJlc2VydmVkXG4gICAgMTU6IGZyZXF1ZW5jeSBpcyB3cml0dGVuIGV4cGxpY3RseVxuICAgIENoYW5uZWwgQ29uZmlndXJhdGlvbnNcbiAgICBUaGVzZSBhcmUgdGhlIGNoYW5uZWwgY29uZmlndXJhdGlvbnM6XG4gICAgMDogRGVmaW5lZCBpbiBBT1QgU3BlY2lmYyBDb25maWdcbiAgICAxOiAxIGNoYW5uZWw6IGZyb250LWNlbnRlclxuICAgIDI6IDIgY2hhbm5lbHM6IGZyb250LWxlZnQsIGZyb250LXJpZ2h0XG4gICovXG4gIC8vIGF1ZGlvT2JqZWN0VHlwZSA9IHByb2ZpbGUgPT4gcHJvZmlsZSwgdGhlIE1QRUctNCBBdWRpbyBPYmplY3QgVHlwZSBtaW51cyAxXG4gIGNvbmZpZ1swXSA9IGFkdHNPYmplY3RUeXBlIDw8IDM7XG4gIC8vIHNhbXBsaW5nRnJlcXVlbmN5SW5kZXhcbiAgY29uZmlnWzBdIHw9IChhZHRzU2FtcGxlaW5nSW5kZXggJiAweDBFKSA+PiAxO1xuICBjb25maWdbMV0gfD0gKGFkdHNTYW1wbGVpbmdJbmRleCAmIDB4MDEpIDw8IDc7XG4gIC8vIGNoYW5uZWxDb25maWd1cmF0aW9uXG4gIGNvbmZpZ1sxXSB8PSBhZHRzQ2hhbmVsQ29uZmlnIDw8IDM7XG4gIGlmIChhZHRzT2JqZWN0VHlwZSA9PT0gNSkge1xuICAgIC8vIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleFxuICAgIGNvbmZpZ1sxXSB8PSAoYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ICYgMHgwRSkgPj4gMTtcbiAgICBjb25maWdbMl0gPSAoYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgICAvLyBhZHRzT2JqZWN0VHlwZSAoZm9yY2UgdG8gMiwgY2hyb21lIGlzIGNoZWNraW5nIHRoYXQgb2JqZWN0IHR5cGUgaXMgbGVzcyB0aGFuIDUgPz8/XG4gICAgLy8gICAgaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy5naXQvKy9tYXN0ZXIvbWVkaWEvZm9ybWF0cy9tcDQvYWFjLmNjXG4gICAgY29uZmlnWzJdIHw9IDIgPDwgMjtcbiAgICBjb25maWdbM10gPSAwO1xuICB9XG4gIHJldHVybiB7IGNvbmZpZzogY29uZmlnLCBzYW1wbGVyYXRlOiBhZHRzU2FtcGxlaW5nUmF0ZXNbYWR0c1NhbXBsZWluZ0luZGV4XSwgY2hhbm5lbENvdW50OiBhZHRzQ2hhbmVsQ29uZmlnLCBjb2RlYzogKCdtcDRhLjQwLicgKyBhZHRzT2JqZWN0VHlwZSksIG1hbmlmZXN0Q29kZWM6IG1hbmlmZXN0Q29kZWMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSGVhZGVyUGF0dGVybiAoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGY2KSA9PT0gMHhmMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhlYWRlckxlbmd0aCAoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDEgPyA3IDogOSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGdWxsRnJhbWVMZW5ndGggKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gKChkYXRhW29mZnNldCArIDNdICYgMHgwMykgPDwgMTEpIHxcbiAgICAoZGF0YVtvZmZzZXQgKyA0XSA8PCAzKSB8XG4gICAgKChkYXRhW29mZnNldCArIDVdICYgMHhFMCkgPj4+IDUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNIZWFkZXIgKGRhdGEsIG9mZnNldCkge1xuICAvLyBMb29rIGZvciBBRFRTIGhlYWRlciB8IDExMTEgMTExMSB8IDExMTEgWDAwWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDFcbiAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyAwIGZvciBBRFRTXG4gIC8vIE1vcmUgaW5mbyBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICBpZiAob2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9iZSAoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIHNhbWUgYXMgaXNIZWFkZXIgYnV0IHdlIGFsc28gY2hlY2sgdGhhdCBBRFRTIGZyYW1lIGZvbGxvd3MgbGFzdCBBRFRTIGZyYW1lXG4gIC8vIG9yIGVuZCBvZiBkYXRhIGlzIHJlYWNoZWRcbiAgaWYgKG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSkge1xuICAgIC8vIEFEVFMgaGVhZGVyIExlbmd0aFxuICAgIGxldCBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgICAvLyBBRFRTIGZyYW1lIExlbmd0aFxuICAgIGxldCBmcmFtZUxlbmd0aCA9IGhlYWRlckxlbmd0aDtcbiAgICBpZiAob2Zmc2V0ICsgNSA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICBmcmFtZUxlbmd0aCA9IGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAgIH1cblxuICAgIGxldCBuZXdPZmZzZXQgPSBvZmZzZXQgKyBmcmFtZUxlbmd0aDtcbiAgICBpZiAobmV3T2Zmc2V0ID09PSBkYXRhLmxlbmd0aCB8fCAobmV3T2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBuZXdPZmZzZXQpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRUcmFja0NvbmZpZyAodHJhY2ssIG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgaWYgKCF0cmFjay5zYW1wbGVyYXRlKSB7XG4gICAgbGV0IGNvbmZpZyA9IGdldEF1ZGlvQ29uZmlnKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpO1xuICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgdHJhY2suc2FtcGxlcmF0ZSA9IGNvbmZpZy5zYW1wbGVyYXRlO1xuICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGNvbmZpZy5jaGFubmVsQ291bnQ7XG4gICAgdHJhY2suY29kZWMgPSBjb25maWcuY29kZWM7XG4gICAgdHJhY2subWFuaWZlc3RDb2RlYyA9IGNvbmZpZy5tYW5pZmVzdENvZGVjO1xuICAgIGxvZ2dlci5sb2coYHBhcnNlZCBjb2RlYzoke3RyYWNrLmNvZGVjfSxyYXRlOiR7Y29uZmlnLnNhbXBsZXJhdGV9LG5iIGNoYW5uZWw6JHtjb25maWcuY2hhbm5lbENvdW50fWApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFtZUR1cmF0aW9uIChzYW1wbGVyYXRlKSB7XG4gIHJldHVybiAxMDI0ICogOTAwMDAgLyBzYW1wbGVyYXRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGcmFtZUhlYWRlciAoZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgsIGZyYW1lRHVyYXRpb24pIHtcbiAgbGV0IGhlYWRlckxlbmd0aCwgZnJhbWVMZW5ndGgsIHN0YW1wO1xuICBsZXQgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgLy8gVGhlIHByb3RlY3Rpb24gc2tpcCBiaXQgdGVsbHMgdXMgaWYgd2UgaGF2ZSAyIGJ5dGVzIG9mIENSQyBkYXRhIGF0IHRoZSBlbmQgb2YgdGhlIEFEVFMgaGVhZGVyXG4gIGhlYWRlckxlbmd0aCA9IGdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAvLyByZXRyaWV2ZSBmcmFtZSBzaXplXG4gIGZyYW1lTGVuZ3RoID0gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG4gIGZyYW1lTGVuZ3RoIC09IGhlYWRlckxlbmd0aDtcblxuICBpZiAoKGZyYW1lTGVuZ3RoID4gMCkgJiYgKChvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCkgPD0gbGVuZ3RoKSkge1xuICAgIHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XG4gICAgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofS8keyhzdGFtcC85MCkudG9GaXhlZCgwKX1gKTtcbiAgICByZXR1cm4geyBoZWFkZXJMZW5ndGgsIGZyYW1lTGVuZ3RoLCBzdGFtcCB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZEZyYW1lICh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpIHtcbiAgbGV0IGZyYW1lRHVyYXRpb24gPSBnZXRGcmFtZUR1cmF0aW9uKHRyYWNrLnNhbXBsZXJhdGUpO1xuICBsZXQgaGVhZGVyID0gcGFyc2VGcmFtZUhlYWRlcihkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCwgZnJhbWVEdXJhdGlvbik7XG4gIGlmIChoZWFkZXIpIHtcbiAgICBsZXQgc3RhbXAgPSBoZWFkZXIuc3RhbXA7XG4gICAgbGV0IGhlYWRlckxlbmd0aCA9IGhlYWRlci5oZWFkZXJMZW5ndGg7XG4gICAgbGV0IGZyYW1lTGVuZ3RoID0gaGVhZGVyLmZyYW1lTGVuZ3RoO1xuXG4gICAgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofS8keyhzdGFtcC85MCkudG9GaXhlZCgwKX1gKTtcbiAgICBsZXQgYWFjU2FtcGxlID0ge1xuICAgICAgdW5pdDogZGF0YS5zdWJhcnJheShvZmZzZXQgKyBoZWFkZXJMZW5ndGgsIG9mZnNldCArIGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoKSxcbiAgICAgIHB0czogc3RhbXAsXG4gICAgICBkdHM6IHN0YW1wXG4gICAgfTtcblxuICAgIHRyYWNrLnNhbXBsZXMucHVzaChhYWNTYW1wbGUpO1xuICAgIHRyYWNrLmxlbiArPSBmcmFtZUxlbmd0aDtcblxuICAgIHJldHVybiB7IHNhbXBsZTogYWFjU2FtcGxlLCBsZW5ndGg6IGZyYW1lTGVuZ3RoICsgaGVhZGVyTGVuZ3RoIH07XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuIiwiLyoqXG4gKlxuICogaW5saW5lIGRlbXV4ZXI6IHByb2JlIGZyYWdtZW50cyBhbmQgaW5zdGFudGlhdGVcbiAqIGFwcHJvcHJpYXRlIGRlbXV4ZXIgZGVwZW5kaW5nIG9uIGNvbnRlbnQgdHlwZSAoVFNEZW11eGVyLCBBQUNEZW11eGVyLCAuLi4pXG4gKlxuICovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCBEZWNyeXB0ZXIgZnJvbSAnLi4vY3J5cHQvZGVjcnlwdGVyJztcbmltcG9ydCBBQUNEZW11eGVyIGZyb20gJy4uL2RlbXV4L2FhY2RlbXV4ZXInO1xuaW1wb3J0IE1QNERlbXV4ZXIgZnJvbSAnLi4vZGVtdXgvbXA0ZGVtdXhlcic7XG5pbXBvcnQgVFNEZW11eGVyIGZyb20gJy4uL2RlbXV4L3RzZGVtdXhlcic7XG5pbXBvcnQgTVAzRGVtdXhlciBmcm9tICcuLi9kZW11eC9tcDNkZW11eGVyJztcbmltcG9ydCBNUDRSZW11eGVyIGZyb20gJy4uL3JlbXV4L21wNC1yZW11eGVyJztcbmltcG9ydCBQYXNzVGhyb3VnaFJlbXV4ZXIgZnJvbSAnLi4vcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlcic7XG5cbmltcG9ydCB7IGdldFNlbGZTY29wZSB9IGZyb20gJy4uL3V0aWxzL2dldC1zZWxmLXNjb3BlJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbi8vIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTEyMzcyNTkvNTg5NDkzXG5jb25zdCBnbG9iYWwgPSBnZXRTZWxmU2NvcGUoKTsgLy8gc2FmZWd1YXJkIGZvciBjb2RlIHRoYXQgbWlnaHQgcnVuIGJvdGggb24gd29ya2VyIGFuZCBtYWluIHRocmVhZFxuXG5sZXQgbm93O1xuLy8gcGVyZm9ybWFuY2Uubm93KCkgbm90IGF2YWlsYWJsZSBvbiBXZWJXb3JrZXIsIGF0IGxlYXN0IG9uIFNhZmFyaSBEZXNrdG9wXG50cnkge1xuICBub3cgPSBnbG9iYWwucGVyZm9ybWFuY2Uubm93LmJpbmQoZ2xvYmFsLnBlcmZvcm1hbmNlKTtcbn0gY2F0Y2ggKGVycikge1xuICBsb2dnZXIuZGVidWcoJ1VuYWJsZSB0byB1c2UgUGVyZm9ybWFuY2UgQVBJIG9uIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgbm93ID0gZ2xvYmFsLkRhdGUubm93O1xufVxuXG5jbGFzcyBEZW11eGVySW5saW5lIHtcbiAgY29uc3RydWN0b3IgKG9ic2VydmVyLCB0eXBlU3VwcG9ydGVkLCBjb25maWcsIHZlbmRvcikge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudmVuZG9yID0gdmVuZG9yO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgbGV0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgaWYgKGRlbXV4ZXIpIHtcbiAgICAgIGRlbXV4ZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2ggKGRhdGEsIGRlY3J5cHRkYXRhLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTKSB7XG4gICAgaWYgKChkYXRhLmJ5dGVMZW5ndGggPiAwKSAmJiAoZGVjcnlwdGRhdGEgIT0gbnVsbCkgJiYgKGRlY3J5cHRkYXRhLmtleSAhPSBudWxsKSAmJiAoZGVjcnlwdGRhdGEubWV0aG9kID09PSAnQUVTLTEyOCcpKSB7XG4gICAgICBsZXQgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXI7XG4gICAgICBpZiAoZGVjcnlwdGVyID09IG51bGwpIHtcbiAgICAgICAgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKHRoaXMub2JzZXJ2ZXIsIHRoaXMuY29uZmlnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gbm93KCk7XG4gICAgICBkZWNyeXB0ZXIuZGVjcnlwdChkYXRhLCBkZWNyeXB0ZGF0YS5rZXkuYnVmZmVyLCBkZWNyeXB0ZGF0YS5pdi5idWZmZXIsIChkZWNyeXB0ZWREYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBub3coKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfREVDUllQVEVELCB7IHN0YXRzOiB7IHRzdGFydDogc3RhcnRUaW1lLCB0ZGVjcnlwdDogZW5kVGltZSB9IH0pO1xuICAgICAgICB0aGlzLnB1c2hEZWNyeXB0ZWQobmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSksIGRlY3J5cHRkYXRhLCBuZXcgVWludDhBcnJheShpbml0U2VnbWVudCksIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoRGVjcnlwdGVkKG5ldyBVaW50OEFycmF5KGRhdGEpLCBkZWNyeXB0ZGF0YSwgbmV3IFVpbnQ4QXJyYXkoaW5pdFNlZ21lbnQpLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hEZWNyeXB0ZWQgKGRhdGEsIGRlY3J5cHRkYXRhLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdGltZU9mZnNldCwgZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gsIGNvbnRpZ3VvdXMsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRlZmF1bHRJbml0UFRTKSB7XG4gICAgbGV0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgaWYgKCFkZW11eGVyIHx8XG4gICAgICAvLyBpbiBjYXNlIG9mIGNvbnRpbnVpdHkgY2hhbmdlLCBvciB0cmFjayBzd2l0Y2hcbiAgICAgIC8vIHdlIG1pZ2h0IHN3aXRjaCBmcm9tIGNvbnRlbnQgdHlwZSAoQUFDIGNvbnRhaW5lciB0byBUUyBjb250YWluZXIsIG9yIFRTIHRvIGZtcDQgZm9yIGV4YW1wbGUpXG4gICAgICAvLyBzbyBsZXQncyBjaGVjayB0aGF0IGN1cnJlbnQgZGVtdXhlciBpcyBzdGlsbCB2YWxpZFxuICAgICAgKChkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoKSAmJiAhdGhpcy5wcm9iZShkYXRhKSkpIHtcbiAgICAgIGNvbnN0IG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcjtcbiAgICAgIGNvbnN0IHR5cGVTdXBwb3J0ZWQgPSB0aGlzLnR5cGVTdXBwb3J0ZWQ7XG4gICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgIC8vIHByb2Jpbmcgb3JkZXIgaXMgVFMvQUFDL01QMy9NUDRcbiAgICAgIGNvbnN0IG11eENvbmZpZyA9IFtcbiAgICAgICAgeyBkZW11eDogVFNEZW11eGVyLCByZW11eDogTVA0UmVtdXhlciB9LFxuICAgICAgICB7IGRlbXV4OiBNUDREZW11eGVyLCByZW11eDogUGFzc1Rocm91Z2hSZW11eGVyIH0sXG4gICAgICAgIHsgZGVtdXg6IEFBQ0RlbXV4ZXIsIHJlbXV4OiBNUDRSZW11eGVyIH0sXG4gICAgICAgIHsgZGVtdXg6IE1QM0RlbXV4ZXIsIHJlbXV4OiBNUDRSZW11eGVyIH1cbiAgICAgIF07XG5cbiAgICAgIC8vIHByb2JlIGZvciBjb250ZW50IHR5cGVcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtdXhDb25maWcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgbXV4ID0gbXV4Q29uZmlnW2ldO1xuICAgICAgICBjb25zdCBwcm9iZSA9IG11eC5kZW11eC5wcm9iZTtcbiAgICAgICAgaWYgKHByb2JlKGRhdGEpKSB7XG4gICAgICAgICAgY29uc3QgcmVtdXhlciA9IHRoaXMucmVtdXhlciA9IG5ldyBtdXgucmVtdXgob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCwgdGhpcy52ZW5kb3IpO1xuICAgICAgICAgIGRlbXV4ZXIgPSBuZXcgbXV4LmRlbXV4KG9ic2VydmVyLCByZW11eGVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQpO1xuICAgICAgICAgIHRoaXMucHJvYmUgPSBwcm9iZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFkZW11eGVyKSB7XG4gICAgICAgIG9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUiwgZmF0YWw6IHRydWUsIHJlYXNvbjogJ25vIGRlbXV4IG1hdGNoaW5nIHdpdGggY29udGVudCBmb3VuZCcgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVtdXhlciA9IGRlbXV4ZXI7XG4gICAgfVxuICAgIGNvbnN0IHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XG5cbiAgICBpZiAoZGlzY29udGludWl0eSB8fCB0cmFja1N3aXRjaCkge1xuICAgICAgZGVtdXhlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbik7XG4gICAgICByZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoKTtcbiAgICB9XG4gICAgaWYgKGRpc2NvbnRpbnVpdHkpIHtcbiAgICAgIGRlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQVFMpO1xuICAgICAgcmVtdXhlci5yZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFBUUyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGVtdXhlci5zZXREZWNyeXB0RGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGVtdXhlci5zZXREZWNyeXB0RGF0YShkZWNyeXB0ZGF0YSk7XG4gICAgfVxuXG4gICAgZGVtdXhlci5hcHBlbmQoZGF0YSwgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZW11eGVySW5saW5lO1xuIiwiLyogZGVtdXhlciB3ZWIgd29ya2VyLlxuICogIC0gbGlzdGVuIHRvIHdvcmtlciBtZXNzYWdlLCBhbmQgdHJpZ2dlciBEZW11eGVySW5saW5lIHVwb24gcmVjZXB0aW9uIG9mIEZyYWdtZW50cy5cbiAqICAtIHByb3ZpZGVzIE1QNCBCb3hlcyBiYWNrIHRvIG1haW4gdGhyZWFkIHVzaW5nIFt0cmFuc2ZlcmFibGUgb2JqZWN0c10oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3VwZGF0ZXMvMjAxMS8xMi9UcmFuc2ZlcmFibGUtT2JqZWN0cy1MaWdodG5pbmctRmFzdCkgaW4gb3JkZXIgdG8gbWluaW1pemUgbWVzc2FnZSBwYXNzaW5nIG92ZXJoZWFkLlxuICovXG5cbmltcG9ydCBEZW11eGVySW5saW5lIGZyb20gJy4uL2RlbXV4L2RlbXV4ZXItaW5saW5lJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgZW5hYmxlTG9ncyB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5cbmxldCBEZW11eGVyV29ya2VyID0gZnVuY3Rpb24gKHNlbGYpIHtcbiAgLy8gb2JzZXJ2ZXIgc2V0dXBcbiAgbGV0IG9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBvYnNlcnZlci50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlciAoZXZlbnQsIC4uLmRhdGEpIHtcbiAgICBvYnNlcnZlci5lbWl0KGV2ZW50LCBldmVudCwgLi4uZGF0YSk7XG4gIH07XG5cbiAgb2JzZXJ2ZXIub2ZmID0gZnVuY3Rpb24gb2ZmIChldmVudCwgLi4uZGF0YSkge1xuICAgIG9ic2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCAuLi5kYXRhKTtcbiAgfTtcblxuICBsZXQgZm9yd2FyZE1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHsgZXZlbnQ6IGV2LCBkYXRhOiBkYXRhIH0pO1xuICB9O1xuXG4gIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgIGxldCBkYXRhID0gZXYuZGF0YTtcbiAgICAvLyBjb25zb2xlLmxvZygnZGVtdXhlciBjbWQ6JyArIGRhdGEuY21kKTtcbiAgICBzd2l0Y2ggKGRhdGEuY21kKSB7XG4gICAgY2FzZSAnaW5pdCc6XG4gICAgICBjb25zdCBjb25maWcgPSBKU09OLnBhcnNlKGRhdGEuY29uZmlnKTtcbiAgICAgIHNlbGYuZGVtdXhlciA9IG5ldyBEZW11eGVySW5saW5lKG9ic2VydmVyLCBkYXRhLnR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgZGF0YS52ZW5kb3IpO1xuXG4gICAgICBlbmFibGVMb2dzKGNvbmZpZy5kZWJ1Zyk7XG5cbiAgICAgIC8vIHNpZ25hbCBlbmQgb2Ygd29ya2VyIGluaXRcbiAgICAgIGZvcndhcmRNZXNzYWdlKCdpbml0JywgbnVsbCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkZW11eCc6XG4gICAgICBzZWxmLmRlbXV4ZXIucHVzaChkYXRhLmRhdGEsIGRhdGEuZGVjcnlwdGRhdGEsIGRhdGEuaW5pdFNlZ21lbnQsIGRhdGEuYXVkaW9Db2RlYywgZGF0YS52aWRlb0NvZGVjLCBkYXRhLnRpbWVPZmZzZXQsIGRhdGEuZGlzY29udGludWl0eSwgZGF0YS50cmFja1N3aXRjaCwgZGF0YS5jb250aWd1b3VzLCBkYXRhLmR1cmF0aW9uLCBkYXRhLmFjY3VyYXRlVGltZU9mZnNldCwgZGF0YS5kZWZhdWx0SW5pdFBUUyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcblxuICAvLyBmb3J3YXJkIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICBvYnNlcnZlci5vbihFdmVudC5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0VELCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19NRVRBREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xuICBvYnNlcnZlci5vbihFdmVudC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oRXZlbnQuSU5JVF9QVFNfRk9VTkQsIGZvcndhcmRNZXNzYWdlKTtcblxuICAvLyBzcGVjaWFsIGNhc2UgZm9yIEZSQUdfUEFSU0lOR19EQVRBOiBwYXNzIGRhdGExL2RhdGEyIGFzIHRyYW5zZmVyYWJsZSBvYmplY3QgKG5vIGNvcHkpXG4gIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcbiAgICBsZXQgdHJhbnNmZXJhYmxlID0gW107XG4gICAgbGV0IG1lc3NhZ2UgPSB7IGV2ZW50OiBldiwgZGF0YTogZGF0YSB9O1xuICAgIGlmIChkYXRhLmRhdGExKSB7XG4gICAgICBtZXNzYWdlLmRhdGExID0gZGF0YS5kYXRhMS5idWZmZXI7XG4gICAgICB0cmFuc2ZlcmFibGUucHVzaChkYXRhLmRhdGExLmJ1ZmZlcik7XG4gICAgICBkZWxldGUgZGF0YS5kYXRhMTtcbiAgICB9XG4gICAgaWYgKGRhdGEuZGF0YTIpIHtcbiAgICAgIG1lc3NhZ2UuZGF0YTIgPSBkYXRhLmRhdGEyLmJ1ZmZlcjtcbiAgICAgIHRyYW5zZmVyYWJsZS5wdXNoKGRhdGEuZGF0YTIuYnVmZmVyKTtcbiAgICAgIGRlbGV0ZSBkYXRhLmRhdGEyO1xuICAgIH1cbiAgICBzZWxmLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyYWJsZSk7XG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRGVtdXhlcldvcmtlcjtcbiIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgKiBhcyB3b3JrIGZyb20gJ3dlYndvcmtpZnktd2VicGFjayc7XG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IERlbXV4ZXJJbmxpbmUgZnJvbSAnLi4vZGVtdXgvZGVtdXhlci1pbmxpbmUnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBnZXRNZWRpYVNvdXJjZSB9IGZyb20gJy4uL3V0aWxzL21lZGlhc291cmNlLWhlbHBlcic7XG5pbXBvcnQgeyBnZXRTZWxmU2NvcGUgfSBmcm9tICcuLi91dGlscy9nZXQtc2VsZi1zY29wZSc7XG5cbmltcG9ydCB7IE9ic2VydmVyIH0gZnJvbSAnLi4vb2JzZXJ2ZXInO1xuXG4vLyBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExMjM3MjU5LzU4OTQ5M1xuY29uc3QgZ2xvYmFsID0gZ2V0U2VsZlNjb3BlKCk7IC8vIHNhZmVndWFyZCBmb3IgY29kZSB0aGF0IG1pZ2h0IHJ1biBib3RoIG9uIHdvcmtlciBhbmQgbWFpbiB0aHJlYWRcbmNvbnN0IE1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UoKTtcblxuY2xhc3MgRGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yIChobHMsIGlkKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5pZCA9IGlkO1xuXG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyID0gbmV3IE9ic2VydmVyKCk7XG4gICAgY29uc3QgY29uZmlnID0gaGxzLmNvbmZpZztcblxuICAgIGNvbnN0IGZvcndhcmRNZXNzYWdlID0gKGV2LCBkYXRhKSA9PiB7XG4gICAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgIGRhdGEuZnJhZyA9IHRoaXMuZnJhZztcbiAgICAgIGRhdGEuaWQgPSB0aGlzLmlkO1xuICAgICAgaGxzLnRyaWdnZXIoZXYsIGRhdGEpO1xuICAgIH07XG5cbiAgICAvLyBmb3J3YXJkIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICAgIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfREVDUllQVEVELCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgb2JzZXJ2ZXIub24oRXZlbnQuRlJBR19QQVJTRUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBvYnNlcnZlci5vbihFdmVudC5FUlJPUiwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19NRVRBREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLm9uKEV2ZW50LkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLm9uKEV2ZW50LklOSVRfUFRTX0ZPVU5ELCBmb3J3YXJkTWVzc2FnZSk7XG5cbiAgICBjb25zdCB0eXBlU3VwcG9ydGVkID0ge1xuICAgICAgbXA0OiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNCcpLFxuICAgICAgbXBlZzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcGVnJyksXG4gICAgICBtcDM6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXA0OyBjb2RlY3M9XCJtcDNcIicpXG4gICAgfTtcbiAgICAvLyBuYXZpZ2F0b3IudmVuZG9yIGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlIGluIFdlYiBXb3JrZXJcbiAgICAvLyByZWZlciB0byBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV29ya2VyR2xvYmFsU2NvcGUvbmF2aWdhdG9yXG4gICAgY29uc3QgdmVuZG9yID0gbmF2aWdhdG9yLnZlbmRvcjtcbiAgICBpZiAoY29uZmlnLmVuYWJsZVdvcmtlciAmJiAodHlwZW9mIChXb3JrZXIpICE9PSAndW5kZWZpbmVkJykpIHtcbiAgICAgIGxvZ2dlci5sb2coJ2RlbXV4aW5nIGluIHdlYndvcmtlcicpO1xuICAgICAgbGV0IHc7XG4gICAgICB0cnkge1xuICAgICAgICB3ID0gdGhpcy53ID0gd29yayhyZXF1aXJlLnJlc29sdmUoJy4uL2RlbXV4L2RlbXV4ZXItd29ya2VyLmpzJykpO1xuICAgICAgICB0aGlzLm9ud21zZyA9IHRoaXMub25Xb3JrZXJNZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHcuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMub253bXNnKTtcbiAgICAgICAgdy5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTiwgZmF0YWw6IHRydWUsIGV2ZW50OiAnZGVtdXhlcldvcmtlcicsIGVycjogeyBtZXNzYWdlOiBldmVudC5tZXNzYWdlICsgJyAoJyArIGV2ZW50LmZpbGVuYW1lICsgJzonICsgZXZlbnQubGluZW5vICsgJyknIH0gfSk7XG4gICAgICAgIH07XG4gICAgICAgIHcucG9zdE1lc3NhZ2UoeyBjbWQ6ICdpbml0JywgdHlwZVN1cHBvcnRlZDogdHlwZVN1cHBvcnRlZCwgdmVuZG9yOiB2ZW5kb3IsIGlkOiBpZCwgY29uZmlnOiBKU09OLnN0cmluZ2lmeShjb25maWcpIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdFcnJvciBpbiB3b3JrZXI6JywgZXJyKTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdFcnJvciB3aGlsZSBpbml0aWFsaXppbmcgRGVtdXhlcldvcmtlciwgZmFsbGJhY2sgb24gRGVtdXhlcklubGluZScpO1xuICAgICAgICBpZiAodykge1xuICAgICAgICAgIC8vIHJldm9rZSB0aGUgT2JqZWN0IFVSTCB0aGF0IHdhcyB1c2VkIHRvIGNyZWF0ZSBkZW11eGVyIHdvcmtlciwgc28gYXMgbm90IHRvIGxlYWsgaXRcbiAgICAgICAgICBnbG9iYWwuVVJMLnJldm9rZU9iamVjdFVSTCh3Lm9iamVjdFVSTCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXJJbmxpbmUob2JzZXJ2ZXIsIHR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgdmVuZG9yKTtcbiAgICAgICAgdGhpcy53ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcklubGluZShvYnNlcnZlciwgdHlwZVN1cHBvcnRlZCwgY29uZmlnLCB2ZW5kb3IpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGxldCB3ID0gdGhpcy53O1xuICAgIGlmICh3KSB7XG4gICAgICB3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyk7XG4gICAgICB3LnRlcm1pbmF0ZSgpO1xuICAgICAgdGhpcy53ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgICBpZiAoZGVtdXhlcikge1xuICAgICAgICBkZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kZW11eGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgb2JzZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdXNoIChkYXRhLCBpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZnJhZywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMpIHtcbiAgICBjb25zdCB3ID0gdGhpcy53O1xuICAgIGNvbnN0IHRpbWVPZmZzZXQgPSBOdW1iZXIuaXNGaW5pdGUoZnJhZy5zdGFydFBUUykgPyBmcmFnLnN0YXJ0UFRTIDogZnJhZy5zdGFydDtcbiAgICBjb25zdCBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgY29uc3QgbGFzdEZyYWcgPSB0aGlzLmZyYWc7XG4gICAgY29uc3QgZGlzY29udGludWl0eSA9ICEobGFzdEZyYWcgJiYgKGZyYWcuY2MgPT09IGxhc3RGcmFnLmNjKSk7XG4gICAgY29uc3QgdHJhY2tTd2l0Y2ggPSAhKGxhc3RGcmFnICYmIChmcmFnLmxldmVsID09PSBsYXN0RnJhZy5sZXZlbCkpO1xuICAgIGNvbnN0IG5leHRTTiA9IGxhc3RGcmFnICYmIChmcmFnLnNuID09PSAobGFzdEZyYWcuc24gKyAxKSk7XG4gICAgY29uc3QgY29udGlndW91cyA9ICF0cmFja1N3aXRjaCAmJiBuZXh0U047XG4gICAgaWYgKGRpc2NvbnRpbnVpdHkpIHtcbiAgICAgIGxvZ2dlci5sb2coYCR7dGhpcy5pZH06ZGlzY29udGludWl0eSBkZXRlY3RlZGApO1xuICAgIH1cblxuICAgIGlmICh0cmFja1N3aXRjaCkge1xuICAgICAgbG9nZ2VyLmxvZyhgJHt0aGlzLmlkfTpzd2l0Y2ggZGV0ZWN0ZWRgKTtcbiAgICB9XG5cbiAgICB0aGlzLmZyYWcgPSBmcmFnO1xuICAgIGlmICh3KSB7XG4gICAgICAvLyBwb3N0IGZyYWdtZW50IHBheWxvYWQgYXMgdHJhbnNmZXJhYmxlIG9iamVjdHMgZm9yIEFycmF5QnVmZmVyIChubyBjb3B5KVxuICAgICAgdy5wb3N0TWVzc2FnZSh7IGNtZDogJ2RlbXV4JywgZGF0YSwgZGVjcnlwdGRhdGEsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0aW1lT2Zmc2V0LCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCwgY29udGlndW91cywgZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgZGVmYXVsdEluaXRQVFMgfSwgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gW2RhdGFdIDogW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGVtdXhlciA9IHRoaXMuZGVtdXhlcjtcbiAgICAgIGlmIChkZW11eGVyKSB7XG4gICAgICAgIGRlbXV4ZXIucHVzaChkYXRhLCBkZWNyeXB0ZGF0YSwgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRpbWVPZmZzZXQsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoLCBjb250aWd1b3VzLCBkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBkZWZhdWx0SW5pdFBUUyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Xb3JrZXJNZXNzYWdlIChldikge1xuICAgIGxldCBkYXRhID0gZXYuZGF0YSxcbiAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgIHN3aXRjaCAoZGF0YS5ldmVudCkge1xuICAgIGNhc2UgJ2luaXQnOlxuICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIGRlbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgZ2xvYmFsLlVSTC5yZXZva2VPYmplY3RVUkwodGhpcy53Lm9iamVjdFVSTCk7XG4gICAgICBicmVhaztcbiAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgRlJBR19QQVJTSU5HX0RBVEE6IGRhdGExIGFuZCBkYXRhMiBhcmUgdHJhbnNmZXJhYmxlIG9iamVjdHNcbiAgICBjYXNlIEV2ZW50LkZSQUdfUEFSU0lOR19EQVRBOlxuICAgICAgZGF0YS5kYXRhLmRhdGExID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5kYXRhMSk7XG4gICAgICBpZiAoZGF0YS5kYXRhMikge1xuICAgICAgICBkYXRhLmRhdGEuZGF0YTIgPSBuZXcgVWludDhBcnJheShkYXRhLmRhdGEyKTtcbiAgICAgIH1cblxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICBkYXRhLmRhdGEgPSBkYXRhLmRhdGEgfHwge307XG4gICAgICBkYXRhLmRhdGEuZnJhZyA9IHRoaXMuZnJhZztcbiAgICAgIGRhdGEuZGF0YS5pZCA9IHRoaXMuaWQ7XG4gICAgICBobHMudHJpZ2dlcihkYXRhLmV2ZW50LCBkYXRhLmRhdGEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERlbXV4ZXI7XG4iLCIvKipcbiAqIFBhcnNlciBmb3IgZXhwb25lbnRpYWwgR29sb21iIGNvZGVzLCBhIHZhcmlhYmxlLWJpdHdpZHRoIG51bWJlciBlbmNvZGluZyBzY2hlbWUgdXNlZCBieSBoMjY0LlxuKi9cblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY2xhc3MgRXhwR29sb21iIHtcbiAgY29uc3RydWN0b3IgKGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIC8vIHRoZSBudW1iZXIgb2YgYnl0ZXMgbGVmdCB0byBleGFtaW5lIGluIHRoaXMuZGF0YVxuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgLy8gdGhlIGN1cnJlbnQgd29yZCBiZWluZyBleGFtaW5lZFxuICAgIHRoaXMud29yZCA9IDA7IC8vIDp1aW50XG4gICAgLy8gdGhlIG51bWJlciBvZiBiaXRzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGUgY3VycmVudCB3b3JkXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gMDsgLy8gOnVpbnRcbiAgfVxuXG4gIC8vICgpOnZvaWRcbiAgbG9hZFdvcmQgKCkge1xuICAgIGxldFxuICAgICAgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgIGJ5dGVzQXZhaWxhYmxlID0gdGhpcy5ieXRlc0F2YWlsYWJsZSxcbiAgICAgIHBvc2l0aW9uID0gZGF0YS5ieXRlTGVuZ3RoIC0gYnl0ZXNBdmFpbGFibGUsXG4gICAgICB3b3JraW5nQnl0ZXMgPSBuZXcgVWludDhBcnJheSg0KSxcbiAgICAgIGF2YWlsYWJsZUJ5dGVzID0gTWF0aC5taW4oNCwgYnl0ZXNBdmFpbGFibGUpO1xuICAgIGlmIChhdmFpbGFibGVCeXRlcyA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBieXRlcyBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICB3b3JraW5nQnl0ZXMuc2V0KGRhdGEuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgYXZhaWxhYmxlQnl0ZXMpKTtcbiAgICB0aGlzLndvcmQgPSBuZXcgRGF0YVZpZXcod29ya2luZ0J5dGVzLmJ1ZmZlcikuZ2V0VWludDMyKDApO1xuICAgIC8vIHRyYWNrIHRoZSBhbW91bnQgb2YgdGhpcy5kYXRhIHRoYXQgaGFzIGJlZW4gcHJvY2Vzc2VkXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gYXZhaWxhYmxlQnl0ZXMgKiA4O1xuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gYXZhaWxhYmxlQnl0ZXM7XG4gIH1cblxuICAvLyAoY291bnQ6aW50KTp2b2lkXG4gIHNraXBCaXRzIChjb3VudCkge1xuICAgIGxldCBza2lwQnl0ZXM7IC8vIDppbnRcbiAgICBpZiAodGhpcy5iaXRzQXZhaWxhYmxlID4gY291bnQpIHtcbiAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50IC09IHRoaXMuYml0c0F2YWlsYWJsZTtcbiAgICAgIHNraXBCeXRlcyA9IGNvdW50ID4+IDM7XG4gICAgICBjb3VudCAtPSAoc2tpcEJ5dGVzID4+IDMpO1xuICAgICAgdGhpcy5ieXRlc0F2YWlsYWJsZSAtPSBza2lwQnl0ZXM7XG4gICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgICB0aGlzLndvcmQgPDw9IGNvdW50O1xuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGNvdW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIChzaXplOmludCk6dWludFxuICByZWFkQml0cyAoc2l6ZSkge1xuICAgIGxldFxuICAgICAgYml0cyA9IE1hdGgubWluKHRoaXMuYml0c0F2YWlsYWJsZSwgc2l6ZSksIC8vIDp1aW50XG4gICAgICB2YWx1ID0gdGhpcy53b3JkID4+PiAoMzIgLSBiaXRzKTsgLy8gOnVpbnRcbiAgICBpZiAoc2l6ZSA+IDMyKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Nhbm5vdCByZWFkIG1vcmUgdGhhbiAzMiBiaXRzIGF0IGEgdGltZScpO1xuICAgIH1cblxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBiaXRzO1xuICAgIGlmICh0aGlzLmJpdHNBdmFpbGFibGUgPiAwKSB7XG4gICAgICB0aGlzLndvcmQgPDw9IGJpdHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLmJ5dGVzQXZhaWxhYmxlID4gMCkge1xuICAgICAgdGhpcy5sb2FkV29yZCgpO1xuICAgIH1cblxuICAgIGJpdHMgPSBzaXplIC0gYml0cztcbiAgICBpZiAoYml0cyA+IDAgJiYgdGhpcy5iaXRzQXZhaWxhYmxlKSB7XG4gICAgICByZXR1cm4gdmFsdSA8PCBiaXRzIHwgdGhpcy5yZWFkQml0cyhiaXRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbHU7XG4gICAgfVxuICB9XG5cbiAgLy8gKCk6dWludFxuICBza2lwTFogKCkge1xuICAgIGxldCBsZWFkaW5nWmVyb0NvdW50OyAvLyA6dWludFxuICAgIGZvciAobGVhZGluZ1plcm9Db3VudCA9IDA7IGxlYWRpbmdaZXJvQ291bnQgPCB0aGlzLmJpdHNBdmFpbGFibGU7ICsrbGVhZGluZ1plcm9Db3VudCkge1xuICAgICAgaWYgKCh0aGlzLndvcmQgJiAoMHg4MDAwMDAwMCA+Pj4gbGVhZGluZ1plcm9Db3VudCkpICE9PSAwKSB7XG4gICAgICAgIC8vIHRoZSBmaXJzdCBiaXQgb2Ygd29ya2luZyB3b3JkIGlzIDFcbiAgICAgICAgdGhpcy53b3JkIDw8PSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHdlIGV4aGF1c3RlZCB3b3JkIGFuZCBzdGlsbCBoYXZlIG5vdCBmb3VuZCBhIDFcbiAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQgKyB0aGlzLnNraXBMWigpO1xuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBza2lwVUVHICgpIHtcbiAgICB0aGlzLnNraXBCaXRzKDEgKyB0aGlzLnNraXBMWigpKTtcbiAgfVxuXG4gIC8vICgpOnZvaWRcbiAgc2tpcEVHICgpIHtcbiAgICB0aGlzLnNraXBCaXRzKDEgKyB0aGlzLnNraXBMWigpKTtcbiAgfVxuXG4gIC8vICgpOnVpbnRcbiAgcmVhZFVFRyAoKSB7XG4gICAgbGV0IGNseiA9IHRoaXMuc2tpcExaKCk7IC8vIDp1aW50XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoY2x6ICsgMSkgLSAxO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIHJlYWRFRyAoKSB7XG4gICAgbGV0IHZhbHUgPSB0aGlzLnJlYWRVRUcoKTsgLy8gOmludFxuICAgIGlmICgweDAxICYgdmFsdSkge1xuICAgICAgLy8gdGhlIG51bWJlciBpcyBvZGQgaWYgdGhlIGxvdyBvcmRlciBiaXQgaXMgc2V0XG4gICAgICByZXR1cm4gKDEgKyB2YWx1KSA+Pj4gMTsgLy8gYWRkIDEgdG8gbWFrZSBpdCBldmVuLCBhbmQgZGl2aWRlIGJ5IDJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC0xICogKHZhbHUgPj4+IDEpOyAvLyBkaXZpZGUgYnkgdHdvIHRoZW4gbWFrZSBpdCBuZWdhdGl2ZVxuICAgIH1cbiAgfVxuXG4gIC8vIFNvbWUgY29udmVuaWVuY2UgZnVuY3Rpb25zXG4gIC8vIDpCb29sZWFuXG4gIHJlYWRCb29sZWFuICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygxKSA9PT0gMTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkVUJ5dGUgKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDgpO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIHJlYWRVU2hvcnQgKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDE2KTtcbiAgfVxuICAvLyAoKTppbnRcbiAgcmVhZFVJbnQgKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDMyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZHZhbmNlIHRoZSBFeHBHb2xvbWIgZGVjb2RlciBwYXN0IGEgc2NhbGluZyBsaXN0LiBUaGUgc2NhbGluZ1xuICAgKiBsaXN0IGlzIG9wdGlvbmFsbHkgdHJhbnNtaXR0ZWQgYXMgcGFydCBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlclxuICAgKiBzZXQgYW5kIGlzIG5vdCByZWxldmFudCB0byB0cmFuc211eGluZy5cbiAgICogQHBhcmFtIGNvdW50IHtudW1iZXJ9IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHNjYWxpbmcgbGlzdFxuICAgKiBAc2VlIFJlY29tbWVuZGF0aW9uIElUVS1UIEguMjY0LCBTZWN0aW9uIDcuMy4yLjEuMS4xXG4gICAqL1xuICBza2lwU2NhbGluZ0xpc3QgKGNvdW50KSB7XG4gICAgbGV0XG4gICAgICBsYXN0U2NhbGUgPSA4LFxuICAgICAgbmV4dFNjYWxlID0gOCxcbiAgICAgIGosXG4gICAgICBkZWx0YVNjYWxlO1xuICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICBpZiAobmV4dFNjYWxlICE9PSAwKSB7XG4gICAgICAgIGRlbHRhU2NhbGUgPSB0aGlzLnJlYWRFRygpO1xuICAgICAgICBuZXh0U2NhbGUgPSAobGFzdFNjYWxlICsgZGVsdGFTY2FsZSArIDI1NikgJSAyNTY7XG4gICAgICB9XG4gICAgICBsYXN0U2NhbGUgPSAobmV4dFNjYWxlID09PSAwKSA/IGxhc3RTY2FsZSA6IG5leHRTY2FsZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgYW5kIHJldHVybiBzb21lIGludGVyZXN0aW5nIHZpZGVvXG4gICAqIHByb3BlcnRpZXMuIEEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBpcyB0aGUgSDI2NCBtZXRhZGF0YSB0aGF0XG4gICAqIGRlc2NyaWJlcyB0aGUgcHJvcGVydGllcyBvZiB1cGNvbWluZyB2aWRlbyBmcmFtZXMuXG4gICAqIEBwYXJhbSBkYXRhIHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0XG4gICAqIEByZXR1cm4ge29iamVjdH0gYW4gb2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBwYXJzZWQgZnJvbSB0aGVcbiAgICogc2VxdWVuY2UgcGFyYW1ldGVyIHNldCwgaW5jbHVkaW5nIHRoZSBkaW1lbnNpb25zIG9mIHRoZVxuICAgKiBhc3NvY2lhdGVkIHZpZGVvIGZyYW1lcy5cbiAgICovXG4gIHJlYWRTUFMgKCkge1xuICAgIGxldFxuICAgICAgZnJhbWVDcm9wTGVmdE9mZnNldCA9IDAsXG4gICAgICBmcmFtZUNyb3BSaWdodE9mZnNldCA9IDAsXG4gICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSAwLFxuICAgICAgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gMCxcbiAgICAgIHByb2ZpbGVJZGMsIHByb2ZpbGVDb21wYXQsIGxldmVsSWRjLFxuICAgICAgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlLCBwaWNXaWR0aEluTWJzTWludXMxLFxuICAgICAgcGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSxcbiAgICAgIGZyYW1lTWJzT25seUZsYWcsXG4gICAgICBzY2FsaW5nTGlzdENvdW50LFxuICAgICAgaSxcbiAgICAgIHJlYWRVQnl0ZSA9IHRoaXMucmVhZFVCeXRlLmJpbmQodGhpcyksXG4gICAgICByZWFkQml0cyA9IHRoaXMucmVhZEJpdHMuYmluZCh0aGlzKSxcbiAgICAgIHJlYWRVRUcgPSB0aGlzLnJlYWRVRUcuYmluZCh0aGlzKSxcbiAgICAgIHJlYWRCb29sZWFuID0gdGhpcy5yZWFkQm9vbGVhbi5iaW5kKHRoaXMpLFxuICAgICAgc2tpcEJpdHMgPSB0aGlzLnNraXBCaXRzLmJpbmQodGhpcyksXG4gICAgICBza2lwRUcgPSB0aGlzLnNraXBFRy5iaW5kKHRoaXMpLFxuICAgICAgc2tpcFVFRyA9IHRoaXMuc2tpcFVFRy5iaW5kKHRoaXMpLFxuICAgICAgc2tpcFNjYWxpbmdMaXN0ID0gdGhpcy5za2lwU2NhbGluZ0xpc3QuYmluZCh0aGlzKTtcblxuICAgIHJlYWRVQnl0ZSgpO1xuICAgIHByb2ZpbGVJZGMgPSByZWFkVUJ5dGUoKTsgLy8gcHJvZmlsZV9pZGNcbiAgICBwcm9maWxlQ29tcGF0ID0gcmVhZEJpdHMoNSk7IC8vIGNvbnN0cmFpbnRfc2V0WzAtNF1fZmxhZywgdSg1KVxuICAgIHNraXBCaXRzKDMpOyAvLyByZXNlcnZlZF96ZXJvXzNiaXRzIHUoMyksXG4gICAgbGV2ZWxJZGMgPSByZWFkVUJ5dGUoKTsgLy8gbGV2ZWxfaWRjIHUoOClcbiAgICBza2lwVUVHKCk7IC8vIHNlcV9wYXJhbWV0ZXJfc2V0X2lkXG4gICAgLy8gc29tZSBwcm9maWxlcyBoYXZlIG1vcmUgb3B0aW9uYWwgZGF0YSB3ZSBkb24ndCBuZWVkXG4gICAgaWYgKHByb2ZpbGVJZGMgPT09IDEwMCB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSAxMTAgfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTIyIHx8XG4gICAgICAgIHByb2ZpbGVJZGMgPT09IDI0NCB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSA0NCB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSA4MyB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSA4NiB8fFxuICAgICAgICBwcm9maWxlSWRjID09PSAxMTggfHxcbiAgICAgICAgcHJvZmlsZUlkYyA9PT0gMTI4KSB7XG4gICAgICBsZXQgY2hyb21hRm9ybWF0SWRjID0gcmVhZFVFRygpO1xuICAgICAgaWYgKGNocm9tYUZvcm1hdElkYyA9PT0gMykge1xuICAgICAgICBza2lwQml0cygxKTtcbiAgICAgIH0gLy8gc2VwYXJhdGVfY29sb3VyX3BsYW5lX2ZsYWdcblxuICAgICAgc2tpcFVFRygpOyAvLyBiaXRfZGVwdGhfbHVtYV9taW51czhcbiAgICAgIHNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2Nocm9tYV9taW51czhcbiAgICAgIHNraXBCaXRzKDEpOyAvLyBxcHByaW1lX3lfemVyb190cmFuc2Zvcm1fYnlwYXNzX2ZsYWdcbiAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7IC8vIHNlcV9zY2FsaW5nX21hdHJpeF9wcmVzZW50X2ZsYWdcbiAgICAgICAgc2NhbGluZ0xpc3RDb3VudCA9IChjaHJvbWFGb3JtYXRJZGMgIT09IDMpID8gOCA6IDEyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2NhbGluZ0xpc3RDb3VudDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHsgLy8gc2VxX3NjYWxpbmdfbGlzdF9wcmVzZW50X2ZsYWdbIGkgXVxuICAgICAgICAgICAgaWYgKGkgPCA2KSB7XG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCgxNik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBza2lwU2NhbGluZ0xpc3QoNjQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBza2lwVUVHKCk7IC8vIGxvZzJfbWF4X2ZyYW1lX251bV9taW51czRcbiAgICBsZXQgcGljT3JkZXJDbnRUeXBlID0gcmVhZFVFRygpO1xuICAgIGlmIChwaWNPcmRlckNudFR5cGUgPT09IDApIHtcbiAgICAgIHJlYWRVRUcoKTsgLy8gbG9nMl9tYXhfcGljX29yZGVyX2NudF9sc2JfbWludXM0XG4gICAgfSBlbHNlIGlmIChwaWNPcmRlckNudFR5cGUgPT09IDEpIHtcbiAgICAgIHNraXBCaXRzKDEpOyAvLyBkZWx0YV9waWNfb3JkZXJfYWx3YXlzX3plcm9fZmxhZ1xuICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3Jfbm9uX3JlZl9waWNcbiAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX3RvcF90b19ib3R0b21fZmllbGRcbiAgICAgIG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZSA9IHJlYWRVRUcoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGU7IGkrKykge1xuICAgICAgICBza2lwRUcoKTtcbiAgICAgIH0gLy8gb2Zmc2V0X2Zvcl9yZWZfZnJhbWVbIGkgXVxuICAgIH1cbiAgICBza2lwVUVHKCk7IC8vIG1heF9udW1fcmVmX2ZyYW1lc1xuICAgIHNraXBCaXRzKDEpOyAvLyBnYXBzX2luX2ZyYW1lX251bV92YWx1ZV9hbGxvd2VkX2ZsYWdcbiAgICBwaWNXaWR0aEluTWJzTWludXMxID0gcmVhZFVFRygpO1xuICAgIHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgZnJhbWVNYnNPbmx5RmxhZyA9IHJlYWRCaXRzKDEpO1xuICAgIGlmIChmcmFtZU1ic09ubHlGbGFnID09PSAwKSB7XG4gICAgICBza2lwQml0cygxKTtcbiAgICB9IC8vIG1iX2FkYXB0aXZlX2ZyYW1lX2ZpZWxkX2ZsYWdcblxuICAgIHNraXBCaXRzKDEpOyAvLyBkaXJlY3RfOHg4X2luZmVyZW5jZV9mbGFnXG4gICAgaWYgKHJlYWRCb29sZWFuKCkpIHsgLy8gZnJhbWVfY3JvcHBpbmdfZmxhZ1xuICAgICAgZnJhbWVDcm9wTGVmdE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgIH1cbiAgICBsZXQgcGl4ZWxSYXRpbyA9IFsxLCAxXTtcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAvLyBhc3BlY3RfcmF0aW9faW5mb19wcmVzZW50X2ZsYWdcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW9JZGMgPSByZWFkVUJ5dGUoKTtcbiAgICAgICAgc3dpdGNoIChhc3BlY3RSYXRpb0lkYykge1xuICAgICAgICBjYXNlIDE6IHBpeGVsUmF0aW8gPSBbMSwgMV07IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IHBpeGVsUmF0aW8gPSBbMTIsIDExXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogcGl4ZWxSYXRpbyA9IFsxMCwgMTFdOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBwaXhlbFJhdGlvID0gWzE2LCAxMV07IGJyZWFrO1xuICAgICAgICBjYXNlIDU6IHBpeGVsUmF0aW8gPSBbNDAsIDMzXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNjogcGl4ZWxSYXRpbyA9IFsyNCwgMTFdOyBicmVhaztcbiAgICAgICAgY2FzZSA3OiBwaXhlbFJhdGlvID0gWzIwLCAxMV07IGJyZWFrO1xuICAgICAgICBjYXNlIDg6IHBpeGVsUmF0aW8gPSBbMzIsIDExXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgOTogcGl4ZWxSYXRpbyA9IFs4MCwgMzNdOyBicmVhaztcbiAgICAgICAgY2FzZSAxMDogcGl4ZWxSYXRpbyA9IFsxOCwgMTFdOyBicmVhaztcbiAgICAgICAgY2FzZSAxMTogcGl4ZWxSYXRpbyA9IFsxNSwgMTFdOyBicmVhaztcbiAgICAgICAgY2FzZSAxMjogcGl4ZWxSYXRpbyA9IFs2NCwgMzNdOyBicmVhaztcbiAgICAgICAgY2FzZSAxMzogcGl4ZWxSYXRpbyA9IFsxNjAsIDk5XTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMTQ6IHBpeGVsUmF0aW8gPSBbNCwgM107IGJyZWFrO1xuICAgICAgICBjYXNlIDE1OiBwaXhlbFJhdGlvID0gWzMsIDJdOyBicmVhaztcbiAgICAgICAgY2FzZSAxNjogcGl4ZWxSYXRpbyA9IFsyLCAxXTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjU1OiB7XG4gICAgICAgICAgcGl4ZWxSYXRpbyA9IFtyZWFkVUJ5dGUoKSA8PCA4IHwgcmVhZFVCeXRlKCksIHJlYWRVQnl0ZSgpIDw8IDggfCByZWFkVUJ5dGUoKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IE1hdGguY2VpbCgoKChwaWNXaWR0aEluTWJzTWludXMxICsgMSkgKiAxNikgLSBmcmFtZUNyb3BMZWZ0T2Zmc2V0ICogMiAtIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ICogMikpLFxuICAgICAgaGVpZ2h0OiAoKDIgLSBmcmFtZU1ic09ubHlGbGFnKSAqIChwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxICsgMSkgKiAxNikgLSAoKGZyYW1lTWJzT25seUZsYWcgPyAyIDogNCkgKiAoZnJhbWVDcm9wVG9wT2Zmc2V0ICsgZnJhbWVDcm9wQm90dG9tT2Zmc2V0KSksXG4gICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvXG4gICAgfTtcbiAgfVxuXG4gIHJlYWRTbGljZVR5cGUgKCkge1xuICAgIC8vIHNraXAgTkFMdSB0eXBlXG4gICAgdGhpcy5yZWFkVUJ5dGUoKTtcbiAgICAvLyBkaXNjYXJkIGZpcnN0X21iX2luX3NsaWNlXG4gICAgdGhpcy5yZWFkVUVHKCk7XG4gICAgLy8gcmV0dXJuIHNsaWNlX3R5cGVcbiAgICByZXR1cm4gdGhpcy5yZWFkVUVHKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXhwR29sb21iO1xuIiwiLyoqXG4gKiBJRDMgcGFyc2VyXG4gKi9cbmNsYXNzIElEMyB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYW4gSUQzIGhlYWRlciBjYW4gYmUgZm91bmQgYXQgb2Zmc2V0IGluIGRhdGFcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgYW4gSUQzIGhlYWRlciBpcyBmb3VuZFxuICAgKi9cbiAgc3RhdGljIGlzSGVhZGVyIChkYXRhLCBvZmZzZXQpIHtcbiAgICAvKlxuICAgICogaHR0cDovL2lkMy5vcmcvaWQzdjIuMy4wXG4gICAgKiBbMF0gICAgID0gJ0knXG4gICAgKiBbMV0gICAgID0gJ0QnXG4gICAgKiBbMl0gICAgID0gJzMnXG4gICAgKiBbMyw0XSAgID0ge1ZlcnNpb259XG4gICAgKiBbNV0gICAgID0ge0ZsYWdzfVxuICAgICogWzYtOV0gICA9IHtJRDMgU2l6ZX1cbiAgICAqXG4gICAgKiBBbiBJRDN2MiB0YWcgY2FuIGJlIGRldGVjdGVkIHdpdGggdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxuICAgICogICQ0OSA0NCAzMyB5eSB5eSB4eCB6eiB6eiB6eiB6elxuICAgICogV2hlcmUgeXkgaXMgbGVzcyB0aGFuICRGRiwgeHggaXMgdGhlICdmbGFncycgYnl0ZSBhbmQgenogaXMgbGVzcyB0aGFuICQ4MFxuICAgICovXG4gICAgaWYgKG9mZnNldCArIDEwIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgICAvLyBsb29rIGZvciAnSUQzJyBpZGVudGlmaWVyXG4gICAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweDQ5ICYmIGRhdGFbb2Zmc2V0ICsgMV0gPT09IDB4NDQgJiYgZGF0YVtvZmZzZXQgKyAyXSA9PT0gMHgzMykge1xuICAgICAgICAvLyBjaGVjayB2ZXJzaW9uIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyAzXSA8IDB4RkYgJiYgZGF0YVtvZmZzZXQgKyA0XSA8IDB4RkYpIHtcbiAgICAgICAgICAvLyBjaGVjayBzaXplIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICAgIGlmIChkYXRhW29mZnNldCArIDZdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDddIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDhdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDldIDwgMHg4MCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgZm9vdGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2ggaW5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBhbiBJRDMgZm9vdGVyIGlzIGZvdW5kXG4gICAqL1xuICBzdGF0aWMgaXNGb290ZXIgKGRhdGEsIG9mZnNldCkge1xuICAgIC8qXG4gICAgKiBUaGUgZm9vdGVyIGlzIGEgY29weSBvZiB0aGUgaGVhZGVyLCBidXQgd2l0aCBhIGRpZmZlcmVudCBpZGVudGlmaWVyXG4gICAgKi9cbiAgICBpZiAob2Zmc2V0ICsgMTAgPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vIGxvb2sgZm9yICczREknIGlkZW50aWZpZXJcbiAgICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4MzMgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg0NCAmJiBkYXRhW29mZnNldCArIDJdID09PSAweDQ5KSB7XG4gICAgICAgIC8vIGNoZWNrIHZlcnNpb24gaXMgd2l0aGluIHJhbmdlXG4gICAgICAgIGlmIChkYXRhW29mZnNldCArIDNdIDwgMHhGRiAmJiBkYXRhW29mZnNldCArIDRdIDwgMHhGRikge1xuICAgICAgICAgIC8vIGNoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXG4gICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgNl0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgN10gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOF0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOV0gPCAweDgwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbnkgYWRqYWNlbnQgSUQzIHRhZ3MgZm91bmQgaW4gZGF0YSBzdGFydGluZyBhdCBvZmZzZXQsIGFzIG9uZSBibG9jayBvZiBkYXRhXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaCBpblxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAgICogQHJldHVybiB7VWludDhBcnJheX0gLSBUaGUgYmxvY2sgb2YgZGF0YSBjb250YWluaW5nIGFueSBJRDMgdGFncyBmb3VuZFxuICAgKi9cbiAgc3RhdGljIGdldElEM0RhdGEgKGRhdGEsIG9mZnNldCkge1xuICAgIGNvbnN0IGZyb250ID0gb2Zmc2V0O1xuICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgd2hpbGUgKElEMy5pc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAvLyBJRDMgaGVhZGVyIGlzIDEwIGJ5dGVzXG4gICAgICBsZW5ndGggKz0gMTA7XG5cbiAgICAgIGNvbnN0IHNpemUgPSBJRDMuX3JlYWRTaXplKGRhdGEsIG9mZnNldCArIDYpO1xuICAgICAgbGVuZ3RoICs9IHNpemU7XG5cbiAgICAgIGlmIChJRDMuaXNGb290ZXIoZGF0YSwgb2Zmc2V0ICsgMTApKSB7XG4gICAgICAgIC8vIElEMyBmb290ZXIgaXMgMTAgYnl0ZXNcbiAgICAgICAgbGVuZ3RoICs9IDEwO1xuICAgICAgfVxuXG4gICAgICBvZmZzZXQgKz0gbGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZGF0YS5zdWJhcnJheShmcm9udCwgZnJvbnQgKyBsZW5ndGgpO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBzdGF0aWMgX3JlYWRTaXplIChkYXRhLCBvZmZzZXQpIHtcbiAgICBsZXQgc2l6ZSA9IDA7XG4gICAgc2l6ZSA9ICgoZGF0YVtvZmZzZXRdICYgMHg3ZikgPDwgMjEpO1xuICAgIHNpemUgfD0gKChkYXRhW29mZnNldCArIDFdICYgMHg3ZikgPDwgMTQpO1xuICAgIHNpemUgfD0gKChkYXRhW29mZnNldCArIDJdICYgMHg3ZikgPDwgNyk7XG4gICAgc2l6ZSB8PSAoZGF0YVtvZmZzZXQgKyAzXSAmIDB4N2YpO1xuICAgIHJldHVybiBzaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaGVzIGZvciB0aGUgRWxlbWVudGFyeSBTdHJlYW0gdGltZXN0YW1wIGZvdW5kIGluIHRoZSBJRDMgZGF0YSBjaHVua1xuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGEgLSBCbG9jayBvZiBkYXRhIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgSUQzIHRhZ3NcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSB0aW1lc3RhbXBcbiAgICovXG4gIHN0YXRpYyBnZXRUaW1lU3RhbXAgKGRhdGEpIHtcbiAgICBjb25zdCBmcmFtZXMgPSBJRDMuZ2V0SUQzRnJhbWVzKGRhdGEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBmcmFtZSA9IGZyYW1lc1tpXTtcbiAgICAgIGlmIChJRDMuaXNUaW1lU3RhbXBGcmFtZShmcmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIElEMy5fcmVhZFRpbWVTdGFtcChmcmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIElEMyBmcmFtZSBpcyBhbiBFbGVtZW50YXJ5IFN0cmVhbSB0aW1lc3RhbXAgZnJhbWVcbiAgICogQHBhcmFtIHtJRDMgZnJhbWV9IGZyYW1lXG4gICAqL1xuICBzdGF0aWMgaXNUaW1lU3RhbXBGcmFtZSAoZnJhbWUpIHtcbiAgICByZXR1cm4gKGZyYW1lICYmIGZyYW1lLmtleSA9PT0gJ1BSSVYnICYmIGZyYW1lLmluZm8gPT09ICdjb20uYXBwbGUuc3RyZWFtaW5nLnRyYW5zcG9ydFN0cmVhbVRpbWVzdGFtcCcpO1xuICB9XG5cbiAgc3RhdGljIF9nZXRGcmFtZURhdGEgKGRhdGEpIHtcbiAgICAvKlxuICAgIEZyYW1lIElEICAgICAgICR4eCB4eCB4eCB4eCAoZm91ciBjaGFyYWN0ZXJzKVxuICAgIFNpemUgICAgICAgICAgICR4eCB4eCB4eCB4eFxuICAgIEZsYWdzICAgICAgICAgICR4eCB4eFxuICAgICovXG4gICAgY29uc3QgdHlwZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSwgZGF0YVszXSk7XG4gICAgY29uc3Qgc2l6ZSA9IElEMy5fcmVhZFNpemUoZGF0YSwgNCk7XG5cbiAgICAvLyBza2lwIGZyYW1lIGlkLCBzaXplLCBhbmQgZmxhZ3NcbiAgICBsZXQgb2Zmc2V0ID0gMTA7XG5cbiAgICByZXR1cm4geyB0eXBlLCBzaXplLCBkYXRhOiBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgc2l6ZSkgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIElEMyBmcmFtZXMgZm91bmQgaW4gYWxsIHRoZSBJRDMgdGFncyBpbiB0aGUgaWQzRGF0YVxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlkM0RhdGEgLSBUaGUgSUQzIGRhdGEgY29udGFpbmluZyBvbmUgb3IgbW9yZSBJRDMgdGFnc1xuICAgKiBAcmV0dXJuIHtJRDMgZnJhbWVbXX0gLSBBcnJheSBvZiBJRDMgZnJhbWUgb2JqZWN0c1xuICAgKi9cbiAgc3RhdGljIGdldElEM0ZyYW1lcyAoaWQzRGF0YSkge1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IGZyYW1lcyA9IFtdO1xuXG4gICAgd2hpbGUgKElEMy5pc0hlYWRlcihpZDNEYXRhLCBvZmZzZXQpKSB7XG4gICAgICBjb25zdCBzaXplID0gSUQzLl9yZWFkU2l6ZShpZDNEYXRhLCBvZmZzZXQgKyA2KTtcbiAgICAgIC8vIHNraXAgcGFzdCBJRDMgaGVhZGVyXG4gICAgICBvZmZzZXQgKz0gMTA7XG4gICAgICBjb25zdCBlbmQgPSBvZmZzZXQgKyBzaXplO1xuICAgICAgLy8gbG9vcCB0aHJvdWdoIGZyYW1lcyBpbiB0aGUgSUQzIHRhZ1xuICAgICAgd2hpbGUgKG9mZnNldCArIDggPCBlbmQpIHtcbiAgICAgICAgY29uc3QgZnJhbWVEYXRhID0gSUQzLl9nZXRGcmFtZURhdGEoaWQzRGF0YS5zdWJhcnJheShvZmZzZXQpKTtcbiAgICAgICAgY29uc3QgZnJhbWUgPSBJRDMuX2RlY29kZUZyYW1lKGZyYW1lRGF0YSk7XG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgIGZyYW1lcy5wdXNoKGZyYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNraXAgZnJhbWUgaGVhZGVyIGFuZCBmcmFtZSBkYXRhXG4gICAgICAgIG9mZnNldCArPSBmcmFtZURhdGEuc2l6ZSArIDEwO1xuICAgICAgfVxuXG4gICAgICBpZiAoSUQzLmlzRm9vdGVyKGlkM0RhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgb2Zmc2V0ICs9IDEwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmcmFtZXM7XG4gIH1cblxuICBzdGF0aWMgX2RlY29kZUZyYW1lIChmcmFtZSkge1xuICAgIGlmIChmcmFtZS50eXBlID09PSAnUFJJVicpIHtcbiAgICAgIHJldHVybiBJRDMuX2RlY29kZVByaXZGcmFtZShmcmFtZSk7XG4gICAgfSBlbHNlIGlmIChmcmFtZS50eXBlWzBdID09PSAnVCcpIHtcbiAgICAgIHJldHVybiBJRDMuX2RlY29kZVRleHRGcmFtZShmcmFtZSk7XG4gICAgfSBlbHNlIGlmIChmcmFtZS50eXBlWzBdID09PSAnVycpIHtcbiAgICAgIHJldHVybiBJRDMuX2RlY29kZVVSTEZyYW1lKGZyYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgc3RhdGljIF9yZWFkVGltZVN0YW1wICh0aW1lU3RhbXBGcmFtZSkge1xuICAgIGlmICh0aW1lU3RhbXBGcmFtZS5kYXRhLmJ5dGVMZW5ndGggPT09IDgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0aW1lU3RhbXBGcmFtZS5kYXRhKTtcbiAgICAgIC8vIHRpbWVzdGFtcCBpcyAzMyBiaXQgZXhwcmVzc2VkIGFzIGEgYmlnLWVuZGlhbiBlaWdodC1vY3RldCBudW1iZXIsXG4gICAgICAvLyB3aXRoIHRoZSB1cHBlciAzMSBiaXRzIHNldCB0byB6ZXJvLlxuICAgICAgY29uc3QgcHRzMzNCaXQgPSBkYXRhWzNdICYgMHgxO1xuICAgICAgbGV0IHRpbWVzdGFtcCA9IChkYXRhWzRdIDw8IDIzKSArXG4gICAgICAgICAgICAgICAgICAgICAgKGRhdGFbNV0gPDwgMTUpICtcbiAgICAgICAgICAgICAgICAgICAgICAoZGF0YVs2XSA8PCA3KSArXG4gICAgICAgICAgICAgICAgICAgICAgIGRhdGFbN107XG4gICAgICB0aW1lc3RhbXAgLz0gNDU7XG5cbiAgICAgIGlmIChwdHMzM0JpdCkge1xuICAgICAgICB0aW1lc3RhbXAgKz0gNDc3MjE4NTguODQ7XG4gICAgICB9IC8vIDJeMzIgLyA5MFxuXG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCh0aW1lc3RhbXApO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBzdGF0aWMgX2RlY29kZVByaXZGcmFtZSAoZnJhbWUpIHtcbiAgICAvKlxuICAgIEZvcm1hdDogPHRleHQgc3RyaW5nPlxcMDxiaW5hcnkgZGF0YT5cbiAgICAqL1xuICAgIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBvd25lciA9IElEMy5fdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YSwgdHJ1ZSk7XG4gICAgY29uc3QgcHJpdmF0ZURhdGEgPSBuZXcgVWludDhBcnJheShmcmFtZS5kYXRhLnN1YmFycmF5KG93bmVyLmxlbmd0aCArIDEpKTtcblxuICAgIHJldHVybiB7IGtleTogZnJhbWUudHlwZSwgaW5mbzogb3duZXIsIGRhdGE6IHByaXZhdGVEYXRhLmJ1ZmZlciB9O1xuICB9XG5cbiAgc3RhdGljIF9kZWNvZGVUZXh0RnJhbWUgKGZyYW1lKSB7XG4gICAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChmcmFtZS50eXBlID09PSAnVFhYWCcpIHtcbiAgICAgIC8qXG4gICAgICBGb3JtYXQ6XG4gICAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgICAgWzEtP10gPSB7RGVzY3JpcHRpb259XFwwe1ZhbHVlfVxuICAgICAgKi9cbiAgICAgIGxldCBpbmRleCA9IDE7XG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IElEMy5fdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuXG4gICAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgICAgY29uc3QgdmFsdWUgPSBJRDMuX3V0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcblxuICAgICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBpbmZvOiBkZXNjcmlwdGlvbiwgZGF0YTogdmFsdWUgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLypcbiAgICAgIEZvcm1hdDpcbiAgICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gICAgICBbMS0/XSA9IHtWYWx1ZX1cbiAgICAgICovXG4gICAgICBjb25zdCB0ZXh0ID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KDEpKTtcbiAgICAgIHJldHVybiB7IGtleTogZnJhbWUudHlwZSwgZGF0YTogdGV4dCB9O1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBfZGVjb2RlVVJMRnJhbWUgKGZyYW1lKSB7XG4gICAgaWYgKGZyYW1lLnR5cGUgPT09ICdXWFhYJykge1xuICAgICAgLypcbiAgICAgIEZvcm1hdDpcbiAgICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gICAgICBbMS0/XSA9IHtEZXNjcmlwdGlvbn1cXDB7VVJMfVxuICAgICAgKi9cbiAgICAgIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBsZXQgaW5kZXggPSAxO1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBJRDMuX3V0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcblxuICAgICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcbiAgICAgIGNvbnN0IHZhbHVlID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XG5cbiAgICAgIHJldHVybiB7IGtleTogZnJhbWUudHlwZSwgaW5mbzogZGVzY3JpcHRpb24sIGRhdGE6IHZhbHVlIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qXG4gICAgICBGb3JtYXQ6XG4gICAgICBbMC0/XSA9IHtVUkx9XG4gICAgICAqL1xuICAgICAgY29uc3QgdXJsID0gSUQzLl91dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhKTtcbiAgICAgIHJldHVybiB7IGtleTogZnJhbWUudHlwZSwgZGF0YTogdXJsIH07XG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84OTM2OTg0L3VpbnQ4YXJyYXktdG8tc3RyaW5nLWluLWphdmFzY3JpcHQvMjIzNzMxOTdcbiAgLy8gaHR0cDovL3d3dy5vbmljb3MuY29tL3N0YWZmL2l6L2FtdXNlL2phdmFzY3JpcHQvZXhwZXJ0L3V0Zi50eHRcbiAgLyogdXRmLmpzIC0gVVRGLTggPD0+IFVURi0xNiBjb252ZXJ0aW9uXG4gICAqXG4gICAqIENvcHlyaWdodCAoQykgMTk5OSBNYXNhbmFvIEl6dW1vIDxpekBvbmljb3MuY28uanA+XG4gICAqIFZlcnNpb246IDEuMFxuICAgKiBMYXN0TW9kaWZpZWQ6IERlYyAyNSAxOTk5XG4gICAqIFRoaXMgbGlicmFyeSBpcyBmcmVlLiAgWW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdC5cbiAgICovXG4gIHN0YXRpYyBfdXRmOEFycmF5VG9TdHIgKGFycmF5LCBleGl0T25OdWxsID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgbGV0IGM7XG4gICAgbGV0IGNoYXIyO1xuICAgIGxldCBjaGFyMztcbiAgICBsZXQgb3V0ID0gJyc7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBjID0gYXJyYXlbaSsrXTtcbiAgICAgIGlmIChjID09PSAweDAwICYmIGV4aXRPbk51bGwpIHtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gMHgwMCB8fCBjID09PSAweDAzKSB7XG4gICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgMyAoRU5EX09GX1RFWFQpIG9yIDAgKE5VTEwpIHRoZW4gc2tpcCBpdFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoYyA+PiA0KSB7XG4gICAgICBjYXNlIDA6IGNhc2UgMTogY2FzZSAyOiBjYXNlIDM6IGNhc2UgNDogY2FzZSA1OiBjYXNlIDY6IGNhc2UgNzpcbiAgICAgICAgLy8gMHh4eHh4eHhcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjogY2FzZSAxMzpcbiAgICAgICAgLy8gMTEweCB4eHh4ICAgMTB4eCB4eHh4XG4gICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMHgxRikgPDwgNikgfCAoY2hhcjIgJiAweDNGKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxNDpcbiAgICAgICAgLy8gMTExMCB4eHh4ICAxMHh4IHh4eHggIDEweHggeHh4eFxuICAgICAgICBjaGFyMiA9IGFycmF5W2krK107XG4gICAgICAgIGNoYXIzID0gYXJyYXlbaSsrXTtcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMHgwRikgPDwgMTIpIHxcbiAgICAgICAgICAgICAgICAgICAgKChjaGFyMiAmIDB4M0YpIDw8IDYpIHxcbiAgICAgICAgICAgICAgICAgICAgKChjaGFyMyAmIDB4M0YpIDw8IDApKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG59XG5cbmNvbnN0IHV0ZjhBcnJheVRvU3RyID0gSUQzLl91dGY4QXJyYXlUb1N0cjtcblxuZXhwb3J0IGRlZmF1bHQgSUQzO1xuXG5leHBvcnQgeyB1dGY4QXJyYXlUb1N0ciB9O1xuIiwiLyoqXG4gKiBNUDMgZGVtdXhlclxuICovXG5pbXBvcnQgSUQzIGZyb20gJy4uL2RlbXV4L2lkMyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IE1wZWdBdWRpbyBmcm9tICcuL21wZWdhdWRpbyc7XG5cbmNsYXNzIE1QM0RlbXV4ZXIge1xuICBjb25zdHJ1Y3RvciAob2JzZXJ2ZXIsIHJlbXV4ZXIsIGNvbmZpZykge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnJlbXV4ZXIgPSByZW11eGVyO1xuICB9XG5cbiAgcmVzZXRJbml0U2VnbWVudCAoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHsgY29udGFpbmVyOiAnYXVkaW8vbXBlZycsIHR5cGU6ICdhdWRpbycsIGlkOiAtMSwgc2VxdWVuY2VOdW1iZXI6IDAsIGlzQUFDOiBmYWxzZSwgc2FtcGxlczogW10sIGxlbjogMCwgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYywgZHVyYXRpb246IGR1cmF0aW9uLCBpbnB1dFRpbWVTY2FsZTogOTAwMDAgfTtcbiAgfVxuXG4gIHJlc2V0VGltZVN0YW1wICgpIHtcbiAgfVxuXG4gIHN0YXRpYyBwcm9iZSAoZGF0YSkge1xuICAgIC8vIGNoZWNrIGlmIGRhdGEgY29udGFpbnMgSUQzIHRpbWVzdGFtcCBhbmQgTVBFRyBzeW5jIHdvcmRcbiAgICBsZXQgb2Zmc2V0LCBsZW5ndGg7XG4gICAgbGV0IGlkM0RhdGEgPSBJRDMuZ2V0SUQzRGF0YShkYXRhLCAwKTtcbiAgICBpZiAoaWQzRGF0YSAmJiBJRDMuZ2V0VGltZVN0YW1wKGlkM0RhdGEpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIExvb2sgZm9yIE1QRUcgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExWCBYWVpYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMSBhbmQgWSBvciBaIHNob3VsZCBiZSAxXG4gICAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxuICAgICAgLy8gTW9yZSBpbmZvIGh0dHA6Ly93d3cubXAzLXRlY2gub3JnL3Byb2dyYW1tZXIvZnJhbWVfaGVhZGVyLmh0bWxcbiAgICAgIGZvciAob2Zmc2V0ID0gaWQzRGF0YS5sZW5ndGgsIGxlbmd0aCA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gMSwgb2Zmc2V0ICsgMTAwKTsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xuICAgICAgICBpZiAoTXBlZ0F1ZGlvLnByb2JlKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdNUEVHIEF1ZGlvIHN5bmMgd29yZCBmb3VuZCAhJyk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICBhcHBlbmQgKGRhdGEsIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIGxldCBpZDNEYXRhID0gSUQzLmdldElEM0RhdGEoZGF0YSwgMCk7XG4gICAgbGV0IHRpbWVzdGFtcCA9IElEMy5nZXRUaW1lU3RhbXAoaWQzRGF0YSk7XG4gICAgbGV0IHB0cyA9IHRpbWVzdGFtcCA/IDkwICogdGltZXN0YW1wIDogdGltZU9mZnNldCAqIDkwMDAwO1xuICAgIGxldCBvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aDtcbiAgICBsZXQgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgbGV0IGZyYW1lSW5kZXggPSAwLCBzdGFtcCA9IDA7XG4gICAgbGV0IHRyYWNrID0gdGhpcy5fYXVkaW9UcmFjaztcblxuICAgIGxldCBpZDNTYW1wbGVzID0gW3sgcHRzOiBwdHMsIGR0czogcHRzLCBkYXRhOiBpZDNEYXRhIH1dO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgaWYgKE1wZWdBdWRpby5pc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGxldCBmcmFtZSA9IE1wZWdBdWRpby5hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpO1xuICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgIHN0YW1wID0gZnJhbWUuc2FtcGxlLnB0cztcbiAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnVW5hYmxlIHRvIHBhcnNlIE1wZWcgYXVkaW8gZnJhbWUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChJRDMuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBpZDNEYXRhID0gSUQzLmdldElEM0RhdGEoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgaWQzU2FtcGxlcy5wdXNoKHsgcHRzOiBzdGFtcCwgZHRzOiBzdGFtcCwgZGF0YTogaWQzRGF0YSB9KTtcbiAgICAgICAgb2Zmc2V0ICs9IGlkM0RhdGEubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBmb3VuZCwga2VlcCBsb29raW5nXG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVtdXhlci5yZW11eCh0cmFjayxcbiAgICAgIHsgc2FtcGxlczogW10gfSxcbiAgICAgIHsgc2FtcGxlczogaWQzU2FtcGxlcywgaW5wdXRUaW1lU2NhbGU6IDkwMDAwIH0sXG4gICAgICB7IHNhbXBsZXM6IFtdIH0sXG4gICAgICB0aW1lT2Zmc2V0LFxuICAgICAgY29udGlndW91cyxcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNUDNEZW11eGVyO1xuIiwiLyoqXG4gKiBNUDQgZGVtdXhlclxuICovXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5cbmNvbnN0IFVJTlQzMl9NQVggPSBNYXRoLnBvdygyLCAzMikgLSAxO1xuXG5jbGFzcyBNUDREZW11eGVyIHtcbiAgY29uc3RydWN0b3IgKG9ic2VydmVyLCByZW11eGVyKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XG4gIH1cblxuICByZXNldFRpbWVTdGFtcCAoaW5pdFBUUykge1xuICAgIHRoaXMuaW5pdFBUUyA9IGluaXRQVFM7XG4gIH1cblxuICByZXNldEluaXRTZWdtZW50IChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcbiAgICAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gICAgaWYgKGluaXRTZWdtZW50ICYmIGluaXRTZWdtZW50LmJ5dGVMZW5ndGgpIHtcbiAgICAgIGNvbnN0IGluaXREYXRhID0gdGhpcy5pbml0RGF0YSA9IE1QNERlbXV4ZXIucGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCk7XG5cbiAgICAgIC8vIGRlZmF1bHQgYXVkaW8gY29kZWMgaWYgbm90aGluZyBzcGVjaWZpZWRcbiAgICAgIC8vIFRPRE8gOiBleHRyYWN0IHRoYXQgZnJvbSBpbml0c2VnbWVudFxuICAgICAgaWYgKGF1ZGlvQ29kZWMgPT0gbnVsbCkge1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICB9XG5cbiAgICAgIGlmICh2aWRlb0NvZGVjID09IG51bGwpIHtcbiAgICAgICAgdmlkZW9Db2RlYyA9ICdhdmMxLjQyZTAxZSc7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRyYWNrcyA9IHt9O1xuICAgICAgaWYgKGluaXREYXRhLmF1ZGlvICYmIGluaXREYXRhLnZpZGVvKSB7XG4gICAgICAgIHRyYWNrcy5hdWRpb3ZpZGVvID0geyBjb250YWluZXI6ICd2aWRlby9tcDQnLCBjb2RlYzogYXVkaW9Db2RlYyArICcsJyArIHZpZGVvQ29kZWMsIGluaXRTZWdtZW50OiBkdXJhdGlvbiA/IGluaXRTZWdtZW50IDogbnVsbCB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGluaXREYXRhLmF1ZGlvKSB7XG4gICAgICAgICAgdHJhY2tzLmF1ZGlvID0geyBjb250YWluZXI6ICdhdWRpby9tcDQnLCBjb2RlYzogYXVkaW9Db2RlYywgaW5pdFNlZ21lbnQ6IGR1cmF0aW9uID8gaW5pdFNlZ21lbnQgOiBudWxsIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5pdERhdGEudmlkZW8pIHtcbiAgICAgICAgICB0cmFja3MudmlkZW8gPSB7IGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsIGNvZGVjOiB2aWRlb0NvZGVjLCBpbml0U2VnbWVudDogZHVyYXRpb24gPyBpbml0U2VnbWVudCA6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIHsgdHJhY2tzIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXVkaW9Db2RlYykge1xuICAgICAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgICAgfVxuXG4gICAgICBpZiAodmlkZW9Db2RlYykge1xuICAgICAgICB0aGlzLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwcm9iZSAoZGF0YSkge1xuICAgIC8vIGVuc3VyZSB3ZSBmaW5kIGEgbW9vZiBib3ggaW4gdGhlIGZpcnN0IDE2IGtCXG4gICAgcmV0dXJuIE1QNERlbXV4ZXIuZmluZEJveCh7IGRhdGE6IGRhdGEsIHN0YXJ0OiAwLCBlbmQ6IE1hdGgubWluKGRhdGEubGVuZ3RoLCAxNjM4NCkgfSwgWydtb29mJ10pLmxlbmd0aCA+IDA7XG4gIH1cblxuICBzdGF0aWMgYmluMnN0ciAoYnVmZmVyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnVmZmVyKTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkVWludDE2IChidWZmZXIsIG9mZnNldCkge1xuICAgIGlmIChidWZmZXIuZGF0YSkge1xuICAgICAgb2Zmc2V0ICs9IGJ1ZmZlci5zdGFydDtcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5kYXRhO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbCA9IGJ1ZmZlcltvZmZzZXRdIDw8IDggfFxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAxXTtcblxuICAgIHJldHVybiB2YWwgPCAwID8gNjU1MzYgKyB2YWwgOiB2YWw7XG4gIH1cblxuICBzdGF0aWMgcmVhZFVpbnQzMiAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICBpZiAoYnVmZmVyLmRhdGEpIHtcbiAgICAgIG9mZnNldCArPSBidWZmZXIuc3RhcnQ7XG4gICAgICBidWZmZXIgPSBidWZmZXIuZGF0YTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWwgPSBidWZmZXJbb2Zmc2V0XSA8PCAyNCB8XG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIDFdIDw8IDE2IHxcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgMl0gPDwgOCB8XG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIDNdO1xuICAgIHJldHVybiB2YWwgPCAwID8gNDI5NDk2NzI5NiArIHZhbCA6IHZhbDtcbiAgfVxuXG4gIHN0YXRpYyB3cml0ZVVpbnQzMiAoYnVmZmVyLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgaWYgKGJ1ZmZlci5kYXRhKSB7XG4gICAgICBvZmZzZXQgKz0gYnVmZmVyLnN0YXJ0O1xuICAgICAgYnVmZmVyID0gYnVmZmVyLmRhdGE7XG4gICAgfVxuICAgIGJ1ZmZlcltvZmZzZXRdID0gdmFsdWUgPj4gMjQ7XG4gICAgYnVmZmVyW29mZnNldCArIDFdID0gKHZhbHVlID4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyW29mZnNldCArIDJdID0gKHZhbHVlID4+IDgpICYgMHhmZjtcbiAgICBidWZmZXJbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDB4ZmY7XG4gIH1cblxuICAvLyBGaW5kIHRoZSBkYXRhIGZvciBhIGJveCBzcGVjaWZpZWQgYnkgaXRzIHBhdGhcbiAgc3RhdGljIGZpbmRCb3ggKGRhdGEsIHBhdGgpIHtcbiAgICBsZXQgcmVzdWx0cyA9IFtdLFxuICAgICAgaSwgc2l6ZSwgdHlwZSwgZW5kLCBzdWJyZXN1bHRzLCBzdGFydCwgZW5kYm94O1xuXG4gICAgaWYgKGRhdGEuZGF0YSkge1xuICAgICAgc3RhcnQgPSBkYXRhLnN0YXJ0O1xuICAgICAgZW5kID0gZGF0YS5lbmQ7XG4gICAgICBkYXRhID0gZGF0YS5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBlbmQgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKCFwYXRoLmxlbmd0aCkge1xuICAgICAgLy8gc2hvcnQtY2lyY3VpdCB0aGUgc2VhcmNoIGZvciBlbXB0eSBwYXRoc1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7KSB7XG4gICAgICBzaXplID0gTVA0RGVtdXhlci5yZWFkVWludDMyKGRhdGEsIGkpO1xuICAgICAgdHlwZSA9IE1QNERlbXV4ZXIuYmluMnN0cihkYXRhLnN1YmFycmF5KGkgKyA0LCBpICsgOCkpO1xuICAgICAgZW5kYm94ID0gc2l6ZSA+IDEgPyBpICsgc2l6ZSA6IGVuZDtcblxuICAgICAgaWYgKHR5cGUgPT09IHBhdGhbMF0pIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyB0aGUgZW5kIG9mIHRoZSBwYXRoIGFuZCB3ZSd2ZSBmb3VuZCB0aGUgYm94IHdlIHdlcmVcbiAgICAgICAgICAvLyBsb29raW5nIGZvclxuICAgICAgICAgIHJlc3VsdHMucHVzaCh7IGRhdGE6IGRhdGEsIHN0YXJ0OiBpICsgOCwgZW5kOiBlbmRib3ggfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciB0aGUgbmV4dCBib3ggYWxvbmcgdGhlIHBhdGhcbiAgICAgICAgICBzdWJyZXN1bHRzID0gTVA0RGVtdXhlci5maW5kQm94KHsgZGF0YTogZGF0YSwgc3RhcnQ6IGkgKyA4LCBlbmQ6IGVuZGJveCB9LCBwYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgICBpZiAoc3VicmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdChzdWJyZXN1bHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkgPSBlbmRib3g7XG4gICAgfVxuXG4gICAgLy8gd2UndmUgZmluaXNoZWQgc2VhcmNoaW5nIGFsbCBvZiBkYXRhXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VTZWdtZW50SW5kZXggKGluaXRTZWdtZW50KSB7XG4gICAgY29uc3QgbW9vdiA9IE1QNERlbXV4ZXIuZmluZEJveChpbml0U2VnbWVudCwgWydtb292J10pWzBdO1xuICAgIGNvbnN0IG1vb3ZFbmRPZmZzZXQgPSBtb292ID8gbW9vdi5lbmQgOiBudWxsOyAvLyB3ZSBuZWVkIHRoaXMgaW4gY2FzZSB3ZSBuZWVkIHRvIGNob3Agb2YgZ2FyYmFnZSBvZiB0aGUgZW5kIG9mIGN1cnJlbnQgZGF0YVxuXG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBsZXQgc2lkeCA9IE1QNERlbXV4ZXIuZmluZEJveChpbml0U2VnbWVudCwgWydzaWR4J10pO1xuICAgIGxldCByZWZlcmVuY2VzO1xuXG4gICAgaWYgKCFzaWR4IHx8ICFzaWR4WzBdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZWZlcmVuY2VzID0gW107XG4gICAgc2lkeCA9IHNpZHhbMF07XG5cbiAgICBjb25zdCB2ZXJzaW9uID0gc2lkeC5kYXRhWzBdO1xuXG4gICAgLy8gc2V0IGluaXRpYWwgb2Zmc2V0LCB3ZSBza2lwIHRoZSByZWZlcmVuY2UgSUQgKG5vdCBuZWVkZWQpXG4gICAgaW5kZXggPSB2ZXJzaW9uID09PSAwID8gOCA6IDE2O1xuXG4gICAgY29uc3QgdGltZXNjYWxlID0gTVA0RGVtdXhlci5yZWFkVWludDMyKHNpZHgsIGluZGV4KTtcbiAgICBpbmRleCArPSA0O1xuXG4gICAgLy8gVE9ETzogcGFyc2UgZWFybGllc3RQcmVzZW50YXRpb25UaW1lIGFuZCBmaXJzdE9mZnNldFxuICAgIC8vIHVzdWFsbHkgemVybyBpbiBvdXIgY2FzZVxuICAgIGxldCBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgPSAwO1xuICAgIGxldCBmaXJzdE9mZnNldCA9IDA7XG5cbiAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgaW5kZXggKz0gODtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXggKz0gMTY7XG4gICAgfVxuXG4gICAgLy8gc2tpcCByZXNlcnZlZFxuICAgIGluZGV4ICs9IDI7XG5cbiAgICBsZXQgc3RhcnRCeXRlID0gc2lkeC5lbmQgKyBmaXJzdE9mZnNldDtcblxuICAgIGNvbnN0IHJlZmVyZW5jZXNDb3VudCA9IE1QNERlbXV4ZXIucmVhZFVpbnQxNihzaWR4LCBpbmRleCk7XG4gICAgaW5kZXggKz0gMjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVmZXJlbmNlc0NvdW50OyBpKyspIHtcbiAgICAgIGxldCByZWZlcmVuY2VJbmRleCA9IGluZGV4O1xuXG4gICAgICBjb25zdCByZWZlcmVuY2VJbmZvID0gTVA0RGVtdXhlci5yZWFkVWludDMyKHNpZHgsIHJlZmVyZW5jZUluZGV4KTtcbiAgICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG5cbiAgICAgIGNvbnN0IHJlZmVyZW5jZVNpemUgPSByZWZlcmVuY2VJbmZvICYgMHg3RkZGRkZGRjtcbiAgICAgIGNvbnN0IHJlZmVyZW5jZVR5cGUgPSAocmVmZXJlbmNlSW5mbyAmIDB4ODAwMDAwMDApID4+PiAzMTtcblxuICAgICAgaWYgKHJlZmVyZW5jZVR5cGUgPT09IDEpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTSURYIGhhcyBoaWVyYXJjaGljYWwgcmVmZXJlbmNlcyAobm90IHN1cHBvcnRlZCknKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdWJzZWdtZW50RHVyYXRpb24gPSBNUDREZW11eGVyLnJlYWRVaW50MzIoc2lkeCwgcmVmZXJlbmNlSW5kZXgpO1xuICAgICAgcmVmZXJlbmNlSW5kZXggKz0gNDtcblxuICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgcmVmZXJlbmNlU2l6ZSxcbiAgICAgICAgc3Vic2VnbWVudER1cmF0aW9uLCAvLyB1bnNjYWxlZFxuICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgZHVyYXRpb246IHN1YnNlZ21lbnREdXJhdGlvbiAvIHRpbWVzY2FsZSxcbiAgICAgICAgICBzdGFydDogc3RhcnRCeXRlLFxuICAgICAgICAgIGVuZDogc3RhcnRCeXRlICsgcmVmZXJlbmNlU2l6ZSAtIDFcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHN0YXJ0Qnl0ZSArPSByZWZlcmVuY2VTaXplO1xuXG4gICAgICAvLyBTa2lwcGluZyAxIGJpdCBmb3IgfHN0YXJ0c1dpdGhTYXB8LCAzIGJpdHMgZm9yIHxzYXBUeXBlfCwgYW5kIDI4IGJpdHNcbiAgICAgIC8vIGZvciB8c2FwRGVsdGF8LlxuICAgICAgcmVmZXJlbmNlSW5kZXggKz0gNDtcblxuICAgICAgLy8gc2tpcCB0byBuZXh0IHJlZlxuICAgICAgaW5kZXggPSByZWZlcmVuY2VJbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZWFybGllc3RQcmVzZW50YXRpb25UaW1lLFxuICAgICAgdGltZXNjYWxlLFxuICAgICAgdmVyc2lvbixcbiAgICAgIHJlZmVyZW5jZXNDb3VudCxcbiAgICAgIHJlZmVyZW5jZXMsXG4gICAgICBtb292RW5kT2Zmc2V0XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gTVA0IGluaXRpYWxpemF0aW9uIHNlZ21lbnQgYW5kIGV4dHJhY3RzIHN0cmVhbSB0eXBlIGFuZFxuICAgKiB0aW1lc2NhbGUgdmFsdWVzIGZvciBhbnkgZGVjbGFyZWQgdHJhY2tzLiBUaW1lc2NhbGUgdmFsdWVzIGluZGljYXRlIHRoZVxuICAgKiBudW1iZXIgb2YgY2xvY2sgdGlja3MgcGVyIHNlY29uZCB0byBhc3N1bWUgZm9yIHRpbWUtYmFzZWQgdmFsdWVzXG4gICAqIGVsc2V3aGVyZSBpbiB0aGUgTVA0LlxuICAgKlxuICAgKiBUbyBkZXRlcm1pbmUgdGhlIHN0YXJ0IHRpbWUgb2YgYW4gTVA0LCB5b3UgbmVlZCB0d28gcGllY2VzIG9mXG4gICAqIGluZm9ybWF0aW9uOiB0aGUgdGltZXNjYWxlIHVuaXQgYW5kIHRoZSBlYXJsaWVzdCBiYXNlIG1lZGlhIGRlY29kZVxuICAgKiB0aW1lLiBNdWx0aXBsZSB0aW1lc2NhbGVzIGNhbiBiZSBzcGVjaWZpZWQgd2l0aGluIGFuIE1QNCBidXQgdGhlXG4gICAqIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgaXMgYWx3YXlzIGV4cHJlc3NlZCBpbiB0aGUgdGltZXNjYWxlIGZyb21cbiAgICogdGhlIG1lZGlhIGhlYWRlciBib3ggZm9yIHRoZSB0cmFjazpcbiAgICogYGBgXG4gICAqIG1vb3YgPiB0cmFrID4gbWRpYSA+IG1kaGQudGltZXNjYWxlXG4gICAqIG1vb3YgPiB0cmFrID4gbWRpYSA+IGhkbHJcbiAgICogYGBgXG4gICAqIEBwYXJhbSBpbml0IHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgdGhlIGluaXQgc2VnbWVudFxuICAgKiBAcmV0dXJuIHtvYmplY3R9IGEgaGFzaCBvZiB0cmFjayB0eXBlIHRvIHRpbWVzY2FsZSB2YWx1ZXMgb3IgbnVsbCBpZlxuICAgKiB0aGUgaW5pdCBzZWdtZW50IGlzIG1hbGZvcm1lZC5cbiAgICovXG4gIHN0YXRpYyBwYXJzZUluaXRTZWdtZW50IChpbml0U2VnbWVudCkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBsZXQgdHJha3MgPSBNUDREZW11eGVyLmZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICd0cmFrJ10pO1xuXG4gICAgdHJha3MuZm9yRWFjaCh0cmFrID0+IHtcbiAgICAgIGNvbnN0IHRraGQgPSBNUDREZW11eGVyLmZpbmRCb3godHJhaywgWyd0a2hkJ10pWzBdO1xuICAgICAgaWYgKHRraGQpIHtcbiAgICAgICAgbGV0IHZlcnNpb24gPSB0a2hkLmRhdGFbdGtoZC5zdGFydF07XG4gICAgICAgIGxldCBpbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xuICAgICAgICBsZXQgdHJhY2tJZCA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0a2hkLCBpbmRleCk7XG5cbiAgICAgICAgY29uc3QgbWRoZCA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWRoZCddKVswXTtcbiAgICAgICAgaWYgKG1kaGQpIHtcbiAgICAgICAgICB2ZXJzaW9uID0gbWRoZC5kYXRhW21kaGQuc3RhcnRdO1xuICAgICAgICAgIGluZGV4ID0gdmVyc2lvbiA9PT0gMCA/IDEyIDogMjA7XG4gICAgICAgICAgY29uc3QgdGltZXNjYWxlID0gTVA0RGVtdXhlci5yZWFkVWludDMyKG1kaGQsIGluZGV4KTtcblxuICAgICAgICAgIGNvbnN0IGhkbHIgPSBNUDREZW11eGVyLmZpbmRCb3godHJhaywgWydtZGlhJywgJ2hkbHInXSlbMF07XG4gICAgICAgICAgaWYgKGhkbHIpIHtcbiAgICAgICAgICAgIGNvbnN0IGhkbHJUeXBlID0gTVA0RGVtdXhlci5iaW4yc3RyKGhkbHIuZGF0YS5zdWJhcnJheShoZGxyLnN0YXJ0ICsgOCwgaGRsci5zdGFydCArIDEyKSk7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHsgJ3NvdW4nOiAnYXVkaW8nLCAndmlkZSc6ICd2aWRlbycgfVtoZGxyVHlwZV07XG4gICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAvLyBleHRyYWN0IGNvZGVjIGluZm8uIFRPRE8gOiBwYXJzZSBjb2RlYyBkZXRhaWxzIHRvIGJlIGFibGUgdG8gYnVpbGQgTUlNRSB0eXBlXG4gICAgICAgICAgICAgIGxldCBjb2RlY0JveCA9IE1QNERlbXV4ZXIuZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWluZicsICdzdGJsJywgJ3N0c2QnXSk7XG4gICAgICAgICAgICAgIGlmIChjb2RlY0JveC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb2RlY0JveCA9IGNvZGVjQm94WzBdO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlY1R5cGUgPSBNUDREZW11eGVyLmJpbjJzdHIoY29kZWNCb3guZGF0YS5zdWJhcnJheShjb2RlY0JveC5zdGFydCArIDEyLCBjb2RlY0JveC5zdGFydCArIDE2KSk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgTVA0RGVtdXhlcjoke3R5cGV9OiR7Y29kZWNUeXBlfSBmb3VuZGApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdFt0cmFja0lkXSA9IHsgdGltZXNjYWxlOiB0aW1lc2NhbGUsIHR5cGU6IHR5cGUgfTtcbiAgICAgICAgICAgICAgcmVzdWx0W3R5cGVdID0geyB0aW1lc2NhbGU6IHRpbWVzY2FsZSwgaWQ6IHRyYWNrSWQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHN0YXJ0IHRpbWUsIGluIHNlY29uZHMsIGZvciBhbiBNUDRcbiAqIGZyYWdtZW50LiBJZiBtdWx0aXBsZSBmcmFnbWVudHMgYXJlIHNwZWNpZmllZCwgdGhlIGVhcmxpZXN0IHRpbWUgaXNcbiAqIHJldHVybmVkLlxuICpcbiAqIFRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGNhbiBiZSBwYXJzZWQgZnJvbSB0cmFjayBmcmFnbWVudFxuICogbWV0YWRhdGE6XG4gKiBgYGBcbiAqIG1vb2YgPiB0cmFmID4gdGZkdC5iYXNlTWVkaWFEZWNvZGVUaW1lXG4gKiBgYGBcbiAqIEl0IHJlcXVpcmVzIHRoZSB0aW1lc2NhbGUgdmFsdWUgZnJvbSB0aGUgbWRoZCB0byBpbnRlcnByZXQuXG4gKlxuICogQHBhcmFtIHRpbWVzY2FsZSB7b2JqZWN0fSBhIGhhc2ggb2YgdHJhY2sgaWRzIHRvIHRpbWVzY2FsZSB2YWx1ZXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBlYXJsaWVzdCBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lIGZvciB0aGVcbiAqIGZyYWdtZW50LCBpbiBzZWNvbmRzXG4gKi9cbiAgc3RhdGljIGdldFN0YXJ0RFRTIChpbml0RGF0YSwgZnJhZ21lbnQpIHtcbiAgICBsZXQgdHJhZnMsIGJhc2VUaW1lcywgcmVzdWx0O1xuXG4gICAgLy8gd2UgbmVlZCBpbmZvIGZyb20gdHdvIGNoaWxkcmVuZCBvZiBlYWNoIHRyYWNrIGZyYWdtZW50IGJveFxuICAgIHRyYWZzID0gTVA0RGVtdXhlci5maW5kQm94KGZyYWdtZW50LCBbJ21vb2YnLCAndHJhZiddKTtcblxuICAgIC8vIGRldGVybWluZSB0aGUgc3RhcnQgdGltZXMgZm9yIGVhY2ggdHJhY2tcbiAgICBiYXNlVGltZXMgPSBbXS5jb25jYXQuYXBwbHkoW10sIHRyYWZzLm1hcChmdW5jdGlvbiAodHJhZikge1xuICAgICAgcmV0dXJuIE1QNERlbXV4ZXIuZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkubWFwKGZ1bmN0aW9uICh0ZmhkKSB7XG4gICAgICAgIGxldCBpZCwgc2NhbGUsIGJhc2VUaW1lO1xuXG4gICAgICAgIC8vIGdldCB0aGUgdHJhY2sgaWQgZnJvbSB0aGUgdGZoZFxuICAgICAgICBpZCA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgICAgLy8gYXNzdW1lIGEgOTBrSHogY2xvY2sgaWYgbm8gdGltZXNjYWxlIHdhcyBzcGVjaWZpZWRcbiAgICAgICAgc2NhbGUgPSBpbml0RGF0YVtpZF0udGltZXNjYWxlIHx8IDkwZTM7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGZyb20gdGhlIHRmZHRcbiAgICAgICAgYmFzZVRpbWUgPSBNUDREZW11eGVyLmZpbmRCb3godHJhZiwgWyd0ZmR0J10pLm1hcChmdW5jdGlvbiAodGZkdCkge1xuICAgICAgICAgIGxldCB2ZXJzaW9uLCByZXN1bHQ7XG5cbiAgICAgICAgICB2ZXJzaW9uID0gdGZkdC5kYXRhW3RmZHQuc3RhcnRdO1xuICAgICAgICAgIHJlc3VsdCA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmR0LCA0KTtcbiAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgICAgcmVzdWx0ICo9IE1hdGgucG93KDIsIDMyKTtcblxuICAgICAgICAgICAgcmVzdWx0ICs9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmR0LCA4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIC8vIGNvbnZlcnQgYmFzZSB0aW1lIHRvIHNlY29uZHNcbiAgICAgICAgcmV0dXJuIGJhc2VUaW1lIC8gc2NhbGU7XG4gICAgICB9KTtcbiAgICB9KSk7XG5cbiAgICAvLyByZXR1cm4gdGhlIG1pbmltdW1cbiAgICByZXN1bHQgPSBNYXRoLm1pbi5hcHBseShudWxsLCBiYXNlVGltZXMpO1xuICAgIHJldHVybiBpc0Zpbml0ZShyZXN1bHQpID8gcmVzdWx0IDogMDtcbiAgfVxuXG4gIHN0YXRpYyBvZmZzZXRTdGFydERUUyAoaW5pdERhdGEsIGZyYWdtZW50LCB0aW1lT2Zmc2V0KSB7XG4gICAgTVA0RGVtdXhlci5maW5kQm94KGZyYWdtZW50LCBbJ21vb2YnLCAndHJhZiddKS5tYXAoZnVuY3Rpb24gKHRyYWYpIHtcbiAgICAgIHJldHVybiBNUDREZW11eGVyLmZpbmRCb3godHJhZiwgWyd0ZmhkJ10pLm1hcChmdW5jdGlvbiAodGZoZCkge1xuICAgICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG4gICAgICAgIGxldCBpZCA9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgICAgLy8gYXNzdW1lIGEgOTBrSHogY2xvY2sgaWYgbm8gdGltZXNjYWxlIHdhcyBzcGVjaWZpZWRcbiAgICAgICAgbGV0IHRpbWVzY2FsZSA9IGluaXREYXRhW2lkXS50aW1lc2NhbGUgfHwgOTBlMztcblxuICAgICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuICAgICAgICBNUDREZW11eGVyLmZpbmRCb3godHJhZiwgWyd0ZmR0J10pLm1hcChmdW5jdGlvbiAodGZkdCkge1xuICAgICAgICAgIGxldCB2ZXJzaW9uID0gdGZkdC5kYXRhW3RmZHQuc3RhcnRdO1xuICAgICAgICAgIGxldCBiYXNlTWVkaWFEZWNvZGVUaW1lID0gTVA0RGVtdXhlci5yZWFkVWludDMyKHRmZHQsIDQpO1xuICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICBNUDREZW11eGVyLndyaXRlVWludDMyKHRmZHQsIDQsIGJhc2VNZWRpYURlY29kZVRpbWUgLSB0aW1lT2Zmc2V0ICogdGltZXNjYWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAqPSBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lICs9IE1QNERlbXV4ZXIucmVhZFVpbnQzMih0ZmR0LCA4KTtcbiAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgLT0gdGltZU9mZnNldCAqIHRpbWVzY2FsZTtcbiAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLm1heChiYXNlTWVkaWFEZWNvZGVUaW1lLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IHVwcGVyID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICAgICAgICBjb25zdCBsb3dlciA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgICAgICAgTVA0RGVtdXhlci53cml0ZVVpbnQzMih0ZmR0LCA0LCB1cHBlcik7XG4gICAgICAgICAgICBNUDREZW11eGVyLndyaXRlVWludDMyKHRmZHQsIDgsIGxvd2VyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBmZWVkIGluY29taW5nIGRhdGEgdG8gdGhlIGZyb250IG9mIHRoZSBwYXJzaW5nIHBpcGVsaW5lXG4gIGFwcGVuZCAoZGF0YSwgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgbGV0IGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICBpZiAoIWluaXREYXRhKSB7XG4gICAgICB0aGlzLnJlc2V0SW5pdFNlZ21lbnQoZGF0YSwgdGhpcy5hdWRpb0NvZGVjLCB0aGlzLnZpZGVvQ29kZWMsIGZhbHNlKTtcbiAgICAgIGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0RFRTLCBpbml0UFRTID0gdGhpcy5pbml0UFRTO1xuICAgIGlmIChpbml0UFRTID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBzdGFydERUUyA9IE1QNERlbXV4ZXIuZ2V0U3RhcnREVFMoaW5pdERhdGEsIGRhdGEpO1xuICAgICAgdGhpcy5pbml0UFRTID0gaW5pdFBUUyA9IHN0YXJ0RFRTIC0gdGltZU9mZnNldDtcbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5JTklUX1BUU19GT1VORCwgeyBpbml0UFRTOiBpbml0UFRTIH0pO1xuICAgIH1cbiAgICBNUDREZW11eGVyLm9mZnNldFN0YXJ0RFRTKGluaXREYXRhLCBkYXRhLCBpbml0UFRTKTtcbiAgICBzdGFydERUUyA9IE1QNERlbXV4ZXIuZ2V0U3RhcnREVFMoaW5pdERhdGEsIGRhdGEpO1xuICAgIHRoaXMucmVtdXhlci5yZW11eChpbml0RGF0YS5hdWRpbywgaW5pdERhdGEudmlkZW8sIG51bGwsIG51bGwsIHN0YXJ0RFRTLCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGRhdGEpO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNUDREZW11eGVyO1xuIiwiLyoqXG4gKiAgTVBFRyBwYXJzZXIgaGVscGVyXG4gKi9cblxuY29uc3QgTXBlZ0F1ZGlvID0ge1xuXG4gIEJpdHJhdGVzTWFwOiBbXG4gICAgMzIsIDY0LCA5NiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDI4OCwgMzIwLCAzNTIsIDM4NCwgNDE2LCA0NDgsXG4gICAgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwLCAzODQsXG4gICAgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCxcbiAgICAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjAsIDE3NiwgMTkyLCAyMjQsIDI1NixcbiAgICA4LCAxNiwgMjQsIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjBdLFxuXG4gIFNhbXBsaW5nUmF0ZU1hcDogWzQ0MTAwLCA0ODAwMCwgMzIwMDAsIDIyMDUwLCAyNDAwMCwgMTYwMDAsIDExMDI1LCAxMjAwMCwgODAwMF0sXG5cbiAgU2FtcGxlc0NvZWZmaWNpZW50czogW1xuICAgIC8vIE1QRUcgMi41XG4gICAgW1xuICAgICAgMCwgLy8gUmVzZXJ2ZWRcbiAgICAgIDcyLCAvLyBMYXllcjNcbiAgICAgIDE0NCwgLy8gTGF5ZXIyXG4gICAgICAxMiAvLyBMYXllcjFcbiAgICBdLFxuICAgIC8vIFJlc2VydmVkXG4gICAgW1xuICAgICAgMCwgLy8gUmVzZXJ2ZWRcbiAgICAgIDAsIC8vIExheWVyM1xuICAgICAgMCwgLy8gTGF5ZXIyXG4gICAgICAwIC8vIExheWVyMVxuICAgIF0sXG4gICAgLy8gTVBFRyAyXG4gICAgW1xuICAgICAgMCwgLy8gUmVzZXJ2ZWRcbiAgICAgIDcyLCAvLyBMYXllcjNcbiAgICAgIDE0NCwgLy8gTGF5ZXIyXG4gICAgICAxMiAvLyBMYXllcjFcbiAgICBdLFxuICAgIC8vIE1QRUcgMVxuICAgIFtcbiAgICAgIDAsIC8vIFJlc2VydmVkXG4gICAgICAxNDQsIC8vIExheWVyM1xuICAgICAgMTQ0LCAvLyBMYXllcjJcbiAgICAgIDEyIC8vIExheWVyMVxuICAgIF1cbiAgXSxcblxuICBCeXRlc0luU2xvdDogW1xuICAgIDAsIC8vIFJlc2VydmVkXG4gICAgMSwgLy8gTGF5ZXIzXG4gICAgMSwgLy8gTGF5ZXIyXG4gICAgNCAvLyBMYXllcjFcbiAgXSxcblxuICBhcHBlbmRGcmFtZTogZnVuY3Rpb24gKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCkge1xuICAgIC8vIFVzaW5nIGh0dHA6Ly93d3cuZGF0YXZveWFnZS5jb20vbXBnc2NyaXB0L21wZWdoZHIuaHRtIGFzIGEgcmVmZXJlbmNlXG4gICAgaWYgKG9mZnNldCArIDI0ID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgbGV0IGhlYWRlciA9IHRoaXMucGFyc2VIZWFkZXIoZGF0YSwgb2Zmc2V0KTtcbiAgICBpZiAoaGVhZGVyICYmIG9mZnNldCArIGhlYWRlci5mcmFtZUxlbmd0aCA8PSBkYXRhLmxlbmd0aCkge1xuICAgICAgbGV0IGZyYW1lRHVyYXRpb24gPSBoZWFkZXIuc2FtcGxlc1BlckZyYW1lICogOTAwMDAgLyBoZWFkZXIuc2FtcGxlUmF0ZTtcbiAgICAgIGxldCBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICAgICAgbGV0IHNhbXBsZSA9IHsgdW5pdDogZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGhlYWRlci5mcmFtZUxlbmd0aCksIHB0czogc3RhbXAsIGR0czogc3RhbXAgfTtcblxuICAgICAgdHJhY2suY29uZmlnID0gW107XG4gICAgICB0cmFjay5jaGFubmVsQ291bnQgPSBoZWFkZXIuY2hhbm5lbENvdW50O1xuICAgICAgdHJhY2suc2FtcGxlcmF0ZSA9IGhlYWRlci5zYW1wbGVSYXRlO1xuICAgICAgdHJhY2suc2FtcGxlcy5wdXNoKHNhbXBsZSk7XG4gICAgICB0cmFjay5sZW4gKz0gaGVhZGVyLmZyYW1lTGVuZ3RoO1xuXG4gICAgICByZXR1cm4geyBzYW1wbGUsIGxlbmd0aDogaGVhZGVyLmZyYW1lTGVuZ3RoIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSxcblxuICBwYXJzZUhlYWRlcjogZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgIGxldCBoZWFkZXJCID0gKGRhdGFbb2Zmc2V0ICsgMV0gPj4gMykgJiAzO1xuICAgIGxldCBoZWFkZXJDID0gKGRhdGFbb2Zmc2V0ICsgMV0gPj4gMSkgJiAzO1xuICAgIGxldCBoZWFkZXJFID0gKGRhdGFbb2Zmc2V0ICsgMl0gPj4gNCkgJiAxNTtcbiAgICBsZXQgaGVhZGVyRiA9IChkYXRhW29mZnNldCArIDJdID4+IDIpICYgMztcbiAgICBsZXQgaGVhZGVyRyA9IChkYXRhW29mZnNldCArIDJdID4+IDEpICYgMTtcbiAgICBpZiAoaGVhZGVyQiAhPT0gMSAmJiBoZWFkZXJFICE9PSAwICYmIGhlYWRlckUgIT09IDE1ICYmIGhlYWRlckYgIT09IDMpIHtcbiAgICAgIGxldCBjb2x1bW5JbkJpdHJhdGVzID0gaGVhZGVyQiA9PT0gMyA/ICgzIC0gaGVhZGVyQykgOiAoaGVhZGVyQyA9PT0gMyA/IDMgOiA0KTtcbiAgICAgIGxldCBiaXRSYXRlID0gTXBlZ0F1ZGlvLkJpdHJhdGVzTWFwW2NvbHVtbkluQml0cmF0ZXMgKiAxNCArIGhlYWRlckUgLSAxXSAqIDEwMDA7XG4gICAgICBsZXQgY29sdW1uSW5TYW1wbGVSYXRlcyA9IGhlYWRlckIgPT09IDMgPyAwIDogaGVhZGVyQiA9PT0gMiA/IDEgOiAyO1xuICAgICAgbGV0IHNhbXBsZVJhdGUgPSBNcGVnQXVkaW8uU2FtcGxpbmdSYXRlTWFwW2NvbHVtbkluU2FtcGxlUmF0ZXMgKiAzICsgaGVhZGVyRl07XG4gICAgICBsZXQgY2hhbm5lbENvdW50ID0gZGF0YVtvZmZzZXQgKyAzXSA+PiA2ID09PSAzID8gMSA6IDI7IC8vIElmIGJpdHMgb2YgY2hhbm5lbCBtb2RlIGFyZSBgMTFgIHRoZW4gaXQgaXMgYSBzaW5nbGUgY2hhbm5lbCAoTW9ubylcbiAgICAgIGxldCBzYW1wbGVDb2VmZmljaWVudCA9IE1wZWdBdWRpby5TYW1wbGVzQ29lZmZpY2llbnRzW2hlYWRlckJdW2hlYWRlckNdO1xuICAgICAgbGV0IGJ5dGVzSW5TbG90ID0gTXBlZ0F1ZGlvLkJ5dGVzSW5TbG90W2hlYWRlckNdO1xuICAgICAgbGV0IHNhbXBsZXNQZXJGcmFtZSA9IHNhbXBsZUNvZWZmaWNpZW50ICogOCAqIGJ5dGVzSW5TbG90O1xuICAgICAgbGV0IGZyYW1lTGVuZ3RoID0gcGFyc2VJbnQoc2FtcGxlQ29lZmZpY2llbnQgKiBiaXRSYXRlIC8gc2FtcGxlUmF0ZSArIGhlYWRlckcsIDEwKSAqIGJ5dGVzSW5TbG90O1xuXG4gICAgICByZXR1cm4geyBzYW1wbGVSYXRlLCBjaGFubmVsQ291bnQsIGZyYW1lTGVuZ3RoLCBzYW1wbGVzUGVyRnJhbWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LFxuXG4gIGlzSGVhZGVyUGF0dGVybjogZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGUwKSA9PT0gMHhlMCAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDYpICE9PSAweDAwO1xuICB9LFxuXG4gIGlzSGVhZGVyOiBmdW5jdGlvbiAoZGF0YSwgb2Zmc2V0KSB7XG4gICAgLy8gTG9vayBmb3IgTVBFRyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTFYIFhZWlggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxIGFuZCBZIG9yIFogc2hvdWxkIGJlIDFcbiAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxuICAgIC8vIE1vcmUgaW5mbyBodHRwOi8vd3d3Lm1wMy10ZWNoLm9yZy9wcm9ncmFtbWVyL2ZyYW1lX2hlYWRlci5odG1sXG4gICAgaWYgKG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiB0aGlzLmlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgcHJvYmU6IGZ1bmN0aW9uIChkYXRhLCBvZmZzZXQpIHtcbiAgICAvLyBzYW1lIGFzIGlzSGVhZGVyIGJ1dCB3ZSBhbHNvIGNoZWNrIHRoYXQgTVBFRyBmcmFtZSBmb2xsb3dzIGxhc3QgTVBFRyBmcmFtZVxuICAgIC8vIG9yIGVuZCBvZiBkYXRhIGlzIHJlYWNoZWRcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIHRoaXMuaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgIC8vIE1QRUcgaGVhZGVyIExlbmd0aFxuICAgICAgbGV0IGhlYWRlckxlbmd0aCA9IDQ7XG4gICAgICAvLyBNUEVHIGZyYW1lIExlbmd0aFxuICAgICAgbGV0IGhlYWRlciA9IHRoaXMucGFyc2VIZWFkZXIoZGF0YSwgb2Zmc2V0KTtcbiAgICAgIGxldCBmcmFtZUxlbmd0aCA9IGhlYWRlckxlbmd0aDtcbiAgICAgIGlmIChoZWFkZXIgJiYgaGVhZGVyLmZyYW1lTGVuZ3RoKSB7XG4gICAgICAgIGZyYW1lTGVuZ3RoID0gaGVhZGVyLmZyYW1lTGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBsZXQgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgZnJhbWVMZW5ndGg7XG4gICAgICBpZiAobmV3T2Zmc2V0ID09PSBkYXRhLmxlbmd0aCB8fCAobmV3T2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIHRoaXMuaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG5ld09mZnNldCkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1wZWdBdWRpbztcbiIsIi8qKlxuICogU0FNUExFLUFFUyBkZWNyeXB0ZXJcbiovXG5cbmltcG9ydCBEZWNyeXB0ZXIgZnJvbSAnLi4vY3J5cHQvZGVjcnlwdGVyJztcblxuY2xhc3MgU2FtcGxlQWVzRGVjcnlwdGVyIHtcbiAgY29uc3RydWN0b3IgKG9ic2VydmVyLCBjb25maWcsIGRlY3J5cHRkYXRhLCBkaXNjYXJkRVBCKSB7XG4gICAgdGhpcy5kZWNyeXB0ZGF0YSA9IGRlY3J5cHRkYXRhO1xuICAgIHRoaXMuZGlzY2FyZEVQQiA9IGRpc2NhcmRFUEI7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKG9ic2VydmVyLCBjb25maWcsIHsgcmVtb3ZlUEtDUzdQYWRkaW5nOiBmYWxzZSB9KTtcbiAgfVxuXG4gIGRlY3J5cHRCdWZmZXIgKGVuY3J5cHRlZERhdGEsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5kZWNyeXB0ZXIuZGVjcnlwdChlbmNyeXB0ZWREYXRhLCB0aGlzLmRlY3J5cHRkYXRhLmtleS5idWZmZXIsIHRoaXMuZGVjcnlwdGRhdGEuaXYuYnVmZmVyLCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBBQUMgLSBlbmNyeXB0IGFsbCBmdWxsIDE2IGJ5dGVzIGJsb2NrcyBzdGFydGluZyBmcm9tIG9mZnNldCAxNlxuICBkZWNyeXB0QWFjU2FtcGxlIChzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2ssIHN5bmMpIHtcbiAgICBsZXQgY3VyVW5pdCA9IHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXQ7XG4gICAgbGV0IGVuY3J5cHRlZERhdGEgPSBjdXJVbml0LnN1YmFycmF5KDE2LCBjdXJVbml0Lmxlbmd0aCAtIGN1clVuaXQubGVuZ3RoICUgMTYpO1xuICAgIGxldCBlbmNyeXB0ZWRCdWZmZXIgPSBlbmNyeXB0ZWREYXRhLmJ1ZmZlci5zbGljZShcbiAgICAgIGVuY3J5cHRlZERhdGEuYnl0ZU9mZnNldCxcbiAgICAgIGVuY3J5cHRlZERhdGEuYnl0ZU9mZnNldCArIGVuY3J5cHRlZERhdGEubGVuZ3RoKTtcblxuICAgIGxldCBsb2NhbHRoaXMgPSB0aGlzO1xuICAgIHRoaXMuZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWRCdWZmZXIsIGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICBkZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSk7XG4gICAgICBjdXJVbml0LnNldChkZWNyeXB0ZWREYXRhLCAxNik7XG5cbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBsb2NhbHRoaXMuZGVjcnlwdEFhY1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXggKyAxLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBkZWNyeXB0QWFjU2FtcGxlcyAoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgZm9yICg7OyBzYW1wbGVJbmRleCsrKSB7XG4gICAgICBpZiAoc2FtcGxlSW5kZXggPj0gc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdC5sZW5ndGggPCAzMikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IHN5bmMgPSB0aGlzLmRlY3J5cHRlci5pc1N5bmMoKTtcblxuICAgICAgdGhpcy5kZWNyeXB0QWFjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjaywgc3luYyk7XG5cbiAgICAgIGlmICghc3luYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQVZDIC0gZW5jcnlwdCBvbmUgMTYgYnl0ZXMgYmxvY2sgb3V0IG9mIHRlbiwgc3RhcnRpbmcgZnJvbSBvZmZzZXQgMzJcbiAgZ2V0QXZjRW5jcnlwdGVkRGF0YSAoZGVjb2RlZERhdGEpIHtcbiAgICBsZXQgZW5jcnlwdGVkRGF0YUxlbiA9IE1hdGguZmxvb3IoKGRlY29kZWREYXRhLmxlbmd0aCAtIDQ4KSAvIDE2MCkgKiAxNiArIDE2O1xuICAgIGxldCBlbmNyeXB0ZWREYXRhID0gbmV3IEludDhBcnJheShlbmNyeXB0ZWREYXRhTGVuKTtcbiAgICBsZXQgb3V0cHV0UG9zID0gMDtcbiAgICBmb3IgKGxldCBpbnB1dFBvcyA9IDMyOyBpbnB1dFBvcyA8PSBkZWNvZGVkRGF0YS5sZW5ndGggLSAxNjsgaW5wdXRQb3MgKz0gMTYwLCBvdXRwdXRQb3MgKz0gMTYpIHtcbiAgICAgIGVuY3J5cHRlZERhdGEuc2V0KGRlY29kZWREYXRhLnN1YmFycmF5KGlucHV0UG9zLCBpbnB1dFBvcyArIDE2KSwgb3V0cHV0UG9zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jcnlwdGVkRGF0YTtcbiAgfVxuXG4gIGdldEF2Y0RlY3J5cHRlZFVuaXQgKGRlY29kZWREYXRhLCBkZWNyeXB0ZWREYXRhKSB7XG4gICAgZGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpO1xuICAgIGxldCBpbnB1dFBvcyA9IDA7XG4gICAgZm9yIChsZXQgb3V0cHV0UG9zID0gMzI7IG91dHB1dFBvcyA8PSBkZWNvZGVkRGF0YS5sZW5ndGggLSAxNjsgb3V0cHV0UG9zICs9IDE2MCwgaW5wdXRQb3MgKz0gMTYpIHtcbiAgICAgIGRlY29kZWREYXRhLnNldChkZWNyeXB0ZWREYXRhLnN1YmFycmF5KGlucHV0UG9zLCBpbnB1dFBvcyArIDE2KSwgb3V0cHV0UG9zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVjb2RlZERhdGE7XG4gIH1cblxuICBkZWNyeXB0QXZjU2FtcGxlIChzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaywgY3VyVW5pdCwgc3luYykge1xuICAgIGxldCBkZWNvZGVkRGF0YSA9IHRoaXMuZGlzY2FyZEVQQihjdXJVbml0LmRhdGEpO1xuICAgIGxldCBlbmNyeXB0ZWREYXRhID0gdGhpcy5nZXRBdmNFbmNyeXB0ZWREYXRhKGRlY29kZWREYXRhKTtcbiAgICBsZXQgbG9jYWx0aGlzID0gdGhpcztcblxuICAgIHRoaXMuZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWREYXRhLmJ1ZmZlciwgZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgIGN1clVuaXQuZGF0YSA9IGxvY2FsdGhpcy5nZXRBdmNEZWNyeXB0ZWRVbml0KGRlY29kZWREYXRhLCBkZWNyeXB0ZWREYXRhKTtcblxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGxvY2FsdGhpcy5kZWNyeXB0QXZjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4ICsgMSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGVjcnlwdEF2Y1NhbXBsZXMgKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgZm9yICg7OyBzYW1wbGVJbmRleCsrLCB1bml0SW5kZXggPSAwKSB7XG4gICAgICBpZiAoc2FtcGxlSW5kZXggPj0gc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgY3VyVW5pdHMgPSBzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0cztcbiAgICAgIGZvciAoOzsgdW5pdEluZGV4KyspIHtcbiAgICAgICAgaWYgKHVuaXRJbmRleCA+PSBjdXJVbml0cy5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjdXJVbml0ID0gY3VyVW5pdHNbdW5pdEluZGV4XTtcbiAgICAgICAgaWYgKGN1clVuaXQubGVuZ3RoIDw9IDQ4IHx8IChjdXJVbml0LnR5cGUgIT09IDEgJiYgY3VyVW5pdC50eXBlICE9PSA1KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN5bmMgPSB0aGlzLmRlY3J5cHRlci5pc1N5bmMoKTtcblxuICAgICAgICB0aGlzLmRlY3J5cHRBdmNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2ssIGN1clVuaXQsIHN5bmMpO1xuXG4gICAgICAgIGlmICghc3luYykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTYW1wbGVBZXNEZWNyeXB0ZXI7XG4iLCIvKipcbiAqIGhpZ2hseSBvcHRpbWl6ZWQgVFMgZGVtdXhlcjpcbiAqIHBhcnNlIFBBVCwgUE1UXG4gKiBleHRyYWN0IFBFUyBwYWNrZXQgZnJvbSBhdWRpbyBhbmQgdmlkZW8gUElEc1xuICogZXh0cmFjdCBBVkMvSDI2NCBOQUwgdW5pdHMgYW5kIEFBQy9BRFRTIHNhbXBsZXMgZnJvbSBQRVMgcGFja2V0XG4gKiB0cmlnZ2VyIHRoZSByZW11eGVyIHVwb24gcGFyc2luZyBjb21wbGV0aW9uXG4gKiBpdCBhbHNvIHRyaWVzIHRvIHdvcmthcm91bmQgYXMgYmVzdCBhcyBpdCBjYW4gYXVkaW8gY29kZWMgc3dpdGNoIChIRS1BQUMgdG8gQUFDIGFuZCB2aWNlIHZlcnNhKSwgd2l0aG91dCBoYXZpbmcgdG8gcmVzdGFydCB0aGUgTWVkaWFTb3VyY2UuXG4gKiBpdCBhbHNvIGNvbnRyb2xzIHRoZSByZW11eGluZyBwcm9jZXNzIDpcbiAqIHVwb24gZGlzY29udGludWl0eSBvciBsZXZlbCBzd2l0Y2ggZGV0ZWN0aW9uLCBpdCB3aWxsIGFsc28gbm90aWZpZXMgdGhlIHJlbXV4ZXIgc28gdGhhdCBpdCBjYW4gcmVzZXQgaXRzIHN0YXRlLlxuKi9cblxuaW1wb3J0ICogYXMgQURUUyBmcm9tICcuL2FkdHMnO1xuaW1wb3J0IE1wZWdBdWRpbyBmcm9tICcuL21wZWdhdWRpbyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBFeHBHb2xvbWIgZnJvbSAnLi9leHAtZ29sb21iJztcbmltcG9ydCBTYW1wbGVBZXNEZWNyeXB0ZXIgZnJvbSAnLi9zYW1wbGUtYWVzJztcbi8vIGltcG9ydCBIZXggZnJvbSAnLi4vdXRpbHMvaGV4JztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuXG4vLyBXZSBhcmUgdXNpbmcgZml4ZWQgdHJhY2sgSURzIGZvciBkcml2aW5nIHRoZSBNUDQgcmVtdXhlclxuLy8gaW5zdGVhZCBvZiBmb2xsb3dpbmcgdGhlIFRTIFBJRHMuXG4vLyBUaGVyZSBpcyBubyByZWFzb24gbm90IHRvIGRvIHRoaXMgYW5kIHNvbWUgYnJvd3NlcnMvU291cmNlQnVmZmVyLWRlbXV4ZXJzXG4vLyBtYXkgbm90IGxpa2UgaWYgdGhlcmUgYXJlIFRyYWNrSUQgXCJzd2l0Y2hlc1wiXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzEzMzFcbi8vIEhlcmUgd2UgYXJlIG1hcHBpbmcgb3VyIGludGVybmFsIHRyYWNrIHR5cGVzIHRvIGNvbnN0YW50IE1QNCB0cmFjayBJRHNcbi8vIFdpdGggTVNFIGN1cnJlbnRseSBvbmUgY2FuIG9ubHkgaGF2ZSBvbmUgdHJhY2sgb2YgZWFjaCwgYW5kIHdlIGFyZSBtdXhpbmdcbi8vIHdoYXRldmVyIHZpZGVvL2F1ZGlvIHJlbmRpdGlvbiBpbiB0aGVtLlxuY29uc3QgUmVtdXhlclRyYWNrSWRDb25maWcgPSB7XG4gIHZpZGVvOiAxLFxuICBhdWRpbzogMixcbiAgaWQzOiAzLFxuICB0ZXh0OiA0XG59O1xuXG5jbGFzcyBUU0RlbXV4ZXIge1xuICBjb25zdHJ1Y3RvciAob2JzZXJ2ZXIsIHJlbXV4ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCkge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMucmVtdXhlciA9IHJlbXV4ZXI7XG4gICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xuICB9XG5cbiAgc2V0RGVjcnlwdERhdGEgKGRlY3J5cHRkYXRhKSB7XG4gICAgaWYgKChkZWNyeXB0ZGF0YSAhPSBudWxsKSAmJiAoZGVjcnlwdGRhdGEua2V5ICE9IG51bGwpICYmIChkZWNyeXB0ZGF0YS5tZXRob2QgPT09ICdTQU1QTEUtQUVTJykpIHtcbiAgICAgIHRoaXMuc2FtcGxlQWVzID0gbmV3IFNhbXBsZUFlc0RlY3J5cHRlcih0aGlzLm9ic2VydmVyLCB0aGlzLmNvbmZpZywgZGVjcnlwdGRhdGEsIHRoaXMuZGlzY2FyZEVQQik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2FtcGxlQWVzID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcHJvYmUgKGRhdGEpIHtcbiAgICBjb25zdCBzeW5jT2Zmc2V0ID0gVFNEZW11eGVyLl9zeW5jT2Zmc2V0KGRhdGEpO1xuICAgIGlmIChzeW5jT2Zmc2V0IDwgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3luY09mZnNldCkge1xuICAgICAgICBsb2dnZXIud2FybihgTVBFRzItVFMgZGV0ZWN0ZWQgYnV0IGZpcnN0IHN5bmMgd29yZCBmb3VuZCBAIG9mZnNldCAke3N5bmNPZmZzZXR9LCBqdW5rIGFoZWFkID9gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIF9zeW5jT2Zmc2V0IChkYXRhKSB7XG4gICAgLy8gc2NhbiAxMDAwIGZpcnN0IGJ5dGVzXG4gICAgY29uc3Qgc2NhbndpbmRvdyA9IE1hdGgubWluKDEwMDAsIGRhdGEubGVuZ3RoIC0gMyAqIDE4OCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc2NhbndpbmRvdykge1xuICAgICAgLy8gYSBUUyBmcmFnbWVudCBzaG91bGQgY29udGFpbiBhdCBsZWFzdCAzIFRTIHBhY2tldHMsIGEgUEFULCBhIFBNVCwgYW5kIG9uZSBQSUQsIGVhY2ggc3RhcnRpbmcgd2l0aCAweDQ3XG4gICAgICBpZiAoZGF0YVtpXSA9PT0gMHg0NyAmJiBkYXRhW2kgKyAxODhdID09PSAweDQ3ICYmIGRhdGFbaSArIDIgKiAxODhdID09PSAweDQ3KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRyYWNrIG1vZGVsIGludGVybmFsIHRvIGRlbXV4ZXIgdXNlZCB0byBkcml2ZSByZW11eGluZyBpbnB1dFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAnYXVkaW8nIHwgJ3ZpZGVvJyB8ICdpZDMnIHwgJ3RleHQnXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvblxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRTRGVtdXhlcidzIGludGVybmFsIHRyYWNrIG1vZGVsXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlVHJhY2sgKHR5cGUsIGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRhaW5lcjogdHlwZSA9PT0gJ3ZpZGVvJyB8fCB0eXBlID09PSAnYXVkaW8nID8gJ3ZpZGVvL21wMnQnIDogdW5kZWZpbmVkLFxuICAgICAgdHlwZSxcbiAgICAgIGlkOiBSZW11eGVyVHJhY2tJZENvbmZpZ1t0eXBlXSxcbiAgICAgIHBpZDogLTEsXG4gICAgICBpbnB1dFRpbWVTY2FsZTogOTAwMDAsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgbGVuOiAwLFxuICAgICAgZHJvcHBlZDogdHlwZSA9PT0gJ3ZpZGVvJyA/IDAgOiB1bmRlZmluZWQsXG4gICAgICBpc0FBQzogdHlwZSA9PT0gJ2F1ZGlvJyA/IHRydWUgOiB1bmRlZmluZWQsXG4gICAgICBkdXJhdGlvbjogdHlwZSA9PT0gJ2F1ZGlvJyA/IGR1cmF0aW9uIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIG5ldyBpbml0IHNlZ21lbnQgb24gdGhlIGRlbXV4ZXIvcmVtdXhlciBpbnRlcmZhY2UuIE5lZWRlZCBmb3IgZGlzY29udGludWl0aWVzL3RyYWNrLXN3aXRjaGVzIChvciBhdCBzdHJlYW0gc3RhcnQpXG4gICAqIFJlc2V0cyBhbGwgaW50ZXJuYWwgdHJhY2sgaW5zdGFuY2VzIG9mIHRoZSBkZW11eGVyLlxuICAgKlxuICAgKiBAb3ZlcnJpZGUgSW1wbGVtZW50cyBnZW5lcmljIGRlbXV4aW5nL3JlbXV4aW5nIGludGVyZmFjZSAoc2VlIERlbXV4ZXJJbmxpbmUpXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbml0U2VnbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXVkaW9Db2RlY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdmlkZW9Db2RlY1xuICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gKGluIFRTIHRpbWVzY2FsZSA9IDkwa0h6KVxuICAgKi9cbiAgcmVzZXRJbml0U2VnbWVudCAoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XG4gICAgdGhpcy5wbXRQYXJzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wbXRJZCA9IC0xO1xuXG4gICAgdGhpcy5fYXZjVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ3ZpZGVvJywgZHVyYXRpb24pO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ2F1ZGlvJywgZHVyYXRpb24pO1xuICAgIHRoaXMuX2lkM1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCdpZDMnLCBkdXJhdGlvbik7XG4gICAgdGhpcy5fdHh0VHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ3RleHQnLCBkdXJhdGlvbik7XG5cbiAgICAvLyBmbHVzaCBhbnkgcGFydGlhbCBjb250ZW50XG4gICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgdGhpcy5hYWNMYXN0UFRTID0gbnVsbDtcbiAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb247XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICByZXNldFRpbWVTdGFtcCAoKSB7fVxuXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgYXBwZW5kIChkYXRhLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICBsZXQgc3RhcnQsIGxlbiA9IGRhdGEubGVuZ3RoLCBzdHQsIHBpZCwgYXRmLCBvZmZzZXQsIHBlcyxcbiAgICAgIHVua25vd25QSURzID0gZmFsc2U7XG4gICAgdGhpcy5jb250aWd1b3VzID0gY29udGlndW91cztcbiAgICBsZXQgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQsXG4gICAgICBhdmNUcmFjayA9IHRoaXMuX2F2Y1RyYWNrLFxuICAgICAgYXVkaW9UcmFjayA9IHRoaXMuX2F1ZGlvVHJhY2ssXG4gICAgICBpZDNUcmFjayA9IHRoaXMuX2lkM1RyYWNrLFxuICAgICAgYXZjSWQgPSBhdmNUcmFjay5waWQsXG4gICAgICBhdWRpb0lkID0gYXVkaW9UcmFjay5waWQsXG4gICAgICBpZDNJZCA9IGlkM1RyYWNrLnBpZCxcbiAgICAgIHBtdElkID0gdGhpcy5fcG10SWQsXG4gICAgICBhdmNEYXRhID0gYXZjVHJhY2sucGVzRGF0YSxcbiAgICAgIGF1ZGlvRGF0YSA9IGF1ZGlvVHJhY2sucGVzRGF0YSxcbiAgICAgIGlkM0RhdGEgPSBpZDNUcmFjay5wZXNEYXRhLFxuICAgICAgcGFyc2VQQVQgPSB0aGlzLl9wYXJzZVBBVCxcbiAgICAgIHBhcnNlUE1UID0gdGhpcy5fcGFyc2VQTVQsXG4gICAgICBwYXJzZVBFUyA9IHRoaXMuX3BhcnNlUEVTLFxuICAgICAgcGFyc2VBVkNQRVMgPSB0aGlzLl9wYXJzZUFWQ1BFUy5iaW5kKHRoaXMpLFxuICAgICAgcGFyc2VBQUNQRVMgPSB0aGlzLl9wYXJzZUFBQ1BFUy5iaW5kKHRoaXMpLFxuICAgICAgcGFyc2VNUEVHUEVTID0gdGhpcy5fcGFyc2VNUEVHUEVTLmJpbmQodGhpcyksXG4gICAgICBwYXJzZUlEM1BFUyA9IHRoaXMuX3BhcnNlSUQzUEVTLmJpbmQodGhpcyk7XG5cbiAgICBjb25zdCBzeW5jT2Zmc2V0ID0gVFNEZW11eGVyLl9zeW5jT2Zmc2V0KGRhdGEpO1xuXG4gICAgLy8gZG9uJ3QgcGFyc2UgbGFzdCBUUyBwYWNrZXQgaWYgaW5jb21wbGV0ZVxuICAgIGxlbiAtPSAobGVuICsgc3luY09mZnNldCkgJSAxODg7XG5cbiAgICAvLyBsb29wIHRocm91Z2ggVFMgcGFja2V0c1xuICAgIGZvciAoc3RhcnQgPSBzeW5jT2Zmc2V0OyBzdGFydCA8IGxlbjsgc3RhcnQgKz0gMTg4KSB7XG4gICAgICBpZiAoZGF0YVtzdGFydF0gPT09IDB4NDcpIHtcbiAgICAgICAgc3R0ID0gISEoZGF0YVtzdGFydCArIDFdICYgMHg0MCk7XG4gICAgICAgIC8vIHBpZCBpcyBhIDEzLWJpdCBmaWVsZCBzdGFydGluZyBhdCB0aGUgbGFzdCBiaXQgb2YgVFNbMV1cbiAgICAgICAgcGlkID0gKChkYXRhW3N0YXJ0ICsgMV0gJiAweDFmKSA8PCA4KSArIGRhdGFbc3RhcnQgKyAyXTtcbiAgICAgICAgYXRmID0gKGRhdGFbc3RhcnQgKyAzXSAmIDB4MzApID4+IDQ7XG4gICAgICAgIC8vIGlmIGFuIGFkYXB0aW9uIGZpZWxkIGlzIHByZXNlbnQsIGl0cyBsZW5ndGggaXMgc3BlY2lmaWVkIGJ5IHRoZSBmaWZ0aCBieXRlIG9mIHRoZSBUUyBwYWNrZXQgaGVhZGVyLlxuICAgICAgICBpZiAoYXRmID4gMSkge1xuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNSArIGRhdGFbc3RhcnQgKyA0XTtcbiAgICAgICAgICAvLyBjb250aW51ZSBpZiB0aGVyZSBpcyBvbmx5IGFkYXB0YXRpb24gZmllbGRcbiAgICAgICAgICBpZiAob2Zmc2V0ID09PSAoc3RhcnQgKyAxODgpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gc3RhcnQgKyA0O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocGlkKSB7XG4gICAgICAgIGNhc2UgYXZjSWQ6XG4gICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgaWYgKGF2Y0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF2Y0RhdGEpKSAmJiBwZXMucHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcGFyc2VBVkNQRVMocGVzLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF2Y0RhdGEgPSB7IGRhdGE6IFtdLCBzaXplOiAwIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdmNEYXRhKSB7XG4gICAgICAgICAgICBhdmNEYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyAxODgpKTtcbiAgICAgICAgICAgIGF2Y0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgYXVkaW9JZDpcbiAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICBpZiAoYXVkaW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdWRpb0RhdGEpKSAmJiBwZXMucHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGF1ZGlvVHJhY2suaXNBQUMpIHtcbiAgICAgICAgICAgICAgICBwYXJzZUFBQ1BFUyhwZXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlTVBFR1BFUyhwZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdWRpb0RhdGEgPSB7IGRhdGE6IFtdLCBzaXplOiAwIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdWRpb0RhdGEpIHtcbiAgICAgICAgICAgIGF1ZGlvRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICBhdWRpb0RhdGEuc2l6ZSArPSBzdGFydCArIDE4OCAtIG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQzSWQ6XG4gICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgaWYgKGlkM0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGlkM0RhdGEpKSAmJiBwZXMucHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcGFyc2VJRDNQRVMocGVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWQzRGF0YSA9IHsgZGF0YTogW10sIHNpemU6IDAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlkM0RhdGEpIHtcbiAgICAgICAgICAgIGlkM0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIDE4OCkpO1xuICAgICAgICAgICAgaWQzRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBkYXRhW29mZnNldF0gKyAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBtdElkID0gdGhpcy5fcG10SWQgPSBwYXJzZVBBVChkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHBtdElkOlxuICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBkYXRhW29mZnNldF0gKyAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBwYXJzZWRQSURzID0gcGFyc2VQTVQoZGF0YSwgb2Zmc2V0LCB0aGlzLnR5cGVTdXBwb3J0ZWQubXBlZyA9PT0gdHJ1ZSB8fCB0aGlzLnR5cGVTdXBwb3J0ZWQubXAzID09PSB0cnVlLCB0aGlzLnNhbXBsZUFlcyAhPSBudWxsKTtcblxuICAgICAgICAgIC8vIG9ubHkgdXBkYXRlIHRyYWNrIGlkIGlmIHRyYWNrIFBJRCBmb3VuZCB3aGlsZSBwYXJzaW5nIFBNVFxuICAgICAgICAgIC8vIHRoaXMgaXMgdG8gYXZvaWQgcmVzZXR0aW5nIHRoZSBQSUQgdG8gLTEgaW4gY2FzZVxuICAgICAgICAgIC8vIHRyYWNrIFBJRCB0cmFuc2llbnRseSBkaXNhcHBlYXJzIGZyb20gdGhlIHN0cmVhbVxuICAgICAgICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIGluIGNhc2Ugb2YgdHJhbnNpZW50IG1pc3NpbmcgYXVkaW8gc2FtcGxlcyBmb3IgZXhhbXBsZVxuICAgICAgICAgIC8vIE5PVEUgdGhpcyBpcyBvbmx5IHRoZSBQSUQgb2YgdGhlIHRyYWNrIGFzIGZvdW5kIGluIFRTLFxuICAgICAgICAgIC8vIGJ1dCB3ZSBhcmUgbm90IHVzaW5nIHRoaXMgZm9yIE1QNCB0cmFjayBJRHMuXG4gICAgICAgICAgYXZjSWQgPSBwYXJzZWRQSURzLmF2YztcbiAgICAgICAgICBpZiAoYXZjSWQgPiAwKSB7XG4gICAgICAgICAgICBhdmNUcmFjay5waWQgPSBhdmNJZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdWRpb0lkID0gcGFyc2VkUElEcy5hdWRpbztcbiAgICAgICAgICBpZiAoYXVkaW9JZCA+IDApIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhY2sucGlkID0gYXVkaW9JZDtcbiAgICAgICAgICAgIGF1ZGlvVHJhY2suaXNBQUMgPSBwYXJzZWRQSURzLmlzQUFDO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZDNJZCA9IHBhcnNlZFBJRHMuaWQzO1xuICAgICAgICAgIGlmIChpZDNJZCA+IDApIHtcbiAgICAgICAgICAgIGlkM1RyYWNrLnBpZCA9IGlkM0lkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1bmtub3duUElEcyAmJiAhcG10UGFyc2VkKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdyZXBhcnNlIGZyb20gYmVnaW5uaW5nJyk7XG4gICAgICAgICAgICB1bmtub3duUElEcyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gd2Ugc2V0IGl0IHRvIC0xODgsIHRoZSArPSAxODggaW4gdGhlIGZvciBsb29wIHdpbGwgcmVzZXQgc3RhcnQgdG8gMFxuICAgICAgICAgICAgc3RhcnQgPSBzeW5jT2Zmc2V0IC0gMTg4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBwbXRQYXJzZWQgPSB0aGlzLnBtdFBhcnNlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgIGNhc2UgMHgxZmZmOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHVua25vd25QSURzID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSwgcmVhc29uOiAnVFMgcGFja2V0IGRpZCBub3Qgc3RhcnQgd2l0aCAweDQ3JyB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdHJ5IHRvIHBhcnNlIGxhc3QgUEVTIHBhY2tldHNcbiAgICBpZiAoYXZjRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXZjRGF0YSkpICYmIHBlcy5wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyc2VBVkNQRVMocGVzLCB0cnVlKTtcbiAgICAgIGF2Y1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlaXRoZXIgYXZjRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICBhdmNUcmFjay5wZXNEYXRhID0gYXZjRGF0YTtcbiAgICB9XG5cbiAgICBpZiAoYXVkaW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdWRpb0RhdGEpKSAmJiBwZXMucHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChhdWRpb1RyYWNrLmlzQUFDKSB7XG4gICAgICAgIHBhcnNlQUFDUEVTKHBlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZU1QRUdQRVMocGVzKTtcbiAgICAgIH1cblxuICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGF1ZGlvRGF0YSAmJiBhdWRpb0RhdGEuc2l6ZSkge1xuICAgICAgICBsb2dnZXIubG9nKCdsYXN0IEFBQyBQRVMgcGFja2V0IHRydW5jYXRlZCxtaWdodCBvdmVybGFwIGJldHdlZW4gZnJhZ21lbnRzJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGVpdGhlciBhdWRpb0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gYXVkaW9EYXRhO1xuICAgIH1cblxuICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkgJiYgcGVzLnB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJzZUlEM1BFUyhwZXMpO1xuICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVpdGhlciBpZDNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBpZDNEYXRhO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNhbXBsZUFlcyA9PSBudWxsKSB7XG4gICAgICB0aGlzLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgYXZjVHJhY2ssIGlkM1RyYWNrLCB0aGlzLl90eHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWNyeXB0QW5kUmVtdXgoYXVkaW9UcmFjaywgYXZjVHJhY2ssIGlkM1RyYWNrLCB0aGlzLl90eHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICB9XG4gIH1cblxuICBkZWNyeXB0QW5kUmVtdXggKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIGlmIChhdWRpb1RyYWNrLnNhbXBsZXMgJiYgYXVkaW9UcmFjay5pc0FBQykge1xuICAgICAgbGV0IGxvY2FsdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLnNhbXBsZUFlcy5kZWNyeXB0QWFjU2FtcGxlcyhhdWRpb1RyYWNrLnNhbXBsZXMsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9jYWx0aGlzLmRlY3J5cHRBbmRSZW11eEF2YyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVjcnlwdEFuZFJlbXV4QXZjKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgfVxuICB9XG5cbiAgZGVjcnlwdEFuZFJlbXV4QXZjIChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzKSB7XG4gICAgICBsZXQgbG9jYWx0aGlzID0gdGhpcztcbiAgICAgIHRoaXMuc2FtcGxlQWVzLmRlY3J5cHRBdmNTYW1wbGVzKHZpZGVvVHJhY2suc2FtcGxlcywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2NhbHRoaXMucmVtdXhlci5yZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtdXhlci5yZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gMDtcbiAgfVxuXG4gIF9wYXJzZVBBVCAoZGF0YSwgb2Zmc2V0KSB7XG4gICAgLy8gc2tpcCB0aGUgUFNJIGhlYWRlciBhbmQgcGFyc2UgdGhlIGZpcnN0IFBNVCBlbnRyeVxuICAgIHJldHVybiAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDFGKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XG4gICAgLy8gbG9nZ2VyLmxvZygnUE1UIFBJRDonICArIHRoaXMuX3BtdElkKTtcbiAgfVxuXG4gIF9wYXJzZVBNVCAoZGF0YSwgb2Zmc2V0LCBtcGVnU3VwcG9ydGVkLCBpc1NhbXBsZUFlcykge1xuICAgIGxldCBzZWN0aW9uTGVuZ3RoLCB0YWJsZUVuZCwgcHJvZ3JhbUluZm9MZW5ndGgsIHBpZCwgcmVzdWx0ID0geyBhdWRpbzogLTEsIGF2YzogLTEsIGlkMzogLTEsIGlzQUFDOiB0cnVlIH07XG4gICAgc2VjdGlvbkxlbmd0aCA9IChkYXRhW29mZnNldCArIDFdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMl07XG4gICAgdGFibGVFbmQgPSBvZmZzZXQgKyAzICsgc2VjdGlvbkxlbmd0aCAtIDQ7XG4gICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXJlIHRoZSB0YWJsZSBpcywgd2UgaGF2ZSB0byBmaWd1cmUgb3V0IGhvd1xuICAgIC8vIGxvbmcgdGhlIHByb2dyYW0gaW5mbyBkZXNjcmlwdG9ycyBhcmVcbiAgICBwcm9ncmFtSW5mb0xlbmd0aCA9IChkYXRhW29mZnNldCArIDEwXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDExXTtcbiAgICAvLyBhZHZhbmNlIHRoZSBvZmZzZXQgdG8gdGhlIGZpcnN0IGVudHJ5IGluIHRoZSBtYXBwaW5nIHRhYmxlXG4gICAgb2Zmc2V0ICs9IDEyICsgcHJvZ3JhbUluZm9MZW5ndGg7XG4gICAgd2hpbGUgKG9mZnNldCA8IHRhYmxlRW5kKSB7XG4gICAgICBwaWQgPSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MUYpIDw8IDggfCBkYXRhW29mZnNldCArIDJdO1xuICAgICAgc3dpdGNoIChkYXRhW29mZnNldF0pIHtcbiAgICAgIGNhc2UgMHhjZjogLy8gU0FNUExFLUFFUyBBQUNcbiAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ3Vua293biBzdHJlYW0gdHlwZTonICsgZGF0YVtvZmZzZXRdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG5cbiAgICAgICAgLy8gSVNPL0lFQyAxMzgxOC03IEFEVFMgQUFDIChNUEVHLTIgbG93ZXIgYml0LXJhdGUgYXVkaW8pXG4gICAgICBjYXNlIDB4MGY6XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0FBQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LmF1ZGlvID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IHBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIFBhY2tldGl6ZWQgbWV0YWRhdGEgKElEMylcbiAgICAgIGNhc2UgMHgxNTpcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnSUQzIFBJRDonICArIHBpZCk7XG4gICAgICAgIGlmIChyZXN1bHQuaWQzID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5pZDMgPSBwaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAweGRiOiAvLyBTQU1QTEUtQUVTIEFWQ1xuICAgICAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygndW5rb3duIHN0cmVhbSB0eXBlOicgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgICAgICAvLyBJVFUtVCBSZWMuIEguMjY0IGFuZCBJU08vSUVDIDE0NDk2LTEwIChsb3dlciBiaXQtcmF0ZSB2aWRlbylcbiAgICAgIGNhc2UgMHgxYjpcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnQVZDIFBJRDonICArIHBpZCk7XG4gICAgICAgIGlmIChyZXN1bHQuYXZjID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5hdmMgPSBwaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBJU08vSUVDIDExMTcyLTMgKE1QRUctMSBhdWRpbylcbiAgICAgICAgLy8gb3IgSVNPL0lFQyAxMzgxOC0zIChNUEVHLTIgaGFsdmVkIHNhbXBsZSByYXRlIGF1ZGlvKVxuICAgICAgY2FzZSAweDAzOlxuICAgICAgY2FzZSAweDA0OlxuICAgICAgICAvLyBsb2dnZXIubG9nKCdNUEVHIFBJRDonICArIHBpZCk7XG4gICAgICAgIGlmICghbXBlZ1N1cHBvcnRlZCkge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ01QRUcgYXVkaW8gZm91bmQsIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyIGZvciBub3cnKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuYXVkaW8gPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmF1ZGlvID0gcGlkO1xuICAgICAgICAgIHJlc3VsdC5pc0FBQyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4MjQ6XG4gICAgICAgIGxvZ2dlci53YXJuKCdIRVZDIHN0cmVhbSB0eXBlIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGZvciBub3cnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxvZ2dlci5sb2coJ3Vua293biBzdHJlYW0gdHlwZTonICsgZGF0YVtvZmZzZXRdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBtb3ZlIHRvIHRoZSBuZXh0IHRhYmxlIGVudHJ5XG4gICAgICAvLyBza2lwIHBhc3QgdGhlIGVsZW1lbnRhcnkgc3RyZWFtIGRlc2NyaXB0b3JzLCBpZiBwcmVzZW50XG4gICAgICBvZmZzZXQgKz0gKChkYXRhW29mZnNldCArIDNdICYgMHgwRikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgNF0pICsgNTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIF9wYXJzZVBFUyAoc3RyZWFtKSB7XG4gICAgbGV0IGkgPSAwLCBmcmFnLCBwZXNGbGFncywgcGVzUHJlZml4LCBwZXNMZW4sIHBlc0hkckxlbiwgcGVzRGF0YSwgcGVzUHRzLCBwZXNEdHMsIHBheWxvYWRTdGFydE9mZnNldCwgZGF0YSA9IHN0cmVhbS5kYXRhO1xuICAgIC8vIHNhZmV0eSBjaGVja1xuICAgIGlmICghc3RyZWFtIHx8IHN0cmVhbS5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyB3ZSBtaWdodCBuZWVkIHVwIHRvIDE5IGJ5dGVzIHRvIHJlYWQgUEVTIGhlYWRlclxuICAgIC8vIGlmIGZpcnN0IGNodW5rIG9mIGRhdGEgaXMgbGVzcyB0aGFuIDE5IGJ5dGVzLCBsZXQncyBtZXJnZSBpdCB3aXRoIGZvbGxvd2luZyBvbmVzIHVudGlsIHdlIGdldCAxOSBieXRlc1xuICAgIC8vIHVzdWFsbHkgb25seSBvbmUgbWVyZ2UgaXMgbmVlZGVkIChhbmQgdGhpcyBpcyByYXJlIC4uLilcbiAgICB3aGlsZSAoZGF0YVswXS5sZW5ndGggPCAxOSAmJiBkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxldCBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YVswXS5sZW5ndGggKyBkYXRhWzFdLmxlbmd0aCk7XG4gICAgICBuZXdEYXRhLnNldChkYXRhWzBdKTtcbiAgICAgIG5ld0RhdGEuc2V0KGRhdGFbMV0sIGRhdGFbMF0ubGVuZ3RoKTtcbiAgICAgIGRhdGFbMF0gPSBuZXdEYXRhO1xuICAgICAgZGF0YS5zcGxpY2UoMSwgMSk7XG4gICAgfVxuICAgIC8vIHJldHJpZXZlIFBUUy9EVFMgZnJvbSBmaXJzdCBmcmFnbWVudFxuICAgIGZyYWcgPSBkYXRhWzBdO1xuICAgIHBlc1ByZWZpeCA9IChmcmFnWzBdIDw8IDE2KSArIChmcmFnWzFdIDw8IDgpICsgZnJhZ1syXTtcbiAgICBpZiAocGVzUHJlZml4ID09PSAxKSB7XG4gICAgICBwZXNMZW4gPSAoZnJhZ1s0XSA8PCA4KSArIGZyYWdbNV07XG4gICAgICAvLyBpZiBQRVMgcGFyc2VkIGxlbmd0aCBpcyBub3QgemVybyBhbmQgZ3JlYXRlciB0aGFuIHRvdGFsIHJlY2VpdmVkIGxlbmd0aCwgc3RvcCBwYXJzaW5nLiBQRVMgbWlnaHQgYmUgdHJ1bmNhdGVkXG4gICAgICAvLyBtaW51cyA2IDogUEVTIGhlYWRlciBzaXplXG4gICAgICBpZiAocGVzTGVuICYmIHBlc0xlbiA+IHN0cmVhbS5zaXplIC0gNikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcGVzRmxhZ3MgPSBmcmFnWzddO1xuICAgICAgaWYgKHBlc0ZsYWdzICYgMHhDMCkge1xuICAgICAgICAvKiBQRVMgaGVhZGVyIGRlc2NyaWJlZCBoZXJlIDogaHR0cDovL2R2ZC5zb3VyY2Vmb3JnZS5uZXQvZHZkaW5mby9wZXMtaGRyLmh0bWxcbiAgICAgICAgICAgIGFzIFBUUyAvIERUUyBpcyAzMyBiaXQgd2UgY2Fubm90IHVzZSBiaXR3aXNlIG9wZXJhdG9yIGluIEpTLFxuICAgICAgICAgICAgYXMgQml0d2lzZSBvcGVyYXRvcnMgdHJlYXQgdGhlaXIgb3BlcmFuZHMgYXMgYSBzZXF1ZW5jZSBvZiAzMiBiaXRzICovXG4gICAgICAgIHBlc1B0cyA9IChmcmFnWzldICYgMHgwRSkgKiA1MzY4NzA5MTIgKy8vIDEgPDwgMjlcbiAgICAgICAgICAoZnJhZ1sxMF0gJiAweEZGKSAqIDQxOTQzMDQgKy8vIDEgPDwgMjJcbiAgICAgICAgICAoZnJhZ1sxMV0gJiAweEZFKSAqIDE2Mzg0ICsvLyAxIDw8IDE0XG4gICAgICAgICAgKGZyYWdbMTJdICYgMHhGRikgKiAxMjggKy8vIDEgPDwgN1xuICAgICAgICAgIChmcmFnWzEzXSAmIDB4RkUpIC8gMjtcbiAgICAgICAgLy8gY2hlY2sgaWYgZ3JlYXRlciB0aGFuIDJeMzIgLTFcbiAgICAgICAgaWYgKHBlc1B0cyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAvLyBkZWNyZW1lbnQgMl4zM1xuICAgICAgICAgIHBlc1B0cyAtPSA4NTg5OTM0NTkyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXNGbGFncyAmIDB4NDApIHtcbiAgICAgICAgICBwZXNEdHMgPSAoZnJhZ1sxNF0gJiAweDBFKSAqIDUzNjg3MDkxMiArLy8gMSA8PCAyOVxuICAgICAgICAgICAgKGZyYWdbMTVdICYgMHhGRikgKiA0MTk0MzA0ICsvLyAxIDw8IDIyXG4gICAgICAgICAgICAoZnJhZ1sxNl0gJiAweEZFKSAqIDE2Mzg0ICsvLyAxIDw8IDE0XG4gICAgICAgICAgICAoZnJhZ1sxN10gJiAweEZGKSAqIDEyOCArLy8gMSA8PCA3XG4gICAgICAgICAgICAoZnJhZ1sxOF0gJiAweEZFKSAvIDI7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgZ3JlYXRlciB0aGFuIDJeMzIgLTFcbiAgICAgICAgICBpZiAocGVzRHRzID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgLy8gZGVjcmVtZW50IDJeMzNcbiAgICAgICAgICAgIHBlc0R0cyAtPSA4NTg5OTM0NTkyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGVzUHRzIC0gcGVzRHRzID4gNjAgKiA5MDAwMCkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYCR7TWF0aC5yb3VuZCgocGVzUHRzIC0gcGVzRHRzKSAvIDkwMDAwKX1zIGRlbHRhIGJldHdlZW4gUFRTIGFuZCBEVFMsIGFsaWduIHRoZW1gKTtcbiAgICAgICAgICAgIHBlc1B0cyA9IHBlc0R0cztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVzRHRzID0gcGVzUHRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZXNIZHJMZW4gPSBmcmFnWzhdO1xuICAgICAgLy8gOSBieXRlcyA6IDYgYnl0ZXMgZm9yIFBFUyBoZWFkZXIgKyAzIGJ5dGVzIGZvciBQRVMgZXh0ZW5zaW9uXG4gICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSBwZXNIZHJMZW4gKyA5O1xuXG4gICAgICBzdHJlYW0uc2l6ZSAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgICAvLyByZWFzc2VtYmxlIFBFUyBwYWNrZXRcbiAgICAgIHBlc0RhdGEgPSBuZXcgVWludDhBcnJheShzdHJlYW0uc2l6ZSk7XG4gICAgICBmb3IgKGxldCBqID0gMCwgZGF0YUxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgZGF0YUxlbjsgaisrKSB7XG4gICAgICAgIGZyYWcgPSBkYXRhW2pdO1xuICAgICAgICBsZXQgbGVuID0gZnJhZy5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgaWYgKHBheWxvYWRTdGFydE9mZnNldCA+IGxlbikge1xuICAgICAgICAgICAgLy8gdHJpbSBmdWxsIGZyYWcgaWYgUEVTIGhlYWRlciBiaWdnZXIgdGhhbiBmcmFnXG4gICAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgLT0gbGVuO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRyaW0gcGFydGlhbCBmcmFnIGlmIFBFUyBoZWFkZXIgc21hbGxlciB0aGFuIGZyYWdcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnLnN1YmFycmF5KHBheWxvYWRTdGFydE9mZnNldCk7XG4gICAgICAgICAgICBsZW4gLT0gcGF5bG9hZFN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGVzRGF0YS5zZXQoZnJhZywgaSk7XG4gICAgICAgIGkgKz0gbGVuO1xuICAgICAgfVxuICAgICAgaWYgKHBlc0xlbikge1xuICAgICAgICAvLyBwYXlsb2FkIHNpemUgOiByZW1vdmUgUEVTIGhlYWRlciArIFBFUyBleHRlbnNpb25cbiAgICAgICAgcGVzTGVuIC09IHBlc0hkckxlbiArIDM7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBkYXRhOiBwZXNEYXRhLCBwdHM6IHBlc1B0cywgZHRzOiBwZXNEdHMsIGxlbjogcGVzTGVuIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hBY2Nlc1VuaXQgKGF2Y1NhbXBsZSwgYXZjVHJhY2spIHtcbiAgICBpZiAoYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCAmJiBhdmNTYW1wbGUuZnJhbWUpIHtcbiAgICAgIGNvbnN0IHNhbXBsZXMgPSBhdmNUcmFjay5zYW1wbGVzO1xuICAgICAgY29uc3QgbmJTYW1wbGVzID0gc2FtcGxlcy5sZW5ndGg7XG4gICAgICAvLyBvbmx5IHB1c2ggQVZDIHNhbXBsZSBpZiBzdGFydGluZyB3aXRoIGEga2V5ZnJhbWUgaXMgbm90IG1hbmRhdG9yeSBPUlxuICAgICAgLy8gICAgaWYga2V5ZnJhbWUgYWxyZWFkeSBmb3VuZCBpbiB0aGlzIGZyYWdtZW50IE9SXG4gICAgICAvLyAgICAgICBrZXlmcmFtZSBmb3VuZCBpbiBsYXN0IGZyYWdtZW50ICh0cmFjay5zcHMpIEFORFxuICAgICAgLy8gICAgICAgICAgc2FtcGxlcyBhbHJlYWR5IGFwcGVuZGVkICh3ZSBhbHJlYWR5IGZvdW5kIGEga2V5ZnJhbWUgaW4gdGhpcyBmcmFnbWVudCkgT1IgZnJhZ21lbnQgaXMgY29udGlndW91c1xuICAgICAgaWYgKCF0aGlzLmNvbmZpZy5mb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5IHx8XG4gICAgICAgICAgYXZjU2FtcGxlLmtleSA9PT0gdHJ1ZSB8fFxuICAgICAgICAgIChhdmNUcmFjay5zcHMgJiYgKG5iU2FtcGxlcyB8fCB0aGlzLmNvbnRpZ3VvdXMpKSkge1xuICAgICAgICBhdmNTYW1wbGUuaWQgPSBuYlNhbXBsZXM7XG4gICAgICAgIHNhbXBsZXMucHVzaChhdmNTYW1wbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZHJvcHBlZCBzYW1wbGVzLCB0cmFjayBpdFxuICAgICAgICBhdmNUcmFjay5kcm9wcGVkKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdmNTYW1wbGUuZGVidWcubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIubG9nKGF2Y1NhbXBsZS5wdHMgKyAnLycgKyBhdmNTYW1wbGUuZHRzICsgJzonICsgYXZjU2FtcGxlLmRlYnVnKTtcbiAgICB9XG4gIH1cblxuICBfcGFyc2VBVkNQRVMgKHBlcywgbGFzdCkge1xuICAgIC8vIGxvZ2dlci5sb2coJ3BhcnNlIG5ldyBQRVMnKTtcbiAgICBsZXQgdHJhY2sgPSB0aGlzLl9hdmNUcmFjayxcbiAgICAgIHVuaXRzID0gdGhpcy5fcGFyc2VBVkNOQUx1KHBlcy5kYXRhKSxcbiAgICAgIGRlYnVnID0gZmFsc2UsXG4gICAgICBleHBHb2xvbWJEZWNvZGVyLFxuICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUsXG4gICAgICBwdXNoLFxuICAgICAgc3BzZm91bmQgPSBmYWxzZSxcbiAgICAgIGksXG4gICAgICBwdXNoQWNjZXNVbml0ID0gdGhpcy5wdXNoQWNjZXNVbml0LmJpbmQodGhpcyksXG4gICAgICBjcmVhdGVBVkNTYW1wbGUgPSBmdW5jdGlvbiAoa2V5LCBwdHMsIGR0cywgZGVidWcpIHtcbiAgICAgICAgcmV0dXJuIHsga2V5OiBrZXksIHB0czogcHRzLCBkdHM6IGR0cywgdW5pdHM6IFtdLCBkZWJ1ZzogZGVidWcgfTtcbiAgICAgIH07XG4gICAgLy8gZnJlZSBwZXMuZGF0YSB0byBzYXZlIHVwIHNvbWUgbWVtb3J5XG4gICAgcGVzLmRhdGEgPSBudWxsO1xuXG4gICAgLy8gaWYgbmV3IE5BTCB1bml0cyBmb3VuZCBhbmQgbGFzdCBzYW1wbGUgc3RpbGwgdGhlcmUsIGxldCdzIHB1c2ggLi4uXG4gICAgLy8gdGhpcyBoZWxwcyBwYXJzaW5nIHN0cmVhbXMgd2l0aCBtaXNzaW5nIEFVRCAob25seSBkbyB0aGlzIGlmIEFVRCBuZXZlciBmb3VuZClcbiAgICBpZiAoYXZjU2FtcGxlICYmIHVuaXRzLmxlbmd0aCAmJiAhdHJhY2suYXVkRm91bmQpIHtcbiAgICAgIHB1c2hBY2Nlc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICBhdmNTYW1wbGUgPSB0aGlzLmF2Y1NhbXBsZSA9IGNyZWF0ZUFWQ1NhbXBsZShmYWxzZSwgcGVzLnB0cywgcGVzLmR0cywgJycpO1xuICAgIH1cblxuICAgIHVuaXRzLmZvckVhY2godW5pdCA9PiB7XG4gICAgICBzd2l0Y2ggKHVuaXQudHlwZSkge1xuICAgICAgLy8gTkRSXG4gICAgICBjYXNlIDE6XG4gICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICBpZiAoIWF2Y1NhbXBsZSkge1xuICAgICAgICAgIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKHRydWUsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnTkRSICc7XG4gICAgICAgIH1cblxuICAgICAgICBhdmNTYW1wbGUuZnJhbWUgPSB0cnVlO1xuICAgICAgICBsZXQgZGF0YSA9IHVuaXQuZGF0YTtcbiAgICAgICAgLy8gb25seSBjaGVjayBzbGljZSB0eXBlIHRvIGRldGVjdCBLRiBpbiBjYXNlIFNQUyBmb3VuZCBpbiBzYW1lIHBhY2tldCAoYW55IGtleWZyYW1lIGlzIHByZWNlZGVkIGJ5IFNQUyAuLi4pXG4gICAgICAgIGlmIChzcHNmb3VuZCAmJiBkYXRhLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAvLyByZXRyaWV2ZSBzbGljZSB0eXBlIGJ5IHBhcnNpbmcgYmVnaW5uaW5nIG9mIE5BTCB1bml0IChmb2xsb3cgSDI2NCBzcGVjLCBzbGljZV9oZWFkZXIgZGVmaW5pdGlvbikgdG8gZGV0ZWN0IGtleWZyYW1lIGVtYmVkZGVkIGluIE5EUlxuICAgICAgICAgIGxldCBzbGljZVR5cGUgPSBuZXcgRXhwR29sb21iKGRhdGEpLnJlYWRTbGljZVR5cGUoKTtcbiAgICAgICAgICAvLyAyIDogSSBzbGljZSwgNCA6IFNJIHNsaWNlLCA3IDogSSBzbGljZSwgOTogU0kgc2xpY2VcbiAgICAgICAgICAvLyBTSSBzbGljZSA6IEEgc2xpY2UgdGhhdCBpcyBjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkgYW5kIHVzaW5nIHF1YW50aXNhdGlvbiBvZiB0aGUgcHJlZGljdGlvbiBzYW1wbGVzLlxuICAgICAgICAgIC8vIEFuIFNJIHNsaWNlIGNhbiBiZSBjb2RlZCBzdWNoIHRoYXQgaXRzIGRlY29kZWQgc2FtcGxlcyBjYW4gYmUgY29uc3RydWN0ZWQgaWRlbnRpY2FsbHkgdG8gYW4gU1Agc2xpY2UuXG4gICAgICAgICAgLy8gSSBzbGljZTogQSBzbGljZSB0aGF0IGlzIG5vdCBhbiBTSSBzbGljZSB0aGF0IGlzIGRlY29kZWQgdXNpbmcgaW50cmEgcHJlZGljdGlvbiBvbmx5LlxuICAgICAgICAgIC8vIGlmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA3KSB7XG4gICAgICAgICAgaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDQgfHwgc2xpY2VUeXBlID09PSA3IHx8IHNsaWNlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgYXZjU2FtcGxlLmtleSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBJRFJcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgIC8vIGhhbmRsZSBQRVMgbm90IHN0YXJ0aW5nIHdpdGggQVVEXG4gICAgICAgIGlmICghYXZjU2FtcGxlKSB7XG4gICAgICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUgPSBjcmVhdGVBVkNTYW1wbGUodHJ1ZSwgcGVzLnB0cywgcGVzLmR0cywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdJRFIgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGF2Y1NhbXBsZS5rZXkgPSB0cnVlO1xuICAgICAgICBhdmNTYW1wbGUuZnJhbWUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgICAgLy8gU0VJXG4gICAgICBjYXNlIDY6XG4gICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICBpZiAoZGVidWcgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdTRUkgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cEdvbG9tYkRlY29kZXIgPSBuZXcgRXhwR29sb21iKHRoaXMuZGlzY2FyZEVQQih1bml0LmRhdGEpKTtcblxuICAgICAgICAvLyBza2lwIGZyYW1lVHlwZVxuICAgICAgICBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuXG4gICAgICAgIHZhciBwYXlsb2FkVHlwZSA9IDA7XG4gICAgICAgIHZhciBwYXlsb2FkU2l6ZSA9IDA7XG4gICAgICAgIHZhciBlbmRPZkNhcHRpb25zID0gZmFsc2U7XG4gICAgICAgIHZhciBiID0gMDtcblxuICAgICAgICB3aGlsZSAoIWVuZE9mQ2FwdGlvbnMgJiYgZXhwR29sb21iRGVjb2Rlci5ieXRlc0F2YWlsYWJsZSA+IDEpIHtcbiAgICAgICAgICBwYXlsb2FkVHlwZSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgYiA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICBwYXlsb2FkVHlwZSArPSBiO1xuICAgICAgICAgIH0gd2hpbGUgKGIgPT09IDB4RkYpO1xuXG4gICAgICAgICAgLy8gUGFyc2UgcGF5bG9hZCBzaXplLlxuICAgICAgICAgIHBheWxvYWRTaXplID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBiID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgIHBheWxvYWRTaXplICs9IGI7XG4gICAgICAgICAgfSB3aGlsZSAoYiA9PT0gMHhGRik7XG5cbiAgICAgICAgICAvLyBUT0RPOiB0aGVyZSBjYW4gYmUgbW9yZSB0aGFuIG9uZSBwYXlsb2FkIGluIGFuIFNFSSBwYWNrZXQuLi5cbiAgICAgICAgICAvLyBUT0RPOiBuZWVkIHRvIHJlYWQgdHlwZSBhbmQgc2l6ZSBpbiBhIHdoaWxlIGxvb3AgdG8gZ2V0IHRoZW0gYWxsXG4gICAgICAgICAgaWYgKHBheWxvYWRUeXBlID09PSA0ICYmIGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUgIT09IDApIHtcbiAgICAgICAgICAgIGVuZE9mQ2FwdGlvbnMgPSB0cnVlO1xuXG4gICAgICAgICAgICBsZXQgY291bnRyeUNvZGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuXG4gICAgICAgICAgICBpZiAoY291bnRyeUNvZGUgPT09IDE4MSkge1xuICAgICAgICAgICAgICBsZXQgcHJvdmlkZXJDb2RlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVVNob3J0KCk7XG5cbiAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyQ29kZSA9PT0gNDkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdXNlclN0cnVjdHVyZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVJbnQoKTtcblxuICAgICAgICAgICAgICAgIGlmICh1c2VyU3RydWN0dXJlID09PSAweDQ3NDEzOTM0KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgdXNlckRhdGFUeXBlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcblxuICAgICAgICAgICAgICAgICAgLy8gUmF3IENFQS02MDggYnl0ZXMgd3JhcHBlZCBpbiBDRUEtNzA4IHBhY2tldFxuICAgICAgICAgICAgICAgICAgaWYgKHVzZXJEYXRhVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmlyc3RCeXRlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlY29uZEJ5dGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3RhbENDcyA9IDMxICYgZmlyc3RCeXRlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYnl0ZUFycmF5ID0gW2ZpcnN0Qnl0ZSwgc2Vjb25kQnl0ZV07XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvdGFsQ0NzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyAzIGJ5dGVzIHBlciBDQ1xuICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5zZXJ0U2FtcGxlSW5PcmRlcih0aGlzLl90eHRUcmFjay5zYW1wbGVzLCB7IHR5cGU6IDMsIHB0czogcGVzLnB0cywgYnl0ZXM6IGJ5dGVBcnJheSB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWRTaXplIDwgZXhwR29sb21iRGVjb2Rlci5ieXRlc0F2YWlsYWJsZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBheWxvYWRTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFNQU1xuICAgICAgY2FzZSA3OlxuICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgc3BzZm91bmQgPSB0cnVlO1xuICAgICAgICBpZiAoZGVidWcgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdTUFMgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdHJhY2suc3BzKSB7XG4gICAgICAgICAgZXhwR29sb21iRGVjb2RlciA9IG5ldyBFeHBHb2xvbWIodW5pdC5kYXRhKTtcbiAgICAgICAgICBsZXQgY29uZmlnID0gZXhwR29sb21iRGVjb2Rlci5yZWFkU1BTKCk7XG4gICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgICAgICAgdHJhY2suaGVpZ2h0ID0gY29uZmlnLmhlaWdodDtcbiAgICAgICAgICB0cmFjay5waXhlbFJhdGlvID0gY29uZmlnLnBpeGVsUmF0aW87XG4gICAgICAgICAgdHJhY2suc3BzID0gW3VuaXQuZGF0YV07XG4gICAgICAgICAgdHJhY2suZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICAgICAgICBsZXQgY29kZWNhcnJheSA9IHVuaXQuZGF0YS5zdWJhcnJheSgxLCA0KTtcbiAgICAgICAgICBsZXQgY29kZWNzdHJpbmcgPSAnYXZjMS4nO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBoID0gY29kZWNhcnJheVtpXS50b1N0cmluZygxNik7XG4gICAgICAgICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgIGggPSAnMCcgKyBoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb2RlY3N0cmluZyArPSBoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmFjay5jb2RlYyA9IGNvZGVjc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBQUFNcbiAgICAgIGNhc2UgODpcbiAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ1BQUyAnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0cmFjay5wcHMpIHtcbiAgICAgICAgICB0cmFjay5wcHMgPSBbdW5pdC5kYXRhXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBBVURcbiAgICAgIGNhc2UgOTpcbiAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICB0cmFjay5hdWRGb3VuZCA9IHRydWU7XG4gICAgICAgIGlmIChhdmNTYW1wbGUpIHtcbiAgICAgICAgICBwdXNoQWNjZXNVbml0KGF2Y1NhbXBsZSwgdHJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUgPSBjcmVhdGVBVkNTYW1wbGUoZmFsc2UsIHBlcy5wdHMsIHBlcy5kdHMsIGRlYnVnID8gJ0FVRCAnIDogJycpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgLy8gRmlsbGVyIERhdGFcbiAgICAgIGNhc2UgMTI6XG4gICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgIGlmIChhdmNTYW1wbGUpIHtcbiAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ3Vua25vd24gTkFMICcgKyB1bml0LnR5cGUgKyAnICc7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChhdmNTYW1wbGUgJiYgcHVzaCkge1xuICAgICAgICBsZXQgdW5pdHMgPSBhdmNTYW1wbGUudW5pdHM7XG4gICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gaWYgbGFzdCBQRVMgcGFja2V0LCBwdXNoIHNhbXBsZXNcbiAgICBpZiAobGFzdCAmJiBhdmNTYW1wbGUpIHtcbiAgICAgIHB1c2hBY2Nlc1VuaXQoYXZjU2FtcGxlLCB0cmFjayk7XG4gICAgICB0aGlzLmF2Y1NhbXBsZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgX2luc2VydFNhbXBsZUluT3JkZXIgKGFyciwgZGF0YSkge1xuICAgIGxldCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICBpZiAoZGF0YS5wdHMgPj0gYXJyW2xlbiAtIDFdLnB0cykge1xuICAgICAgICBhcnIucHVzaChkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IGxlbiAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICAgIGlmIChkYXRhLnB0cyA8IGFycltwb3NdLnB0cykge1xuICAgICAgICAgICAgYXJyLnNwbGljZShwb3MsIDAsIGRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyci5wdXNoKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRMYXN0TmFsVW5pdCAoKSB7XG4gICAgbGV0IGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlLCBsYXN0VW5pdDtcbiAgICAvLyB0cnkgdG8gZmFsbGJhY2sgdG8gcHJldmlvdXMgc2FtcGxlIGlmIGN1cnJlbnQgb25lIGlzIGVtcHR5XG4gICAgaWYgKCFhdmNTYW1wbGUgfHwgYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbGV0IHRyYWNrID0gdGhpcy5fYXZjVHJhY2ssIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgICAgYXZjU2FtcGxlID0gc2FtcGxlc1tzYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBpZiAoYXZjU2FtcGxlKSB7XG4gICAgICBsZXQgdW5pdHMgPSBhdmNTYW1wbGUudW5pdHM7XG4gICAgICBsYXN0VW5pdCA9IHVuaXRzW3VuaXRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdFVuaXQ7XG4gIH1cblxuICBfcGFyc2VBVkNOQUx1IChhcnJheSkge1xuICAgIGxldCBpID0gMCwgbGVuID0gYXJyYXkuYnl0ZUxlbmd0aCwgdmFsdWUsIG92ZXJmbG93LCB0cmFjayA9IHRoaXMuX2F2Y1RyYWNrLCBzdGF0ZSA9IHRyYWNrLm5hbHVTdGF0ZSB8fCAwLCBsYXN0U3RhdGUgPSBzdGF0ZTtcbiAgICBsZXQgdW5pdHMgPSBbXSwgdW5pdCwgdW5pdFR5cGUsIGxhc3RVbml0U3RhcnQgPSAtMSwgbGFzdFVuaXRUeXBlO1xuICAgIC8vIGxvZ2dlci5sb2coJ1BFUzonICsgSGV4LmhleER1bXAoYXJyYXkpKTtcblxuICAgIGlmIChzdGF0ZSA9PT0gLTEpIHtcbiAgICAvLyBzcGVjaWFsIHVzZSBjYXNlIHdoZXJlIHdlIGZvdW5kIDMgb3IgNC1ieXRlIHN0YXJ0IGNvZGVzIGV4YWN0bHkgYXQgdGhlIGVuZCBvZiBwcmV2aW91cyBQRVMgcGFja2V0XG4gICAgICBsYXN0VW5pdFN0YXJ0ID0gMDtcbiAgICAgIC8vIE5BTHUgdHlwZSBpcyB2YWx1ZSByZWFkIGZyb20gb2Zmc2V0IDBcbiAgICAgIGxhc3RVbml0VHlwZSA9IGFycmF5WzBdICYgMHgxZjtcbiAgICAgIHN0YXRlID0gMDtcbiAgICAgIGkgPSAxO1xuICAgIH1cblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICB2YWx1ZSA9IGFycmF5W2krK107XG4gICAgICAvLyBvcHRpbWl6YXRpb24uIHN0YXRlIDAgYW5kIDEgYXJlIHRoZSBwcmVkb21pbmFudCBjYXNlLiBsZXQncyBoYW5kbGUgdGhlbSBvdXRzaWRlIG9mIHRoZSBzd2l0Y2gvY2FzZVxuICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09PSAxKSB7XG4gICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBoZXJlIHdlIGhhdmUgc3RhdGUgZWl0aGVyIGVxdWFsIHRvIDIgb3IgM1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAxKSB7XG4gICAgICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49IDApIHtcbiAgICAgICAgICB1bml0ID0geyBkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBpIC0gc3RhdGUgLSAxKSwgdHlwZTogbGFzdFVuaXRUeXBlIH07XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygncHVzaGluZyBOQUxVLCB0eXBlL3NpemU6JyArIHVuaXQudHlwZSArICcvJyArIHVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICB1bml0cy5wdXNoKHVuaXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxhc3RVbml0U3RhcnQgaXMgdW5kZWZpbmVkID0+IHRoaXMgaXMgdGhlIGZpcnN0IHN0YXJ0IGNvZGUgZm91bmQgaW4gdGhpcyBQRVMgcGFja2V0XG4gICAgICAgICAgLy8gZmlyc3QgY2hlY2sgaWYgc3RhcnQgY29kZSBkZWxpbWl0ZXIgaXMgb3ZlcmxhcHBpbmcgYmV0d2VlbiAyIFBFUyBwYWNrZXRzLFxuICAgICAgICAgIC8vIGllIGl0IHN0YXJ0ZWQgaW4gbGFzdCBwYWNrZXQgKGxhc3RTdGF0ZSBub3QgemVybylcbiAgICAgICAgICAvLyBhbmQgZW5kZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIFBFUyBwYWNrZXQgKGkgPD0gNCAtIGxhc3RTdGF0ZSlcbiAgICAgICAgICBsZXQgbGFzdFVuaXQgPSB0aGlzLl9nZXRMYXN0TmFsVW5pdCgpO1xuICAgICAgICAgIGlmIChsYXN0VW5pdCkge1xuICAgICAgICAgICAgaWYgKGxhc3RTdGF0ZSAmJiAoaSA8PSA0IC0gbGFzdFN0YXRlKSkge1xuICAgICAgICAgICAgICAvLyBzdGFydCBkZWxpbWl0ZXIgb3ZlcmxhcHBpbmcgYmV0d2VlbiBQRVMgcGFja2V0c1xuICAgICAgICAgICAgICAvLyBzdHJpcCBzdGFydCBkZWxpbWl0ZXIgYnl0ZXMgZnJvbSB0aGUgZW5kIG9mIGxhc3QgTkFMIHVuaXRcbiAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgbGFzdFVuaXQgaGFkIGEgc3RhdGUgZGlmZmVyZW50IGZyb20gemVyb1xuICAgICAgICAgICAgICBpZiAobGFzdFVuaXQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBzdHJpcCBsYXN0IGJ5dGVzXG4gICAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IGxhc3RVbml0LmRhdGEuc3ViYXJyYXkoMCwgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoIC0gbGFzdFN0YXRlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgTkFMIHVuaXRzIGFyZSBub3Qgc3RhcnRpbmcgcmlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBhY2tldCwgcHVzaCBwcmVjZWRpbmcgZGF0YSBpbnRvIHByZXZpb3VzIE5BTCB1bml0LlxuICAgICAgICAgICAgb3ZlcmZsb3cgPSBpIC0gc3RhdGUgLSAxO1xuICAgICAgICAgICAgaWYgKG92ZXJmbG93ID4gMCkge1xuICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdmaXJzdCBOQUxVIGZvdW5kIHdpdGggb3ZlcmZsb3c6JyArIG92ZXJmbG93KTtcbiAgICAgICAgICAgICAgbGV0IHRtcCA9IG5ldyBVaW50OEFycmF5KGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCArIG92ZXJmbG93KTtcbiAgICAgICAgICAgICAgdG1wLnNldChsYXN0VW5pdC5kYXRhLCAwKTtcbiAgICAgICAgICAgICAgdG1wLnNldChhcnJheS5zdWJhcnJheSgwLCBvdmVyZmxvdyksIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEgPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGNhbiByZWFkIHVuaXQgdHlwZVxuICAgICAgICBpZiAoaSA8IGxlbikge1xuICAgICAgICAgIHVuaXRUeXBlID0gYXJyYXlbaV0gJiAweDFmO1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2ZpbmQgTkFMVSBAIG9mZnNldDonICsgaSArICcsdHlwZTonICsgdW5pdFR5cGUpO1xuICAgICAgICAgIGxhc3RVbml0U3RhcnQgPSBpO1xuICAgICAgICAgIGxhc3RVbml0VHlwZSA9IHVuaXRUeXBlO1xuICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBub3QgZW5vdWdoIGJ5dGUgdG8gcmVhZCB1bml0IHR5cGUuIGxldCdzIHJlYWQgaXQgb24gbmV4dCBQRVMgcGFyc2luZ1xuICAgICAgICAgIHN0YXRlID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3RVbml0U3RhcnQgPj0gMCAmJiBzdGF0ZSA+PSAwKSB7XG4gICAgICB1bml0ID0geyBkYXRhOiBhcnJheS5zdWJhcnJheShsYXN0VW5pdFN0YXJ0LCBsZW4pLCB0eXBlOiBsYXN0VW5pdFR5cGUsIHN0YXRlOiBzdGF0ZSB9O1xuICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgIC8vIGxvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplL3N0YXRlOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCArICcvJyArIHN0YXRlKTtcbiAgICB9XG4gICAgLy8gbm8gTkFMdSBmb3VuZFxuICAgIGlmICh1bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGFwcGVuZCBwZXMuZGF0YSB0byBwcmV2aW91cyBOQUwgdW5pdFxuICAgICAgbGV0IGxhc3RVbml0ID0gdGhpcy5fZ2V0TGFzdE5hbFVuaXQoKTtcbiAgICAgIGlmIChsYXN0VW5pdCkge1xuICAgICAgICBsZXQgdG1wID0gbmV3IFVpbnQ4QXJyYXkobGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgYXJyYXkuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRtcC5zZXQobGFzdFVuaXQuZGF0YSwgMCk7XG4gICAgICAgIHRtcC5zZXQoYXJyYXksIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGxhc3RVbml0LmRhdGEgPSB0bXA7XG4gICAgICB9XG4gICAgfVxuICAgIHRyYWNrLm5hbHVTdGF0ZSA9IHN0YXRlO1xuICAgIHJldHVybiB1bml0cztcbiAgfVxuXG4gIC8qKlxuICAgKiByZW1vdmUgRW11bGF0aW9uIFByZXZlbnRpb24gYnl0ZXMgZnJvbSBhIFJCU1BcbiAgICovXG4gIGRpc2NhcmRFUEIgKGRhdGEpIHtcbiAgICBsZXQgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgRVBCUG9zaXRpb25zID0gW10sXG4gICAgICBpID0gMSxcbiAgICAgIG5ld0xlbmd0aCwgbmV3RGF0YTtcblxuICAgIC8vIEZpbmQgYWxsIGBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlc2BcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCAtIDIpIHtcbiAgICAgIGlmIChkYXRhW2ldID09PSAwICYmXG4gICAgICAgICAgZGF0YVtpICsgMV0gPT09IDAgJiZcbiAgICAgICAgICBkYXRhW2kgKyAyXSA9PT0gMHgwMykge1xuICAgICAgICBFUEJQb3NpdGlvbnMucHVzaChpICsgMik7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBubyBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlcyB3ZXJlIGZvdW5kIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5hbFxuICAgIC8vIGFycmF5XG4gICAgaWYgKEVQQlBvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIG5ldyBhcnJheSB0byBob2xkIHRoZSBOQUwgdW5pdCBkYXRhXG4gICAgbmV3TGVuZ3RoID0gbGVuZ3RoIC0gRVBCUG9zaXRpb25zLmxlbmd0aDtcbiAgICBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcbiAgICBsZXQgc291cmNlSW5kZXggPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5ld0xlbmd0aDsgc291cmNlSW5kZXgrKywgaSsrKSB7XG4gICAgICBpZiAoc291cmNlSW5kZXggPT09IEVQQlBvc2l0aW9uc1swXSkge1xuICAgICAgICAvLyBTa2lwIHRoaXMgYnl0ZVxuICAgICAgICBzb3VyY2VJbmRleCsrO1xuICAgICAgICAvLyBSZW1vdmUgdGhpcyBwb3NpdGlvbiBpbmRleFxuICAgICAgICBFUEJQb3NpdGlvbnMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIG5ld0RhdGFbaV0gPSBkYXRhW3NvdXJjZUluZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RhdGE7XG4gIH1cblxuICBfcGFyc2VBQUNQRVMgKHBlcykge1xuICAgIGxldCB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2ssXG4gICAgICBkYXRhID0gcGVzLmRhdGEsXG4gICAgICBwdHMgPSBwZXMucHRzLFxuICAgICAgc3RhcnRPZmZzZXQgPSAwLFxuICAgICAgYWFjT3ZlckZsb3cgPSB0aGlzLmFhY092ZXJGbG93LFxuICAgICAgYWFjTGFzdFBUUyA9IHRoaXMuYWFjTGFzdFBUUyxcbiAgICAgIGZyYW1lRHVyYXRpb24sIGZyYW1lSW5kZXgsIG9mZnNldCwgc3RhbXAsIGxlbjtcbiAgICBpZiAoYWFjT3ZlckZsb3cpIHtcbiAgICAgIGxldCB0bXAgPSBuZXcgVWludDhBcnJheShhYWNPdmVyRmxvdy5ieXRlTGVuZ3RoICsgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgIHRtcC5zZXQoYWFjT3ZlckZsb3csIDApO1xuICAgICAgdG1wLnNldChkYXRhLCBhYWNPdmVyRmxvdy5ieXRlTGVuZ3RoKTtcbiAgICAgIC8vIGxvZ2dlci5sb2coYEFBQzogYXBwZW5kIG92ZXJmbG93aW5nICR7YWFjT3ZlckZsb3cuYnl0ZUxlbmd0aH0gYnl0ZXMgdG8gYmVnaW5uaW5nIG9mIG5ldyBQRVNgKTtcbiAgICAgIGRhdGEgPSB0bXA7XG4gICAgfVxuICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgZm9yIChvZmZzZXQgPSBzdGFydE9mZnNldCwgbGVuID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XG4gICAgICBpZiAoQURUUy5pc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBBRFRTIGhlYWRlciBkb2VzIG5vdCBzdGFydCBzdHJhaWdodCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYXlsb2FkLCByYWlzZSBhbiBlcnJvclxuICAgIGlmIChvZmZzZXQpIHtcbiAgICAgIGxldCByZWFzb24sIGZhdGFsO1xuICAgICAgaWYgKG9mZnNldCA8IGxlbiAtIDEpIHtcbiAgICAgICAgcmVhc29uID0gYEFBQyBQRVMgZGlkIG5vdCBzdGFydCB3aXRoIEFEVFMgaGVhZGVyLG9mZnNldDoke29mZnNldH1gO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVhc29uID0gJ25vIEFEVFMgaGVhZGVyIGZvdW5kIGluIEFBQyBQRVMnO1xuICAgICAgICBmYXRhbCA9IHRydWU7XG4gICAgICB9XG4gICAgICBsb2dnZXIud2FybihgcGFyc2luZyBlcnJvcjoke3JlYXNvbn1gKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLCBmYXRhbDogZmF0YWwsIHJlYXNvbjogcmVhc29uIH0pO1xuICAgICAgaWYgKGZhdGFsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBBRFRTLmluaXRUcmFja0NvbmZpZyh0cmFjaywgdGhpcy5vYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCB0aGlzLmF1ZGlvQ29kZWMpO1xuICAgIGZyYW1lSW5kZXggPSAwO1xuICAgIGZyYW1lRHVyYXRpb24gPSBBRFRTLmdldEZyYW1lRHVyYXRpb24odHJhY2suc2FtcGxlcmF0ZSk7XG5cbiAgICAvLyBpZiBsYXN0IEFBQyBmcmFtZSBpcyBvdmVyZmxvd2luZywgd2Ugc2hvdWxkIGVuc3VyZSB0aW1lc3RhbXBzIGFyZSBjb250aWd1b3VzOlxuICAgIC8vIGZpcnN0IHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGZyYW1lRHVyYXRpb25cbiAgICBpZiAoYWFjT3ZlckZsb3cgJiYgYWFjTGFzdFBUUykge1xuICAgICAgbGV0IG5ld1BUUyA9IGFhY0xhc3RQVFMgKyBmcmFtZUR1cmF0aW9uO1xuICAgICAgaWYgKE1hdGguYWJzKG5ld1BUUyAtIHB0cykgPiAxKSB7XG4gICAgICAgIGxvZ2dlci5sb2coYEFBQzogYWxpZ24gUFRTIGZvciBvdmVybGFwcGluZyBmcmFtZXMgYnkgJHtNYXRoLnJvdW5kKChuZXdQVFMgLSBwdHMpIC8gOTApfWApO1xuICAgICAgICBwdHMgPSBuZXdQVFM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2NhbiBmb3IgYWFjIHNhbXBsZXNcbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICBpZiAoQURUUy5pc0hlYWRlcihkYXRhLCBvZmZzZXQpICYmIChvZmZzZXQgKyA1KSA8IGxlbikge1xuICAgICAgICBsZXQgZnJhbWUgPSBBRFRTLmFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCk7XG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coYCR7TWF0aC5yb3VuZChmcmFtZS5zYW1wbGUucHRzKX0gOiBBQUNgKTtcbiAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgIHN0YW1wID0gZnJhbWUuc2FtcGxlLnB0cztcbiAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnVW5hYmxlIHRvIHBhcnNlIEFBQyBmcmFtZScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGZvdW5kLCBrZWVwIGxvb2tpbmdcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA8IGxlbikge1xuICAgICAgYWFjT3ZlckZsb3cgPSBkYXRhLnN1YmFycmF5KG9mZnNldCwgbGVuKTtcbiAgICAgIC8vIGxvZ2dlci5sb2coYEFBQzogb3ZlcmZsb3cgZGV0ZWN0ZWQ6JHtsZW4tb2Zmc2V0fWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5hYWNPdmVyRmxvdyA9IGFhY092ZXJGbG93O1xuICAgIHRoaXMuYWFjTGFzdFBUUyA9IHN0YW1wO1xuICB9XG5cbiAgX3BhcnNlTVBFR1BFUyAocGVzKSB7XG4gICAgbGV0IGRhdGEgPSBwZXMuZGF0YTtcbiAgICBsZXQgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgbGV0IGZyYW1lSW5kZXggPSAwO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCBwdHMgPSBwZXMucHRzO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgaWYgKE1wZWdBdWRpby5pc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGxldCBmcmFtZSA9IE1wZWdBdWRpby5hcHBlbmRGcmFtZSh0aGlzLl9hdWRpb1RyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCk7XG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBNcGVnIGF1ZGlvIGZyYW1lJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfcGFyc2VJRDNQRVMgKHBlcykge1xuICAgIHRoaXMuX2lkM1RyYWNrLnNhbXBsZXMucHVzaChwZXMpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRTRGVtdXhlcjtcbiIsImV4cG9ydCBjb25zdCBFcnJvclR5cGVzID0ge1xuICAvLyBJZGVudGlmaWVyIGZvciBhIG5ldHdvcmsgZXJyb3IgKGxvYWRpbmcgZXJyb3IgLyB0aW1lb3V0IC4uLilcbiAgTkVUV09SS19FUlJPUjogJ25ldHdvcmtFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWVkaWEgRXJyb3IgKHZpZGVvL3BhcnNpbmcvbWVkaWFzb3VyY2UgZXJyb3IpXG4gIE1FRElBX0VSUk9SOiAnbWVkaWFFcnJvcicsXG4gIC8vIEVNRSAoZW5jcnlwdGVkIG1lZGlhIGV4dGVuc2lvbnMpIGVycm9yc1xuICBLRVlfU1lTVEVNX0VSUk9SOiAna2V5U3lzdGVtRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG11eCBFcnJvciAoZGVtdXhpbmcvcmVtdXhpbmcpXG4gIE1VWF9FUlJPUjogJ211eEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYWxsIG90aGVyIGVycm9yc1xuICBPVEhFUl9FUlJPUjogJ290aGVyRXJyb3InXG59O1xuXG4vKipcbiAqIEBlbnVtIHtFcnJvckRldGFpbHN9XG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBFcnJvckRldGFpbFxuICovXG5leHBvcnQgY29uc3QgRXJyb3JEZXRhaWxzID0ge1xuICBLRVlfU1lTVEVNX05PX0tFWVM6ICdrZXlTeXN0ZW1Ob0tleXMnLFxuICBLRVlfU1lTVEVNX05PX0FDQ0VTUzogJ2tleVN5c3RlbU5vQWNjZXNzJyxcbiAgS0VZX1NZU1RFTV9OT19TRVNTSU9OOiAna2V5U3lzdGVtTm9TZXNzaW9uJyxcbiAgS0VZX1NZU1RFTV9MSUNFTlNFX1JFUVVFU1RfRkFJTEVEOiAna2V5U3lzdGVtTGljZW5zZVJlcXVlc3RGYWlsZWQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIE1BTklGRVNUX0xPQURfRVJST1I6ICdtYW5pZmVzdExvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3QgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBNQU5JRkVTVF9MT0FEX1RJTUVPVVQ6ICdtYW5pZmVzdExvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtYW5pZmVzdCBwYXJzaW5nIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZWFzb24gOiBlcnJvciByZWFzb259XG4gIE1BTklGRVNUX1BBUlNJTkdfRVJST1I6ICdtYW5pZmVzdFBhcnNpbmdFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3Qgd2l0aCBvbmx5IGluY29tcGF0aWJsZSBjb2RlY3MgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlYXNvbiA6IGVycm9yIHJlYXNvbn1cbiAgTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUjogJ21hbmlmZXN0SW5jb21wYXRpYmxlQ29kZWNzRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGxldmVsIGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIExFVkVMX0xPQURfRVJST1I6ICdsZXZlbExvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBMRVZFTF9MT0FEX1RJTUVPVVQ6ICdsZXZlbExvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCBzd2l0Y2ggZXJyb3IgLSBkYXRhOiB7IGxldmVsIDogZmF1bHR5IGxldmVsIElkLCBldmVudCA6IGVycm9yIGRlc2NyaXB0aW9ufVxuICBMRVZFTF9TV0lUQ0hfRVJST1I6ICdsZXZlbFN3aXRjaEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYW4gYXVkaW8gdHJhY2sgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjogJ2F1ZGlvVHJhY2tMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEFVRElPX1RSQUNLX0xPQURfVElNRU9VVDogJ2F1ZGlvVHJhY2tMb2FkVGltZU91dCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvYWQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEZSQUdfTE9BRF9FUlJPUjogJ2ZyYWdMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEZSQUdfTE9BRF9USU1FT1VUOiAnZnJhZ0xvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBmcmFnbWVudCBkZWNyeXB0aW9uIGVycm9yIGV2ZW50IC0gZGF0YToge2lkIDogZGVtdXhlciBJZCxmcmFnOiBmcmFnbWVudCBvYmplY3QsIHJlYXNvbiA6IHBhcnNpbmcgZXJyb3IgZGVzY3JpcHRpb24gfVxuICBGUkFHX0RFQ1JZUFRfRVJST1I6ICdmcmFnRGVjcnlwdEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBmcmFnbWVudCBwYXJzaW5nIGVycm9yIGV2ZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgSWQsIHJlYXNvbiA6IHBhcnNpbmcgZXJyb3IgZGVzY3JpcHRpb24gfVxuICAvLyB3aWxsIGJlIHJlbmFtZWQgREVNVVhfUEFSU0lOR19FUlJPUiBhbmQgc3dpdGNoZWQgdG8gTVVYX0VSUk9SIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2VcbiAgRlJBR19QQVJTSU5HX0VSUk9SOiAnZnJhZ1BhcnNpbmdFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgcmVtdXggYWxsb2MgZXJyb3IgZXZlbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBJZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgYnl0ZXMgOiBuYiBvZiBieXRlcyBvbiB3aGljaCBhbGxvY2F0aW9uIGZhaWxlZCAsIHJlYXNvbiA6IGVycm9yIHRleHQgfVxuICBSRU1VWF9BTExPQ19FUlJPUjogJ3JlbXV4QWxsb2NFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGRlY3J5cHQga2V5IGxvYWQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEtFWV9MT0FEX0VSUk9SOiAna2V5TG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZGVjcnlwdCBrZXkgbG9hZCB0aW1lb3V0IGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0fVxuICBLRVlfTE9BRF9USU1FT1VUOiAna2V5TG9hZFRpbWVPdXQnLFxuICAvLyBUcmlnZ2VyZWQgd2hlbiBhbiBleGNlcHRpb24gb2NjdXJzIHdoaWxlIGFkZGluZyBhIHNvdXJjZUJ1ZmZlciB0byBNZWRpYVNvdXJjZSAtIGRhdGEgOiB7ICBlcnIgOiBleGNlcHRpb24gLCBtaW1lVHlwZSA6IG1pbWVUeXBlIH1cbiAgQlVGRkVSX0FERF9DT0RFQ19FUlJPUjogJ2J1ZmZlckFkZENvZGVjRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBhcHBlbmQgZXJyb3IgLSBkYXRhOiBhcHBlbmQgZXJyb3IgZGVzY3JpcHRpb25cbiAgQlVGRkVSX0FQUEVORF9FUlJPUjogJ2J1ZmZlckFwcGVuZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgYXBwZW5kaW5nIGVycm9yIGV2ZW50IC0gZGF0YTogYXBwZW5kaW5nIGVycm9yIGRlc2NyaXB0aW9uXG4gIEJVRkZFUl9BUFBFTkRJTkdfRVJST1I6ICdidWZmZXJBcHBlbmRpbmdFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIHN0YWxsZWQgZXJyb3IgZXZlbnRcbiAgQlVGRkVSX1NUQUxMRURfRVJST1I6ICdidWZmZXJTdGFsbGVkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBmdWxsIGV2ZW50XG4gIEJVRkZFUl9GVUxMX0VSUk9SOiAnYnVmZmVyRnVsbEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgc2VlayBvdmVyIGhvbGUgZXZlbnRcbiAgQlVGRkVSX1NFRUtfT1ZFUl9IT0xFOiAnYnVmZmVyU2Vla092ZXJIb2xlJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgbnVkZ2Ugb24gc3RhbGwgKHBsYXliYWNrIGlzIHN0dWNrIGFsdGhvdWdoIGN1cnJlbnRUaW1lIGlzIGluIGEgYnVmZmVyZWQgYXJlYSlcbiAgQlVGRkVSX05VREdFX09OX1NUQUxMOiAnYnVmZmVyTnVkZ2VPblN0YWxsJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYW4gaW50ZXJuYWwgZXhjZXB0aW9uIGhhcHBlbmluZyBpbnNpZGUgaGxzLmpzIHdoaWxlIGhhbmRsaW5nIGFuIGV2ZW50XG4gIElOVEVSTkFMX0VYQ0VQVElPTjogJ2ludGVybmFsRXhjZXB0aW9uJ1xufTtcbiIsIi8qXG4qXG4qIEFsbCBvYmplY3RzIGluIHRoZSBldmVudCBoYW5kbGluZyBjaGFpbiBzaG91bGQgaW5oZXJpdCBmcm9tIHRoaXMgY2xhc3NcbipcbiovXG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCBFdmVudCBmcm9tICcuL2V2ZW50cyc7XG5cbmNvbnN0IEZPUkJJRERFTl9FVkVOVF9OQU1FUyA9IHtcbiAgJ2hsc0V2ZW50R2VuZXJpYyc6IHRydWUsXG4gICdobHNIYW5kbGVyRGVzdHJveWluZyc6IHRydWUsXG4gICdobHNIYW5kbGVyRGVzdHJveWVkJzogdHJ1ZVxufTtcblxuY2xhc3MgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscywgLi4uZXZlbnRzKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5vbkV2ZW50ID0gdGhpcy5vbkV2ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVkRXZlbnRzID0gZXZlbnRzO1xuICAgIHRoaXMudXNlR2VuZXJpY0hhbmRsZXIgPSB0cnVlO1xuXG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5vbkhhbmRsZXJEZXN0cm95aW5nKCk7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5vbkhhbmRsZXJEZXN0cm95ZWQoKTtcbiAgfVxuXG4gIG9uSGFuZGxlckRlc3Ryb3lpbmcgKCkge31cbiAgb25IYW5kbGVyRGVzdHJveWVkICgpIHt9XG5cbiAgaXNFdmVudEhhbmRsZXIgKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5oYW5kbGVkRXZlbnRzID09PSAnb2JqZWN0JyAmJiB0aGlzLmhhbmRsZWRFdmVudHMubGVuZ3RoICYmIHR5cGVvZiB0aGlzLm9uRXZlbnQgPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICByZWdpc3Rlckxpc3RlbmVycyAoKSB7XG4gICAgaWYgKHRoaXMuaXNFdmVudEhhbmRsZXIoKSkge1xuICAgICAgdGhpcy5oYW5kbGVkRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChGT1JCSURERU5fRVZFTlRfTkFNRVNbZXZlbnRdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JiaWRkZW4gZXZlbnQtbmFtZTogJyArIGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGxzLm9uKGV2ZW50LCB0aGlzLm9uRXZlbnQpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgdW5yZWdpc3Rlckxpc3RlbmVycyAoKSB7XG4gICAgaWYgKHRoaXMuaXNFdmVudEhhbmRsZXIoKSkge1xuICAgICAgdGhpcy5oYW5kbGVkRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuaGxzLm9mZihldmVudCwgdGhpcy5vbkV2ZW50KTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBhcmd1bWVudHM6IGV2ZW50IChzdHJpbmcpLCBkYXRhIChhbnkpXG4gICAqL1xuICBvbkV2ZW50IChldmVudCwgZGF0YSkge1xuICAgIHRoaXMub25FdmVudEdlbmVyaWMoZXZlbnQsIGRhdGEpO1xuICB9XG5cbiAgb25FdmVudEdlbmVyaWMgKGV2ZW50LCBkYXRhKSB7XG4gICAgbGV0IGV2ZW50VG9GdW5jdGlvbiA9IGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgbGV0IGZ1bmNOYW1lID0gJ29uJyArIGV2ZW50LnJlcGxhY2UoJ2hscycsICcnKTtcbiAgICAgIGlmICh0eXBlb2YgdGhpc1tmdW5jTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFdmVudCAke2V2ZW50fSBoYXMgbm8gZ2VuZXJpYyBoYW5kbGVyIGluIHRoaXMgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IGNsYXNzICh0cmllZCAke2Z1bmNOYW1lfSlgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNbZnVuY05hbWVdLmJpbmQodGhpcywgZGF0YSk7XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgZXZlbnRUb0Z1bmN0aW9uLmNhbGwodGhpcywgZXZlbnQsIGRhdGEpLmNhbGwoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihgQW4gaW50ZXJuYWwgZXJyb3IgaGFwcGVuZWQgd2hpbGUgaGFuZGxpbmcgZXZlbnQgJHtldmVudH0uIEVycm9yIG1lc3NhZ2U6IFwiJHtlcnIubWVzc2FnZX1cIi4gSGVyZSBpcyBhIHN0YWNrdHJhY2U6YCwgZXJyKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTiwgZmF0YWw6IGZhbHNlLCBldmVudDogZXZlbnQsIGVycjogZXJyIH0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFdmVudEhhbmRsZXI7XG4iLCIvKipcbiAqIEByZWFkb25seVxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgSGxzRXZlbnRzID0ge1xuICAvLyBmaXJlZCBiZWZvcmUgTWVkaWFTb3VyY2UgaXMgYXR0YWNoaW5nIHRvIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IG1lZGlhIH1cbiAgTUVESUFfQVRUQUNISU5HOiAnaGxzTWVkaWFBdHRhY2hpbmcnLFxuICAvLyBmaXJlZCB3aGVuIE1lZGlhU291cmNlIGhhcyBiZWVuIHN1Y2Nlc2Z1bGx5IGF0dGFjaGVkIHRvIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IH1cbiAgTUVESUFfQVRUQUNIRUQ6ICdobHNNZWRpYUF0dGFjaGVkJyxcbiAgLy8gZmlyZWQgYmVmb3JlIGRldGFjaGluZyBNZWRpYVNvdXJjZSBmcm9tIG1lZGlhIGVsZW1lbnQgLSBkYXRhOiB7IH1cbiAgTUVESUFfREVUQUNISU5HOiAnaGxzTWVkaWFEZXRhY2hpbmcnLFxuICAvLyBmaXJlZCB3aGVuIE1lZGlhU291cmNlIGhhcyBiZWVuIGRldGFjaGVkIGZyb20gbWVkaWEgZWxlbWVudCAtIGRhdGE6IHsgfVxuICBNRURJQV9ERVRBQ0hFRDogJ2hsc01lZGlhRGV0YWNoZWQnLFxuICAvLyBmaXJlZCB3aGVuIHdlIGJ1ZmZlciBpcyBnb2luZyB0byBiZSByZXNldCAtIGRhdGE6IHsgfVxuICBCVUZGRVJfUkVTRVQ6ICdobHNCdWZmZXJSZXNldCcsXG4gIC8vIGZpcmVkIHdoZW4gd2Uga25vdyBhYm91dCB0aGUgY29kZWNzIHRoYXQgd2UgbmVlZCBidWZmZXJzIGZvciB0byBwdXNoIGludG8gLSBkYXRhOiB7dHJhY2tzIDogeyBjb250YWluZXIsIGNvZGVjLCBsZXZlbENvZGVjLCBpbml0U2VnbWVudCwgbWV0YWRhdGEgfX1cbiAgQlVGRkVSX0NPREVDUzogJ2hsc0J1ZmZlckNvZGVjcycsXG4gIC8vIGZpcmVkIHdoZW4gc291cmNlYnVmZmVycyBoYXZlIGJlZW4gY3JlYXRlZCAtIGRhdGE6IHsgdHJhY2tzIDogdHJhY2tzIH1cbiAgQlVGRkVSX0NSRUFURUQ6ICdobHNCdWZmZXJDcmVhdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiB3ZSBhcHBlbmQgYSBzZWdtZW50IHRvIHRoZSBidWZmZXIgLSBkYXRhOiB7IHNlZ21lbnQ6IHNlZ21lbnQgb2JqZWN0IH1cbiAgQlVGRkVSX0FQUEVORElORzogJ2hsc0J1ZmZlckFwcGVuZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gd2UgYXJlIGRvbmUgd2l0aCBhcHBlbmRpbmcgYSBtZWRpYSBzZWdtZW50IHRvIHRoZSBidWZmZXIgLSBkYXRhIDogeyBwYXJlbnQgOiBzZWdtZW50IHBhcmVudCB0aGF0IHRyaWdnZXJlZCBCVUZGRVJfQVBQRU5ESU5HLCBwZW5kaW5nIDogbmIgb2Ygc2VnbWVudHMgd2FpdGluZyBmb3IgYXBwZW5kaW5nIGZvciB0aGlzIHNlZ21lbnQgcGFyZW50fVxuICBCVUZGRVJfQVBQRU5ERUQ6ICdobHNCdWZmZXJBcHBlbmRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIHN0cmVhbSBpcyBmaW5pc2hlZCBhbmQgd2Ugd2FudCB0byBub3RpZnkgdGhlIG1lZGlhIGJ1ZmZlciB0aGF0IHRoZXJlIHdpbGwgYmUgbm8gbW9yZSBkYXRhIC0gZGF0YTogeyB9XG4gIEJVRkZFUl9FT1M6ICdobHNCdWZmZXJFb3MnLFxuICAvLyBmaXJlZCB3aGVuIHRoZSBtZWRpYSBidWZmZXIgc2hvdWxkIGJlIGZsdXNoZWQgLSBkYXRhIHsgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCB9XG4gIEJVRkZFUl9GTFVTSElORzogJ2hsc0J1ZmZlckZsdXNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiB0aGUgbWVkaWEgYnVmZmVyIGhhcyBiZWVuIGZsdXNoZWQgLSBkYXRhOiB7IH1cbiAgQlVGRkVSX0ZMVVNIRUQ6ICdobHNCdWZmZXJGbHVzaGVkJyxcbiAgLy8gZmlyZWQgdG8gc2lnbmFsIHRoYXQgYSBtYW5pZmVzdCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogbWFuaWZlc3RVUkx9XG4gIE1BTklGRVNUX0xPQURJTkc6ICdobHNNYW5pZmVzdExvYWRpbmcnLFxuICAvLyBmaXJlZCBhZnRlciBtYW5pZmVzdCBoYXMgYmVlbiBsb2FkZWQgLSBkYXRhOiB7IGxldmVscyA6IFthdmFpbGFibGUgcXVhbGl0eSBsZXZlbHNdLCBhdWRpb1RyYWNrcyA6IFsgYXZhaWxhYmxlIGF1ZGlvIHRyYWNrc10sIHVybCA6IG1hbmlmZXN0VVJMLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lfX1cbiAgTUFOSUZFU1RfTE9BREVEOiAnaGxzTWFuaWZlc3RMb2FkZWQnLFxuICAvLyBmaXJlZCBhZnRlciBtYW5pZmVzdCBoYXMgYmVlbiBwYXJzZWQgLSBkYXRhOiB7IGxldmVscyA6IFthdmFpbGFibGUgcXVhbGl0eSBsZXZlbHNdLCBmaXJzdExldmVsIDogaW5kZXggb2YgZmlyc3QgcXVhbGl0eSBsZXZlbCBhcHBlYXJpbmcgaW4gTWFuaWZlc3R9XG4gIE1BTklGRVNUX1BBUlNFRDogJ2hsc01hbmlmZXN0UGFyc2VkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHN3aXRjaCBpcyByZXF1ZXN0ZWQgLSBkYXRhOiB7IGxldmVsIDogaWQgb2YgbmV3IGxldmVsIH1cbiAgTEVWRUxfU1dJVENISU5HOiAnaGxzTGV2ZWxTd2l0Y2hpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgc3dpdGNoIGlzIGVmZmVjdGl2ZSAtIGRhdGE6IHsgbGV2ZWwgOiBpZCBvZiBuZXcgbGV2ZWwgfVxuICBMRVZFTF9TV0lUQ0hFRDogJ2hsc0xldmVsU3dpdGNoZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgcGxheWxpc3QgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IGxldmVsIFVSTCwgbGV2ZWwgOiBpZCBvZiBsZXZlbCBiZWluZyBsb2FkZWR9XG4gIExFVkVMX0xPQURJTkc6ICdobHNMZXZlbExvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgcGxheWxpc3QgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGxldmVsIDogaWQgb2YgbG9hZGVkIGxldmVsLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lfSB9XG4gIExFVkVMX0xPQURFRDogJ2hsc0xldmVsTG9hZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsJ3MgZGV0YWlscyBoYXZlIGJlZW4gdXBkYXRlZCBiYXNlZCBvbiBwcmV2aW91cyBkZXRhaWxzLCBhZnRlciBpdCBoYXMgYmVlbiBsb2FkZWQgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIHVwZGF0ZWQgbGV2ZWwgfVxuICBMRVZFTF9VUERBVEVEOiAnaGxzTGV2ZWxVcGRhdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsJ3MgUFRTIGluZm9ybWF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQgYWZ0ZXIgcGFyc2luZyBhIGZyYWdtZW50IC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiB1cGRhdGVkIGxldmVsLCBkcmlmdDogUFRTIGRyaWZ0IG9ic2VydmVkIHdoZW4gcGFyc2luZyBsYXN0IGZyYWdtZW50IH1cbiAgTEVWRUxfUFRTX1VQREFURUQ6ICdobHNMZXZlbFB0c1VwZGF0ZWQnLFxuICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBhdWRpbyB0cmFjayBsaXN0cyBoYXMgYmVlbiB1cGRhdGVkIC0gZGF0YTogeyBhdWRpb1RyYWNrcyA6IGF1ZGlvVHJhY2tzIH1cbiAgQVVESU9fVFJBQ0tTX1VQREFURUQ6ICdobHNBdWRpb1RyYWNrc1VwZGF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIHN3aXRjaGluZyBpcyByZXF1ZXN0ZWQgLSBkYXRhOiB7IGlkIDogYXVkaW8gdHJhY2sgaWQgfVxuICBBVURJT19UUkFDS19TV0lUQ0hJTkc6ICdobHNBdWRpb1RyYWNrU3dpdGNoaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBhdWRpbyB0cmFjayBzd2l0Y2ggYWN0dWFsbHkgb2NjdXJzIC0gZGF0YTogeyBpZCA6IGF1ZGlvIHRyYWNrIGlkIH1cbiAgQVVESU9fVFJBQ0tfU1dJVENIRUQ6ICdobHNBdWRpb1RyYWNrU3dpdGNoZWQnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyB1cmwgOiBhdWRpbyB0cmFjayBVUkwsIGlkIDogYXVkaW8gdHJhY2sgaWQgfVxuICBBVURJT19UUkFDS19MT0FESU5HOiAnaGxzQXVkaW9UcmFja0xvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIGxvYWRpbmcgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBpZCA6IGF1ZGlvIHRyYWNrIGlkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lIH0gfVxuICBBVURJT19UUkFDS19MT0FERUQ6ICdobHNBdWRpb1RyYWNrTG9hZGVkJyxcbiAgLy8gZmlyZWQgdG8gbm90aWZ5IHRoYXQgc3VidGl0bGUgdHJhY2sgbGlzdHMgaGFzIGJlZW4gdXBkYXRlZCAtIGRhdGE6IHsgc3VidGl0bGVUcmFja3MgOiBzdWJ0aXRsZVRyYWNrcyB9XG4gIFNVQlRJVExFX1RSQUNLU19VUERBVEVEOiAnaGxzU3VidGl0bGVUcmFja3NVcGRhdGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBzdWJ0aXRsZSB0cmFjayBzd2l0Y2ggb2NjdXJzIC0gZGF0YTogeyBpZCA6IHN1YnRpdGxlIHRyYWNrIGlkIH1cbiAgU1VCVElUTEVfVFJBQ0tfU1dJVENIOiAnaGxzU3VidGl0bGVUcmFja1N3aXRjaCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBzdWJ0aXRsZSB0cmFjayBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogc3VidGl0bGUgdHJhY2sgVVJMLCBpZCA6IHN1YnRpdGxlIHRyYWNrIGlkIH1cbiAgU1VCVElUTEVfVFJBQ0tfTE9BRElORzogJ2hsc1N1YnRpdGxlVHJhY2tMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIHRyYWNrIGxvYWRpbmcgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBpZCA6IHN1YnRpdGxlIHRyYWNrIGlkLCBzdGF0cyA6IHsgdHJlcXVlc3QsIHRmaXJzdCwgdGxvYWQsIG10aW1lIH0gfVxuICBTVUJUSVRMRV9UUkFDS19MT0FERUQ6ICdobHNTdWJ0aXRsZVRyYWNrTG9hZGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIHN1YnRpdGxlIGZyYWdtZW50IGhhcyBiZWVuIHByb2Nlc3NlZCAtIGRhdGE6IHsgc3VjY2VzcyA6IGJvb2xlYW4sIGZyYWcgOiB0aGUgcHJvY2Vzc2VkIGZyYWcgfVxuICBTVUJUSVRMRV9GUkFHX1BST0NFU1NFRDogJ2hsc1N1YnRpdGxlRnJhZ1Byb2Nlc3NlZCcsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIGZpcnN0IHRpbWVzdGFtcCBpcyBmb3VuZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBpbml0UFRTOiBpbml0UFRTLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgSU5JVF9QVFNfRk9VTkQ6ICdobHNJbml0UHRzRm91bmQnLFxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICBGUkFHX0xPQURJTkc6ICdobHNGcmFnTG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIHByb2dyZXNzaW5nIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCB7IHRyZXF1ZXN0LCB0Zmlyc3QsIGxvYWRlZCB9IH1cbiAgRlJBR19MT0FEX1BST0dSRVNTOiAnaGxzRnJhZ0xvYWRQcm9ncmVzcycsXG4gIC8vIElkZW50aWZpZXIgZm9yIGZyYWdtZW50IGxvYWQgYWJvcnRpbmcgZm9yIGVtZXJnZW5jeSBzd2l0Y2ggZG93biAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gIEZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRDogJ2hsc0ZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcGF5bG9hZCA6IGZyYWdtZW50IHBheWxvYWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbGVuZ3RoIH0gfVxuICBGUkFHX0xPQURFRDogJ2hsc0ZyYWdMb2FkZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgaGFzIGZpbmlzaGVkIGRlY3J5cHRpbmcgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBwYXlsb2FkIDogZnJhZ21lbnQgcGF5bG9hZCwgc3RhdHMgOiB7IHRzdGFydCwgdGRlY3J5cHQgfSB9XG4gIEZSQUdfREVDUllQVEVEOiAnaGxzRnJhZ0RlY3J5cHRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gSW5pdCBTZWdtZW50IGhhcyBiZWVuIGV4dHJhY3RlZCBmcm9tIGZyYWdtZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgbW9vdiA6IG1vb3YgTVA0IGJveCwgY29kZWNzIDogY29kZWNzIGZvdW5kIHdoaWxlIHBhcnNpbmcgZnJhZ21lbnQgfVxuICBGUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UOiAnaGxzRnJhZ1BhcnNpbmdJbml0U2VnbWVudCcsXG4gIC8vIGZpcmVkIHdoZW4gcGFyc2luZyBzZWkgdGV4dCBpcyBjb21wbGV0ZWQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBzYW1wbGVzIDogWyBzZWkgc2FtcGxlcyBwZXMgXSB9XG4gIEZSQUdfUEFSU0lOR19VU0VSREFUQTogJ2hsc0ZyYWdQYXJzaW5nVXNlcmRhdGEnLFxuICAvLyBmaXJlZCB3aGVuIHBhcnNpbmcgaWQzIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHNhbXBsZXMgOiBbIGlkMyBzYW1wbGVzIHBlcyBdIH1cbiAgRlJBR19QQVJTSU5HX01FVEFEQVRBOiAnaGxzRnJhZ1BhcnNpbmdNZXRhZGF0YScsXG4gIC8vIGZpcmVkIHdoZW4gZGF0YSBoYXZlIGJlZW4gZXh0cmFjdGVkIGZyb20gZnJhZ21lbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBkYXRhMSA6IG1vb2YgTVA0IGJveCBvciBUUyBmcmFnbWVudHMsIGRhdGEyIDogbWRhdCBNUDQgYm94IG9yIG51bGx9XG4gIEZSQUdfUEFSU0lOR19EQVRBOiAnaGxzRnJhZ1BhcnNpbmdEYXRhJyxcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCBwYXJzaW5nIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QgfVxuICBGUkFHX1BBUlNFRDogJ2hsc0ZyYWdQYXJzZWQnLFxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHJlbXV4ZWQgTVA0IGJveGVzIGhhdmUgYWxsIGJlZW4gYXBwZW5kZWQgaW50byBTb3VyY2VCdWZmZXIgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgc3RhdHMgOiB7IHRyZXF1ZXN0LCB0Zmlyc3QsIHRsb2FkLCB0cGFyc2VkLCB0YnVmZmVyZWQsIGxlbmd0aCwgYndFc3RpbWF0ZSB9IH1cbiAgRlJBR19CVUZGRVJFRDogJ2hsc0ZyYWdCdWZmZXJlZCcsXG4gIC8vIGZpcmVkIHdoZW4gZnJhZ21lbnQgbWF0Y2hpbmcgd2l0aCBjdXJyZW50IG1lZGlhIHBvc2l0aW9uIGlzIGNoYW5naW5nIC0gZGF0YSA6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgRlJBR19DSEFOR0VEOiAnaGxzRnJhZ0NoYW5nZWQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIEZQUyBkcm9wIGV2ZW50IC0gZGF0YTogeyBjdXJlbnREcm9wcGVkLCBjdXJyZW50RGVjb2RlZCwgdG90YWxEcm9wcGVkRnJhbWVzIH1cbiAgRlBTX0RST1A6ICdobHNGcHNEcm9wJyxcbiAgLy8gdHJpZ2dlcmVkIHdoZW4gRlBTIGRyb3AgdHJpZ2dlcnMgYXV0byBsZXZlbCBjYXBwaW5nIC0gZGF0YTogeyBsZXZlbCwgZHJvcHBlZGxldmVsIH1cbiAgRlBTX0RST1BfTEVWRUxfQ0FQUElORzogJ2hsc0Zwc0Ryb3BMZXZlbENhcHBpbmcnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBlcnJvciBldmVudCAtIGRhdGE6IHsgdHlwZSA6IGVycm9yIHR5cGUsIGRldGFpbHMgOiBlcnJvciBkZXRhaWxzLCBmYXRhbCA6IGlmIHRydWUsIGhscy5qcyBjYW5ub3Qvd2lsbCBub3QgdHJ5IHRvIHJlY292ZXIsIGlmIGZhbHNlLCBobHMuanMgd2lsbCB0cnkgdG8gcmVjb3ZlcixvdGhlciBlcnJvciBzcGVjaWZpYyBkYXRhIH1cbiAgRVJST1I6ICdobHNFcnJvcicsXG4gIC8vIGZpcmVkIHdoZW4gaGxzLmpzIGluc3RhbmNlIHN0YXJ0cyBkZXN0cm95aW5nLiBEaWZmZXJlbnQgZnJvbSBNRURJQV9ERVRBQ0hFRCBhcyBvbmUgY291bGQgd2FudCB0byBkZXRhY2ggYW5kIHJlYXR0YWNoIGEgbWVkaWEgdG8gdGhlIGluc3RhbmNlIG9mIGhscy5qcyB0byBoYW5kbGUgbWlkLXJvbGxzIGZvciBleGFtcGxlIC0gZGF0YTogeyB9XG4gIERFU1RST1lJTkc6ICdobHNEZXN0cm95aW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGRlY3J5cHQga2V5IGxvYWRpbmcgc3RhcnRzIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0IH1cbiAgS0VZX0xPQURJTkc6ICdobHNLZXlMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGRlY3J5cHQga2V5IGxvYWRpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBwYXlsb2FkIDoga2V5IHBheWxvYWQsIHN0YXRzIDogeyB0cmVxdWVzdCwgdGZpcnN0LCB0bG9hZCwgbGVuZ3RoIH0gfVxuICBLRVlfTE9BREVEOiAnaGxzS2V5TG9hZGVkJyxcbiAgLy8gZmlyZWQgdXBvbiBzdHJlYW0gY29udHJvbGxlciBzdGF0ZSB0cmFuc2l0aW9ucyAtIGRhdGE6IHsgcHJldmlvdXNTdGF0ZSwgbmV4dFN0YXRlIH1cbiAgU1RSRUFNX1NUQVRFX1RSQU5TSVRJT046ICdobHNTdHJlYW1TdGF0ZVRyYW5zaXRpb24nXG59O1xuXG5leHBvcnQgZGVmYXVsdCBIbHNFdmVudHM7XG4iLCJpbXBvcnQgKiBhcyBVUkxUb29sa2l0IGZyb20gJ3VybC10b29sa2l0JztcblxuaW1wb3J0IHtcbiAgRXJyb3JUeXBlcyxcbiAgRXJyb3JEZXRhaWxzXG59IGZyb20gJy4vZXJyb3JzJztcblxuaW1wb3J0IFBsYXlsaXN0TG9hZGVyIGZyb20gJy4vbG9hZGVyL3BsYXlsaXN0LWxvYWRlcic7XG5pbXBvcnQgRnJhZ21lbnRMb2FkZXIgZnJvbSAnLi9sb2FkZXIvZnJhZ21lbnQtbG9hZGVyJztcbmltcG9ydCBLZXlMb2FkZXIgZnJvbSAnLi9sb2FkZXIva2V5LWxvYWRlcic7XG5cbmltcG9ydCB7IEZyYWdtZW50VHJhY2tlciB9IGZyb20gJy4vY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyJztcbmltcG9ydCBTdHJlYW1Db250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgTGV2ZWxDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyJztcbmltcG9ydCBJRDNUcmFja0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2lkMy10cmFjay1jb250cm9sbGVyJztcblxuaW1wb3J0IHsgaXNTdXBwb3J0ZWQgfSBmcm9tICcuL2lzLXN1cHBvcnRlZCc7XG5pbXBvcnQgeyBsb2dnZXIsIGVuYWJsZUxvZ3MgfSBmcm9tICcuL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBobHNEZWZhdWx0Q29uZmlnIH0gZnJvbSAnLi9jb25maWcnO1xuXG5pbXBvcnQgSGxzRXZlbnRzIGZyb20gJy4vZXZlbnRzJztcblxuaW1wb3J0IHsgT2JzZXJ2ZXIgfSBmcm9tICcuL29ic2VydmVyJztcblxuLyoqXG4gKiBAbW9kdWxlIEhsc1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGxzIGV4dGVuZHMgT2JzZXJ2ZXIge1xuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgdmVyc2lvbiAoKSB7XG4gICAgcmV0dXJuIF9fVkVSU0lPTl9fO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzU3VwcG9ydGVkICgpIHtcbiAgICByZXR1cm4gaXNTdXBwb3J0ZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7SGxzRXZlbnRzfVxuICAgKi9cbiAgc3RhdGljIGdldCBFdmVudHMgKCkge1xuICAgIHJldHVybiBIbHNFdmVudHM7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0hsc0Vycm9yVHlwZXN9XG4gICAqL1xuICBzdGF0aWMgZ2V0IEVycm9yVHlwZXMgKCkge1xuICAgIHJldHVybiBFcnJvclR5cGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtIbHNFcnJvckRldGFpbHN9XG4gICAqL1xuICBzdGF0aWMgZ2V0IEVycm9yRGV0YWlscyAoKSB7XG4gICAgcmV0dXJuIEVycm9yRGV0YWlscztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7SGxzQ29uZmlnfVxuICAgKi9cbiAgc3RhdGljIGdldCBEZWZhdWx0Q29uZmlnICgpIHtcbiAgICBpZiAoIUhscy5kZWZhdWx0Q29uZmlnKSB7XG4gICAgICByZXR1cm4gaGxzRGVmYXVsdENvbmZpZztcbiAgICB9XG5cbiAgICByZXR1cm4gSGxzLmRlZmF1bHRDb25maWc7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0hsc0NvbmZpZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgRGVmYXVsdENvbmZpZyAoZGVmYXVsdENvbmZpZykge1xuICAgIEhscy5kZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGFuIEhMUyBjbGllbnQgdGhhdCBjYW4gYXR0YWNoIHRvIGV4YWN0bHkgb25lIGBIVE1MTWVkaWFFbGVtZW50YC5cbiAgICpcbiAgICogQGNvbnN0cnVjdHMgSGxzXG4gICAqIEBwYXJhbSB7SGxzQ29uZmlnfSBjb25maWdcbiAgICovXG4gIGNvbnN0cnVjdG9yIChjb25maWcgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0gSGxzLkRlZmF1bHRDb25maWc7XG5cbiAgICBpZiAoKGNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgfHwgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCkgJiYgKGNvbmZpZy5saXZlU3luY0R1cmF0aW9uIHx8IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IGRvblxcJ3QgbWl4IHVwIGxpdmVTeW5jRHVyYXRpb25Db3VudC9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgYW5kIGxpdmVTeW5jRHVyYXRpb24vbGl2ZU1heExhdGVuY3lEdXJhdGlvbicpO1xuICAgIH1cblxuICAgIGZvciAobGV0IHByb3AgaW4gZGVmYXVsdENvbmZpZykge1xuICAgICAgaWYgKHByb3AgaW4gY29uZmlnKSBjb250aW51ZTtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGRlZmF1bHRDb25maWdbcHJvcF07XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgIT09IHVuZGVmaW5lZCAmJiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IDw9IGNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudFwiIG11c3QgYmUgZ3QgXCJsaXZlU3luY0R1cmF0aW9uQ291bnRcIicpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmIChjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA8PSBjb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCBjb25maWcubGl2ZVN5bmNEdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvblwiIG11c3QgYmUgZ3QgXCJsaXZlU3luY0R1cmF0aW9uXCInKTtcbiAgICB9XG5cbiAgICBlbmFibGVMb2dzKGNvbmZpZy5kZWJ1Zyk7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuXG4gICAgLy8gY29yZSBjb250cm9sbGVycyBhbmQgbmV0d29yayBsb2FkZXJzXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtBYnJDb250cm9sbGVyfSBhYnJDb250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3QgYWJyQ29udHJvbGxlciA9IHRoaXMuYWJyQ29udHJvbGxlciA9IG5ldyBjb25maWcuYWJyQ29udHJvbGxlcih0aGlzKTtcblxuICAgIGNvbnN0IGJ1ZmZlckNvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmJ1ZmZlckNvbnRyb2xsZXIodGhpcyk7XG4gICAgY29uc3QgY2FwTGV2ZWxDb250cm9sbGVyID0gbmV3IGNvbmZpZy5jYXBMZXZlbENvbnRyb2xsZXIodGhpcyk7XG4gICAgY29uc3QgZnBzQ29udHJvbGxlciA9IG5ldyBjb25maWcuZnBzQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBwbGF5TGlzdExvYWRlciA9IG5ldyBQbGF5bGlzdExvYWRlcih0aGlzKTtcbiAgICBjb25zdCBmcmFnbWVudExvYWRlciA9IG5ldyBGcmFnbWVudExvYWRlcih0aGlzKTtcbiAgICBjb25zdCBrZXlMb2FkZXIgPSBuZXcgS2V5TG9hZGVyKHRoaXMpO1xuICAgIGNvbnN0IGlkM1RyYWNrQ29udHJvbGxlciA9IG5ldyBJRDNUcmFja0NvbnRyb2xsZXIodGhpcyk7XG5cbiAgICAvLyBuZXR3b3JrIGNvbnRyb2xsZXJzXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtMZXZlbENvbnRyb2xsZXJ9IGxldmVsQ29udHJvbGxlclxuICAgICAqL1xuICAgIGNvbnN0IGxldmVsQ29udHJvbGxlciA9IHRoaXMubGV2ZWxDb250cm9sbGVyID0gbmV3IExldmVsQ29udHJvbGxlcih0aGlzKTtcblxuICAgIC8vIEZJWE1FOiBGcmFnbWVudFRyYWNrZXIgbXVzdCBiZSBkZWZpbmVkIGJlZm9yZSBTdHJlYW1Db250cm9sbGVyIGJlY2F1c2UgdGhlIG9yZGVyIG9mIGV2ZW50IGhhbmRsaW5nIGlzIGltcG9ydGFudFxuICAgIGNvbnN0IGZyYWdtZW50VHJhY2tlciA9IG5ldyBGcmFnbWVudFRyYWNrZXIodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtTdHJlYW1Db250cm9sbGVyfSBzdHJlYW1Db250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3Qgc3RyZWFtQ29udHJvbGxlciA9IHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IG5ldyBTdHJlYW1Db250cm9sbGVyKHRoaXMsIGZyYWdtZW50VHJhY2tlcik7XG5cbiAgICBsZXQgbmV0d29ya0NvbnRyb2xsZXJzID0gW2xldmVsQ29udHJvbGxlciwgc3RyZWFtQ29udHJvbGxlcl07XG5cbiAgICAvLyBvcHRpb25hbCBhdWRpbyBzdHJlYW0gY29udHJvbGxlclxuICAgIC8qKlxuICAgICAqIEB2YXIge0lDb3JlQ29tcG9uZW50IHwgQ29udHJvbGxlcn1cbiAgICAgKi9cbiAgICBsZXQgQ29udHJvbGxlciA9IGNvbmZpZy5hdWRpb1N0cmVhbUNvbnRyb2xsZXI7XG4gICAgaWYgKENvbnRyb2xsZXIpIHtcbiAgICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKG5ldyBDb250cm9sbGVyKHRoaXMsIGZyYWdtZW50VHJhY2tlcikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge0lOZXR3b3JrQ29udHJvbGxlcltdfSBuZXR3b3JrQ29udHJvbGxlcnNcbiAgICAgKi9cbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycyA9IG5ldHdvcmtDb250cm9sbGVycztcblxuICAgIC8qKlxuICAgICAqIEB2YXIge0lDb3JlQ29tcG9uZW50W119XG4gICAgICovXG4gICAgY29uc3QgY29yZUNvbXBvbmVudHMgPSBbXG4gICAgICBwbGF5TGlzdExvYWRlcixcbiAgICAgIGZyYWdtZW50TG9hZGVyLFxuICAgICAga2V5TG9hZGVyLFxuICAgICAgYWJyQ29udHJvbGxlcixcbiAgICAgIGJ1ZmZlckNvbnRyb2xsZXIsXG4gICAgICBjYXBMZXZlbENvbnRyb2xsZXIsXG4gICAgICBmcHNDb250cm9sbGVyLFxuICAgICAgaWQzVHJhY2tDb250cm9sbGVyLFxuICAgICAgZnJhZ21lbnRUcmFja2VyXG4gICAgXTtcblxuICAgIC8vIG9wdGlvbmFsIGF1ZGlvIHRyYWNrIGFuZCBzdWJ0aXRsZSBjb250cm9sbGVyXG4gICAgQ29udHJvbGxlciA9IGNvbmZpZy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICBpZiAoQ29udHJvbGxlcikge1xuICAgICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcih0aGlzKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtBdWRpb1RyYWNrQ29udHJvbGxlcn0gYXVkaW9UcmFja0NvbnRyb2xsZXJcbiAgICAgICAqL1xuICAgICAgdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlciA9IGF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgICAgY29yZUNvbXBvbmVudHMucHVzaChhdWRpb1RyYWNrQ29udHJvbGxlcik7XG4gICAgfVxuXG4gICAgQ29udHJvbGxlciA9IGNvbmZpZy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICBpZiAoQ29udHJvbGxlcikge1xuICAgICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcih0aGlzKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcn0gc3VidGl0bGVUcmFja0NvbnRyb2xsZXJcbiAgICAgICAqL1xuICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnB1c2goc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpO1xuICAgIH1cblxuICAgIENvbnRyb2xsZXIgPSBjb25maWcuZW1lQ29udHJvbGxlcjtcbiAgICBpZiAoQ29udHJvbGxlcikge1xuICAgICAgY29uc3QgZW1lQ29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKHRoaXMpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge0VNRUNvbnRyb2xsZXJ9IGVtZUNvbnRyb2xsZXJcbiAgICAgICAqL1xuICAgICAgdGhpcy5lbWVDb250cm9sbGVyID0gZW1lQ29udHJvbGxlcjtcbiAgICAgIGNvcmVDb21wb25lbnRzLnB1c2goZW1lQ29udHJvbGxlcik7XG4gICAgfVxuXG4gICAgLy8gb3B0aW9uYWwgc3VidGl0bGUgY29udHJvbGxlcnNcbiAgICBDb250cm9sbGVyID0gY29uZmlnLnN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjtcbiAgICBpZiAoQ29udHJvbGxlcikge1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnB1c2gobmV3IENvbnRyb2xsZXIodGhpcywgZnJhZ21lbnRUcmFja2VyKSk7XG4gICAgfVxuICAgIENvbnRyb2xsZXIgPSBjb25maWcudGltZWxpbmVDb250cm9sbGVyO1xuICAgIGlmIChDb250cm9sbGVyKSB7XG4gICAgICBjb3JlQ29tcG9uZW50cy5wdXNoKG5ldyBDb250cm9sbGVyKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtJQ29yZUNvbXBvbmVudFtdfVxuICAgICAqL1xuICAgIHRoaXMuY29yZUNvbXBvbmVudHMgPSBjb3JlQ29tcG9uZW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlIG9mIHRoZSBpbnN0YW5jZVxuICAgKi9cbiAgZGVzdHJveSAoKSB7XG4gICAgbG9nZ2VyLmxvZygnZGVzdHJveScpO1xuICAgIHRoaXMudHJpZ2dlcihIbHNFdmVudHMuREVTVFJPWUlORyk7XG4gICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuICAgIHRoaXMuY29yZUNvbXBvbmVudHMuY29uY2F0KHRoaXMubmV0d29ya0NvbnRyb2xsZXJzKS5mb3JFYWNoKGNvbXBvbmVudCA9PiB7XG4gICAgICBjb21wb25lbnQuZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIHRoaXMudXJsID0gbnVsbDtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYSBtZWRpYSBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTE1lZGlhRWxlbWVudH0gbWVkaWFcbiAgICovXG4gIGF0dGFjaE1lZGlhIChtZWRpYSkge1xuICAgIGxvZ2dlci5sb2coJ2F0dGFjaE1lZGlhJyk7XG4gICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xuICAgIHRoaXMudHJpZ2dlcihIbHNFdmVudHMuTUVESUFfQVRUQUNISU5HLCB7IG1lZGlhOiBtZWRpYSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRhY2ggZnJvbSB0aGUgbWVkaWFcbiAgICovXG4gIGRldGFjaE1lZGlhICgpIHtcbiAgICBsb2dnZXIubG9nKCdkZXRhY2hNZWRpYScpO1xuICAgIHRoaXMudHJpZ2dlcihIbHNFdmVudHMuTUVESUFfREVUQUNISU5HKTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNvdXJjZSBVUkwuIENhbiBiZSByZWxhdGl2ZSBvciBhYnNvbHV0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKi9cbiAgbG9hZFNvdXJjZSAodXJsKSB7XG4gICAgdXJsID0gVVJMVG9vbGtpdC5idWlsZEFic29sdXRlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB1cmwsIHsgYWx3YXlzTm9ybWFsaXplOiB0cnVlIH0pO1xuICAgIGxvZ2dlci5sb2coYGxvYWRTb3VyY2U6JHt1cmx9YCk7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgLy8gd2hlbiBhdHRhY2hpbmcgdG8gYSBzb3VyY2UgVVJMLCB0cmlnZ2VyIGEgcGxheWxpc3QgbG9hZFxuICAgIHRoaXMudHJpZ2dlcihIbHNFdmVudHMuTUFOSUZFU1RfTE9BRElORywgeyB1cmw6IHVybCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBsb2FkaW5nIGRhdGEgZnJvbSB0aGUgc3RyZWFtIHNvdXJjZS5cbiAgICogRGVwZW5kaW5nIG9uIGRlZmF1bHQgY29uZmlnLCBjbGllbnQgc3RhcnRzIGxvYWRpbmcgYXV0b21hdGljYWxseSB3aGVuIGEgc291cmNlIGlzIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0UG9zaXRpb24gU2V0IHRoZSBzdGFydCBwb3NpdGlvbiB0byBzdHJlYW0gZnJvbVxuICAgKiBAZGVmYXVsdCAtMSBOb25lIChmcm9tIGVhcmxpZXN0IHBvaW50KVxuICAgKi9cbiAgc3RhcnRMb2FkIChzdGFydFBvc2l0aW9uID0gLTEpIHtcbiAgICBsb2dnZXIubG9nKGBzdGFydExvYWQoJHtzdGFydFBvc2l0aW9ufSlgKTtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGNvbnRyb2xsZXIgPT4ge1xuICAgICAgY29udHJvbGxlci5zdGFydExvYWQoc3RhcnRQb3NpdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsb2FkaW5nIG9mIGFueSBzdHJlYW0gZGF0YS5cbiAgICovXG4gIHN0b3BMb2FkICgpIHtcbiAgICBsb2dnZXIubG9nKCdzdG9wTG9hZCcpO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goY29udHJvbGxlciA9PiB7XG4gICAgICBjb250cm9sbGVyLnN0b3BMb2FkKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3dhcCB0aHJvdWdoIHBvc3NpYmxlIGF1ZGlvIGNvZGVjcyBpbiB0aGUgc3RyZWFtIChmb3IgZXhhbXBsZSB0byBzd2l0Y2ggZnJvbSBzdGVyZW8gdG8gNS4xKVxuICAgKi9cbiAgc3dhcEF1ZGlvQ29kZWMgKCkge1xuICAgIGxvZ2dlci5sb2coJ3N3YXBBdWRpb0NvZGVjJyk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLnN3YXBBdWRpb0NvZGVjKCk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB0aGUgbWVkaWEtZWxlbWVudCBmYWlscywgdGhpcyBhbGxvd3MgdG8gZGV0YWNoIGFuZCB0aGVuIHJlLWF0dGFjaCBpdFxuICAgKiBhcyBvbmUgY2FsbCAoY29udmVuaWVuY2UgbWV0aG9kKS5cbiAgICpcbiAgICogQXV0b21hdGljIHJlY292ZXJ5IG9mIG1lZGlhLWVycm9ycyBieSB0aGlzIHByb2Nlc3MgaXMgY29uZmlndXJhYmxlLlxuICAgKi9cbiAgcmVjb3Zlck1lZGlhRXJyb3IgKCkge1xuICAgIGxvZ2dlci5sb2coJ3JlY292ZXJNZWRpYUVycm9yJyk7XG4gICAgbGV0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgdGhpcy5hdHRhY2hNZWRpYShtZWRpYSk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1F1YWxpdHlMZXZlbFtdfVxuICAgKi9cbiAgZ2V0IGxldmVscyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVscztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRleCBvZiBxdWFsaXR5IGxldmVsIGN1cnJlbnRseSBwbGF5ZWRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBjdXJyZW50TGV2ZWwgKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuY3VycmVudExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBxdWFsaXR5IGxldmVsIGluZGV4IGltbWVkaWF0ZWx5IC5cbiAgICogVGhpcyB3aWxsIGZsdXNoIHRoZSBjdXJyZW50IGJ1ZmZlciB0byByZXBsYWNlIHRoZSBxdWFsaXR5IGFzYXAuXG4gICAqIFRoYXQgbWVhbnMgcGxheWJhY2sgd2lsbCBpbnRlcnJ1cHQgYXQgbGVhc3Qgc2hvcnRseSB0byByZS1idWZmZXIgYW5kIHJlLXN5bmMgZXZlbnR1YWxseS5cbiAgICogQHR5cGUge251bWJlcn0gLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICovXG4gIHNldCBjdXJyZW50TGV2ZWwgKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGN1cnJlbnRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubG9hZExldmVsID0gbmV3TGV2ZWw7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLmltbWVkaWF0ZUxldmVsU3dpdGNoKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5kZXggb2YgbmV4dCBxdWFsaXR5IGxldmVsIGxvYWRlZCBhcyBzY2hlZHVsZWQgYnkgc3RyZWFtIGNvbnRyb2xsZXIuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbmV4dExldmVsICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBmb3IgbmV4dCBsb2FkZWQgZGF0YS5cbiAgICogVGhpcyB3aWxsIHN3aXRjaCB0aGUgdmlkZW8gcXVhbGl0eSBhc2FwLCB3aXRob3V0IGludGVycnVwdGluZyBwbGF5YmFjay5cbiAgICogTWF5IGFib3J0IGN1cnJlbnQgbG9hZGluZyBvZiBkYXRhLCBhbmQgZmx1c2ggcGFydHMgb2YgYnVmZmVyIChvdXRzaWRlIGN1cnJlbnRseSBwbGF5ZWQgZnJhZ21lbnQgcmVnaW9uKS5cbiAgICogQHR5cGUge251bWJlcn0gLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICovXG4gIHNldCBuZXh0TGV2ZWwgKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IG5leHRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcXVhbGl0eSBsZXZlbCBvZiB0aGUgY3VycmVudGx5IG9yIGxhc3QgKG9mIG5vbmUgaXMgbG9hZGVkIGN1cnJlbnRseSkgc2VnbWVudFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxvYWRMZXZlbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBxdWFsaXR5IGxldmVsIGluZGV4IGZvciBuZXh0IGxvYWRlZCBkYXRhIGluIGEgY29uc2VydmF0aXZlIHdheS5cbiAgICogVGhpcyB3aWxsIHN3aXRjaCB0aGUgcXVhbGl0eSB3aXRob3V0IGZsdXNoaW5nLCBidXQgaW50ZXJydXB0IGN1cnJlbnQgbG9hZGluZy5cbiAgICogVGh1cyB0aGUgbW9tZW50IHdoZW4gdGhlIHF1YWxpdHkgc3dpdGNoIHdpbGwgYXBwZWFyIGluIGVmZmVjdCB3aWxsIG9ubHkgYmUgYWZ0ZXIgdGhlIGFscmVhZHkgZXhpc3RpbmcgYnVmZmVyLlxuICAgKiBAdHlwZSB7bnVtYmVyfSBuZXdMZXZlbCAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvblxuICAgKi9cbiAgc2V0IGxvYWRMZXZlbCAobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgbG9hZExldmVsOiR7bmV3TGV2ZWx9YCk7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgbmV4dCBxdWFsaXR5IGxldmVsIGxvYWRlZFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG5leHRMb2FkTGV2ZWwgKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBxdWFsaXR5IGxldmVsIG9mIG5leHQgbG9hZGVkIHNlZ21lbnQgaW4gYSBmdWxseSBcIm5vbi1kZXN0cnVjdGl2ZVwiIHdheS5cbiAgICogU2FtZSBhcyBgbG9hZExldmVsYCBidXQgd2lsbCB3YWl0IGZvciBuZXh0IHN3aXRjaCAodW50aWwgY3VycmVudCBsb2FkaW5nIGlzIGRvbmUpLlxuICAgKiBAdHlwZSB7bnVtYmVyfSBsZXZlbFxuICAgKi9cbiAgc2V0IG5leHRMb2FkTGV2ZWwgKGxldmVsKSB7XG4gICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubmV4dExvYWRMZXZlbCA9IGxldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBcImZpcnN0IGxldmVsXCI6IGxpa2UgYSBkZWZhdWx0IGxldmVsLCBpZiBub3Qgc2V0LFxuICAgKiBmYWxscyBiYWNrIHRvIGluZGV4IG9mIGZpcnN0IGxldmVsIHJlZmVyZW5jZWQgaW4gbWFuaWZlc3RcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBmaXJzdExldmVsICgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbCwgdGhpcy5taW5BdXRvTGV2ZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgXCJmaXJzdC1sZXZlbFwiLCBzZWUgZ2V0dGVyLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2V0IGZpcnN0TGV2ZWwgKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGZpcnN0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXG4gICAqIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgKiBpZiAtMSA6IGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24sIHBsYXliYWNrIHdpbGwgc3RhcnQgZnJvbSBsZXZlbCBtYXRjaGluZyBkb3dubG9hZCBiYW5kd2lkdGhcbiAgICogKGRldGVybWluZWQgZnJvbSBkb3dubG9hZCBvZiBmaXJzdCBzZWdtZW50KVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHN0YXJ0TGV2ZWwgKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIHNldCAgc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICogaWYgbm90IG92ZXJyaWRlZCBieSB1c2VyLCBmaXJzdCBsZXZlbCBhcHBlYXJpbmcgaW4gbWFuaWZlc3Qgd2lsbCBiZSB1c2VkIGFzIHN0YXJ0IGxldmVsXG4gICAqIGlmIC0xIDogYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiwgcGxheWJhY2sgd2lsbCBzdGFydCBmcm9tIGxldmVsIG1hdGNoaW5nIGRvd25sb2FkIGJhbmR3aWR0aFxuICAgKiAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXG4gICAqIEB0eXBlIHtudW1iZXJ9IG5ld0xldmVsXG4gICAqL1xuICBzZXQgc3RhcnRMZXZlbCAobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgc3RhcnRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIGNvbnN0IGhscyA9IHRoaXM7XG4gICAgLy8gaWYgbm90IGluIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBkZXRlY3Rpb24sIGVuc3VyZSBzdGFydExldmVsIGlzIGdyZWF0ZXIgdGhhbiBtaW5BdXRvTGV2ZWxcbiAgICBpZiAobmV3TGV2ZWwgIT09IC0xKSB7XG4gICAgICBuZXdMZXZlbCA9IE1hdGgubWF4KG5ld0xldmVsLCBobHMubWluQXV0b0xldmVsKTtcbiAgICB9XG5cbiAgICBobHMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtIChgQUJSQ29udHJvbGxlcmApXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgYXV0b0xldmVsQ2FwcGluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9MZXZlbENhcHBpbmc7XG4gIH1cblxuICAvKipcbiAgICogQ2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBzaG91bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAoYEFCUkNvbnRyb2xsZXJgKVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2V0IGF1dG9MZXZlbENhcHBpbmcgKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGF1dG9MZXZlbENhcHBpbmc6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogVHJ1ZSB3aGVuIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gZW5hYmxlZFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBhdXRvTGV2ZWxFbmFibGVkICgpIHtcbiAgICByZXR1cm4gKHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID09PSAtMSk7XG4gIH1cblxuICAvKipcbiAgICogTGV2ZWwgc2V0IG1hbnVhbGx5IChpZiBhbnkpXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWFudWFsTGV2ZWwgKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBtaW4gbGV2ZWwgc2VsZWN0YWJsZSBpbiBhdXRvIG1vZGUgYWNjb3JkaW5nIHRvIGNvbmZpZy5taW5BdXRvQml0cmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbkF1dG9MZXZlbCAoKSB7XG4gICAgbGV0IGhscyA9IHRoaXMsIGxldmVscyA9IGhscy5sZXZlbHMsIG1pbkF1dG9CaXRyYXRlID0gaGxzLmNvbmZpZy5taW5BdXRvQml0cmF0ZSwgbGVuID0gbGV2ZWxzID8gbGV2ZWxzLmxlbmd0aCA6IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgbGV2ZWxOZXh0Qml0cmF0ZSA9IGxldmVsc1tpXS5yZWFsQml0cmF0ZSA/IE1hdGgubWF4KGxldmVsc1tpXS5yZWFsQml0cmF0ZSwgbGV2ZWxzW2ldLmJpdHJhdGUpIDogbGV2ZWxzW2ldLmJpdHJhdGU7XG4gICAgICBpZiAobGV2ZWxOZXh0Qml0cmF0ZSA+IG1pbkF1dG9CaXRyYXRlKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBtYXggbGV2ZWwgc2VsZWN0YWJsZSBpbiBhdXRvIG1vZGUgYWNjb3JkaW5nIHRvIGF1dG9MZXZlbENhcHBpbmdcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtYXhBdXRvTGV2ZWwgKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXM7XG4gICAgY29uc3QgbGV2ZWxzID0gaGxzLmxldmVscztcbiAgICBjb25zdCBhdXRvTGV2ZWxDYXBwaW5nID0gaGxzLmF1dG9MZXZlbENhcHBpbmc7XG4gICAgbGV0IG1heEF1dG9MZXZlbDtcbiAgICBpZiAoYXV0b0xldmVsQ2FwcGluZyA9PT0gLTEgJiYgbGV2ZWxzICYmIGxldmVscy5sZW5ndGgpIHtcbiAgICAgIG1heEF1dG9MZXZlbCA9IGxldmVscy5sZW5ndGggLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhBdXRvTGV2ZWwgPSBhdXRvTGV2ZWxDYXBwaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBtYXhBdXRvTGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogbmV4dCBhdXRvbWF0aWNhbGx5IHNlbGVjdGVkIHF1YWxpdHkgbGV2ZWxcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBuZXh0QXV0b0xldmVsICgpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzO1xuICAgIC8vIGVuc3VyZSBuZXh0IGF1dG8gbGV2ZWwgaXMgYmV0d2VlbiAgbWluIGFuZCBtYXggYXV0byBsZXZlbFxuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChobHMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsLCBobHMubWluQXV0b0xldmVsKSwgaGxzLm1heEF1dG9MZXZlbCk7XG4gIH1cblxuICAvKipcbiAgICogdGhpcyBzZXR0ZXIgaXMgdXNlZCB0byBmb3JjZSBuZXh0IGF1dG8gbGV2ZWwuXG4gICAqIHRoaXMgaXMgdXNlZnVsIHRvIGZvcmNlIGEgc3dpdGNoIGRvd24gaW4gYXV0byBtb2RlOlxuICAgKiBpbiBjYXNlIG9mIGxvYWQgZXJyb3Igb24gbGV2ZWwgTiwgaGxzLmpzIGNhbiBzZXQgbmV4dEF1dG9MZXZlbCB0byBOLTEgZm9yIGV4YW1wbGUpXG4gICAqIGZvcmNlZCB2YWx1ZSBpcyB2YWxpZCBmb3Igb25lIGZyYWdtZW50LiB1cG9uIHN1Y2Nlc2Z1bCBmcmFnIGxvYWRpbmcgYXQgZm9yY2VkIGxldmVsLFxuICAgKiB0aGlzIHZhbHVlIHdpbGwgYmUgcmVzZXR0ZWQgdG8gLTEgYnkgQUJSIGNvbnRyb2xsZXIuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzZXQgbmV4dEF1dG9MZXZlbCAobmV4dExldmVsKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcztcbiAgICBobHMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsID0gTWF0aC5tYXgoaGxzLm1pbkF1dG9MZXZlbCwgbmV4dExldmVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXVkaW9UcmFja1tdfVxuICAgKi9cbiAgZ2V0IGF1ZGlvVHJhY2tzICgpIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFja3MgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgYXVkaW8gdHJhY2sgKGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGF1ZGlvVHJhY2sgKCkge1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gYXVkaW9UcmFja0NvbnRyb2xsZXIgPyBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrIDogLTE7XG4gIH1cblxuICAvKipcbiAgICogc2VsZWN0cyBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzZXQgYXVkaW9UcmFjayAoYXVkaW9UcmFja0lkKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChhdWRpb1RyYWNrQ29udHJvbGxlcikge1xuICAgICAgYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjayA9IGF1ZGlvVHJhY2tJZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1NlY29uZHN9XG4gICAqL1xuICBnZXQgbGl2ZVN5bmNQb3NpdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5saXZlU3luY1Bvc2l0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdFxuICAgKiBAdHlwZSB7U3VidGl0bGVUcmFja1tdfVxuICAgKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2tzICgpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFja3MgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2sgKCkge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrIDogLTE7XG4gIH1cblxuICAvKipcbiAgICogc2VsZWN0IGFuIHN1YnRpdGxlIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHNcbiAgICogQHR5cGV7bnVtYmVyfVxuICAgKi9cbiAgc2V0IHN1YnRpdGxlVHJhY2sgKHN1YnRpdGxlVHJhY2tJZCkge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICBpZiAoc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgPSBzdWJ0aXRsZVRyYWNrSWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IHN1YnRpdGxlRGlzcGxheSAoKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlRGlzcGxheSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZS9kaXNhYmxlIHN1YnRpdGxlIGRpc3BsYXkgcmVuZGVyaW5nXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc2V0IHN1YnRpdGxlRGlzcGxheSAodmFsdWUpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZURpc3BsYXkgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IGdldE1lZGlhU291cmNlIH0gZnJvbSAnLi91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTdXBwb3J0ZWQgKCkge1xuICBjb25zdCBtZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKCk7XG4gIGNvbnN0IHNvdXJjZUJ1ZmZlciA9IHdpbmRvdy5Tb3VyY2VCdWZmZXIgfHwgd2luZG93LldlYktpdFNvdXJjZUJ1ZmZlcjtcbiAgY29uc3QgaXNUeXBlU3VwcG9ydGVkID0gbWVkaWFTb3VyY2UgJiZcbiAgICB0eXBlb2YgbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkID09PSAnZnVuY3Rpb24nICYmXG4gICAgbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJFMDFFLG1wNGEuNDAuMlwiJyk7XG5cbiAgLy8gaWYgU291cmNlQnVmZmVyIGlzIGV4cG9zZWQgZW5zdXJlIGl0cyBBUEkgaXMgdmFsaWRcbiAgLy8gc2FmYXJpIGFuZCBvbGQgdmVyc2lvbiBvZiBDaHJvbWUgZG9lIG5vdCBleHBvc2UgU291cmNlQnVmZmVyIGdsb2JhbGx5IHNvIGNoZWNraW5nIFNvdXJjZUJ1ZmZlci5wcm90b3R5cGUgaXMgaW1wb3NzaWJsZVxuICBjb25zdCBzb3VyY2VCdWZmZXJWYWxpZEFQSSA9ICFzb3VyY2VCdWZmZXIgfHxcbiAgICAoc291cmNlQnVmZmVyLnByb3RvdHlwZSAmJlxuICAgICAgdHlwZW9mIHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUuYXBwZW5kQnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2Ygc291cmNlQnVmZmVyLnByb3RvdHlwZS5yZW1vdmUgPT09ICdmdW5jdGlvbicpO1xuICByZXR1cm4gISFpc1R5cGVTdXBwb3J0ZWQgJiYgISFzb3VyY2VCdWZmZXJWYWxpZEFQSTtcbn1cbiIsIi8qXG4gKiBGcmFnbWVudCBMb2FkZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jbGFzcyBGcmFnbWVudExvYWRlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChobHMpIHtcbiAgICBzdXBlcihobHMsIEV2ZW50LkZSQUdfTE9BRElORyk7XG4gICAgdGhpcy5sb2FkZXJzID0ge307XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBsZXQgbG9hZGVycyA9IHRoaXMubG9hZGVycztcbiAgICBmb3IgKGxldCBsb2FkZXJOYW1lIGluIGxvYWRlcnMpIHtcbiAgICAgIGxldCBsb2FkZXIgPSBsb2FkZXJzW2xvYWRlck5hbWVdO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcblxuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIG9uRnJhZ0xvYWRpbmcgKGRhdGEpIHtcbiAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgdHlwZSA9IGZyYWcudHlwZSxcbiAgICAgIGxvYWRlcnMgPSB0aGlzLmxvYWRlcnMsXG4gICAgICBjb25maWcgPSB0aGlzLmhscy5jb25maWcsXG4gICAgICBGcmFnbWVudElMb2FkZXIgPSBjb25maWcuZkxvYWRlcixcbiAgICAgIERlZmF1bHRJTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcblxuICAgIC8vIHJlc2V0IGZyYWdtZW50IHN0YXRlXG4gICAgZnJhZy5sb2FkZWQgPSAwO1xuXG4gICAgbGV0IGxvYWRlciA9IGxvYWRlcnNbdHlwZV07XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9nZ2VyLndhcm4oYGFib3J0IHByZXZpb3VzIGZyYWdtZW50IGxvYWRlciBmb3IgdHlwZTogJHt0eXBlfWApO1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgbG9hZGVyID0gbG9hZGVyc1t0eXBlXSA9IGZyYWcubG9hZGVyID1cbiAgICAgIGNvbmZpZy5mTG9hZGVyID8gbmV3IEZyYWdtZW50SUxvYWRlcihjb25maWcpIDogbmV3IERlZmF1bHRJTG9hZGVyKGNvbmZpZyk7XG5cbiAgICBsZXQgbG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3M7XG5cbiAgICBsb2FkZXJDb250ZXh0ID0geyB1cmw6IGZyYWcudXJsLCBmcmFnOiBmcmFnLCByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsIHByb2dyZXNzRGF0YTogZmFsc2UgfTtcblxuICAgIGxldCBzdGFydCA9IGZyYWcuYnl0ZVJhbmdlU3RhcnRPZmZzZXQsXG4gICAgICBlbmQgPSBmcmFnLmJ5dGVSYW5nZUVuZE9mZnNldDtcblxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc3RhcnQpICYmIE51bWJlci5pc0Zpbml0ZShlbmQpKSB7XG4gICAgICBsb2FkZXJDb250ZXh0LnJhbmdlU3RhcnQgPSBzdGFydDtcbiAgICAgIGxvYWRlckNvbnRleHQucmFuZ2VFbmQgPSBlbmQ7XG4gICAgfVxuXG4gICAgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgdGltZW91dDogY29uZmlnLmZyYWdMb2FkaW5nVGltZU91dCxcbiAgICAgIG1heFJldHJ5OiAwLFxuICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgIG1heFJldHJ5RGVsYXk6IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dFxuICAgIH07XG5cbiAgICBsb2FkZXJDYWxsYmFja3MgPSB7XG4gICAgICBvblN1Y2Nlc3M6IHRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSxcbiAgICAgIG9uRXJyb3I6IHRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblRpbWVvdXQ6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSxcbiAgICAgIG9uUHJvZ3Jlc3M6IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9O1xuXG4gICAgbG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICB9XG5cbiAgbG9hZHN1Y2Nlc3MgKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMgPSBudWxsKSB7XG4gICAgbGV0IHBheWxvYWQgPSByZXNwb25zZS5kYXRhLCBmcmFnID0gY29udGV4dC5mcmFnO1xuICAgIC8vIGRldGFjaCBmcmFnbWVudCBsb2FkZXIgb24gbG9hZCBzdWNjZXNzXG4gICAgZnJhZy5sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sb2FkZXJzW2ZyYWcudHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURFRCwgeyBwYXlsb2FkOiBwYXlsb2FkLCBmcmFnOiBmcmFnLCBzdGF0czogc3RhdHMsIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyB9KTtcbiAgfVxuXG4gIGxvYWRlcnJvciAocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzID0gbnVsbCkge1xuICAgIGNvbnN0IGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgbGV0IGxvYWRlciA9IGZyYWcubG9hZGVyO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIHRoaXMubG9hZGVyc1tmcmFnLnR5cGVdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SLCBmYXRhbDogZmFsc2UsIGZyYWc6IGNvbnRleHQuZnJhZywgcmVzcG9uc2U6IHJlc3BvbnNlLCBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMgfSk7XG4gIH1cblxuICBsb2FkdGltZW91dCAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzID0gbnVsbCkge1xuICAgIGNvbnN0IGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgbGV0IGxvYWRlciA9IGZyYWcubG9hZGVyO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIHRoaXMubG9hZGVyc1tmcmFnLnR5cGVdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQsIGZhdGFsOiBmYWxzZSwgZnJhZzogY29udGV4dC5mcmFnLCBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMgfSk7XG4gIH1cblxuICAvLyBkYXRhIHdpbGwgYmUgdXNlZCBmb3IgcHJvZ3Jlc3NpdmUgcGFyc2luZ1xuICBsb2FkcHJvZ3Jlc3MgKHN0YXRzLCBjb250ZXh0LCBkYXRhLCBuZXR3b3JrRGV0YWlscyA9IG51bGwpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgbGV0IGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgZnJhZy5sb2FkZWQgPSBzdGF0cy5sb2FkZWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5GUkFHX0xPQURfUFJPR1JFU1MsIHsgZnJhZzogZnJhZywgc3RhdHM6IHN0YXRzLCBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRnJhZ21lbnRMb2FkZXI7XG4iLCJcbmltcG9ydCAqIGFzIFVSTFRvb2xraXQgZnJvbSAndXJsLXRvb2xraXQnO1xuXG5pbXBvcnQgTGV2ZWxLZXkgZnJvbSAnLi9sZXZlbC1rZXknO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGcmFnbWVudCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl91cmwgPSBudWxsO1xuICAgIHRoaXMuX2J5dGVSYW5nZSA9IG51bGw7XG4gICAgdGhpcy5fZGVjcnlwdGRhdGEgPSBudWxsO1xuICAgIHRoaXMudGFnTGlzdCA9IFtdO1xuICAgIHRoaXMucHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICB0aGlzLnJhd1Byb2dyYW1EYXRlVGltZSA9IG51bGw7XG5cbiAgICAvLyBIb2xkcyB0aGUgdHlwZXMgb2YgZGF0YSB0aGlzIGZyYWdtZW50IHN1cHBvcnRzXG4gICAgdGhpcy5fZWxlbWVudGFyeVN0cmVhbXMgPSB7XG4gICAgICBbRnJhZ21lbnQuRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXTogZmFsc2UsXG4gICAgICBbRnJhZ21lbnQuRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXTogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIGB0eXBlYCBwcm9wZXJ0eSBmb3IgdGhpcy5fZWxlbWVudGFyeVN0cmVhbXNcbiAgICpcbiAgICogQGVudW1cbiAgICovXG4gIHN0YXRpYyBnZXQgRWxlbWVudGFyeVN0cmVhbVR5cGVzICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgQVVESU86ICdhdWRpbycsXG4gICAgICBWSURFTzogJ3ZpZGVvJ1xuICAgIH07XG4gIH1cblxuICBnZXQgdXJsICgpIHtcbiAgICBpZiAoIXRoaXMuX3VybCAmJiB0aGlzLnJlbHVybCkge1xuICAgICAgdGhpcy5fdXJsID0gVVJMVG9vbGtpdC5idWlsZEFic29sdXRlVVJMKHRoaXMuYmFzZXVybCwgdGhpcy5yZWx1cmwsIHsgYWx3YXlzTm9ybWFsaXplOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl91cmw7XG4gIH1cblxuICBzZXQgdXJsICh2YWx1ZSkge1xuICAgIHRoaXMuX3VybCA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IGJ5dGVSYW5nZSAoKSB7XG4gICAgaWYgKCF0aGlzLl9ieXRlUmFuZ2UgJiYgIXRoaXMucmF3Qnl0ZVJhbmdlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2J5dGVSYW5nZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2J5dGVSYW5nZTtcbiAgICB9XG5cbiAgICBsZXQgYnl0ZVJhbmdlID0gW107XG4gICAgaWYgKHRoaXMucmF3Qnl0ZVJhbmdlKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnJhd0J5dGVSYW5nZS5zcGxpdCgnQCcsIDIpO1xuICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgbGFzdEJ5dGVSYW5nZUVuZE9mZnNldCA9IHRoaXMubGFzdEJ5dGVSYW5nZUVuZE9mZnNldDtcbiAgICAgICAgYnl0ZVJhbmdlWzBdID0gbGFzdEJ5dGVSYW5nZUVuZE9mZnNldCB8fCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnl0ZVJhbmdlWzBdID0gcGFyc2VJbnQocGFyYW1zWzFdKTtcbiAgICAgIH1cbiAgICAgIGJ5dGVSYW5nZVsxXSA9IHBhcnNlSW50KHBhcmFtc1swXSkgKyBieXRlUmFuZ2VbMF07XG4gICAgICB0aGlzLl9ieXRlUmFuZ2UgPSBieXRlUmFuZ2U7XG4gICAgfVxuICAgIHJldHVybiBieXRlUmFuZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBieXRlUmFuZ2VTdGFydE9mZnNldCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzBdO1xuICB9XG5cbiAgZ2V0IGJ5dGVSYW5nZUVuZE9mZnNldCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzFdO1xuICB9XG5cbiAgZ2V0IGRlY3J5cHRkYXRhICgpIHtcbiAgICBpZiAoIXRoaXMuX2RlY3J5cHRkYXRhKSB7XG4gICAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IHRoaXMuZnJhZ21lbnREZWNyeXB0ZGF0YUZyb21MZXZlbGtleSh0aGlzLmxldmVsa2V5LCB0aGlzLnNuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZGVjcnlwdGRhdGE7XG4gIH1cblxuICBnZXQgZW5kUHJvZ3JhbURhdGVUaW1lICgpIHtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh0aGlzLnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBkdXJhdGlvbiA9ICFOdW1iZXIuaXNGaW5pdGUodGhpcy5kdXJhdGlvbikgPyAwIDogdGhpcy5kdXJhdGlvbjtcblxuICAgIHJldHVybiB0aGlzLnByb2dyYW1EYXRlVGltZSArIChkdXJhdGlvbiAqIDEwMDApO1xuICB9XG5cbiAgZ2V0IGVuY3J5cHRlZCAoKSB7XG4gICAgcmV0dXJuICEhKCh0aGlzLmRlY3J5cHRkYXRhICYmIHRoaXMuZGVjcnlwdGRhdGEudXJpICE9PSBudWxsKSAmJiAodGhpcy5kZWNyeXB0ZGF0YS5rZXkgPT09IG51bGwpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnRhcnlTdHJlYW1UeXBlfSB0eXBlXG4gICAqL1xuICBhZGRFbGVtZW50YXJ5U3RyZWFtICh0eXBlKSB7XG4gICAgdGhpcy5fZWxlbWVudGFyeVN0cmVhbXNbdHlwZV0gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudGFyeVN0cmVhbVR5cGV9IHR5cGVcbiAgICovXG4gIGhhc0VsZW1lbnRhcnlTdHJlYW0gKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudGFyeVN0cmVhbXNbdHlwZV0gPT09IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBtZXRob2QgZm9yIHBhcnNlTGV2ZWxQbGF5bGlzdCB0byBjcmVhdGUgYW4gaW5pdGlhbGl6YXRpb24gdmVjdG9yIGZvciBhIGdpdmVuIHNlZ21lbnRcbiAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAqL1xuICBjcmVhdGVJbml0aWFsaXphdGlvblZlY3RvciAoc2VnbWVudE51bWJlcikge1xuICAgIGxldCB1aW50OFZpZXcgPSBuZXcgVWludDhBcnJheSgxNik7XG5cbiAgICBmb3IgKGxldCBpID0gMTI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICB1aW50OFZpZXdbaV0gPSAoc2VnbWVudE51bWJlciA+PiA4ICogKDE1IC0gaSkpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gdWludDhWaWV3O1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIGZvciBwYXJzZUxldmVsUGxheWxpc3QgdG8gZ2V0IGEgZnJhZ21lbnQncyBkZWNyeXB0aW9uIGRhdGEgZnJvbSB0aGUgY3VycmVudGx5IHBhcnNlZCBlbmNyeXB0aW9uIGtleSBkYXRhXG4gICAqIEBwYXJhbSBsZXZlbGtleSAtIGEgcGxheWxpc3QncyBlbmNyeXB0aW9uIGluZm9cbiAgICogQHBhcmFtIHNlZ21lbnROdW1iZXIgLSB0aGUgZnJhZ21lbnQncyBzZWdtZW50IG51bWJlclxuICAgKiBAcmV0dXJucyB7Kn0gLSBhbiBvYmplY3QgdG8gYmUgYXBwbGllZCBhcyBhIGZyYWdtZW50J3MgZGVjcnlwdGRhdGFcbiAgICovXG4gIGZyYWdtZW50RGVjcnlwdGRhdGFGcm9tTGV2ZWxrZXkgKGxldmVsa2V5LCBzZWdtZW50TnVtYmVyKSB7XG4gICAgbGV0IGRlY3J5cHRkYXRhID0gbGV2ZWxrZXk7XG5cbiAgICBpZiAobGV2ZWxrZXkgJiYgbGV2ZWxrZXkubWV0aG9kICYmIGxldmVsa2V5LnVyaSAmJiAhbGV2ZWxrZXkuaXYpIHtcbiAgICAgIGRlY3J5cHRkYXRhID0gbmV3IExldmVsS2V5KCk7XG4gICAgICBkZWNyeXB0ZGF0YS5tZXRob2QgPSBsZXZlbGtleS5tZXRob2Q7XG4gICAgICBkZWNyeXB0ZGF0YS5iYXNldXJpID0gbGV2ZWxrZXkuYmFzZXVyaTtcbiAgICAgIGRlY3J5cHRkYXRhLnJlbHVyaSA9IGxldmVsa2V5LnJlbHVyaTtcbiAgICAgIGRlY3J5cHRkYXRhLml2ID0gdGhpcy5jcmVhdGVJbml0aWFsaXphdGlvblZlY3RvcihzZWdtZW50TnVtYmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVjcnlwdGRhdGE7XG4gIH1cbn1cbiIsIi8qXG4gKiBEZWNyeXB0IGtleSBMb2FkZXJcbiovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5jbGFzcyBLZXlMb2FkZXIgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCBFdmVudC5LRVlfTE9BRElORyk7XG4gICAgdGhpcy5sb2FkZXJzID0ge307XG4gICAgdGhpcy5kZWNyeXB0a2V5ID0gbnVsbDtcbiAgICB0aGlzLmRlY3J5cHR1cmwgPSBudWxsO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgZm9yIChsZXQgbG9hZGVyTmFtZSBpbiB0aGlzLmxvYWRlcnMpIHtcbiAgICAgIGxldCBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbbG9hZGVyTmFtZV07XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubG9hZGVycyA9IHt9O1xuICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgb25LZXlMb2FkaW5nIChkYXRhKSB7XG4gICAgbGV0IGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICB0eXBlID0gZnJhZy50eXBlLFxuICAgICAgbG9hZGVyID0gdGhpcy5sb2FkZXJzW3R5cGVdLFxuICAgICAgZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhLFxuICAgICAgdXJpID0gZGVjcnlwdGRhdGEudXJpO1xuICAgIC8vIGlmIHVyaSBpcyBkaWZmZXJlbnQgZnJvbSBwcmV2aW91cyBvbmUgb3IgaWYgZGVjcnlwdCBrZXkgbm90IHJldHJpZXZlZCB5ZXRcbiAgICBpZiAodXJpICE9PSB0aGlzLmRlY3J5cHR1cmwgfHwgdGhpcy5kZWNyeXB0a2V5ID09PSBudWxsKSB7XG4gICAgICBsZXQgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuXG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBhYm9ydCBwcmV2aW91cyBrZXkgbG9hZGVyIGZvciB0eXBlOiR7dHlwZX1gKTtcbiAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICBmcmFnLmxvYWRlciA9IHRoaXMubG9hZGVyc1t0eXBlXSA9IG5ldyBjb25maWcubG9hZGVyKGNvbmZpZyk7XG4gICAgICB0aGlzLmRlY3J5cHR1cmwgPSB1cmk7XG4gICAgICB0aGlzLmRlY3J5cHRrZXkgPSBudWxsO1xuXG4gICAgICBsZXQgbG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3M7XG4gICAgICBsb2FkZXJDb250ZXh0ID0geyB1cmw6IHVyaSwgZnJhZzogZnJhZywgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInIH07XG4gICAgICAvLyBtYXhSZXRyeSBpcyAwIHNvIHRoYXQgaW5zdGVhZCBvZiByZXRyeWluZyB0aGUgc2FtZSBrZXkgb24gdGhlIHNhbWUgdmFyaWFudCBtdWx0aXBsZSB0aW1lcyxcbiAgICAgIC8vIGtleS1sb2FkZXIgd2lsbCB0cmlnZ2VyIGFuIGVycm9yIGFuZCByZWx5IG9uIHN0cmVhbS1jb250cm9sbGVyIHRvIGhhbmRsZSByZXRyeSBsb2dpYy5cbiAgICAgIC8vIHRoaXMgd2lsbCBhbHNvIGFsaWduIHJldHJ5IGxvZ2ljIHdpdGggZnJhZ21lbnQtbG9hZGVyXG4gICAgICBsb2FkZXJDb25maWcgPSB7IHRpbWVvdXQ6IGNvbmZpZy5mcmFnTG9hZGluZ1RpbWVPdXQsIG1heFJldHJ5OiAwLCByZXRyeURlbGF5OiBjb25maWcuZnJhZ0xvYWRpbmdSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5OiBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQgfTtcbiAgICAgIGxvYWRlckNhbGxiYWNrcyA9IHsgb25TdWNjZXNzOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksIG9uRXJyb3I6IHRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksIG9uVGltZW91dDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpIH07XG4gICAgICBmcmFnLmxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGVjcnlwdGtleSkge1xuICAgICAgLy8gd2UgYWxyZWFkeSBsb2FkZWQgdGhpcyBrZXksIHJldHVybiBpdFxuICAgICAgZGVjcnlwdGRhdGEua2V5ID0gdGhpcy5kZWNyeXB0a2V5O1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5LRVlfTE9BREVELCB7IGZyYWc6IGZyYWcgfSk7XG4gICAgfVxuICB9XG5cbiAgbG9hZHN1Y2Nlc3MgKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCkge1xuICAgIGxldCBmcmFnID0gY29udGV4dC5mcmFnO1xuICAgIHRoaXMuZGVjcnlwdGtleSA9IGZyYWcuZGVjcnlwdGRhdGEua2V5ID0gbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UuZGF0YSk7XG4gICAgLy8gZGV0YWNoIGZyYWdtZW50IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcbiAgICBmcmFnLmxvYWRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxvYWRlcnNbZnJhZy50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LktFWV9MT0FERUQsIHsgZnJhZzogZnJhZyB9KTtcbiAgfVxuXG4gIGxvYWRlcnJvciAocmVzcG9uc2UsIGNvbnRleHQpIHtcbiAgICBsZXQgZnJhZyA9IGNvbnRleHQuZnJhZyxcbiAgICAgIGxvYWRlciA9IGZyYWcubG9hZGVyO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIHsgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLCBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZywgcmVzcG9uc2U6IHJlc3BvbnNlIH0pO1xuICB9XG5cbiAgbG9hZHRpbWVvdXQgKHN0YXRzLCBjb250ZXh0KSB7XG4gICAgbGV0IGZyYWcgPSBjb250ZXh0LmZyYWcsXG4gICAgICBsb2FkZXIgPSBmcmFnLmxvYWRlcjtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQsIGZhdGFsOiBmYWxzZSwgZnJhZzogZnJhZyB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBLZXlMb2FkZXI7XG4iLCJpbXBvcnQgKiBhcyBVUkxUb29sa2l0IGZyb20gJ3VybC10b29sa2l0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGV2ZWxLZXkge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5tZXRob2QgPSBudWxsO1xuICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICB0aGlzLml2ID0gbnVsbDtcbiAgICB0aGlzLl91cmkgPSBudWxsO1xuICB9XG5cbiAgZ2V0IHVyaSAoKSB7XG4gICAgaWYgKCF0aGlzLl91cmkgJiYgdGhpcy5yZWx1cmkpIHtcbiAgICAgIHRoaXMuX3VyaSA9IFVSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVVSTCh0aGlzLmJhc2V1cmksIHRoaXMucmVsdXJpLCB7IGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdXJpO1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBMZXZlbCB7XG4gIGNvbnN0cnVjdG9yIChiYXNlVXJsKSB7XG4gICAgLy8gUGxlYXNlIGtlZXAgcHJvcGVydGllcyBpbiBhbHBoYWJldGljYWwgb3JkZXJcbiAgICB0aGlzLmVuZENDID0gMDtcbiAgICB0aGlzLmVuZFNOID0gMDtcbiAgICB0aGlzLmZyYWdtZW50cyA9IFtdO1xuICAgIHRoaXMuaW5pdFNlZ21lbnQgPSBudWxsO1xuICAgIHRoaXMubGl2ZSA9IHRydWU7XG4gICAgdGhpcy5uZWVkU2lkeFJhbmdlcyA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRDQyA9IDA7XG4gICAgdGhpcy5zdGFydFNOID0gMDtcbiAgICB0aGlzLnN0YXJ0VGltZU9mZnNldCA9IG51bGw7XG4gICAgdGhpcy50YXJnZXRkdXJhdGlvbiA9IDA7XG4gICAgdGhpcy50b3RhbGR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgIHRoaXMudXJsID0gYmFzZVVybDtcbiAgICB0aGlzLnZlcnNpb24gPSBudWxsO1xuICB9XG5cbiAgZ2V0IGhhc1Byb2dyYW1EYXRlVGltZSAoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuZnJhZ21lbnRzWzBdICYmIE51bWJlci5pc0Zpbml0ZSh0aGlzLmZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWUpKTtcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgVVJMVG9vbGtpdCBmcm9tICd1cmwtdG9vbGtpdCc7XG5cbmltcG9ydCBGcmFnbWVudCBmcm9tICcuL2ZyYWdtZW50JztcbmltcG9ydCBMZXZlbCBmcm9tICcuL2xldmVsJztcbmltcG9ydCBMZXZlbEtleSBmcm9tICcuL2xldmVsLWtleSc7XG5cbmltcG9ydCBBdHRyTGlzdCBmcm9tICcuLi91dGlscy9hdHRyLWxpc3QnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IGlzQ29kZWNUeXBlIH0gZnJvbSAnLi4vdXRpbHMvY29kZWNzJztcblxuLyoqXG4gKiBNM1U4IHBhcnNlclxuICogQG1vZHVsZVxuICovXG5cbi8vIGh0dHBzOi8vcmVnZXgxMDEuY29tIGlzIHlvdXIgZnJpZW5kXG5jb25zdCBNQVNURVJfUExBWUxJU1RfUkVHRVggPSAvI0VYVC1YLVNUUkVBTS1JTkY6KFteXFxuXFxyXSopW1xcclxcbl0rKFteXFxyXFxuXSspL2c7XG5jb25zdCBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVggPSAvI0VYVC1YLU1FRElBOiguKikvZztcblxuY29uc3QgTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVCA9IG5ldyBSZWdFeHAoW1xuICAvI0VYVElORjpcXHMqKFxcZCooPzpcXC5cXGQrKT8pKD86LCguKilcXHMrKT8vLnNvdXJjZSwgLy8gZHVyYXRpb24gKCNFWFRJTkY6PGR1cmF0aW9uPiw8dGl0bGU+KSwgZ3JvdXAgMSA9PiBkdXJhdGlvbiwgZ3JvdXAgMiA9PiB0aXRsZVxuICAvfCg/ISMpKFtcXFMrID9dKykvLnNvdXJjZSwgLy8gc2VnbWVudCBVUkksIGdyb3VwIDMgPT4gdGhlIFVSSSAobm90ZSBuZXdsaW5lIGlzIG5vdCBlYXRlbilcbiAgL3wjRVhULVgtQllURVJBTkdFOiooLispLy5zb3VyY2UsIC8vIG5leHQgc2VnbWVudCdzIGJ5dGVyYW5nZSwgZ3JvdXAgNCA9PiByYW5nZSBzcGVjICh4QHkpXG4gIC98I0VYVC1YLVBST0dSQU0tREFURS1USU1FOiguKykvLnNvdXJjZSwgLy8gbmV4dCBzZWdtZW50J3MgcHJvZ3JhbSBkYXRlL3RpbWUgZ3JvdXAgNSA9PiB0aGUgZGF0ZXRpbWUgc3BlY1xuICAvfCMuKi8uc291cmNlIC8vIEFsbCBvdGhlciBub24tc2VnbWVudCBvcmllbnRlZCB0YWdzIHdpbGwgbWF0Y2ggd2l0aCBhbGwgZ3JvdXBzIGVtcHR5XG5dLmpvaW4oJycpLCAnZycpO1xuXG5jb25zdCBMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XID0gLyg/Oig/OiMoRVhUTTNVKSl8KD86I0VYVC1YLShQTEFZTElTVC1UWVBFKTooLispKXwoPzojRVhULVgtKE1FRElBLVNFUVVFTkNFKTogKihcXGQrKSl8KD86I0VYVC1YLShUQVJHRVREVVJBVElPTik6ICooXFxkKykpfCg/OiNFWFQtWC0oS0VZKTooLispKXwoPzojRVhULVgtKFNUQVJUKTooLispKXwoPzojRVhULVgtKEVORExJU1QpKXwoPzojRVhULVgtKERJU0NPTlRJTlVJVFktU0VRKVVFTkNFOihcXGQrKSl8KD86I0VYVC1YLShESVMpQ09OVElOVUlUWSkpfCg/OiNFWFQtWC0oVkVSU0lPTik6KFxcZCspKXwoPzojRVhULVgtKE1BUCk6KC4rKSl8KD86KCMpKFteOl0qKTooLiopKXwoPzooIykoLiopKSg/Oi4qKVxccj9cXG4/LztcblxuY29uc3QgTVA0X1JFR0VYX1NVRkZJWCA9IC9cXC4obXA0fG00c3xtNHZ8bTRhKSQvaTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTTNVOFBhcnNlciB7XG4gIHN0YXRpYyBmaW5kR3JvdXAgKGdyb3VwcywgbWVkaWFHcm91cElkKSB7XG4gICAgaWYgKCFncm91cHMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBtYXRjaGluZ0dyb3VwID0gbnVsbDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgIGlmIChncm91cC5pZCA9PT0gbWVkaWFHcm91cElkKSB7XG4gICAgICAgIG1hdGNoaW5nR3JvdXAgPSBncm91cDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hpbmdHcm91cDtcbiAgfVxuXG4gIHN0YXRpYyBjb252ZXJ0QVZDMVRvQVZDT1RJIChjb2RlYykge1xuICAgIGxldCByZXN1bHQsIGF2Y2RhdGEgPSBjb2RlYy5zcGxpdCgnLicpO1xuICAgIGlmIChhdmNkYXRhLmxlbmd0aCA+IDIpIHtcbiAgICAgIHJlc3VsdCA9IGF2Y2RhdGEuc2hpZnQoKSArICcuJztcbiAgICAgIHJlc3VsdCArPSBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgIHJlc3VsdCArPSAoJzAwMCcgKyBwYXJzZUludChhdmNkYXRhLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY29kZWM7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBzdGF0aWMgcmVzb2x2ZSAodXJsLCBiYXNlVXJsKSB7XG4gICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVVSTChiYXNlVXJsLCB1cmwsIHsgYWx3YXlzTm9ybWFsaXplOiB0cnVlIH0pO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlTWFzdGVyUGxheWxpc3QgKHN0cmluZywgYmFzZXVybCkge1xuICAgIGxldCBsZXZlbHMgPSBbXSwgcmVzdWx0O1xuICAgIE1BU1RFUl9QTEFZTElTVF9SRUdFWC5sYXN0SW5kZXggPSAwO1xuXG4gICAgZnVuY3Rpb24gc2V0Q29kZWNzIChjb2RlY3MsIGxldmVsKSB7XG4gICAgICBbJ3ZpZGVvJywgJ2F1ZGlvJ10uZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IGNvZGVjcy5maWx0ZXIoKGNvZGVjKSA9PiBpc0NvZGVjVHlwZShjb2RlYywgdHlwZSkpO1xuICAgICAgICBpZiAoZmlsdGVyZWQubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgcHJlZmVycmVkID0gZmlsdGVyZWQuZmlsdGVyKChjb2RlYykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVjLmxhc3RJbmRleE9mKCdhdmMxJywgMCkgPT09IDAgfHwgY29kZWMubGFzdEluZGV4T2YoJ21wNGEnLCAwKSA9PT0gMDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZXZlbFtgJHt0eXBlfUNvZGVjYF0gPSBwcmVmZXJyZWQubGVuZ3RoID4gMCA/IHByZWZlcnJlZFswXSA6IGZpbHRlcmVkWzBdO1xuXG4gICAgICAgICAgLy8gcmVtb3ZlIGZyb20gbGlzdFxuICAgICAgICAgIGNvZGVjcyA9IGNvZGVjcy5maWx0ZXIoKGNvZGVjKSA9PiBmaWx0ZXJlZC5pbmRleE9mKGNvZGVjKSA9PT0gLTEpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbGV2ZWwudW5rbm93bkNvZGVjcyA9IGNvZGVjcztcbiAgICB9XG5cbiAgICB3aGlsZSAoKHJlc3VsdCA9IE1BU1RFUl9QTEFZTElTVF9SRUdFWC5leGVjKHN0cmluZykpICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGxldmVsID0ge307XG5cbiAgICAgIGNvbnN0IGF0dHJzID0gbGV2ZWwuYXR0cnMgPSBuZXcgQXR0ckxpc3QocmVzdWx0WzFdKTtcbiAgICAgIGxldmVsLnVybCA9IE0zVThQYXJzZXIucmVzb2x2ZShyZXN1bHRbMl0sIGJhc2V1cmwpO1xuXG4gICAgICBjb25zdCByZXNvbHV0aW9uID0gYXR0cnMuZGVjaW1hbFJlc29sdXRpb24oJ1JFU09MVVRJT04nKTtcbiAgICAgIGlmIChyZXNvbHV0aW9uKSB7XG4gICAgICAgIGxldmVsLndpZHRoID0gcmVzb2x1dGlvbi53aWR0aDtcbiAgICAgICAgbGV2ZWwuaGVpZ2h0ID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBsZXZlbC5iaXRyYXRlID0gYXR0cnMuZGVjaW1hbEludGVnZXIoJ0FWRVJBR0UtQkFORFdJRFRIJykgfHwgYXR0cnMuZGVjaW1hbEludGVnZXIoJ0JBTkRXSURUSCcpO1xuICAgICAgbGV2ZWwubmFtZSA9IGF0dHJzLk5BTUU7XG5cbiAgICAgIHNldENvZGVjcyhbXS5jb25jYXQoKGF0dHJzLkNPREVDUyB8fCAnJykuc3BsaXQoL1sgLF0rLykpLCBsZXZlbCk7XG5cbiAgICAgIGlmIChsZXZlbC52aWRlb0NvZGVjICYmIGxldmVsLnZpZGVvQ29kZWMuaW5kZXhPZignYXZjMScpICE9PSAtMSkge1xuICAgICAgICBsZXZlbC52aWRlb0NvZGVjID0gTTNVOFBhcnNlci5jb252ZXJ0QVZDMVRvQVZDT1RJKGxldmVsLnZpZGVvQ29kZWMpO1xuICAgICAgfVxuXG4gICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG4gICAgfVxuICAgIHJldHVybiBsZXZlbHM7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhIChzdHJpbmcsIGJhc2V1cmwsIHR5cGUsIGF1ZGlvR3JvdXBzID0gW10pIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBtZWRpYXMgPSBbXTtcbiAgICBsZXQgaWQgPSAwO1xuICAgIE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG1lZGlhID0ge307XG4gICAgICBjb25zdCBhdHRycyA9IG5ldyBBdHRyTGlzdChyZXN1bHRbMV0pO1xuICAgICAgaWYgKGF0dHJzLlRZUEUgPT09IHR5cGUpIHtcbiAgICAgICAgbWVkaWEuZ3JvdXBJZCA9IGF0dHJzWydHUk9VUC1JRCddO1xuICAgICAgICBtZWRpYS5uYW1lID0gYXR0cnMuTkFNRTtcbiAgICAgICAgbWVkaWEudHlwZSA9IHR5cGU7XG4gICAgICAgIG1lZGlhLmRlZmF1bHQgPSAoYXR0cnMuREVGQVVMVCA9PT0gJ1lFUycpO1xuICAgICAgICBtZWRpYS5hdXRvc2VsZWN0ID0gKGF0dHJzLkFVVE9TRUxFQ1QgPT09ICdZRVMnKTtcbiAgICAgICAgbWVkaWEuZm9yY2VkID0gKGF0dHJzLkZPUkNFRCA9PT0gJ1lFUycpO1xuICAgICAgICBpZiAoYXR0cnMuVVJJKSB7XG4gICAgICAgICAgbWVkaWEudXJsID0gTTNVOFBhcnNlci5yZXNvbHZlKGF0dHJzLlVSSSwgYmFzZXVybCk7XG4gICAgICAgIH1cblxuICAgICAgICBtZWRpYS5sYW5nID0gYXR0cnMuTEFOR1VBR0U7XG4gICAgICAgIGlmICghbWVkaWEubmFtZSkge1xuICAgICAgICAgIG1lZGlhLm5hbWUgPSBtZWRpYS5sYW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF1ZGlvR3JvdXBzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGdyb3VwQ29kZWMgPSBNM1U4UGFyc2VyLmZpbmRHcm91cChhdWRpb0dyb3VwcywgbWVkaWEuZ3JvdXBJZCk7XG4gICAgICAgICAgbWVkaWEuYXVkaW9Db2RlYyA9IGdyb3VwQ29kZWMgPyBncm91cENvZGVjLmNvZGVjIDogYXVkaW9Hcm91cHNbMF0uY29kZWM7XG4gICAgICAgIH1cbiAgICAgICAgbWVkaWEuaWQgPSBpZCsrO1xuICAgICAgICBtZWRpYXMucHVzaChtZWRpYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZWRpYXM7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VMZXZlbFBsYXlsaXN0IChzdHJpbmcsIGJhc2V1cmwsIGlkLCB0eXBlLCBsZXZlbFVybElkKSB7XG4gICAgbGV0IGN1cnJlbnRTTiA9IDA7XG4gICAgbGV0IHRvdGFsZHVyYXRpb24gPSAwO1xuICAgIGxldCBsZXZlbCA9IG5ldyBMZXZlbChiYXNldXJsKTtcbiAgICBsZXQgbGV2ZWxrZXkgPSBuZXcgTGV2ZWxLZXkoKTtcbiAgICBsZXQgY2MgPSAwO1xuICAgIGxldCBwcmV2RnJhZyA9IG51bGw7XG4gICAgbGV0IGZyYWcgPSBuZXcgRnJhZ21lbnQoKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBpO1xuXG4gICAgbGV0IGZpcnN0UGR0SW5kZXggPSBudWxsO1xuXG4gICAgTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVC5sYXN0SW5kZXggPSAwO1xuXG4gICAgd2hpbGUgKChyZXN1bHQgPSBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gcmVzdWx0WzFdO1xuICAgICAgaWYgKGR1cmF0aW9uKSB7IC8vIElORlxuICAgICAgICBmcmFnLmR1cmF0aW9uID0gcGFyc2VGbG9hdChkdXJhdGlvbik7XG4gICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgY29uc3QgdGl0bGUgPSAoJyAnICsgcmVzdWx0WzJdKS5zbGljZSgxKTtcbiAgICAgICAgZnJhZy50aXRsZSA9IHRpdGxlIHx8IG51bGw7XG4gICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHRpdGxlID8gWyAnSU5GJywgZHVyYXRpb24sIHRpdGxlIF0gOiBbICdJTkYnLCBkdXJhdGlvbiBdKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzNdKSB7IC8vIHVybFxuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGZyYWcuZHVyYXRpb24pKSB7XG4gICAgICAgICAgY29uc3Qgc24gPSBjdXJyZW50U04rKztcbiAgICAgICAgICBmcmFnLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIGZyYWcuc3RhcnQgPSB0b3RhbGR1cmF0aW9uO1xuICAgICAgICAgIGZyYWcubGV2ZWxrZXkgPSBsZXZlbGtleTtcbiAgICAgICAgICBmcmFnLnNuID0gc247XG4gICAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuICAgICAgICAgIGZyYWcuY2MgPSBjYztcbiAgICAgICAgICBmcmFnLnVybElkID0gbGV2ZWxVcmxJZDtcbiAgICAgICAgICBmcmFnLmJhc2V1cmwgPSBiYXNldXJsO1xuICAgICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgICBmcmFnLnJlbHVybCA9ICgnICcgKyByZXN1bHRbM10pLnNsaWNlKDEpO1xuICAgICAgICAgIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZyk7XG5cbiAgICAgICAgICBsZXZlbC5mcmFnbWVudHMucHVzaChmcmFnKTtcbiAgICAgICAgICBwcmV2RnJhZyA9IGZyYWc7XG4gICAgICAgICAgdG90YWxkdXJhdGlvbiArPSBmcmFnLmR1cmF0aW9uO1xuXG4gICAgICAgICAgZnJhZyA9IG5ldyBGcmFnbWVudCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFs0XSkgeyAvLyBYLUJZVEVSQU5HRVxuICAgICAgICBmcmFnLnJhd0J5dGVSYW5nZSA9ICgnICcgKyByZXN1bHRbNF0pLnNsaWNlKDEpO1xuICAgICAgICBpZiAocHJldkZyYWcpIHtcbiAgICAgICAgICBjb25zdCBsYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0ID0gcHJldkZyYWcuYnl0ZVJhbmdlRW5kT2Zmc2V0O1xuICAgICAgICAgIGlmIChsYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0KSB7XG4gICAgICAgICAgICBmcmFnLmxhc3RCeXRlUmFuZ2VFbmRPZmZzZXQgPSBsYXN0Qnl0ZVJhbmdlRW5kT2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbNV0pIHsgLy8gUFJPR1JBTS1EQVRFLVRJTUVcbiAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9ICgnICcgKyByZXN1bHRbNV0pLnNsaWNlKDEpO1xuICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ1BST0dSQU0tREFURS1USU1FJywgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWVdKTtcbiAgICAgICAgaWYgKGZpcnN0UGR0SW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICBmaXJzdFBkdEluZGV4ID0gbGV2ZWwuZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdLm1hdGNoKExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdFtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIGNvbnN0IHZhbHVlMSA9ICgnICcgKyByZXN1bHRbaSArIDFdKS5zbGljZSgxKTtcbiAgICAgICAgY29uc3QgdmFsdWUyID0gKCcgJyArIHJlc3VsdFtpICsgMl0pLnNsaWNlKDEpO1xuXG4gICAgICAgIHN3aXRjaCAocmVzdWx0W2ldKSB7XG4gICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHZhbHVlMiA/IFsgdmFsdWUxLCB2YWx1ZTIgXSA6IFsgdmFsdWUxIF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdQTEFZTElTVC1UWVBFJzpcbiAgICAgICAgICBsZXZlbC50eXBlID0gdmFsdWUxLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01FRElBLVNFUVVFTkNFJzpcbiAgICAgICAgICBjdXJyZW50U04gPSBsZXZlbC5zdGFydFNOID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVEFSR0VURFVSQVRJT04nOlxuICAgICAgICAgIGxldmVsLnRhcmdldGR1cmF0aW9uID0gcGFyc2VGbG9hdCh2YWx1ZTEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdWRVJTSU9OJzpcbiAgICAgICAgICBsZXZlbC52ZXJzaW9uID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRVhUTTNVJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRU5ETElTVCc6XG4gICAgICAgICAgbGV2ZWwubGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdESVMnOlxuICAgICAgICAgIGNjKys7XG4gICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydESVMnXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0RJU0NPTlRJTlVJVFktU0VRJzpcbiAgICAgICAgICBjYyA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0tFWSc6XG4gICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXBhbnRvcy1odHRwLWxpdmUtc3RyZWFtaW5nLTA4I3NlY3Rpb24tMy40LjRcbiAgICAgICAgICB2YXIgZGVjcnlwdHBhcmFtcyA9IHZhbHVlMTtcbiAgICAgICAgICB2YXIga2V5QXR0cnMgPSBuZXcgQXR0ckxpc3QoZGVjcnlwdHBhcmFtcyk7XG4gICAgICAgICAgdmFyIGRlY3J5cHRtZXRob2QgPSBrZXlBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdNRVRIT0QnKSxcbiAgICAgICAgICAgIGRlY3J5cHR1cmkgPSBrZXlBdHRycy5VUkksXG4gICAgICAgICAgICBkZWNyeXB0aXYgPSBrZXlBdHRycy5oZXhhZGVjaW1hbEludGVnZXIoJ0lWJyk7XG4gICAgICAgICAgaWYgKGRlY3J5cHRtZXRob2QpIHtcbiAgICAgICAgICAgIGxldmVsa2V5ID0gbmV3IExldmVsS2V5KCk7XG4gICAgICAgICAgICBpZiAoKGRlY3J5cHR1cmkpICYmIChbJ0FFUy0xMjgnLCAnU0FNUExFLUFFUycsICdTQU1QTEUtQUVTLUNFTkMnXS5pbmRleE9mKGRlY3J5cHRtZXRob2QpID49IDApKSB7XG4gICAgICAgICAgICAgIGxldmVsa2V5Lm1ldGhvZCA9IGRlY3J5cHRtZXRob2Q7XG4gICAgICAgICAgICAgIC8vIFVSSSB0byBnZXQgdGhlIGtleVxuICAgICAgICAgICAgICBsZXZlbGtleS5iYXNldXJpID0gYmFzZXVybDtcbiAgICAgICAgICAgICAgbGV2ZWxrZXkucmVsdXJpID0gZGVjcnlwdHVyaTtcbiAgICAgICAgICAgICAgbGV2ZWxrZXkua2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6YXRpb24gVmVjdG9yIChJVilcbiAgICAgICAgICAgICAgbGV2ZWxrZXkuaXYgPSBkZWNyeXB0aXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTVEFSVCc6XG4gICAgICAgICAgbGV0IHN0YXJ0UGFyYW1zID0gdmFsdWUxO1xuICAgICAgICAgIGxldCBzdGFydEF0dHJzID0gbmV3IEF0dHJMaXN0KHN0YXJ0UGFyYW1zKTtcbiAgICAgICAgICBsZXQgc3RhcnRUaW1lT2Zmc2V0ID0gc3RhcnRBdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnVElNRS1PRkZTRVQnKTtcbiAgICAgICAgICAvLyBUSU1FLU9GRlNFVCBjYW4gYmUgMFxuICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICAgICAgbGV2ZWwuc3RhcnRUaW1lT2Zmc2V0ID0gc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNQVAnOlxuICAgICAgICAgIGxldCBtYXBBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgIGZyYWcucmVsdXJsID0gbWFwQXR0cnMuVVJJO1xuICAgICAgICAgIGZyYWcucmF3Qnl0ZVJhbmdlID0gbWFwQXR0cnMuQllURVJBTkdFO1xuICAgICAgICAgIGZyYWcuYmFzZXVybCA9IGJhc2V1cmw7XG4gICAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuICAgICAgICAgIGZyYWcudHlwZSA9IHR5cGU7XG4gICAgICAgICAgZnJhZy5zbiA9ICdpbml0U2VnbWVudCc7XG4gICAgICAgICAgbGV2ZWwuaW5pdFNlZ21lbnQgPSBmcmFnO1xuICAgICAgICAgIGZyYWcgPSBuZXcgRnJhZ21lbnQoKTtcbiAgICAgICAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9IGxldmVsLmluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsb2dnZXIud2FybihgbGluZSBwYXJzZWQgYnV0IG5vdCBoYW5kbGVkOiAke3Jlc3VsdH1gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmcmFnID0gcHJldkZyYWc7XG4gICAgLy8gbG9nZ2VyLmxvZygnZm91bmQgJyArIGxldmVsLmZyYWdtZW50cy5sZW5ndGggKyAnIGZyYWdtZW50cycpO1xuICAgIGlmIChmcmFnICYmICFmcmFnLnJlbHVybCkge1xuICAgICAgbGV2ZWwuZnJhZ21lbnRzLnBvcCgpO1xuICAgICAgdG90YWxkdXJhdGlvbiAtPSBmcmFnLmR1cmF0aW9uO1xuICAgIH1cbiAgICBsZXZlbC50b3RhbGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbjtcbiAgICBsZXZlbC5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gPSB0b3RhbGR1cmF0aW9uIC8gbGV2ZWwuZnJhZ21lbnRzLmxlbmd0aDtcbiAgICBsZXZlbC5lbmRTTiA9IGN1cnJlbnRTTiAtIDE7XG4gICAgbGV2ZWwuc3RhcnRDQyA9IGxldmVsLmZyYWdtZW50c1swXSA/IGxldmVsLmZyYWdtZW50c1swXS5jYyA6IDA7XG4gICAgbGV2ZWwuZW5kQ0MgPSBjYztcblxuICAgIGlmICghbGV2ZWwuaW5pdFNlZ21lbnQgJiYgbGV2ZWwuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gdGhpcyBpcyBhIGJpdCBsdXJreSBidXQgSExTIHJlYWxseSBoYXMgbm8gb3RoZXIgd2F5IHRvIHRlbGwgdXNcbiAgICAgIC8vIGlmIHRoZSBmcmFnbWVudHMgYXJlIFRTIG9yIE1QNCwgZXhjZXB0IGlmIHdlIGRvd25sb2FkIHRoZW0gOi9cbiAgICAgIC8vIGJ1dCB0aGlzIGlzIHRvIGJlIGFibGUgdG8gaGFuZGxlIFNJRFguXG4gICAgICBpZiAobGV2ZWwuZnJhZ21lbnRzLmV2ZXJ5KChmcmFnKSA9PiBNUDRfUkVHRVhfU1VGRklYLnRlc3QoZnJhZy5yZWx1cmwpKSkge1xuICAgICAgICBsb2dnZXIud2FybignTVA0IGZyYWdtZW50cyBmb3VuZCBidXQgbm8gaW5pdCBzZWdtZW50IChwcm9iYWJseSBubyBNQVAsIGluY29tcGxldGUgTTNVOCksIHRyeWluZyB0byBmZXRjaCBTSURYJyk7XG5cbiAgICAgICAgZnJhZyA9IG5ldyBGcmFnbWVudCgpO1xuICAgICAgICBmcmFnLnJlbHVybCA9IGxldmVsLmZyYWdtZW50c1swXS5yZWx1cmw7XG4gICAgICAgIGZyYWcuYmFzZXVybCA9IGJhc2V1cmw7XG4gICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgZnJhZy50eXBlID0gdHlwZTtcbiAgICAgICAgZnJhZy5zbiA9ICdpbml0U2VnbWVudCc7XG5cbiAgICAgICAgbGV2ZWwuaW5pdFNlZ21lbnQgPSBmcmFnO1xuICAgICAgICBsZXZlbC5uZWVkU2lkeFJhbmdlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmFja2ZpbGwgYW55IG1pc3NpbmcgUERUIHZhbHVlc1xuICAgICAgIFwiSWYgdGhlIGZpcnN0IEVYVC1YLVBST0dSQU0tREFURS1USU1FIHRhZyBpbiBhIFBsYXlsaXN0IGFwcGVhcnMgYWZ0ZXJcbiAgICAgICBvbmUgb3IgbW9yZSBNZWRpYSBTZWdtZW50IFVSSXMsIHRoZSBjbGllbnQgU0hPVUxEIGV4dHJhcG9sYXRlXG4gICAgICAgYmFja3dhcmQgZnJvbSB0aGF0IHRhZyAodXNpbmcgRVhUSU5GIGR1cmF0aW9ucyBhbmQvb3IgbWVkaWFcbiAgICAgICB0aW1lc3RhbXBzKSB0byBhc3NvY2lhdGUgZGF0ZXMgd2l0aCB0aG9zZSBzZWdtZW50cy5cIlxuICAgICAqIFdlIGhhdmUgYWxyZWFkeSBleHRyYXBvbGF0ZWQgZm9yd2FyZCwgYnV0IGFsbCBmcmFnbWVudHMgdXAgdG8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIFBEVCBkbyBub3QgaGF2ZSB0aGVpciBQRFRzXG4gICAgICogY29tcHV0ZWQuXG4gICAgICovXG4gICAgaWYgKGZpcnN0UGR0SW5kZXgpIHtcbiAgICAgIGJhY2tmaWxsUHJvZ3JhbURhdGVUaW1lcyhsZXZlbC5mcmFnbWVudHMsIGZpcnN0UGR0SW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBsZXZlbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMgKGZyYWdtZW50cywgc3RhcnRJbmRleCkge1xuICBsZXQgZnJhZ1ByZXYgPSBmcmFnbWVudHNbc3RhcnRJbmRleF07XG4gIGZvciAobGV0IGkgPSBzdGFydEluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBmcmFnID0gZnJhZ21lbnRzW2ldO1xuICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gZnJhZ1ByZXYucHJvZ3JhbURhdGVUaW1lIC0gKGZyYWcuZHVyYXRpb24gKiAxMDAwKTtcbiAgICBmcmFnUHJldiA9IGZyYWc7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduUHJvZ3JhbURhdGVUaW1lIChmcmFnLCBwcmV2RnJhZykge1xuICBpZiAoZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IERhdGUucGFyc2UoZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpO1xuICB9IGVsc2UgaWYgKHByZXZGcmFnICYmIHByZXZGcmFnLnByb2dyYW1EYXRlVGltZSkge1xuICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gcHJldkZyYWcuZW5kUHJvZ3JhbURhdGVUaW1lO1xuICB9XG5cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJhZy5wcm9ncmFtRGF0ZVRpbWUpKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgfVxufVxuIiwiLyoqXG4gKiBQbGF5bGlzdExvYWRlciAtIGRlbGVnYXRlIGZvciBtZWRpYSBtYW5pZmVzdC9wbGF5bGlzdCBsb2FkaW5nIHRhc2tzLiBUYWtlcyBjYXJlIG9mIHBhcnNpbmcgbWVkaWEgdG8gaW50ZXJuYWwgZGF0YS1tb2RlbHMuXG4gKlxuICogT25jZSBsb2FkZWQsIGRpc3BhdGNoZXMgZXZlbnRzIHdpdGggcGFyc2VkIGRhdGEtbW9kZWxzIG9mIG1hbmlmZXN0L2xldmVscy9hdWRpby9zdWJ0aXRsZSB0cmFja3MuXG4gKlxuICogVXNlcyBsb2FkZXIocykgc2V0IGluIGNvbmZpZyB0byBkbyBhY3R1YWwgaW50ZXJuYWwgbG9hZGluZyBvZiByZXNvdXJjZSB0YXNrcy5cbiAqXG4gKiBAbW9kdWxlXG4gKlxuICovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9ldmVudC1oYW5kbGVyJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmltcG9ydCBNUDREZW11eGVyIGZyb20gJy4uL2RlbXV4L21wNGRlbXV4ZXInO1xuaW1wb3J0IE0zVThQYXJzZXIgZnJvbSAnLi9tM3U4LXBhcnNlcic7XG5cbmNvbnN0IHsgcGVyZm9ybWFuY2UgfSA9IHdpbmRvdztcblxuLyoqXG4gKiBgdHlwZWAgcHJvcGVydHkgdmFsdWVzIGZvciB0aGlzIGxvYWRlcnMnIGNvbnRleHQgb2JqZWN0XG4gKiBAZW51bVxuICpcbiAqL1xuY29uc3QgQ29udGV4dFR5cGUgPSB7XG4gIE1BTklGRVNUOiAnbWFuaWZlc3QnLFxuICBMRVZFTDogJ2xldmVsJyxcbiAgQVVESU9fVFJBQ0s6ICdhdWRpb1RyYWNrJyxcbiAgU1VCVElUTEVfVFJBQ0s6ICdzdWJ0aXRsZVRyYWNrJ1xufTtcblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5jb25zdCBMZXZlbFR5cGUgPSB7XG4gIE1BSU46ICdtYWluJyxcbiAgQVVESU86ICdhdWRpbycsXG4gIFNVQlRJVExFOiAnc3VidGl0bGUnXG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBQbGF5bGlzdExvYWRlciBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0c1xuICAgKiBAcGFyYW0ge0hsc30gaGxzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoaGxzKSB7XG4gICAgc3VwZXIoaGxzLFxuICAgICAgRXZlbnQuTUFOSUZFU1RfTE9BRElORyxcbiAgICAgIEV2ZW50LkxFVkVMX0xPQURJTkcsXG4gICAgICBFdmVudC5BVURJT19UUkFDS19MT0FESU5HLFxuICAgICAgRXZlbnQuU1VCVElUTEVfVFJBQ0tfTE9BRElORyk7XG5cbiAgICB0aGlzLmxvYWRlcnMgPSB7fTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgQ29udGV4dFR5cGUgKCkge1xuICAgIHJldHVybiBDb250ZXh0VHlwZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTGV2ZWxUeXBlICgpIHtcbiAgICByZXR1cm4gTGV2ZWxUeXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGV4dFR5cGV9IHR5cGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgY2FuSGF2ZVF1YWxpdHlMZXZlbHMgKHR5cGUpIHtcbiAgICByZXR1cm4gKHR5cGUgIT09IENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmXG4gICAgICB0eXBlICE9PSBDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyk7XG4gIH1cblxuICAvKipcbiAgICogTWFwIGNvbnRleHQudHlwZSB0byBMZXZlbFR5cGVcbiAgICogQHBhcmFtIHt7dHlwZTogQ29udGV4dFR5cGV9fSBjb250ZXh0XG4gICAqIEByZXR1cm5zIHtMZXZlbFR5cGV9XG4gICAqL1xuICBzdGF0aWMgbWFwQ29udGV4dFRvTGV2ZWxUeXBlIChjb250ZXh0KSB7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBjb250ZXh0O1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgIHJldHVybiBMZXZlbFR5cGUuQVVESU87XG4gICAgY2FzZSBDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgIHJldHVybiBMZXZlbFR5cGUuU1VCVElUTEU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBMZXZlbFR5cGUuTUFJTjtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0UmVzcG9uc2VVcmwgKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgbGV0IHVybCA9IHJlc3BvbnNlLnVybDtcbiAgICAvLyByZXNwb25zZVVSTCBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMgKGl0IGlzIHVzZWQgdG8gZGV0ZWN0IFVSTCByZWRpcmVjdGlvbilcbiAgICAvLyBkYXRhLXVyaSBtb2RlIGFsc28gbm90IHN1cHBvcnRlZCAoYnV0IG5vIG5lZWQgdG8gZGV0ZWN0IHJlZGlyZWN0aW9uKVxuICAgIGlmICh1cmwgPT09IHVuZGVmaW5lZCB8fCB1cmwuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgICAgLy8gZmFsbGJhY2sgdG8gaW5pdGlhbCBVUkxcbiAgICAgIHVybCA9IGNvbnRleHQudXJsO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZGVmYXVsdHMgb3IgY29uZmlndXJlZCBsb2FkZXItdHlwZSBvdmVybG9hZHMgKHBMb2FkZXIgYW5kIGxvYWRlciBjb25maWcgcGFyYW1zKVxuICAgKiBEZWZhdWx0IGxvYWRlciBpcyBYSFJMb2FkZXIgKHNlZSB1dGlscylcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybnMge1hIUkxvYWRlcn0gb3Igb3RoZXIgY29tcGF0aWJsZSBjb25maWd1cmVkIG92ZXJsb2FkXG4gICAqL1xuICBjcmVhdGVJbnRlcm5hbExvYWRlciAoY29udGV4dCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBjb25zdCBQTG9hZGVyID0gY29uZmlnLnBMb2FkZXI7XG4gICAgY29uc3QgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICBjb25zdCBJbnRlcm5hbExvYWRlciA9IFBMb2FkZXIgfHwgTG9hZGVyO1xuXG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEludGVybmFsTG9hZGVyKGNvbmZpZyk7XG5cbiAgICBjb250ZXh0LmxvYWRlciA9IGxvYWRlcjtcbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IGxvYWRlcjtcblxuICAgIHJldHVybiBsb2FkZXI7XG4gIH1cblxuICBnZXRJbnRlcm5hbExvYWRlciAoY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXTtcbiAgfVxuXG4gIHJlc2V0SW50ZXJuYWxMb2FkZXIgKGNvbnRleHRUeXBlKSB7XG4gICAgaWYgKHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGBkZXN0cm95YCBvbiBhbGwgaW50ZXJuYWwgbG9hZGVyIGluc3RhbmNlcyBtYXBwZWQgKG9uZSBwZXIgY29udGV4dCB0eXBlKVxuICAgKi9cbiAgZGVzdHJveUludGVybmFsTG9hZGVycyAoKSB7XG4gICAgZm9yIChsZXQgY29udGV4dFR5cGUgaW4gdGhpcy5sb2FkZXJzKSB7XG4gICAgICBsZXQgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHRUeXBlKTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmRlc3Ryb3lJbnRlcm5hbExvYWRlcnMoKTtcblxuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIG9uTWFuaWZlc3RMb2FkaW5nIChkYXRhKSB7XG4gICAgdGhpcy5sb2FkKGRhdGEudXJsLCB7IHR5cGU6IENvbnRleHRUeXBlLk1BTklGRVNULCBsZXZlbDogMCwgaWQ6IG51bGwgfSk7XG4gIH1cblxuICBvbkxldmVsTG9hZGluZyAoZGF0YSkge1xuICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlOiBDb250ZXh0VHlwZS5MRVZFTCwgbGV2ZWw6IGRhdGEubGV2ZWwsIGlkOiBkYXRhLmlkIH0pO1xuICB9XG5cbiAgb25BdWRpb1RyYWNrTG9hZGluZyAoZGF0YSkge1xuICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlOiBDb250ZXh0VHlwZS5BVURJT19UUkFDSywgbGV2ZWw6IG51bGwsIGlkOiBkYXRhLmlkIH0pO1xuICB9XG5cbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGluZyAoZGF0YSkge1xuICAgIHRoaXMubG9hZChkYXRhLnVybCwgeyB0eXBlOiBDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSywgbGV2ZWw6IG51bGwsIGlkOiBkYXRhLmlkIH0pO1xuICB9XG5cbiAgbG9hZCAodXJsLCBjb250ZXh0KSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuXG4gICAgbG9nZ2VyLmRlYnVnKGBMb2FkaW5nIHBsYXlsaXN0IG9mIHR5cGUgJHtjb250ZXh0LnR5cGV9LCBsZXZlbDogJHtjb250ZXh0LmxldmVsfSwgaWQ6ICR7Y29udGV4dC5pZH1gKTtcblxuICAgIC8vIENoZWNrIGlmIGEgbG9hZGVyIGZvciB0aGlzIGNvbnRleHQgYWxyZWFkeSBleGlzdHNcbiAgICBsZXQgbG9hZGVyID0gdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBjb25zdCBsb2FkZXJDb250ZXh0ID0gbG9hZGVyLmNvbnRleHQ7XG4gICAgICBpZiAobG9hZGVyQ29udGV4dCAmJiBsb2FkZXJDb250ZXh0LnVybCA9PT0gdXJsKSB7IC8vIHNhbWUgVVJMIGNhbid0IG92ZXJsYXBcbiAgICAgICAgbG9nZ2VyLnRyYWNlKCdwbGF5bGlzdCByZXF1ZXN0IG9uZ29pbmcnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYGFib3J0aW5nIHByZXZpb3VzIGxvYWRlciBmb3IgdHlwZTogJHtjb250ZXh0LnR5cGV9YCk7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBtYXhSZXRyeSxcbiAgICAgIHRpbWVvdXQsXG4gICAgICByZXRyeURlbGF5LFxuICAgICAgbWF4UmV0cnlEZWxheTtcblxuICAgIC8vIGFwcGx5IGRpZmZlcmVudCBjb25maWdzIGZvciByZXRyaWVzIGRlcGVuZGluZyBvblxuICAgIC8vIGNvbnRleHQgKG1hbmlmZXN0LCBsZXZlbCwgYXVkaW8vc3VicyBwbGF5bGlzdClcbiAgICBzd2l0Y2ggKGNvbnRleHQudHlwZSkge1xuICAgIGNhc2UgQ29udGV4dFR5cGUuTUFOSUZFU1Q6XG4gICAgICBtYXhSZXRyeSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdNYXhSZXRyeTtcbiAgICAgIHRpbWVvdXQgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nVGltZU91dDtcbiAgICAgIHJldHJ5RGVsYXkgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTtcbiAgICAgIG1heFJldHJ5RGVsYXkgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDb250ZXh0VHlwZS5MRVZFTDpcbiAgICAgIC8vIERpc2FibGUgaW50ZXJuYWwgbG9hZGVyIHJldHJ5IGxvZ2ljLCBzaW5jZSB3ZSBhcmUgbWFuYWdpbmcgcmV0cmllcyBpbiBMZXZlbCBDb250cm9sbGVyXG4gICAgICBtYXhSZXRyeSA9IDA7XG4gICAgICB0aW1lb3V0ID0gY29uZmlnLmxldmVsTG9hZGluZ1RpbWVPdXQ7XG4gICAgICAvLyBUT0RPIEludHJvZHVjZSByZXRyeSBzZXR0aW5ncyBmb3IgYXVkaW8tdHJhY2sgYW5kIHN1YnRpdGxlLXRyYWNrLCBpdCBzaG91bGQgbm90IHVzZSBsZXZlbCByZXRyeSBjb25maWdcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBtYXhSZXRyeSA9IGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeTtcbiAgICAgIHRpbWVvdXQgPSBjb25maWcubGV2ZWxMb2FkaW5nVGltZU91dDtcbiAgICAgIHJldHJ5RGVsYXkgPSBjb25maWcubGV2ZWxMb2FkaW5nUmV0cnlEZWxheTtcbiAgICAgIG1heFJldHJ5RGVsYXkgPSBjb25maWcubGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbG9hZGVyID0gdGhpcy5jcmVhdGVJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcblxuICAgIGNvbnRleHQudXJsID0gdXJsO1xuICAgIGNvbnRleHQucmVzcG9uc2VUeXBlID0gY29udGV4dC5yZXNwb25zZVR5cGUgfHwgJyc7IC8vIEZJWE1FOiAoc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnkgdG8gZG8gdGhpcylcblxuICAgIGNvbnN0IGxvYWRlckNvbmZpZyA9IHtcbiAgICAgIHRpbWVvdXQsXG4gICAgICBtYXhSZXRyeSxcbiAgICAgIHJldHJ5RGVsYXksXG4gICAgICBtYXhSZXRyeURlbGF5XG4gICAgfTtcblxuICAgIGNvbnN0IGxvYWRlckNhbGxiYWNrcyA9IHtcbiAgICAgIG9uU3VjY2VzczogdGhpcy5sb2Fkc3VjY2Vzcy5iaW5kKHRoaXMpLFxuICAgICAgb25FcnJvcjogdGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSxcbiAgICAgIG9uVGltZW91dDogdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpXG4gICAgfTtcblxuICAgIGxvZ2dlci5kZWJ1ZyhgQ2FsbGluZyBpbnRlcm5hbCBsb2FkZXIgZGVsZWdhdGUgZm9yIFVSTDogJHt1cmx9YCk7XG5cbiAgICBsb2FkZXIubG9hZChjb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGxvYWRzdWNjZXNzIChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzID0gbnVsbCkge1xuICAgIGlmIChjb250ZXh0LmlzU2lkeFJlcXVlc3QpIHtcbiAgICAgIHRoaXMuX2hhbmRsZVNpZHhSZXF1ZXN0KHJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICAgIHRoaXMuX2hhbmRsZVBsYXlsaXN0TG9hZGVkKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0LnR5cGUpO1xuXG4gICAgY29uc3Qgc3RyaW5nID0gcmVzcG9uc2UuZGF0YTtcblxuICAgIHN0YXRzLnRsb2FkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgLy8gc3RhdHMubXRpbWUgPSBuZXcgRGF0ZSh0YXJnZXQuZ2V0UmVzcG9uc2VIZWFkZXIoJ0xhc3QtTW9kaWZpZWQnKSk7XG5cbiAgICAvLyBWYWxpZGF0ZSBpZiBpdCBpcyBhbiBNM1U4IGF0IGFsbFxuICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVE0zVScpICE9PSAwKSB7XG4gICAgICB0aGlzLl9oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihyZXNwb25zZSwgY29udGV4dCwgJ25vIEVYVE0zVSBkZWxpbWl0ZXInLCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgY2h1bmstbGlzdCBvciBtYXN0ZXIuIGhhbmRsZSBlbXB0eSBjaHVuayBsaXN0IGNhc2UgKGZpcnN0IEVYVElORiBub3Qgc2lnbmFsZWQsIGJ1dCBUQVJHRVREVVJBVElPTiBwcmVzZW50KVxuICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVElORjonKSA+IDAgfHwgc3RyaW5nLmluZGV4T2YoJyNFWFQtWC1UQVJHRVREVVJBVElPTjonKSA+IDApIHtcbiAgICAgIHRoaXMuX2hhbmRsZVRyYWNrT3JMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oYW5kbGVNYXN0ZXJQbGF5bGlzdChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICB9XG4gIH1cblxuICBsb2FkZXJyb3IgKHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyA9IG51bGwpIHtcbiAgICB0aGlzLl9oYW5kbGVOZXR3b3JrRXJyb3IoY29udGV4dCwgbmV0d29ya0RldGFpbHMsIGZhbHNlLCByZXNwb25zZSk7XG4gIH1cblxuICBsb2FkdGltZW91dCAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzID0gbnVsbCkge1xuICAgIHRoaXMuX2hhbmRsZU5ldHdvcmtFcnJvcihjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgdHJ1ZSk7XG4gIH1cblxuICBfaGFuZGxlTWFzdGVyUGxheWxpc3QgKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCBzdHJpbmcgPSByZXNwb25zZS5kYXRhO1xuXG4gICAgY29uc3QgdXJsID0gUGxheWxpc3RMb2FkZXIuZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpO1xuXG4gICAgY29uc3QgbGV2ZWxzID0gTTNVOFBhcnNlci5wYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgdXJsKTtcbiAgICBpZiAoIWxldmVscy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2hhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCAnbm8gbGV2ZWwgZm91bmQgaW4gbWFuaWZlc3QnLCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gbXVsdGkgbGV2ZWwgcGxheWxpc3QsIHBhcnNlIGxldmVsIGluZm9cblxuICAgIGNvbnN0IGF1ZGlvR3JvdXBzID0gbGV2ZWxzLm1hcChsZXZlbCA9PiAoe1xuICAgICAgaWQ6IGxldmVsLmF0dHJzLkFVRElPLFxuICAgICAgY29kZWM6IGxldmVsLmF1ZGlvQ29kZWNcbiAgICB9KSk7XG5cbiAgICBsZXQgYXVkaW9UcmFja3MgPSBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIHVybCwgJ0FVRElPJywgYXVkaW9Hcm91cHMpO1xuICAgIGxldCBzdWJ0aXRsZXMgPSBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIHVybCwgJ1NVQlRJVExFUycpO1xuXG4gICAgaWYgKGF1ZGlvVHJhY2tzLmxlbmd0aCkge1xuICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSBmb3VuZCBhbiBhdWRpbyB0cmFjayBlbWJlZGRlZCBpbiBtYWluIHBsYXlsaXN0IChhdWRpbyB0cmFjayB3aXRob3V0IFVSSSBhdHRyaWJ1dGUpXG4gICAgICBsZXQgZW1iZWRkZWRBdWRpb0ZvdW5kID0gZmFsc2U7XG4gICAgICBhdWRpb1RyYWNrcy5mb3JFYWNoKGF1ZGlvVHJhY2sgPT4ge1xuICAgICAgICBpZiAoIWF1ZGlvVHJhY2sudXJsKSB7XG4gICAgICAgICAgZW1iZWRkZWRBdWRpb0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGlmIG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIGRlZmluZWQsIGJ1dCBhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLFxuICAgICAgLy8gd2UgbmVlZCB0byBzaWduYWwgdGhpcyBtYWluIGF1ZGlvIHRyYWNrIHRoaXMgY291bGQgaGFwcGVuIHdpdGggcGxheWxpc3RzIHdpdGhcbiAgICAgIC8vIGFsdCBhdWRpbyByZW5kaXRpb24gaW4gd2hpY2ggcXVhbGl0eSBsZXZlbHMgKG1haW4pXG4gICAgICAvLyBjb250YWlucyBib3RoIGF1ZGlvK3ZpZGVvLiBidXQgd2l0aCBtaXhlZCBhdWRpbyB0cmFjayBub3Qgc2lnbmFsZWRcbiAgICAgIGlmIChlbWJlZGRlZEF1ZGlvRm91bmQgPT09IGZhbHNlICYmIGxldmVsc1swXS5hdWRpb0NvZGVjICYmICFsZXZlbHNbMF0uYXR0cnMuQVVESU8pIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCwgYnV0IG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIHNpZ25hbGVkLCBjcmVhdGUgb25lJyk7XG4gICAgICAgIGF1ZGlvVHJhY2tzLnVuc2hpZnQoe1xuICAgICAgICAgIHR5cGU6ICdtYWluJyxcbiAgICAgICAgICBuYW1lOiAnbWFpbidcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGxzLnRyaWdnZXIoRXZlbnQuTUFOSUZFU1RfTE9BREVELCB7XG4gICAgICBsZXZlbHMsXG4gICAgICBhdWRpb1RyYWNrcyxcbiAgICAgIHN1YnRpdGxlcyxcbiAgICAgIHVybCxcbiAgICAgIHN0YXRzLFxuICAgICAgbmV0d29ya0RldGFpbHNcbiAgICB9KTtcbiAgfVxuXG4gIF9oYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdCAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuXG4gICAgY29uc3QgeyBpZCwgbGV2ZWwsIHR5cGUgfSA9IGNvbnRleHQ7XG5cbiAgICBjb25zdCB1cmwgPSBQbGF5bGlzdExvYWRlci5nZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XG5cbiAgICBjb25zdCBsZXZlbFVybElkID0gTnVtYmVyLmlzRmluaXRlKGlkKSA/IGlkIDogMDtcbiAgICBjb25zdCBsZXZlbElkID0gTnVtYmVyLmlzRmluaXRlKGxldmVsKSA/IGxldmVsIDogbGV2ZWxVcmxJZDtcbiAgICBjb25zdCBsZXZlbFR5cGUgPSBQbGF5bGlzdExvYWRlci5tYXBDb250ZXh0VG9MZXZlbFR5cGUoY29udGV4dCk7XG5cbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSBNM1U4UGFyc2VyLnBhcnNlTGV2ZWxQbGF5bGlzdChyZXNwb25zZS5kYXRhLCB1cmwsIGxldmVsSWQsIGxldmVsVHlwZSwgbGV2ZWxVcmxJZCk7XG5cbiAgICAvLyBzZXQgc3RhdHMgb24gbGV2ZWwgc3RydWN0dXJlXG4gICAgbGV2ZWxEZXRhaWxzLnRsb2FkID0gc3RhdHMudGxvYWQ7XG5cbiAgICAvLyBXZSBoYXZlIGRvbmUgb3VyIGZpcnN0IHJlcXVlc3QgKE1hbmlmZXN0LXR5cGUpIGFuZCByZWNlaXZlXG4gICAgLy8gbm90IGEgbWFzdGVyIHBsYXlsaXN0IGJ1dCBhIGNodW5rLWxpc3QgKHRyYWNrL2xldmVsKVxuICAgIC8vIFdlIGZpcmUgdGhlIG1hbmlmZXN0LWxvYWRlZCBldmVudCBhbnl3YXkgd2l0aCB0aGUgcGFyc2VkIGxldmVsLWRldGFpbHNcbiAgICAvLyBieSBjcmVhdGluZyBhIHNpbmdsZS1sZXZlbCBzdHJ1Y3R1cmUgZm9yIGl0LlxuICAgIGlmICh0eXBlID09PSBDb250ZXh0VHlwZS5NQU5JRkVTVCkge1xuICAgICAgY29uc3Qgc2luZ2xlTGV2ZWwgPSB7XG4gICAgICAgIHVybCxcbiAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzXG4gICAgICB9O1xuXG4gICAgICBobHMudHJpZ2dlcihFdmVudC5NQU5JRkVTVF9MT0FERUQsIHtcbiAgICAgICAgbGV2ZWxzOiBbc2luZ2xlTGV2ZWxdLFxuICAgICAgICBhdWRpb1RyYWNrczogW10sXG4gICAgICAgIHVybCxcbiAgICAgICAgc3RhdHMsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzYXZlIHBhcnNpbmcgdGltZVxuICAgIHN0YXRzLnRwYXJzZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgIC8vIGluIGNhc2Ugd2UgbmVlZCBTSURYIHJhbmdlc1xuICAgIC8vIHJldHVybiBlYXJseSBhZnRlciBjYWxsaW5nIGxvYWQgZm9yXG4gICAgLy8gdGhlIFNJRFggYm94LlxuICAgIGlmIChsZXZlbERldGFpbHMubmVlZFNpZHhSYW5nZXMpIHtcbiAgICAgIGNvbnN0IHNpZHhVcmwgPSBsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQudXJsO1xuICAgICAgdGhpcy5sb2FkKHNpZHhVcmwsIHtcbiAgICAgICAgaXNTaWR4UmVxdWVzdDogdHJ1ZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbGV2ZWwsXG4gICAgICAgIGxldmVsRGV0YWlscyxcbiAgICAgICAgaWQsXG4gICAgICAgIHJhbmdlU3RhcnQ6IDAsXG4gICAgICAgIHJhbmdlRW5kOiAyMDQ4LFxuICAgICAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcidcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGV4dGVuZCB0aGUgY29udGV4dCB3aXRoIHRoZSBuZXcgbGV2ZWxEZXRhaWxzIHByb3BlcnR5XG4gICAgY29udGV4dC5sZXZlbERldGFpbHMgPSBsZXZlbERldGFpbHM7XG5cbiAgICB0aGlzLl9oYW5kbGVQbGF5bGlzdExvYWRlZChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKTtcbiAgfVxuXG4gIF9oYW5kbGVTaWR4UmVxdWVzdCAocmVzcG9uc2UsIGNvbnRleHQpIHtcbiAgICBjb25zdCBzaWR4SW5mbyA9IE1QNERlbXV4ZXIucGFyc2VTZWdtZW50SW5kZXgobmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UuZGF0YSkpO1xuICAgIC8vIGlmIHByb3ZpZGVkIGZyYWdtZW50IGRvZXMgbm90IGNvbnRhaW4gc2lkeCwgZWFybHkgcmV0dXJuXG4gICAgaWYgKCFzaWR4SW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaWR4UmVmZXJlbmNlcyA9IHNpZHhJbmZvLnJlZmVyZW5jZXM7XG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gY29udGV4dC5sZXZlbERldGFpbHM7XG4gICAgc2lkeFJlZmVyZW5jZXMuZm9yRWFjaCgoc2VnbWVudFJlZiwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHNlZ1JlZkluZm8gPSBzZWdtZW50UmVmLmluZm87XG4gICAgICBjb25zdCBmcmFnID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1tpbmRleF07XG5cbiAgICAgIGlmIChmcmFnLmJ5dGVSYW5nZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZnJhZy5yYXdCeXRlUmFuZ2UgPSBTdHJpbmcoMSArIHNlZ1JlZkluZm8uZW5kIC0gc2VnUmVmSW5mby5zdGFydCkgKyAnQCcgKyBTdHJpbmcoc2VnUmVmSW5mby5zdGFydCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV2ZWxEZXRhaWxzLmluaXRTZWdtZW50LnJhd0J5dGVSYW5nZSA9IFN0cmluZyhzaWR4SW5mby5tb292RW5kT2Zmc2V0KSArICdAMCc7XG4gIH1cblxuICBfaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IgKHJlc3BvbnNlLCBjb250ZXh0LCByZWFzb24sIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudC5FUlJPUiwge1xuICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX1BBUlNJTkdfRVJST1IsXG4gICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgcmVhc29uLFxuICAgICAgbmV0d29ya0RldGFpbHNcbiAgICB9KTtcbiAgfVxuXG4gIF9oYW5kbGVOZXR3b3JrRXJyb3IgKGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCB0aW1lb3V0ID0gZmFsc2UsIHJlc3BvbnNlID0gbnVsbCkge1xuICAgIGxvZ2dlci5pbmZvKGBBIG5ldHdvcmsgZXJyb3Igb2NjdXJlZCB3aGlsZSBsb2FkaW5nIGEgJHtjb250ZXh0LnR5cGV9LXR5cGUgcGxheWxpc3RgKTtcblxuICAgIGxldCBkZXRhaWxzO1xuICAgIGxldCBmYXRhbDtcblxuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG5cbiAgICBzd2l0Y2ggKGNvbnRleHQudHlwZSkge1xuICAgIGNhc2UgQ29udGV4dFR5cGUuTUFOSUZFU1Q6XG4gICAgICBkZXRhaWxzID0gKHRpbWVvdXQgPyBFcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9USU1FT1VUIDogRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfRVJST1IpO1xuICAgICAgZmF0YWwgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDb250ZXh0VHlwZS5MRVZFTDpcbiAgICAgIGRldGFpbHMgPSAodGltZW91dCA/IEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQgOiBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUik7XG4gICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgIGRldGFpbHMgPSAodGltZW91dCA/IEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQgOiBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUik7XG4gICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGRldGFpbHMgPSAuLi4/XG4gICAgICBmYXRhbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHQudHlwZSk7XG4gICAgfVxuXG4gICAgbGV0IGVycm9yRGF0YSA9IHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgIGRldGFpbHMsXG4gICAgICBmYXRhbCxcbiAgICAgIHVybDogbG9hZGVyLnVybCxcbiAgICAgIGxvYWRlcixcbiAgICAgIGNvbnRleHQsXG4gICAgICBuZXR3b3JrRGV0YWlsc1xuICAgIH07XG5cbiAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgIGVycm9yRGF0YS5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIH1cblxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuRVJST1IsIGVycm9yRGF0YSk7XG4gIH1cblxuICBfaGFuZGxlUGxheWxpc3RMb2FkZWQgKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICBjb25zdCB7IHR5cGUsIGxldmVsLCBpZCwgbGV2ZWxEZXRhaWxzIH0gPSBjb250ZXh0O1xuXG4gICAgaWYgKCFsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pIHtcbiAgICAgIHRoaXMuX2hhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCAnaW52YWxpZCB0YXJnZXQgZHVyYXRpb24nLCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2FuSGF2ZUxldmVscyA9IFBsYXlsaXN0TG9hZGVyLmNhbkhhdmVRdWFsaXR5TGV2ZWxzKGNvbnRleHQudHlwZSk7XG4gICAgaWYgKGNhbkhhdmVMZXZlbHMpIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuTEVWRUxfTE9BREVELCB7XG4gICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgbGV2ZWw6IGxldmVsIHx8IDAsXG4gICAgICAgIGlkOiBpZCB8fCAwLFxuICAgICAgICBzdGF0cyxcbiAgICAgICAgbmV0d29ya0RldGFpbHNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQ29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuQVVESU9fVFJBQ0tfTE9BREVELCB7XG4gICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0s6XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnQuU1VCVElUTEVfVFJBQ0tfTE9BREVELCB7XG4gICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGxheWxpc3RMb2FkZXI7XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudGVtaXR0ZXIzJztcblxuLyoqXG4gKiBAY2xhc3NcbiAqXG4gKiBTaW1wbGUgYWRhcHRlciBzdWItY2xhc3Mgb2YgTm9kZWpzLWxpa2UgRXZlbnRFbWl0dGVyLlxuICpcbiAqIFdlIHNpbXBseSB3YW50IHRvIHBhc3MgYWxvbmcgdGhlIGV2ZW50LW5hbWUgaXRzZWxmXG4gKiBpbiBldmVyeSBjYWxsIHRvIGEgaGFuZGxlciwgd2hpY2ggaXMgdGhlIHB1cnBvc2Ugb2Ygb3VyIGB0cmlnZ2VyYCBtZXRob2RcbiAqIGV4dGVuZGluZyB0aGUgc3RhbmRhcmQgQVBJLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIE9ic2VydmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge2FueX0gZGF0YVxuICAgKi9cbiAgdHJpZ2dlciAoZXZlbnQsIC4uLmRhdGEpIHtcbiAgICB0aGlzLmVtaXQoZXZlbnQsIGV2ZW50LCAuLi5kYXRhKTtcbiAgfVxufVxuIiwiLyoqXG4gKiAgQUFDIGhlbHBlclxuICovXG5cbmNsYXNzIEFBQyB7XG4gIHN0YXRpYyBnZXRTaWxlbnRGcmFtZSAoY29kZWMsIGNoYW5uZWxDb3VudCkge1xuICAgIHN3aXRjaCAoY29kZWMpIHtcbiAgICBjYXNlICdtcDRhLjQwLjInOlxuICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjMsIDB4ODBdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgyMSwgMHgwMCwgMHg0OSwgMHg5MCwgMHgwMiwgMHgxOSwgMHgwMCwgMHgyMywgMHg4MF0pO1xuICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDhlXSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODAsIDB4MmMsIDB4ODAsIDB4MDgsIDB4MDIsIDB4MzhdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA1KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgzOF0pO1xuICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDAwLCAweGIyLCAweDAwLCAweDIwLCAweDA4LCAweGUwXSk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIC8vIGhhbmRsZSBIRS1BQUMgYmVsb3cgKG1wNGEuNDAuNSAvIG1wNGEuNDAuMjkpXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGUgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NGUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgxYywgMHg2LCAweGYxLCAweGMxLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NWUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDk1LCAweDAsIDB4NiwgMHhmMSwgMHhhMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xuICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NWUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDk1LCAweDAsIDB4NiwgMHhmMSwgMHhhMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQUFDO1xuIiwiLyoqXG4gKiBHZW5lcmF0ZSBNUDQgQm94XG4qL1xuXG5jb25zdCBVSU5UMzJfTUFYID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcblxuY2xhc3MgTVA0IHtcbiAgc3RhdGljIGluaXQgKCkge1xuICAgIE1QNC50eXBlcyA9IHtcbiAgICAgIGF2YzE6IFtdLCAvLyBjb2RpbmduYW1lXG4gICAgICBhdmNDOiBbXSxcbiAgICAgIGJ0cnQ6IFtdLFxuICAgICAgZGluZjogW10sXG4gICAgICBkcmVmOiBbXSxcbiAgICAgIGVzZHM6IFtdLFxuICAgICAgZnR5cDogW10sXG4gICAgICBoZGxyOiBbXSxcbiAgICAgIG1kYXQ6IFtdLFxuICAgICAgbWRoZDogW10sXG4gICAgICBtZGlhOiBbXSxcbiAgICAgIG1maGQ6IFtdLFxuICAgICAgbWluZjogW10sXG4gICAgICBtb29mOiBbXSxcbiAgICAgIG1vb3Y6IFtdLFxuICAgICAgbXA0YTogW10sXG4gICAgICAnLm1wMyc6IFtdLFxuICAgICAgbXZleDogW10sXG4gICAgICBtdmhkOiBbXSxcbiAgICAgIHBhc3A6IFtdLFxuICAgICAgc2R0cDogW10sXG4gICAgICBzdGJsOiBbXSxcbiAgICAgIHN0Y286IFtdLFxuICAgICAgc3RzYzogW10sXG4gICAgICBzdHNkOiBbXSxcbiAgICAgIHN0c3o6IFtdLFxuICAgICAgc3R0czogW10sXG4gICAgICB0ZmR0OiBbXSxcbiAgICAgIHRmaGQ6IFtdLFxuICAgICAgdHJhZjogW10sXG4gICAgICB0cmFrOiBbXSxcbiAgICAgIHRydW46IFtdLFxuICAgICAgdHJleDogW10sXG4gICAgICB0a2hkOiBbXSxcbiAgICAgIHZtaGQ6IFtdLFxuICAgICAgc21oZDogW11cbiAgICB9O1xuXG4gICAgbGV0IGk7XG4gICAgZm9yIChpIGluIE1QNC50eXBlcykge1xuICAgICAgaWYgKE1QNC50eXBlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBNUDQudHlwZXNbaV0gPSBbXG4gICAgICAgICAgaS5jaGFyQ29kZUF0KDApLFxuICAgICAgICAgIGkuY2hhckNvZGVBdCgxKSxcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMiksXG4gICAgICAgICAgaS5jaGFyQ29kZUF0KDMpXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHZpZGVvSGRsciA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAweDc2LCAweDY5LCAweDY0LCAweDY1LCAvLyBoYW5kbGVyX3R5cGU6ICd2aWRlJ1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHg1NiwgMHg2OSwgMHg2NCwgMHg2NSxcbiAgICAgIDB4NmYsIDB4NDgsIDB4NjEsIDB4NmUsXG4gICAgICAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdWaWRlb0hhbmRsZXInXG4gICAgXSk7XG5cbiAgICBsZXQgYXVkaW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgIDB4NzMsIDB4NmYsIDB4NzUsIDB4NmUsIC8vIGhhbmRsZXJfdHlwZTogJ3NvdW4nXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDUzLCAweDZmLCAweDc1LCAweDZlLFxuICAgICAgMHg2NCwgMHg0OCwgMHg2MSwgMHg2ZSxcbiAgICAgIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1NvdW5kSGFuZGxlcidcbiAgICBdKTtcblxuICAgIE1QNC5IRExSX1RZUEVTID0ge1xuICAgICAgJ3ZpZGVvJzogdmlkZW9IZGxyLFxuICAgICAgJ2F1ZGlvJzogYXVkaW9IZGxyXG4gICAgfTtcblxuICAgIGxldCBkcmVmID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZW50cnlfY291bnRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MGMsIC8vIGVudHJ5X3NpemVcbiAgICAgIDB4NzUsIDB4NzIsIDB4NmMsIDB4MjAsIC8vICd1cmwnIHR5cGVcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMSAvLyBlbnRyeV9mbGFnc1xuICAgIF0pO1xuXG4gICAgbGV0IHN0Y28gPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBlbnRyeV9jb3VudFxuICAgIF0pO1xuXG4gICAgTVA0LlNUVFMgPSBNUDQuU1RTQyA9IE1QNC5TVENPID0gc3RjbztcblxuICAgIE1QNC5TVFNaID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHNhbXBsZV9zaXplXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIHNhbXBsZV9jb3VudFxuICAgIF0pO1xuICAgIE1QNC5WTUhEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGdyYXBoaWNzbW9kZVxuICAgICAgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwIC8vIG9wY29sb3JcbiAgICBdKTtcbiAgICBNUDQuU01IRCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAvLyBiYWxhbmNlXG4gICAgICAweDAwLCAweDAwIC8vIHJlc2VydmVkXG4gICAgXSk7XG5cbiAgICBNUDQuU1RTRCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDFdKTsvLyBlbnRyeV9jb3VudFxuXG4gICAgbGV0IG1ham9yQnJhbmQgPSBuZXcgVWludDhBcnJheShbMTA1LCAxMTUsIDExMSwgMTA5XSk7IC8vIGlzb21cbiAgICBsZXQgYXZjMUJyYW5kID0gbmV3IFVpbnQ4QXJyYXkoWzk3LCAxMTgsIDk5LCA0OV0pOyAvLyBhdmMxXG4gICAgbGV0IG1pbm9yVmVyc2lvbiA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAxXSk7XG5cbiAgICBNUDQuRlRZUCA9IE1QNC5ib3goTVA0LnR5cGVzLmZ0eXAsIG1ham9yQnJhbmQsIG1pbm9yVmVyc2lvbiwgbWFqb3JCcmFuZCwgYXZjMUJyYW5kKTtcbiAgICBNUDQuRElORiA9IE1QNC5ib3goTVA0LnR5cGVzLmRpbmYsIE1QNC5ib3goTVA0LnR5cGVzLmRyZWYsIGRyZWYpKTtcbiAgfVxuXG4gIHN0YXRpYyBib3ggKHR5cGUpIHtcbiAgICBsZXRcbiAgICAgIHBheWxvYWQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgc2l6ZSA9IDgsXG4gICAgICBpID0gcGF5bG9hZC5sZW5ndGgsXG4gICAgICBsZW4gPSBpLFxuICAgICAgcmVzdWx0O1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgdG90YWwgc2l6ZSB3ZSBuZWVkIHRvIGFsbG9jYXRlXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgcmVzdWx0WzBdID0gKHNpemUgPj4gMjQpICYgMHhmZjtcbiAgICByZXN1bHRbMV0gPSAoc2l6ZSA+PiAxNikgJiAweGZmO1xuICAgIHJlc3VsdFsyXSA9IChzaXplID4+IDgpICYgMHhmZjtcbiAgICByZXN1bHRbM10gPSBzaXplICYgMHhmZjtcbiAgICByZXN1bHQuc2V0KHR5cGUsIDQpO1xuICAgIC8vIGNvcHkgdGhlIHBheWxvYWQgaW50byB0aGUgcmVzdWx0XG4gICAgZm9yIChpID0gMCwgc2l6ZSA9IDg7IGkgPCBsZW47IGkrKykge1xuICAgICAgLy8gY29weSBwYXlsb2FkW2ldIGFycmF5IEAgb2Zmc2V0IHNpemVcbiAgICAgIHJlc3VsdC5zZXQocGF5bG9hZFtpXSwgc2l6ZSk7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHN0YXRpYyBoZGxyICh0eXBlKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLmhkbHIsIE1QNC5IRExSX1RZUEVTW3R5cGVdKTtcbiAgfVxuXG4gIHN0YXRpYyBtZGF0IChkYXRhKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kYXQsIGRhdGEpO1xuICB9XG5cbiAgc3RhdGljIG1kaGQgKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcbiAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgY29uc3QgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgY29uc3QgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDEsIC8vIHZlcnNpb24gMVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICAodGltZXNjYWxlID4+IDI0KSAmIDB4RkYsXG4gICAgICAodGltZXNjYWxlID4+IDE2KSAmIDB4RkYsXG4gICAgICAodGltZXNjYWxlID4+IDgpICYgMHhGRixcbiAgICAgIHRpbWVzY2FsZSAmIDB4RkYsIC8vIHRpbWVzY2FsZVxuICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDI0KSxcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDgpICYgMHhGRixcbiAgICAgIHVwcGVyV29yZER1cmF0aW9uICYgMHhGRixcbiAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAyNCksXG4gICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcbiAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiA4KSAmIDB4RkYsXG4gICAgICBsb3dlcldvcmREdXJhdGlvbiAmIDB4RkYsXG4gICAgICAweDU1LCAweGM0LCAvLyAndW5kJyBsYW5ndWFnZSAodW5kZXRlcm1pbmVkKVxuICAgICAgMHgwMCwgMHgwMFxuICAgIF0pKTtcbiAgfVxuXG4gIHN0YXRpYyBtZGlhICh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGlhLCBNUDQubWRoZCh0cmFjay50aW1lc2NhbGUsIHRyYWNrLmR1cmF0aW9uKSwgTVA0LmhkbHIodHJhY2sudHlwZSksIE1QNC5taW5mKHRyYWNrKSk7XG4gIH1cblxuICBzdGF0aWMgbWZoZCAoc2VxdWVuY2VOdW1iZXIpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWZoZCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAoc2VxdWVuY2VOdW1iZXIgPj4gMjQpLFxuICAgICAgKHNlcXVlbmNlTnVtYmVyID4+IDE2KSAmIDB4RkYsXG4gICAgICAoc2VxdWVuY2VOdW1iZXIgPj4gOCkgJiAweEZGLFxuICAgICAgc2VxdWVuY2VOdW1iZXIgJiAweEZGIC8vIHNlcXVlbmNlX251bWJlclxuICAgIF0pKTtcbiAgfVxuXG4gIHN0YXRpYyBtaW5mICh0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMuc21oZCwgTVA0LlNNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnZtaGQsIE1QNC5WTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIG1vb2YgKHNuLCBiYXNlTWVkaWFEZWNvZGVUaW1lLCB0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tb29mLCBNUDQubWZoZChzbiksIE1QNC50cmFmKHRyYWNrLCBiYXNlTWVkaWFEZWNvZGVUaW1lKSk7XG4gIH1cbiAgLyoqXG4gKiBAcGFyYW0gdHJhY2tzLi4uIChvcHRpb25hbCkge2FycmF5fSB0aGUgdHJhY2tzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1vdmllXG4gKi9cbiAgc3RhdGljIG1vb3YgKHRyYWNrcykge1xuICAgIGxldFxuICAgICAgaSA9IHRyYWNrcy5sZW5ndGgsXG4gICAgICBib3hlcyA9IFtdO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYm94ZXNbaV0gPSBNUDQudHJhayh0cmFja3NbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubW9vdiwgTVA0Lm12aGQodHJhY2tzWzBdLnRpbWVzY2FsZSwgdHJhY2tzWzBdLmR1cmF0aW9uKV0uY29uY2F0KGJveGVzKS5jb25jYXQoTVA0Lm12ZXgodHJhY2tzKSkpO1xuICB9XG5cbiAgc3RhdGljIG12ZXggKHRyYWNrcykge1xuICAgIGxldFxuICAgICAgaSA9IHRyYWNrcy5sZW5ndGgsXG4gICAgICBib3hlcyA9IFtdO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYm94ZXNbaV0gPSBNUDQudHJleCh0cmFja3NbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubXZleF0uY29uY2F0KGJveGVzKSk7XG4gIH1cblxuICBzdGF0aWMgbXZoZCAodGltZXNjYWxlLCBkdXJhdGlvbikge1xuICAgIGR1cmF0aW9uICo9IHRpbWVzY2FsZTtcbiAgICBjb25zdCB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICBjb25zdCBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICBsZXRcbiAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDAxLCAvLyB2ZXJzaW9uIDFcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMiwgLy8gY3JlYXRpb25fdGltZVxuICAgICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLCAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgICAgICAodGltZXNjYWxlID4+IDI0KSAmIDB4RkYsXG4gICAgICAgICh0aW1lc2NhbGUgPj4gMTYpICYgMHhGRixcbiAgICAgICAgKHRpbWVzY2FsZSA+PiA4KSAmIDB4RkYsXG4gICAgICAgIHRpbWVzY2FsZSAmIDB4RkYsIC8vIHRpbWVzY2FsZVxuICAgICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMjQpLFxuICAgICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcbiAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDgpICYgMHhGRixcbiAgICAgICAgdXBwZXJXb3JkRHVyYXRpb24gJiAweEZGLFxuICAgICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gMjQpLFxuICAgICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcbiAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDgpICYgMHhGRixcbiAgICAgICAgbG93ZXJXb3JkRHVyYXRpb24gJiAweEZGLFxuICAgICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAvLyAxLjAgcmF0ZVxuICAgICAgICAweDAxLCAweDAwLCAvLyAxLjAgdm9sdW1lXG4gICAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgICAgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiAvLyBuZXh0X3RyYWNrX0lEXG4gICAgICBdKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXZoZCwgYnl0ZXMpO1xuICB9XG5cbiAgc3RhdGljIHNkdHAgKHRyYWNrKSB7XG4gICAgbGV0XG4gICAgICBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXSxcbiAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCArIHNhbXBsZXMubGVuZ3RoKSxcbiAgICAgIGZsYWdzLFxuICAgICAgaTtcbiAgICAvLyBsZWF2ZSB0aGUgZnVsbCBib3ggaGVhZGVyICg0IGJ5dGVzKSBhbGwgemVyb1xuICAgIC8vIHdyaXRlIHRoZSBzYW1wbGUgdGFibGVcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZmxhZ3MgPSBzYW1wbGVzW2ldLmZsYWdzO1xuICAgICAgYnl0ZXNbaSArIDRdID0gKGZsYWdzLmRlcGVuZHNPbiA8PCA0KSB8XG4gICAgICAgIChmbGFncy5pc0RlcGVuZGVkT24gPDwgMikgfFxuICAgICAgICAoZmxhZ3MuaGFzUmVkdW5kYW5jeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnNkdHAsIGJ5dGVzKTtcbiAgfVxuXG4gIHN0YXRpYyBzdGJsICh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdGJsLCBNUDQuc3RzZCh0cmFjayksIE1QNC5ib3goTVA0LnR5cGVzLnN0dHMsIE1QNC5TVFRTKSwgTVA0LmJveChNUDQudHlwZXMuc3RzYywgTVA0LlNUU0MpLCBNUDQuYm94KE1QNC50eXBlcy5zdHN6LCBNUDQuU1RTWiksIE1QNC5ib3goTVA0LnR5cGVzLnN0Y28sIE1QNC5TVENPKSk7XG4gIH1cblxuICBzdGF0aWMgYXZjMSAodHJhY2spIHtcbiAgICBsZXQgc3BzID0gW10sIHBwcyA9IFtdLCBpLCBkYXRhLCBsZW47XG4gICAgLy8gYXNzZW1ibGUgdGhlIFNQU3NcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5zcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEgPSB0cmFjay5zcHNbaV07XG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBzcHMucHVzaCgobGVuID4+PiA4KSAmIDB4RkYpO1xuICAgICAgc3BzLnB1c2goKGxlbiAmIDB4RkYpKTtcblxuICAgICAgLy8gU1BTXG4gICAgICBzcHMgPSBzcHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBhc3NlbWJsZSB0aGUgUFBTc1xuICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5wcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEgPSB0cmFjay5wcHNbaV07XG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBwcHMucHVzaCgobGVuID4+PiA4KSAmIDB4RkYpO1xuICAgICAgcHBzLnB1c2goKGxlbiAmIDB4RkYpKTtcblxuICAgICAgcHBzID0gcHBzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7XG4gICAgfVxuXG4gICAgbGV0IGF2Y2MgPSBNUDQuYm94KE1QNC50eXBlcy5hdmNDLCBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MDEsIC8vIHZlcnNpb25cbiAgICAgICAgc3BzWzNdLCAvLyBwcm9maWxlXG4gICAgICAgIHNwc1s0XSwgLy8gcHJvZmlsZSBjb21wYXRcbiAgICAgICAgc3BzWzVdLCAvLyBsZXZlbFxuICAgICAgICAweGZjIHwgMywgLy8gbGVuZ3RoU2l6ZU1pbnVzT25lLCBoYXJkLWNvZGVkIHRvIDQgYnl0ZXNcbiAgICAgICAgMHhFMCB8IHRyYWNrLnNwcy5sZW5ndGggLy8gM2JpdCByZXNlcnZlZCAoMTExKSArIG51bU9mU2VxdWVuY2VQYXJhbWV0ZXJTZXRzXG4gICAgICBdLmNvbmNhdChzcHMpLmNvbmNhdChbXG4gICAgICAgIHRyYWNrLnBwcy5sZW5ndGggLy8gbnVtT2ZQaWN0dXJlUGFyYW1ldGVyU2V0c1xuICAgICAgXSkuY29uY2F0KHBwcykpKSwgLy8gXCJQUFNcIlxuICAgICAgd2lkdGggPSB0cmFjay53aWR0aCxcbiAgICAgIGhlaWdodCA9IHRyYWNrLmhlaWdodCxcbiAgICAgIGhTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1swXSxcbiAgICAgIHZTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1sxXTtcblxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5hdmMxLCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgICAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgICh3aWR0aCA+PiA4KSAmIDB4RkYsXG4gICAgICB3aWR0aCAmIDB4ZmYsIC8vIHdpZHRoXG4gICAgICAoaGVpZ2h0ID4+IDgpICYgMHhGRixcbiAgICAgIGhlaWdodCAmIDB4ZmYsIC8vIGhlaWdodFxuICAgICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCwgLy8gaG9yaXpyZXNvbHV0aW9uXG4gICAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLCAvLyB2ZXJ0cmVzb2x1dGlvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsIC8vIGZyYW1lX2NvdW50XG4gICAgICAweDEyLFxuICAgICAgMHg2NCwgMHg2MSwgMHg2OSwgMHg2QywgLy8gZGFpbHltb3Rpb24vaGxzLmpzXG4gICAgICAweDc5LCAweDZELCAweDZGLCAweDc0LFxuICAgICAgMHg2OSwgMHg2RiwgMHg2RSwgMHgyRixcbiAgICAgIDB4NjgsIDB4NkMsIDB4NzMsIDB4MkUsXG4gICAgICAweDZBLCAweDczLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBjb21wcmVzc29ybmFtZVxuICAgICAgMHgwMCwgMHgxOCwgLy8gZGVwdGggPSAyNFxuICAgICAgMHgxMSwgMHgxMV0pLCAvLyBwcmVfZGVmaW5lZCA9IC0xXG4gICAgYXZjYyxcbiAgICBNUDQuYm94KE1QNC50eXBlcy5idHJ0LCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAweDFjLCAweDljLCAweDgwLCAvLyBidWZmZXJTaXplREJcbiAgICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzAsIC8vIG1heEJpdHJhdGVcbiAgICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzBdKSksIC8vIGF2Z0JpdHJhdGVcbiAgICBNUDQuYm94KE1QNC50eXBlcy5wYXNwLCBuZXcgVWludDhBcnJheShbXG4gICAgICAoaFNwYWNpbmcgPj4gMjQpLCAvLyBoU3BhY2luZ1xuICAgICAgKGhTcGFjaW5nID4+IDE2KSAmIDB4RkYsXG4gICAgICAoaFNwYWNpbmcgPj4gOCkgJiAweEZGLFxuICAgICAgaFNwYWNpbmcgJiAweEZGLFxuICAgICAgKHZTcGFjaW5nID4+IDI0KSwgLy8gdlNwYWNpbmdcbiAgICAgICh2U3BhY2luZyA+PiAxNikgJiAweEZGLFxuICAgICAgKHZTcGFjaW5nID4+IDgpICYgMHhGRixcbiAgICAgIHZTcGFjaW5nICYgMHhGRl0pKVxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgZXNkcyAodHJhY2spIHtcbiAgICBsZXQgY29uZmlnbGVuID0gdHJhY2suY29uZmlnLmxlbmd0aDtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuXG4gICAgICAweDAzLCAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgIDB4MTcgKyBjb25maWdsZW4sIC8vIGxlbmd0aFxuICAgICAgMHgwMCwgMHgwMSwgLy8gZXNfaWRcbiAgICAgIDB4MDAsIC8vIHN0cmVhbV9wcmlvcml0eVxuXG4gICAgICAweDA0LCAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgIDB4MGYgKyBjb25maWdsZW4sIC8vIGxlbmd0aFxuICAgICAgMHg0MCwgLy8gY29kZWMgOiBtcGVnNF9hdWRpb1xuICAgICAgMHgxNSwgLy8gc3RyZWFtX3R5cGVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGJ1ZmZlcl9zaXplXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBtYXhCaXRyYXRlXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBhdmdCaXRyYXRlXG5cbiAgICAgIDB4MDUgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgXS5jb25jYXQoW2NvbmZpZ2xlbl0pLmNvbmNhdCh0cmFjay5jb25maWcpLmNvbmNhdChbMHgwNiwgMHgwMSwgMHgwMl0pKTsgLy8gR0FTcGVjaWZpY0NvbmZpZykpOyAvLyBsZW5ndGggKyBhdWRpbyBjb25maWcgZGVzY3JpcHRvclxuICB9XG5cbiAgc3RhdGljIG1wNGEgKHRyYWNrKSB7XG4gICAgbGV0IHNhbXBsZXJhdGUgPSB0cmFjay5zYW1wbGVyYXRlO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tcDRhLCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIHRyYWNrLmNoYW5uZWxDb3VudCwgLy8gY2hhbm5lbGNvdW50XG4gICAgICAweDAwLCAweDEwLCAvLyBzYW1wbGVTaXplOjE2Yml0c1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWQyXG4gICAgICAoc2FtcGxlcmF0ZSA+PiA4KSAmIDB4RkYsXG4gICAgICBzYW1wbGVyYXRlICYgMHhmZiwgLy9cbiAgICAgIDB4MDAsIDB4MDBdKSxcbiAgICBNUDQuYm94KE1QNC50eXBlcy5lc2RzLCBNUDQuZXNkcyh0cmFjaykpKTtcbiAgfVxuXG4gIHN0YXRpYyBtcDMgKHRyYWNrKSB7XG4gICAgbGV0IHNhbXBsZXJhdGUgPSB0cmFjay5zYW1wbGVyYXRlO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlc1snLm1wMyddLCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIHRyYWNrLmNoYW5uZWxDb3VudCwgLy8gY2hhbm5lbGNvdW50XG4gICAgICAweDAwLCAweDEwLCAvLyBzYW1wbGVTaXplOjE2Yml0c1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWQyXG4gICAgICAoc2FtcGxlcmF0ZSA+PiA4KSAmIDB4RkYsXG4gICAgICBzYW1wbGVyYXRlICYgMHhmZiwgLy9cbiAgICAgIDB4MDAsIDB4MDBdKSk7XG4gIH1cblxuICBzdGF0aWMgc3RzZCAodHJhY2spIHtcbiAgICBpZiAodHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgaWYgKCF0cmFjay5pc0FBQyAmJiB0cmFjay5jb2RlYyA9PT0gJ21wMycpIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQubXAzKHRyYWNrKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lm1wNGEodHJhY2spKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQuYXZjMSh0cmFjaykpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyB0a2hkICh0cmFjaykge1xuICAgIGxldCBpZCA9IHRyYWNrLmlkLFxuICAgICAgZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiAqIHRyYWNrLnRpbWVzY2FsZSxcbiAgICAgIHdpZHRoID0gdHJhY2sud2lkdGgsXG4gICAgICBoZWlnaHQgPSB0cmFjay5oZWlnaHQsXG4gICAgICB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKSxcbiAgICAgIGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50a2hkLCBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAxLCAvLyB2ZXJzaW9uIDFcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDcsIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLCAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgICAgKGlkID4+IDI0KSAmIDB4RkYsXG4gICAgICAoaWQgPj4gMTYpICYgMHhGRixcbiAgICAgIChpZCA+PiA4KSAmIDB4RkYsXG4gICAgICBpZCAmIDB4RkYsIC8vIHRyYWNrX0lEXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDI0KSxcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweEZGLFxuICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDgpICYgMHhGRixcbiAgICAgIHVwcGVyV29yZER1cmF0aW9uICYgMHhGRixcbiAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAyNCksXG4gICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhGRixcbiAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiA4KSAmIDB4RkYsXG4gICAgICBsb3dlcldvcmREdXJhdGlvbiAmIDB4RkYsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIC8vIGxheWVyXG4gICAgICAweDAwLCAweDAwLCAvLyBhbHRlcm5hdGVfZ3JvdXBcbiAgICAgIDB4MDAsIDB4MDAsIC8vIG5vbi1hdWRpbyB0cmFjayB2b2x1bWVcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcbiAgICAgICh3aWR0aCA+PiA4KSAmIDB4RkYsXG4gICAgICB3aWR0aCAmIDB4RkYsXG4gICAgICAweDAwLCAweDAwLCAvLyB3aWR0aFxuICAgICAgKGhlaWdodCA+PiA4KSAmIDB4RkYsXG4gICAgICBoZWlnaHQgJiAweEZGLFxuICAgICAgMHgwMCwgMHgwMCAvLyBoZWlnaHRcbiAgICBdKSk7XG4gIH1cblxuICBzdGF0aWMgdHJhZiAodHJhY2ssIGJhc2VNZWRpYURlY29kZVRpbWUpIHtcbiAgICBsZXQgc2FtcGxlRGVwZW5kZW5jeVRhYmxlID0gTVA0LnNkdHAodHJhY2spLFxuICAgICAgaWQgPSB0cmFjay5pZCxcbiAgICAgIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgLyAoVUlOVDMyX01BWCArIDEpKSxcbiAgICAgIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhZixcbiAgICAgIE1QNC5ib3goTVA0LnR5cGVzLnRmaGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgICAgIChpZCA+PiAyNCksXG4gICAgICAgIChpZCA+PiAxNikgJiAwWEZGLFxuICAgICAgICAoaWQgPj4gOCkgJiAwWEZGLFxuICAgICAgICAoaWQgJiAweEZGKSAvLyB0cmFja19JRFxuICAgICAgXSkpLFxuICAgICAgTVA0LmJveChNUDQudHlwZXMudGZkdCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDAxLCAvLyB2ZXJzaW9uIDFcbiAgICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMjQpLFxuICAgICAgICAodXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAxNikgJiAwWEZGLFxuICAgICAgICAodXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4KSAmIDBYRkYsXG4gICAgICAgICh1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhGRiksXG4gICAgICAgIChsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDI0KSxcbiAgICAgICAgKGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYpICYgMFhGRixcbiAgICAgICAgKGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gOCkgJiAwWEZGLFxuICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4RkYpXG4gICAgICBdKSksXG4gICAgICBNUDQudHJ1bih0cmFjayxcbiAgICAgICAgc2FtcGxlRGVwZW5kZW5jeVRhYmxlLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgIDE2ICsgLy8gdGZoZFxuICAgICAgICAgICAgICAgICAgICAyMCArIC8vIHRmZHRcbiAgICAgICAgICAgICAgICAgICAgOCArIC8vIHRyYWYgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgIDE2ICsgLy8gbWZoZFxuICAgICAgICAgICAgICAgICAgICA4ICsgLy8gbW9vZiBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgOCksIC8vIG1kYXQgaGVhZGVyXG4gICAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhY2sgYm94LlxuICAgKiBAcGFyYW0gdHJhY2sge29iamVjdH0gYSB0cmFjayBkZWZpbml0aW9uXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IHRoZSB0cmFjayBib3hcbiAgICovXG4gIHN0YXRpYyB0cmFrICh0cmFjaykge1xuICAgIHRyYWNrLmR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24gfHwgMHhmZmZmZmZmZjtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhaywgTVA0LnRraGQodHJhY2spLCBNUDQubWRpYSh0cmFjaykpO1xuICB9XG5cbiAgc3RhdGljIHRyZXggKHRyYWNrKSB7XG4gICAgbGV0IGlkID0gdHJhY2suaWQ7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyZXgsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIChpZCA+PiAyNCksXG4gICAgICAoaWQgPj4gMTYpICYgMFhGRixcbiAgICAgIChpZCA+PiA4KSAmIDBYRkYsXG4gICAgICAoaWQgJiAweEZGKSwgLy8gdHJhY2tfSURcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4XG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfc2l6ZVxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMSAvLyBkZWZhdWx0X3NhbXBsZV9mbGFnc1xuICAgIF0pKTtcbiAgfVxuXG4gIHN0YXRpYyB0cnVuICh0cmFjaywgb2Zmc2V0KSB7XG4gICAgbGV0IHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdLFxuICAgICAgbGVuID0gc2FtcGxlcy5sZW5ndGgsXG4gICAgICBhcnJheWxlbiA9IDEyICsgKDE2ICogbGVuKSxcbiAgICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlsZW4pLFxuICAgICAgaSwgc2FtcGxlLCBkdXJhdGlvbiwgc2l6ZSwgZmxhZ3MsIGN0cztcbiAgICBvZmZzZXQgKz0gOCArIGFycmF5bGVuO1xuICAgIGFycmF5LnNldChbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MGYsIDB4MDEsIC8vIGZsYWdzXG4gICAgICAobGVuID4+PiAyNCkgJiAweEZGLFxuICAgICAgKGxlbiA+Pj4gMTYpICYgMHhGRixcbiAgICAgIChsZW4gPj4+IDgpICYgMHhGRixcbiAgICAgIGxlbiAmIDB4RkYsIC8vIHNhbXBsZV9jb3VudFxuICAgICAgKG9mZnNldCA+Pj4gMjQpICYgMHhGRixcbiAgICAgIChvZmZzZXQgPj4+IDE2KSAmIDB4RkYsXG4gICAgICAob2Zmc2V0ID4+PiA4KSAmIDB4RkYsXG4gICAgICBvZmZzZXQgJiAweEZGIC8vIGRhdGFfb2Zmc2V0XG4gICAgXSwgMCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzYW1wbGUgPSBzYW1wbGVzW2ldO1xuICAgICAgZHVyYXRpb24gPSBzYW1wbGUuZHVyYXRpb247XG4gICAgICBzaXplID0gc2FtcGxlLnNpemU7XG4gICAgICBmbGFncyA9IHNhbXBsZS5mbGFncztcbiAgICAgIGN0cyA9IHNhbXBsZS5jdHM7XG4gICAgICBhcnJheS5zZXQoW1xuICAgICAgICAoZHVyYXRpb24gPj4+IDI0KSAmIDB4RkYsXG4gICAgICAgIChkdXJhdGlvbiA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgKGR1cmF0aW9uID4+PiA4KSAmIDB4RkYsXG4gICAgICAgIGR1cmF0aW9uICYgMHhGRiwgLy8gc2FtcGxlX2R1cmF0aW9uXG4gICAgICAgIChzaXplID4+PiAyNCkgJiAweEZGLFxuICAgICAgICAoc2l6ZSA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgKHNpemUgPj4+IDgpICYgMHhGRixcbiAgICAgICAgc2l6ZSAmIDB4RkYsIC8vIHNhbXBsZV9zaXplXG4gICAgICAgIChmbGFncy5pc0xlYWRpbmcgPDwgMikgfCBmbGFncy5kZXBlbmRzT24sXG4gICAgICAgIChmbGFncy5pc0RlcGVuZGVkT24gPDwgNikgfFxuICAgICAgICAgIChmbGFncy5oYXNSZWR1bmRhbmN5IDw8IDQpIHxcbiAgICAgICAgICAoZmxhZ3MucGFkZGluZ1ZhbHVlIDw8IDEpIHxcbiAgICAgICAgICBmbGFncy5pc05vblN5bmMsXG4gICAgICAgIGZsYWdzLmRlZ3JhZFByaW8gJiAweEYwIDw8IDgsXG4gICAgICAgIGZsYWdzLmRlZ3JhZFByaW8gJiAweDBGLCAvLyBzYW1wbGVfZmxhZ3NcbiAgICAgICAgKGN0cyA+Pj4gMjQpICYgMHhGRixcbiAgICAgICAgKGN0cyA+Pj4gMTYpICYgMHhGRixcbiAgICAgICAgKGN0cyA+Pj4gOCkgJiAweEZGLFxuICAgICAgICBjdHMgJiAweEZGIC8vIHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxuICAgICAgXSwgMTIgKyAxNiAqIGkpO1xuICAgIH1cbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJ1biwgYXJyYXkpO1xuICB9XG5cbiAgc3RhdGljIGluaXRTZWdtZW50ICh0cmFja3MpIHtcbiAgICBpZiAoIU1QNC50eXBlcykge1xuICAgICAgTVA0LmluaXQoKTtcbiAgICB9XG5cbiAgICBsZXQgbW92aWUgPSBNUDQubW9vdih0cmFja3MpLCByZXN1bHQ7XG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTVA0LkZUWVAuYnl0ZUxlbmd0aCArIG1vdmllLmJ5dGVMZW5ndGgpO1xuICAgIHJlc3VsdC5zZXQoTVA0LkZUWVApO1xuICAgIHJlc3VsdC5zZXQobW92aWUsIE1QNC5GVFlQLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTVA0O1xuIiwiLyoqXG4gKiBmTVA0IHJlbXV4ZXJcbiovXG5cbmltcG9ydCBBQUMgZnJvbSAnLi9hYWMtaGVscGVyJztcbmltcG9ydCBNUDQgZnJvbSAnLi9tcDQtZ2VuZXJhdG9yJztcblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG4vLyAxMCBzZWNvbmRzXG5jb25zdCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OID0gMTAgKiAxMDAwO1xuXG5jbGFzcyBNUDRSZW11eGVyIHtcbiAgY29uc3RydWN0b3IgKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQsIHZlbmRvcikge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgdGhpcy5pc1NhZmFyaSA9IHZlbmRvciAmJiB2ZW5kb3IuaW5kZXhPZignQXBwbGUnKSA+IC0xICYmIHVzZXJBZ2VudCAmJiAhdXNlckFnZW50Lm1hdGNoKCdDcmlPUycpO1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICB9XG5cbiAgcmVzZXRUaW1lU3RhbXAgKGRlZmF1bHRUaW1lU3RhbXApIHtcbiAgICB0aGlzLl9pbml0UFRTID0gdGhpcy5faW5pdERUUyA9IGRlZmF1bHRUaW1lU3RhbXA7XG4gIH1cblxuICByZXNldEluaXRTZWdtZW50ICgpIHtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gIH1cblxuICByZW11eCAoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgLy8gZ2VuZXJhdGUgSW5pdCBTZWdtZW50IGlmIG5lZWRlZFxuICAgIGlmICghdGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICBjb25zdCBuYkF1ZGlvU2FtcGxlcyA9IGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gICAgICBjb25zdCBuYlZpZGVvU2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gICAgICBsZXQgYXVkaW9UaW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICAgIGxldCB2aWRlb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgICAgaWYgKG5iQXVkaW9TYW1wbGVzICYmIG5iVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgIC8vIHRpbWVPZmZzZXQgaXMgZXhwZWN0ZWQgdG8gYmUgdGhlIG9mZnNldCBvZiB0aGUgZmlyc3QgdGltZXN0YW1wIG9mIHRoaXMgZnJhZ21lbnQgKGZpcnN0IERUUylcbiAgICAgICAgLy8gaWYgZmlyc3QgYXVkaW8gRFRTIGlzIG5vdCBhbGlnbmVkIHdpdGggZmlyc3QgdmlkZW8gRFRTIHRoZW4gd2UgbmVlZCB0byB0YWtlIHRoYXQgaW50byBhY2NvdW50XG4gICAgICAgIC8vIHdoZW4gcHJvdmlkaW5nIHRpbWVPZmZzZXQgdG8gcmVtdXhBdWRpbyAvIHJlbXV4VmlkZW8uIGlmIHdlIGRvbid0IGRvIHRoYXQsIHRoZXJlIG1pZ2h0IGJlIGEgcGVybWFuZW50IC8gc21hbGxcbiAgICAgICAgLy8gZHJpZnQgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW8gc3RyZWFtc1xuICAgICAgICBsZXQgYXVkaW92aWRlb0RlbHRhRHRzID0gKGF1ZGlvVHJhY2suc2FtcGxlc1swXS5wdHMgLSB2aWRlb1RyYWNrLnNhbXBsZXNbMF0ucHRzKSAvIHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgIGF1ZGlvVGltZU9mZnNldCArPSBNYXRoLm1heCgwLCBhdWRpb3ZpZGVvRGVsdGFEdHMpO1xuICAgICAgICB2aWRlb1RpbWVPZmZzZXQgKz0gTWF0aC5tYXgoMCwgLWF1ZGlvdmlkZW9EZWx0YUR0cyk7XG4gICAgICB9XG4gICAgICAvLyBQdXJwb3NlZnVsbHkgcmVtdXhpbmcgYXVkaW8gYmVmb3JlIHZpZGVvLCBzbyB0aGF0IHJlbXV4VmlkZW8gY2FuIHVzZSBuZXh0QXVkaW9QdHMsIHdoaWNoIGlzXG4gICAgICAvLyBjYWxjdWxhdGVkIGluIHJlbXV4QXVkaW8uXG4gICAgICAvLyBsb2dnZXIubG9nKCduYiBBQUMgc2FtcGxlczonICsgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgICBpZiAobmJBdWRpb1NhbXBsZXMpIHtcbiAgICAgICAgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IHZpZGVvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cbiAgICAgICAgaWYgKCFhdWRpb1RyYWNrLnRpbWVzY2FsZSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKCdyZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIGF1ZGlvIGRldGVjdGVkJyk7XG4gICAgICAgICAgdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhdWRpb0RhdGEgPSB0aGlzLnJlbXV4QXVkaW8oYXVkaW9UcmFjaywgYXVkaW9UaW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICAvLyBsb2dnZXIubG9nKCduYiBBVkMgc2FtcGxlczonICsgdmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCk7XG4gICAgICAgIGlmIChuYlZpZGVvU2FtcGxlcykge1xuICAgICAgICAgIGxldCBhdWRpb1RyYWNrTGVuZ3RoO1xuICAgICAgICAgIGlmIChhdWRpb0RhdGEpIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhY2tMZW5ndGggPSBhdWRpb0RhdGEuZW5kUFRTIC0gYXVkaW9EYXRhLnN0YXJ0UFRTO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIGluaXRTZWdtZW50IHdhcyBnZW5lcmF0ZWQgd2l0aG91dCB2aWRlbyBzYW1wbGVzLCByZWdlbmVyYXRlIGl0IGFnYWluXG4gICAgICAgICAgaWYgKCF2aWRlb1RyYWNrLnRpbWVzY2FsZSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3JlZ2VuZXJhdGUgSW5pdFNlZ21lbnQgYXMgdmlkZW8gZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yZW11eFZpZGVvKHZpZGVvVHJhY2ssIHZpZGVvVGltZU9mZnNldCwgY29udGlndW91cywgYXVkaW9UcmFja0xlbmd0aCwgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnbmIgQVZDIHNhbXBsZXM6JyArIHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgICBpZiAobmJWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICBsZXQgdmlkZW9EYXRhID0gdGhpcy5yZW11eFZpZGVvKHZpZGVvVHJhY2ssIHZpZGVvVGltZU9mZnNldCwgY29udGlndW91cywgMCwgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgICBpZiAodmlkZW9EYXRhICYmIGF1ZGlvVHJhY2suY29kZWMpIHtcbiAgICAgICAgICAgIHRoaXMucmVtdXhFbXB0eUF1ZGlvKGF1ZGlvVHJhY2ssIGF1ZGlvVGltZU9mZnNldCwgY29udGlndW91cywgdmlkZW9EYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbG9nZ2VyLmxvZygnbmIgSUQzIHNhbXBsZXM6JyArIGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgIGlmIChpZDNUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5yZW11eElEMyhpZDNUcmFjaywgdGltZU9mZnNldCk7XG4gICAgfVxuXG4gICAgLy8gbG9nZ2VyLmxvZygnbmIgSUQzIHNhbXBsZXM6JyArIGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpO1xuICAgIGlmICh0ZXh0VHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmVtdXhUZXh0KHRleHRUcmFjaywgdGltZU9mZnNldCk7XG4gICAgfVxuXG4gICAgLy8gbm90aWZ5IGVuZCBvZiBwYXJzaW5nXG4gICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0VEKTtcbiAgfVxuXG4gIGdlbmVyYXRlSVMgKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpIHtcbiAgICBsZXQgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyLFxuICAgICAgYXVkaW9TYW1wbGVzID0gYXVkaW9UcmFjay5zYW1wbGVzLFxuICAgICAgdmlkZW9TYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzLFxuICAgICAgdHlwZVN1cHBvcnRlZCA9IHRoaXMudHlwZVN1cHBvcnRlZCxcbiAgICAgIGNvbnRhaW5lciA9ICdhdWRpby9tcDQnLFxuICAgICAgdHJhY2tzID0ge30sXG4gICAgICBkYXRhID0geyB0cmFja3M6IHRyYWNrcyB9LFxuICAgICAgY29tcHV0ZVBUU0RUUyA9ICh0aGlzLl9pbml0UFRTID09PSB1bmRlZmluZWQpLFxuICAgICAgaW5pdFBUUywgaW5pdERUUztcblxuICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICBpbml0UFRTID0gaW5pdERUUyA9IEluZmluaXR5O1xuICAgIH1cblxuICAgIGlmIChhdWRpb1RyYWNrLmNvbmZpZyAmJiBhdWRpb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAvLyBsZXQncyB1c2UgYXVkaW8gc2FtcGxpbmcgcmF0ZSBhcyBNUDQgdGltZSBzY2FsZS5cbiAgICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IHRoZXJlIGlzIGEgaW50ZWdlciBuYiBvZiBhdWRpbyBmcmFtZXMgcGVyIGF1ZGlvIHNhbXBsZSAoMTAyNCBmb3IgQUFDKVxuICAgICAgLy8gdXNpbmcgYXVkaW8gc2FtcGxpbmcgcmF0ZSBoZXJlIGhlbHBzIGhhdmluZyBhbiBpbnRlZ2VyIE1QNCBmcmFtZSBkdXJhdGlvblxuICAgICAgLy8gdGhpcyBhdm9pZHMgcG90ZW50aWFsIHJvdW5kaW5nIGlzc3VlIGFuZCBBViBzeW5jIGlzc3VlXG4gICAgICBhdWRpb1RyYWNrLnRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suc2FtcGxlcmF0ZTtcbiAgICAgIGxvZ2dlci5sb2coYGF1ZGlvIHNhbXBsaW5nIHJhdGUgOiAke2F1ZGlvVHJhY2suc2FtcGxlcmF0ZX1gKTtcbiAgICAgIGlmICghYXVkaW9UcmFjay5pc0FBQykge1xuICAgICAgICBpZiAodHlwZVN1cHBvcnRlZC5tcGVnKSB7IC8vIENocm9tZSBhbmQgU2FmYXJpXG4gICAgICAgICAgY29udGFpbmVyID0gJ2F1ZGlvL21wZWcnO1xuICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlU3VwcG9ydGVkLm1wMykgeyAvLyBGaXJlZm94XG4gICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICdtcDMnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmFja3MuYXVkaW8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICBjb2RlYzogYXVkaW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6ICFhdWRpb1RyYWNrLmlzQUFDICYmIHR5cGVTdXBwb3J0ZWQubXBlZyA/IG5ldyBVaW50OEFycmF5KCkgOiBNUDQuaW5pdFNlZ21lbnQoW2F1ZGlvVHJhY2tdKSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBjaGFubmVsQ291bnQ6IGF1ZGlvVHJhY2suY2hhbm5lbENvdW50XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICAvLyByZW1lbWJlciBmaXJzdCBQVFMgb2YgdGhpcyBkZW11eGluZyBjb250ZXh0LiBmb3IgYXVkaW8sIFBUUyA9IERUU1xuICAgICAgICBpbml0UFRTID0gaW5pdERUUyA9IGF1ZGlvU2FtcGxlc1swXS5wdHMgLSBhdWRpb1RyYWNrLmlucHV0VGltZVNjYWxlICogdGltZU9mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmlkZW9UcmFjay5zcHMgJiYgdmlkZW9UcmFjay5wcHMgJiYgdmlkZW9TYW1wbGVzLmxlbmd0aCkge1xuICAgICAgLy8gbGV0J3MgdXNlIGlucHV0IHRpbWUgc2NhbGUgYXMgTVA0IHZpZGVvIHRpbWVzY2FsZVxuICAgICAgLy8gd2UgdXNlIGlucHV0IHRpbWUgc2NhbGUgc3RyYWlnaHQgYXdheSB0byBhdm9pZCByb3VuZGluZyBpc3N1ZXMgb24gZnJhbWUgZHVyYXRpb24gLyBjdHMgY29tcHV0YXRpb25cbiAgICAgIGNvbnN0IGlucHV0VGltZVNjYWxlID0gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgIHZpZGVvVHJhY2sudGltZXNjYWxlID0gaW5wdXRUaW1lU2NhbGU7XG4gICAgICB0cmFja3MudmlkZW8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsXG4gICAgICAgIGNvZGVjOiB2aWRlb1RyYWNrLmNvZGVjLFxuICAgICAgICBpbml0U2VnbWVudDogTVA0LmluaXRTZWdtZW50KFt2aWRlb1RyYWNrXSksXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgd2lkdGg6IHZpZGVvVHJhY2sud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB2aWRlb1RyYWNrLmhlaWdodFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgaW5pdFBUUyA9IE1hdGgubWluKGluaXRQVFMsIHZpZGVvU2FtcGxlc1swXS5wdHMgLSBpbnB1dFRpbWVTY2FsZSAqIHRpbWVPZmZzZXQpO1xuICAgICAgICBpbml0RFRTID0gTWF0aC5taW4oaW5pdERUUywgdmlkZW9TYW1wbGVzWzBdLmR0cyAtIGlucHV0VGltZVNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5JTklUX1BUU19GT1VORCwgeyBpbml0UFRTOiBpbml0UFRTIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyh0cmFja3MpLmxlbmd0aCkge1xuICAgICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCBkYXRhKTtcbiAgICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgdGhpcy5faW5pdFBUUyA9IGluaXRQVFM7XG4gICAgICAgIHRoaXMuX2luaXREVFMgPSBpbml0RFRTO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvYnNlcnZlci50cmlnZ2VyKEV2ZW50LkVSUk9SLCB7IHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsIGZhdGFsOiBmYWxzZSwgcmVhc29uOiAnbm8gYXVkaW8vdmlkZW8gc2FtcGxlcyBmb3VuZCcgfSk7XG4gICAgfVxuICB9XG5cbiAgcmVtdXhWaWRlbyAodHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGF1ZGlvVHJhY2tMZW5ndGgsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIGxldCBvZmZzZXQgPSA4O1xuICAgIGxldCBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICBsZXQgbWRhdDtcbiAgICBsZXQgbW9vZjtcbiAgICBsZXQgZmlyc3RQVFM7XG4gICAgbGV0IGZpcnN0RFRTO1xuICAgIGxldCBsYXN0UFRTO1xuICAgIGxldCBsYXN0RFRTO1xuICAgIGNvbnN0IHRpbWVTY2FsZSA9IHRyYWNrLnRpbWVzY2FsZTtcbiAgICBjb25zdCBpbnB1dFNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgIGNvbnN0IG91dHB1dFNhbXBsZXMgPSBbXTtcbiAgICBjb25zdCBuYlNhbXBsZXMgPSBpbnB1dFNhbXBsZXMubGVuZ3RoO1xuICAgIGNvbnN0IHB0c05vcm1hbGl6ZSA9IHRoaXMuX1BUU05vcm1hbGl6ZTtcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcblxuICAgIC8vIGlmIHBhcnNlZCBmcmFnbWVudCBpcyBjb250aWd1b3VzIHdpdGggbGFzdCBvbmUsIGxldCdzIHVzZSBsYXN0IERUUyB2YWx1ZSBhcyByZWZlcmVuY2VcbiAgICBsZXQgbmV4dEF2Y0R0cyA9IHRoaXMubmV4dEF2Y0R0cztcblxuICAgIGNvbnN0IGlzU2FmYXJpID0gdGhpcy5pc1NhZmFyaTtcblxuICAgIGlmIChuYlNhbXBsZXMgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTYWZhcmkgZG9lcyBub3QgbGlrZSBvdmVybGFwcGluZyBEVFMgb24gY29uc2VjdXRpdmUgZnJhZ21lbnRzLiBsZXQncyB1c2UgbmV4dEF2Y0R0cyB0byBvdmVyY29tZSB0aGlzIGlmIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmVcbiAgICBpZiAoaXNTYWZhcmkpIHtcbiAgICAgIC8vIGFsc28gY29uc2lkZXIgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFzIGJlaW5nIGNvbnRpZ3VvdXMgKGV2ZW4gaWYgYSBsZXZlbCBzd2l0Y2ggb2NjdXJzKSxcbiAgICAgIC8vIGZvciBzYWtlIG9mIGNsYXJpdHk6XG4gICAgICAvLyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXJlIGZyYWdzIHdpdGhcbiAgICAgIC8vICAtIGxlc3MgdGhhbiAxMDBtcyBnYXBzIGJldHdlZW4gbmV3IHRpbWUgb2Zmc2V0IChpZiBhY2N1cmF0ZSkgYW5kIG5leHQgZXhwZWN0ZWQgUFRTIE9SXG4gICAgICAvLyAgLSBsZXNzIHRoYW4gMjAwIG1zIFBUUyBnYXBzICh0aW1lU2NhbGUvNSlcbiAgICAgIGNvbnRpZ3VvdXMgfD0gKGlucHV0U2FtcGxlcy5sZW5ndGggJiYgbmV4dEF2Y0R0cyAmJlxuICAgICAgICAgICAgICAgICAgICAgKChhY2N1cmF0ZVRpbWVPZmZzZXQgJiYgTWF0aC5hYnModGltZU9mZnNldCAtIG5leHRBdmNEdHMgLyB0aW1lU2NhbGUpIDwgMC4xKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKChpbnB1dFNhbXBsZXNbMF0ucHRzIC0gbmV4dEF2Y0R0cyAtIGluaXRQVFMpKSA8IHRpbWVTY2FsZSAvIDUpXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29udGlndW91cykge1xuICAgICAgLy8gaWYgbm90IGNvbnRpZ3VvdXMsIGxldCdzIHVzZSB0YXJnZXQgdGltZU9mZnNldFxuICAgICAgbmV4dEF2Y0R0cyA9IHRpbWVPZmZzZXQgKiB0aW1lU2NhbGU7XG4gICAgfVxuXG4gICAgLy8gUFRTIGlzIGNvZGVkIG9uIDMzYml0cywgYW5kIGNhbiBsb29wIGZyb20gLTJeMzIgdG8gMl4zMlxuICAgIC8vIHB0c05vcm1hbGl6ZSB3aWxsIG1ha2UgUFRTL0RUUyB2YWx1ZSBtb25vdG9uaWMsIHdlIHVzZSBsYXN0IGtub3duIERUUyB2YWx1ZSBhcyByZWZlcmVuY2UgdmFsdWVcbiAgICBpbnB1dFNhbXBsZXMuZm9yRWFjaChmdW5jdGlvbiAoc2FtcGxlKSB7XG4gICAgICBzYW1wbGUucHRzID0gcHRzTm9ybWFsaXplKHNhbXBsZS5wdHMgLSBpbml0UFRTLCBuZXh0QXZjRHRzKTtcbiAgICAgIHNhbXBsZS5kdHMgPSBwdHNOb3JtYWxpemUoc2FtcGxlLmR0cyAtIGluaXRQVFMsIG5leHRBdmNEdHMpO1xuICAgIH0pO1xuXG4gICAgLy8gc29ydCB2aWRlbyBzYW1wbGVzIGJ5IERUUyB0aGVuIFBUUyB0aGVuIGRlbXV4IGlkIG9yZGVyXG4gICAgaW5wdXRTYW1wbGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGNvbnN0IGRlbHRhZHRzID0gYS5kdHMgLSBiLmR0cztcbiAgICAgIGNvbnN0IGRlbHRhcHRzID0gYS5wdHMgLSBiLnB0cztcbiAgICAgIHJldHVybiBkZWx0YWR0cyB8fCAoZGVsdGFwdHMgfHwgKGEuaWQgLSBiLmlkKSk7XG4gICAgfSk7XG5cbiAgICAvLyBoYW5kbGUgYnJva2VuIHN0cmVhbXMgd2l0aCBQVFMgPCBEVFMsIHRvbGVyYW5jZSB1cCAyMDBtcyAoMTgwMDAgaW4gOTBrSHogdGltZXNjYWxlKVxuICAgIGxldCBQVFNEVFNzaGlmdCA9IGlucHV0U2FtcGxlcy5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IE1hdGgubWF4KE1hdGgubWluKHByZXYsIGN1cnIucHRzIC0gY3Vyci5kdHMpLCAtMTgwMDApLCAwKTtcbiAgICBpZiAoUFRTRFRTc2hpZnQgPCAwKSB7XG4gICAgICBsb2dnZXIud2FybihgUFRTIDwgRFRTIGRldGVjdGVkIGluIHZpZGVvIHNhbXBsZXMsIHNoaWZ0aW5nIERUUyBieSAke01hdGgucm91bmQoUFRTRFRTc2hpZnQgLyA5MCl9IG1zIHRvIG92ZXJjb21lIHRoaXMgaXNzdWVgKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlucHV0U2FtcGxlc1tpXS5kdHMgKz0gUFRTRFRTc2hpZnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29tcHV0ZSBmaXJzdCBEVFMgYW5kIGxhc3QgRFRTLCBub3JtYWxpemUgdGhlbSBhZ2FpbnN0IHJlZmVyZW5jZSB2YWx1ZVxuICAgIGxldCBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbMF07XG4gICAgZmlyc3REVFMgPSBNYXRoLm1heChzYW1wbGUuZHRzLCAwKTtcbiAgICBmaXJzdFBUUyA9IE1hdGgubWF4KHNhbXBsZS5wdHMsIDApO1xuXG4gICAgLy8gY2hlY2sgdGltZXN0YW1wIGNvbnRpbnVpdHkgYWNjcm9zcyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgKHRoaXMgaXMgdG8gcmVtb3ZlIGludGVyLWZyYWdtZW50IGdhcC9ob2xlKVxuICAgIGxldCBkZWx0YSA9IE1hdGgucm91bmQoKGZpcnN0RFRTIC0gbmV4dEF2Y0R0cykgLyA5MCk7XG4gICAgLy8gaWYgZnJhZ21lbnQgYXJlIGNvbnRpZ3VvdXMsIGRldGVjdCBob2xlL292ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzXG4gICAgaWYgKGNvbnRpZ3VvdXMpIHtcbiAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICBpZiAoZGVsdGEgPiAxKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgQVZDOiR7ZGVsdGF9IG1zIGhvbGUgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWQsZmlsbGluZyBpdGApO1xuICAgICAgICB9IGVsc2UgaWYgKGRlbHRhIDwgLTEpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBBVkM6JHsoLWRlbHRhKX0gbXMgb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBob2xlL2dhcCA6IHNldCBEVFMgdG8gbmV4dCBleHBlY3RlZCBEVFNcbiAgICAgICAgZmlyc3REVFMgPSBuZXh0QXZjRHRzO1xuICAgICAgICBpbnB1dFNhbXBsZXNbMF0uZHRzID0gZmlyc3REVFM7XG4gICAgICAgIC8vIG9mZnNldCBQVFMgYXMgd2VsbCwgZW5zdXJlIHRoYXQgUFRTIGlzIHNtYWxsZXIgb3IgZXF1YWwgdGhhbiBuZXcgRFRTXG4gICAgICAgIGZpcnN0UFRTID0gTWF0aC5tYXgoZmlyc3RQVFMgLSBkZWx0YSwgbmV4dEF2Y0R0cyk7XG4gICAgICAgIGlucHV0U2FtcGxlc1swXS5wdHMgPSBmaXJzdFBUUztcbiAgICAgICAgbG9nZ2VyLmxvZyhgVmlkZW8vUFRTL0RUUyBhZGp1c3RlZDogJHtNYXRoLnJvdW5kKGZpcnN0UFRTIC8gOTApfS8ke01hdGgucm91bmQoZmlyc3REVFMgLyA5MCl9LGRlbHRhOiR7ZGVsdGF9IG1zYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29tcHV0ZSBsYXN0UFRTL2xhc3REVFNcbiAgICBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaW5wdXRTYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgIGxhc3REVFMgPSBNYXRoLm1heChzYW1wbGUuZHRzLCAwKTtcbiAgICBsYXN0UFRTID0gTWF0aC5tYXgoc2FtcGxlLnB0cywgMCwgbGFzdERUUyk7XG5cbiAgICAvLyBvbiBTYWZhcmkgbGV0J3Mgc2lnbmFsIHRoZSBzYW1lIHNhbXBsZSBkdXJhdGlvbiBmb3IgYWxsIHNhbXBsZXNcbiAgICAvLyBzYW1wbGUgZHVyYXRpb24gKGFzIGV4cGVjdGVkIGJ5IHRydW4gTVA0IGJveGVzKSwgc2hvdWxkIGJlIHRoZSBkZWx0YSBiZXR3ZWVuIHNhbXBsZSBEVFNcbiAgICAvLyBzZXQgdGhpcyBjb25zdGFudCBkdXJhdGlvbiBhcyBiZWluZyB0aGUgYXZnIGRlbHRhIGJldHdlZW4gY29uc2VjdXRpdmUgRFRTLlxuICAgIGlmIChpc1NhZmFyaSkge1xuICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBNYXRoLnJvdW5kKChsYXN0RFRTIC0gZmlyc3REVFMpIC8gKGlucHV0U2FtcGxlcy5sZW5ndGggLSAxKSk7XG4gICAgfVxuXG4gICAgbGV0IG5iTmFsdSA9IDAsIG5hbHVMZW4gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIC8vIGNvbXB1dGUgdG90YWwvYXZjIHNhbXBsZSBsZW5ndGggYW5kIG5iIG9mIE5BTCB1bml0c1xuICAgICAgbGV0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXSwgdW5pdHMgPSBzYW1wbGUudW5pdHMsIG5iVW5pdHMgPSB1bml0cy5sZW5ndGgsIHNhbXBsZUxlbiA9IDA7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5iVW5pdHM7IGorKykge1xuICAgICAgICBzYW1wbGVMZW4gKz0gdW5pdHNbal0uZGF0YS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIG5hbHVMZW4gKz0gc2FtcGxlTGVuO1xuICAgICAgbmJOYWx1ICs9IG5iVW5pdHM7XG4gICAgICBzYW1wbGUubGVuZ3RoID0gc2FtcGxlTGVuO1xuXG4gICAgICAvLyBub3JtYWxpemUgUFRTL0RUU1xuICAgICAgaWYgKGlzU2FmYXJpKSB7XG4gICAgICAgIC8vIHNhbXBsZSBEVFMgaXMgY29tcHV0ZWQgdXNpbmcgYSBjb25zdGFudCBkZWNvZGluZyBvZmZzZXQgKG1wNFNhbXBsZUR1cmF0aW9uKSBiZXR3ZWVuIHNhbXBsZXNcbiAgICAgICAgc2FtcGxlLmR0cyA9IGZpcnN0RFRTICsgaSAqIG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZW5zdXJlIHNhbXBsZSBtb25vdG9uaWMgRFRTXG4gICAgICAgIHNhbXBsZS5kdHMgPSBNYXRoLm1heChzYW1wbGUuZHRzLCBmaXJzdERUUyk7XG4gICAgICB9XG4gICAgICAvLyBlbnN1cmUgdGhhdCBjb21wdXRlZCB2YWx1ZSBpcyBncmVhdGVyIG9yIGVxdWFsIHRoYW4gc2FtcGxlIERUU1xuICAgICAgc2FtcGxlLnB0cyA9IE1hdGgubWF4KHNhbXBsZS5wdHMsIHNhbXBsZS5kdHMpO1xuICAgIH1cblxuICAgIC8qIGNvbmNhdGVuYXRlIHRoZSB2aWRlbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbXBkYXQgdHlwZSkgKi9cbiAgICBsZXQgbWRhdFNpemUgPSBuYWx1TGVuICsgKDQgKiBuYk5hbHUpICsgODtcbiAgICB0cnkge1xuICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1VWF9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SLCBmYXRhbDogZmFsc2UsIGJ5dGVzOiBtZGF0U2l6ZSwgcmVhc29uOiBgZmFpbCBhbGxvY2F0aW5nIHZpZGVvIG1kYXQgJHttZGF0U2l6ZX1gIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgdmlldy5zZXRVaW50MzIoMCwgbWRhdFNpemUpO1xuICAgIG1kYXQuc2V0KE1QNC50eXBlcy5tZGF0LCA0KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIGxldCBhdmNTYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV0sXG4gICAgICAgIGF2Y1NhbXBsZVVuaXRzID0gYXZjU2FtcGxlLnVuaXRzLFxuICAgICAgICBtcDRTYW1wbGVMZW5ndGggPSAwLFxuICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXQ7XG4gICAgICAvLyBjb252ZXJ0IE5BTFUgYml0c3RyZWFtIHRvIE1QNCBmb3JtYXQgKHByZXBlbmQgTkFMVSB3aXRoIHNpemUgZmllbGQpXG4gICAgICBmb3IgKGxldCBqID0gMCwgbmJVbml0cyA9IGF2Y1NhbXBsZVVuaXRzLmxlbmd0aDsgaiA8IG5iVW5pdHM7IGorKykge1xuICAgICAgICBsZXQgdW5pdCA9IGF2Y1NhbXBsZVVuaXRzW2pdLFxuICAgICAgICAgIHVuaXREYXRhID0gdW5pdC5kYXRhLFxuICAgICAgICAgIHVuaXREYXRhTGVuID0gdW5pdC5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgdW5pdERhdGFMZW4pO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgbWRhdC5zZXQodW5pdERhdGEsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSB1bml0RGF0YUxlbjtcbiAgICAgICAgbXA0U2FtcGxlTGVuZ3RoICs9IDQgKyB1bml0RGF0YUxlbjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1NhZmFyaSkge1xuICAgICAgICAvLyBleHBlY3RlZCBzYW1wbGUgZHVyYXRpb24gaXMgdGhlIERlY29kaW5nIFRpbWVzdGFtcCBkaWZmIG9mIGNvbnNlY3V0aXZlIHNhbXBsZXNcbiAgICAgICAgaWYgKGkgPCBuYlNhbXBsZXMgLSAxKSB7XG4gICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBpbnB1dFNhbXBsZXNbaSArIDFdLmR0cyAtIGF2Y1NhbXBsZS5kdHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgbGFzdEZyYW1lRHVyYXRpb24gPSBhdmNTYW1wbGUuZHRzIC0gaW5wdXRTYW1wbGVzW2kgPiAwID8gaSAtIDEgOiBpXS5kdHM7XG4gICAgICAgICAgaWYgKGNvbmZpZy5zdHJldGNoU2hvcnRWaWRlb1RyYWNrKSB7XG4gICAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzLCBhIHNlZ21lbnQncyBhdWRpbyB0cmFjayBkdXJhdGlvbiBtYXkgZXhjZWVkIHRoZSB2aWRlbyB0cmFjayBkdXJhdGlvbi5cbiAgICAgICAgICAgIC8vIFNpbmNlIHdlJ3ZlIGFscmVhZHkgcmVtdXhlZCBhdWRpbywgYW5kIHdlIGtub3cgaG93IGxvbmcgdGhlIGF1ZGlvIHRyYWNrIGlzLCB3ZSBsb29rIHRvXG4gICAgICAgICAgICAvLyBzZWUgaWYgdGhlIGRlbHRhIHRvIHRoZSBuZXh0IHNlZ21lbnQgaXMgbG9uZ2VyIHRoYW4gbWF4QnVmZmVySG9sZS5cbiAgICAgICAgICAgIC8vIElmIHNvLCBwbGF5YmFjayB3b3VsZCBwb3RlbnRpYWxseSBnZXQgc3R1Y2ssIHNvIHdlIGFydGlmaWNpYWxseSBpbmZsYXRlXG4gICAgICAgICAgICAvLyB0aGUgZHVyYXRpb24gb2YgdGhlIGxhc3QgZnJhbWUgdG8gbWluaW1pemUgYW55IHBvdGVudGlhbCBnYXAgYmV0d2VlbiBzZWdtZW50cy5cbiAgICAgICAgICAgIGxldCBtYXhCdWZmZXJIb2xlID0gY29uZmlnLm1heEJ1ZmZlckhvbGUsXG4gICAgICAgICAgICAgIGdhcFRvbGVyYW5jZSA9IE1hdGguZmxvb3IobWF4QnVmZmVySG9sZSAqIHRpbWVTY2FsZSksXG4gICAgICAgICAgICAgIGRlbHRhVG9GcmFtZUVuZCA9IChhdWRpb1RyYWNrTGVuZ3RoID8gZmlyc3RQVFMgKyBhdWRpb1RyYWNrTGVuZ3RoICogdGltZVNjYWxlIDogdGhpcy5uZXh0QXVkaW9QdHMpIC0gYXZjU2FtcGxlLnB0cztcbiAgICAgICAgICAgIGlmIChkZWx0YVRvRnJhbWVFbmQgPiBnYXBUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgLy8gV2Ugc3VidHJhY3QgbGFzdEZyYW1lRHVyYXRpb24gZnJvbSBkZWx0YVRvRnJhbWVFbmQgdG8gdHJ5IHRvIHByZXZlbnQgYW55IHZpZGVvXG4gICAgICAgICAgICAgIC8vIGZyYW1lIG92ZXJsYXAuIG1heEJ1ZmZlckhvbGUgc2hvdWxkIGJlID4+IGxhc3RGcmFtZUR1cmF0aW9uIGFueXdheS5cbiAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBkZWx0YVRvRnJhbWVFbmQgLSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgaWYgKG1wNFNhbXBsZUR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBJdCBpcyBhcHByb3hpbWF0ZWx5ICR7ZGVsdGFUb0ZyYW1lRW5kIC8gOTB9IG1zIHRvIHRoZSBuZXh0IHNlZ21lbnQ7IHVzaW5nIGR1cmF0aW9uICR7bXA0U2FtcGxlRHVyYXRpb24gLyA5MH0gbXMgZm9yIHRoZSBsYXN0IHZpZGVvIGZyYW1lLmApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gTWF0aC5yb3VuZChhdmNTYW1wbGUucHRzIC0gYXZjU2FtcGxlLmR0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb3NpdGlvblRpbWVPZmZzZXQgPSBNYXRoLm1heCgwLCBtcDRTYW1wbGVEdXJhdGlvbiAqIE1hdGgucm91bmQoKGF2Y1NhbXBsZS5wdHMgLSBhdmNTYW1wbGUuZHRzKSAvIG1wNFNhbXBsZUR1cmF0aW9uKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCdQVFMvRFRTL2luaXREVFMvbm9ybVBUUy9ub3JtRFRTL3JlbGF0aXZlIFBUUyA6ICR7YXZjU2FtcGxlLnB0c30vJHthdmNTYW1wbGUuZHRzfS8ke2luaXREVFN9LyR7cHRzbm9ybX0vJHtkdHNub3JtfS8keyhhdmNTYW1wbGUucHRzLzQyOTQ5NjcyOTYpLnRvRml4ZWQoMyl9Jyk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgYXZjU2FtcGxlLmR0czogJHthdmNTYW1wbGUuZHRzIC8gOTB9LCBhdmNTYW1wbGUucHRzOiAke2F2Y1NhbXBsZS5wdHMgLyA5MH0sIG1wNFNhbXBsZUR1cmF0aW9uOiAke21wNFNhbXBsZUR1cmF0aW9uIC8gOTB9YCwgYXZjU2FtcGxlKVxuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKHtcbiAgICAgICAgc2l6ZTogbXA0U2FtcGxlTGVuZ3RoLFxuICAgICAgICAvLyBjb25zdGFudCBkdXJhdGlvblxuICAgICAgICBkdXJhdGlvbjogbXA0U2FtcGxlRHVyYXRpb24sXG4gICAgICAgIGN0czogY29tcG9zaXRpb25UaW1lT2Zmc2V0LFxuICAgICAgICBmbGFnczoge1xuICAgICAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgICAgICBpc0RlcGVuZGVkT246IDAsXG4gICAgICAgICAgaGFzUmVkdW5kYW5jeTogMCxcbiAgICAgICAgICBkZWdyYWRQcmlvOiAwLFxuICAgICAgICAgIGRlcGVuZHNPbjogYXZjU2FtcGxlLmtleSA/IDIgOiAxLFxuICAgICAgICAgIGlzTm9uU3luYzogYXZjU2FtcGxlLmtleSA/IDAgOiAxXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBuZXh0IEFWQyBzYW1wbGUgRFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBEVFMgKyBsYXN0IHNhbXBsZSBkdXJhdGlvbiAoaW4gUEVTIHRpbWVzY2FsZSlcbiAgICB0aGlzLm5leHRBdmNEdHMgPSBsYXN0RFRTICsgbXA0U2FtcGxlRHVyYXRpb247XG4gICAgbGV0IGRyb3BwZWQgPSB0cmFjay5kcm9wcGVkO1xuICAgIHRyYWNrLmxlbiA9IDA7XG4gICAgdHJhY2submJOYWx1ID0gMDtcbiAgICB0cmFjay5kcm9wcGVkID0gMDtcbiAgICBpZiAob3V0cHV0U2FtcGxlcy5sZW5ndGggJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2Nocm9tZScpID4gLTEpIHtcbiAgICAgIGxldCBmbGFncyA9IG91dHB1dFNhbXBsZXNbMF0uZmxhZ3M7XG4gICAgICAvLyBjaHJvbWUgd29ya2Fyb3VuZCwgbWFyayBmaXJzdCBzYW1wbGUgYXMgYmVpbmcgYSBSYW5kb20gQWNjZXNzIFBvaW50IHRvIGF2b2lkIHNvdXJjZWJ1ZmZlciBhcHBlbmQgaXNzdWVcbiAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yMjk0MTJcbiAgICAgIGZsYWdzLmRlcGVuZHNPbiA9IDI7XG4gICAgICBmbGFncy5pc05vblN5bmMgPSAwO1xuICAgIH1cbiAgICB0cmFjay5zYW1wbGVzID0gb3V0cHV0U2FtcGxlcztcbiAgICBtb29mID0gTVA0Lm1vb2YodHJhY2suc2VxdWVuY2VOdW1iZXIrKywgZmlyc3REVFMsIHRyYWNrKTtcbiAgICB0cmFjay5zYW1wbGVzID0gW107XG5cbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgIGRhdGExOiBtb29mLFxuICAgICAgZGF0YTI6IG1kYXQsXG4gICAgICBzdGFydFBUUzogZmlyc3RQVFMgLyB0aW1lU2NhbGUsXG4gICAgICBlbmRQVFM6IChsYXN0UFRTICsgbXA0U2FtcGxlRHVyYXRpb24pIC8gdGltZVNjYWxlLFxuICAgICAgc3RhcnREVFM6IGZpcnN0RFRTIC8gdGltZVNjYWxlLFxuICAgICAgZW5kRFRTOiB0aGlzLm5leHRBdmNEdHMgLyB0aW1lU2NhbGUsXG4gICAgICB0eXBlOiAndmlkZW8nLFxuICAgICAgaGFzQXVkaW86IGZhbHNlLFxuICAgICAgaGFzVmlkZW86IHRydWUsXG4gICAgICBuYjogb3V0cHV0U2FtcGxlcy5sZW5ndGgsXG4gICAgICBkcm9wcGVkOiBkcm9wcGVkXG4gICAgfTtcbiAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcmVtdXhBdWRpbyAodHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIGNvbnN0IGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgbXA0dGltZVNjYWxlID0gdHJhY2sudGltZXNjYWxlO1xuICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gaW5wdXRUaW1lU2NhbGUgLyBtcDR0aW1lU2NhbGU7XG4gICAgY29uc3QgbXA0U2FtcGxlRHVyYXRpb24gPSB0cmFjay5pc0FBQyA/IDEwMjQgOiAxMTUyO1xuICAgIGNvbnN0IGlucHV0U2FtcGxlRHVyYXRpb24gPSBtcDRTYW1wbGVEdXJhdGlvbiAqIHNjYWxlRmFjdG9yO1xuICAgIGNvbnN0IHB0c05vcm1hbGl6ZSA9IHRoaXMuX1BUU05vcm1hbGl6ZTtcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICBjb25zdCByYXdNUEVHID0gIXRyYWNrLmlzQUFDICYmIHRoaXMudHlwZVN1cHBvcnRlZC5tcGVnO1xuXG4gICAgbGV0IG9mZnNldCxcbiAgICAgIG1wNFNhbXBsZSxcbiAgICAgIGZpbGxGcmFtZSxcbiAgICAgIG1kYXQsIG1vb2YsXG4gICAgICBmaXJzdFBUUywgbGFzdFBUUyxcbiAgICAgIGlucHV0U2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMsXG4gICAgICBvdXRwdXRTYW1wbGVzID0gW10sXG4gICAgICBuZXh0QXVkaW9QdHMgPSB0aGlzLm5leHRBdWRpb1B0cztcblxuICAgIC8vIGZvciBhdWRpbyBzYW1wbGVzLCBhbHNvIGNvbnNpZGVyIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcyBiZWluZyBjb250aWd1b3VzIChldmVuIGlmIGEgbGV2ZWwgc3dpdGNoIG9jY3VycyksXG4gICAgLy8gZm9yIHNha2Ugb2YgY2xhcml0eTpcbiAgICAvLyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXJlIGZyYWdzIHdpdGhcbiAgICAvLyAgLSBsZXNzIHRoYW4gMTAwbXMgZ2FwcyBiZXR3ZWVuIG5ldyB0aW1lIG9mZnNldCAoaWYgYWNjdXJhdGUpIGFuZCBuZXh0IGV4cGVjdGVkIFBUUyBPUlxuICAgIC8vICAtIGxlc3MgdGhhbiAyMCBhdWRpbyBmcmFtZXMgZGlzdGFuY2VcbiAgICAvLyBjb250aWd1b3VzIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGZyb20gc2FtZSBxdWFsaXR5IGxldmVsIChzYW1lIGxldmVsLCBuZXcgU04gPSBvbGQgU04gKyAxKVxuICAgIC8vIHRoaXMgaGVscHMgZW5zdXJpbmcgYXVkaW8gY29udGludWl0eVxuICAgIC8vIGFuZCB0aGlzIGFsc28gYXZvaWRzIGF1ZGlvIGdsaXRjaGVzL2N1dCB3aGVuIHN3aXRjaGluZyBxdWFsaXR5LCBvciByZXBvcnRpbmcgd3JvbmcgZHVyYXRpb24gb24gZmlyc3QgYXVkaW8gZnJhbWVcbiAgICBjb250aWd1b3VzIHw9IChpbnB1dFNhbXBsZXMubGVuZ3RoICYmIG5leHRBdWRpb1B0cyAmJlxuICAgICAgICAgICAgICAgICAgICgoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmIE1hdGguYWJzKHRpbWVPZmZzZXQgLSBuZXh0QXVkaW9QdHMgLyBpbnB1dFRpbWVTY2FsZSkgPCAwLjEpIHx8XG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKChpbnB1dFNhbXBsZXNbMF0ucHRzIC0gbmV4dEF1ZGlvUHRzIC0gaW5pdFBUUykpIDwgMjAgKiBpbnB1dFNhbXBsZUR1cmF0aW9uKVxuICAgICk7XG5cbiAgICAvLyBjb21wdXRlIG5vcm1hbGl6ZWQgUFRTXG4gICAgaW5wdXRTYW1wbGVzLmZvckVhY2goZnVuY3Rpb24gKHNhbXBsZSkge1xuICAgICAgc2FtcGxlLnB0cyA9IHNhbXBsZS5kdHMgPSBwdHNOb3JtYWxpemUoc2FtcGxlLnB0cyAtIGluaXRQVFMsIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZSk7XG4gICAgfSk7XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHNhbXBsZSB3aXRoIG5lZ2F0aXZlIFBUUyB0aGF0IGFyZSBub3QgcGxheWFibGUgYW55d2F5XG4gICAgLy8gaWYgd2UgZG9uJ3QgcmVtb3ZlIHRoZXNlIG5lZ2F0aXZlIHNhbXBsZXMsIHRoZXkgd2lsbCBzaGlmdCBhbGwgYXVkaW8gc2FtcGxlcyBmb3J3YXJkLlxuICAgIC8vIGxlYWRpbmcgdG8gYXVkaW8gb3ZlcmxhcCBiZXR3ZWVuIGN1cnJlbnQgLyBuZXh0IGZyYWdtZW50XG4gICAgaW5wdXRTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmZpbHRlcihmdW5jdGlvbiAoc2FtcGxlKSB7XG4gICAgICByZXR1cm4gc2FtcGxlLnB0cyA+PSAwO1xuICAgIH0pO1xuXG4gICAgLy8gaW4gY2FzZSBhbGwgc2FtcGxlcyBoYXZlIG5lZ2F0aXZlIFBUUywgYW5kIGhhdmUgYmVlbiBmaWx0ZXJlZCBvdXQsIHJldHVybiBub3dcbiAgICBpZiAoaW5wdXRTYW1wbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghY29udGlndW91cykge1xuICAgICAgaWYgKCFhY2N1cmF0ZVRpbWVPZmZzZXQpIHtcbiAgICAgICAgLy8gaWYgZnJhZyBhcmUgbW90IGNvbnRpZ3VvdXMgYW5kIGlmIHdlIGNhbnQgdHJ1c3QgdGltZSBvZmZzZXQsIGxldCdzIHVzZSBmaXJzdCBzYW1wbGUgUFRTIGFzIG5leHQgYXVkaW8gUFRTXG4gICAgICAgIG5leHRBdWRpb1B0cyA9IGlucHV0U2FtcGxlc1swXS5wdHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiB0aW1lT2Zmc2V0IGlzIGFjY3VyYXRlLCBsZXQncyB1c2UgaXQgYXMgcHJlZGljdGVkIG5leHQgYXVkaW8gUFRTXG4gICAgICAgIG5leHRBdWRpb1B0cyA9IHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgYXVkaW8gdHJhY2sgaXMgbWlzc2luZyBzYW1wbGVzLCB0aGUgZnJhbWVzIHNlZW0gdG8gZ2V0IFwibGVmdC1zaGlmdGVkXCIgd2l0aGluIHRoZVxuICAgIC8vIHJlc3VsdGluZyBtcDQgc2VnbWVudCwgY2F1c2luZyBzeW5jIGlzc3VlcyBhbmQgbGVhdmluZyBnYXBzIGF0IHRoZSBlbmQgb2YgdGhlIGF1ZGlvIHNlZ21lbnQuXG4gICAgLy8gSW4gYW4gZWZmb3J0IHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZywgd2UgaW5qZWN0IGZyYW1lcyBoZXJlIHdoZXJlIHRoZXJlIGFyZSBnYXBzLlxuICAgIC8vIFdoZW4gcG9zc2libGUsIHdlIGluamVjdCBhIHNpbGVudCBmcmFtZTsgd2hlbiB0aGF0J3Mgbm90IHBvc3NpYmxlLCB3ZSBkdXBsaWNhdGUgdGhlIGxhc3RcbiAgICAvLyBmcmFtZS5cblxuICAgIGlmICh0cmFjay5pc0FBQykge1xuICAgICAgY29uc3QgbWF4QXVkaW9GcmFtZXNEcmlmdCA9IHRoaXMuY29uZmlnLm1heEF1ZGlvRnJhbWVzRHJpZnQ7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbmV4dFB0cyA9IG5leHRBdWRpb1B0czsgaSA8IGlucHV0U2FtcGxlcy5sZW5ndGg7KSB7XG4gICAgICAgIC8vIEZpcnN0LCBsZXQncyBzZWUgaG93IGZhciBvZmYgdGhpcyBmcmFtZSBpcyBmcm9tIHdoZXJlIHdlIGV4cGVjdCBpdCB0byBiZVxuICAgICAgICB2YXIgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldLCBkZWx0YTtcbiAgICAgICAgbGV0IHB0cyA9IHNhbXBsZS5wdHM7XG4gICAgICAgIGRlbHRhID0gcHRzIC0gbmV4dFB0cztcblxuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IE1hdGguYWJzKDEwMDAgKiBkZWx0YSAvIGlucHV0VGltZVNjYWxlKTtcblxuICAgICAgICAvLyBJZiB3ZSdyZSBvdmVybGFwcGluZyBieSBtb3JlIHRoYW4gYSBkdXJhdGlvbiwgZHJvcCB0aGlzIHNhbXBsZVxuICAgICAgICBpZiAoZGVsdGEgPD0gLW1heEF1ZGlvRnJhbWVzRHJpZnQgKiBpbnB1dFNhbXBsZUR1cmF0aW9uKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYERyb3BwaW5nIDEgYXVkaW8gZnJhbWUgQCAkeyhuZXh0UHRzIC8gaW5wdXRUaW1lU2NhbGUpLnRvRml4ZWQoMyl9cyBkdWUgdG8gJHtNYXRoLnJvdW5kKGR1cmF0aW9uKX0gbXMgb3ZlcmxhcC5gKTtcbiAgICAgICAgICBpbnB1dFNhbXBsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIHRyYWNrLmxlbiAtPSBzYW1wbGUudW5pdC5sZW5ndGg7XG4gICAgICAgICAgLy8gRG9uJ3QgdG91Y2ggbmV4dFB0c05vcm0gb3IgaVxuICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYnJhY2Utc3R5bGVcblxuICAgICAgICAvLyBJbnNlcnQgbWlzc2luZyBmcmFtZXMgaWY6XG4gICAgICAgIC8vIDE6IFdlJ3JlIG1vcmUgdGhhbiBtYXhBdWRpb0ZyYW1lc0RyaWZ0IGZyYW1lIGF3YXlcbiAgICAgICAgLy8gMjogTm90IG1vcmUgdGhhbiBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OIGF3YXlcbiAgICAgICAgLy8gMzogY3VycmVudFRpbWUgKGFrYSBuZXh0UHRzTm9ybSkgaXMgbm90IDBcbiAgICAgICAgZWxzZSBpZiAoZGVsdGEgPj0gbWF4QXVkaW9GcmFtZXNEcmlmdCAqIGlucHV0U2FtcGxlRHVyYXRpb24gJiYgZHVyYXRpb24gPCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OICYmIG5leHRQdHMpIHtcbiAgICAgICAgICBsZXQgbWlzc2luZyA9IE1hdGgucm91bmQoZGVsdGEgLyBpbnB1dFNhbXBsZUR1cmF0aW9uKTtcbiAgICAgICAgICBsb2dnZXIud2FybihgSW5qZWN0aW5nICR7bWlzc2luZ30gYXVkaW8gZnJhbWUgQCAkeyhuZXh0UHRzIC8gaW5wdXRUaW1lU2NhbGUpLnRvRml4ZWQoMyl9cyBkdWUgdG8gJHtNYXRoLnJvdW5kKDEwMDAgKiBkZWx0YSAvIGlucHV0VGltZVNjYWxlKX0gbXMgZ2FwLmApO1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWlzc2luZzsgaisrKSB7XG4gICAgICAgICAgICBsZXQgbmV3U3RhbXAgPSBNYXRoLm1heChuZXh0UHRzLCAwKTtcbiAgICAgICAgICAgIGZpbGxGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLCB0cmFjay5jaGFubmVsQ291bnQpO1xuICAgICAgICAgICAgaWYgKCFmaWxsRnJhbWUpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyBsYXN0IGZyYW1lIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAgIGZpbGxGcmFtZSA9IHNhbXBsZS51bml0LnN1YmFycmF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dFNhbXBsZXMuc3BsaWNlKGksIDAsIHsgdW5pdDogZmlsbEZyYW1lLCBwdHM6IG5ld1N0YW1wLCBkdHM6IG5ld1N0YW1wIH0pO1xuICAgICAgICAgICAgdHJhY2subGVuICs9IGZpbGxGcmFtZS5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0UHRzICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQWRqdXN0IHNhbXBsZSB0byBuZXh0IGV4cGVjdGVkIHB0c1xuICAgICAgICAgIHNhbXBsZS5wdHMgPSBzYW1wbGUuZHRzID0gbmV4dFB0cztcbiAgICAgICAgICBuZXh0UHRzICs9IGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIGp1c3QgYWRqdXN0IHB0c1xuICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPiAoMC4xICogaW5wdXRTYW1wbGVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coYEludmFsaWQgZnJhbWUgZGVsdGEgJHtNYXRoLnJvdW5kKGRlbHRhICsgaW5wdXRTYW1wbGVEdXJhdGlvbil9IGF0IFBUUyAke01hdGgucm91bmQocHRzIC8gOTApfSAoc2hvdWxkIGJlICR7TWF0aC5yb3VuZChpbnB1dFNhbXBsZUR1cmF0aW9uKX0pLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzYW1wbGUucHRzID0gc2FtcGxlLmR0cyA9IG5leHRQdHM7XG4gICAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGogPSAwLCBuYlNhbXBsZXMgPSBpbnB1dFNhbXBsZXMubGVuZ3RoOyBqIDwgbmJTYW1wbGVzOyBqKyspIHtcbiAgICAgIGxldCBhdWRpb1NhbXBsZSA9IGlucHV0U2FtcGxlc1tqXTtcbiAgICAgIGxldCB1bml0ID0gYXVkaW9TYW1wbGUudW5pdDtcbiAgICAgIGxldCBwdHMgPSBhdWRpb1NhbXBsZS5wdHM7XG4gICAgICAvLyBsb2dnZXIubG9nKGBBdWRpby9QVFM6JHtNYXRoLnJvdW5kKHB0cy85MCl9YCk7XG4gICAgICAvLyBpZiBub3QgZmlyc3Qgc2FtcGxlXG4gICAgICBpZiAobGFzdFBUUyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1wNFNhbXBsZS5kdXJhdGlvbiA9IE1hdGgucm91bmQoKHB0cyAtIGxhc3RQVFMpIC8gc2NhbGVGYWN0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGRlbHRhID0gTWF0aC5yb3VuZCgxMDAwICogKHB0cyAtIG5leHRBdWRpb1B0cykgLyBpbnB1dFRpbWVTY2FsZSksXG4gICAgICAgICAgbnVtTWlzc2luZ0ZyYW1lcyA9IDA7XG4gICAgICAgIC8vIGlmIGZyYWdtZW50IGFyZSBjb250aWd1b3VzLCBkZXRlY3QgaG9sZS9vdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50c1xuICAgICAgICAvLyBjb250aWd1b3VzIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGZyb20gc2FtZSBxdWFsaXR5IGxldmVsIChzYW1lIGxldmVsLCBuZXcgU04gPSBvbGQgU04gKyAxKVxuICAgICAgICBpZiAoY29udGlndW91cyAmJiB0cmFjay5pc0FBQykge1xuICAgICAgICAgIC8vIGxvZyBkZWx0YVxuICAgICAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICAgICAgaWYgKGRlbHRhID4gMCAmJiBkZWx0YSA8IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04pIHtcbiAgICAgICAgICAgICAgbnVtTWlzc2luZ0ZyYW1lcyA9IE1hdGgucm91bmQoKHB0cyAtIG5leHRBdWRpb1B0cykgLyBpbnB1dFNhbXBsZUR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgJHtkZWx0YX0gbXMgaG9sZSBiZXR3ZWVuIEFBQyBzYW1wbGVzIGRldGVjdGVkLGZpbGxpbmcgaXRgKTtcbiAgICAgICAgICAgICAgaWYgKG51bU1pc3NpbmdGcmFtZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgZmlsbEZyYW1lID0gQUFDLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxsRnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgIGZpbGxGcmFtZSA9IHVuaXQuc3ViYXJyYXkoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cmFjay5sZW4gKz0gbnVtTWlzc2luZ0ZyYW1lcyAqIGZpbGxGcmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBmcmFtZSBvdmVybGFwLCBvdmVybGFwcGluZyBmb3IgbW9yZSB0aGFuIGhhbGYgYSBmcmFtZSBkdXJhaW9uXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlbHRhIDwgLTEyKSB7XG4gICAgICAgICAgICAgIC8vIGRyb3Agb3ZlcmxhcHBpbmcgYXVkaW8gZnJhbWVzLi4uIGJyb3dzZXIgd2lsbCBkZWFsIHdpdGggaXRcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgZHJvcCBvdmVybGFwcGluZyBBQUMgc2FtcGxlLCBleHBlY3RlZC9wYXJzZWQvZGVsdGE6JHsobmV4dEF1ZGlvUHRzIC8gaW5wdXRUaW1lU2NhbGUpLnRvRml4ZWQoMyl9cy8keyhwdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKX1zLyR7KC1kZWx0YSl9bXNgKTtcbiAgICAgICAgICAgICAgdHJhY2subGVuIC09IHVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgUFRTL0RUUyB0byBleHBlY3RlZCBQVFMvRFRTXG4gICAgICAgICAgICBwdHMgPSBuZXh0QXVkaW9QdHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiBvdXIgYXVkaW9TYW1wbGVzXG4gICAgICAgIGZpcnN0UFRTID0gcHRzO1xuICAgICAgICBpZiAodHJhY2subGVuID4gMCkge1xuICAgICAgICAgIC8qIGNvbmNhdGVuYXRlIHRoZSBhdWRpbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgICAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbWRhdCB0eXBlKSAqL1xuICAgICAgICAgIGxldCBtZGF0U2l6ZSA9IHJhd01QRUcgPyB0cmFjay5sZW4gOiB0cmFjay5sZW4gKyA4O1xuICAgICAgICAgIG9mZnNldCA9IHJhd01QRUcgPyAwIDogODtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5FUlJPUiwgeyB0eXBlOiBFcnJvclR5cGVzLk1VWF9FUlJPUiwgZGV0YWlsczogRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SLCBmYXRhbDogZmFsc2UsIGJ5dGVzOiBtZGF0U2l6ZSwgcmVhc29uOiBgZmFpbCBhbGxvY2F0aW5nIGF1ZGlvIG1kYXQgJHttZGF0U2l6ZX1gIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJhd01QRUcpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgbWRhdFNpemUpO1xuICAgICAgICAgICAgbWRhdC5zZXQoTVA0LnR5cGVzLm1kYXQsIDQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyBhdWRpbyBzYW1wbGVzXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTWlzc2luZ0ZyYW1lczsgaSsrKSB7XG4gICAgICAgICAgZmlsbEZyYW1lID0gQUFDLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG4gICAgICAgICAgaWYgKCFmaWxsRnJhbWUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBnZXQgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYzsgZHVwbGljYXRpbmcgdGhpcyBmcmFtZSBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgZmlsbEZyYW1lID0gdW5pdC5zdWJhcnJheSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZGF0LnNldChmaWxsRnJhbWUsIG9mZnNldCk7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZpbGxGcmFtZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIG1wNFNhbXBsZSA9IHtcbiAgICAgICAgICAgIHNpemU6IGZpbGxGcmFtZS5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgY3RzOiAwLFxuICAgICAgICAgICAgZHVyYXRpb246IDEwMjQsXG4gICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICBpc0xlYWRpbmc6IDAsXG4gICAgICAgICAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgICAgICAgICAgaGFzUmVkdW5kYW5jeTogMCxcbiAgICAgICAgICAgICAgZGVncmFkUHJpbzogMCxcbiAgICAgICAgICAgICAgZGVwZW5kc09uOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobXA0U2FtcGxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWRhdC5zZXQodW5pdCwgb2Zmc2V0KTtcbiAgICAgIGxldCB1bml0TGVuID0gdW5pdC5ieXRlTGVuZ3RoO1xuICAgICAgb2Zmc2V0ICs9IHVuaXRMZW47XG4gICAgICAvLyBjb25zb2xlLmxvZygnUFRTL0RUUy9pbml0RFRTL25vcm1QVFMvbm9ybURUUy9yZWxhdGl2ZSBQVFMgOiAke2F1ZGlvU2FtcGxlLnB0c30vJHthdWRpb1NhbXBsZS5kdHN9LyR7aW5pdERUU30vJHtwdHNub3JtfS8ke2R0c25vcm19LyR7KGF1ZGlvU2FtcGxlLnB0cy80Mjk0OTY3Mjk2KS50b0ZpeGVkKDMpfScpO1xuICAgICAgbXA0U2FtcGxlID0ge1xuICAgICAgICBzaXplOiB1bml0TGVuLFxuICAgICAgICBjdHM6IDAsXG4gICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICBmbGFnczoge1xuICAgICAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgICAgICBpc0RlcGVuZGVkT246IDAsXG4gICAgICAgICAgaGFzUmVkdW5kYW5jeTogMCxcbiAgICAgICAgICBkZWdyYWRQcmlvOiAwLFxuICAgICAgICAgIGRlcGVuZHNPbjogMVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG1wNFNhbXBsZSk7XG4gICAgICBsYXN0UFRTID0gcHRzO1xuICAgIH1cbiAgICBsZXQgbGFzdFNhbXBsZUR1cmF0aW9uID0gMDtcbiAgICBsZXQgbmJTYW1wbGVzID0gb3V0cHV0U2FtcGxlcy5sZW5ndGg7XG4gICAgLy8gc2V0IGxhc3Qgc2FtcGxlIGR1cmF0aW9uIGFzIGJlaW5nIGlkZW50aWNhbCB0byBwcmV2aW91cyBzYW1wbGVcbiAgICBpZiAobmJTYW1wbGVzID49IDIpIHtcbiAgICAgIGxhc3RTYW1wbGVEdXJhdGlvbiA9IG91dHB1dFNhbXBsZXNbbmJTYW1wbGVzIC0gMl0uZHVyYXRpb247XG4gICAgICBtcDRTYW1wbGUuZHVyYXRpb24gPSBsYXN0U2FtcGxlRHVyYXRpb247XG4gICAgfVxuICAgIGlmIChuYlNhbXBsZXMpIHtcbiAgICAgIC8vIG5leHQgYXVkaW8gc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZHVyYXRpb25cbiAgICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gbmV4dEF1ZGlvUHRzID0gbGFzdFBUUyArIHNjYWxlRmFjdG9yICogbGFzdFNhbXBsZUR1cmF0aW9uO1xuICAgICAgLy8gbG9nZ2VyLmxvZygnQXVkaW8vUFRTL1BUU2VuZDonICsgYXVkaW9TYW1wbGUucHRzLnRvRml4ZWQoMCkgKyAnLycgKyB0aGlzLm5leHRBYWNEdHMudG9GaXhlZCgwKSk7XG4gICAgICB0cmFjay5sZW4gPSAwO1xuICAgICAgdHJhY2suc2FtcGxlcyA9IG91dHB1dFNhbXBsZXM7XG4gICAgICBpZiAocmF3TVBFRykge1xuICAgICAgICBtb29mID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vb2YgPSBNUDQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdFBUUyAvIHNjYWxlRmFjdG9yLCB0cmFjayk7XG4gICAgICB9XG5cbiAgICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gZmlyc3RQVFMgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICAgIGNvbnN0IGVuZCA9IG5leHRBdWRpb1B0cyAvIGlucHV0VGltZVNjYWxlO1xuICAgICAgY29uc3QgYXVkaW9EYXRhID0ge1xuICAgICAgICBkYXRhMTogbW9vZixcbiAgICAgICAgZGF0YTI6IG1kYXQsXG4gICAgICAgIHN0YXJ0UFRTOiBzdGFydCxcbiAgICAgICAgZW5kUFRTOiBlbmQsXG4gICAgICAgIHN0YXJ0RFRTOiBzdGFydCxcbiAgICAgICAgZW5kRFRTOiBlbmQsXG4gICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgIGhhc0F1ZGlvOiB0cnVlLFxuICAgICAgICBoYXNWaWRlbzogZmFsc2UsXG4gICAgICAgIG5iOiBuYlNhbXBsZXNcbiAgICAgIH07XG4gICAgICB0aGlzLm9ic2VydmVyLnRyaWdnZXIoRXZlbnQuRlJBR19QQVJTSU5HX0RBVEEsIGF1ZGlvRGF0YSk7XG4gICAgICByZXR1cm4gYXVkaW9EYXRhO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJlbXV4RW1wdHlBdWRpbyAodHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIHZpZGVvRGF0YSkge1xuICAgIGxldCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlLFxuICAgICAgbXA0dGltZVNjYWxlID0gdHJhY2suc2FtcGxlcmF0ZSA/IHRyYWNrLnNhbXBsZXJhdGUgOiBpbnB1dFRpbWVTY2FsZSxcbiAgICAgIHNjYWxlRmFjdG9yID0gaW5wdXRUaW1lU2NhbGUgLyBtcDR0aW1lU2NhbGUsXG4gICAgICBuZXh0QXVkaW9QdHMgPSB0aGlzLm5leHRBdWRpb1B0cyxcblxuICAgICAgLy8gc3luYyB3aXRoIHZpZGVvJ3MgdGltZXN0YW1wXG4gICAgICBzdGFydERUUyA9IChuZXh0QXVkaW9QdHMgIT09IHVuZGVmaW5lZCA/IG5leHRBdWRpb1B0cyA6IHZpZGVvRGF0YS5zdGFydERUUyAqIGlucHV0VGltZVNjYWxlKSArIHRoaXMuX2luaXREVFMsXG4gICAgICBlbmREVFMgPSB2aWRlb0RhdGEuZW5kRFRTICogaW5wdXRUaW1lU2NhbGUgKyB0aGlzLl9pbml0RFRTLFxuICAgICAgLy8gb25lIHNhbXBsZSdzIGR1cmF0aW9uIHZhbHVlXG4gICAgICBzYW1wbGVEdXJhdGlvbiA9IDEwMjQsXG4gICAgICBmcmFtZUR1cmF0aW9uID0gc2NhbGVGYWN0b3IgKiBzYW1wbGVEdXJhdGlvbixcblxuICAgICAgLy8gc2FtcGxlcyBjb3VudCBvZiB0aGlzIHNlZ21lbnQncyBkdXJhdGlvblxuICAgICAgbmJTYW1wbGVzID0gTWF0aC5jZWlsKChlbmREVFMgLSBzdGFydERUUykgLyBmcmFtZUR1cmF0aW9uKSxcblxuICAgICAgLy8gc2lsZW50IGZyYW1lXG4gICAgICBzaWxlbnRGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLCB0cmFjay5jaGFubmVsQ291bnQpO1xuXG4gICAgbG9nZ2VyLndhcm4oJ3JlbXV4IGVtcHR5IEF1ZGlvJyk7XG4gICAgLy8gQ2FuJ3QgcmVtdXggaWYgd2UgY2FuJ3QgZ2VuZXJhdGUgYSBzaWxlbnQgZnJhbWUuLi5cbiAgICBpZiAoIXNpbGVudEZyYW1lKSB7XG4gICAgICBsb2dnZXIudHJhY2UoJ1VuYWJsZSB0byByZW11eEVtcHR5QXVkaW8gc2luY2Ugd2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGEgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYyEnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgc2FtcGxlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIGxldCBzdGFtcCA9IHN0YXJ0RFRTICsgaSAqIGZyYW1lRHVyYXRpb247XG4gICAgICBzYW1wbGVzLnB1c2goeyB1bml0OiBzaWxlbnRGcmFtZSwgcHRzOiBzdGFtcCwgZHRzOiBzdGFtcCB9KTtcbiAgICAgIHRyYWNrLmxlbiArPSBzaWxlbnRGcmFtZS5sZW5ndGg7XG4gICAgfVxuICAgIHRyYWNrLnNhbXBsZXMgPSBzYW1wbGVzO1xuXG4gICAgdGhpcy5yZW11eEF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzKTtcbiAgfVxuXG4gIHJlbXV4SUQzICh0cmFjaykge1xuICAgIGxldCBsZW5ndGggPSB0cmFjay5zYW1wbGVzLmxlbmd0aCwgc2FtcGxlO1xuICAgIGNvbnN0IGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG4gICAgY29uc3QgaW5pdERUUyA9IHRoaXMuX2luaXREVFM7XG4gICAgLy8gY29uc3VtZSBzYW1wbGVzXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcbiAgICAgICAgLy8gc2V0dGluZyBpZDMgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxuICAgICAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG4gICAgICAgIHNhbXBsZS5wdHMgPSAoKHNhbXBsZS5wdHMgLSBpbml0UFRTKSAvIGlucHV0VGltZVNjYWxlKTtcbiAgICAgICAgc2FtcGxlLmR0cyA9ICgoc2FtcGxlLmR0cyAtIGluaXREVFMpIC8gaW5wdXRUaW1lU2NhbGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5vYnNlcnZlci50cmlnZ2VyKEV2ZW50LkZSQUdfUEFSU0lOR19NRVRBREFUQSwge1xuICAgICAgICBzYW1wbGVzOiB0cmFjay5zYW1wbGVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gIH1cblxuICByZW11eFRleHQgKHRyYWNrKSB7XG4gICAgdHJhY2suc2FtcGxlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gKGEucHRzIC0gYi5wdHMpO1xuICAgIH0pO1xuXG4gICAgbGV0IGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoLCBzYW1wbGU7XG4gICAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICAvLyBjb25zdW1lIHNhbXBsZXNcbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xuICAgICAgICAvLyBzZXR0aW5nIHRleHQgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxuICAgICAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG4gICAgICAgIHNhbXBsZS5wdHMgPSAoKHNhbXBsZS5wdHMgLSBpbml0UFRTKSAvIGlucHV0VGltZVNjYWxlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIHtcbiAgICAgICAgc2FtcGxlczogdHJhY2suc2FtcGxlc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICB9XG5cbiAgX1BUU05vcm1hbGl6ZSAodmFsdWUsIHJlZmVyZW5jZSkge1xuICAgIGxldCBvZmZzZXQ7XG4gICAgaWYgKHJlZmVyZW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHJlZmVyZW5jZSA8IHZhbHVlKSB7XG4gICAgICAvLyAtIDJeMzNcbiAgICAgIG9mZnNldCA9IC04NTg5OTM0NTkyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyArIDJeMzNcbiAgICAgIG9mZnNldCA9IDg1ODk5MzQ1OTI7XG4gICAgfVxuICAgIC8qIFBUUyBpcyAzM2JpdCAoZnJvbSAwIHRvIDJeMzMgLTEpXG4gICAgICBpZiBkaWZmIGJldHdlZW4gdmFsdWUgYW5kIHJlZmVyZW5jZSBpcyBiaWdnZXIgdGhhbiBoYWxmIG9mIHRoZSBhbXBsaXR1ZGUgKDJeMzIpIHRoZW4gaXQgbWVhbnMgdGhhdFxuICAgICAgUFRTIGxvb3Bpbmcgb2NjdXJlZC4gZmlsbCB0aGUgZ2FwICovXG4gICAgd2hpbGUgKE1hdGguYWJzKHZhbHVlIC0gcmVmZXJlbmNlKSA+IDQyOTQ5NjcyOTYpIHtcbiAgICAgIHZhbHVlICs9IG9mZnNldDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTVA0UmVtdXhlcjtcbiIsIi8qKlxuICogcGFzc3Rocm91Z2ggcmVtdXhlclxuKi9cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMnO1xuXG5jbGFzcyBQYXNzVGhyb3VnaFJlbXV4ZXIge1xuICBjb25zdHJ1Y3RvciAob2JzZXJ2ZXIpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgfVxuXG4gIHJlc2V0VGltZVN0YW1wICgpIHtcbiAgfVxuXG4gIHJlc2V0SW5pdFNlZ21lbnQgKCkge1xuICB9XG5cbiAgcmVtdXggKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgcmF3RGF0YSkge1xuICAgIGxldCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XG4gICAgbGV0IHN0cmVhbVR5cGUgPSAnJztcbiAgICBpZiAoYXVkaW9UcmFjaykge1xuICAgICAgc3RyZWFtVHlwZSArPSAnYXVkaW8nO1xuICAgIH1cblxuICAgIGlmICh2aWRlb1RyYWNrKSB7XG4gICAgICBzdHJlYW1UeXBlICs9ICd2aWRlbyc7XG4gICAgfVxuXG4gICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNJTkdfREFUQSwge1xuICAgICAgZGF0YTE6IHJhd0RhdGEsXG4gICAgICBzdGFydFBUUzogdGltZU9mZnNldCxcbiAgICAgIHN0YXJ0RFRTOiB0aW1lT2Zmc2V0LFxuICAgICAgdHlwZTogc3RyZWFtVHlwZSxcbiAgICAgIGhhc0F1ZGlvOiAhIWF1ZGlvVHJhY2ssXG4gICAgICBoYXNWaWRlbzogISF2aWRlb1RyYWNrLFxuICAgICAgbmI6IDEsXG4gICAgICBkcm9wcGVkOiAwXG4gICAgfSk7XG4gICAgLy8gbm90aWZ5IGVuZCBvZiBwYXJzaW5nXG4gICAgb2JzZXJ2ZXIudHJpZ2dlcihFdmVudC5GUkFHX1BBUlNFRCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFzc1Rocm91Z2hSZW11eGVyO1xuIiwiaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuL2V2ZW50LWhhbmRsZXInO1xuXG4vKipcbiAqIFN1Yi1jbGFzcyBzcGVjaWFsaXphdGlvbiBvZiBFdmVudEhhbmRsZXIgYmFzZSBjbGFzcy5cbiAqXG4gKiBUYXNrTG9vcCBhbGxvd3MgdG8gc2NoZWR1bGUgYSB0YXNrIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCAob3B0aW9ubmFseSByZXBlYXRlZGx5KSBvbiB0aGUgbWFpbiBsb29wLFxuICogc2NoZWR1bGVkIGFzeW5jaHJvbmVvdXNseSwgYXZvaWRpbmcgcmVjdXJzaXZlIGNhbGxzIGluIHRoZSBzYW1lIHRpY2suXG4gKlxuICogVGhlIHRhc2sgaXRzZWxmIGlzIGltcGxlbWVudGVkIGluIGBkb1RpY2tgLiBJdCBjYW4gYmUgcmVxdWVzdGVkIGFuZCBjYWxsZWQgZm9yIHNpbmdsZSBleGVjdXRpb25cbiAqIHVzaW5nIHRoZSBgdGlja2AgbWV0aG9kLlxuICpcbiAqIEl0IHdpbGwgYmUgYXNzdXJlZCB0aGF0IHRoZSB0YXNrIGV4ZWN1dGlvbiBtZXRob2QgKGB0aWNrYCkgb25seSBnZXRzIGNhbGxlZCBvbmNlIHBlciBtYWluIGxvb3AgXCJ0aWNrXCIsXG4gKiBubyBtYXR0ZXIgaG93IG9mdGVuIGl0IGdldHMgcmVxdWVzdGVkIGZvciBleGVjdXRpb24uIEV4ZWN1dGlvbiBpbiBmdXJ0aGVyIHRpY2tzIHdpbGwgYmUgc2NoZWR1bGVkIGFjY29yZGluZ2x5LlxuICpcbiAqIElmIGZ1cnRoZXIgZXhlY3V0aW9uIHJlcXVlc3RzIGhhdmUgYWxyZWFkeSBiZWVuIHNjaGVkdWxlZCBvbiB0aGUgbmV4dCB0aWNrLCBpdCBjYW4gYmUgY2hlY2tlZCB3aXRoIGBoYXNOZXh0VGlja2AsXG4gKiBhbmQgY2FuY2VsbGVkIHdpdGggYGNsZWFyTmV4dFRpY2tgLlxuICpcbiAqIFRoZSB0YXNrIGNhbiBiZSBzY2hlZHVsZWQgYXMgYW4gaW50ZXJ2YWwgcmVwZWF0ZWRseSB3aXRoIGEgcGVyaW9kIGFzIHBhcmFtZXRlciAoc2VlIGBzZXRJbnRlcnZhbGAsIGBjbGVhckludGVydmFsYCkuXG4gKlxuICogU3ViLWNsYXNzZXMgbmVlZCB0byBpbXBsZW1lbnQgdGhlIGBkb1RpY2tgIG1ldGhvZCB3aGljaCB3aWxsIGVmZmVjdGl2ZWx5IGhhdmUgdGhlIHRhc2sgZXhlY3V0aW9uIHJvdXRpbmUuXG4gKlxuICogRnVydGhlciBleHBsYW5hdGlvbnM6XG4gKlxuICogVGhlIGJhc2VjbGFzcyBoYXMgYSBgdGlja2AgbWV0aG9kIHRoYXQgd2lsbCBzY2hlZHVsZSB0aGUgZG9UaWNrIGNhbGwuIEl0IG1heSBiZSBjYWxsZWQgc3luY2hyb25lb3VzbHlcbiAqIG9ubHkgZm9yIGEgc3RhY2stZGVwdGggb2Ygb25lLiBPbiByZS1lbnRyYW50IGNhbGxzLCBzdWItc2VxdWVudCBjYWxscyBhcmUgc2NoZWR1bGVkIGZvciBuZXh0IG1haW4gbG9vcCB0aWNrcy5cbiAqXG4gKiBXaGVuIHRoZSB0YXNrIGV4ZWN1dGlvbiAoYHRpY2tgIG1ldGhvZCkgaXMgY2FsbGVkIGluIHJlLWVudHJhbnQgd2F5IHRoaXMgaXMgZGV0ZWN0ZWQgYW5kXG4gKiB3ZSBhcmUgbGltaXRpbmcgdGhlIHRhc2sgZXhlY3V0aW9uIHBlciBjYWxsIHN0YWNrIHRvIGV4YWN0bHkgb25lLCBidXQgc2NoZWR1bGluZy9wb3N0LXBvbmluZyBmdXJ0aGVyXG4gKiB0YXNrIHByb2Nlc3Npbmcgb24gdGhlIG5leHQgbWFpbiBsb29wIGl0ZXJhdGlvbiAoYWxzbyBrbm93biBhcyBcIm5leHQgdGlja1wiIGluIHRoZSBOb2RlL0pTIHJ1bnRpbWUgbGluZ28pLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhc2tMb29wIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGhscywgLi4uZXZlbnRzKSB7XG4gICAgc3VwZXIoaGxzLCAuLi5ldmVudHMpO1xuXG4gICAgdGhpcy5fdGlja0ludGVydmFsID0gbnVsbDtcbiAgICB0aGlzLl90aWNrVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgIHRoaXMuX2JvdW5kVGljayA9IHRoaXMudGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgb25IYW5kbGVyRGVzdHJveWluZyAoKSB7XG4gICAgLy8gY2xlYXIgYWxsIHRpbWVycyBiZWZvcmUgdW5yZWdpc3RlcmluZyBmcm9tIGV2ZW50IGJ1c1xuICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaGFzSW50ZXJ2YWwgKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3RpY2tJbnRlcnZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc05leHRUaWNrICgpIHtcbiAgICByZXR1cm4gISF0aGlzLl90aWNrVGltZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbGxpcyBJbnRlcnZhbCB0aW1lIChtcylcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgd2hlbiBpbnRlcnZhbCBoYXMgYmVlbiBzY2hlZHVsZWQsIGZhbHNlIHdoZW4gYWxyZWFkeSBzY2hlZHVsZWQgKG5vIGVmZmVjdClcbiAgICovXG4gIHNldEludGVydmFsIChtaWxsaXMpIHtcbiAgICBpZiAoIXRoaXMuX3RpY2tJbnRlcnZhbCkge1xuICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gc2V0SW50ZXJ2YWwodGhpcy5fYm91bmRUaWNrLCBtaWxsaXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIGludGVydmFsIHdhcyBjbGVhcmVkLCBmYWxzZSB3aGVuIG5vbmUgd2FzIHNldCAobm8gZWZmZWN0KVxuICAgKi9cbiAgY2xlYXJJbnRlcnZhbCAoKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl90aWNrSW50ZXJ2YWwpO1xuICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gbnVsbDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgd2hlbiB0aW1lb3V0IHdhcyBjbGVhcmVkLCBmYWxzZSB3aGVuIG5vbmUgd2FzIHNldCAobm8gZWZmZWN0KVxuICAgKi9cbiAgY2xlYXJOZXh0VGljayAoKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpY2tUaW1lcik7XG4gICAgICB0aGlzLl90aWNrVGltZXIgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIGNhbGwgdGhlIHN1YmNsYXNzIGRvVGljayBpbXBsZW1lbnRhdGlvbiBpbiB0aGlzIG1haW4gbG9vcCB0aWNrXG4gICAqIG9yIGluIHRoZSBuZXh0IG9uZSAodmlhIHNldFRpbWVvdXQoLDApKSBpbiBjYXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkXG4gICAqIGluIHRoaXMgdGljayAoaW4gY2FzZSB0aGlzIGlzIGEgcmUtZW50cmFudCBjYWxsKS5cbiAgICovXG4gIHRpY2sgKCkge1xuICAgIHRoaXMuX3RpY2tDYWxsQ291bnQrKztcbiAgICBpZiAodGhpcy5fdGlja0NhbGxDb3VudCA9PT0gMSkge1xuICAgICAgdGhpcy5kb1RpY2soKTtcbiAgICAgIC8vIHJlLWVudHJhbnQgY2FsbCB0byB0aWNrIGZyb20gcHJldmlvdXMgZG9UaWNrIGNhbGwgc3RhY2tcbiAgICAgIC8vIC0+IHNjaGVkdWxlIGEgY2FsbCBvbiB0aGUgbmV4dCBtYWluIGxvb3AgaXRlcmF0aW9uIHRvIHByb2Nlc3MgdGhpcyB0YXNrIHByb2Nlc3NpbmcgcmVxdWVzdFxuICAgICAgaWYgKHRoaXMuX3RpY2tDYWxsQ291bnQgPiAxKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBvbmx5IG9uZSB0aW1lciBleGlzdHMgYXQgYW55IHRpbWUgYXQgbWF4XG4gICAgICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgICAgICB0aGlzLl90aWNrVGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuX2JvdW5kVGljaywgMCk7XG4gICAgICB9XG4gICAgICB0aGlzLl90aWNrQ2FsbENvdW50ID0gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9yIHN1YmNsYXNzIHRvIGltcGxlbWVudCB0YXNrIGxvZ2ljXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZG9UaWNrICgpIHt9XG59XG4iLCJjb25zdCBERUNJTUFMX1JFU09MVVRJT05fUkVHRVggPSAvXihcXGQrKXgoXFxkKykkLzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuY29uc3QgQVRUUl9MSVNUX1JFR0VYID0gL1xccyooLis/KVxccyo9KCg/OlxcXCIuKj9cXFwiKXwuKj8pKD86LHwkKS9nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG5cbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20va2Fub25naWwvbm9kZS1tM3U4cGFyc2UvYmxvYi9tYXN0ZXIvYXR0cmxpc3QuanNcbmNsYXNzIEF0dHJMaXN0IHtcbiAgY29uc3RydWN0b3IgKGF0dHJzKSB7XG4gICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGF0dHJzID0gQXR0ckxpc3QucGFyc2VBdHRyTGlzdChhdHRycyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgYXR0ciBpbiBhdHRycykge1xuICAgICAgaWYgKGF0dHJzLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgIHRoaXNbYXR0cl0gPSBhdHRyc1thdHRyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWNpbWFsSW50ZWdlciAoYXR0ck5hbWUpIHtcbiAgICBjb25zdCBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxMCk7XG4gICAgaWYgKGludFZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50VmFsdWU7XG4gIH1cblxuICBoZXhhZGVjaW1hbEludGVnZXIgKGF0dHJOYW1lKSB7XG4gICAgaWYgKHRoaXNbYXR0ck5hbWVdKSB7XG4gICAgICBsZXQgc3RyaW5nVmFsdWUgPSAodGhpc1thdHRyTmFtZV0gfHwgJzB4Jykuc2xpY2UoMik7XG4gICAgICBzdHJpbmdWYWx1ZSA9ICgoc3RyaW5nVmFsdWUubGVuZ3RoICYgMSkgPyAnMCcgOiAnJykgKyBzdHJpbmdWYWx1ZTtcblxuICAgICAgY29uc3QgdmFsdWUgPSBuZXcgVWludDhBcnJheShzdHJpbmdWYWx1ZS5sZW5ndGggLyAyKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nVmFsdWUubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHZhbHVlW2ldID0gcGFyc2VJbnQoc3RyaW5nVmFsdWUuc2xpY2UoaSAqIDIsIGkgKiAyICsgMiksIDE2KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBoZXhhZGVjaW1hbEludGVnZXJBc051bWJlciAoYXR0ck5hbWUpIHtcbiAgICBjb25zdCBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxNik7XG4gICAgaWYgKGludFZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50VmFsdWU7XG4gIH1cblxuICBkZWNpbWFsRmxvYXRpbmdQb2ludCAoYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzW2F0dHJOYW1lXSk7XG4gIH1cblxuICBlbnVtZXJhdGVkU3RyaW5nIChhdHRyTmFtZSkge1xuICAgIHJldHVybiB0aGlzW2F0dHJOYW1lXTtcbiAgfVxuXG4gIGRlY2ltYWxSZXNvbHV0aW9uIChhdHRyTmFtZSkge1xuICAgIGNvbnN0IHJlcyA9IERFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWC5leGVjKHRoaXNbYXR0ck5hbWVdKTtcbiAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogcGFyc2VJbnQocmVzWzFdLCAxMCksXG4gICAgICBoZWlnaHQ6IHBhcnNlSW50KHJlc1syXSwgMTApXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZUF0dHJMaXN0IChpbnB1dCkge1xuICAgIGxldCBtYXRjaCwgYXR0cnMgPSB7fTtcbiAgICBBVFRSX0xJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoKG1hdGNoID0gQVRUUl9MSVNUX1JFR0VYLmV4ZWMoaW5wdXQpKSAhPT0gbnVsbCkge1xuICAgICAgbGV0IHZhbHVlID0gbWF0Y2hbMl0sIHF1b3RlID0gJ1wiJztcblxuICAgICAgaWYgKHZhbHVlLmluZGV4T2YocXVvdGUpID09PSAwICYmXG4gICAgICAgICAgdmFsdWUubGFzdEluZGV4T2YocXVvdGUpID09PSAodmFsdWUubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxLCAtMSk7XG4gICAgICB9XG5cbiAgICAgIGF0dHJzW21hdGNoWzFdXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnM7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXR0ckxpc3Q7XG4iLCJsZXQgQmluYXJ5U2VhcmNoID0ge1xuICAvKipcbiAgICAgKiBTZWFyY2hlcyBmb3IgYW4gaXRlbSBpbiBhbiBhcnJheSB3aGljaCBtYXRjaGVzIGEgY2VydGFpbiBjb25kaXRpb24uXG4gICAgICogVGhpcyByZXF1aXJlcyB0aGUgY29uZGl0aW9uIHRvIG9ubHkgbWF0Y2ggb25lIGl0ZW0gaW4gdGhlIGFycmF5LFxuICAgICAqIGFuZCBmb3IgdGhlIGFycmF5IHRvIGJlIG9yZGVyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyaXNvbkZ1bmN0aW9uXG4gICAgICogICAgICBDYWxsZWQgYW5kIHByb3ZpZGVkIGEgY2FuZGlkYXRlIGl0ZW0gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgICAqICAgICAgU2hvdWxkIHJldHVybjpcbiAgICAgKiAgICAgICAgICA+IC0xIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBsb2NhdGVkIGF0IGEgbG93ZXIgaW5kZXggdGhhbiB0aGUgcHJvdmlkZWQgaXRlbS5cbiAgICAgKiAgICAgICAgICA+IDEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBoaWdoZXIgaW5kZXggdGhhbiB0aGUgcHJvdmlkZWQgaXRlbS5cbiAgICAgKiAgICAgICAgICA+IDAgaWYgdGhlIGl0ZW0gaXMgdGhlIGl0ZW0geW91J3JlIGxvb2tpbmcgZm9yLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Kn0gVGhlIG9iamVjdCBpZiBpdCBpcyBmb3VuZCBvciBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgc2VhcmNoOiBmdW5jdGlvbiAobGlzdCwgY29tcGFyaXNvbkZ1bmN0aW9uKSB7XG4gICAgbGV0IG1pbkluZGV4ID0gMDtcbiAgICBsZXQgbWF4SW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRFbGVtZW50ID0gbnVsbDtcblxuICAgIHdoaWxlIChtaW5JbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgY3VycmVudEluZGV4ID0gKG1pbkluZGV4ICsgbWF4SW5kZXgpIC8gMiB8IDA7XG4gICAgICBjdXJyZW50RWxlbWVudCA9IGxpc3RbY3VycmVudEluZGV4XTtcblxuICAgICAgbGV0IGNvbXBhcmlzb25SZXN1bHQgPSBjb21wYXJpc29uRnVuY3Rpb24oY3VycmVudEVsZW1lbnQpO1xuICAgICAgaWYgKGNvbXBhcmlzb25SZXN1bHQgPiAwKSB7XG4gICAgICAgIG1pbkluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcbiAgICAgIH0gZWxzZSBpZiAoY29tcGFyaXNvblJlc3VsdCA8IDApIHtcbiAgICAgICAgbWF4SW5kZXggPSBjdXJyZW50SW5kZXggLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRFbGVtZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBCaW5hcnlTZWFyY2g7XG4iLCIvKipcbiAqIEBtb2R1bGUgQnVmZmVySGVscGVyXG4gKlxuICogUHJvdmlkaW5nIG1ldGhvZHMgZGVhbGluZyB3aXRoIGJ1ZmZlciBsZW5ndGggcmV0cmlldmFsIGZvciBleGFtcGxlLlxuICpcbiAqIEluIGdlbmVyYWwsIGEgaGVscGVyIGFyb3VuZCBIVE1MNSBNZWRpYUVsZW1lbnQgVGltZVJhbmdlcyBnYXRoZXJlZCBmcm9tIGBidWZmZXJlZGAgcHJvcGVydHkuXG4gKlxuICogQWxzbyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L2J1ZmZlcmVkXG4qL1xuXG5leHBvcnQgY2xhc3MgQnVmZmVySGVscGVyIHtcbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIGBtZWRpYWAncyBidWZmZXJlZCBpbmNsdWRlIGBwb3NpdGlvbmBcbiAgICogQHBhcmFtIHtIVE1MTWVkaWFFbGVtZW50fFNvdXJjZUJ1ZmZlcn0gbWVkaWFcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzQnVmZmVyZWQgKG1lZGlhLCBwb3NpdGlvbikge1xuICAgIHRyeSB7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgbGV0IGJ1ZmZlcmVkID0gbWVkaWEuYnVmZmVyZWQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocG9zaXRpb24gPj0gYnVmZmVyZWQuc3RhcnQoaSkgJiYgcG9zaXRpb24gPD0gYnVmZmVyZWQuZW5kKGkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gdGhpcyBpcyB0byBjYXRjaFxuICAgICAgLy8gSW52YWxpZFN0YXRlRXJyb3I6IEZhaWxlZCB0byByZWFkIHRoZSAnYnVmZmVyZWQnIHByb3BlcnR5IGZyb20gJ1NvdXJjZUJ1ZmZlcic6XG4gICAgICAvLyBUaGlzIFNvdXJjZUJ1ZmZlciBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhcmVudCBtZWRpYSBzb3VyY2VcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGJ1ZmZlckluZm8gKG1lZGlhLCBwb3MsIG1heEhvbGVEdXJhdGlvbikge1xuICAgIHRyeSB7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgbGV0IHZidWZmZXJlZCA9IG1lZGlhLmJ1ZmZlcmVkLCBidWZmZXJlZCA9IFtdLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYnVmZmVyZWQucHVzaCh7IHN0YXJ0OiB2YnVmZmVyZWQuc3RhcnQoaSksIGVuZDogdmJ1ZmZlcmVkLmVuZChpKSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkSW5mbyhidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyB0aGlzIGlzIHRvIGNhdGNoXG4gICAgICAvLyBJbnZhbGlkU3RhdGVFcnJvcjogRmFpbGVkIHRvIHJlYWQgdGhlICdidWZmZXJlZCcgcHJvcGVydHkgZnJvbSAnU291cmNlQnVmZmVyJzpcbiAgICAgIC8vIFRoaXMgU291cmNlQnVmZmVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IG1lZGlhIHNvdXJjZVxuICAgIH1cbiAgICByZXR1cm4geyBsZW46IDAsIHN0YXJ0OiBwb3MsIGVuZDogcG9zLCBuZXh0U3RhcnQ6IHVuZGVmaW5lZCB9O1xuICB9XG5cbiAgc3RhdGljIGJ1ZmZlcmVkSW5mbyAoYnVmZmVyZWQsIHBvcywgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgbGV0IGJ1ZmZlcmVkMiA9IFtdLFxuICAgICAgLy8gYnVmZmVyU3RhcnQgYW5kIGJ1ZmZlckVuZCBhcmUgYnVmZmVyIGJvdW5kYXJpZXMgYXJvdW5kIGN1cnJlbnQgdmlkZW8gcG9zaXRpb25cbiAgICAgIGJ1ZmZlckxlbiwgYnVmZmVyU3RhcnQsIGJ1ZmZlckVuZCwgYnVmZmVyU3RhcnROZXh0LCBpO1xuICAgIC8vIHNvcnQgb24gYnVmZmVyLnN0YXJ0L3NtYWxsZXIgZW5kIChJRSBkb2VzIG5vdCBhbHdheXMgcmV0dXJuIHNvcnRlZCBidWZmZXJlZCByYW5nZSlcbiAgICBidWZmZXJlZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBsZXQgZGlmZiA9IGEuc3RhcnQgLSBiLnN0YXJ0O1xuICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYi5lbmQgLSBhLmVuZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyB0aGVyZSBtaWdodCBiZSBzb21lIHNtYWxsIGhvbGVzIGJldHdlZW4gYnVmZmVyIHRpbWUgcmFuZ2VcbiAgICAvLyBjb25zaWRlciB0aGF0IGhvbGVzIHNtYWxsZXIgdGhhbiBtYXhIb2xlRHVyYXRpb24gYXJlIGlycmVsZXZhbnQgYW5kIGJ1aWxkIGFub3RoZXJcbiAgICAvLyBidWZmZXIgdGltZSByYW5nZSByZXByZXNlbnRhdGlvbnMgdGhhdCBkaXNjYXJkcyB0aG9zZSBob2xlc1xuICAgIGZvciAoaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGJ1ZjJsZW4gPSBidWZmZXJlZDIubGVuZ3RoO1xuICAgICAgaWYgKGJ1ZjJsZW4pIHtcbiAgICAgICAgbGV0IGJ1ZjJlbmQgPSBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZDtcbiAgICAgICAgLy8gaWYgc21hbGwgaG9sZSAodmFsdWUgYmV0d2VlbiAwIG9yIG1heEhvbGVEdXJhdGlvbiApIG9yIG92ZXJsYXBwaW5nIChuZWdhdGl2ZSlcbiAgICAgICAgaWYgKChidWZmZXJlZFtpXS5zdGFydCAtIGJ1ZjJlbmQpIDwgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICAgICAgLy8gbWVyZ2Ugb3ZlcmxhcHBpbmcgdGltZSByYW5nZXNcbiAgICAgICAgICAvLyB1cGRhdGUgbGFzdFJhbmdlLmVuZCBvbmx5IGlmIHNtYWxsZXIgdGhhbiBpdGVtLmVuZFxuICAgICAgICAgIC8vIGUuZy4gIFsgMSwgMTVdIHdpdGggIFsgMiw4XSA9PiBbIDEsMTVdIChubyBuZWVkIHRvIG1vZGlmeSBsYXN0UmFuZ2UuZW5kKVxuICAgICAgICAgIC8vIHdoZXJlYXMgWyAxLCA4XSB3aXRoICBbIDIsMTVdID0+IFsgMSwxNV0gKCBsYXN0UmFuZ2Ugc2hvdWxkIHN3aXRjaCBmcm9tIFsxLDhdIHRvIFsxLDE1XSlcbiAgICAgICAgICBpZiAoYnVmZmVyZWRbaV0uZW5kID4gYnVmMmVuZCkge1xuICAgICAgICAgICAgYnVmZmVyZWQyW2J1ZjJsZW4gLSAxXS5lbmQgPSBidWZmZXJlZFtpXS5lbmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGJpZyBob2xlXG4gICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmaXJzdCB2YWx1ZVxuICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGJ1ZmZlckxlbiA9IDAsIGJ1ZmZlclN0YXJ0ID0gYnVmZmVyRW5kID0gcG9zOyBpIDwgYnVmZmVyZWQyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc3RhcnQgPSBidWZmZXJlZDJbaV0uc3RhcnQsXG4gICAgICAgIGVuZCA9IGJ1ZmZlcmVkMltpXS5lbmQ7XG4gICAgICAvLyBsb2dnZXIubG9nKCdidWYgc3RhcnQvZW5kOicgKyBidWZmZXJlZC5zdGFydChpKSArICcvJyArIGJ1ZmZlcmVkLmVuZChpKSk7XG4gICAgICBpZiAoKHBvcyArIG1heEhvbGVEdXJhdGlvbikgPj0gc3RhcnQgJiYgcG9zIDwgZW5kKSB7XG4gICAgICAgIC8vIHBsYXkgcG9zaXRpb24gaXMgaW5zaWRlIHRoaXMgYnVmZmVyIFRpbWVSYW5nZSwgcmV0cmlldmUgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvbiBhbmQgYnVmZmVyIGxlbmd0aFxuICAgICAgICBidWZmZXJTdGFydCA9IHN0YXJ0O1xuICAgICAgICBidWZmZXJFbmQgPSBlbmQ7XG4gICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckVuZCAtIHBvcztcbiAgICAgIH0gZWxzZSBpZiAoKHBvcyArIG1heEhvbGVEdXJhdGlvbikgPCBzdGFydCkge1xuICAgICAgICBidWZmZXJTdGFydE5leHQgPSBzdGFydDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGxlbjogYnVmZmVyTGVuLCBzdGFydDogYnVmZmVyU3RhcnQsIGVuZDogYnVmZmVyRW5kLCBuZXh0U3RhcnQ6IGJ1ZmZlclN0YXJ0TmV4dCB9O1xuICB9XG59XG4iLCIvKipcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIHBvcnRlZCBmcm9tIHRoZSBkYXNoLmpzIHByb2plY3QgYXQ6XG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvYmxvYi9kZXZlbG9wbWVudC9leHRlcm5hbHMvY2VhNjA4LXBhcnNlci5qc1xuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2NvbW1pdC84MjY5YjI2YTc2MWUwODUzYmIyMWQ3ODc4MGVkOTQ1MTQ0ZWNkZDRkI2RpZmYtNzFiYzI5NWEyZDZiNmI3MDkzYTFkMzI5MGQ1M2E0YjJcbiAqXG4gKiBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IGFwcGVhcnMgYmVsb3c6XG4gKlxuICogVGhlIGNvcHlyaWdodCBpbiB0aGlzIHNvZnR3YXJlIGlzIGJlaW5nIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSBCU0QgTGljZW5zZSxcbiAqIGluY2x1ZGVkIGJlbG93LiBUaGlzIHNvZnR3YXJlIG1heSBiZSBzdWJqZWN0IHRvIG90aGVyIHRoaXJkIHBhcnR5IGFuZCBjb250cmlidXRvclxuICogcmlnaHRzLCBpbmNsdWRpbmcgcGF0ZW50IHJpZ2h0cywgYW5kIG5vIHN1Y2ggcmlnaHRzIGFyZSBncmFudGVkIHVuZGVyIHRoaXMgbGljZW5zZS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiwgREFTSCBJbmR1c3RyeSBGb3J1bS5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vclxuICogIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgMi4gTmVpdGhlciB0aGUgbmFtZSBvZiBEYXNoIEluZHVzdHJ5IEZvcnVtIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuICogIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIEFTIElTIEFORCBBTllcbiAqICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELlxuICogIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsXG4gKiAgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVFxuICogIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbiAqICBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiAgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuLyoqXG4gICAgICogIEV4Y2VwdGlvbnMgZnJvbSByZWd1bGFyIEFTQ0lJLiBDb2RlUG9pbnRzIGFyZSBtYXBwZWQgdG8gVVRGLTE2IGNvZGVzXG4gICAgICovXG5cbmxldCBzcGVjaWFsQ2VhNjA4Q2hhcnNDb2RlcyA9IHtcbiAgMHgyYTogMHhlMSwgLy8gbG93ZXJjYXNlIGEsIGFjdXRlIGFjY2VudFxuICAweDVjOiAweGU5LCAvLyBsb3dlcmNhc2UgZSwgYWN1dGUgYWNjZW50XG4gIDB4NWU6IDB4ZWQsIC8vIGxvd2VyY2FzZSBpLCBhY3V0ZSBhY2NlbnRcbiAgMHg1ZjogMHhmMywgLy8gbG93ZXJjYXNlIG8sIGFjdXRlIGFjY2VudFxuICAweDYwOiAweGZhLCAvLyBsb3dlcmNhc2UgdSwgYWN1dGUgYWNjZW50XG4gIDB4N2I6IDB4ZTcsIC8vIGxvd2VyY2FzZSBjIHdpdGggY2VkaWxsYVxuICAweDdjOiAweGY3LCAvLyBkaXZpc2lvbiBzeW1ib2xcbiAgMHg3ZDogMHhkMSwgLy8gdXBwZXJjYXNlIE4gdGlsZGVcbiAgMHg3ZTogMHhmMSwgLy8gbG93ZXJjYXNlIG4gdGlsZGVcbiAgMHg3ZjogMHgyNTg4LCAvLyBGdWxsIGJsb2NrXG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDE2IEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMSBBTkQgTE9XIEJFVFdFRU4gMHgzMCBBTkQgMHgzRlxuICAvLyBUSElTIE1FQU5TIFRIQVQgXFx4NTAgTVVTVCBCRSBBRERFRCBUTyBUSEUgVkFMVUVTXG4gIDB4ODA6IDB4YWUsIC8vIFJlZ2lzdGVyZWQgc3ltYm9sIChSKVxuICAweDgxOiAweGIwLCAvLyBkZWdyZWUgc2lnblxuICAweDgyOiAweGJkLCAvLyAxLzIgc3ltYm9sXG4gIDB4ODM6IDB4YmYsIC8vIEludmVydGVkIChvcGVuKSBxdWVzdGlvbiBtYXJrXG4gIDB4ODQ6IDB4MjEyMiwgLy8gVHJhZGVtYXJrIHN5bWJvbCAoVE0pXG4gIDB4ODU6IDB4YTIsIC8vIENlbnRzIHN5bWJvbFxuICAweDg2OiAweGEzLCAvLyBQb3VuZHMgc3RlcmxpbmdcbiAgMHg4NzogMHgyNjZhLCAvLyBNdXNpYyA4J3RoIG5vdGVcbiAgMHg4ODogMHhlMCwgLy8gbG93ZXJjYXNlIGEsIGdyYXZlIGFjY2VudFxuICAweDg5OiAweDIwLCAvLyB0cmFuc3BhcmVudCBzcGFjZSAocmVndWxhcilcbiAgMHg4YTogMHhlOCwgLy8gbG93ZXJjYXNlIGUsIGdyYXZlIGFjY2VudFxuICAweDhiOiAweGUyLCAvLyBsb3dlcmNhc2UgYSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4YzogMHhlYSwgLy8gbG93ZXJjYXNlIGUsIGNpcmN1bWZsZXggYWNjZW50XG4gIDB4OGQ6IDB4ZWUsIC8vIGxvd2VyY2FzZSBpLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhlOiAweGY0LCAvLyBsb3dlcmNhc2UgbywgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4ZjogMHhmYiwgLy8gbG93ZXJjYXNlIHUsIGNpcmN1bWZsZXggYWNjZW50XG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMiBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAweDkwOiAweGMxLCAvLyBjYXBpdGFsIGxldHRlciBBIHdpdGggYWN1dGVcbiAgMHg5MTogMHhjOSwgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGFjdXRlXG4gIDB4OTI6IDB4ZDMsIC8vIGNhcGl0YWwgbGV0dGVyIE8gd2l0aCBhY3V0ZVxuICAweDkzOiAweGRhLCAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggYWN1dGVcbiAgMHg5NDogMHhkYywgLy8gY2FwaXRhbCBsZXR0ZXIgVSB3aXRoIGRpYXJlc2lzXG4gIDB4OTU6IDB4ZmMsIC8vIGxvd2VyY2FzZSBsZXR0ZXIgVSB3aXRoIGRpYWVyZXNpc1xuICAweDk2OiAweDIwMTgsIC8vIG9wZW5pbmcgc2luZ2xlIHF1b3RlXG4gIDB4OTc6IDB4YTEsIC8vIGludmVydGVkIGV4Y2xhbWF0aW9uIG1hcmtcbiAgMHg5ODogMHgyYSwgLy8gYXN0ZXJpc2tcbiAgMHg5OTogMHgyMDE5LCAvLyBjbG9zaW5nIHNpbmdsZSBxdW90ZVxuICAweDlhOiAweDI1MDEsIC8vIGJveCBkcmF3aW5ncyBoZWF2eSBob3Jpem9udGFsXG4gIDB4OWI6IDB4YTksIC8vIGNvcHlyaWdodCBzaWduXG4gIDB4OWM6IDB4MjEyMCwgLy8gU2VydmljZSBtYXJrXG4gIDB4OWQ6IDB4MjAyMiwgLy8gKHJvdW5kKSBidWxsZXRcbiAgMHg5ZTogMHgyMDFjLCAvLyBMZWZ0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAweDlmOiAweDIwMWQsIC8vIFJpZ2h0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAweGEwOiAweGMwLCAvLyB1cHBlcmNhc2UgQSwgZ3JhdmUgYWNjZW50XG4gIDB4YTE6IDB4YzIsIC8vIHVwcGVyY2FzZSBBLCBjaXJjdW1mbGV4XG4gIDB4YTI6IDB4YzcsIC8vIHVwcGVyY2FzZSBDIHdpdGggY2VkaWxsYVxuICAweGEzOiAweGM4LCAvLyB1cHBlcmNhc2UgRSwgZ3JhdmUgYWNjZW50XG4gIDB4YTQ6IDB4Y2EsIC8vIHVwcGVyY2FzZSBFLCBjaXJjdW1mbGV4XG4gIDB4YTU6IDB4Y2IsIC8vIGNhcGl0YWwgbGV0dGVyIEUgd2l0aCBkaWFyZXNpc1xuICAweGE2OiAweGViLCAvLyBsb3dlcmNhc2UgbGV0dGVyIGUgd2l0aCBkaWFyZXNpc1xuICAweGE3OiAweGNlLCAvLyB1cHBlcmNhc2UgSSwgY2lyY3VtZmxleFxuICAweGE4OiAweGNmLCAvLyB1cHBlcmNhc2UgSSwgd2l0aCBkaWFyZXNpc1xuICAweGE5OiAweGVmLCAvLyBsb3dlcmNhc2UgaSwgd2l0aCBkaWFyZXNpc1xuICAweGFhOiAweGQ0LCAvLyB1cHBlcmNhc2UgTywgY2lyY3VtZmxleFxuICAweGFiOiAweGQ5LCAvLyB1cHBlcmNhc2UgVSwgZ3JhdmUgYWNjZW50XG4gIDB4YWM6IDB4ZjksIC8vIGxvd2VyY2FzZSB1LCBncmF2ZSBhY2NlbnRcbiAgMHhhZDogMHhkYiwgLy8gdXBwZXJjYXNlIFUsIGNpcmN1bWZsZXhcbiAgMHhhZTogMHhhYiwgLy8gbGVmdC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgMHhhZjogMHhiYiwgLy8gcmlnaHQtcG9pbnRpbmcgZG91YmxlIGFuZ2xlIHF1b3RhdGlvbiBtYXJrXG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMyBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAweGIwOiAweGMzLCAvLyBVcHBlcmNhc2UgQSwgdGlsZGVcbiAgMHhiMTogMHhlMywgLy8gTG93ZXJjYXNlIGEsIHRpbGRlXG4gIDB4YjI6IDB4Y2QsIC8vIFVwcGVyY2FzZSBJLCBhY3V0ZSBhY2NlbnRcbiAgMHhiMzogMHhjYywgLy8gVXBwZXJjYXNlIEksIGdyYXZlIGFjY2VudFxuICAweGI0OiAweGVjLCAvLyBMb3dlcmNhc2UgaSwgZ3JhdmUgYWNjZW50XG4gIDB4YjU6IDB4ZDIsIC8vIFVwcGVyY2FzZSBPLCBncmF2ZSBhY2NlbnRcbiAgMHhiNjogMHhmMiwgLy8gTG93ZXJjYXNlIG8sIGdyYXZlIGFjY2VudFxuICAweGI3OiAweGQ1LCAvLyBVcHBlcmNhc2UgTywgdGlsZGVcbiAgMHhiODogMHhmNSwgLy8gTG93ZXJjYXNlIG8sIHRpbGRlXG4gIDB4Yjk6IDB4N2IsIC8vIE9wZW4gY3VybHkgYnJhY2VcbiAgMHhiYTogMHg3ZCwgLy8gQ2xvc2luZyBjdXJseSBicmFjZVxuICAweGJiOiAweDVjLCAvLyBCYWNrc2xhc2hcbiAgMHhiYzogMHg1ZSwgLy8gQ2FyZXRcbiAgMHhiZDogMHg1ZiwgLy8gVW5kZXJzY29yZVxuICAweGJlOiAweDdjLCAvLyBQaXBlICh2ZXJ0aWNhbCBsaW5lKVxuICAweGJmOiAweDIyM2MsIC8vIFRpbGRlIG9wZXJhdG9yXG4gIDB4YzA6IDB4YzQsIC8vIFVwcGVyY2FzZSBBLCB1bWxhdXRcbiAgMHhjMTogMHhlNCwgLy8gTG93ZXJjYXNlIEEsIHVtbGF1dFxuICAweGMyOiAweGQ2LCAvLyBVcHBlcmNhc2UgTywgdW1sYXV0XG4gIDB4YzM6IDB4ZjYsIC8vIExvd2VyY2FzZSBvLCB1bWxhdXRcbiAgMHhjNDogMHhkZiwgLy8gRXNzemV0dCAoc2hhcnAgUylcbiAgMHhjNTogMHhhNSwgLy8gWWVuIHN5bWJvbFxuICAweGM2OiAweGE0LCAvLyBHZW5lcmljIGN1cnJlbmN5IHNpZ25cbiAgMHhjNzogMHgyNTAzLCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdmVydGljYWxcbiAgMHhjODogMHhjNSwgLy8gVXBwZXJjYXNlIEEsIHJpbmdcbiAgMHhjOTogMHhlNSwgLy8gTG93ZXJjYXNlIEEsIHJpbmdcbiAgMHhjYTogMHhkOCwgLy8gVXBwZXJjYXNlIE8sIHN0cm9rZVxuICAweGNiOiAweGY4LCAvLyBMb3dlcmNhc2Ugbywgc3Ryb2tcbiAgMHhjYzogMHgyNTBmLCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgcmlnaHRcbiAgMHhjZDogMHgyNTEzLCAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgbGVmdFxuICAweGNlOiAweDI1MTcsIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgcmlnaHRcbiAgMHhjZjogMHgyNTFiIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgbGVmdFxufTtcblxuLyoqXG4gKiBVdGlsc1xuICovXG5sZXQgZ2V0Q2hhckZvckJ5dGUgPSBmdW5jdGlvbiAoYnl0ZSkge1xuICBsZXQgY2hhckNvZGUgPSBieXRlO1xuICBpZiAoc3BlY2lhbENlYTYwOENoYXJzQ29kZXMuaGFzT3duUHJvcGVydHkoYnl0ZSkpIHtcbiAgICBjaGFyQ29kZSA9IHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzW2J5dGVdO1xuICB9XG5cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xufTtcblxubGV0IE5SX1JPV1MgPSAxNSxcbiAgTlJfQ09MUyA9IDEwMDtcbi8vIFRhYmxlcyB0byBsb29rIHVwIHJvdyBmcm9tIFBBQyBkYXRhXG5sZXQgcm93c0xvd0NoMSA9IHsgMHgxMTogMSwgMHgxMjogMywgMHgxNTogNSwgMHgxNjogNywgMHgxNzogOSwgMHgxMDogMTEsIDB4MTM6IDEyLCAweDE0OiAxNCB9O1xubGV0IHJvd3NIaWdoQ2gxID0geyAweDExOiAyLCAweDEyOiA0LCAweDE1OiA2LCAweDE2OiA4LCAweDE3OiAxMCwgMHgxMzogMTMsIDB4MTQ6IDE1IH07XG5sZXQgcm93c0xvd0NoMiA9IHsgMHgxOTogMSwgMHgxQTogMywgMHgxRDogNSwgMHgxRTogNywgMHgxRjogOSwgMHgxODogMTEsIDB4MUI6IDEyLCAweDFDOiAxNCB9O1xubGV0IHJvd3NIaWdoQ2gyID0geyAweDE5OiAyLCAweDFBOiA0LCAweDFEOiA2LCAweDFFOiA4LCAweDFGOiAxMCwgMHgxQjogMTMsIDB4MUM6IDE1IH07XG5cbmxldCBiYWNrZ3JvdW5kQ29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ2JsYWNrJywgJ3RyYW5zcGFyZW50J107XG5cbi8qKlxuICogU2ltcGxlIGxvZ2dlciBjbGFzcyB0byBiZSBhYmxlIHRvIHdyaXRlIHdpdGggdGltZS1zdGFtcHMgYW5kIGZpbHRlciBvbiBsZXZlbC5cbiAqL1xubGV0IGxvZ2dlciA9IHtcbiAgdmVyYm9zZUZpbHRlcjogeyAnREFUQSc6IDMsICdERUJVRyc6IDMsICdJTkZPJzogMiwgJ1dBUk5JTkcnOiAyLCAnVEVYVCc6IDEsICdFUlJPUic6IDAgfSxcbiAgdGltZTogbnVsbCxcbiAgdmVyYm9zZUxldmVsOiAwLCAvLyBPbmx5IHdyaXRlIGVycm9yc1xuICBzZXRUaW1lOiBmdW5jdGlvbiAobmV3VGltZSkge1xuICAgIHRoaXMudGltZSA9IG5ld1RpbWU7XG4gIH0sXG4gIGxvZzogZnVuY3Rpb24gKHNldmVyaXR5LCBtc2cpIHtcbiAgICBsZXQgbWluTGV2ZWwgPSB0aGlzLnZlcmJvc2VGaWx0ZXJbc2V2ZXJpdHldO1xuICAgIGlmICh0aGlzLnZlcmJvc2VMZXZlbCA+PSBtaW5MZXZlbCkge1xuICAgICAgLy8gY29uc29sZS5sb2codGhpcy50aW1lICsgJyBbJyArIHNldmVyaXR5ICsgJ10gJyArIG1zZyk7XG4gICAgfVxuICB9XG59O1xuXG5sZXQgbnVtQXJyYXlUb0hleEFycmF5ID0gZnVuY3Rpb24gKG51bUFycmF5KSB7XG4gIGxldCBoZXhBcnJheSA9IFtdO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgaGV4QXJyYXkucHVzaChudW1BcnJheVtqXS50b1N0cmluZygxNikpO1xuICB9XG5cbiAgcmV0dXJuIGhleEFycmF5O1xufTtcblxuY2xhc3MgUGVuU3RhdGUge1xuICBjb25zdHJ1Y3RvciAoZm9yZWdyb3VuZCwgdW5kZXJsaW5lLCBpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCkge1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IGZvcmVncm91bmQgfHwgJ3doaXRlJztcbiAgICB0aGlzLnVuZGVybGluZSA9IHVuZGVybGluZSB8fCBmYWxzZTtcbiAgICB0aGlzLml0YWxpY3MgPSBpdGFsaWNzIHx8IGZhbHNlO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IGJhY2tncm91bmQgfHwgJ2JsYWNrJztcbiAgICB0aGlzLmZsYXNoID0gZmxhc2ggfHwgZmFsc2U7XG4gIH1cblxuICByZXNldCAoKSB7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICB0aGlzLnVuZGVybGluZSA9IGZhbHNlO1xuICAgIHRoaXMuaXRhbGljcyA9IGZhbHNlO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9ICdibGFjayc7XG4gICAgdGhpcy5mbGFzaCA9IGZhbHNlO1xuICB9XG5cbiAgc2V0U3R5bGVzIChzdHlsZXMpIHtcbiAgICBsZXQgYXR0cmlicyA9IFsnZm9yZWdyb3VuZCcsICd1bmRlcmxpbmUnLCAnaXRhbGljcycsICdiYWNrZ3JvdW5kJywgJ2ZsYXNoJ107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc3R5bGUgPSBhdHRyaWJzW2ldO1xuICAgICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgdGhpc1tzdHlsZV0gPSBzdHlsZXNbc3R5bGVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlzRGVmYXVsdCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmZvcmVncm91bmQgPT09ICd3aGl0ZScgJiYgIXRoaXMudW5kZXJsaW5lICYmICF0aGlzLml0YWxpY3MgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tncm91bmQgPT09ICdibGFjaycgJiYgIXRoaXMuZmxhc2gpO1xuICB9XG5cbiAgZXF1YWxzIChvdGhlcikge1xuICAgIHJldHVybiAoKHRoaXMuZm9yZWdyb3VuZCA9PT0gb3RoZXIuZm9yZWdyb3VuZCkgJiZcbiAgICAgICAgICAgICAgICAgKHRoaXMudW5kZXJsaW5lID09PSBvdGhlci51bmRlcmxpbmUpICYmXG4gICAgICAgICAgICAgICAgICh0aGlzLml0YWxpY3MgPT09IG90aGVyLml0YWxpY3MpICYmXG4gICAgICAgICAgICAgICAgICh0aGlzLmJhY2tncm91bmQgPT09IG90aGVyLmJhY2tncm91bmQpICYmXG4gICAgICAgICAgICAgICAgICh0aGlzLmZsYXNoID09PSBvdGhlci5mbGFzaCkpO1xuICB9XG5cbiAgY29weSAobmV3UGVuU3RhdGUpIHtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBuZXdQZW5TdGF0ZS5mb3JlZ3JvdW5kO1xuICAgIHRoaXMudW5kZXJsaW5lID0gbmV3UGVuU3RhdGUudW5kZXJsaW5lO1xuICAgIHRoaXMuaXRhbGljcyA9IG5ld1BlblN0YXRlLml0YWxpY3M7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3UGVuU3RhdGUuYmFja2dyb3VuZDtcbiAgICB0aGlzLmZsYXNoID0gbmV3UGVuU3RhdGUuZmxhc2g7XG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuICgnY29sb3I9JyArIHRoaXMuZm9yZWdyb3VuZCArICcsIHVuZGVybGluZT0nICsgdGhpcy51bmRlcmxpbmUgKyAnLCBpdGFsaWNzPScgKyB0aGlzLml0YWxpY3MgK1xuICAgICAgICAgICAgJywgYmFja2dyb3VuZD0nICsgdGhpcy5iYWNrZ3JvdW5kICsgJywgZmxhc2g9JyArIHRoaXMuZmxhc2gpO1xuICB9XG59XG5cbi8qKlxuICogVW5pY29kZSBjaGFyYWN0ZXIgd2l0aCBzdHlsaW5nIGFuZCBiYWNrZ3JvdW5kLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFN0eWxlZFVuaWNvZGVDaGFyIHtcbiAgY29uc3RydWN0b3IgKHVjaGFyLCBmb3JlZ3JvdW5kLCB1bmRlcmxpbmUsIGl0YWxpY3MsIGJhY2tncm91bmQsIGZsYXNoKSB7XG4gICAgdGhpcy51Y2hhciA9IHVjaGFyIHx8ICcgJzsgLy8gdW5pY29kZSBjaGFyYWN0ZXJcbiAgICB0aGlzLnBlblN0YXRlID0gbmV3IFBlblN0YXRlKGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpO1xuICB9XG5cbiAgcmVzZXQgKCkge1xuICAgIHRoaXMudWNoYXIgPSAnICc7XG4gICAgdGhpcy5wZW5TdGF0ZS5yZXNldCgpO1xuICB9XG5cbiAgc2V0Q2hhciAodWNoYXIsIG5ld1BlblN0YXRlKSB7XG4gICAgdGhpcy51Y2hhciA9IHVjaGFyO1xuICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdQZW5TdGF0ZSk7XG4gIH1cblxuICBzZXRQZW5TdGF0ZSAobmV3UGVuU3RhdGUpIHtcbiAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3UGVuU3RhdGUpO1xuICB9XG5cbiAgZXF1YWxzIChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLnVjaGFyID09PSBvdGhlci51Y2hhciAmJiB0aGlzLnBlblN0YXRlLmVxdWFscyhvdGhlci5wZW5TdGF0ZSk7XG4gIH1cblxuICBjb3B5IChuZXdDaGFyKSB7XG4gICAgdGhpcy51Y2hhciA9IG5ld0NoYXIudWNoYXI7XG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld0NoYXIucGVuU3RhdGUpO1xuICB9XG5cbiAgaXNFbXB0eSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudWNoYXIgPT09ICcgJyAmJiB0aGlzLnBlblN0YXRlLmlzRGVmYXVsdCgpO1xuICB9XG59XG5cbi8qKlxuICogQ0VBLTYwOCByb3cgY29uc2lzdGluZyBvZiBOUl9DT0xTIGluc3RhbmNlcyBvZiBTdHlsZWRVbmljb2RlQ2hhci5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBSb3cge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5jaGFycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICB0aGlzLmNoYXJzLnB1c2gobmV3IFN0eWxlZFVuaWNvZGVDaGFyKCkpO1xuICAgIH1cblxuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmN1cnJQZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZSgpO1xuICB9XG5cbiAgZXF1YWxzIChvdGhlcikge1xuICAgIGxldCBlcXVhbCA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5jaGFyc1tpXS5lcXVhbHMob3RoZXIuY2hhcnNbaV0pKSB7XG4gICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXF1YWw7XG4gIH1cblxuICBjb3B5IChvdGhlcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICB0aGlzLmNoYXJzW2ldLmNvcHkob3RoZXIuY2hhcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGlzRW1wdHkgKCkge1xuICAgIGxldCBlbXB0eSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5jaGFyc1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbXB0eTtcbiAgfVxuXG4gIC8qKlxuICAgICAqICBTZXQgdGhlIGN1cnNvciB0byBhIHZhbGlkIGNvbHVtbi5cbiAgICAgKi9cbiAgc2V0Q3Vyc29yIChhYnNQb3MpIHtcbiAgICBpZiAodGhpcy5wb3MgIT09IGFic1Bvcykge1xuICAgICAgdGhpcy5wb3MgPSBhYnNQb3M7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucG9zIDwgMCkge1xuICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnTmVnYXRpdmUgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XG4gICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBvcyA+IE5SX0NPTFMpIHtcbiAgICAgIGxvZ2dlci5sb2coJ0VSUk9SJywgJ1RvbyBsYXJnZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgIHRoaXMucG9zID0gTlJfQ09MUztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICAgKiBNb3ZlIHRoZSBjdXJzb3IgcmVsYXRpdmUgdG8gY3VycmVudCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgbW92ZUN1cnNvciAocmVsUG9zKSB7XG4gICAgbGV0IG5ld1BvcyA9IHRoaXMucG9zICsgcmVsUG9zO1xuICAgIGlmIChyZWxQb3MgPiAxKSB7XG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5wb3MgKyAxOyBpIDwgbmV3UG9zICsgMTsgaSsrKSB7XG4gICAgICAgIHRoaXMuY2hhcnNbaV0uc2V0UGVuU3RhdGUodGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNldEN1cnNvcihuZXdQb3MpO1xuICB9XG5cbiAgLyoqXG4gICAgICogQmFja3NwYWNlLCBtb3ZlIG9uZSBzdGVwIGJhY2sgYW5kIGNsZWFyIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgYmFja1NwYWNlICgpIHtcbiAgICB0aGlzLm1vdmVDdXJzb3IoLTEpO1xuICAgIHRoaXMuY2hhcnNbdGhpcy5wb3NdLnNldENoYXIoJyAnLCB0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gIH1cblxuICBpbnNlcnRDaGFyIChieXRlKSB7XG4gICAgaWYgKGJ5dGUgPj0gMHg5MCkgeyAvLyBFeHRlbmRlZCBjaGFyXG4gICAgICB0aGlzLmJhY2tTcGFjZSgpO1xuICAgIH1cbiAgICBsZXQgY2hhciA9IGdldENoYXJGb3JCeXRlKGJ5dGUpO1xuICAgIGlmICh0aGlzLnBvcyA+PSBOUl9DT0xTKSB7XG4gICAgICBsb2dnZXIubG9nKCdFUlJPUicsICdDYW5ub3QgaW5zZXJ0ICcgKyBieXRlLnRvU3RyaW5nKDE2KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICgnICsgY2hhciArICcpIGF0IHBvc2l0aW9uICcgKyB0aGlzLnBvcyArICcuIFNraXBwaW5nIGl0IScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKGNoYXIsIHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICB0aGlzLm1vdmVDdXJzb3IoMSk7XG4gIH1cblxuICBjbGVhckZyb21Qb3MgKHN0YXJ0UG9zKSB7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gc3RhcnRQb3M7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIHRoaXMuY2hhcnNbaV0ucmVzZXQoKTtcbiAgICB9XG4gIH1cblxuICBjbGVhciAoKSB7XG4gICAgdGhpcy5jbGVhckZyb21Qb3MoMCk7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuY3VyclBlblN0YXRlLnJlc2V0KCk7XG4gIH1cblxuICBjbGVhclRvRW5kT2ZSb3cgKCkge1xuICAgIHRoaXMuY2xlYXJGcm9tUG9zKHRoaXMucG9zKTtcbiAgfVxuXG4gIGdldFRleHRTdHJpbmcgKCkge1xuICAgIGxldCBjaGFycyA9IFtdO1xuICAgIGxldCBlbXB0eSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIGxldCBjaGFyID0gdGhpcy5jaGFyc1tpXS51Y2hhcjtcbiAgICAgIGlmIChjaGFyICE9PSAnICcpIHtcbiAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY2hhcnMucHVzaChjaGFyKTtcbiAgICB9XG4gICAgaWYgKGVtcHR5KSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICB9XG4gIH1cblxuICBzZXRQZW5TdHlsZXMgKHN0eWxlcykge1xuICAgIHRoaXMuY3VyclBlblN0YXRlLnNldFN0eWxlcyhzdHlsZXMpO1xuICAgIGxldCBjdXJyQ2hhciA9IHRoaXMuY2hhcnNbdGhpcy5wb3NdO1xuICAgIGN1cnJDaGFyLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIEtlZXAgYSBDRUEtNjA4IHNjcmVlbiBvZiAzMngxNSBzdHlsZWQgY2hhcmFjdGVyc1xuICogQGNvbnN0cnVjdG9yXG4qL1xuY2xhc3MgQ2FwdGlvblNjcmVlbiB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLnJvd3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgdGhpcy5yb3dzLnB1c2gobmV3IFJvdygpKTtcbiAgICB9IC8vIE5vdGUgdGhhdCB3ZSB1c2UgemVyby1iYXNlZCBudW1iZXJpbmcgKDAtMTQpXG5cbiAgICB0aGlzLmN1cnJSb3cgPSBOUl9ST1dTIC0gMTtcbiAgICB0aGlzLm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgcmVzZXQgKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICB0aGlzLnJvd3NbaV0uY2xlYXIoKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJSb3cgPSBOUl9ST1dTIC0gMTtcbiAgfVxuXG4gIGVxdWFscyAob3RoZXIpIHtcbiAgICBsZXQgZXF1YWwgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMucm93c1tpXS5lcXVhbHMob3RoZXIucm93c1tpXSkpIHtcbiAgICAgICAgZXF1YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcXVhbDtcbiAgfVxuXG4gIGNvcHkgKG90aGVyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIHRoaXMucm93c1tpXS5jb3B5KG90aGVyLnJvd3NbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGlzRW1wdHkgKCkge1xuICAgIGxldCBlbXB0eSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5yb3dzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5O1xuICB9XG5cbiAgYmFja1NwYWNlICgpIHtcbiAgICBsZXQgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LmJhY2tTcGFjZSgpO1xuICB9XG5cbiAgY2xlYXJUb0VuZE9mUm93ICgpIHtcbiAgICBsZXQgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LmNsZWFyVG9FbmRPZlJvdygpO1xuICB9XG5cbiAgLyoqXG4gICAgICogSW5zZXJ0IGEgY2hhcmFjdGVyICh3aXRob3V0IHN0eWxpbmcpIGluIHRoZSBjdXJyZW50IHJvdy5cbiAgICAgKi9cbiAgaW5zZXJ0Q2hhciAoY2hhcikge1xuICAgIGxldCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuaW5zZXJ0Q2hhcihjaGFyKTtcbiAgfVxuXG4gIHNldFBlbiAoc3R5bGVzKSB7XG4gICAgbGV0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5zZXRQZW5TdHlsZXMoc3R5bGVzKTtcbiAgfVxuXG4gIG1vdmVDdXJzb3IgKHJlbFBvcykge1xuICAgIGxldCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cubW92ZUN1cnNvcihyZWxQb3MpO1xuICB9XG5cbiAgc2V0Q3Vyc29yIChhYnNQb3MpIHtcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ3NldEN1cnNvcjogJyArIGFic1Bvcyk7XG4gICAgbGV0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5zZXRDdXJzb3IoYWJzUG9zKTtcbiAgfVxuXG4gIHNldFBBQyAocGFjRGF0YSkge1xuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAncGFjRGF0YSA9ICcgKyBKU09OLnN0cmluZ2lmeShwYWNEYXRhKSk7XG4gICAgbGV0IG5ld1JvdyA9IHBhY0RhdGEucm93IC0gMTtcbiAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgJiYgbmV3Um93IDwgdGhpcy5uclJvbGxVcFJvd3MgLSAxKSB7XG4gICAgICBuZXdSb3cgPSB0aGlzLm5yUm9sbFVwUm93cyAtIDE7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoaXMgb25seSBhZmZlY3RzIFJvbGwtdXAgQ2FwdGlvbnMgYnkgY2hlY2tpbmcgdGhpcy5uclJvbGxVcFJvd3NcbiAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgJiYgdGhpcy5jdXJyUm93ICE9PSBuZXdSb3cpIHtcbiAgICAgIC8vIGNsZWFyIGFsbCByb3dzIGZpcnN0XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgICB0aGlzLnJvd3NbaV0uY2xlYXIoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29weSB0aGlzLm5yUm9sbFVwUm93cyByb3dzIGZyb20gbGFzdE91dHB1dFNjcmVlbiBhbmQgcGxhY2UgaXQgaW4gdGhlIG5ld1JvdyBsb2NhdGlvblxuICAgICAgLy8gdG9wUm93SW5kZXggLSB0aGUgc3RhcnQgb2Ygcm93cyB0byBjb3B5IChpbmNsdXNpdmUgaW5kZXgpXG4gICAgICBsZXQgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gKHRoaXMubnJSb2xsVXBSb3dzKTtcbiAgICAgIC8vIFdlIG9ubHkgY29weSBpZiB0aGUgbGFzdCBwb3NpdGlvbiB3YXMgYWxyZWFkeSBzaG93bi5cbiAgICAgIC8vIFdlIHVzZSB0aGUgY3VlU3RhcnRUaW1lIHZhbHVlIHRvIGNoZWNrIHRoaXMuXG4gICAgICBjb25zdCBsYXN0T3V0cHV0U2NyZWVuID0gdGhpcy5sYXN0T3V0cHV0U2NyZWVuO1xuICAgICAgaWYgKGxhc3RPdXRwdXRTY3JlZW4pIHtcbiAgICAgICAgbGV0IHByZXZMaW5lVGltZSA9IGxhc3RPdXRwdXRTY3JlZW4ucm93c1t0b3BSb3dJbmRleF0uY3VlU3RhcnRUaW1lO1xuICAgICAgICBpZiAocHJldkxpbmVUaW1lICYmIHByZXZMaW5lVGltZSA8IGxvZ2dlci50aW1lKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5yUm9sbFVwUm93czsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJvd3NbbmV3Um93IC0gdGhpcy5uclJvbGxVcFJvd3MgKyBpICsgMV0uY29weShsYXN0T3V0cHV0U2NyZWVuLnJvd3NbdG9wUm93SW5kZXggKyBpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyUm93ID0gbmV3Um93O1xuICAgIGxldCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICBpZiAocGFjRGF0YS5pbmRlbnQgIT09IG51bGwpIHtcbiAgICAgIGxldCBpbmRlbnQgPSBwYWNEYXRhLmluZGVudDtcbiAgICAgIGxldCBwcmV2UG9zID0gTWF0aC5tYXgoaW5kZW50IC0gMSwgMCk7XG4gICAgICByb3cuc2V0Q3Vyc29yKHBhY0RhdGEuaW5kZW50KTtcbiAgICAgIHBhY0RhdGEuY29sb3IgPSByb3cuY2hhcnNbcHJldlBvc10ucGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICB9XG4gICAgbGV0IHN0eWxlcyA9IHsgZm9yZWdyb3VuZDogcGFjRGF0YS5jb2xvciwgdW5kZXJsaW5lOiBwYWNEYXRhLnVuZGVybGluZSwgaXRhbGljczogcGFjRGF0YS5pdGFsaWNzLCBiYWNrZ3JvdW5kOiAnYmxhY2snLCBmbGFzaDogZmFsc2UgfTtcbiAgICB0aGlzLnNldFBlbihzdHlsZXMpO1xuICB9XG5cbiAgLyoqXG4gICAgICogU2V0IGJhY2tncm91bmQvZXh0cmEgZm9yZWdyb3VuZCwgYnV0IGZpcnN0IGRvIGJhY2tfc3BhY2UsIGFuZCB0aGVuIGluc2VydCBzcGFjZSAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpLlxuICAgICAqL1xuICBzZXRCa2dEYXRhIChia2dEYXRhKSB7XG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdia2dEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KGJrZ0RhdGEpKTtcbiAgICB0aGlzLmJhY2tTcGFjZSgpO1xuICAgIHRoaXMuc2V0UGVuKGJrZ0RhdGEpO1xuICAgIHRoaXMuaW5zZXJ0Q2hhcigweDIwKTsgLy8gU3BhY2VcbiAgfVxuXG4gIHNldFJvbGxVcFJvd3MgKG5yUm93cykge1xuICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnJSb3dzO1xuICB9XG5cbiAgcm9sbFVwICgpIHtcbiAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgPT09IG51bGwpIHtcbiAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ3JvbGxfdXAgYnV0IG5yUm9sbFVwUm93cyBub3Qgc2V0IHlldCcpO1xuICAgICAgcmV0dXJuOyAvLyBOb3QgcHJvcGVybHkgc2V0dXBcbiAgICB9XG4gICAgbG9nZ2VyLmxvZygnVEVYVCcsIHRoaXMuZ2V0RGlzcGxheVRleHQoKSk7XG4gICAgbGV0IHRvcFJvd0luZGV4ID0gdGhpcy5jdXJyUm93ICsgMSAtIHRoaXMubnJSb2xsVXBSb3dzO1xuICAgIGxldCB0b3BSb3cgPSB0aGlzLnJvd3Muc3BsaWNlKHRvcFJvd0luZGV4LCAxKVswXTtcbiAgICB0b3BSb3cuY2xlYXIoKTtcbiAgICB0aGlzLnJvd3Muc3BsaWNlKHRoaXMuY3VyclJvdywgMCwgdG9wUm93KTtcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JvbGxpbmcgdXAnKTtcbiAgICAvLyBsb2dnZXIubG9nKCdURVhUJywgdGhpcy5nZXRfZGlzcGxheV90ZXh0KCkpXG4gIH1cblxuICAvKipcbiAgICAqIEdldCBhbGwgbm9uLWVtcHR5IHJvd3Mgd2l0aCBhcyB1bmljb2RlIHRleHQuXG4gICAgKi9cbiAgZ2V0RGlzcGxheVRleHQgKGFzT25lUm93KSB7XG4gICAgYXNPbmVSb3cgPSBhc09uZVJvdyB8fCBmYWxzZTtcbiAgICBsZXQgZGlzcGxheVRleHQgPSBbXTtcbiAgICBsZXQgdGV4dCA9ICcnO1xuICAgIGxldCByb3dOciA9IC0xO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICBsZXQgcm93VGV4dCA9IHRoaXMucm93c1tpXS5nZXRUZXh0U3RyaW5nKCk7XG4gICAgICBpZiAocm93VGV4dCkge1xuICAgICAgICByb3dOciA9IGkgKyAxO1xuICAgICAgICBpZiAoYXNPbmVSb3cpIHtcbiAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKCdSb3cgJyArIHJvd05yICsgJzogXFwnJyArIHJvd1RleHQgKyAnXFwnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlzcGxheVRleHQucHVzaChyb3dUZXh0LnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRpc3BsYXlUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChhc09uZVJvdykge1xuICAgICAgICB0ZXh0ID0gJ1snICsgZGlzcGxheVRleHQuam9pbignIHwgJykgKyAnXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gZGlzcGxheVRleHQuam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgZ2V0VGV4dEFuZEZvcm1hdCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucm93cztcbiAgfVxufVxuXG4vLyB2YXIgbW9kZXMgPSBbJ01PREVfUk9MTC1VUCcsICdNT0RFX1BPUC1PTicsICdNT0RFX1BBSU5ULU9OJywgJ01PREVfVEVYVCddO1xuXG5jbGFzcyBDZWE2MDhDaGFubmVsIHtcbiAgY29uc3RydWN0b3IgKGNoYW5uZWxOdW1iZXIsIG91dHB1dEZpbHRlcikge1xuICAgIHRoaXMuY2hOciA9IGNoYW5uZWxOdW1iZXI7XG4gICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBvdXRwdXRGaWx0ZXI7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLnZlcmJvc2UgPSAwO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gbmV3IENhcHRpb25TY3JlZW4oKTtcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKCk7XG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gbmV3IENhcHRpb25TY3JlZW4oKTtcbiAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MgLSAxXTtcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7IC8vIEtlZXBzIHRyYWNrIG9mIHdoZXJlIGEgY3VlIHN0YXJ0ZWQuXG4gIH1cblxuICByZXNldCAoKSB7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuLnJlc2V0KCk7XG4gICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsO1xuICAgIHRoaXMubGFzdEN1ZUVuZFRpbWUgPSBudWxsO1xuICB9XG5cbiAgZ2V0SGFuZGxlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0RmlsdGVyO1xuICB9XG5cbiAgc2V0SGFuZGxlciAobmV3SGFuZGxlcikge1xuICAgIHRoaXMub3V0cHV0RmlsdGVyID0gbmV3SGFuZGxlcjtcbiAgfVxuXG4gIHNldFBBQyAocGFjRGF0YSkge1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UEFDKHBhY0RhdGEpO1xuICB9XG5cbiAgc2V0QmtnRGF0YSAoYmtnRGF0YSkge1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgfVxuXG4gIHNldE1vZGUgKG5ld01vZGUpIHtcbiAgICBpZiAobmV3TW9kZSA9PT0gdGhpcy5tb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ01PREU9JyArIG5ld01vZGUpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy53cml0ZVNjcmVlbi5yZXNldCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RlICE9PSAnTU9ERV9ST0xMLVVQJykge1xuICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gIH1cblxuICBpbnNlcnRDaGFycyAoY2hhcnMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuLmluc2VydENoYXIoY2hhcnNbaV0pO1xuICAgIH1cblxuICAgIGxldCBzY3JlZW4gPSB0aGlzLndyaXRlU2NyZWVuID09PSB0aGlzLmRpc3BsYXllZE1lbW9yeSA/ICdESVNQJyA6ICdOT05fRElTUCc7XG4gICAgbG9nZ2VyLmxvZygnSU5GTycsIHNjcmVlbiArICc6ICcgKyB0aGlzLndyaXRlU2NyZWVuLmdldERpc3BsYXlUZXh0KHRydWUpKTtcbiAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QQUlOVC1PTicgfHwgdGhpcy5tb2RlID09PSAnTU9ERV9ST0xMLVVQJykge1xuICAgICAgbG9nZ2VyLmxvZygnVEVYVCcsICdESVNQTEFZRUQ6ICcgKyB0aGlzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCh0cnVlKSk7XG4gICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBjY1JDTCAoKSB7IC8vIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcgKHN3aXRjaCBtb2RlIHRvIFBvcCBPbilcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JDTCAtIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcnKTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfUE9QLU9OJyk7XG4gIH1cblxuICBjY0JTICgpIHsgLy8gQmFja1NwYWNlXG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdCUyAtIEJhY2tTcGFjZScpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1RFWFQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy53cml0ZVNjcmVlbi5iYWNrU3BhY2UoKTtcbiAgICBpZiAodGhpcy53cml0ZVNjcmVlbiA9PT0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkpIHtcbiAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGNjQU9GICgpIHsgLy8gUmVzZXJ2ZWQgKGZvcm1lcmx5IEFsYXJtIE9mZilcblxuICB9XG5cbiAgY2NBT04gKCkgeyAvLyBSZXNlcnZlZCAoZm9ybWVybHkgQWxhcm0gT24pXG5cbiAgfVxuXG4gIGNjREVSICgpIHsgLy8gRGVsZXRlIHRvIEVuZCBvZiBSb3dcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0RFUi0gRGVsZXRlIHRvIEVuZCBvZiBSb3cnKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLmNsZWFyVG9FbmRPZlJvdygpO1xuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICB9XG5cbiAgY2NSVSAobnJSb3dzKSB7IC8vIFJvbGwtVXAgQ2FwdGlvbnMtMiwzLG9yIDQgUm93c1xuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnUlUoJyArIG5yUm93cyArICcpIC0gUm9sbCBVcCcpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfUk9MTC1VUCcpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0Um9sbFVwUm93cyhuclJvd3MpO1xuICB9XG5cbiAgY2NGT04gKCkgeyAvLyBGbGFzaCBPblxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRk9OIC0gRmxhc2ggT24nKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbih7IGZsYXNoOiB0cnVlIH0pO1xuICB9XG5cbiAgY2NSREMgKCkgeyAvLyBSZXN1bWUgRGlyZWN0IENhcHRpb25pbmcgKHN3aXRjaCBtb2RlIHRvIFBhaW50T24pXG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdSREMgLSBSZXN1bWUgRGlyZWN0IENhcHRpb25pbmcnKTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfUEFJTlQtT04nKTtcbiAgfVxuXG4gIGNjVFIgKCkgeyAvLyBUZXh0IFJlc3RhcnQgaW4gdGV4dCBtb2RlIChub3Qgc3VwcG9ydGVkLCBob3dldmVyKVxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnVFInKTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xuICB9XG5cbiAgY2NSVEQgKCkgeyAvLyBSZXN1bWUgVGV4dCBEaXNwbGF5IGluIFRleHQgbW9kZSAobm90IHN1cHBvcnRlZCwgaG93ZXZlcilcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ1JURCcpO1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XG4gIH1cblxuICBjY0VETSAoKSB7IC8vIEVyYXNlIERpc3BsYXllZCBNZW1vcnlcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0VETSAtIEVyYXNlIERpc3BsYXllZCBNZW1vcnknKTtcbiAgICB0aGlzLmRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcbiAgfVxuXG4gIGNjQ1IgKCkgeyAvLyBDYXJyaWFnZSBSZXR1cm5cbiAgICBsb2dnZXIubG9nKCdDUiAtIENhcnJpYWdlIFJldHVybicpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4ucm9sbFVwKCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICB9XG5cbiAgY2NFTk0gKCkgeyAvLyBFcmFzZSBOb24tRGlzcGxheWVkIE1lbW9yeVxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnRU5NIC0gRXJhc2UgTm9uLWRpc3BsYXllZCBNZW1vcnknKTtcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICB9XG5cbiAgY2NFT0MgKCkgeyAvLyBFbmQgb2YgQ2FwdGlvbiAoRmxpcCBNZW1vcmllcylcbiAgICBsb2dnZXIubG9nKCdJTkZPJywgJ0VPQyAtIEVuZCBPZiBDYXB0aW9uJyk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUE9QLU9OJykge1xuICAgICAgbGV0IHRtcCA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gdG1wO1xuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgICAgbG9nZ2VyLmxvZygnVEVYVCcsICdESVNQOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQoKSk7XG4gICAgfVxuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcbiAgfVxuXG4gIGNjVE8gKG5yQ29scykgeyAvLyBUYWIgT2Zmc2V0IDEsMiwgb3IgMyBjb2x1bW5zXG4gICAgbG9nZ2VyLmxvZygnSU5GTycsICdUTygnICsgbnJDb2xzICsgJykgLSBUYWIgT2Zmc2V0Jyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5tb3ZlQ3Vyc29yKG5yQ29scyk7XG4gIH1cblxuICBjY01JRFJPVyAoc2Vjb25kQnl0ZSkgeyAvLyBQYXJzZSBNSURST1cgY29tbWFuZFxuICAgIGxldCBzdHlsZXMgPSB7IGZsYXNoOiBmYWxzZSB9O1xuICAgIHN0eWxlcy51bmRlcmxpbmUgPSBzZWNvbmRCeXRlICUgMiA9PT0gMTtcbiAgICBzdHlsZXMuaXRhbGljcyA9IHNlY29uZEJ5dGUgPj0gMHgyZTtcbiAgICBpZiAoIXN0eWxlcy5pdGFsaWNzKSB7XG4gICAgICBsZXQgY29sb3JJbmRleCA9IE1hdGguZmxvb3Ioc2Vjb25kQnl0ZSAvIDIpIC0gMHgxMDtcbiAgICAgIGxldCBjb2xvcnMgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnXTtcbiAgICAgIHN0eWxlcy5mb3JlZ3JvdW5kID0gY29sb3JzW2NvbG9ySW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgfVxuICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnTUlEUk9XOiAnICsgSlNPTi5zdHJpbmdpZnkoc3R5bGVzKSk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQZW4oc3R5bGVzKTtcbiAgfVxuXG4gIG91dHB1dERhdGFVcGRhdGUgKGRpc3BhdGNoID0gZmFsc2UpIHtcbiAgICBsZXQgdCA9IGxvZ2dlci50aW1lO1xuICAgIGlmICh0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyKSB7XG4gICAgICBpZiAodGhpcy5jdWVTdGFydFRpbWUgPT09IG51bGwgJiYgIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkgeyAvLyBTdGFydCBvZiBhIG5ldyBjdWVcbiAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5lcXVhbHModGhpcy5sYXN0T3V0cHV0U2NyZWVuKSkge1xuICAgICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSh0aGlzLmN1ZVN0YXJ0VGltZSwgdCwgdGhpcy5sYXN0T3V0cHV0U2NyZWVuKTtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCA9PT0gdHJ1ZSAmJiB0aGlzLm91dHB1dEZpbHRlci5kaXNwYXRjaEN1ZSkge1xuICAgICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5kaXNwYXRjaEN1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSA/IG51bGwgOiB0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4uY29weSh0aGlzLmRpc3BsYXllZE1lbW9yeSk7XG4gICAgfVxuICB9XG5cbiAgY3VlU3BsaXRBdFRpbWUgKHQpIHtcbiAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIpIHtcbiAgICAgIGlmICghdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUpIHtcbiAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIHQsIHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgQ2VhNjA4UGFyc2VyIHtcbiAgY29uc3RydWN0b3IgKGZpZWxkLCBvdXQxLCBvdXQyKSB7XG4gICAgdGhpcy5maWVsZCA9IGZpZWxkIHx8IDE7XG4gICAgdGhpcy5vdXRwdXRzID0gW291dDEsIG91dDJdO1xuICAgIHRoaXMuY2hhbm5lbHMgPSBbbmV3IENlYTYwOENoYW5uZWwoMSwgb3V0MSksIG5ldyBDZWE2MDhDaGFubmVsKDIsIG91dDIpXTtcbiAgICB0aGlzLmN1cnJDaE5yID0gLTE7IC8vIFdpbGwgYmUgMSBvciAyXG4gICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7IC8vIEZpcnN0IGJ5dGUgb2YgbGFzdCBjb21tYW5kXG4gICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7IC8vIFNlY29uZCBieXRlIG9mIGxhc3QgY29tbWFuZFxuICAgIHRoaXMuYnVmZmVyZWREYXRhID0gW107XG4gICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgIHRoaXMubGFzdFRpbWUgPSBudWxsO1xuICAgIHRoaXMuZGF0YUNvdW50ZXJzID0geyAncGFkZGluZyc6IDAsICdjaGFyJzogMCwgJ2NtZCc6IDAsICdvdGhlcic6IDAgfTtcbiAgfVxuXG4gIGdldEhhbmRsZXIgKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbaW5kZXhdLmdldEhhbmRsZXIoKTtcbiAgfVxuXG4gIHNldEhhbmRsZXIgKGluZGV4LCBuZXdIYW5kbGVyKSB7XG4gICAgdGhpcy5jaGFubmVsc1tpbmRleF0uc2V0SGFuZGxlcihuZXdIYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIEFkZCBkYXRhIGZvciB0aW1lIHQgaW4gZm9ybXMgb2YgbGlzdCBvZiBieXRlcyAodW5zaWduZWQgaW50cykuIFRoZSBieXRlcyBhcmUgdHJlYXRlZCBhcyBwYWlycy5cbiAgICAgKi9cbiAgYWRkRGF0YSAodCwgYnl0ZUxpc3QpIHtcbiAgICBsZXQgY21kRm91bmQsIGEsIGIsXG4gICAgICBjaGFyc0ZvdW5kID0gZmFsc2U7XG5cbiAgICB0aGlzLmxhc3RUaW1lID0gdDtcbiAgICBsb2dnZXIuc2V0VGltZSh0KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZUxpc3QubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGEgPSBieXRlTGlzdFtpXSAmIDB4N2Y7XG4gICAgICBiID0gYnl0ZUxpc3RbaSArIDFdICYgMHg3ZjtcbiAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgICAgdGhpcy5kYXRhQ291bnRlcnMucGFkZGluZyArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0RBVEEnLCAnWycgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpICsgMV1dKSArICddIC0+ICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKScpO1xuICAgICAgfVxuICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQ21kKGEsIGIpO1xuICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VNaWRyb3coYSwgYik7XG4gICAgICB9XG5cbiAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlUEFDKGEsIGIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzKGEsIGIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgIGNoYXJzRm91bmQgPSB0aGlzLnBhcnNlQ2hhcnMoYSwgYik7XG4gICAgICAgIGlmIChjaGFyc0ZvdW5kKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY3VyckNoTnIgJiYgdGhpcy5jdXJyQ2hOciA+PSAwKSB7XG4gICAgICAgICAgICBsZXQgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbdGhpcy5jdXJyQ2hOciAtIDFdO1xuICAgICAgICAgICAgY2hhbm5lbC5pbnNlcnRDaGFycyhjaGFyc0ZvdW5kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnV0FSTklORycsICdObyBjaGFubmVsIGZvdW5kIHlldC4gVEVYVC1NT0RFPycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNtZEZvdW5kKSB7XG4gICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLmNtZCArPSAyO1xuICAgICAgfSBlbHNlIGlmIChjaGFyc0ZvdW5kKSB7XG4gICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLmNoYXIgKz0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGF0YUNvdW50ZXJzLm90aGVyICs9IDI7XG4gICAgICAgIGxvZ2dlci5sb2coJ1dBUk5JTkcnLCAnQ291bGRuXFwndCBwYXJzZSBjbGVhbmVkIGRhdGEgJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIG9yaWc6ICcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpICsgMV1dKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAgICogUGFyc2UgQ29tbWFuZC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVGVsbHMgaWYgYSBjb21tYW5kIHdhcyBmb3VuZFxuICAgICAqL1xuICBwYXJzZUNtZCAoYSwgYikge1xuICAgIGxldCBjaE5yID0gbnVsbDtcblxuICAgIGxldCBjb25kMSA9IChhID09PSAweDE0IHx8IGEgPT09IDB4MUMpICYmIChiID49IDB4MjAgJiYgYiA8PSAweDJGKTtcbiAgICBsZXQgY29uZDIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFGKSAmJiAoYiA+PSAweDIxICYmIGIgPD0gMHgyMyk7XG4gICAgaWYgKCEoY29uZDEgfHwgY29uZDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGEgPT09IHRoaXMubGFzdENtZEEgJiYgYiA9PT0gdGhpcy5sYXN0Q21kQikge1xuICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDsgLy8gUmVwZWF0ZWQgY29tbWFuZHMgYXJlIGRyb3BwZWQgKG9uY2UpXG4gICAgICBsb2dnZXIubG9nKCdERUJVRycsICdSZXBlYXRlZCBjb21tYW5kICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKSBpcyBkcm9wcGVkJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoYSA9PT0gMHgxNCB8fCBhID09PSAweDE3KSB7XG4gICAgICBjaE5yID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hOciA9IDI7XG4gICAgfSAvLyAoYSA9PT0gMHgxQyB8fCBhPT09IDB4MWYpXG5cbiAgICBsZXQgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOciAtIDFdO1xuXG4gICAgaWYgKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxQykge1xuICAgICAgaWYgKGIgPT09IDB4MjApIHtcbiAgICAgICAgY2hhbm5lbC5jY1JDTCgpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDIxKSB7XG4gICAgICAgIGNoYW5uZWwuY2NCUygpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDIyKSB7XG4gICAgICAgIGNoYW5uZWwuY2NBT0YoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMykge1xuICAgICAgICBjaGFubmVsLmNjQU9OKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjQpIHtcbiAgICAgICAgY2hhbm5lbC5jY0RFUigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI1KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVSgyKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNikge1xuICAgICAgICBjaGFubmVsLmNjUlUoMyk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjcpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JVKDQpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI4KSB7XG4gICAgICAgIGNoYW5uZWwuY2NGT04oKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOSkge1xuICAgICAgICBjaGFubmVsLmNjUkRDKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkEpIHtcbiAgICAgICAgY2hhbm5lbC5jY1RSKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkIpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JURCgpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJDKSB7XG4gICAgICAgIGNoYW5uZWwuY2NFRE0oKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyRCkge1xuICAgICAgICBjaGFubmVsLmNjQ1IoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyRSkge1xuICAgICAgICBjaGFubmVsLmNjRU5NKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MkYpIHtcbiAgICAgICAgY2hhbm5lbC5jY0VPQygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIGEgPT0gMHgxNyB8fCBhID09IDB4MUZcbiAgICAgIGNoYW5uZWwuY2NUTyhiIC0gMHgyMCk7XG4gICAgfVxuICAgIHRoaXMubGFzdENtZEEgPSBhO1xuICAgIHRoaXMubGFzdENtZEIgPSBiO1xuICAgIHRoaXMuY3VyckNoTnIgPSBjaE5yO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAgICogUGFyc2UgbWlkcm93IHN0eWxpbmcgY29tbWFuZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICBwYXJzZU1pZHJvdyAoYSwgYikge1xuICAgIGxldCBjaE5yID0gbnVsbDtcblxuICAgIGlmICgoKGEgPT09IDB4MTEpIHx8IChhID09PSAweDE5KSkgJiYgYiA+PSAweDIwICYmIGIgPD0gMHgyZikge1xuICAgICAgaWYgKGEgPT09IDB4MTEpIHtcbiAgICAgICAgY2hOciA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaE5yID0gMjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoTnIgIT09IHRoaXMuY3VyckNoTnIpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnRVJST1InLCAnTWlzbWF0Y2ggY2hhbm5lbCBpbiBtaWRyb3cgcGFyc2luZycpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOciAtIDFdO1xuICAgICAgY2hhbm5lbC5jY01JRFJPVyhiKTtcbiAgICAgIGxvZ2dlci5sb2coJ0RFQlVHJywgJ01JRFJPVyAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyknKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAgICogUGFyc2UgUHJlYWJsZSBBY2Nlc3MgQ29kZXMgKFRhYmxlIDUzKS5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVGVsbHMgaWYgUEFDIGZvdW5kXG4gICAgICovXG4gIHBhcnNlUEFDIChhLCBiKSB7XG4gICAgbGV0IGNoTnIgPSBudWxsO1xuICAgIGxldCByb3cgPSBudWxsO1xuXG4gICAgbGV0IGNhc2UxID0gKChhID49IDB4MTEgJiYgYSA8PSAweDE3KSB8fCAoYSA+PSAweDE5ICYmIGEgPD0gMHgxRikpICYmIChiID49IDB4NDAgJiYgYiA8PSAweDdGKTtcbiAgICBsZXQgY2FzZTIgPSAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSAmJiAoYiA+PSAweDQwICYmIGIgPD0gMHg1Rik7XG4gICAgaWYgKCEoY2FzZTEgfHwgY2FzZTIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGEgPT09IHRoaXMubGFzdENtZEEgJiYgYiA9PT0gdGhpcy5sYXN0Q21kQikge1xuICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBSZXBlYXRlZCBjb21tYW5kcyBhcmUgZHJvcHBlZCAob25jZSlcbiAgICB9XG5cbiAgICBjaE5yID0gKGEgPD0gMHgxNykgPyAxIDogMjtcblxuICAgIGlmIChiID49IDB4NDAgJiYgYiA8PSAweDVGKSB7XG4gICAgICByb3cgPSAoY2hOciA9PT0gMSkgPyByb3dzTG93Q2gxW2FdIDogcm93c0xvd0NoMlthXTtcbiAgICB9IGVsc2UgeyAvLyAweDYwIDw9IGIgPD0gMHg3RlxuICAgICAgcm93ID0gKGNoTnIgPT09IDEpID8gcm93c0hpZ2hDaDFbYV0gOiByb3dzSGlnaENoMlthXTtcbiAgICB9XG4gICAgbGV0IHBhY0RhdGEgPSB0aGlzLmludGVycHJldFBBQyhyb3csIGIpO1xuICAgIGxldCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XG4gICAgY2hhbm5lbC5zZXRQQUMocGFjRGF0YSk7XG4gICAgdGhpcy5sYXN0Q21kQSA9IGE7XG4gICAgdGhpcy5sYXN0Q21kQiA9IGI7XG4gICAgdGhpcy5jdXJyQ2hOciA9IGNoTnI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICAgKiBJbnRlcnByZXQgdGhlIHNlY29uZCBieXRlIG9mIHRoZSBwYWMsIGFuZCByZXR1cm4gdGhlIGluZm9ybWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHBhY0RhdGEgd2l0aCBzdHlsZSBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICBpbnRlcnByZXRQQUMgKHJvdywgYnl0ZSkge1xuICAgIGxldCBwYWNJbmRleCA9IGJ5dGU7XG4gICAgbGV0IHBhY0RhdGEgPSB7IGNvbG9yOiBudWxsLCBpdGFsaWNzOiBmYWxzZSwgaW5kZW50OiBudWxsLCB1bmRlcmxpbmU6IGZhbHNlLCByb3c6IHJvdyB9O1xuXG4gICAgaWYgKGJ5dGUgPiAweDVGKSB7XG4gICAgICBwYWNJbmRleCA9IGJ5dGUgLSAweDYwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNJbmRleCA9IGJ5dGUgLSAweDQwO1xuICAgIH1cblxuICAgIHBhY0RhdGEudW5kZXJsaW5lID0gKHBhY0luZGV4ICYgMSkgPT09IDE7XG4gICAgaWYgKHBhY0luZGV4IDw9IDB4ZCkge1xuICAgICAgcGFjRGF0YS5jb2xvciA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YScsICd3aGl0ZSddW01hdGguZmxvb3IocGFjSW5kZXggLyAyKV07XG4gICAgfSBlbHNlIGlmIChwYWNJbmRleCA8PSAweGYpIHtcbiAgICAgIHBhY0RhdGEuaXRhbGljcyA9IHRydWU7XG4gICAgICBwYWNEYXRhLmNvbG9yID0gJ3doaXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFjRGF0YS5pbmRlbnQgPSAoTWF0aC5mbG9vcigocGFjSW5kZXggLSAweDEwKSAvIDIpKSAqIDQ7XG4gICAgfVxuICAgIHJldHVybiBwYWNEYXRhOyAvLyBOb3RlIHRoYXQgcm93IGhhcyB6ZXJvIG9mZnNldC4gVGhlIHNwZWMgdXNlcyAxLlxuICB9XG5cbiAgLyoqXG4gICAgICogUGFyc2UgY2hhcmFjdGVycy5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIDEgdG8gMiBjb2RlcyBjb3JyZXNwb25kaW5nIHRvIGNoYXJzLCBpZiBmb3VuZC4gbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gIHBhcnNlQ2hhcnMgKGEsIGIpIHtcbiAgICBsZXQgY2hhbm5lbE5yID0gbnVsbCxcbiAgICAgIGNoYXJDb2RlcyA9IG51bGwsXG4gICAgICBjaGFyQ29kZTEgPSBudWxsO1xuXG4gICAgaWYgKGEgPj0gMHgxOSkge1xuICAgICAgY2hhbm5lbE5yID0gMjtcbiAgICAgIGNoYXJDb2RlMSA9IGEgLSA4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFubmVsTnIgPSAxO1xuICAgICAgY2hhckNvZGUxID0gYTtcbiAgICB9XG4gICAgaWYgKGNoYXJDb2RlMSA+PSAweDExICYmIGNoYXJDb2RlMSA8PSAweDEzKSB7XG4gICAgICAvLyBTcGVjaWFsIGNoYXJhY3RlclxuICAgICAgbGV0IG9uZUNvZGUgPSBiO1xuICAgICAgaWYgKGNoYXJDb2RlMSA9PT0gMHgxMSkge1xuICAgICAgICBvbmVDb2RlID0gYiArIDB4NTA7XG4gICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlMSA9PT0gMHgxMikge1xuICAgICAgICBvbmVDb2RlID0gYiArIDB4NzA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbmVDb2RlID0gYiArIDB4OTA7XG4gICAgICB9XG5cbiAgICAgIGxvZ2dlci5sb2coJ0lORk8nLCAnU3BlY2lhbCBjaGFyIFxcJycgKyBnZXRDaGFyRm9yQnl0ZShvbmVDb2RlKSArICdcXCcgaW4gY2hhbm5lbCAnICsgY2hhbm5lbE5yKTtcbiAgICAgIGNoYXJDb2RlcyA9IFtvbmVDb2RlXTtcbiAgICB9IGVsc2UgaWYgKGEgPj0gMHgyMCAmJiBhIDw9IDB4N2YpIHtcbiAgICAgIGNoYXJDb2RlcyA9IChiID09PSAwKSA/IFthXSA6IFthLCBiXTtcbiAgICB9XG4gICAgaWYgKGNoYXJDb2Rlcykge1xuICAgICAgbGV0IGhleENvZGVzID0gbnVtQXJyYXlUb0hleEFycmF5KGNoYXJDb2Rlcyk7XG4gICAgICBsb2dnZXIubG9nKCdERUJVRycsICdDaGFyIGNvZGVzID0gICcgKyBoZXhDb2Rlcy5qb2luKCcsJykpO1xuICAgICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgICB0aGlzLmxhc3RDbWRCID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJDb2RlcztcbiAgfVxuXG4gIC8qKlxuICAgICogUGFyc2UgZXh0ZW5kZWQgYmFja2dyb3VuZCBhdHRyaWJ1dGVzIGFzIHdlbGwgYXMgbmV3IGZvcmVncm91bmQgY29sb3IgYmxhY2suXG4gICAgKiBAcmV0dXJuc3tCb29sZWFufSBUZWxscyBpZiBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXJlIGZvdW5kXG4gICAgKi9cbiAgcGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyAoYSwgYikge1xuICAgIGxldCBia2dEYXRhLFxuICAgICAgaW5kZXgsXG4gICAgICBjaE5yLFxuICAgICAgY2hhbm5lbDtcblxuICAgIGxldCBjYXNlMSA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmIChiID49IDB4MjAgJiYgYiA8PSAweDJmKTtcbiAgICBsZXQgY2FzZTIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFmKSAmJiAoYiA+PSAweDJkICYmIGIgPD0gMHgyZik7XG4gICAgaWYgKCEoY2FzZTEgfHwgY2FzZTIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgYmtnRGF0YSA9IHt9O1xuICAgIGlmIChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpIHtcbiAgICAgIGluZGV4ID0gTWF0aC5mbG9vcigoYiAtIDB4MjApIC8gMik7XG4gICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kQ29sb3JzW2luZGV4XTtcbiAgICAgIGlmIChiICUgMiA9PT0gMSkge1xuICAgICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBia2dEYXRhLmJhY2tncm91bmQgKyAnX3NlbWknO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyZCkge1xuICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcbiAgICB9IGVsc2Uge1xuICAgICAgYmtnRGF0YS5mb3JlZ3JvdW5kID0gJ2JsYWNrJztcbiAgICAgIGlmIChiID09PSAweDJmKSB7XG4gICAgICAgIGJrZ0RhdGEudW5kZXJsaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2hOciA9IChhIDwgMHgxOCkgPyAxIDogMjtcbiAgICBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yIC0gMV07XG4gICAgY2hhbm5lbC5zZXRCa2dEYXRhKGJrZ0RhdGEpO1xuICAgIHRoaXMubGFzdENtZEEgPSBudWxsO1xuICAgIHRoaXMubGFzdENtZEIgPSBudWxsO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAgICogUmVzZXQgc3RhdGUgb2YgcGFyc2VyIGFuZCBpdHMgY2hhbm5lbHMuXG4gICAgICovXG4gIHJlc2V0ICgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmNoYW5uZWxzW2ldKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbHNbaV0ucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sYXN0Q21kQSA9IG51bGw7XG4gICAgdGhpcy5sYXN0Q21kQiA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICAgKiBUcmlnZ2VyIHRoZSBnZW5lcmF0aW9uIG9mIGEgY3VlLCBhbmQgdGhlIHN0YXJ0IG9mIGEgbmV3IG9uZSBpZiBkaXNwbGF5U2NyZWVucyBhcmUgbm90IGVtcHR5LlxuICAgICAqL1xuICBjdWVTcGxpdEF0VGltZSAodCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuY2hhbm5lbHNbaV0pIHtcbiAgICAgICAgdGhpcy5jaGFubmVsc1tpXS5jdWVTcGxpdEF0VGltZSh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2VhNjA4UGFyc2VyO1xuIiwiLy8gZnJvbSBodHRwOi8vbXA0cmEub3JnL2NvZGVjcy5odG1sXG5jb25zdCBzYW1wbGVFbnRyeUNvZGVzSVNPID0ge1xuICBhdWRpbzoge1xuICAgICdhM2RzJzogdHJ1ZSxcbiAgICAnYWMtMyc6IHRydWUsXG4gICAgJ2FjLTQnOiB0cnVlLFxuICAgICdhbGFjJzogdHJ1ZSxcbiAgICAnYWxhdyc6IHRydWUsXG4gICAgJ2RyYTEnOiB0cnVlLFxuICAgICdkdHMrJzogdHJ1ZSxcbiAgICAnZHRzLSc6IHRydWUsXG4gICAgJ2R0c2MnOiB0cnVlLFxuICAgICdkdHNlJzogdHJ1ZSxcbiAgICAnZHRzaCc6IHRydWUsXG4gICAgJ2VjLTMnOiB0cnVlLFxuICAgICdlbmNhJzogdHJ1ZSxcbiAgICAnZzcxOSc6IHRydWUsXG4gICAgJ2c3MjYnOiB0cnVlLFxuICAgICdtNGFlJzogdHJ1ZSxcbiAgICAnbWhhMSc6IHRydWUsXG4gICAgJ21oYTInOiB0cnVlLFxuICAgICdtaG0xJzogdHJ1ZSxcbiAgICAnbWhtMic6IHRydWUsXG4gICAgJ21scGEnOiB0cnVlLFxuICAgICdtcDRhJzogdHJ1ZSxcbiAgICAncmF3ICc6IHRydWUsXG4gICAgJ09wdXMnOiB0cnVlLFxuICAgICdzYW1yJzogdHJ1ZSxcbiAgICAnc2F3Yic6IHRydWUsXG4gICAgJ3Nhd3AnOiB0cnVlLFxuICAgICdzZXZjJzogdHJ1ZSxcbiAgICAnc3FjcCc6IHRydWUsXG4gICAgJ3NzbXYnOiB0cnVlLFxuICAgICd0d29zJzogdHJ1ZSxcbiAgICAndWxhdyc6IHRydWVcbiAgfSxcbiAgdmlkZW86IHtcbiAgICAnYXZjMSc6IHRydWUsXG4gICAgJ2F2YzInOiB0cnVlLFxuICAgICdhdmMzJzogdHJ1ZSxcbiAgICAnYXZjNCc6IHRydWUsXG4gICAgJ2F2Y3AnOiB0cnVlLFxuICAgICdkcmFjJzogdHJ1ZSxcbiAgICAnZHZhdic6IHRydWUsXG4gICAgJ2R2aGUnOiB0cnVlLFxuICAgICdlbmN2JzogdHJ1ZSxcbiAgICAnaGV2MSc6IHRydWUsXG4gICAgJ2h2YzEnOiB0cnVlLFxuICAgICdtanAyJzogdHJ1ZSxcbiAgICAnbXA0dic6IHRydWUsXG4gICAgJ212YzEnOiB0cnVlLFxuICAgICdtdmMyJzogdHJ1ZSxcbiAgICAnbXZjMyc6IHRydWUsXG4gICAgJ212YzQnOiB0cnVlLFxuICAgICdyZXN2JzogdHJ1ZSxcbiAgICAncnY2MCc6IHRydWUsXG4gICAgJ3MyNjMnOiB0cnVlLFxuICAgICdzdmMxJzogdHJ1ZSxcbiAgICAnc3ZjMic6IHRydWUsXG4gICAgJ3ZjLTEnOiB0cnVlLFxuICAgICd2cDA4JzogdHJ1ZSxcbiAgICAndnAwOSc6IHRydWVcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNDb2RlY1R5cGUgKGNvZGVjLCB0eXBlKSB7XG4gIGNvbnN0IHR5cGVDb2RlcyA9IHNhbXBsZUVudHJ5Q29kZXNJU09bdHlwZV07XG4gIHJldHVybiAhIXR5cGVDb2RlcyAmJiB0eXBlQ29kZXNbY29kZWMuc2xpY2UoMCwgNCldID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0NvZGVjU3VwcG9ydGVkSW5NcDQgKGNvZGVjLCB0eXBlKSB7XG4gIHJldHVybiB3aW5kb3cuTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKGAke3R5cGUgfHwgJ3ZpZGVvJ30vbXA0O2NvZGVjcz1cIiR7Y29kZWN9XCJgKTtcbn1cblxuZXhwb3J0IHsgaXNDb2RlY1R5cGUsIGlzQ29kZWNTdXBwb3J0ZWRJbk1wNCB9O1xuIiwiaW1wb3J0IHsgZml4TGluZUJyZWFrcyB9IGZyb20gJy4vdnR0cGFyc2VyJztcblxuZXhwb3J0IGZ1bmN0aW9uIG5ld0N1ZSAodHJhY2ssIHN0YXJ0VGltZSwgZW5kVGltZSwgY2FwdGlvblNjcmVlbikge1xuICBsZXQgcm93O1xuICBsZXQgY3VlO1xuICBsZXQgaW5kZW50aW5nO1xuICBsZXQgaW5kZW50O1xuICBsZXQgdGV4dDtcbiAgbGV0IFZUVEN1ZSA9IHdpbmRvdy5WVFRDdWUgfHwgd2luZG93LlRleHRUcmFja0N1ZTtcblxuICBmb3IgKGxldCByID0gMDsgciA8IGNhcHRpb25TY3JlZW4ucm93cy5sZW5ndGg7IHIrKykge1xuICAgIHJvdyA9IGNhcHRpb25TY3JlZW4ucm93c1tyXTtcbiAgICBpbmRlbnRpbmcgPSB0cnVlO1xuICAgIGluZGVudCA9IDA7XG4gICAgdGV4dCA9ICcnO1xuXG4gICAgaWYgKCFyb3cuaXNFbXB0eSgpKSB7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHJvdy5jaGFycy5sZW5ndGg7IGMrKykge1xuICAgICAgICBpZiAocm93LmNoYXJzW2NdLnVjaGFyLm1hdGNoKC9cXHMvKSAmJiBpbmRlbnRpbmcpIHtcbiAgICAgICAgICBpbmRlbnQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ICs9IHJvdy5jaGFyc1tjXS51Y2hhcjtcbiAgICAgICAgICBpbmRlbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVG8gYmUgdXNlZCBmb3IgY2xlYW5pbmctdXAgb3JwaGFuZWQgcm9sbC11cCBjYXB0aW9uc1xuICAgICAgcm93LmN1ZVN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcblxuICAgICAgLy8gR2l2ZSBhIHNsaWdodCBidW1wIHRvIHRoZSBlbmRUaW1lIGlmIGl0J3MgZXF1YWwgdG8gc3RhcnRUaW1lIHRvIGF2b2lkIGEgU3ludGF4RXJyb3IgaW4gSUVcbiAgICAgIGlmIChzdGFydFRpbWUgPT09IGVuZFRpbWUpIHtcbiAgICAgICAgZW5kVGltZSArPSAwLjAwMDE7XG4gICAgICB9XG5cbiAgICAgIGN1ZSA9IG5ldyBWVFRDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCBmaXhMaW5lQnJlYWtzKHRleHQudHJpbSgpKSk7XG5cbiAgICAgIGlmIChpbmRlbnQgPj0gMTYpIHtcbiAgICAgICAgaW5kZW50LS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRlbnQrKztcbiAgICAgIH1cblxuICAgICAgLy8gVlRUQ3VlLmxpbmUgZ2V0J3MgZmxha2V5IHdoZW4gdXNpbmcgY29udHJvbHMsIHNvIGxldCdzIG5vdyBpbmNsdWRlIGxpbmUgMTMmMTRcbiAgICAgIC8vIGFsc28sIGRyb3AgbGluZSAxIHNpbmNlIGl0J3MgdG8gY2xvc2UgdG8gdGhlIHRvcFxuICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8vKSkge1xuICAgICAgICBjdWUubGluZSA9IHIgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VlLmxpbmUgPSAociA+IDcgPyByIC0gMiA6IHIgKyAxKTtcbiAgICAgIH1cblxuICAgICAgY3VlLmFsaWduID0gJ2xlZnQnO1xuICAgICAgLy8gQ2xhbXAgdGhlIHBvc2l0aW9uIGJldHdlZW4gMCBhbmQgMTAwIC0gaWYgb3V0IG9mIHRoZXNlIGJvdW5kcywgRmlyZWZveCB0aHJvd3MgYW4gZXhjZXB0aW9uIGFuZCBjYXB0aW9ucyBicmVha1xuICAgICAgY3VlLnBvc2l0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCAxMDAgKiAoaW5kZW50IC8gMzIpICsgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8vKSA/IDUwIDogMCkpKTtcbiAgICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IEJpbmFyeVNlYXJjaCBmcm9tICcuL2JpbmFyeS1zZWFyY2gnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGaXJzdEZyYWdXaXRoQ0MgKGZyYWdtZW50cywgY2MpIHtcbiAgbGV0IGZpcnN0RnJhZyA9IG51bGw7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFnbWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBjdXJyZW50RnJhZyA9IGZyYWdtZW50c1tpXTtcbiAgICBpZiAoY3VycmVudEZyYWcgJiYgY3VycmVudEZyYWcuY2MgPT09IGNjKSB7XG4gICAgICBmaXJzdEZyYWcgPSBjdXJyZW50RnJhZztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaXJzdEZyYWc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRnJhZ1dpdGhDQyAoZnJhZ21lbnRzLCBDQykge1xuICByZXR1cm4gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIChjYW5kaWRhdGUpID0+IHtcbiAgICBpZiAoY2FuZGlkYXRlLmNjIDwgQ0MpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoY2FuZGlkYXRlLmNjID4gQ0MpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMgKGxhc3RGcmFnLCBsYXN0TGV2ZWwsIGRldGFpbHMpIHtcbiAgbGV0IHNob3VsZEFsaWduID0gZmFsc2U7XG4gIGlmIChsYXN0TGV2ZWwgJiYgbGFzdExldmVsLmRldGFpbHMgJiYgZGV0YWlscykge1xuICAgIGlmIChkZXRhaWxzLmVuZENDID4gZGV0YWlscy5zdGFydENDIHx8IChsYXN0RnJhZyAmJiBsYXN0RnJhZy5jYyA8IGRldGFpbHMuc3RhcnRDQykpIHtcbiAgICAgIHNob3VsZEFsaWduID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNob3VsZEFsaWduO1xufVxuXG4vLyBGaW5kIHRoZSBmaXJzdCBmcmFnIGluIHRoZSBwcmV2aW91cyBsZXZlbCB3aGljaCBtYXRjaGVzIHRoZSBDQyBvZiB0aGUgZmlyc3QgZnJhZyBvZiB0aGUgbmV3IGxldmVsXG5leHBvcnQgZnVuY3Rpb24gZmluZERpc2NvbnRpbnVvdXNSZWZlcmVuY2VGcmFnIChwcmV2RGV0YWlscywgY3VyRGV0YWlscykge1xuICBjb25zdCBwcmV2RnJhZ3MgPSBwcmV2RGV0YWlscy5mcmFnbWVudHM7XG4gIGNvbnN0IGN1ckZyYWdzID0gY3VyRGV0YWlscy5mcmFnbWVudHM7XG5cbiAgaWYgKCFjdXJGcmFncy5sZW5ndGggfHwgIXByZXZGcmFncy5sZW5ndGgpIHtcbiAgICBsb2dnZXIubG9nKCdObyBmcmFnbWVudHMgdG8gYWxpZ24nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwcmV2U3RhcnRGcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhwcmV2RnJhZ3MsIGN1ckZyYWdzWzBdLmNjKTtcblxuICBpZiAoIXByZXZTdGFydEZyYWcgfHwgKHByZXZTdGFydEZyYWcgJiYgIXByZXZTdGFydEZyYWcuc3RhcnRQVFMpKSB7XG4gICAgbG9nZ2VyLmxvZygnTm8gZnJhZyBpbiBwcmV2aW91cyBsZXZlbCB0byBhbGlnbiBvbicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBwcmV2U3RhcnRGcmFnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRqdXN0UHRzIChzbGlkaW5nLCBkZXRhaWxzKSB7XG4gIGRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goKGZyYWcpID0+IHtcbiAgICBpZiAoZnJhZykge1xuICAgICAgbGV0IHN0YXJ0ID0gZnJhZy5zdGFydCArIHNsaWRpbmc7XG4gICAgICBmcmFnLnN0YXJ0ID0gZnJhZy5zdGFydFBUUyA9IHN0YXJ0O1xuICAgICAgZnJhZy5lbmRQVFMgPSBzdGFydCArIGZyYWcuZHVyYXRpb247XG4gICAgfVxuICB9KTtcbiAgZGV0YWlscy5QVFNLbm93biA9IHRydWU7XG59XG5cbi8qKlxuICogVXNpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGxhc3QgbGV2ZWwsIHRoaXMgZnVuY3Rpb24gY29tcHV0ZXMgUFRTJyBvZiB0aGUgbmV3IGZyYWdtZW50cyBzbyB0aGF0IHRoZXkgZm9ybSBhXG4gKiBjb250aWd1b3VzIHN0cmVhbSB3aXRoIHRoZSBsYXN0IGZyYWdtZW50cy5cbiAqIFRoZSBQVFMgb2YgYSBmcmFnbWVudCBsZXRzIEhscy5qcyBrbm93IHdoZXJlIGl0IGZpdHMgaW50byBhIHN0cmVhbSAtIGJ5IGtub3dpbmcgZXZlcnkgUFRTLCB3ZSBrbm93IHdoaWNoIGZyYWdtZW50IHRvXG4gKiBkb3dubG9hZCBhdCBhbnkgZ2l2ZW4gdGltZS4gUFRTIGlzIG5vcm1hbGx5IGNvbXB1dGVkIHdoZW4gdGhlIGZyYWdtZW50IGlzIGRlbXV4ZWQsIHNvIHRha2luZyB0aGlzIHN0ZXAgc2F2ZXMgdXMgdGltZVxuICogYW5kIGFuIGV4dHJhIGRvd25sb2FkLlxuICogQHBhcmFtIGxhc3RGcmFnXG4gKiBAcGFyYW0gbGFzdExldmVsXG4gKiBAcGFyYW0gZGV0YWlsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWxpZ25TdHJlYW0gKGxhc3RGcmFnLCBsYXN0TGV2ZWwsIGRldGFpbHMpIHtcbiAgYWxpZ25EaXNjb250aW51aXRpZXMobGFzdEZyYWcsIGRldGFpbHMsIGxhc3RMZXZlbCk7XG4gIGlmICghZGV0YWlscy5QVFNLbm93biAmJiBsYXN0TGV2ZWwpIHtcbiAgICAvLyBJZiB0aGUgUFRTIHdhc24ndCBmaWd1cmVkIG91dCB2aWEgZGlzY29udGludWl0eSBzZXF1ZW5jZSB0aGF0IG1lYW5zIHRoZXJlIHdhcyBubyBDQyBpbmNyZWFzZSB3aXRoaW4gdGhlIGxldmVsLlxuICAgIC8vIEFsaWduaW5nIHZpYSBQcm9ncmFtIERhdGUgVGltZSBzaG91bGQgdGhlcmVmb3JlIGJlIHJlbGlhYmxlLCBzaW5jZSBQRFQgc2hvdWxkIGJlIHRoZSBzYW1lIHdpdGhpbiB0aGUgc2FtZVxuICAgIC8vIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UuXG4gICAgYWxpZ25QRFQoZGV0YWlscywgbGFzdExldmVsLmRldGFpbHMpO1xuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFBUUyBpZiBhIG5ldyBsZXZlbCdzIGZyYWdtZW50cyB1c2luZyB0aGUgUFRTIG9mIGEgZnJhZ21lbnQgaW4gdGhlIGxhc3QgbGV2ZWwgd2hpY2ggc2hhcmVzIHRoZSBzYW1lXG4gKiBkaXNjb250aW51aXR5IHNlcXVlbmNlLlxuICogQHBhcmFtIGxhc3RMZXZlbCAtIFRoZSBkZXRhaWxzIG9mIHRoZSBsYXN0IGxvYWRlZCBsZXZlbFxuICogQHBhcmFtIGRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgbmV3IGxldmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGlnbkRpc2NvbnRpbnVpdGllcyAobGFzdEZyYWcsIGRldGFpbHMsIGxhc3RMZXZlbCkge1xuICBpZiAoc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgbGFzdExldmVsLCBkZXRhaWxzKSkge1xuICAgIGNvbnN0IHJlZmVyZW5jZUZyYWcgPSBmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWcobGFzdExldmVsLmRldGFpbHMsIGRldGFpbHMpO1xuICAgIGlmIChyZWZlcmVuY2VGcmFnKSB7XG4gICAgICBsb2dnZXIubG9nKCdBZGp1c3RpbmcgUFRTIHVzaW5nIGxhc3QgbGV2ZWwgZHVlIHRvIENDIGluY3JlYXNlIHdpdGhpbiBjdXJyZW50IGxldmVsJyk7XG4gICAgICBhZGp1c3RQdHMocmVmZXJlbmNlRnJhZy5zdGFydCwgZGV0YWlscyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFBUUyBvZiBhIG5ldyBsZXZlbCdzIGZyYWdtZW50cyB1c2luZyB0aGUgZGlmZmVyZW5jZSBpbiBQcm9ncmFtIERhdGUgVGltZSBmcm9tIHRoZSBsYXN0IGxldmVsLlxuICogQHBhcmFtIGRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgbmV3IGxldmVsXG4gKiBAcGFyYW0gbGFzdERldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgbGFzdCBsb2FkZWQgbGV2ZWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFsaWduUERUIChkZXRhaWxzLCBsYXN0RGV0YWlscykge1xuICBpZiAobGFzdERldGFpbHMgJiYgbGFzdERldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgIGlmICghZGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgfHwgIWxhc3REZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpZiBsYXN0IGxldmVsIHNsaWRpbmcgaXMgMTAwMCBhbmQgaXRzIGZpcnN0IGZyYWcgUFJPR1JBTS1EQVRFLVRJTUUgaXMgMjAxNy0wOC0yMCAxOjEwOjAwIEFNXG4gICAgLy8gYW5kIGlmIG5ldyBkZXRhaWxzIGZpcnN0IGZyYWcgUFJPR1JBTSBEQVRFLVRJTUUgaXMgMjAxNy0wOC0yMCAxOjEwOjA4IEFNXG4gICAgLy8gdGhlbiB3ZSBjYW4gZGVkdWNlIHRoYXQgcGxheWxpc3QgQiBzbGlkaW5nIGlzIDEwMDArOCA9IDEwMDhzXG4gICAgbGV0IGxhc3RQRFQgPSBsYXN0RGV0YWlscy5mcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lO1xuICAgIGxldCBuZXdQRFQgPSBkZXRhaWxzLmZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7XG4gICAgLy8gZGF0ZSBkaWZmIGlzIGluIG1zLiBmcmFnLnN0YXJ0IGlzIGluIHNlY29uZHNcbiAgICBsZXQgc2xpZGluZyA9IChuZXdQRFQgLSBsYXN0UERUKSAvIDEwMDAgKyBsYXN0RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShzbGlkaW5nKSkge1xuICAgICAgbG9nZ2VyLmxvZyhgYWRqdXN0aW5nIFBUUyB1c2luZyBwcm9ncmFtRGF0ZVRpbWUgZGVsdGEsIHNsaWRpbmc6JHtzbGlkaW5nLnRvRml4ZWQoMyl9YCk7XG4gICAgICBhZGp1c3RQdHMoc2xpZGluZywgZGV0YWlscyk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogRVdNQSBCYW5kd2lkdGggRXN0aW1hdG9yXG4gKiAgLSBoZWF2aWx5IGluc3BpcmVkIGZyb20gc2hha2EtcGxheWVyXG4gKiBUcmFja3MgYmFuZHdpZHRoIHNhbXBsZXMgYW5kIGVzdGltYXRlcyBhdmFpbGFibGUgYmFuZHdpZHRoLlxuICogQmFzZWQgb24gdGhlIG1pbmltdW0gb2YgdHdvIGV4cG9uZW50aWFsbHktd2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VzIHdpdGhcbiAqIGRpZmZlcmVudCBoYWxmLWxpdmVzLlxuICovXG5cbmltcG9ydCBFV01BIGZyb20gJy4uL3V0aWxzL2V3bWEnO1xuXG5jbGFzcyBFd21hQmFuZFdpZHRoRXN0aW1hdG9yIHtcbiAgY29uc3RydWN0b3IgKGhscywgc2xvdywgZmFzdCwgZGVmYXVsdEVzdGltYXRlKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5kZWZhdWx0RXN0aW1hdGVfID0gZGVmYXVsdEVzdGltYXRlO1xuICAgIHRoaXMubWluV2VpZ2h0XyA9IDAuMDAxO1xuICAgIHRoaXMubWluRGVsYXlNc18gPSA1MDtcbiAgICB0aGlzLnNsb3dfID0gbmV3IEVXTUEoc2xvdyk7XG4gICAgdGhpcy5mYXN0XyA9IG5ldyBFV01BKGZhc3QpO1xuICB9XG5cbiAgc2FtcGxlIChkdXJhdGlvbk1zLCBudW1CeXRlcykge1xuICAgIGR1cmF0aW9uTXMgPSBNYXRoLm1heChkdXJhdGlvbk1zLCB0aGlzLm1pbkRlbGF5TXNfKTtcbiAgICBsZXQgYmFuZHdpZHRoID0gODAwMCAqIG51bUJ5dGVzIC8gZHVyYXRpb25NcyxcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdpbnN0YW50IGJ3OicrIE1hdGgucm91bmQoYmFuZHdpZHRoKSk7XG4gICAgICAvLyB3ZSB3ZWlnaHQgc2FtcGxlIHVzaW5nIGxvYWRpbmcgZHVyYXRpb24uLi4uXG4gICAgICB3ZWlnaHQgPSBkdXJhdGlvbk1zIC8gMTAwMDtcbiAgICB0aGlzLmZhc3RfLnNhbXBsZSh3ZWlnaHQsIGJhbmR3aWR0aCk7XG4gICAgdGhpcy5zbG93Xy5zYW1wbGUod2VpZ2h0LCBiYW5kd2lkdGgpO1xuICB9XG5cbiAgY2FuRXN0aW1hdGUgKCkge1xuICAgIGxldCBmYXN0ID0gdGhpcy5mYXN0XztcbiAgICByZXR1cm4gKGZhc3QgJiYgZmFzdC5nZXRUb3RhbFdlaWdodCgpID49IHRoaXMubWluV2VpZ2h0Xyk7XG4gIH1cblxuICBnZXRFc3RpbWF0ZSAoKSB7XG4gICAgaWYgKHRoaXMuY2FuRXN0aW1hdGUoKSkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ3Nsb3cgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdmYXN0IGVzdGltYXRlOicrIE1hdGgucm91bmQodGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpKSk7XG4gICAgICAvLyBUYWtlIHRoZSBtaW5pbXVtIG9mIHRoZXNlIHR3byBlc3RpbWF0ZXMuICBUaGlzIHNob3VsZCBoYXZlIHRoZSBlZmZlY3Qgb2ZcbiAgICAgIC8vIGFkYXB0aW5nIGRvd24gcXVpY2tseSwgYnV0IHVwIG1vcmUgc2xvd2x5LlxuICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuZmFzdF8uZ2V0RXN0aW1hdGUoKSwgdGhpcy5zbG93Xy5nZXRFc3RpbWF0ZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEVzdGltYXRlXztcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgRXdtYUJhbmRXaWR0aEVzdGltYXRvcjtcbiIsIi8qXG4gKiBjb21wdXRlIGFuIEV4cG9uZW50aWFsIFdlaWdodGVkIG1vdmluZyBhdmVyYWdlXG4gKiAtIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vdmluZ19hdmVyYWdlI0V4cG9uZW50aWFsX21vdmluZ19hdmVyYWdlXG4gKiAgLSBoZWF2aWx5IGluc3BpcmVkIGZyb20gc2hha2EtcGxheWVyXG4gKi9cblxuY2xhc3MgRVdNQSB7XG4gIC8vICBBYm91dCBoYWxmIG9mIHRoZSBlc3RpbWF0ZWQgdmFsdWUgd2lsbCBiZSBmcm9tIHRoZSBsYXN0IHxoYWxmTGlmZXwgc2FtcGxlcyBieSB3ZWlnaHQuXG4gIGNvbnN0cnVjdG9yIChoYWxmTGlmZSkge1xuICAgIC8vIExhcmdlciB2YWx1ZXMgb2YgYWxwaGEgZXhwaXJlIGhpc3RvcmljYWwgZGF0YSBtb3JlIHNsb3dseS5cbiAgICB0aGlzLmFscGhhXyA9IGhhbGZMaWZlID8gTWF0aC5leHAoTWF0aC5sb2coMC41KSAvIGhhbGZMaWZlKSA6IDA7XG4gICAgdGhpcy5lc3RpbWF0ZV8gPSAwO1xuICAgIHRoaXMudG90YWxXZWlnaHRfID0gMDtcbiAgfVxuXG4gIHNhbXBsZSAod2VpZ2h0LCB2YWx1ZSkge1xuICAgIGxldCBhZGpBbHBoYSA9IE1hdGgucG93KHRoaXMuYWxwaGFfLCB3ZWlnaHQpO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gdmFsdWUgKiAoMSAtIGFkakFscGhhKSArIGFkakFscGhhICogdGhpcy5lc3RpbWF0ZV87XG4gICAgdGhpcy50b3RhbFdlaWdodF8gKz0gd2VpZ2h0O1xuICB9XG5cbiAgZ2V0VG90YWxXZWlnaHQgKCkge1xuICAgIHJldHVybiB0aGlzLnRvdGFsV2VpZ2h0XztcbiAgfVxuXG4gIGdldEVzdGltYXRlICgpIHtcbiAgICBpZiAodGhpcy5hbHBoYV8pIHtcbiAgICAgIGxldCB6ZXJvRmFjdG9yID0gMSAtIE1hdGgucG93KHRoaXMuYWxwaGFfLCB0aGlzLnRvdGFsV2VpZ2h0Xyk7XG4gICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV8gLyB6ZXJvRmFjdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZV87XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVXTUE7XG4iLCJleHBvcnQgZnVuY3Rpb24gZ2V0U2VsZlNjb3BlICgpIHtcbiAgLy8gc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTIzNzI1OS81ODk0OTNcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmICovXG4gICAgcmV0dXJuIHNlbGY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxufVxuIiwiaW1wb3J0IHsgZ2V0U2VsZlNjb3BlIH0gZnJvbSAnLi9nZXQtc2VsZi1zY29wZSc7XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuY29uc3QgZmFrZUxvZ2dlciA9IHtcbiAgdHJhY2U6IG5vb3AsXG4gIGRlYnVnOiBub29wLFxuICBsb2c6IG5vb3AsXG4gIHdhcm46IG5vb3AsXG4gIGluZm86IG5vb3AsXG4gIGVycm9yOiBub29wXG59O1xuXG5sZXQgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuXG4vLyBsZXQgbGFzdENhbGxUaW1lO1xuLy8gZnVuY3Rpb24gZm9ybWF0TXNnV2l0aFRpbWVJbmZvKHR5cGUsIG1zZykge1xuLy8gICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuLy8gICBjb25zdCBkaWZmID0gbGFzdENhbGxUaW1lID8gJysnICsgKG5vdyAtIGxhc3RDYWxsVGltZSkgOiAnMCc7XG4vLyAgIGxhc3RDYWxsVGltZSA9IG5vdztcbi8vICAgbXNnID0gKG5ldyBEYXRlKG5vdykpLnRvSVNPU3RyaW5nKCkgKyAnIHwgWycgKyAgdHlwZSArICddID4gJyArIG1zZyArICcgKCAnICsgZGlmZiArICcgbXMgKSc7XG4vLyAgIHJldHVybiBtc2c7XG4vLyB9XG5cbmZ1bmN0aW9uIGZvcm1hdE1zZyAodHlwZSwgbXNnKSB7XG4gIG1zZyA9ICdbJyArIHR5cGUgKyAnXSA+ICcgKyBtc2c7XG4gIHJldHVybiBtc2c7XG59XG5cbmNvbnN0IGdsb2JhbCA9IGdldFNlbGZTY29wZSgpO1xuXG5mdW5jdGlvbiBjb25zb2xlUHJpbnRGbiAodHlwZSkge1xuICBjb25zdCBmdW5jID0gZ2xvYmFsLmNvbnNvbGVbdHlwZV07XG4gIGlmIChmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICBpZiAoYXJnc1swXSkge1xuICAgICAgICBhcmdzWzBdID0gZm9ybWF0TXNnKHR5cGUsIGFyZ3NbMF0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jLmFwcGx5KGdsb2JhbC5jb25zb2xlLCBhcmdzKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBub29wO1xufVxuXG5mdW5jdGlvbiBleHBvcnRMb2dnZXJGdW5jdGlvbnMgKGRlYnVnQ29uZmlnLCAuLi5mdW5jdGlvbnMpIHtcbiAgZnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBleHBvcnRlZExvZ2dlclt0eXBlXSA9IGRlYnVnQ29uZmlnW3R5cGVdID8gZGVidWdDb25maWdbdHlwZV0uYmluZChkZWJ1Z0NvbmZpZykgOiBjb25zb2xlUHJpbnRGbih0eXBlKTtcbiAgfSk7XG59XG5cbmV4cG9ydCB2YXIgZW5hYmxlTG9ncyA9IGZ1bmN0aW9uIChkZWJ1Z0NvbmZpZykge1xuICBpZiAoZGVidWdDb25maWcgPT09IHRydWUgfHwgdHlwZW9mIGRlYnVnQ29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyhkZWJ1Z0NvbmZpZyxcbiAgICAgIC8vIFJlbW92ZSBvdXQgZnJvbSBsaXN0IGhlcmUgdG8gaGFyZC1kaXNhYmxlIGEgbG9nLWxldmVsXG4gICAgICAvLyAndHJhY2UnLFxuICAgICAgJ2RlYnVnJyxcbiAgICAgICdsb2cnLFxuICAgICAgJ2luZm8nLFxuICAgICAgJ3dhcm4nLFxuICAgICAgJ2Vycm9yJ1xuICAgICk7XG4gICAgLy8gU29tZSBicm93c2VycyBkb24ndCBhbGxvdyB0byB1c2UgYmluZCBvbiBjb25zb2xlIG9iamVjdCBhbnl3YXlcbiAgICAvLyBmYWxsYmFjayB0byBkZWZhdWx0IGlmIG5lZWRlZFxuICAgIHRyeSB7XG4gICAgICBleHBvcnRlZExvZ2dlci5sb2coKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcbiAgfVxufTtcblxuZXhwb3J0IHZhciBsb2dnZXIgPSBleHBvcnRlZExvZ2dlcjtcbiIsImNvbnN0IHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyA9IChmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzLmJpbmQod2luZG93Lm5hdmlnYXRvcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0pKCk7XG5cbmV4cG9ydCB7XG4gIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc1xufTtcbiIsIi8qKlxuICogTWVkaWFTb3VyY2UgaGVscGVyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1lZGlhU291cmNlICgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5NZWRpYVNvdXJjZSB8fCB3aW5kb3cuV2ViS2l0TWVkaWFTb3VyY2U7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIE91dHB1dEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICh0aW1lbGluZUNvbnRyb2xsZXIsIHRyYWNrTmFtZSkge1xuICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyID0gdGltZWxpbmVDb250cm9sbGVyO1xuICAgIHRoaXMudHJhY2tOYW1lID0gdHJhY2tOYW1lO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgICB0aGlzLmVuZFRpbWUgPSBudWxsO1xuICAgIHRoaXMuc2NyZWVuID0gbnVsbDtcbiAgfVxuXG4gIGRpc3BhdGNoQ3VlICgpIHtcbiAgICBpZiAodGhpcy5zdGFydFRpbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlci5hZGRDdWVzKHRoaXMudHJhY2tOYW1lLCB0aGlzLnN0YXJ0VGltZSwgdGhpcy5lbmRUaW1lLCB0aGlzLnNjcmVlbik7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICB9XG5cbiAgbmV3Q3VlIChzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbikge1xuICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PT0gbnVsbCB8fCB0aGlzLnN0YXJ0VGltZSA+IHN0YXJ0VGltZSkge1xuICAgICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgfVxuXG4gICAgdGhpcy5lbmRUaW1lID0gZW5kVGltZTtcbiAgICB0aGlzLnNjcmVlbiA9IHNjcmVlbjtcbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlci5jcmVhdGVDYXB0aW9uc1RyYWNrKHRoaXMudHJhY2tOYW1lKTtcbiAgfVxufVxuIiwiXG5leHBvcnQgZnVuY3Rpb24gc2VuZEFkZFRyYWNrRXZlbnQgKHRyYWNrLCB2aWRlb0VsKSB7XG4gIGxldCBldmVudCA9IG51bGw7XG4gIHRyeSB7XG4gICAgZXZlbnQgPSBuZXcgd2luZG93LkV2ZW50KCdhZGR0cmFjaycpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBmb3IgSUUxMVxuICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KCdhZGR0cmFjaycsIGZhbHNlLCBmYWxzZSk7XG4gIH1cbiAgZXZlbnQudHJhY2sgPSB0cmFjaztcbiAgdmlkZW9FbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyQ3VycmVudEN1ZXMgKHRyYWNrKSB7XG4gIGlmICh0cmFjayAmJiB0cmFjay5jdWVzKSB7XG4gICAgd2hpbGUgKHRyYWNrLmN1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdHJhY2sucmVtb3ZlQ3VlKHRyYWNrLmN1ZXNbMF0pO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiAgVGltZVJhbmdlcyB0byBzdHJpbmcgaGVscGVyXG4gKi9cblxuY29uc3QgVGltZVJhbmdlcyA9IHtcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uIChyKSB7XG4gICAgbGV0IGxvZyA9ICcnLCBsZW4gPSByLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsb2cgKz0gJ1snICsgci5zdGFydChpKS50b0ZpeGVkKDMpICsgJywnICsgci5lbmQoaSkudG9GaXhlZCgzKSArICddJztcbiAgICB9XG5cbiAgICByZXR1cm4gbG9nO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBUaW1lUmFuZ2VzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyB2dHQuanMgQ29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZUVEN1ZSkge1xuICAgIHJldHVybiB3aW5kb3cuVlRUQ3VlO1xuICB9XG5cbiAgbGV0IGF1dG9LZXl3b3JkID0gJ2F1dG8nO1xuICBsZXQgZGlyZWN0aW9uU2V0dGluZyA9IHtcbiAgICAnJzogdHJ1ZSxcbiAgICBscjogdHJ1ZSxcbiAgICBybDogdHJ1ZVxuICB9O1xuICBsZXQgYWxpZ25TZXR0aW5nID0ge1xuICAgIHN0YXJ0OiB0cnVlLFxuICAgIG1pZGRsZTogdHJ1ZSxcbiAgICBlbmQ6IHRydWUsXG4gICAgbGVmdDogdHJ1ZSxcbiAgICByaWdodDogdHJ1ZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGZpbmREaXJlY3Rpb25TZXR0aW5nICh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGRpciA9IGRpcmVjdGlvblNldHRpbmdbdmFsdWUudG9Mb3dlckNhc2UoKV07XG4gICAgcmV0dXJuIGRpciA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRBbGlnblNldHRpbmcgKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgYWxpZ24gPSBhbGlnblNldHRpbmdbdmFsdWUudG9Mb3dlckNhc2UoKV07XG4gICAgcmV0dXJuIGFsaWduID8gdmFsdWUudG9Mb3dlckNhc2UoKSA6IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kIChvYmopIHtcbiAgICBsZXQgaSA9IDE7XG4gICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBjb2JqID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yIChsZXQgcCBpbiBjb2JqKSB7XG4gICAgICAgIG9ialtwXSA9IGNvYmpbcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIFZUVEN1ZSAoc3RhcnRUaW1lLCBlbmRUaW1lLCB0ZXh0KSB7XG4gICAgbGV0IGN1ZSA9IHRoaXM7XG4gICAgbGV0IGlzSUU4ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoL01TSUVcXHM4XFwuMC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfSkoKTtcbiAgICBsZXQgYmFzZU9iaiA9IHt9O1xuXG4gICAgaWYgKGlzSUU4KSB7XG4gICAgICBjdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZU9iai5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaGltIGltcGxlbWVudGF0aW9uIHNwZWNpZmljIHByb3BlcnRpZXMuIFRoZXNlIHByb3BlcnRpZXMgYXJlIG5vdCBpblxuICAgICAqIHRoZSBzcGVjLlxuICAgICAqL1xuXG4gICAgLy8gTGV0cyB1cyBrbm93IHdoZW4gdGhlIFZUVEN1ZSdzIGRhdGEgaGFzIGNoYW5nZWQgaW4gc3VjaCBhIHdheSB0aGF0IHdlIG5lZWRcbiAgICAvLyB0byByZWNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGUuIFRoaXMgbGV0cyB1cyBjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlXG4gICAgLy8gbGF6aWx5LlxuICAgIGN1ZS5oYXNCZWVuUmVzZXQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFZUVEN1ZSBhbmQgVGV4dFRyYWNrQ3VlIHByb3BlcnRpZXNcbiAgICAgKiBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJ2dHQvI3Z0dGN1ZS1pbnRlcmZhY2VcbiAgICAgKi9cblxuICAgIGxldCBfaWQgPSAnJztcbiAgICBsZXQgX3BhdXNlT25FeGl0ID0gZmFsc2U7XG4gICAgbGV0IF9zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgbGV0IF9lbmRUaW1lID0gZW5kVGltZTtcbiAgICBsZXQgX3RleHQgPSB0ZXh0O1xuICAgIGxldCBfcmVnaW9uID0gbnVsbDtcbiAgICBsZXQgX3ZlcnRpY2FsID0gJyc7XG4gICAgbGV0IF9zbmFwVG9MaW5lcyA9IHRydWU7XG4gICAgbGV0IF9saW5lID0gJ2F1dG8nO1xuICAgIGxldCBfbGluZUFsaWduID0gJ3N0YXJ0JztcbiAgICBsZXQgX3Bvc2l0aW9uID0gNTA7XG4gICAgbGV0IF9wb3NpdGlvbkFsaWduID0gJ21pZGRsZSc7XG4gICAgbGV0IF9zaXplID0gNTA7XG4gICAgbGV0IF9hbGlnbiA9ICdtaWRkbGUnO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2lkJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9pZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfaWQgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwYXVzZU9uRXhpdCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfcGF1c2VPbkV4aXQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3BhdXNlT25FeGl0ID0gISF2YWx1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc3RhcnRUaW1lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zdGFydFRpbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdGFydCB0aW1lIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3N0YXJ0VGltZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2VuZFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2VuZFRpbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9lbmRUaW1lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndGV4dCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGV4dDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBfdGV4dCA9ICcnICsgdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncmVnaW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdpb247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3JlZ2lvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3ZlcnRpY2FsJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF92ZXJ0aWNhbDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBsZXQgc2V0dGluZyA9IGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgLy8gSGF2ZSB0byBjaGVjayBmb3IgZmFsc2UgYmVjYXVzZSB0aGUgc2V0dGluZyBhbiBiZSBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICAgIGlmIChzZXR0aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3ZlcnRpY2FsID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzbmFwVG9MaW5lcycsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc25hcFRvTGluZXM7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3NuYXBUb0xpbmVzID0gISF2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdsaW5lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9saW5lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInICYmIHZhbHVlICE9PSBhdXRvS2V5d29yZCkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBudW1iZXIgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9saW5lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnbGluZUFsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9saW5lQWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgbGV0IHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfbGluZUFsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwb3NpdGlvbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfcG9zaXRpb247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9zaXRpb24gbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uQWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uQWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgbGV0IHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfcG9zaXRpb25BbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc2l6ZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaXplIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfc2l6ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2FsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9hbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBsZXQgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9hbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICAvKipcbiAgICAgKiBPdGhlciA8dHJhY2s+IHNwZWMgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgICovXG5cbiAgICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtdmlkZW8tZWxlbWVudC5odG1sI3RleHQtdHJhY2stY3VlLWRpc3BsYXktc3RhdGVcbiAgICBjdWUuZGlzcGxheVN0YXRlID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGlzSUU4KSB7XG4gICAgICByZXR1cm4gY3VlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWVFRDdWUgbWV0aG9kc1xuICAgKi9cblxuICBWVFRDdWUucHJvdG90eXBlLmdldEN1ZUFzSFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBBc3N1bWUgV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUgaXMgb24gdGhlIGdsb2JhbC5cbiAgICBsZXQgV2ViVlRUID0gd2luZG93LldlYlZUVDtcbiAgICByZXR1cm4gV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUod2luZG93LCB0aGlzLnRleHQpO1xuICB9O1xuXG4gIHJldHVybiBWVFRDdWU7XG59KSgpO1xuIiwiLypcbiAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvdnR0LmpzL2Jsb2IvbWFzdGVyL2Rpc3QvdnR0LmpzI0wxNzE2XG4gKi9cblxuaW1wb3J0IFZUVEN1ZSBmcm9tICcuL3Z0dGN1ZSc7XG5cbmNvbnN0IFN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbiBTdHJpbmdEZWNvZGVyICgpIHtcbiAgcmV0dXJuIHtcbiAgICBkZWNvZGU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgLSBleHBlY3RlZCBzdHJpbmcgZGF0YS4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoZGF0YSkpO1xuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIFZUVFBhcnNlciAoKSB7XG4gIHRoaXMud2luZG93ID0gd2luZG93O1xuICB0aGlzLnN0YXRlID0gJ0lOSVRJQUwnO1xuICB0aGlzLmJ1ZmZlciA9ICcnO1xuICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcigpO1xuICB0aGlzLnJlZ2lvbkxpc3QgPSBbXTtcbn1cblxuLy8gVHJ5IHRvIHBhcnNlIGlucHV0IGFzIGEgdGltZSBzdGFtcC5cbmZ1bmN0aW9uIHBhcnNlVGltZVN0YW1wIChpbnB1dCkge1xuICBmdW5jdGlvbiBjb21wdXRlU2Vjb25kcyAoaCwgbSwgcywgZikge1xuICAgIHJldHVybiAoaCB8IDApICogMzYwMCArIChtIHwgMCkgKiA2MCArIChzIHwgMCkgKyAoZiB8IDApIC8gMTAwMDtcbiAgfVxuXG4gIGxldCBtID0gaW5wdXQubWF0Y2goL14oXFxkKyk6KFxcZHsyfSkoOlxcZHsyfSk/XFwuKFxcZHszfSkvKTtcbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAobVszXSkge1xuICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnNdOlttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsxXSwgbVsyXSwgbVszXS5yZXBsYWNlKCc6JywgJycpLCBtWzRdKTtcbiAgfSBlbHNlIGlmIChtWzFdID4gNTkpIHtcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzXTpbbWludXRlc10uW21pbGxpc2Vjb25kc11cbiAgICAvLyBGaXJzdCBwb3NpdGlvbiBpcyBob3VycyBhcyBpdCdzIG92ZXIgNTkuXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIDAsIG1bNF0pO1xuICB9IGVsc2Uge1xuICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbbWludXRlc106W3NlY29uZHNdLlttaWxsaXNlY29uZHNdXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKDAsIG1bMV0sIG1bMl0sIG1bNF0pO1xuICB9XG59XG5cbi8vIEEgc2V0dGluZ3Mgb2JqZWN0IGhvbGRzIGtleS92YWx1ZSBwYWlycyBhbmQgd2lsbCBpZ25vcmUgYW55dGhpbmcgYnV0IHRoZSBmaXJzdFxuLy8gYXNzaWdubWVudCB0byBhIHNwZWNpZmljIGtleS5cbmZ1bmN0aW9uIFNldHRpbmdzICgpIHtcbiAgdGhpcy52YWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG5TZXR0aW5ncy5wcm90b3R5cGUgPSB7XG4gIC8vIE9ubHkgYWNjZXB0IHRoZSBmaXJzdCBhc3NpZ25tZW50IHRvIGFueSBrZXkuXG4gIHNldDogZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAoIXRoaXMuZ2V0KGspICYmIHYgIT09ICcnKSB7XG4gICAgICB0aGlzLnZhbHVlc1trXSA9IHY7XG4gICAgfVxuICB9LFxuICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciBhIGtleSwgb3IgYSBkZWZhdWx0IHZhbHVlLlxuICAvLyBJZiAnZGVmYXVsdEtleScgaXMgcGFzc2VkIHRoZW4gJ2RmbHQnIGlzIGFzc3VtZWQgdG8gYmUgYW4gb2JqZWN0IHdpdGhcbiAgLy8gYSBudW1iZXIgb2YgcG9zc2libGUgZGVmYXVsdCB2YWx1ZXMgYXMgcHJvcGVydGllcyB3aGVyZSAnZGVmYXVsdEtleScgaXNcbiAgLy8gdGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIGNob3Nlbjsgb3RoZXJ3aXNlIGl0J3MgYXNzdW1lZCB0byBiZVxuICAvLyBhIHNpbmdsZSB2YWx1ZS5cbiAgZ2V0OiBmdW5jdGlvbiAoaywgZGZsdCwgZGVmYXVsdEtleSkge1xuICAgIGlmIChkZWZhdWx0S2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHRbZGVmYXVsdEtleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0O1xuICB9LFxuICAvLyBDaGVjayB3aGV0aGVyIHdlIGhhdmUgYSB2YWx1ZSBmb3IgYSBrZXkuXG4gIGhhczogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayBpbiB0aGlzLnZhbHVlcztcbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgb25lIG9mIHRoZSBnaXZlbiBhbHRlcm5hdGl2ZXMuXG4gIGFsdDogZnVuY3Rpb24gKGssIHYsIGEpIHtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IGEubGVuZ3RoOyArK24pIHtcbiAgICAgIGlmICh2ID09PSBhW25dKSB7XG4gICAgICAgIHRoaXMuc2V0KGssIHYpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIGEgdmFsaWQgKHNpZ25lZCkgaW50ZWdlci5cbiAgaW50ZWdlcjogZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAoL14tP1xcZCskLy50ZXN0KHYpKSB7IC8vIGludGVnZXJcbiAgICAgIHRoaXMuc2V0KGssIHBhcnNlSW50KHYsIDEwKSk7XG4gICAgfVxuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIHBlcmNlbnRhZ2UuXG4gIHBlcmNlbnQ6IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgbGV0IG07XG4gICAgaWYgKChtID0gdi5tYXRjaCgvXihbXFxkXXsxLDN9KShcXC5bXFxkXSopPyUkLykpKSB7XG4gICAgICB2ID0gcGFyc2VGbG9hdCh2KTtcbiAgICAgIGlmICh2ID49IDAgJiYgdiA8PSAxMDApIHtcbiAgICAgICAgdGhpcy5zZXQoaywgdik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBpbnB1dCBpbnRvIGdyb3VwcyBzZXBhcmF0ZWQgYnkgJ2dyb3VwRGVsaW0nLCBhbmRcbi8vIGludGVycHJldGUgZWFjaCBncm91cCBhcyBhIGtleS92YWx1ZSBwYWlyIHNlcGFyYXRlZCBieSAna2V5VmFsdWVEZWxpbScuXG5mdW5jdGlvbiBwYXJzZU9wdGlvbnMgKGlucHV0LCBjYWxsYmFjaywga2V5VmFsdWVEZWxpbSwgZ3JvdXBEZWxpbSkge1xuICBsZXQgZ3JvdXBzID0gZ3JvdXBEZWxpbSA/IGlucHV0LnNwbGl0KGdyb3VwRGVsaW0pIDogW2lucHV0XTtcbiAgZm9yIChsZXQgaSBpbiBncm91cHMpIHtcbiAgICBpZiAodHlwZW9mIGdyb3Vwc1tpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCBrdiA9IGdyb3Vwc1tpXS5zcGxpdChrZXlWYWx1ZURlbGltKTtcbiAgICBpZiAoa3YubGVuZ3RoICE9PSAyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBsZXQgayA9IGt2WzBdO1xuICAgIGxldCB2ID0ga3ZbMV07XG4gICAgY2FsbGJhY2soaywgdik7XG4gIH1cbn1cblxubGV0IGRlZmF1bHRzID0gbmV3IFZUVEN1ZSgwLCAwLCAwKTtcbi8vICdtaWRkbGUnIHdhcyBjaGFuZ2VkIHRvICdjZW50ZXInIGluIHRoZSBzcGVjOiBodHRwczovL2dpdGh1Yi5jb20vdzNjL3dlYnZ0dC9wdWxsLzI0NFxuLy8gIFNhZmFyaSBkb2Vzbid0IHlldCBzdXBwb3J0IHRoaXMgY2hhbmdlLCBidXQgRkYgYW5kIENocm9tZSBkby5cbmxldCBjZW50ZXIgPSBkZWZhdWx0cy5hbGlnbiA9PT0gJ21pZGRsZScgPyAnbWlkZGxlJyA6ICdjZW50ZXInO1xuXG5mdW5jdGlvbiBwYXJzZUN1ZSAoaW5wdXQsIGN1ZSwgcmVnaW9uTGlzdCkge1xuICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgaW5wdXQgaWYgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvci5cbiAgbGV0IG9JbnB1dCA9IGlucHV0O1xuICAvLyA0LjEgV2ViVlRUIHRpbWVzdGFtcFxuICBmdW5jdGlvbiBjb25zdW1lVGltZVN0YW1wICgpIHtcbiAgICBsZXQgdHMgPSBwYXJzZVRpbWVTdGFtcChpbnB1dCk7XG4gICAgaWYgKHRzID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCB0aW1lc3RhbXA6ICcgKyBvSW5wdXQpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSB0aW1lIHN0YW1wIGZyb20gaW5wdXQuXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eW15cXHNhLXpBLVotXSsvLCAnJyk7XG4gICAgcmV0dXJuIHRzO1xuICB9XG5cbiAgLy8gNC40LjIgV2ViVlRUIGN1ZSBzZXR0aW5nc1xuICBmdW5jdGlvbiBjb25zdW1lQ3VlU2V0dGluZ3MgKGlucHV0LCBjdWUpIHtcbiAgICBsZXQgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcblxuICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgIHN3aXRjaCAoaykge1xuICAgICAgY2FzZSAncmVnaW9uJzpcbiAgICAgICAgLy8gRmluZCB0aGUgbGFzdCByZWdpb24gd2UgcGFyc2VkIHdpdGggdGhlIHNhbWUgcmVnaW9uIGlkLlxuICAgICAgICBmb3IgKGxldCBpID0gcmVnaW9uTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChyZWdpb25MaXN0W2ldLmlkID09PSB2KSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5zZXQoaywgcmVnaW9uTGlzdFtpXS5yZWdpb24pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgWydybCcsICdsciddKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsaW5lJzpcbiAgICAgICAgdmFyIHZhbHMgPSB2LnNwbGl0KCcsJyksXG4gICAgICAgICAgdmFsczAgPSB2YWxzWzBdO1xuICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGssIHZhbHMwKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLnBlcmNlbnQoaywgdmFsczApKSB7XG4gICAgICAgICAgc2V0dGluZ3Muc2V0KCdzbmFwVG9MaW5lcycsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRpbmdzLmFsdChrLCB2YWxzMCwgWydhdXRvJ10pO1xuICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoJ2xpbmVBbGlnbicsIHZhbHNbMV0sIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnXSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Bvc2l0aW9uJzpcbiAgICAgICAgdmFscyA9IHYuc3BsaXQoJywnKTtcbiAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2YWxzWzBdKTtcbiAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KCdwb3NpdGlvbkFsaWduJywgdmFsc1sxXSwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCcsICdsaW5lLWxlZnQnLCAnbGluZS1yaWdodCcsICdhdXRvJ10pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzaXplJzpcbiAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhbGlnbic6XG4gICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJywgJ2xlZnQnLCAncmlnaHQnXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0sIC86LywgL1xccy8pO1xuXG4gICAgLy8gQXBwbHkgZGVmYXVsdCB2YWx1ZXMgZm9yIGFueSBtaXNzaW5nIGZpZWxkcy5cbiAgICBjdWUucmVnaW9uID0gc2V0dGluZ3MuZ2V0KCdyZWdpb24nLCBudWxsKTtcbiAgICBjdWUudmVydGljYWwgPSBzZXR0aW5ncy5nZXQoJ3ZlcnRpY2FsJywgJycpO1xuICAgIGxldCBsaW5lID0gc2V0dGluZ3MuZ2V0KCdsaW5lJywgJ2F1dG8nKTtcbiAgICBpZiAobGluZSA9PT0gJ2F1dG8nICYmIGRlZmF1bHRzLmxpbmUgPT09IC0xKSB7XG4gICAgICAvLyBzZXQgbnVtZXJpYyBsaW5lIG51bWJlciBmb3IgU2FmYXJpXG4gICAgICBsaW5lID0gLTE7XG4gICAgfVxuICAgIGN1ZS5saW5lID0gbGluZTtcbiAgICBjdWUubGluZUFsaWduID0gc2V0dGluZ3MuZ2V0KCdsaW5lQWxpZ24nLCAnc3RhcnQnKTtcbiAgICBjdWUuc25hcFRvTGluZXMgPSBzZXR0aW5ncy5nZXQoJ3NuYXBUb0xpbmVzJywgdHJ1ZSk7XG4gICAgY3VlLnNpemUgPSBzZXR0aW5ncy5nZXQoJ3NpemUnLCAxMDApO1xuICAgIGN1ZS5hbGlnbiA9IHNldHRpbmdzLmdldCgnYWxpZ24nLCBjZW50ZXIpO1xuICAgIGxldCBwb3NpdGlvbiA9IHNldHRpbmdzLmdldCgncG9zaXRpb24nLCAnYXV0bycpO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2F1dG8nICYmIGRlZmF1bHRzLnBvc2l0aW9uID09PSA1MCkge1xuICAgICAgLy8gc2V0IG51bWVyaWMgcG9zaXRpb24gZm9yIFNhZmFyaVxuICAgICAgcG9zaXRpb24gPSBjdWUuYWxpZ24gPT09ICdzdGFydCcgfHwgY3VlLmFsaWduID09PSAnbGVmdCcgPyAwIDogY3VlLmFsaWduID09PSAnZW5kJyB8fCBjdWUuYWxpZ24gPT09ICdyaWdodCcgPyAxMDAgOiA1MDtcbiAgICB9XG4gICAgY3VlLnBvc2l0aW9uID0gcG9zaXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSAoKSB7XG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eXFxzKy8sICcnKTtcbiAgfVxuXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHRpbWluZ3MuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGN1ZS5zdGFydFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7IC8vICgxKSBjb2xsZWN0IGN1ZSBzdGFydCB0aW1lXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGlmIChpbnB1dC5zdWJzdHIoMCwgMykgIT09ICctLT4nKSB7IC8vICgzKSBuZXh0IGNoYXJhY3RlcnMgbXVzdCBtYXRjaCAnLS0+J1xuICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIHRpbWUgc3RhbXAgKHRpbWUgc3RhbXBzIG11c3QgYmUgc2VwYXJhdGVkIGJ5IFxcJy0tPlxcJyk6ICcgK1xuICAgICAgb0lucHV0KTtcbiAgfVxuICBpbnB1dCA9IGlucHV0LnN1YnN0cigzKTtcbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY3VlLmVuZFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7IC8vICg1KSBjb2xsZWN0IGN1ZSBlbmQgdGltZVxuXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHNldHRpbmdzIGxpc3QuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKTtcbn1cblxuZnVuY3Rpb24gZml4TGluZUJyZWFrcyAoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0LnJlcGxhY2UoLzxicig/OiBcXC8pPz4vZ2ksICdcXG4nKTtcbn1cblxuVlRUUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgcGFyc2U6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gZGF0YSB0aGVuIHdlIHdvbid0IGRlY29kZSBpdCwgYnV0IHdpbGwganVzdCB0cnkgdG8gcGFyc2VcbiAgICAvLyB3aGF0ZXZlciBpcyBpbiBidWZmZXIgYWxyZWFkeS4gVGhpcyBtYXkgb2NjdXIgaW4gY2lyY3Vtc3RhbmNlcywgZm9yXG4gICAgLy8gZXhhbXBsZSB3aGVuIGZsdXNoKCkgaXMgY2FsbGVkLlxuICAgIGlmIChkYXRhKSB7XG4gICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoZSBkYXRhIHRoYXQgd2UgcmVjZWl2ZWQuXG4gICAgICBzZWxmLmJ1ZmZlciArPSBzZWxmLmRlY29kZXIuZGVjb2RlKGRhdGEsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxlY3ROZXh0TGluZSAoKSB7XG4gICAgICBsZXQgYnVmZmVyID0gc2VsZi5idWZmZXI7XG4gICAgICBsZXQgcG9zID0gMDtcblxuICAgICAgYnVmZmVyID0gZml4TGluZUJyZWFrcyhidWZmZXIpO1xuXG4gICAgICB3aGlsZSAocG9zIDwgYnVmZmVyLmxlbmd0aCAmJiBidWZmZXJbcG9zXSAhPT0gJ1xccicgJiYgYnVmZmVyW3Bvc10gIT09ICdcXG4nKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuXG4gICAgICBsZXQgbGluZSA9IGJ1ZmZlci5zdWJzdHIoMCwgcG9zKTtcbiAgICAgIC8vIEFkdmFuY2UgdGhlIGJ1ZmZlciBlYXJseSBpbiBjYXNlIHdlIGZhaWwgYmVsb3cuXG4gICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXHInKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXG4nKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmJ1ZmZlciA9IGJ1ZmZlci5zdWJzdHIocG9zKTtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cblxuICAgIC8vIDMuMiBXZWJWVFQgbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVyIChpbnB1dCkge1xuICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgY2FzZSAnUmVnaW9uJzpcbiAgICAgICAgICAvLyAzLjMgV2ViVlRUIHJlZ2lvbiBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3BhcnNlIHJlZ2lvbicsIHYpO1xuICAgICAgICAgIC8vIHBhcnNlUmVnaW9uKHYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LCAvOi8pO1xuICAgIH1cblxuICAgIC8vIDUuMSBXZWJWVFQgZmlsZSBwYXJzaW5nLlxuICAgIHRyeSB7XG4gICAgICBsZXQgbGluZTtcbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSAnSU5JVElBTCcpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3Qgc3RhcnQgcGFyc2luZyB1bnRpbCB3ZSBoYXZlIHRoZSBmaXJzdCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KHNlbGYuYnVmZmVyKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuICAgICAgICAvLyBzdHJpcCBvZiBVVEYtOCBCT00gaWYgYW55XG4gICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0J5dGVfb3JkZXJfbWFyayNVVEYtOFxuICAgICAgICBsZXQgbSA9IGxpbmUubWF0Y2goL14ow6/Cu8K/KT9XRUJWVFQoWyBcXHRdLiopPyQvKTtcbiAgICAgICAgaWYgKCFtIHx8ICFtWzBdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgV2ViVlRUIHNpZ25hdHVyZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuc3RhdGUgPSAnSEVBREVSJztcbiAgICAgIH1cblxuICAgICAgbGV0IGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICB3aGlsZSAoc2VsZi5idWZmZXIpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3QgcGFyc2UgYSBsaW5lIHVudGlsIHdlIGhhdmUgdGhlIGZ1bGwgbGluZS5cbiAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChzZWxmLmJ1ZmZlcikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWxyZWFkeUNvbGxlY3RlZExpbmUpIHtcbiAgICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoc2VsZi5zdGF0ZSkge1xuICAgICAgICBjYXNlICdIRUFERVInOlxuICAgICAgICAgIC8vIDEzLTE4IC0gQWxsb3cgYSBoZWFkZXIgKG1ldGFkYXRhKSB1bmRlciB0aGUgV0VCVlRUIGxpbmUuXG4gICAgICAgICAgaWYgKC86Ly50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICBwYXJzZUhlYWRlcihsaW5lKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAvLyBBbiBlbXB0eSBsaW5lIHRlcm1pbmF0ZXMgdGhlIGhlYWRlciBhbmQgc3RhcnRzIHRoZSBib2R5IChjdWVzKS5cbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSAnTk9URSc6XG4gICAgICAgICAgLy8gSWdub3JlIE5PVEUgYmxvY2tzLlxuICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgJ0lEJzpcbiAgICAgICAgICAvLyBDaGVjayBmb3IgdGhlIHN0YXJ0IG9mIE5PVEUgYmxvY2tzLlxuICAgICAgICAgIGlmICgvXk5PVEUoJHxbIFxcdF0pLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gJ05PVEUnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIDE5LTI5IC0gQWxsb3cgYW55IG51bWJlciBvZiBsaW5lIHRlcm1pbmF0b3JzLCB0aGVuIGluaXRpYWxpemUgbmV3IGN1ZSB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLmN1ZSA9IG5ldyBWVFRDdWUoMCwgMCwgJycpO1xuICAgICAgICAgIHNlbGYuc3RhdGUgPSAnQ1VFJztcbiAgICAgICAgICAvLyAzMC0zOSAtIENoZWNrIGlmIHNlbGYgbGluZSBjb250YWlucyBhbiBvcHRpb25hbCBpZGVudGlmaWVyIG9yIHRpbWluZyBkYXRhLlxuICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJy0tPicpID09PSAtMSkge1xuICAgICAgICAgICAgc2VsZi5jdWUuaWQgPSBsaW5lO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFByb2Nlc3MgbGluZSBhcyBzdGFydCBvZiBhIGN1ZS5cbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ0NVRSc6XG4gICAgICAgICAgLy8gNDAgLSBDb2xsZWN0IGN1ZSB0aW1pbmdzIGFuZCBzZXR0aW5ncy5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyc2VDdWUobGluZSwgc2VsZi5jdWUsIHNlbGYucmVnaW9uTGlzdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiBhbiBlcnJvciBpZ25vcmUgcmVzdCBvZiB0aGUgY3VlLlxuICAgICAgICAgICAgc2VsZi5jdWUgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdCQURDVUUnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuc3RhdGUgPSAnQ1VFVEVYVCc7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgJ0NVRVRFWFQnOlxuICAgICAgICAgIHZhciBoYXNTdWJzdHJpbmcgPSBsaW5lLmluZGV4T2YoJy0tPicpICE9PSAtMTtcbiAgICAgICAgICAvLyAzNCAtIElmIHdlIGhhdmUgYW4gZW1wdHkgbGluZSB0aGVuIHJlcG9ydCB0aGUgY3VlLlxuICAgICAgICAgIC8vIDM1IC0gSWYgd2UgaGF2ZSB0aGUgc3BlY2lhbCBzdWJzdHJpbmcgJy0tPicgdGhlbiByZXBvcnQgdGhlIGN1ZSxcbiAgICAgICAgICAvLyBidXQgZG8gbm90IGNvbGxlY3QgdGhlIGxpbmUgYXMgd2UgbmVlZCB0byBwcm9jZXNzIHRoZSBjdXJyZW50XG4gICAgICAgICAgLy8gb25lIGFzIGEgbmV3IGN1ZS5cbiAgICAgICAgICBpZiAoIWxpbmUgfHwgaGFzU3Vic3RyaW5nICYmIChhbHJlYWR5Q29sbGVjdGVkTGluZSA9IHRydWUpKSB7XG4gICAgICAgICAgICAvLyBXZSBhcmUgZG9uZSBwYXJzaW5nIHNlbGYgY3VlLlxuICAgICAgICAgICAgaWYgKHNlbGYub25jdWUpIHtcbiAgICAgICAgICAgICAgc2VsZi5vbmN1ZShzZWxmLmN1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWxmLmN1ZS50ZXh0KSB7XG4gICAgICAgICAgICBzZWxmLmN1ZS50ZXh0ICs9ICdcXG4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuY3VlLnRleHQgKz0gbGluZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSAnQkFEQ1VFJzogLy8gQkFEQ1VFXG4gICAgICAgICAgLy8gNTQtNjIgLSBDb2xsZWN0IGFuZCBkaXNjYXJkIHRoZSByZW1haW5pbmcgY3VlLlxuICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IHBhcnNpbmcgYSBjdWUsIHJlcG9ydCB3aGF0IHdlIGhhdmUuXG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gJ0NVRVRFWFQnICYmIHNlbGYuY3VlICYmIHNlbGYub25jdWUpIHtcbiAgICAgICAgc2VsZi5vbmN1ZShzZWxmLmN1ZSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgIC8vIEVudGVyIEJBRFdFQlZUVCBzdGF0ZSBpZiBoZWFkZXIgd2FzIG5vdCBwYXJzZWQgY29ycmVjdGx5IG90aGVyd2lzZVxuICAgICAgLy8gYW5vdGhlciBleGNlcHRpb24gb2NjdXJyZWQgc28gZW50ZXIgQkFEQ1VFIHN0YXRlLlxuICAgICAgc2VsZi5zdGF0ZSA9IHNlbGYuc3RhdGUgPT09ICdJTklUSUFMJyA/ICdCQURXRUJWVFQnIDogJ0JBRENVRSc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBmbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgLy8gRmluaXNoIGRlY29kaW5nIHRoZSBzdHJlYW0uXG4gICAgICBzZWxmLmJ1ZmZlciArPSBzZWxmLmRlY29kZXIuZGVjb2RlKCk7XG4gICAgICAvLyBTeW50aGVzaXplIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgY3VlIG9yIHJlZ2lvbi5cbiAgICAgIGlmIChzZWxmLmN1ZSB8fCBzZWxmLnN0YXRlID09PSAnSEVBREVSJykge1xuICAgICAgICBzZWxmLmJ1ZmZlciArPSAnXFxuXFxuJztcbiAgICAgICAgc2VsZi5wYXJzZSgpO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UndmUgZmx1c2hlZCwgcGFyc2VkLCBhbmQgd2UncmUgc3RpbGwgb24gdGhlIElOSVRJQUwgc3RhdGUgdGhlblxuICAgICAgLy8gdGhhdCBtZWFucyB3ZSBkb24ndCBoYXZlIGVub3VnaCBvZiB0aGUgc3RyZWFtIHRvIHBhcnNlIHRoZSBmaXJzdFxuICAgICAgLy8gbGluZS5cbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSAnSU5JVElBTCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgV2ViVlRUIHNpZ25hdHVyZS4nKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBpZiAoc2VsZi5vbmZsdXNoKSB7XG4gICAgICBzZWxmLm9uZmx1c2goKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuZXhwb3J0IHsgZml4TGluZUJyZWFrcyB9O1xuXG5leHBvcnQgZGVmYXVsdCBWVFRQYXJzZXI7XG4iLCJpbXBvcnQgVlRUUGFyc2VyIGZyb20gJy4vdnR0cGFyc2VyJztcbmltcG9ydCB7IHV0ZjhBcnJheVRvU3RyIH0gZnJvbSAnLi4vZGVtdXgvaWQzJztcblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gSUUxMVxuY29uc3Qgc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChpbnB1dFN0cmluZywgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICByZXR1cm4gaW5wdXRTdHJpbmcuc3Vic3RyKHBvc2l0aW9uIHx8IDAsIHNlYXJjaFN0cmluZy5sZW5ndGgpID09PSBzZWFyY2hTdHJpbmc7XG59O1xuXG5jb25zdCBjdWVTdHJpbmcybWlsbGlzID0gZnVuY3Rpb24gKHRpbWVTdHJpbmcpIHtcbiAgbGV0IHRzID0gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoLTMpKTtcbiAgbGV0IHNlY3MgPSBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cigtNiwgMikpO1xuICBsZXQgbWlucyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKC05LCAyKSk7XG4gIGxldCBob3VycyA9IHRpbWVTdHJpbmcubGVuZ3RoID4gOSA/IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKDAsIHRpbWVTdHJpbmcuaW5kZXhPZignOicpKSkgOiAwO1xuXG4gIGlmICghTnVtYmVyLmlzRmluaXRlKHRzKSB8fCAhTnVtYmVyLmlzRmluaXRlKHNlY3MpIHx8ICFOdW1iZXIuaXNGaW5pdGUobWlucykgfHwgIU51bWJlci5pc0Zpbml0ZShob3VycykpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICB0cyArPSAxMDAwICogc2VjcztcbiAgdHMgKz0gNjAgKiAxMDAwICogbWlucztcbiAgdHMgKz0gNjAgKiA2MCAqIDEwMDAgKiBob3VycztcblxuICByZXR1cm4gdHM7XG59O1xuXG4vLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJrc2t5YXBwL3N0cmluZy1oYXNoXG5jb25zdCBoYXNoID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgbGV0IGhhc2ggPSA1MzgxO1xuICBsZXQgaSA9IHRleHQubGVuZ3RoO1xuICB3aGlsZSAoaSkge1xuICAgIGhhc2ggPSAoaGFzaCAqIDMzKSBeIHRleHQuY2hhckNvZGVBdCgtLWkpO1xuICB9XG5cbiAgcmV0dXJuIChoYXNoID4+PiAwKS50b1N0cmluZygpO1xufTtcblxuY29uc3QgY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKHZ0dENDcywgY2MsIHByZXNlbnRhdGlvblRpbWUpIHtcbiAgbGV0IGN1cnJDQyA9IHZ0dENDc1tjY107XG4gIGxldCBwcmV2Q0MgPSB2dHRDQ3NbY3VyckNDLnByZXZDQ107XG5cbiAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGlzY29udGludWl0eSBvciBjdWVzIGhhdmUgYmVlbiBwcm9jZXNzZWQgc2luY2UgdGhlIGxhc3QgZGlzY29udGludWl0eVxuICAvLyBPZmZzZXQgPSBjdXJyZW50IGRpc2NvbnRpbnVpdHkgdGltZVxuICBpZiAoIXByZXZDQyB8fCAoIXByZXZDQy5uZXcgJiYgY3VyckNDLm5ldykpIHtcbiAgICB2dHRDQ3MuY2NPZmZzZXQgPSB2dHRDQ3MucHJlc2VudGF0aW9uT2Zmc2V0ID0gY3VyckNDLnN0YXJ0O1xuICAgIGN1cnJDQy5uZXcgPSBmYWxzZTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUaGVyZSBoYXZlIGJlZW4gZGlzY29udGludWl0aWVzIHNpbmNlIGN1ZXMgd2VyZSBsYXN0IHBhcnNlZC5cbiAgLy8gT2Zmc2V0ID0gdGltZSBlbGFwc2VkXG4gIHdoaWxlIChwcmV2Q0MgJiYgcHJldkNDLm5ldykge1xuICAgIHZ0dENDcy5jY09mZnNldCArPSBjdXJyQ0Muc3RhcnQgLSBwcmV2Q0Muc3RhcnQ7XG4gICAgY3VyckNDLm5ldyA9IGZhbHNlO1xuICAgIGN1cnJDQyA9IHByZXZDQztcbiAgICBwcmV2Q0MgPSB2dHRDQ3NbY3VyckNDLnByZXZDQ107XG4gIH1cblxuICB2dHRDQ3MucHJlc2VudGF0aW9uT2Zmc2V0ID0gcHJlc2VudGF0aW9uVGltZTtcbn07XG5cbmNvbnN0IFdlYlZUVFBhcnNlciA9IHtcbiAgcGFyc2U6IGZ1bmN0aW9uICh2dHRCeXRlQXJyYXksIHN5bmNQVFMsIHZ0dENDcywgY2MsIGNhbGxCYWNrLCBlcnJvckNhbGxCYWNrKSB7XG4gICAgLy8gQ29udmVydCBieXRlQXJyYXkgaW50byBzdHJpbmcsIHJlcGxhY2luZyBhbnkgc29tZXdoYXQgZXhvdGljIGxpbmVmZWVkcyB3aXRoIFwiXFxuXCIsIHRoZW4gc3BsaXQgb24gdGhhdCBjaGFyYWN0ZXIuXG4gICAgbGV0IHJlID0gL1xcclxcbnxcXG5cXHJ8XFxufFxcci9nO1xuICAgIC8vIFVpbnQ4QXJyYXkucHJvdG90eXBlLnJlZHVjZSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gSUUxMVxuICAgIGxldCB2dHRMaW5lcyA9IHV0ZjhBcnJheVRvU3RyKG5ldyBVaW50OEFycmF5KHZ0dEJ5dGVBcnJheSkpLnRyaW0oKS5yZXBsYWNlKHJlLCAnXFxuJykuc3BsaXQoJ1xcbicpO1xuXG4gICAgbGV0IGN1ZVRpbWUgPSAnMDA6MDAuMDAwJztcbiAgICBsZXQgbXBlZ1RzID0gMDtcbiAgICBsZXQgbG9jYWxUaW1lID0gMDtcbiAgICBsZXQgcHJlc2VudGF0aW9uVGltZSA9IDA7XG4gICAgbGV0IGN1ZXMgPSBbXTtcbiAgICBsZXQgcGFyc2luZ0Vycm9yO1xuICAgIGxldCBpbkhlYWRlciA9IHRydWU7XG4gICAgLy8gbGV0IFZUVEN1ZSA9IFZUVEN1ZSB8fCB3aW5kb3cuVGV4dFRyYWNrQ3VlO1xuXG4gICAgLy8gQ3JlYXRlIHBhcnNlciBvYmplY3QgdXNpbmcgVlRUQ3VlIHdpdGggVGV4dFRyYWNrQ3VlIGZhbGxiYWNrIG9uIGNlcnRhaW4gYnJvd3NlcnMuXG4gICAgbGV0IHBhcnNlciA9IG5ldyBWVFRQYXJzZXIoKTtcblxuICAgIHBhcnNlci5vbmN1ZSA9IGZ1bmN0aW9uIChjdWUpIHtcbiAgICAgIC8vIEFkanVzdCBjdWUgdGltaW5nOyBjbGFtcCBjdWVzIHRvIHN0YXJ0IG5vIGVhcmxpZXIgdGhhbiAtIGFuZCBkcm9wIGN1ZXMgdGhhdCBkb24ndCBlbmQgYWZ0ZXIgLSAwIG9uIHRpbWVsaW5lLlxuICAgICAgbGV0IGN1cnJDQyA9IHZ0dENDc1tjY107XG4gICAgICBsZXQgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0O1xuXG4gICAgICAvLyBVcGRhdGUgb2Zmc2V0cyBmb3IgbmV3IGRpc2NvbnRpbnVpdGllc1xuICAgICAgaWYgKGN1cnJDQyAmJiBjdXJyQ0MubmV3KSB7XG4gICAgICAgIGlmIChsb2NhbFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFdoZW4gbG9jYWwgdGltZSBpcyBwcm92aWRlZCwgb2Zmc2V0ID0gZGlzY29udGludWl0eSBzdGFydCB0aW1lIC0gbG9jYWwgdGltZVxuICAgICAgICAgIGN1ZU9mZnNldCA9IHZ0dENDcy5jY09mZnNldCA9IGN1cnJDQy5zdGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxjdWxhdGVPZmZzZXQodnR0Q0NzLCBjYywgcHJlc2VudGF0aW9uVGltZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByZXNlbnRhdGlvblRpbWUpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBNUEVHVFMsIG9mZnNldCA9IHByZXNlbnRhdGlvbiB0aW1lICsgZGlzY29udGludWl0eSBvZmZzZXRcbiAgICAgICAgY3VlT2Zmc2V0ID0gcHJlc2VudGF0aW9uVGltZSAtIHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGN1ZS5zdGFydFRpbWUgKz0gY3VlT2Zmc2V0IC0gbG9jYWxUaW1lO1xuICAgICAgY3VlLmVuZFRpbWUgKz0gY3VlT2Zmc2V0IC0gbG9jYWxUaW1lO1xuXG4gICAgICAvLyBDcmVhdGUgYSB1bmlxdWUgaGFzaCBpZCBmb3IgYSBjdWUgYmFzZWQgb24gc3RhcnQvZW5kIHRpbWVzIGFuZCB0ZXh0LlxuICAgICAgLy8gVGhpcyBoZWxwcyB0aW1lbGluZS1jb250cm9sbGVyIHRvIGF2b2lkIHNob3dpbmcgcmVwZWF0ZWQgY2FwdGlvbnMuXG4gICAgICBjdWUuaWQgPSBoYXNoKGN1ZS5zdGFydFRpbWUudG9TdHJpbmcoKSkgKyBoYXNoKGN1ZS5lbmRUaW1lLnRvU3RyaW5nKCkpICsgaGFzaChjdWUudGV4dCk7XG5cbiAgICAgIC8vIEZpeCBlbmNvZGluZyBvZiBzcGVjaWFsIGNoYXJhY3RlcnMuIFRPRE86IFRlc3Qgd2l0aCBhbGwgc29ydHMgb2Ygd2VpcmQgY2hhcmFjdGVycy5cbiAgICAgIGN1ZS50ZXh0ID0gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZVVSSUNvbXBvbmVudChjdWUudGV4dCkpO1xuICAgICAgaWYgKGN1ZS5lbmRUaW1lID4gMCkge1xuICAgICAgICBjdWVzLnB1c2goY3VlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcGFyc2VyLm9ucGFyc2luZ2Vycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHBhcnNpbmdFcnJvciA9IGU7XG4gICAgfTtcblxuICAgIHBhcnNlci5vbmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHBhcnNpbmdFcnJvciAmJiBlcnJvckNhbGxCYWNrKSB7XG4gICAgICAgIGVycm9yQ2FsbEJhY2socGFyc2luZ0Vycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FsbEJhY2soY3Vlcyk7XG4gICAgfTtcblxuICAgIC8vIEdvIHRocm91Z2ggY29udGVudHMgbGluZSBieSBsaW5lLlxuICAgIHZ0dExpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICBpZiAoaW5IZWFkZXIpIHtcbiAgICAgICAgLy8gTG9vayBmb3IgWC1USU1FU1RBTVAtTUFQIGluIGhlYWRlci5cbiAgICAgICAgaWYgKHN0YXJ0c1dpdGgobGluZSwgJ1gtVElNRVNUQU1QLU1BUD0nKSkge1xuICAgICAgICAgIC8vIE9uY2UgZm91bmQsIG5vIG1vcmUgYXJlIGFsbG93ZWQgYW55d2F5LCBzbyBzdG9wIHNlYXJjaGluZy5cbiAgICAgICAgICBpbkhlYWRlciA9IGZhbHNlO1xuICAgICAgICAgIC8vIEV4dHJhY3QgTE9DQUwgYW5kIE1QRUdUUy5cbiAgICAgICAgICBsaW5lLnN1YnN0cigxNikuc3BsaXQoJywnKS5mb3JFYWNoKHRpbWVzdGFtcCA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhcnRzV2l0aCh0aW1lc3RhbXAsICdMT0NBTDonKSkge1xuICAgICAgICAgICAgICBjdWVUaW1lID0gdGltZXN0YW1wLnN1YnN0cig2KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRzV2l0aCh0aW1lc3RhbXAsICdNUEVHVFM6JykpIHtcbiAgICAgICAgICAgICAgbXBlZ1RzID0gcGFyc2VJbnQodGltZXN0YW1wLnN1YnN0cig3KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBzdWJ0aXRsZSBvZmZzZXQgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgICAgaWYgKHN5bmNQVFMgKyAoKHZ0dENDc1tjY10uc3RhcnQgKiA5MDAwMCkgfHwgMCkgPCAwKSB7XG4gICAgICAgICAgICAgIHN5bmNQVFMgKz0gODU4OTkzNDU5MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkanVzdCBNUEVHVFMgYnkgc3luYyBQVFMuXG4gICAgICAgICAgICBtcGVnVHMgLT0gc3luY1BUUztcbiAgICAgICAgICAgIC8vIENvbnZlcnQgY3VlIHRpbWUgdG8gc2Vjb25kc1xuICAgICAgICAgICAgbG9jYWxUaW1lID0gY3VlU3RyaW5nMm1pbGxpcyhjdWVUaW1lKSAvIDEwMDA7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IE1QRUdUUyB0byBzZWNvbmRzIGZyb20gOTBrSHouXG4gICAgICAgICAgICBwcmVzZW50YXRpb25UaW1lID0gbXBlZ1RzIC8gOTAwMDA7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbFRpbWUgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgTWFsZm9ybWVkIFgtVElNRVNUQU1QLU1BUDogJHtsaW5lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgTWFsZm9ybWVkIFgtVElNRVNUQU1QLU1BUDogJHtsaW5lfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gd2l0aG91dCBwYXJzaW5nIFgtVElNRVNUQU1QLU1BUCBsaW5lLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChsaW5lID09PSAnJykge1xuICAgICAgICAgIGluSGVhZGVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFBhcnNlIGxpbmUgYnkgZGVmYXVsdC5cbiAgICAgIHBhcnNlci5wYXJzZShsaW5lICsgJ1xcbicpO1xuICAgIH0pO1xuXG4gICAgcGFyc2VyLmZsdXNoKCk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFdlYlZUVFBhcnNlcjtcbiIsIi8qKlxuICogWEhSIGJhc2VkIGxvZ2dlclxuKi9cblxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuY29uc3QgeyBwZXJmb3JtYW5jZSwgWE1MSHR0cFJlcXVlc3QgfSA9IHdpbmRvdztcblxuY2xhc3MgWGhyTG9hZGVyIHtcbiAgY29uc3RydWN0b3IgKGNvbmZpZykge1xuICAgIGlmIChjb25maWcgJiYgY29uZmlnLnhoclNldHVwKSB7XG4gICAgICB0aGlzLnhoclNldHVwID0gY29uZmlnLnhoclNldHVwO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuYWJvcnQoKTtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gIH1cblxuICBhYm9ydCAoKSB7XG4gICAgbGV0IGxvYWRlciA9IHRoaXMubG9hZGVyO1xuICAgIGlmIChsb2FkZXIgJiYgbG9hZGVyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHRoaXMuc3RhdHMuYWJvcnRlZCA9IHRydWU7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBudWxsO1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpO1xuICAgIHRoaXMucmV0cnlUaW1lb3V0ID0gbnVsbDtcbiAgfVxuXG4gIGxvYWQgKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB0aGlzLnN0YXRzID0geyB0cmVxdWVzdDogcGVyZm9ybWFuY2Uubm93KCksIHJldHJ5OiAwIH07XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gY29uZmlnLnJldHJ5RGVsYXk7XG4gICAgdGhpcy5sb2FkSW50ZXJuYWwoKTtcbiAgfVxuXG4gIGxvYWRJbnRlcm5hbCAoKSB7XG4gICAgbGV0IHhociwgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICB4aHIgPSB0aGlzLmxvYWRlciA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgbGV0IHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBzdGF0cy50Zmlyc3QgPSAwO1xuICAgIHN0YXRzLmxvYWRlZCA9IDA7XG4gICAgY29uc3QgeGhyU2V0dXAgPSB0aGlzLnhoclNldHVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh4aHJTZXR1cCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gZml4IHhoclNldHVwOiAoeGhyLCB1cmwpID0+IHt4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtTGFuZ3VhZ2VcIiwgXCJ0ZXN0XCIpO31cbiAgICAgICAgICAvLyBub3Qgd29ya2luZywgYXMgeGhyLnNldFJlcXVlc3RIZWFkZXIgZXhwZWN0cyB4aHIucmVhZHlTdGF0ZSA9PT0gT1BFTlxuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBjb250ZXh0LnVybCwgdHJ1ZSk7XG4gICAgICAgICAgeGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgheGhyLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJRTExIHRocm93cyBhbiBleGNlcHRpb24gb24geGhyLm9wZW4gaWYgYXR0ZW1wdGluZyB0byBhY2Nlc3MgYW4gSFRUUCByZXNvdXJjZSBvdmVyIEhUVFBTXG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkVycm9yKHsgY29kZTogeGhyLnN0YXR1cywgdGV4dDogZS5tZXNzYWdlIH0sIGNvbnRleHQsIHhocik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQucmFuZ2VFbmQpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdSYW5nZScsICdieXRlcz0nICsgY29udGV4dC5yYW5nZVN0YXJ0ICsgJy0nICsgKGNvbnRleHQucmFuZ2VFbmQgLSAxKSk7XG4gICAgfVxuXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHRoaXMucmVhZHlzdGF0ZWNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5sb2FkcHJvZ3Jlc3MuYmluZCh0aGlzKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gY29udGV4dC5yZXNwb25zZVR5cGU7XG5cbiAgICAvLyBzZXR1cCB0aW1lb3V0IGJlZm9yZSB3ZSBwZXJmb3JtIHJlcXVlc3RcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCB0aGlzLmNvbmZpZy50aW1lb3V0KTtcbiAgICB4aHIuc2VuZCgpO1xuICB9XG5cbiAgcmVhZHlzdGF0ZWNoYW5nZSAoZXZlbnQpIHtcbiAgICBsZXQgeGhyID0gZXZlbnQuY3VycmVudFRhcmdldCxcbiAgICAgIHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZSxcbiAgICAgIHN0YXRzID0gdGhpcy5zdGF0cyxcbiAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgIC8vIGRvbid0IHByb2NlZWQgaWYgeGhyIGhhcyBiZWVuIGFib3J0ZWRcbiAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vID49IEhFQURFUlNfUkVDRUlWRURcbiAgICBpZiAocmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICAvLyBjbGVhciB4aHIgdGltZW91dCBhbmQgcmVhcm0gaXQgaWYgcmVhZHlTdGF0ZSBsZXNzIHRoYW4gNFxuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgIGlmIChzdGF0cy50Zmlyc3QgPT09IDApIHtcbiAgICAgICAgc3RhdHMudGZpcnN0ID0gTWF0aC5tYXgocGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLnRyZXF1ZXN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgbGV0IHN0YXR1cyA9IHhoci5zdGF0dXM7XG4gICAgICAgIC8vIGh0dHAgc3RhdHVzIGJldHdlZW4gMjAwIHRvIDI5OSBhcmUgYWxsIHN1Y2Nlc3NmdWxcbiAgICAgICAgaWYgKHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgc3RhdHMudGxvYWQgPSBNYXRoLm1heChzdGF0cy50Zmlyc3QsIHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgICBsZXQgZGF0YSwgbGVuO1xuICAgICAgICAgIGlmIChjb250ZXh0LnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgICAgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgICAgICAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdHMubG9hZGVkID0gc3RhdHMudG90YWwgPSBsZW47XG4gICAgICAgICAgbGV0IHJlc3BvbnNlID0geyB1cmw6IHhoci5yZXNwb25zZVVSTCwgZGF0YTogZGF0YSB9O1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uU3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIHhocik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgbWF4IG5iIG9mIHJldHJpZXMgcmVhY2hlZCBvciBpZiBodHRwIHN0YXR1cyBiZXR3ZWVuIDQwMCBhbmQgNDk5IChzdWNoIGVycm9yIGNhbm5vdCBiZSByZWNvdmVyZWQsIHJldHJ5aW5nIGlzIHVzZWxlc3MpLCByZXR1cm4gZXJyb3JcbiAgICAgICAgICBpZiAoc3RhdHMucmV0cnkgPj0gY29uZmlnLm1heFJldHJ5IHx8IChzdGF0dXMgPj0gNDAwICYmIHN0YXR1cyA8IDQ5OSkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgJHtzdGF0dXN9IHdoaWxlIGxvYWRpbmcgJHtjb250ZXh0LnVybH1gKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3IoeyBjb2RlOiBzdGF0dXMsIHRleHQ6IHhoci5zdGF0dXNUZXh0IH0sIGNvbnRleHQsIHhocik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJldHJ5XG4gICAgICAgICAgICBsb2dnZXIud2FybihgJHtzdGF0dXN9IHdoaWxlIGxvYWRpbmcgJHtjb250ZXh0LnVybH0sIHJldHJ5aW5nIGluICR7dGhpcy5yZXRyeURlbGF5fS4uLmApO1xuICAgICAgICAgICAgLy8gYWJvcnRzIGFuZCByZXNldHMgaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgLy8gc2NoZWR1bGUgcmV0cnlcbiAgICAgICAgICAgIHRoaXMucmV0cnlUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5sb2FkSW50ZXJuYWwuYmluZCh0aGlzKSwgdGhpcy5yZXRyeURlbGF5KTtcbiAgICAgICAgICAgIC8vIHNldCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICAgICAgICB0aGlzLnJldHJ5RGVsYXkgPSBNYXRoLm1pbigyICogdGhpcy5yZXRyeURlbGF5LCBjb25maWcubWF4UmV0cnlEZWxheSk7XG4gICAgICAgICAgICBzdGF0cy5yZXRyeSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVhZHlTdGF0ZSA+PSAyIEFORCByZWFkeVN0YXRlICE9PTQgKHJlYWR5U3RhdGUgPSBIRUFERVJTX1JFQ0VJVkVEIHx8IExPQURJTkcpIHJlYXJtIHRpbWVvdXQgYXMgeGhyIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSwgY29uZmlnLnRpbWVvdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxvYWR0aW1lb3V0ICgpIHtcbiAgICBsb2dnZXIud2FybihgdGltZW91dCB3aGlsZSBsb2FkaW5nICR7dGhpcy5jb250ZXh0LnVybH1gKTtcbiAgICB0aGlzLmNhbGxiYWNrcy5vblRpbWVvdXQodGhpcy5zdGF0cywgdGhpcy5jb250ZXh0LCBudWxsKTtcbiAgfVxuXG4gIGxvYWRwcm9ncmVzcyAoZXZlbnQpIHtcbiAgICBsZXQgeGhyID0gZXZlbnQuY3VycmVudFRhcmdldCxcbiAgICAgIHN0YXRzID0gdGhpcy5zdGF0cztcblxuICAgIHN0YXRzLmxvYWRlZCA9IGV2ZW50LmxvYWRlZDtcbiAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgc3RhdHMudG90YWwgPSBldmVudC50b3RhbDtcbiAgICB9XG5cbiAgICBsZXQgb25Qcm9ncmVzcyA9IHRoaXMuY2FsbGJhY2tzLm9uUHJvZ3Jlc3M7XG4gICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgIC8vIHRoaXJkIGFyZyBpcyB0byBwcm92aWRlIG9uIHByb2dyZXNzIGRhdGFcbiAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIHRoaXMuY29udGV4dCwgbnVsbCwgeGhyKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgWGhyTG9hZGVyO1xuIiwiaW1wb3J0IFBsYXllciBmcm9tICd4Z3BsYXllcidcbmltcG9ydCBIbHMgZnJvbSAnLi9obHMuanMvaGxzJ1xuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMnXG5cbmNsYXNzIEhsc0pzUGxheWVyIGV4dGVuZHMgUGxheWVyIHtcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKVxuICAgIHRoaXMuaGxzT3B0cyA9IG9wdGlvbnMuaGxzT3B0cyB8fCB7fVxuICAgIGxldCB1dGlsID0gUGxheWVyLnV0aWxcbiAgICBsZXQgcGxheWVyID0gdGhpc1xuICAgIHRoaXMuYnJvd3NlciA9IHV0aWxzLmdldEJyb3dzZXJWZXJzaW9uKClcbiAgICBpZihwbGF5ZXIuY29uZmlnLnVzZUhscyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoKFBsYXllci5zbmlmZmVyLmRldmljZSA9PT0gJ21vYmlsZScgJiYgbmF2aWdhdG9yLnBsYXRmb3JtICE9PSAnTWFjSW50ZWwnICYmIG5hdmlnYXRvci5wbGF0Zm9ybSAhPT0gJ1dpbjMyJykgfHwgdGhpcy5icm93c2VyLmluZGV4T2YoJ1NhZmFyaScpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKCFwbGF5ZXIuY29uZmlnLnVzZUhscykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIE51bWJlci5pc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgbGV0IGhsc1xuICAgIGhscyA9IG5ldyBIbHModGhpcy5obHNPcHRzKVxuICAgIHRoaXMuaGxzID0gaGxzXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGxheWVyLCAnc3JjJywge1xuICAgICAgZ2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIHBsYXllci5jdXJyZW50U3JjXG4gICAgICB9LFxuICAgICAgc2V0ICh1cmwpIHtcbiAgICAgICAgdXRpbC5yZW1vdmVDbGFzcyhwbGF5ZXIucm9vdCwgJ3hncGxheWVyLWlzLWxpdmUnKVxuICAgICAgICBjb25zdCBsaXZlRG9tID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnhncGxheWVyLWxpdmUnKVxuICAgICAgICBpZiAobGl2ZURvbSkge1xuICAgICAgICAgIGxpdmVEb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaXZlRG9tKVxuICAgICAgICB9XG4gICAgICAgIC8vIHBsYXllci5jb25maWcudXJsID0gdXJsXG4gICAgICAgIGNvbnN0IHBhdXNlZCA9IHBsYXllci5wYXVzZWRcbiAgICAgICAgcGxheWVyLmhscy5zdG9wTG9hZCgpXG4gICAgICAgIHBsYXllci5obHMuZGV0YWNoTWVkaWEoKVxuICAgICAgICBwbGF5ZXIuaGxzLmRlc3Ryb3koKVxuICAgICAgICBwbGF5ZXIuaGxzID0gbmV3IEhscyhwbGF5ZXIuaGxzT3B0cylcbiAgICAgICAgcGxheWVyLnJlZ2lzdGVyKHVybClcbiAgICAgICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgICAgICBwbGF5ZXIucGF1c2UoKVxuICAgICAgICAgIHBsYXllci5vbmNlKCdwYXVzZScsICgpID0+IHtcbiAgICAgICAgICAgIHBsYXllci5obHMubG9hZFNvdXJjZSh1cmwpXG4gICAgICAgICAgfSlcbiAgICAgICAgICBwbGF5ZXIub25jZSgnY2FucGxheScsICgpID0+IHtcbiAgICAgICAgICAgIHBsYXllci5wbGF5KCkuY2F0Y2goZXJyID0+IHt9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGxheWVyLmhscy5sb2FkU291cmNlKHVybClcbiAgICAgICAgfVxuICAgICAgICBwbGF5ZXIuaGxzLmF0dGFjaE1lZGlhKHBsYXllci52aWRlbylcbiAgICAgICAgcGxheWVyLm9uY2UoJ2NhbnBsYXknLCAoKSA9PiB7XG4gICAgICAgICAgcGxheWVyLmN1cnJlbnRUaW1lID0gMFxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gICAgdGhpcy5yZWdpc3Rlcih0aGlzLmNvbmZpZy51cmwpXG4gICAgdGhpcy5vbmNlKCdjb21wbGV0ZScsICgpID0+IHtcbiAgICAgIGhscy5hdHRhY2hNZWRpYShwbGF5ZXIudmlkZW8pXG4gICAgICBwbGF5ZXIub25jZSgnY2FucGxheScsICgpID0+IHtcbiAgICAgICAgaWYocGxheWVyLmNvbmZpZy5hdXRvcGxheSkge1xuICAgICAgICAgIHBsYXllci5wbGF5KCkuY2F0Y2goZXJyID0+IHt9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaWYocGxheWVyLmNvbmZpZy5pc0xpdmUpIHtcbiAgICAgICAgdXRpbC5hZGRDbGFzcyhwbGF5ZXIucm9vdCwgJ3hncGxheWVyLWlzLWxpdmUnKVxuICAgICAgICBpZighdXRpbC5maW5kRG9tKHBsYXllci5yb290LCAnLnhncGxheWVyLWxpdmUnKSkge1xuICAgICAgICAgIGNvbnN0IGxpdmUgPSB1dGlsLmNyZWF0ZURvbSgneGctbGl2ZScsICfmraPlnKjnm7Tmkq0nLCB7fSwgJ3hncGxheWVyLWxpdmUnKVxuICAgICAgICAgIHBsYXllci5jb250cm9scy5hcHBlbmRDaGlsZChsaXZlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLm9uY2UoJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICBobHMuc3RvcExvYWQoKVxuICAgIH0pXG4gIH1cbiAgcmVnaXN0ZXIgKHVybCkge1xuICAgIGxldCBobHMgPSB0aGlzLmhsc1xuICAgIGxldCB1dGlsID0gUGxheWVyLnV0aWxcbiAgICBsZXQgcGxheWVyID0gdGhpc1xuICAgIGhscy5vbihIbHMuRXZlbnRzLk1FRElBX0FUVEFDSEVELCAoKSA9PiB7XG4gICAgICBobHMubG9hZFNvdXJjZSh1cmwpXG4gICAgfSlcblxuICAgIGhscy5vbihIbHMuRXZlbnRzLkxFVkVMX0xPQURFRCwgKG5hbWUsIGUpID0+IHtcbiAgICAgIGlmICghaGxzLmluaXRlZCkge1xuICAgICAgICBobHMuaW5pdGVkID0gdHJ1ZVxuICAgICAgICBpZiAoZSAmJiBlLmRldGFpbHMgJiYgZS5kZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICB1dGlsLmFkZENsYXNzKHBsYXllci5yb290LCAneGdwbGF5ZXItaXMtbGl2ZScpXG4gICAgICAgICAgaWYoIXV0aWwuZmluZERvbShwbGF5ZXIucm9vdCwgJy54Z3BsYXllci1saXZlJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpdmUgPSB1dGlsLmNyZWF0ZURvbSgneGctbGl2ZScsICfmraPlnKjnm7Tmkq0nLCB7fSwgJ3hncGxheWVyLWxpdmUnKVxuICAgICAgICAgICAgcGxheWVyLmNvbnRyb2xzLmFwcGVuZENoaWxkKGxpdmUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgICBobHMub24oSGxzLkV2ZW50cy5FUlJPUiwgKGV2ZW50LCBkYXRhKSA9PiB7XG4gICAgICBwbGF5ZXIuZW1pdCgnSExTX0VSUk9SJywge1xuICAgICAgICBlcnJvclR5cGU6IGRhdGEudHlwZSxcbiAgICAgICAgZXJyb3JEZXRhaWxzOiBkYXRhLmRldGFpbHMsXG4gICAgICAgIGVycm9yRmF0YWw6IGRhdGEuZmF0YWwsXG4gICAgICB9KVxuICAgICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIEhscy5FcnJvclR5cGVzLk5FVFdPUktfRVJST1I6XG4gICAgICAgICAgICBobHMuc3RhcnRMb2FkKClcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBIbHMuRXJyb3JUeXBlcy5NRURJQV9FUlJPUjpcbiAgICAgICAgICAgIGhscy5yZWNvdmVyTWVkaWFFcnJvcigpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBwbGF5ZXIuZW1pdCgnZXJyb3InLCBkYXRhKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLl9zdGF0aXN0aWNzKCk7XG4gIH1cblxuICBfc3RhdGlzdGljcygpIHtcbiAgICBsZXQgc3RhdHNJbmZvID0ge1xuICAgICAgc3BlZWQ6MCxcbiAgICAgIHBsYXllclR5cGU6IFwiSGxzUGxheWVyXCJcbiAgICB9O1xuXG4gICAgbGV0IG1lZGlhaW5mbyA9IHtcbiAgICAgIHZpZGVvRGF0YVJhdGU6MCxcbiAgICAgIGF1ZGlvRGF0YVJhdGU6MFxuICAgIH07XG4gICAgbGV0IGhscyA9IHRoaXMuaGxzO1xuICAgIGxldCBwbGF5ZXIgPSB0aGlzO1xuXG4gICAgaGxzLm9uKEhscy5FdmVudHMuRlJBR19MT0FEX1BST0dSRVNTLCAoZmxhZyxwYXlsb2FkKSA9PntcbiAgICAgIHN0YXRzSW5mby5zcGVlZCA9IHBheWxvYWQuc3RhdHMubG9hZGVkIC8gMTAwMDtcbiAgICB9KTtcbiAgICBobHMub24oSGxzLkV2ZW50cy5GUkFHX1BBUlNJTkdfREFUQSwgKGZsYWcscGF5bG9hZCkgPT57XG4gICAgICBpZiAocGF5bG9hZC50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgIG1lZGlhaW5mby5mcHMgPSBwYXJzZUludChwYXlsb2FkLm5iLyhwYXlsb2FkLmVuZFBUUyAtcGF5bG9hZC5zdGFydFBUUykpO1xuICAgICAgfVxuICAgIH0pXG5cbiAgICBobHMub24oSGxzLkV2ZW50cy5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCAoZmxhZyxwYXlsb2FkKSA9PntcbiAgICAgIG1lZGlhaW5mby5oYXNBdWRpbyA9IChwYXlsb2FkLnRyYWNrcyAmJiBwYXlsb2FkLnRyYWNrcy5hdWRpbyk/IHRydWU6IGZhbHNlO1xuICAgICAgbWVkaWFpbmZvLmhhc1ZpZGVvID0gKHBheWxvYWQudHJhY2tzICYmIHBheWxvYWQudHJhY2tzLmF1ZGlvKT8gdHJ1ZTogZmFsc2U7XG5cbiAgICAgIGlmKG1lZGlhaW5mby5oYXNBdWRpbykge1xuICAgICAgICBsZXQgdHJhY2sgPSBwYXlsb2FkLnRyYWNrcy5hdWRpbztcbiAgICAgICAgbWVkaWFpbmZvLmF1ZGlvQ2hhbm5lbENvdW50ID0gKHRyYWNrLm1ldGFkYXRhICYmIHRyYWNrLm1ldGFkYXRhLmNoYW5uZWxDb3VudCkgPyB0cmFjay5tZXRhZGF0YS5jaGFubmVsQ291bnQ6MDtcbiAgICAgICAgbWVkaWFpbmZvLmF1ZGlvQ29kZWMgPSB0cmFjay5jb2RlYztcbiAgICAgIH1cblxuICAgICAgaWYobWVkaWFpbmZvLmhhc1ZpZGVvKSB7XG4gICAgICAgIGxldCB0cmFjayA9IHBheWxvYWQudHJhY2tzLnZpZGVvO1xuICAgICAgICBtZWRpYWluZm8udmlkZW9Db2RlYyA9IHRyYWNrLmNvZGVjO1xuICAgICAgICBtZWRpYWluZm8ud2lkdGggPSAodHJhY2subWV0YWRhdGEgJiYgdHJhY2subWV0YWRhdGEud2lkdGgpID8gdHJhY2subWV0YWRhdGEud2lkdGg6MDtcbiAgICAgICAgbWVkaWFpbmZvLmhlaWdodCA9ICh0cmFjay5tZXRhZGF0YSAmJiB0cmFjay5tZXRhZGF0YS5oZWlnaHQpID8gdHJhY2subWV0YWRhdGEuaGVpZ2h0OjA7XG4gICAgICB9XG4gICAgICBtZWRpYWluZm8uZHVyYXRpb24gPSAocGF5bG9hZC5mcmFnICYmIHBheWxvYWQuZnJhZy5kdXJhdGlvbikgPyBwYXlsb2FkLmZyYWcuZHVyYXRpb246MFxuICAgICAgbWVkaWFpbmZvLmxldmVsID0ocGF5bG9hZC5mcmFnICYmIHBheWxvYWQuZnJhZy5sZXZlbCkgPyBwYXlsb2FkLmZyYWcubGV2ZWw6MDtcbiAgICAgIGlmKG1lZGlhaW5mby52aWRlb0NvZGVjIHx8IG1lZGlhaW5mby5hdWRpb0NvZGVjKSB7XG4gICAgICAgIG1lZGlhaW5mby5taW1lVHlwZSA9IGB2aWRlby9obHM7IGNvZGVjcz1cIiR7bWVkaWFpbmZvLnZpZGVvQ29kZWN9OyR7bWVkaWFpbmZvLmF1ZGlvQ29kZWN9XCJgXG4gICAgICB9XG5cbiAgICAgIHBsYXllci5tZWRpYWluZm8gPSBtZWRpYWluZm87XG4gICAgICBwbGF5ZXIuZW1pdChcIm1lZGlhX2luZm9cIiwgbWVkaWFpbmZvKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3N0YXRpc3RpY3NUaW1tZXIgPSBzZXRJbnRlcnZhbCgoKT0+e1xuICAgICAgcGxheWVyLmVtaXQoXCJzdGF0aXN0aWNzX2luZm9cIiwgc3RhdHNJbmZvKTtcbiAgICAgIHN0YXRzSW5mby5zcGVlZCA9IDA7XG4gICAgfSwgMTAwMClcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fc3RhdGlzdGljc1RpbW1lcik7XG4gIH1cbn1cblxuSGxzSnNQbGF5ZXIuaXNTdXBwb3J0ZWQgPSBIbHMuaXNTdXBwb3J0ZWRcblxuZXhwb3J0IGRlZmF1bHQgSGxzSnNQbGF5ZXJcbiIsImxldCB1dGlsID0ge31cblxudXRpbC5nZXRCcm93c2VyVmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgLy/lj5blvpfmtY/op4jlmajnmoR1c2VyQWdlbnTlrZfnrKbkuLJcbiAgaWYodXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIm1vYmlsZVwiKSA+IC0xKSB7XG4gICAgcmV0dXJuIFwiVW5rbm93blwiXG4gIH1cbiAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSA+IC0xKSB7XG4gICAgbGV0IHZlcnNpb24gPSB1c2VyQWdlbnQubWF0Y2goL2ZpcmVmb3hcXC9bXFxkLl0rL2dpKVswXS5tYXRjaCgvW1xcZF0rLylbMF1cbiAgICByZXR1cm4gXCJGaXJlZm94IFwiK3ZlcnNpb25cbiAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZihcIkVkZ2VcIikgPiAtMSkge1xuICAgIGxldCB2ZXJzaW9uID0gdXNlckFnZW50Lm1hdGNoKC9lZGdlXFwvW1xcZC5dKy9naSlbMF0ubWF0Y2goL1tcXGRdKy8pWzBdXG4gICAgcmV0dXJuIFwiRWRnZSBcIit2ZXJzaW9uXG4gIH0gZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoXCJydjoxMVwiKSA+IC0xKSB7XG4gICAgcmV0dXJuIFwiSUUgMTFcIlxuICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKFwiT3BlcmFcIikgPiAtMSB8fCB1c2VyQWdlbnQuaW5kZXhPZihcIk9QUlwiKSA+IC0xKSB7XG4gICAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKFwiT3BlcmFcIikgPiAtMSkge1xuICAgICAgbGV0IHZlcnNpb24gPSB1c2VyQWdlbnQubWF0Y2goL29wZXJhXFwvW1xcZC5dKy9naSlbMF0ubWF0Y2goL1tcXGRdKy8pWzBdXG4gICAgICByZXR1cm4gXCJPcGVyYSBcIit2ZXJzaW9uXG4gICAgfVxuICAgIGlmICh1c2VyQWdlbnQuaW5kZXhPZihcIk9QUlwiKSA+IC0xKSB7XG4gICAgICBsZXQgdmVyc2lvbiA9IHVzZXJBZ2VudC5tYXRjaCgvb3ByXFwvW1xcZC5dKy9naSlbMF0ubWF0Y2goL1tcXGRdKy8pWzBdXG4gICAgICByZXR1cm4gXCJPcGVyYSBcIit2ZXJzaW9uXG4gICAgfVxuICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKFwiQ2hyb21lXCIpID4gLTEpIHtcbiAgICBsZXQgdmVyc2lvbiA9IHVzZXJBZ2VudC5tYXRjaCgvY2hyb21lXFwvW1xcZC5dKy9naSlbMF0ubWF0Y2goL1tcXGRdKy8pWzBdXG4gICAgcmV0dXJuIFwiQ2hyb21lIFwiK3ZlcnNpb25cbiAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZihcIlNhZmFyaVwiKSA+IC0xKSB7XG4gICAgbGV0IHZlcnNpb24gPSB1c2VyQWdlbnQubWF0Y2goL3NhZmFyaVxcL1tcXGQuXSsvZ2kpWzBdLm1hdGNoKC9bXFxkXSsvKVswXVxuICAgIHJldHVybiBcIlNhZmFyaSBcIit2ZXJzaW9uXG4gIH0gZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoXCJNU0lFXCIpID4gLTEgfHwgdXNlckFnZW50LmluZGV4T2YoXCJUcmlkZW50XCIpID4gLTEpIHtcbiAgICBpZiAodXNlckFnZW50LmluZGV4T2YoXCJNU0lFXCIpID4gLTEpIHtcbiAgICAgIGxldCB2ZXJzaW9uID0gdXNlckFnZW50Lm1hdGNoKC9tc2llIFtcXGQuXSsvZ2kpWzBdLm1hdGNoKC9bXFxkXSsvKVswXVxuICAgICAgcmV0dXJuIFwiSUUgXCIrdmVyc2lvblxuICAgIH1cbiAgICBpZiAodXNlckFnZW50LmluZGV4T2YoXCJUcmlkZW50XCIpID4gLTEpIHtcbiAgICAgIGxldCB2ZXJzaW9uVHJpZGVudCA9IHVzZXJBZ2VudC5tYXRjaCgvdHJpZGVudFxcL1tcXGQuXSsvZ2kpWzBdLm1hdGNoKC9bXFxkXSsvKVswXVxuICAgICAgbGV0IHZlcnNpb24gPSBwYXJzZUludCh2ZXJzaW9uVHJpZGVudCkgKyA0XG4gICAgICByZXR1cm4gXCJJRSBcIit2ZXJzaW9uXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlVua25vd25cIlxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHV0aWxcbiIsIihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dbXCJQbGF5ZXJcIl07IH0oKSk7Il0sInNvdXJjZVJvb3QiOiIifQ==