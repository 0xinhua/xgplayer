!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("xgplayer")):"function"==typeof define&&define.amd?define(["xgplayer"],t):"object"==typeof exports?exports["xgplayer-flv"]=t(require("xgplayer")):e["xgplayer-flv"]=t(e.xgplayer)}(window,(function(__WEBPACK_EXTERNAL_MODULE_xgplayer__){return function(e){var t={};function n(s){if(t[s])return t[s].exports;var i=t[s]={i:s,l:!1,exports:{}};return e[s].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,s){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(n.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(s,i,function(t){return e[t]}.bind(null,i));return s},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=0)}({"../xgplayer-flv-live/dist/index.js":
/*!****************************!*\
  !*** .-live/dist/index.js ***!
  \****************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";var n;window,n=function(__WEBPACK_EXTERNAL_MODULE_xgplayer__){return function(e){var t={};function n(s){if(t[s])return t[s].exports;var i=t[s]={i:s,l:!1,exports:{}};return e[s].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,s){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(n.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(s,i,function(t){return e[t]}.bind(null,i));return s},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=0)}({"../../node_modules/events/events.js":
/*!*****************************************************************************************!*\
      !*** /Users/leonardo/Documents/front-end/player/xgplayer/node_modules/events/events.js ***!
      \*****************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\n\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function () {\n    return defaultMaxListeners;\n  },\n  set: function (arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function () {\n\n  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = type === 'error';\n\n  var events = this._events;\n  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0) er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined) return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n};\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = this._events;\n  if (events === undefined) return this;\n\n  list = events[type];\n  if (list === undefined) return this;\n\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = Object.create(null);else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0) return this;\n\n    if (position === 0) list.shift();else {\n      spliceOne(list, position);\n    }\n\n    if (list.length === 1) events[type] = list[0];\n\n    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events, i;\n\n  events = this._events;\n  if (events === undefined) return this;\n\n  // not listening for removeListener, no need to emit\n  if (events.removeListener === undefined) {\n    if (arguments.length === 0) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    } else if (events[type] !== undefined) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n    }\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    var key;\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n\n  listeners = events[type];\n\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners !== undefined) {\n    // LIFO order\n    for (i = listeners.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners[i]);\n    }\n  }\n\n  return this;\n};\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined) return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined) return [];\n\n  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i) copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++) list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n//# sourceURL=webpack://xgplayer-flv//Users/leonardo/Documents/front-end/player/xgplayer/node_modules/events/events.js?")},"../xgplayer-buffer/index.js":
/*!***********************************!*\
      !*** ../xgplayer-buffer/index.js ***!
      \***********************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nmodule.exports = {\n  Track: __webpack_require__(/*! ./src/track */ "../xgplayer-buffer/src/track.js").default,\n  Tracks: __webpack_require__(/*! ./src/track */ "../xgplayer-buffer/src/track.js").Tracks,\n  AudioTrack: __webpack_require__(/*! ./src/track */ "../xgplayer-buffer/src/track.js").AudioTrack,\n  VideoTrack: __webpack_require__(/*! ./src/track */ "../xgplayer-buffer/src/track.js").VideoTrack,\n\n  XgBuffer: __webpack_require__(/*! ./src/buffer */ "../xgplayer-buffer/src/buffer.js").XgBuffer,\n  RemuxBuffer: __webpack_require__(/*! ./src/buffer */ "../xgplayer-buffer/src/buffer.js").RemuxBuffer,\n\n  PreSource: __webpack_require__(/*! ./src/presouce */ "../xgplayer-buffer/src/presouce.js").default\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-buffer/index.js?')},"../xgplayer-buffer/src/buffer.js":
/*!****************************************!*\
      !*** ../xgplayer-buffer/src/buffer.js ***!
      \****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nclass XgBuffer {\n  /**\n   * A buffer to store loaded data.\n   *\n   * @class LoaderBuffer\n   * @param {number} length - Optional the buffer size\n   */\n  constructor(length) {\n    this.length = length || 0;\n    this.historyLen = length || 0;\n    this.array = [];\n    this.offset = 0;\n  }\n\n  /**\n   * The function to push data.\n   *\n   * @param {number} data - The data to push into the buffer\n   */\n  push(data) {\n    this.array.push(data);\n    this.length += data.byteLength;\n    this.historyLen += data.byteLength;\n  }\n\n  /**\n   * The function to shift data.\n   *\n   * @param {number} length - The size of shift.\n   */\n  shift(length) {\n    if (this.array.length < 1) {\n      return new Uint8Array(0);\n    }\n\n    if (length === undefined) {\n      return this._shiftBuffer();\n    }\n    if (this.offset + length === this.array[0].length) {\n      let ret = this.array[0].slice(this.offset, this.offset + length);\n      this.offset = 0;\n      this.array.shift();\n      this.length -= length;\n      return ret;\n    }\n\n    if (this.offset + length < this.array[0].length) {\n      let ret = this.array[0].slice(this.offset, this.offset + length);\n      this.offset += length;\n      this.length -= length;\n      return ret;\n    }\n\n    let ret = new Uint8Array(length);\n    let tmpoff = 0;\n    while (this.array.length > 0 && length > 0) {\n      if (this.offset + length < this.array[0].length) {\n        let tmp = this.array[0].slice(this.offset, this.offset + length);\n        ret.set(tmp, tmpoff);\n        this.offset += length;\n        this.length -= length;\n        length = 0;\n        break;\n      } else {\n        let templength = this.array[0].length - this.offset;\n        ret.set(this.array[0].slice(this.offset, this.array[0].length), tmpoff);\n        this.array.shift();\n        this.offset = 0;\n        tmpoff += templength;\n        this.length -= templength;\n        length -= templength;\n      }\n    }\n    return ret;\n  }\n\n  /**\n   * Function to clear the buffer.\n   */\n  clear() {\n    this.array = [];\n    this.length = 0;\n    this.offset = 0;\n  }\n\n  destroy() {\n    this.clear();\n    this.historyLen = 0;\n  }\n\n  /**\n   * Function to shift one unit8Array.\n   */\n  _shiftBuffer() {\n    this.length -= this.array[0].length;\n    this.offset = 0;\n    return this.array.shift();\n  }\n\n  /**\n   * Convert uint8 data to number.\n   *\n   * @param {number} start - the start postion.\n   * @param {number} length - the length of data.\n   */\n  toInt(start, length) {\n    let retInt = 0;\n    let i = this.offset + start;\n    while (i < this.offset + length + start) {\n      if (i < this.array[0].length) {\n        retInt = retInt * 256 + this.array[0][i];\n      } else if (this.array[1]) {\n        retInt = retInt * 256 + this.array[1][i - this.array[0].length];\n      }\n\n      i++;\n    }\n    return retInt;\n  }\n}\n\nexports.XgBuffer = XgBuffer;\nclass RemuxBuffer {\n  constructor() {\n    this.video = [];\n    this.audio = [];\n  }\n\n  destroy() {\n    this.video = [];\n    this.audio = [];\n  }\n}\nexports.RemuxBuffer = RemuxBuffer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-buffer/src/buffer.js?')},"../xgplayer-buffer/src/presouce.js":
/*!******************************************!*\
      !*** ../xgplayer-buffer/src/presouce.js ***!
      \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass Source {\n  constructor() {\n    this.mimetype = '';\n    this.init = null;\n    this.data = [];\n  }\n}\n\nclass PreSource {\n  constructor() {\n    this.sources = {};\n  }\n\n  getSource(source) {\n    return this.sources[source];\n  }\n\n  createSource(name) {\n    this.sources[name] = new Source();\n    return this.sources[name];\n  }\n\n  clear() {\n    this.sources = {};\n  }\n\n  destroy() {\n    this.sources = {};\n  }\n}\n\nexports.default = PreSource;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-buffer/src/presouce.js?")},"../xgplayer-buffer/src/track.js":
/*!***************************************!*\
      !*** ../xgplayer-buffer/src/track.js ***!
      \***************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass Track {\n  /**\n   * The constructor.\n   */\n  constructor() {\n    this.id = -1;\n    this.sequenceNumber = 0;\n    this.samples = [];\n    this.droppedSamples = [];\n    this.length = 0;\n  }\n\n  /**\n   * Reset the track.\n   */\n  reset() {\n    this.sequenceNumber = 0;\n    this.samples = [];\n    this.length = 0;\n  }\n  /**\n   * destroy the track.\n   */\n  distroy() {\n    this.reset();\n    this.id = -1;\n  }\n}\n\nexports.default = Track;\nclass AudioTrack extends Track {\n  /**\n   * The constructor for audio track.\n   */\n  constructor() {\n    super();\n    this.TAG = 'AudioTrack';\n    this.type = 'audio';\n  }\n}\n\nexports.AudioTrack = AudioTrack;\nclass VideoTrack extends Track {\n  /**\n   * The constructor for video track.\n   */\n  constructor() {\n    super();\n    this.TAG = 'VideoTrack';\n    this.type = 'video';\n    this.dropped = 0;\n  }\n  /**\n   * reset the video track.\n   */\n  reset() {\n    this.sequenceNumber = 0;\n    this.samples = [];\n    this.length = 0;\n    this.dropped = 0;\n  }\n}\n\nexports.VideoTrack = VideoTrack;\nclass Tracks {\n  constructor() {\n    this.audioTrack = null;\n    this.videoTrack = null;\n  }\n\n  destroy() {\n    this.audioTrack = null;\n    this.videoTrack = null;\n  }\n}\nexports.Tracks = Tracks;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-buffer/src/track.js?")},"../xgplayer-codec/index.js":
/*!**********************************!*\
      !*** ../xgplayer-codec/index.js ***!
      \**********************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nmodule.exports = {\n  Nalunit: __webpack_require__(/*! ./src/h264/nalunit */ "../xgplayer-codec/src/h264/nalunit/index.js").default,\n  SpsParser: __webpack_require__(/*! ./src/h264/nalunit/sps */ "../xgplayer-codec/src/h264/nalunit/sps.js").default,\n\n  Compatibility: __webpack_require__(/*! ./src/compatibility */ "../xgplayer-codec/src/compatibility.js").default\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-codec/index.js?')},"../xgplayer-codec/src/aac/aac-helper.js":
/*!***********************************************!*\
      !*** ../xgplayer-codec/src/aac/aac-helper.js ***!
      \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nclass AAC {\n\n  static getSilentFrame(codec, channelCount) {\n    if (codec === \'mp4a.40.2\') {\n      // handle LC-AAC\n      if (channelCount === 1) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n      } else if (channelCount === 2) {\n        return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n      } else if (channelCount === 3) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n      } else if (channelCount === 4) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n      } else if (channelCount === 5) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n      } else if (channelCount === 6) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n      }\n    } else {\n      // handle HE-AAC (mp4a.40.5 / mp4a.40.29)\n      if (channelCount === 1) {\n        // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e \'16/1 "0x%x," "\\n"\' -v output.aac\n        return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n      } else if (channelCount === 2) {\n        // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e \'16/1 "0x%x," "\\n"\' -v output.aac\n        return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n      } else if (channelCount === 3) {\n        // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e \'16/1 "0x%x," "\\n"\' -v output.aac\n        return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n      }\n    }\n    return null;\n  }\n\n}\n\nexports.default = AAC;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-codec/src/aac/aac-helper.js?')},"../xgplayer-codec/src/compatibility.js":
/*!**********************************************!*\
      !*** ../xgplayer-codec/src/compatibility.js ***!
      \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nvar _aacHelper = __webpack_require__(/*! ./aac/aac-helper */ \"../xgplayer-codec/src/aac/aac-helper.js\");\n\nvar _aacHelper2 = _interopRequireDefault(_aacHelper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst { REMUX_EVENTS, DEMUX_EVENTS } = _xgplayerUtils.EVENTS;\n\nclass Compatibility {\n  constructor() {\n    this.nextAudioDts = 0; // 模拟下一段音频数据的dts\n    this.nextVideoDts = 0; // 模拟下一段视频数据的dts\n\n    this.lastAudioSamplesLen = 0; // 上一段音频数据的长度\n    this.lastVideoSamplesLen = 0; // 上一段视频数据的长度\n\n    this.lastVideoDts = undefined; // 上一段音频数据的长度\n    this.lastAudioDts = undefined; // 上一段视频数据的长度\n\n    this.allAudioSamplesCount = 0; // 音频总数据量(原始帧)\n    this.allVideoSamplesCount = 0; // 视频总数据量(原始帧)\n\n    this._firstAudioSample = null;\n    this._firstVideoSample = null;\n\n    this.filledAudioSamples = []; // 补充音频帧（）\n    this.filledVideoSamples = []; // 补充视频帧（）\n\n    this._videoLargeGap = 0;\n    this._audioLargeGap = 0;\n  }\n\n  init() {\n    this.before(REMUX_EVENTS.REMUX_MEDIA, this.doFix.bind(this));\n  }\n\n  reset() {\n    this.nextAudioDts = null; // 估算下一段音频数据的dts\n    this.nextVideoDts = null; // 估算下一段视频数据的dts\n\n    this.lastAudioSamplesLen = 0; // 上一段音频数据的长度\n    this.lastVideoSamplesLen = 0; // 上一段视频数据的长度\n\n    this.lastVideoDts = undefined; // 上一段音频数据的长度\n    this.lastAudioDts = undefined; // 上一段视频数据的长度\n\n    // this.allAudioSamplesCount = 0 // 音频总数据量(原始帧)\n    // this.allVideoSamplesCount = 0 // 视频总数据量(原始帧)\n\n    // this._firstAudioSample = null\n    // this._firstVideoSample = null\n\n    this.filledAudioSamples = []; // 补充音频帧（）\n    this.filledVideoSamples = []; // 补充视频帧（）\n  }\n\n  doFix() {\n    const { isFirstAudioSamples, isFirstVideoSamples } = this.getFirstSample();\n\n    // this.removeInvalidSamples()\n\n    this.recordSamplesCount();\n\n    if (this._firstVideoSample) {\n      this.fixRefSampleDuration(this.videoTrack.meta, this.videoTrack.samples);\n    }\n    if (this._firstAudioSample) {\n      this.fixRefSampleDuration(this.audioTrack.meta, this.audioTrack.samples);\n    }\n\n    const { changed: videoChanged, changedIdx: videoChangedIdx } = Compatibility.detactChangeStream(this.videoTrack.samples);\n    if (videoChanged && !isFirstAudioSamples) {\n      this.fixChangeStreamVideo(videoChangedIdx);\n    } else {\n      this.doFixVideo(isFirstVideoSamples);\n    }\n\n    const { changed: audioChanged, changedIdx: audioChangedIdx } = Compatibility.detactChangeStream(this.audioTrack.samples);\n    if (audioChanged) {\n      this.fixChangeStreamAudio(audioChangedIdx);\n    } else {\n      this.doFixAudio(isFirstAudioSamples);\n    }\n\n    // this.removeInvalidSamples()\n  }\n\n  doFixVideo(first, streamChangeStart) {\n    let { samples: videoSamples, meta } = this.videoTrack;\n\n    if (meta.frameRate && meta.frameRate.fixed === false) {\n      return;\n    }\n\n    if (!videoSamples || !videoSamples.length || !this._firstVideoSample) {\n      return;\n    }\n\n    // console.log(`video lastSample, ${videoSamples[videoSamples.length - 1].dts}`)\n\n    const firstSample = videoSamples[0];\n\n    const samplesLen = videoSamples.length;\n\n    // step0.修复hls流出现巨大gap，需要强制重定位的问题\n    if (this._videoLargeGap > 0) {\n      Compatibility.doFixLargeGap(videoSamples, this._videoLargeGap);\n    }\n\n    if (firstSample.dts !== this._firstVideoSample.dts && (streamChangeStart || Compatibility.detectLargeGap(this.nextVideoDts, firstSample))) {\n      if (streamChangeStart) {\n        this.nextVideoDts = streamChangeStart; // FIX: Hls中途切codec，在如果直接seek到后面的点会导致largeGap计算失败\n      }\n\n      this._videoLargeGap = this.nextVideoDts - firstSample.dts;\n      Compatibility.doFixLargeGap(videoSamples, this._videoLargeGap);\n    }\n\n    const firstDts = firstSample.dts;\n\n    // step1. 修复与audio首帧差距太大的问题\n    if (first && this._firstAudioSample) {\n      const videoFirstDts = this._firstVideoSample.dts;\n      const audioFirstDts = this._firstAudioSample.dts;\n      const gap = videoFirstDts - audioFirstDts;\n      if (gap > 2 * meta.refSampleDuration) {\n        const fillCount = Math.floor(gap / meta.refSampleDuration);\n\n        for (let i = 0; i < fillCount; i++) {\n          const clonedFirstSample = Object.assign({}, firstSample); // 视频头部帧缺失需要复制第一帧\n          // 重新计算sample的dts和pts\n          clonedFirstSample.dts = videoFirstDts - (i + 1) * meta.refSampleDuration;\n          clonedFirstSample.pts = clonedFirstSample.dts + clonedFirstSample.cts;\n\n          videoSamples.unshift(clonedFirstSample);\n\n          this.filledVideoSamples.push({\n            dts: clonedFirstSample.dts,\n            size: clonedFirstSample.data.byteLength\n          });\n        }\n      }\n    }\n\n    let gap;\n    // step2. 修复samples段之间的间距问题、\n    if (this.nextVideoDts) {\n      // step1. 处理samples段之间的丢帧情况\n      // 当发现duration差距大于2帧时进行补帧\n      gap = firstDts - this.nextVideoDts;\n      const absGap = Math.abs(gap);\n      if (gap > 2 * meta.refSampleDuration) {\n        const fillFrameCount = Math.floor(gap / meta.refSampleDuration);\n\n        for (let i = 0; i < fillFrameCount; i++) {\n          const clonedSample = Object.assign({}, videoSamples[0]);\n          const computed = firstDts - (i + 1) * meta.refSampleDuration;\n\n          clonedSample.dts = computed > this.nextVideoDts ? computed : this.nextVideoDts; // 补的第一帧一定要是nextVideoDts\n          clonedSample.pts = clonedSample.dts + clonedSample.cts;\n\n          this.videoTrack.samples.unshift(clonedSample);\n\n          this.filledVideoSamples.push({\n            dts: clonedSample.dts,\n            size: clonedSample.data.byteLength\n          });\n        }\n      } else if (absGap <= meta.refSampleDuration && absGap > 0) {\n        // 当差距在+-一帧之间时将第一帧的dts强行定位到期望位置\n        // console.log('重定位视频帧dts', videoSamples[0].dts, this.nextVideoDts)\n        videoSamples[0].dts = this.nextVideoDts;\n        videoSamples[0].originDts = videoSamples[0].dts;\n        videoSamples[0].cts = videoSamples[0].cts !== undefined ? videoSamples[0].cts : videoSamples[0].pts - videoSamples[0].dts;\n        videoSamples[0].pts = videoSamples[0].dts + videoSamples[0].cts;\n      } else if (gap < 0) {\n        // 出现大的gap\n        Compatibility.doFixLargeGap(videoSamples, -1 * gap);\n      }\n    }\n    const lastDts = videoSamples[videoSamples.length - 1].dts;\n\n    const lastSampleDuration = videoSamples.length >= 2 ? lastDts - videoSamples[videoSamples.length - 2].dts : meta.refSampleDuration;\n\n    this.lastVideoSamplesLen = samplesLen;\n    this.nextVideoDts = lastDts + lastSampleDuration;\n    this.lastVideoDts = lastDts;\n\n    // step2. 修复sample段之内的间距问题\n    // step3. 修复samples段内部的dts异常问题\n    for (let i = 0, len = videoSamples.length; i < len; i++) {\n      const current = videoSamples[i];\n      const next = videoSamples[i + 1];\n\n      if (!next) {\n        break;\n      }\n\n      const duration = next.dts - current.dts;\n\n      if (duration > 2 * meta.refSampleDuration) {\n        // 两帧之间间隔太大，需要补空白帧\n        let fillFrameCount = Math.floor(duration / meta.refSampleDuration);\n\n        let fillFrameIdx = 0;\n        while (fillFrameIdx < fillFrameCount) {\n          const fillFrame = Object.assign({}, next);\n          fillFrame.dts = current.dts + (fillFrameIdx + 1) * meta.refSampleDuration;\n          fillFrame.pts = fillFrame.dts + fillFrame.cts;\n          if (fillFrame < next.dts) {\n            videoSamples.splice(i, 0, fillFrame);\n\n            this.filledVideoSamples.push({\n              dts: fillFrame.dts,\n              size: fillFrame.data.byteLength\n            });\n          }\n\n          fillFrameIdx++;\n          i++;\n        }\n      }\n    }\n\n    this.videoTrack.samples = videoSamples;\n  }\n\n  doFixAudio(first, streamChangeStart) {\n    let { samples: audioSamples, meta } = this.audioTrack;\n\n    if (!audioSamples || !audioSamples.length) {\n      return;\n    }\n    // console.log(`audio lastSample, ${audioSamples[audioSamples.length - 1].dts}`)\n\n    const samplesLen = audioSamples.length;\n    const silentFrame = _aacHelper2.default.getSilentFrame(meta.codec, meta.channelCount);\n\n    const firstSample = this._firstAudioSample;\n\n    const _firstSample = audioSamples[0];\n    // 对audioSamples按照dts做排序\n    // audioSamples = Compatibility.sortAudioSamples(audioSamples)\n    if (this._audioLargeGap > 0) {\n      Compatibility.doFixLargeGap(audioSamples, this._audioLargeGap);\n    }\n\n    if (_firstSample.dts !== this._firstAudioSample.dts && (streamChangeStart || Compatibility.detectLargeGap(this.nextAudioDts, _firstSample))) {\n      if (streamChangeStart) {\n        this.nextAudioDts = streamChangeStart; // FIX: Hls中途切codec，在如果直接seek到后面的点会导致largeGap计算失败\n      }\n      this._audioLargeGap = this.nextAudioDts - _firstSample.dts;\n      Compatibility.doFixLargeGap(audioSamples, this._audioLargeGap);\n    }\n    // step0. 首帧与video首帧间距大的问题\n    if (this._firstVideoSample && first) {\n      const videoFirstPts = this._firstVideoSample.pts ? this._firstVideoSample.pts : this._firstVideoSample.dts + this._firstVideoSample.cts;\n\n      if (firstSample.dts - videoFirstPts > meta.refSampleDuration) {\n        const silentSampleCount = Math.floor((firstSample.dts - videoFirstPts) / meta.refSampleDuration);\n\n        for (let i = 0; i < silentSampleCount; i++) {\n          const silentSample = {\n            data: silentFrame,\n            datasize: silentFrame.byteLength,\n            dts: firstSample.dts - (i + 1) * meta.refSampleDuration,\n            filtered: 0\n          };\n\n          audioSamples.unshift(silentSample);\n\n          this.filledAudioSamples.push({\n            dts: silentSample.dts,\n            size: silentSample.data.byteLength\n          });\n        }\n      }\n    }\n\n    let gap;\n    const firstDts = audioSamples[0].dts;\n\n    if (this.nextAudioDts) {\n      // step1. 处理samples段之间的丢帧情况\n      // 当发现duration差距大于1帧时进行补帧\n      gap = firstDts - this.nextAudioDts;\n      const absGap = Math.abs(gap);\n\n      if (absGap > meta.refSampleDuration && samplesLen === 1 && this.lastAudioSamplesLen === 1) {\n        meta.refSampleDurationFixed = undefined;\n      }\n\n      if (gap > 2 * meta.refSampleDuration) {\n        if (samplesLen === 1 && this.lastAudioSamplesLen === 1) {\n          // 如果sample的length一直是1，而且一直不符合refSampleDuration，需要动态修改refSampleDuration\n          meta.refSampleDurationFixed = meta.refSampleDurationFixed !== undefined ? meta.refSampleDurationFixed + gap : meta.refSampleDuration + gap;\n        } else {\n          const silentFrameCount = Math.floor(gap / meta.refSampleDuration);\n\n          for (let i = 0; i < silentFrameCount; i++) {\n            const computed = firstDts - (i + 1) * meta.refSampleDuration;\n            const silentSample = Object.assign({}, audioSamples[0], {\n              dts: computed > this.nextAudioDts ? computed : this.nextAudioDts\n            });\n\n            this.filledAudioSamples.push({\n              dts: silentSample.dts,\n              size: silentSample.data.byteLength\n            });\n            this.audioTrack.samples.unshift(silentSample);\n          }\n        }\n      } else if (absGap <= meta.refSampleDuration && absGap > 0) {\n        // 当差距比较小的时候将音频帧重定位\n        // console.log('重定位音频帧dts', audioSamples[0].dts, this.nextAudioDts)\n        audioSamples[0].dts = this.nextAudioDts;\n        audioSamples[0].pts = this.nextAudioDts;\n      } else if (gap < 0) {\n        Compatibility.doFixLargeGap(audioSamples, -1 * gap);\n      }\n    }\n    const lastDts = audioSamples[audioSamples.length - 1].dts;\n    const lastSampleDuration = audioSamples.length >= 2 ? lastDts - audioSamples[audioSamples.length - 2].dts : meta.refSampleDuration;\n\n    this.lastAudioSamplesLen = samplesLen;\n    this.nextAudioDts = meta.refSampleDurationFixed ? lastDts + meta.refSampleDurationFixed : lastDts + lastSampleDuration;\n    this.lastAudioDts = lastDts;\n\n    // step3. 修复samples段内部的dts异常问题\n    for (let i = 0, len = audioSamples.length; i < len; i++) {\n      const current = audioSamples[i];\n      const next = audioSamples[i + 1];\n\n      if (!next) {\n        break;\n      }\n\n      const duration = next.dts - current.dts;\n      audioSamples[i].duration = duration;\n      /*\n      if (duration > (2 * meta.refSampleDuration)) {\n        // 两帧之间间隔太大，需要补空白帧\n        /**\n        let silentFrameCount = Math.floor(duration / meta.refSampleDuration)\n        let frameIdx = 0\n         while (frameIdx < silentFrameCount) {\n          const silentSample = {\n            data: silentFrame,\n            datasize: silentFrame.byteLength,\n            dts: current.dts + (frameIdx + 1) * meta.refSampleDuration,\n            filtered: 0,\n            isSilent: true\n          }\n           audioSamples.splice(i, 0, silentSample)\n           this.filledAudioSamples.push({\n            dts: silentSample.dts,\n            size: silentSample.data.byteLength\n          })\n           frameIdx++\n          i++ // 不对静音帧做比较\n        }\n      } */\n    }\n\n    this.audioTrack.samples = Compatibility.sortAudioSamples(audioSamples);\n  }\n\n  fixChangeStreamVideo(changeIdx) {\n    const { samples, meta } = this.videoTrack;\n    const prevDts = changeIdx === 0 ? this.getStreamChangeStart(samples[0]) : samples[changeIdx - 1].dts;\n    const curDts = samples[changeIdx].dts;\n    const isContinue = Math.abs(prevDts - curDts) <= 2 * meta.refSampleDuration;\n\n    if (isContinue) {\n      if (!samples[changeIdx].options) {\n        samples[changeIdx].options = {\n          isContinue: true\n        };\n      } else {\n        samples[changeIdx].options.isContinue = true;\n      }\n      return this.doFixVideo(false);\n    }\n\n    const firstPartSamples = samples.slice(0, changeIdx);\n    const secondPartSamples = samples.slice(changeIdx);\n    const firstSample = samples[0];\n\n    const changeSample = secondPartSamples[0];\n    const firstPartDuration = changeSample.dts - firstSample.dts;\n    const streamChangeStart = firstSample.options && firstSample.options.start + firstPartDuration ? firstSample.options.start : null;\n\n    this.videoTrack.samples = samples.slice(0, changeIdx);\n\n    this.doFixVideo(false);\n\n    this.videoTrack.samples = samples.slice(changeIdx);\n\n    this.doFixVideo(false, streamChangeStart);\n\n    this.videoTrack.samples = firstPartSamples.concat(secondPartSamples);\n  }\n\n  fixChangeStreamAudio(changeIdx) {\n    const { samples, meta } = this.audioTrack;\n\n    const prevDts = changeIdx === 0 ? this.getStreamChangeStart(samples[0]) : samples[changeIdx - 1].dts;\n    const curDts = samples[changeIdx].dts;\n    const isContinue = Math.abs(prevDts - curDts) <= 2 * meta.refSampleDuration;\n\n    if (isContinue) {\n      if (!samples[changeIdx].options) {\n        samples[changeIdx].options = {\n          isContinue: true\n        };\n      } else {\n        samples[changeIdx].options.isContinue = true;\n      }\n      return this.doFixAudio(false);\n    }\n\n    const firstPartSamples = samples.slice(0, changeIdx);\n    const secondPartSamples = samples.slice(changeIdx);\n    const firstSample = samples[0];\n\n    const changeSample = secondPartSamples[0];\n    const firstPartDuration = changeSample.dts - firstSample.dts;\n    const streamChangeStart = firstSample.options && firstSample.options.start + firstPartDuration ? firstSample.options.start : null;\n\n    this.audioTrack.samples = firstPartSamples;\n\n    this.doFixAudio(false);\n\n    this.audioTrack.samples = secondPartSamples;\n\n    this.doFixAudio(false, streamChangeStart);\n\n    this.audioTrack.samples = firstPartSamples.concat(secondPartSamples);\n  }\n\n  getFirstSample() {\n    // 获取video和audio的首帧数据\n    let { samples: videoSamples } = this.videoTrack;\n    let { samples: audioSamples } = this.audioTrack;\n\n    let isFirstVideoSamples = false;\n    let isFirstAudioSamples = false;\n\n    if (!this._firstVideoSample && videoSamples.length) {\n      this._firstVideoSample = Compatibility.findFirstVideoSample(videoSamples);\n      isFirstVideoSamples = true;\n    }\n\n    if (!this._firstAudioSample && audioSamples.length) {\n      this._firstAudioSample = Compatibility.findFirstAudioSample(audioSamples); // 寻找dts最小的帧作为首个音频帧\n      isFirstAudioSamples = true;\n    }\n\n    return {\n      isFirstVideoSamples,\n      isFirstAudioSamples\n    };\n  }\n\n  /**\n   * 在没有refSampleDuration的问题流中，\n   */\n  fixRefSampleDuration(meta, samples) {\n    const isVideo = meta.type === 'video';\n    const allSamplesCount = isVideo ? this.allVideoSamplesCount : this.allAudioSamplesCount;\n    const firstDts = isVideo ? this._firstVideoSample.dts : this._firstAudioSample.dts;\n    const filledSamplesCount = isVideo ? this.filledVideoSamples.length : this.filledAudioSamples.length;\n\n    if (!meta.refSampleDuration || meta.refSampleDuration <= 0 || Number.isNaN(meta.refSampleDuration)) {\n      if (samples.length >= 1) {\n        const lastDts = samples[samples.length - 1].dts;\n\n        meta.refSampleDuration = Math.floor((lastDts - firstDts) / (allSamplesCount + filledSamplesCount - 1)); // 将refSampleDuration重置为计算后的平均值\n      }\n    } else if (meta.refSampleDuration) {\n      if (samples.length >= 5) {\n        const lastDts = samples[samples.length - 1].dts;\n        const firstDts = samples[0].dts;\n        const durationAvg = (lastDts - firstDts) / (samples.length - 1);\n\n        meta.refSampleDuration = Math.floor(Math.abs(meta.refSampleDuration - durationAvg) <= 5 ? meta.refSampleDuration : durationAvg); // 将refSampleDuration重置为计算后的平均值\n      }\n    }\n  }\n\n  /**\n   * 记录截止目前一共播放了多少帧\n   */\n  recordSamplesCount() {\n    const { audioTrack, videoTrack } = this;\n\n    this.allAudioSamplesCount += audioTrack.samples.length;\n    this.allVideoSamplesCount += videoTrack.samples.length;\n  }\n\n  /**\n   * 去除不合法的帧（倒退、重复帧）\n   */\n  removeInvalidSamples() {\n    const { _firstVideoSample, _firstAudioSample } = this;\n\n    this.audioTrack.samples = this.audioTrack.samples.filter(sample => {\n      return sample.dts >= _firstAudioSample.dts && (this.lastAudioDts === undefined || sample.dts > this.lastAudioDts);\n    });\n\n    this.videoTrack.samples = this.videoTrack.samples.filter(sample => {\n      return sample.dts >= _firstVideoSample.dts && (this.lastVideoDts === undefined || sample.dts > this.lastVideoDts);\n    });\n  }\n\n  getStreamChangeStart(sample) {\n    if (sample.options && sample.options.start) {\n      return sample.options.start - this.dtsBase;\n    }\n    return Infinity;\n  }\n\n  static sortAudioSamples(samples) {\n    if (samples.length === 1) {\n      return samples;\n    }\n\n    return samples.sort((a, b) => {\n      return a.dts - b.dts;\n    });\n  }\n\n  /**\n   * 寻找dts最小的sample\n   * @param samples\n   */\n  static findFirstAudioSample(samples) {\n    if (!samples || samples.length === 0) {\n      return null;\n    }\n\n    return Compatibility.sortAudioSamples(samples)[0];\n  }\n\n  static findFirstVideoSample(samples) {\n    if (!samples.length) {\n      return null;\n    }\n\n    const sorted = samples.sort((a, b) => {\n      return a.dts - b.dts;\n    });\n\n    for (let i = 0, len = sorted.length; i < len; i++) {\n      if (sorted[i].isKeyframe) {\n        return sorted[i];\n      }\n    }\n  }\n\n  static detectLargeGap(nextDts, firstSample) {\n    if (nextDts === null) {\n      return;\n    }\n    const curDts = firstSample.dts || 0;\n    const cond1 = nextDts - curDts >= 1000 || curDts - nextDts >= 1000; // fix hls流出现大量流dts间距问题\n    const cond2 = firstSample.options && firstSample.options.discontinue;\n\n    return cond1 || cond2;\n  }\n\n  static doFixLargeGap(samples, gap) {\n    for (let i = 0, len = samples.length; i < len; i++) {\n      const sample = samples[i];\n      sample.dts += gap;\n      if (sample.pts) {\n        sample.pts += gap;\n      }\n    }\n  }\n\n  /**\n   * 中途换流\n   */\n  static detactChangeStream(samples) {\n    let changed = false;\n    let changedIdx = -1;\n    for (let i = 0, len = samples.length; i < len; i++) {\n      if (samples[i].options && samples[i].options.meta) {\n        changed = true;\n        changedIdx = i;\n        break;\n      }\n    }\n\n    return {\n      changed,\n      changedIdx\n    };\n  }\n\n  get tracks() {\n    return this._context.getInstance('TRACKS');\n  }\n\n  get audioTrack() {\n    if (this.tracks) {\n      return this.tracks.audioTrack;\n    }\n    return null;\n  }\n\n  get videoTrack() {\n    if (this.tracks) {\n      return this.tracks.videoTrack;\n    }\n    return null;\n  }\n\n  get dtsBase() {\n    const remuxer = this._context.getInstance('MP4_REMUXER');\n    if (remuxer) {\n      return remuxer._dtsBase;\n    }\n    return 0;\n  }\n}\nexports.default = Compatibility;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-codec/src/compatibility.js?")},"../xgplayer-codec/src/h264/nalunit/golomb.js":
/*!****************************************************!*\
      !*** ../xgplayer-codec/src/h264/nalunit/golomb.js ***!
      \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass Golomb {\n  constructor(uint8array) {\n    this.TAG = 'Golomb';\n    this._buffer = uint8array;\n    this._bufferIndex = 0;\n    this._totalBytes = uint8array.byteLength;\n    this._totalBits = uint8array.byteLength * 8;\n    this._currentWord = 0;\n    this._currentWordBitsLeft = 0;\n  }\n\n  destroy() {\n    this._buffer = null;\n  }\n\n  _fillCurrentWord() {\n    let bufferBytesLeft = this._totalBytes - this._bufferIndex;\n    if (bufferBytesLeft <= 0) {\n      // TODO 异常处理\n    }\n\n    let bytesRead = Math.min(4, bufferBytesLeft);\n    let word = new Uint8Array(4);\n    word.set(this._buffer.subarray(this._bufferIndex, this._bufferIndex + bytesRead));\n    this._currentWord = new DataView(word.buffer).getUint32(0);\n\n    this._bufferIndex += bytesRead;\n    this._currentWordBitsLeft = bytesRead * 8;\n  }\n\n  readBits(size) {\n    let bits = Math.min(this._currentWordBitsLeft, size); // :uint\n    let valu = this._currentWord >>> 32 - bits;\n    if (size > 32) {\n      throw new Error('Cannot read more than 32 bits at a time');\n    }\n    this._currentWordBitsLeft -= bits;\n    if (this._currentWordBitsLeft > 0) {\n      this._currentWord <<= bits;\n    } else if (this._totalBytes - this._bufferIndex > 0) {\n      this._fillCurrentWord();\n    }\n\n    bits = size - bits;\n    if (bits > 0 && this._currentWordBitsLeft) {\n      return valu << bits | this.readBits(bits);\n    } else {\n      return valu;\n    }\n  }\n\n  readBool() {\n    return this.readBits(1) === 1;\n  }\n\n  readByte() {\n    return this.readBits(8);\n  }\n\n  _skipLeadingZero() {\n    let zeroCount;\n    for (zeroCount = 0; zeroCount < this._currentWordBitsLeft; zeroCount++) {\n      if ((this._currentWord & 0x80000000 >>> zeroCount) !== 0) {\n        this._currentWord <<= zeroCount;\n        this._currentWordBitsLeft -= zeroCount;\n        return zeroCount;\n      }\n    }\n    this._fillCurrentWord();\n    return zeroCount + this._skipLeadingZero();\n  }\n\n  readUEG() {\n    // unsigned exponential golomb\n    let leadingZeros = this._skipLeadingZero();\n    return this.readBits(leadingZeros + 1) - 1;\n  }\n\n  readSEG() {\n    // signed exponential golomb\n    let value = this.readUEG();\n    if (value & 0x01) {\n      return value + 1 >>> 1;\n    } else {\n      return -1 * (value >>> 1);\n    }\n  }\n}\n\nexports.default = Golomb;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-codec/src/h264/nalunit/golomb.js?")},"../xgplayer-codec/src/h264/nalunit/index.js":
/*!***************************************************!*\
      !*** ../xgplayer-codec/src/h264/nalunit/index.js ***!
      \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _sps = __webpack_require__(/*! ./sps */ "../xgplayer-codec/src/h264/nalunit/sps.js");\n\nvar _sps2 = _interopRequireDefault(_sps);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Nalunit {\n  static getNalunits(buffer) {\n    if (buffer.length - buffer.position < 4) {\n      return [];\n    }\n\n    let buf = buffer.dataview;\n    let position = buffer.position;\n    if (buf.getInt32(position) === 1 || buf.getInt16(position) === 0 && buf.getInt8(position + 2) === 1) {\n      return Nalunit.getAnnexbNals(buffer);\n    } else {\n      return Nalunit.getAvccNals(buffer);\n    }\n  }\n\n  static getAnnexbNals(buffer) {\n    let nals = [];\n    let position = Nalunit.getHeaderPositionAnnexB(buffer);\n    let start = position.pos;\n    let end = start;\n    while (start < buffer.length - 4) {\n      let header = buffer.buffer.slice(start, start + position.headerLength);\n      if (position.pos === buffer.position) {\n        buffer.skip(position.headerLength);\n      }\n      position = Nalunit.getHeaderPositionAnnexB(buffer);\n      end = position.pos;\n      let body = new Uint8Array(buffer.buffer.slice(start + header.byteLength, end));\n      let unit = { header, body };\n      Nalunit.analyseNal(unit);\n      nals.push(unit);\n      buffer.skip(end - buffer.position);\n      start = end;\n    }\n    return nals;\n  }\n\n  static getAvccNals(buffer) {\n    let nals = [];\n    while (buffer.position < buffer.length - 4) {\n      let length = buffer.dataview.getInt32(buffer.position);\n      if (buffer.length - buffer.position >= length) {\n        let header = buffer.buffer.slice(buffer.position, buffer.position + 4);\n        buffer.skip(4);\n        let body = buffer.buffer.slice(buffer.position, buffer.position + length);\n        buffer.skip(length);\n        let unit = { header, body };\n        Nalunit.analyseNal(unit);\n        nals.push(unit);\n      } else {\n        break;\n      }\n    }\n    return nals;\n  }\n\n  static analyseNal(unit) {\n    let type = unit.body[0] & 0x1f;\n    switch (type) {\n      case 1:\n        // NDR\n        unit.ndr = true;\n        break;\n      case 5:\n        // IDR\n        unit.idr = true;\n        break;\n      case 6:\n        // SEI\n        break;\n      case 7:\n        // SPS\n        unit.sps = _sps2.default.parseSPS(unit.body);\n        break;\n      case 8:\n        // PPS\n        unit.pps = true;\n        break;\n      case 9:\n        // AUD\n        break;\n      default:\n        break;\n    }\n  }\n\n  static getHeaderPositionAnnexB(buffer) {\n    // seperate\n    let pos = buffer.position;\n    let headerLength = 0;\n    while (headerLength !== 3 && headerLength !== 4 && pos < buffer.length - 4) {\n      if (buffer.dataview.getInt16(pos) === 0) {\n        if (buffer.dataview.getInt16(pos + 2) === 1) {\n          // 0x000001\n          headerLength = 4;\n        } else if (buffer.dataview.getInt8(pos + 2) === 1) {\n          headerLength = 3;\n        } else {\n          pos++;\n        }\n      } else {\n        pos++;\n      }\n    }\n\n    if (pos === buffer.length - 4) {\n      if (buffer.dataview.getInt16(pos) === 0) {\n        if (buffer.dataview.getInt16(pos + 2) === 1) {\n          // 0x000001\n          headerLength = 4;\n        }\n      } else {\n        pos++;\n        if (buffer.dataview.getInt16(pos) === 0 && buffer.dataview.getInt8(pos) === 1) {\n          // 0x0000001\n          headerLength = 3;\n        } else {\n          pos = buffer.length;\n        }\n      }\n    }\n    return { pos, headerLength };\n  }\n\n  static getAvcc(sps, pps) {\n    let ret = new Uint8Array(sps.byteLength + pps.byteLength + 11);\n    ret[0] = 0x01;\n    ret[1] = sps[1];\n    ret[2] = sps[2];\n    ret[3] = sps[3];\n    ret[4] = 255;\n    ret[5] = 225;\n\n    let offset = 6;\n\n    ret.set(new Uint8Array([sps.byteLength >>> 8 & 0xff, sps.byteLength & 0xff]), offset);\n    offset += 2;\n    ret.set(sps, offset);\n    offset += sps.byteLength;\n\n    ret[offset] = 1;\n    offset++;\n\n    ret.set(new Uint8Array([pps.byteLength >>> 8 & 0xff, pps.byteLength & 0xff]), offset);\n    offset += 2;\n    ret.set(pps, offset);\n    return ret;\n  }\n}\n\nexports.default = Nalunit;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-codec/src/h264/nalunit/index.js?')},"../xgplayer-codec/src/h264/nalunit/sps.js":
/*!*************************************************!*\
      !*** ../xgplayer-codec/src/h264/nalunit/sps.js ***!
      \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _golomb = __webpack_require__(/*! ./golomb */ \"../xgplayer-codec/src/h264/nalunit/golomb.js\");\n\nvar _golomb2 = _interopRequireDefault(_golomb);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass SPSParser {\n  static _ebsp2rbsp(uint8array) {\n    let src = uint8array;\n    let srcLength = src.byteLength;\n    let dst = new Uint8Array(srcLength);\n    let dstIdx = 0;\n\n    for (let i = 0; i < srcLength; i++) {\n      if (i >= 2) {\n        if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {\n          continue;\n        }\n      }\n      dst[dstIdx] = src[i];\n      dstIdx++;\n    }\n\n    return new Uint8Array(dst.buffer, 0, dstIdx);\n  }\n\n  static parseSPS(uint8array) {\n    let rbsp = SPSParser._ebsp2rbsp(uint8array);\n    let gb = new _golomb2.default(rbsp);\n\n    gb.readByte();\n    let profileIdc = gb.readByte();\n    gb.readByte();\n    let levelIdc = gb.readByte();\n    gb.readUEG();\n\n    let profile_string = SPSParser.getProfileString(profileIdc);\n    let level_string = SPSParser.getLevelString(levelIdc);\n    let chroma_format_idc = 1;\n    let chroma_format = 420;\n    let chroma_format_table = [0, 420, 422, 444];\n    let bit_depth = 8;\n\n    if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128 || profileIdc === 138 || profileIdc === 144) {\n      chroma_format_idc = gb.readUEG();\n      if (chroma_format_idc === 3) {\n        gb.readBits(1);\n      }\n      if (chroma_format_idc <= 3) {\n        chroma_format = chroma_format_table[chroma_format_idc];\n      }\n\n      bit_depth = gb.readUEG() + 8;\n      gb.readUEG();\n      gb.readBits(1);\n      if (gb.readBool()) {\n        let scaling_list_count = chroma_format_idc !== 3 ? 8 : 12;\n        for (let i = 0; i < scaling_list_count; i++) {\n          if (gb.readBool()) {\n            if (i < 6) {\n              SPSParser._skipScalingList(gb, 16);\n            } else {\n              SPSParser._skipScalingList(gb, 64);\n            }\n          }\n        }\n      }\n    }\n    gb.readUEG();\n    let pic_order_cnt_type = gb.readUEG();\n    if (pic_order_cnt_type === 0) {\n      gb.readUEG();\n    } else if (pic_order_cnt_type === 1) {\n      gb.readBits(1);\n      gb.readSEG();\n      gb.readSEG();\n      let num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG();\n      for (let i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {\n        gb.readSEG();\n      }\n    }\n    gb.readUEG();\n    gb.readBits(1);\n\n    let pic_width_in_mbs_minus1 = gb.readUEG();\n    let pic_height_in_map_units_minus1 = gb.readUEG();\n\n    let frame_mbs_only_flag = gb.readBits(1);\n    if (frame_mbs_only_flag === 0) {\n      gb.readBits(1);\n    }\n    gb.readBits(1);\n\n    let frame_crop_left_offset = 0;\n    let frame_crop_right_offset = 0;\n    let frame_crop_top_offset = 0;\n    let frame_crop_bottom_offset = 0;\n\n    let frame_cropping_flag = gb.readBool();\n    if (frame_cropping_flag) {\n      frame_crop_left_offset = gb.readUEG();\n      frame_crop_right_offset = gb.readUEG();\n      frame_crop_top_offset = gb.readUEG();\n      frame_crop_bottom_offset = gb.readUEG();\n    }\n\n    let par_width = 1,\n        par_height = 1;\n    let fps = 0,\n        fps_fixed = true,\n        fps_num = 0,\n        fps_den = 0;\n\n    let vui_parameters_present_flag = gb.readBool();\n    if (vui_parameters_present_flag) {\n      if (gb.readBool()) {\n        // aspect_ratio_info_present_flag\n        let aspect_ratio_idc = gb.readByte();\n        let par_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];\n        let par_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];\n\n        if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {\n          par_width = par_w_table[aspect_ratio_idc - 1];\n          par_height = par_h_table[aspect_ratio_idc - 1];\n        } else if (aspect_ratio_idc === 255) {\n          par_width = gb.readByte() << 8 | gb.readByte();\n          par_height = gb.readByte() << 8 | gb.readByte();\n        }\n      }\n\n      if (gb.readBool()) {\n        gb.readBool();\n      }\n      if (gb.readBool()) {\n        gb.readBits(4);\n        if (gb.readBool()) {\n          gb.readBits(24);\n        }\n      }\n      if (gb.readBool()) {\n        gb.readUEG();\n        gb.readUEG();\n      }\n      if (gb.readBool()) {\n        let num_units_in_tick = gb.readBits(32);\n        let time_scale = gb.readBits(32);\n        fps_fixed = gb.readBool();\n\n        fps_num = time_scale;\n        fps_den = num_units_in_tick * 2;\n        fps = fps_num / fps_den;\n      }\n    }\n\n    let parScale = 1;\n    if (par_width !== 1 || par_height !== 1) {\n      parScale = par_width / par_height;\n    }\n\n    let crop_unit_x = 0,\n        crop_unit_y = 0;\n    if (chroma_format_idc === 0) {\n      crop_unit_x = 1;\n      crop_unit_y = 2 - frame_mbs_only_flag;\n    } else {\n      let sub_wc = chroma_format_idc === 3 ? 1 : 2;\n      let sub_hc = chroma_format_idc === 1 ? 2 : 1;\n      crop_unit_x = sub_wc;\n      crop_unit_y = sub_hc * (2 - frame_mbs_only_flag);\n    }\n\n    let codec_width = (pic_width_in_mbs_minus1 + 1) * 16;\n    let codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16);\n\n    codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x;\n    codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y;\n\n    let present_width = Math.ceil(codec_width * parScale);\n\n    gb.destroy();\n    gb = null;\n\n    return {\n      profile_string: profile_string,\n      level_string: level_string,\n      bit_depth: bit_depth,\n      chroma_format: chroma_format,\n      chroma_format_string: SPSParser.getChromaFormatString(chroma_format),\n\n      frame_rate: {\n        fixed: fps_fixed,\n        fps: fps,\n        fps_den: fps_den,\n        fps_num: fps_num\n      },\n\n      par_ratio: {\n        width: par_width,\n        height: par_height\n      },\n\n      codec_size: {\n        width: codec_width,\n        height: codec_height\n      },\n\n      present_size: {\n        width: present_width,\n        height: codec_height\n      }\n    };\n  }\n\n  static _skipScalingList(gb, count) {\n    let last_scale = 8,\n        next_scale = 8;\n    let delta_scale = 0;\n    for (let i = 0; i < count; i++) {\n      if (next_scale !== 0) {\n        delta_scale = gb.readSEG();\n        next_scale = (last_scale + delta_scale + 256) % 256;\n      }\n      last_scale = next_scale === 0 ? last_scale : next_scale;\n    }\n  }\n\n  static getProfileString(profileIdc) {\n    switch (profileIdc) {\n      case 66:\n        return 'Baseline';\n      case 77:\n        return 'Main';\n      case 88:\n        return 'Extended';\n      case 100:\n        return 'High';\n      case 110:\n        return 'High10';\n      case 122:\n        return 'High422';\n      case 244:\n        return 'High444';\n      default:\n        return 'Unknown';\n    }\n  }\n\n  static getLevelString(levelIdc) {\n    return (levelIdc / 10).toFixed(1);\n  }\n\n  static getChromaFormatString(chroma) {\n    switch (chroma) {\n      case 420:\n        return '4:2:0';\n      case 422:\n        return '4:2:2';\n      case 444:\n        return '4:4:4';\n      default:\n        return 'Unknown';\n    }\n  }\n\n  static toVideoMeta(spsConfig) {\n    let meta = {};\n    if (spsConfig && spsConfig.codec_size) {\n      meta.codecWidth = spsConfig.codec_size.width;\n      meta.codecHeight = spsConfig.codec_size.height;\n      meta.presentWidth = spsConfig.present_size.width;\n      meta.presentHeight = spsConfig.present_size.height;\n    }\n\n    meta.profile = spsConfig.profile_string;\n    meta.level = spsConfig.level_string;\n    meta.bitDepth = spsConfig.bit_depth;\n    meta.chromaFormat = spsConfig.chroma_format;\n\n    meta.parRatio = {\n      width: spsConfig.par_ratio.width,\n      height: spsConfig.par_ratio.height\n    };\n\n    meta.frameRate = spsConfig.frame_rate;\n\n    let fpsDen = meta.frameRate.fps_den;\n    let fpsNum = meta.frameRate.fps_num;\n    meta.refSampleDuration = Math.floor(meta.timescale * (fpsDen / fpsNum));\n    return meta;\n  }\n} /* eslint-disable camelcase  */\n/* eslint-disable one-var  */\nexports.default = SPSParser;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-codec/src/h264/nalunit/sps.js?")},"../xgplayer-demux/index.js":
/*!**********************************!*\
      !*** ../xgplayer-demux/index.js ***!
      \**********************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nmodule.exports = {\n  // HLS\n  M3U8Parser: __webpack_require__(/*! ./src/hls/demuxer/m3u8parser */ "../xgplayer-demux/src/hls/demuxer/m3u8parser.js").default,\n  TsDemuxer: __webpack_require__(/*! ./src/hls/demuxer/ts */ "../xgplayer-demux/src/hls/demuxer/ts.js").default,\n  Playlist: __webpack_require__(/*! ./src/hls/playlist */ "../xgplayer-demux/src/hls/playlist.js").default,\n  FlvDemuxer: __webpack_require__(/*! ./src/flv/index */ "../xgplayer-demux/src/flv/index.js").default\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-demux/index.js?')},"../xgplayer-demux/src/flv/amf-parser.js":
/*!***********************************************!*\
      !*** ../xgplayer-demux/src/flv/amf-parser.js ***!
      \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nconst DATA_TYPES = {\n  NUMBER: 0,\n  BOOLEAN: 1,\n  STRING: 2,\n  OBJECT: 3,\n  MIX_ARRAY: 8,\n  OBJECT_END: 9,\n  STRICT_ARRAY: 10,\n  DATE: 11,\n  LONE_STRING: 12\n\n  /**\n   * meta信息解析\n   */\n};class AMFParser {\n  constructor() {\n    this.offset = 0;\n    this.readOffset = this.offset;\n  }\n\n  resolve(meta, size) {\n    if (size < 3) {\n      throw new Error('not enough data for metainfo');\n    }\n    const metaData = {};\n    const name = this.parseValue(meta);\n    const value = this.parseValue(meta, size - name.bodySize);\n    metaData[name.data] = value.data;\n\n    this.resetStatus();\n    return metaData;\n  }\n\n  resetStatus() {\n    this.offset = 0;\n    this.readOffset = this.offset;\n  }\n\n  parseString(buffer) {\n    const dv = new DataView(buffer, this.readOffset);\n    const strLen = dv.getUint16(0, !_xgplayerUtils.isLe);\n    let str = '';\n    if (strLen > 0) {\n      str = _xgplayerUtils.UTF8.decode(new Uint8Array(buffer, this.readOffset + 2, strLen));\n    } else {\n      str = '';\n    }\n    let size = strLen + 2;\n    this.readOffset += size;\n    return {\n      data: str,\n      bodySize: strLen + 2\n    };\n  }\n\n  parseDate(buffer, size) {\n    const dv = new DataView(buffer, this.readOffset, size);\n    let ts = dv.getFloat64(0, !_xgplayerUtils.isLe);\n    const timeOffset = dv.getInt16(8, !_xgplayerUtils.isLe);\n    ts += timeOffset * 60 * 1000;\n\n    this.readOffset += 10;\n    return {\n      data: new Date(ts),\n      bodySize: 10\n    };\n  }\n\n  parseObject(buffer, size) {\n    const name = this.parseString(buffer, size);\n    const value = this.parseValue(buffer, size - name.bodySize);\n    return {\n      data: {\n        name: name.data,\n        value: value.data\n      },\n      bodySize: name.bodySize + value.bodySize,\n      isObjEnd: value.isObjEnd\n    };\n  }\n\n  parseLongString(buffer) {\n    const dv = new DataView(buffer, this.readOffset);\n    const strLen = dv.getUint32(0, !_xgplayerUtils.isLe);\n    let str = '';\n    if (strLen > 0) {\n      str = _xgplayerUtils.UTF8.decode(new Uint8Array(buffer, this.readOffset + 2, strLen));\n    } else {\n      str = '';\n    }\n    // const size = strLen + 4;\n    this.readOffset += strLen + 4;\n    return {\n      data: str,\n      bodySize: strLen + 4\n    };\n  }\n\n  /**\n   * 解析meta中的变量\n   */\n  parseValue(data, size) {\n    let buffer = new ArrayBuffer();\n    if (data instanceof ArrayBuffer) {\n      buffer = data;\n    } else {\n      buffer = data.buffer;\n    }\n    const {\n      NUMBER,\n      BOOLEAN,\n      STRING,\n      OBJECT,\n      MIX_ARRAY,\n      OBJECT_END,\n      STRICT_ARRAY,\n      DATE,\n      LONE_STRING\n    } = DATA_TYPES;\n    const dataView = new DataView(buffer, this.readOffset, size);\n    let isObjEnd = false;\n    const type = dataView.getUint8(0);\n    let offset = 1;\n    this.readOffset += 1;\n    let value = null;\n\n    switch (type) {\n      case NUMBER:\n        {\n          value = dataView.getFloat64(1, !_xgplayerUtils.isLe);\n          this.readOffset += 8;\n          offset += 8;\n          break;\n        }\n      case BOOLEAN:\n        {\n          const boolNum = dataView.getUint8(1);\n          value = !!boolNum;\n          this.readOffset += 1;\n          offset += 1;\n          break;\n        }\n      case STRING:\n        {\n          const str = this.parseString(buffer);\n          value = str.data;\n          offset += str.bodySize;\n          break;\n        }\n      case OBJECT:\n        {\n          value = {};\n          let objEndSize = 0;\n          if (dataView.getUint32(size - 4, !_xgplayerUtils.isLe) & 0x00FFFFFF) {\n            objEndSize = 3;\n          }\n          // this.readOffset += offset - 1;\n          while (offset < size - 4) {\n            const amfObj = this.parseObject(buffer, size - offset - objEndSize);\n            if (amfObj.isObjectEnd) {\n              break;\n            }\n            value[amfObj.data.name] = amfObj.data.value;\n            offset += amfObj.bodySize;\n          }\n          if (offset <= size - 3) {\n            const mark = dataView.getUint32(offset - 1, !_xgplayerUtils.isLe) & 0x00FFFFFF;\n            if (mark === 9) {\n              this.readOffset += 3;\n              offset += 3;\n            }\n          }\n          break;\n        }\n      case MIX_ARRAY:\n        {\n          value = {};\n          offset += 4;\n          this.readOffset += 4;\n          let objEndSize = 0;\n          if ((dataView.getUint32(size - 4, !_xgplayerUtils.isLe) & 0x00FFFFFF) === 9) {\n            objEndSize = 3;\n          }\n\n          while (offset < size - 8) {\n            const amfVar = this.parseObject(buffer, size - offset - objEndSize);\n            if (amfVar.isObjectEnd) {\n              break;\n            }\n            value[amfVar.data.name] = amfVar.data.value;\n            offset += amfVar.bodySize;\n          }\n          if (offset <= size - 3) {\n            const marker = dataView.getUint32(offset - 1, !_xgplayerUtils.isLe) & 0x00FFFFFF;\n            if (marker === 9) {\n              offset += 3;\n              this.readOffset += 3;\n            }\n          }\n          break;\n        }\n\n      case OBJECT_END:\n        {\n          value = null;\n          isObjEnd = true;\n          break;\n        }\n\n      case STRICT_ARRAY:\n        {\n          value = [];\n          const arrLength = dataView.getUint32(1, !_xgplayerUtils.isLe);\n          offset += 4;\n          this.readOffset += 4;\n          for (let i = 0; i < arrLength; i++) {\n            const script = this.parseValue(buffer, size - offset);\n            value.push(script.data);\n            offset += script.bodySize;\n          }\n          break;\n        }\n\n      case DATE:\n        {\n          const date = this.parseDate(buffer, size - 1);\n          value = date.data;\n          offset += date.bodySize;\n          break;\n        }\n\n      case LONE_STRING:\n        {\n          const longStr = this.parseLongString(buffer, size - 1);\n          value = longStr.data;\n          offset += longStr.bodySize;\n          break;\n        }\n\n      default:\n        {\n          offset = size;\n        }\n    }\n\n    return {\n      data: value,\n      bodySize: offset,\n      isObjEnd: isObjEnd\n    };\n  }\n}\nexports.default = AMFParser;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-demux/src/flv/amf-parser.js?")},"../xgplayer-demux/src/flv/index.js":
/*!******************************************!*\
      !*** ../xgplayer-demux/src/flv/index.js ***!
      \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nvar _xgplayerCodec = __webpack_require__(/*! xgplayer-codec */ \"../xgplayer-codec/index.js\");\n\nvar _xgplayerBuffer = __webpack_require__(/*! xgplayer-buffer */ \"../xgplayer-buffer/index.js\");\n\nvar _amfParser = __webpack_require__(/*! ./amf-parser */ \"../xgplayer-demux/src/flv/amf-parser.js\");\n\nvar _amfParser2 = _interopRequireDefault(_amfParser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst DEMUX_EVENTS = _xgplayerUtils.EVENTS.DEMUX_EVENTS;\n\nclass FlvDemuxer {\n  constructor() {\n    this._firstFragmentLoaded = false;\n    this._trackNum = 0;\n    this._hasScript = false;\n  }\n\n  init() {\n    this.on(DEMUX_EVENTS.DEMUX_START, this.doParseFlv.bind(this));\n  }\n\n  /**\n   * if the flv head is valid\n   * @param data\n   * @returns {boolean}\n   */\n  static isFlvFile(data) {\n    return !(data[0] !== 0x46 || data[1] !== 0x4C || data[2] !== 0x56 || data[3] !== 0x01);\n  }\n\n  /**\n   * If the stream has audio or video.\n   * @param {number} streamFlag - Data from the stream which is define whether the audio / video track is exist.\n   */\n  static getPlayType(streamFlag) {\n    const result = {\n      hasVideo: false,\n      hasAudio: false\n    };\n\n    if (streamFlag & 0x01 > 0) {\n      result.hasVideo = true;\n    }\n\n    if (streamFlag & 0x04 > 0) {\n      result.hasAudio = true;\n    }\n\n    return result;\n  }\n\n  doParseFlv() {\n    if (!this._firstFragmentLoaded) {\n      if (this.loaderBuffer.length < 13) {\n        return;\n      }\n      const header = this.loaderBuffer.shift(13);\n      this.parseFlvHeader(header);\n      this.doParseFlv(); // 递归调用，继续解析flv流\n    } else {\n      if (this.loaderBuffer.length < 11) {\n        return;\n      }\n      let chunk;\n\n      let loopMax = 100000; // 防止死循环产生\n      do {\n        chunk = this._parseFlvTag();\n      } while (chunk && loopMax-- > 0);\n\n      this.emit(DEMUX_EVENTS.DEMUX_COMPLETE);\n    }\n  }\n\n  parseFlvHeader(header) {\n    if (!FlvDemuxer.isFlvFile(header)) {\n      this.emit(DEMUX_EVENTS.DEMUX_ERROR, new Error('invalid flv file'));\n      this.doParseFlv();\n    } else {\n      this._firstFragmentLoaded = true;\n      const playType = FlvDemuxer.getPlayType(header[4]);\n\n      if (playType.hasVideo) {\n        this.initVideoTrack();\n      }\n\n      if (playType.hasAudio) {\n        this.initAudioTrack();\n      }\n    }\n    this.doParseFlv();\n  }\n\n  /**\n   * init default video track configs\n   */\n  initVideoTrack() {\n    this._trackNum++;\n    let videoTrack = new _xgplayerBuffer.VideoTrack();\n    videoTrack.meta = new _xgplayerUtils.VideoTrackMeta();\n    videoTrack.id = videoTrack.meta.id = this._trackNum;\n\n    this.tracks.videoTrack = videoTrack;\n  }\n\n  /**\n   * init default audio track configs\n   */\n  initAudioTrack() {\n    this._trackNum++;\n    let audioTrack = new _xgplayerBuffer.AudioTrack();\n    audioTrack.meta = new _xgplayerUtils.AudioTrackMeta();\n    audioTrack.id = audioTrack.meta.id = this._trackNum;\n\n    this.tracks.audioTrack = audioTrack;\n  }\n\n  /**\n   * Package the data as the following data structure\n   * {\n   *    data: Uint8Array. the Stream data.\n   *    info: The first byte info of the Tag.\n   *    tagType: 8、9、18\n   *    timeStamp: the timestemp\n   * }\n   */\n  _parseFlvTag() {\n    if (this.loaderBuffer.length < 11) {\n      return null;\n    }\n    let chunk = this._parseFlvTagHeader();\n    if (chunk) {\n      this._processChunk(chunk);\n    }\n    return chunk;\n  }\n\n  /**\n   * Parse the 11 byte tag Header\n   */\n  _parseFlvTagHeader() {\n    let offset = 0;\n    let chunk = {};\n\n    let tagType = this.loaderBuffer.toInt(offset, 1);\n    offset += 1;\n\n    // 2 bit FMS reserved, 1 bit filtered, 5 bit tag type\n    chunk.filtered = (tagType & 32) >>> 5;\n    chunk.tagType = tagType & 31;\n\n    // 3 Byte datasize\n    chunk.datasize = this.loaderBuffer.toInt(offset, 3);\n    offset += 3;\n\n    if (chunk.tagType !== 8 && chunk.tagType !== 9 && chunk.tagType !== 11 && chunk.tagType !== 18 || this.loaderBuffer.toInt(8, 3) !== 0) {\n      if (this.loaderBuffer && this.loaderBuffer.length > 0) {\n        this.loaderBuffer.shift(1);\n      }\n      this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error('tagType ' + chunk.tagType), false);\n      return null;\n    }\n\n    if (this.loaderBuffer.length < chunk.datasize + 15) {\n      return null;\n    }\n\n    // read the data.\n    this.loaderBuffer.shift(4);\n\n    // 3 Byte timestamp\n    let timestamp = this.loaderBuffer.toInt(0, 3);\n    this.loaderBuffer.shift(3);\n\n    // 1 Byte timestampExt\n    let timestampExt = this.loaderBuffer.shift(1)[0];\n    if (timestampExt > 0) {\n      timestamp += timestampExt * 0x1000000;\n    }\n\n    chunk.dts = timestamp;\n\n    // streamId\n    this.loaderBuffer.shift(3);\n    return chunk;\n  }\n\n  _processChunk(chunk) {\n    switch (chunk.tagType) {\n      case 18:\n        this._parseScriptData(chunk);\n        break;\n      case 8:\n        this._parseAACData(chunk);\n        break;\n      case 9:\n        this._parseHevcData(chunk);\n        break;\n      case 11:\n        // for some CDN that did not process the currect RTMP messages\n        this.loaderBuffer.shift(3);\n        break;\n      default:\n        this.loaderBuffer.shift(1);\n    }\n  }\n\n  /**\n   * parse flv script data\n   * @param chunk\n   * @private\n   */\n  _parseScriptData(chunk) {\n    let audioTrack = this.tracks.audioTrack;\n    let videoTrack = this.tracks.videoTrack;\n\n    let data = this.loaderBuffer.shift(chunk.datasize);\n\n    const info = new _amfParser2.default().resolve(data, data.length);\n\n    const onMetaData = this._context.onMetaData = info ? info.onMetaData : undefined;\n\n    // fill mediaInfo\n    this._context.mediaInfo.duration = onMetaData.duration;\n    this._context.mediaInfo.hasVideo = onMetaData.hasVideo;\n    this._context.mediaInfo.hsaAudio = onMetaData.hasAudio;\n\n    let validate = this._datasizeValidator(chunk.datasize);\n    if (validate) {\n      this.emit(DEMUX_EVENTS.MEDIA_INFO);\n      this._hasScript = true;\n    }\n\n    // Edit default meta.\n    if (audioTrack && !audioTrack.hasSpecificConfig) {\n      let meta = audioTrack.meta;\n      if (onMetaData.audiosamplerate) {\n        meta.sampleRate = onMetaData.audiosamplerate;\n      }\n\n      if (onMetaData.audiochannels) {\n        meta.channelCount = onMetaData.audiochannels;\n      }\n\n      switch (onMetaData.audiosamplerate) {\n        case 44100:\n          meta.sampleRateIndex = 4;\n          break;\n        case 22050:\n          meta.sampleRateIndex = 7;\n          break;\n        case 11025:\n          meta.sampleRateIndex = 10;\n          break;\n      }\n    }\n    if (videoTrack && !videoTrack.hasSpecificConfig) {\n      let meta = videoTrack.meta;\n      if (typeof onMetaData.framerate === 'number') {\n        let fpsNum = Math.floor(onMetaData.framerate * 1000);\n        if (fpsNum > 0) {\n          let fps = fpsNum / 1000;\n          if (!meta.frameRate) {\n            meta.frameRate = {};\n          }\n          meta.frameRate.fixed = true;\n          meta.frameRate.fps = fps;\n          meta.frameRate.fps_num = fpsNum;\n          meta.frameRate.fps_den = 1000;\n        }\n      }\n    }\n  }\n\n  _aacSequenceHeaderParser(data) {\n    let ret = {};\n    ret.hasSpecificConfig = true;\n    ret.objectType = data[1] >>> 3;\n    ret.sampleRateIndex = (data[1] & 7) << 1 | data[2] >>> 7;\n    ret.audiosamplerate = this._switchAudioSampleRate(ret.sampleRateIndex);\n    ret.channelCount = (data[2] & 120) >>> 3;\n    ret.frameLength = (data[2] & 4) >>> 2;\n    ret.dependsOnCoreCoder = (data[2] & 2) >>> 1;\n    ret.extensionFlagIndex = data[2] & 1;\n\n    ret.codec = `mp4a.40.${ret.objectType}`;\n    let userAgent = window.navigator.userAgent.toLowerCase();\n    let extensionSamplingIndex;\n\n    let config;\n    let samplingIndex = ret.sampleRateIndex;\n\n    if (userAgent.indexOf('firefox') !== -1) {\n      // firefox: use SBR (HE-AAC) if freq less than 24kHz\n      if (ret.sampleRateIndex >= 6) {\n        ret.objectType = 5;\n        config = new Array(4);\n        extensionSamplingIndex = samplingIndex - 3;\n      } else {\n        // use LC-AAC\n        ret.objectType = 2;\n        config = new Array(2);\n        extensionSamplingIndex = samplingIndex;\n      }\n    } else if (userAgent.indexOf('android') !== -1) {\n      // android: always use LC-AAC\n      ret.objectType = 2;\n      config = new Array(2);\n      extensionSamplingIndex = samplingIndex;\n    } else {\n      // for other browsers, e.g. chrome...\n      // Always use HE-AAC to make it easier to switch aac codec profile\n      ret.objectType = 5;\n      extensionSamplingIndex = ret.sampleRateIndex;\n      config = new Array(4);\n\n      if (ret.sampleRateIndex >= 6) {\n        extensionSamplingIndex = ret.sampleRateIndex - 3;\n      } else if (ret.channelCount === 1) {\n        // Mono channel\n        ret.objectType = 2;\n        config = new Array(2);\n        extensionSamplingIndex = ret.sampleRateIndex;\n      }\n    }\n\n    config[0] = ret.objectType << 3;\n    config[0] |= (ret.sampleRateIndex & 0x0F) >>> 1;\n    config[1] = (ret.sampleRateIndex & 0x0F) << 7;\n    config[1] |= (ret.channelCount & 0x0F) << 3;\n    if (ret.objectType === 5) {\n      config[1] |= (extensionSamplingIndex & 0x0F) >>> 1;\n      config[2] = (extensionSamplingIndex & 0x01) << 7;\n      // extended audio object type: force to 2 (LC-AAC)\n      config[2] |= 2 << 2;\n      config[3] = 0;\n    }\n    ret.config = config;\n    return ret;\n  }\n\n  _parseAACData(chunk) {\n    let track = this.tracks.audioTrack;\n    if (!track) {\n      return;\n    }\n\n    let meta = track.meta;\n\n    if (!meta) {\n      track.meta = new _xgplayerUtils.AudioTrackMeta();\n      meta = track.meta;\n    }\n\n    let info = this.loaderBuffer.shift(1)[0];\n\n    chunk.data = this.loaderBuffer.shift(chunk.datasize - 1);\n\n    let format = (info & 240) >>> 4;\n\n    track.format = format;\n\n    if (format !== 10) {\n      this.emit(DEMUX_EVENTS.DEMUX_ERROR, new Error(`invalid audio format: ${format}`));\n    }\n\n    if (format === 10 && !this._hasAudioSequence) {\n      meta.sampleRate = this._switchAudioSamplingFrequency(info);\n      meta.sampleRateIndex = (info & 12) >>> 2;\n      meta.frameLenth = (info & 2) >>> 1;\n      meta.channelCount = info & 1;\n      meta.refSampleDuration = Math.floor(1024 / meta.audioSampleRate * meta.timescale);\n    }\n\n    let audioSampleRate = meta.audioSampleRate;\n    let audioSampleRateIndex = meta.sampleRateIndex;\n    let refSampleDuration = meta.refSampleDuration;\n\n    delete chunk.tagType;\n    let validate = this._datasizeValidator(chunk.datasize);\n\n    if (chunk.data[0] === 0) {\n      // AAC Sequence Header\n      let aacHeader = this._aacSequenceHeaderParser(chunk.data);\n      audioSampleRate = aacHeader.audiosamplerate || meta.audioSampleRate;\n      audioSampleRateIndex = aacHeader.sampleRateIndex || meta.sampleRateIndex;\n      refSampleDuration = Math.floor(1024 / audioSampleRate * meta.timescale);\n\n      meta.channelCount = aacHeader.channelCount;\n      meta.sampleRate = audioSampleRate;\n      meta.sampleRateIndex = audioSampleRateIndex;\n      meta.refSampleDuration = refSampleDuration;\n      meta.duration = this._context.mediaInfo.duration * meta.timescale;\n      meta.config = aacHeader.config;\n      meta.objectType = aacHeader.objectType;\n\n      const audioMedia = this._context.mediaInfo.audio;\n\n      // fill audio media info\n      audioMedia.codec = aacHeader.codec;\n      audioMedia.channelCount = aacHeader.channelCount;\n      audioMedia.sampleRate = audioSampleRate;\n      audioMedia.sampleRateIndex = aacHeader.audioSampleRateIndex;\n\n      if (this._hasScript && !this._hasAudioSequence) {\n        this.emit(DEMUX_EVENTS.METADATA_PARSED, 'audio');\n      } else if (this._hasScript && this._hasAudioSequence) {\n        this.emit(DEMUX_EVENTS.METADATA_PARSED, 'audio');\n        this.emit(DEMUX_EVENTS.AUDIO_METADATA_CHANGE);\n        // this.emit(DEMUX_EVENTS.METADATA_PARSED, 'audio')\n      }\n      this._hasAudioSequence = true;\n\n      this._metaChange = true;\n    } else {\n      if (this._metaChange) {\n        chunk.options = {\n          meta: track.meta\n        };\n        this._metaChange = false;\n      }\n\n      chunk.data = chunk.data.slice(1, chunk.data.length);\n      track.samples.push(chunk);\n    }\n    if (!validate) {\n      this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error('TAG length error at ' + chunk.datasize), false);\n      // this.logger.warn(this.TAG, error.message)\n    }\n  }\n\n  /**\n   * parse hevc/avc video data\n   * @param chunk\n   * @private\n   */\n  _parseHevcData(chunk) {\n    // header\n    let info = this.loaderBuffer.shift(1)[0];\n    chunk.frameType = (info & 0xf0) >>> 4;\n    chunk.isKeyframe = chunk.frameType === 1;\n    // let tempCodecID = this.tracks.videoTrack.codecID\n    let codecID = info & 0x0f;\n    this.tracks.videoTrack.codecID = codecID;\n\n    // hevc和avc的header解析方式一样\n    chunk.avcPacketType = this.loaderBuffer.shift(1)[0];\n    chunk.cts = this.loaderBuffer.toInt(0, 3);\n    this.loaderBuffer.shift(3);\n\n    // 12 for hevc, 7 for avc\n    if (codecID === 12) {\n      const data = this.loaderBuffer.shift(chunk.datasize - 5);\n      chunk.data = data;\n\n      if (Number.parseInt(chunk.avcPacketType) !== 0) {\n        if (!this._datasizeValidator(chunk.datasize)) {\n          this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error(`invalid video tag datasize: ${chunk.datasize}`), false);\n        }\n        let nalu = {};\n        let r = 0;\n        nalu.cts = chunk.cts;\n        nalu.dts = chunk.dts;\n        while (chunk.data.length > r) {\n          let sizes = chunk.data.slice(Number.parseInt(r), 4 + r);\n          nalu.size = sizes[3];\n          nalu.size += sizes[2] * 256;\n          nalu.size += sizes[1] * 256 * 256;\n          nalu.size += sizes[0] * 256 * 256 * 256;\n          r += 4;\n          nalu.data = chunk.data.slice(Number.parseInt(r), nalu.size + r);\n          r += nalu.size;\n          this.tracks.videoTrack.samples.push(nalu);\n          this.emit(DEMUX_EVENTS.METADATA_PARSED, 'video');\n        }\n      } else if (Number.parseInt(chunk.avcPacketType) === 0) {\n        if (!this._datasizeValidator(chunk.datasize)) {\n          this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error(`invalid video tag datasize: ${chunk.datasize}`), false);\n        } else {\n          this.emit(DEMUX_EVENTS.METADATA_PARSED, 'video');\n        }\n      }\n    } else if (codecID === 7) {\n      let data = this.loaderBuffer.shift(chunk.datasize - 5);\n      if (data[4] === 0 && data[5] === 0 && data[6] === 0 && data[7] === 1) {\n        let avcclength = 0;\n        for (let i = 0; i < 4; i++) {\n          avcclength = avcclength * 256 + data[i];\n        }\n        avcclength -= 4;\n        data = data.slice(4, data.length);\n        data[3] = avcclength % 256;\n        avcclength = (avcclength - data[3]) / 256;\n        data[2] = avcclength % 256;\n        avcclength = (avcclength - data[2]) / 256;\n        data[1] = avcclength % 256;\n        data[0] = (avcclength - data[1]) / 256;\n      }\n\n      chunk.data = data;\n      // If it is AVC sequece Header.\n      if (chunk.avcPacketType === 0) {\n        this._avcSequenceHeaderParser(chunk.data);\n        let validate = this._datasizeValidator(chunk.datasize);\n        if (validate) {\n          if (this._hasScript && !this._hasVideoSequence) {\n            this.emit(DEMUX_EVENTS.METADATA_PARSED, 'video');\n          } else if (this._hasScript && this._hasVideoSequence) {\n            this.emit(DEMUX_EVENTS.METADATA_PARSED, 'audio');\n            this.emit(DEMUX_EVENTS.VIDEO_METADATA_CHANGE);\n            // this.emit(DEMUX_EVENTS.METADATA_PARSED, 'video')\n          }\n          this._hasVideoSequence = true;\n        }\n        this._metaChange = true;\n      } else {\n        if (!this._datasizeValidator(chunk.datasize)) {\n          this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error(`invalid video tag datasize: ${chunk.datasize}`), false);\n          return;\n        }\n        if (this._metaChange) {\n          chunk.options = {\n            meta: Object.assign({}, this.tracks.videoTrack.meta)\n          };\n          this._metaChange = false;\n        }\n        this.tracks.videoTrack.samples.push(chunk);\n        // this.emit(DEMUX_EVENTS.DEMUX_COMPLETE)\n      }\n    } else {\n      this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error(`video codeid is ${codecID}`), false);\n      chunk.data = this.loaderBuffer.shift(chunk.datasize - 1);\n      if (!this._datasizeValidator(chunk.datasize)) {\n        this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error(`invalid video tag datasize: ${chunk.datasize}`), false);\n      }\n      this.tracks.videoTrack.samples.push(chunk);\n      this.emit(DEMUX_EVENTS.DEMUX_COMPLETE);\n    }\n    delete chunk.tagType;\n  }\n\n  /**\n   * parse avc metadata\n   * @param data\n   * @private\n   */\n  _avcSequenceHeaderParser(data) {\n    let track = this.tracks.videoTrack;\n\n    if (!track) {\n      return;\n    }\n\n    let offset = 0;\n\n    if (!track.meta) {\n      track.meta = new _xgplayerUtils.VideoTrackMeta();\n    }\n    let meta = track.meta;\n\n    meta.configurationVersion = data[0];\n    meta.avcProfileIndication = data[1];\n    meta.profileCompatibility = data[2];\n    meta.avcLevelIndication = data[3] / 10;\n    meta.nalUnitLength = (data[4] & 0x03) + 1;\n\n    let numOfSps = data[5] & 0x1f;\n    offset = 6;\n    let config = {};\n\n    // parse SPS\n    for (let i = 0; i < numOfSps; i++) {\n      let size = data[offset] * 255 + data[offset + 1];\n      offset += 2;\n\n      let sps = new Uint8Array(size);\n      for (let j = 0; j < size; j++) {\n        sps[j] = data[offset + j];\n      }\n\n      // codec string\n      let codecString = 'avc1.';\n      for (let j = 1; j < 4; j++) {\n        let h = sps[j].toString(16);\n        if (h.length < 2) {\n          h = '0' + h;\n        }\n        codecString += h;\n      }\n\n      meta.codec = codecString;\n\n      offset += size;\n      this.tracks.videoTrack.meta.sps = sps;\n      config = _xgplayerCodec.SpsParser.parseSPS(sps);\n    }\n\n    let numOfPps = data[offset];\n\n    offset++;\n\n    for (let i = 0; i < numOfPps; i++) {\n      let size = data[offset] * 255 + data[offset + 1];\n      offset += 2;\n      let pps = new Uint8Array(size);\n      for (let j = 0; j < size; j++) {\n        pps[j] = data[offset + j];\n      }\n      offset += size;\n      this.tracks.videoTrack.meta.pps = pps;\n    }\n\n    Object.assign(meta, _xgplayerCodec.SpsParser.toVideoMeta(config));\n\n    // fill video media info\n    const videoMedia = this._context.mediaInfo.video;\n\n    videoMedia.codec = meta.codec;\n    videoMedia.profile = meta.profile;\n    videoMedia.level = meta.level;\n    videoMedia.chromaFormat = meta.chromaFormat;\n    videoMedia.frameRate = meta.frameRate;\n    videoMedia.parRatio = meta.parRatio;\n    videoMedia.width = videoMedia.width === meta.presentWidth ? videoMedia.width : meta.presentWidth;\n    videoMedia.height = videoMedia.height === meta.presentHeight ? videoMedia.width : meta.presentHeight;\n\n    meta.duration = this._context.mediaInfo.duration * meta.timescale;\n    meta.avcc = new Uint8Array(data.length);\n    meta.avcc.set(data);\n    track.meta = meta;\n  }\n\n  /**\n   * choose audio sample rate\n   * @param samplingFrequencyIndex\n   * @returns {number}\n   * @private\n   */\n  _switchAudioSampleRate(samplingFrequencyIndex) {\n    let samplingFrequencyList = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n    return samplingFrequencyList[samplingFrequencyIndex];\n  }\n\n  /**\n   * choose audio sampling frequence\n   * @param info\n   * @returns {number}\n   * @private\n   */\n  _switchAudioSamplingFrequency(info) {\n    let samplingFrequencyIndex = (info & 12) >>> 2;\n    let samplingFrequencyList = [5500, 11025, 22050, 44100, 48000];\n    return samplingFrequencyList[samplingFrequencyIndex];\n  }\n\n  /**\n   * choose audio channel count\n   * @param info\n   * @returns {number}\n   * @private\n   */\n  _switchAudioChannel(info) {\n    let sampleTrackNumIndex = info & 1;\n    let sampleTrackNumList = [1, 2];\n    return sampleTrackNumList[sampleTrackNumIndex];\n  }\n\n  /**\n   * check datasize is valid use 4 Byte after current tag\n   * @param datasize\n   * @returns {boolean}\n   * @private\n   */\n  _datasizeValidator(datasize) {\n    let datasizeConfirm = this.loaderBuffer.toInt(0, 4);\n    this.loaderBuffer.shift(4);\n    return datasizeConfirm === datasize + 11;\n  }\n\n  get loaderBuffer() {\n    const buffer = this._context.getInstance('LOADER_BUFFER');\n    if (buffer) {\n      return buffer;\n    } else {\n      this.emit(DEMUX_EVENTS.DEMUX_ERROR, new Error('找不到 loaderBuffer 实例'));\n    }\n  }\n\n  get tracks() {\n    return this._context.getInstance('TRACKS');\n  }\n\n  get logger() {\n    return this._context.getInstance('LOGGER');\n  }\n}\n\nexports.default = FlvDemuxer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-demux/src/flv/index.js?")},"../xgplayer-demux/src/hls/demuxer/m3u8parser.js":
/*!*******************************************************!*\
      !*** ../xgplayer-demux/src/hls/demuxer/m3u8parser.js ***!
      \*******************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Reference: https://tools.ietf.org/html/rfc8216#section-4.3\n */\nclass M3U8Parser {\n  static parse(text, baseurl = '') {\n    let ret = {\n      duration: 0\n    };\n    if (!text || !text.split) {\n      return;\n    }\n    let refs = text.split(/\\r|\\n/);\n    refs = refs.filter(ref => {\n      return ref;\n    });\n    let ref = refs.shift();\n    if (!ref.match('#EXTM3U')) {\n      throw new Error(`Invalid m3u8 file: not \"#EXTM3U\"`);\n      return null;\n    }\n    ref = refs.shift();\n    while (ref) {\n      let refm = ref.match(/#(.[A-Z|-]*):(.*)/);\n      let refd = ref.match(/#(.[A-Z|-]*)/);\n      if (refd && refm && refm.length > 2) {\n        switch (refm[1]) {\n          case 'EXT-X-VERSION':\n            ret.version = parseInt(refm[2]);\n            break;\n          case 'EXT-X-MEDIA-SEQUENCE':\n            ret.sequence = parseInt(refm[2]);\n            break;\n          case 'EXT-X-TARGETDURATION':\n            ret.targetduration = parseFloat(refm[2]);\n            break;\n          case 'EXTINF':\n            M3U8Parser.parseFrag(refm, refs, ret, baseurl);\n            break;\n          case 'EXT-X-KEY':\n            M3U8Parser.parseDecrypt(refm[2], ret);\n            break;\n          default:\n            break;\n        }\n      }if (refd && refd.length > 1) {\n        switch (refd[1]) {\n          case 'EXT-X-DISCONTINUITY':\n            ref = refs.shift();\n            let refm = ref.match(/#(.[A-Z|-]*):(.*)/);\n            if (refm.length > 2 && refm[1] === 'EXTINF') {\n              M3U8Parser.parseFrag(refm, refs, ret, baseurl, true);\n            }\n            break;\n          default:\n            break;\n        }\n      }\n      ref = refs.shift();\n    }\n    return ret;\n  }\n\n  static parseFrag(refm, refs, ret, baseurl, discontinue) {\n    if (!ret.frags) {\n      ret.frags = [];\n    }\n\n    let freg = {\n      start: ret.duration,\n      duration: parseFloat(refm[2]) * 1000\n    };\n\n    ret.duration += freg.duration;\n    let nextline = refs.shift();\n    if (nextline.match(/#(.*):(.*)/)) {\n      nextline = refs.shift();\n    }\n    if (nextline.length > 0 && nextline.charAt(0) === '/' && baseurl.match(/.*\\/\\/.*\\.\\w+/g)) {\n      baseurl = baseurl.match(/.*\\/\\/.*\\.\\w+/g)[0];\n    }\n    if (nextline.match(/.*:\\/\\/.*/)) {\n      freg.url = nextline;\n    } else {\n      freg.url = baseurl + nextline;\n    }\n    freg.discontinue = discontinue;\n    ret.frags.push(freg);\n  }\n\n  static parseURL(url) {\n    let baseurl = '';\n    let urls = url.match(/(.*\\/).*\\.m3u8/);\n    if (urls && urls.length > 0) {\n      for (let i = 0; i < urls.length; i++) {\n        if (urls[i].match(/.*\\/$/g) && urls[i].length > baseurl.length) {\n          baseurl = urls[i];\n        }\n      }\n    }\n    return baseurl;\n  }\n\n  static parseDecrypt(refm, ret) {\n    ret.encrypt = {};\n    let refs = refm.split(',');\n    for (let i in refs) {\n      let cmd = refs[i];\n      if (cmd.match(/METHOD=(.*)/)) {\n        ret.encrypt.method = cmd.match(/METHOD=(.*)/)[1];\n      }\n      if (cmd.match(/URI=\"(.*)\"/)) {\n        ret.encrypt.uri = cmd.match(/URI=\"(.*)\"/)[1];\n      }\n\n      if (cmd.match(/IV=0x(.*)/)) {\n        let iv = cmd.match(/IV=0x(.*)/)[1];\n        let length = Math.ceil(iv.length / 2);\n        ret.encrypt.ivb = new Uint8Array(length);\n        for (let i = length - 1; i >= 0; i--) {\n          let im = parseInt(iv.substr(i * 2, 2), 16);\n          ret.encrypt.ivb[i] = im;\n        }\n        ret.encrypt.iv = iv;\n      }\n    };\n  }\n}\n\nexports.default = M3U8Parser;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-demux/src/hls/demuxer/m3u8parser.js?")},"../xgplayer-demux/src/hls/demuxer/ts.js":
/*!***********************************************!*\
      !*** ../xgplayer-demux/src/hls/demuxer/ts.js ***!
      \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _xgplayerCodec = __webpack_require__(/*! xgplayer-codec */ \"../xgplayer-codec/index.js\");\n\nvar _xgplayerBuffer = __webpack_require__(/*! xgplayer-buffer */ \"../xgplayer-buffer/index.js\");\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nconst DEMUX_EVENTS = _xgplayerUtils.EVENTS.DEMUX_EVENTS;\nconst StreamType = {\n  0x01: ['video', 'MPEG-1'],\n  0x02: ['video', 'MPEG-2'],\n  0x1b: ['video', 'AVC.H264'],\n  0xea: ['video', 'VC-1'],\n  0x03: ['audio', 'MPEG-1'],\n  0x04: ['audio', 'MPEG-2'],\n  0x0f: ['audio', 'MPEG-2.AAC'],\n  0x11: ['audio', 'MPEG-4.AAC'],\n  0x80: ['audio', 'LPCM'],\n  0x81: ['audio', 'AC3'],\n  0x06: ['audio', 'AC3'],\n  0x82: ['audio', 'DTS'],\n  0x83: ['audio', 'Dolby TrueHD'],\n  0x84: ['audio', 'AC3-Plus'],\n  0x85: ['audio', 'DTS-HD'],\n  0x86: ['audio', 'DTS-MA'],\n  0xa1: ['audio', 'AC3-Plus-SEC'],\n  0xa2: ['audio', 'DTS-HD-SEC']\n};\n\nclass TsDemuxer {\n  constructor(configs) {\n    this.configs = Object.assign({}, configs);\n    this.demuxing = false;\n    this.pat = [];\n    this.pmt = [];\n    this._hasVideoMeta = false;\n    this._hasAudioMeta = false;\n  }\n\n  init() {\n    this.on(DEMUX_EVENTS.DEMUX_START, this.demux.bind(this));\n  }\n\n  demux(frag) {\n    if (this.demuxing) {\n      return;\n    }\n\n    let buffer = this.inputBuffer;\n    let frags = { pat: [], pmt: [] };\n    let peses = {};\n\n    // Read TS segment\n    while (buffer.length >= 188) {\n      if (buffer.length >= 1 && buffer.array[0][buffer.offset] !== 71) {\n        this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error(`Untrust sync code: ${buffer.array[0][buffer.offset]}, try to recover;`), false);\n      }\n      while (buffer.length >= 1 && buffer.array[0][buffer.offset] !== 71) {\n        buffer.shift(1);\n      }\n      let buf = buffer.shift(188);\n      // console.log(buf);\n      let tsStream = new _xgplayerUtils.Stream(buf.buffer);\n      let ts = {};\n      TsDemuxer.read(tsStream, ts, frags);\n      if (ts.pes) {\n        if (!peses[ts.header.pid]) {\n          peses[ts.header.pid] = [];\n        }\n        peses[ts.header.pid].push(ts.pes);\n        ts.pes.ES.buffer = [ts.pes.ES.buffer];\n      } else if (peses[ts.header.pid]) {\n        peses[ts.header.pid][peses[ts.header.pid].length - 1].ES.buffer.push(ts.payload.stream);\n      }\n    }\n\n    let AudioOptions = frag;\n    let VideoOptions = frag;\n\n    // Get Frames data\n    for (let i = 0; i < Object.keys(peses).length; i++) {\n      let epeses = peses[Object.keys(peses)[i]];\n      for (let j = 0; j < epeses.length; j++) {\n        epeses[j].id = Object.keys(peses)[i];\n        epeses[j].ES.buffer = TsDemuxer.Merge(epeses[j].ES.buffer);\n        if (epeses[j].type === 'audio') {\n          this.pushAudioSample(epeses[j], AudioOptions);\n          AudioOptions = {};\n        } else if (epeses[j].type === 'video') {\n          this.pushVideoSample(epeses[j], VideoOptions);\n          VideoOptions = {};\n        }\n      }\n    }\n\n    if (this._hasAudioMeta) {\n      this.emit(DEMUX_EVENTS.DEMUX_COMPLETE, 'audio');\n    }\n    if (this._hasVideoMeta) {\n      this.emit(DEMUX_EVENTS.DEMUX_COMPLETE, 'video');\n    }\n  }\n\n  pushAudioSample(pes, options) {\n    let track;\n    if (!this._tracks.audioTrack) {\n      this._tracks.audioTrack = new _xgplayerBuffer.AudioTrack();\n      track = this._tracks.audioTrack;\n    } else {\n      track = this._tracks.audioTrack;\n    }\n    let meta = new _xgplayerUtils.AudioTrackMeta({\n      audioSampleRate: pes.ES.frequence,\n      sampleRate: pes.ES.frequence,\n      channelCount: pes.ES.channel,\n      codec: 'mp4a.40.' + pes.ES.audioObjectType,\n      config: pes.ES.audioConfig,\n      id: 2,\n      sampleRateIndex: pes.ES.frequencyIndex\n    });\n    meta.refSampleDuration = Math.floor(1024 / meta.audioSampleRate * meta.timescale);\n\n    let metaEqual = TsDemuxer.compaireMeta(track.meta, meta, true);\n\n    if (!this._hasAudioMeta || !metaEqual) {\n      track.meta = meta;\n      this._hasAudioMeta = true;\n      this.emit(DEMUX_EVENTS.METADATA_PARSED, 'audio');\n    }\n\n    let data = new Uint8Array(pes.ES.buffer.buffer.slice(pes.ES.buffer.position, pes.ES.buffer.length));\n    let dts = parseInt(pes.pts / 90);\n    let pts = parseInt(pes.pts / 90);\n    let sample = new _xgplayerUtils.AudioTrackSample({ dts, pts, data, options });\n    track.samples.push(sample);\n  }\n\n  pushVideoSample(pes, options) {\n    let nals = _xgplayerCodec.Nalunit.getNalunits(pes.ES.buffer);\n    let track;\n    let meta = new _xgplayerUtils.VideoTrackMeta();\n    if (!this._tracks.videoTrack) {\n      this._tracks.videoTrack = new _xgplayerBuffer.VideoTrack();\n      track = this._tracks.videoTrack;\n    } else {\n      track = this._tracks.videoTrack;\n    }\n    let sampleLength = 0;\n    let sps = false;\n    let pps = false;\n    for (let i = 0; i < nals.length; i++) {\n      let nal = nals[i];\n      if (nal.sps) {\n        sps = nal;\n        track.sps = nal.body;\n        meta.chromaFormat = sps.sps.chroma_format;\n        meta.codec = 'avc1.';\n        for (var j = 1; j < 4; j++) {\n          var h = sps.body[j].toString(16);\n          if (h.length < 2) {\n            h = '0' + h;\n          }\n          meta.codec += h;\n        }\n        meta.codecHeight = sps.sps.codec_size.height;\n        meta.codecWidth = sps.sps.codec_size.width;\n        meta.frameRate = sps.sps.frame_rate;\n        meta.id = 1;\n        meta.level = sps.sps.level_string;\n        meta.presentHeight = sps.sps.present_size.height;\n        meta.presentWidth = sps.sps.present_size.width;\n        meta.profile = sps.sps.profile_string;\n        meta.refSampleDuration = Math.floor(meta.timescale * (sps.sps.frame_rate.fps_den / sps.sps.frame_rate.fps_num));\n        meta.sarRatio = sps.sps.sar_ratio ? sps.sps.sar_ratio : sps.sps.par_ratio;\n      } else if (nal.pps) {\n        track.pps = nal.body;\n        pps = nal;\n      } else {\n        sampleLength += 4 + nal.body.byteLength;\n      }\n    }\n\n    if (sps && pps) {\n      meta.avcc = _xgplayerCodec.Nalunit.getAvcc(sps.body, pps.body);\n      let metaEqual = TsDemuxer.compaireMeta(track.meta, meta, true);\n      if (!this._hasVideoMeta || !metaEqual) {\n        if (options) {\n          options.meta = Object.assign({}, meta);\n        } else {\n          options = {\n            meta: Object.assign({}, meta)\n          };\n        }\n        track.meta = meta;\n        this._hasVideoMeta = true;\n        this.emit(DEMUX_EVENTS.METADATA_PARSED, 'video');\n      }\n    }\n\n    let data = new Uint8Array(sampleLength);\n    let offset = 0;\n    let isKeyframe = false;\n    for (let i = 0; i < nals.length; i++) {\n      let nal = nals[i];\n      let length = nal.body.byteLength;\n      if (nal.idr) {\n        isKeyframe = true;\n      }\n      if (!nal.pps && !nal.sps) {\n        data.set(new Uint8Array([length >>> 24 & 0xff, length >>> 16 & 0xff, length >>> 8 & 0xff, length & 0xff]), offset);\n        offset += 4;\n        data.set(nal.body, offset);\n        offset += length;\n      }\n    }\n    let sample = new _xgplayerUtils.VideoTrackSample({\n      dts: parseInt(pes.dts / 90),\n      pts: parseInt(pes.pts / 90),\n      cts: (pes.pts - pes.dts) / 90,\n      originDts: pes.dts,\n      isKeyframe,\n      data,\n      options\n    });\n    track.samples.push(sample);\n  }\n\n  destory() {\n    this.off(DEMUX_EVENTS.DEMUX_START, this.demux);\n    this.configs = {};\n    this.demuxing = false;\n    this.pat = [];\n    this.pmt = [];\n    this._hasVideoMeta = false;\n    this._hasAudioMeta = false;\n  }\n\n  static compaireArray(a, b, type) {\n    let al = 0;\n    let bl = 0;\n    if (type === 'Uint8Array') {\n      al = a.byteLength;\n      bl = b.byteLength;\n    } else if (type === 'Array') {\n      al = a.length;\n      bl = b.length;\n    }\n    if (al !== bl) {\n      return false;\n    }\n\n    for (let i = 0; i < al; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  static compaireMeta(a, b, ignoreDuration) {\n    if (!a || !b) {\n      return false;\n    }\n\n    for (let i = 0, k = Object.keys(a).length; i < k; i++) {\n      let itema = a[Object.keys(a)[i]];\n      let itemb = b[Object.keys(a)[i]];\n      if (typeof itema !== 'object') {\n        if (ignoreDuration && Object.keys(a)[i] !== 'duration' && Object.keys(a)[i] !== 'refSampleDuration' && Object.keys(a)[i] !== 'refSampleDurationFixed' && itema !== itemb) {\n          return false;\n        }\n      } else if (itema.byteLength !== undefined) {\n        if (itemb.byteLength === undefined) {\n          return false;\n        }\n        if (!TsDemuxer.compaireArray(itema, itemb, 'Uint8Array')) {\n          return false;\n        }\n      } else if (itema.length !== undefined) {\n        if (itemb.length === undefined) {\n          return false;\n        }\n        if (!TsDemuxer.compaireArray(itema, itemb, 'Array')) {\n          return false;\n        }\n      } else {\n        if (!TsDemuxer.compaireMeta(itema, itemb)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  static Merge(buffers) {\n    let data;\n    let length = 0;\n    let offset = 0;\n    for (let i = 0; i < buffers.length; i++) {\n      length += buffers[i].length - buffers[i].position;\n    }\n\n    data = new Uint8Array(length);\n    for (let i = 0; i < buffers.length; i++) {\n      let buffer = buffers[i];\n      data.set(new Uint8Array(buffer.buffer, buffer.position), offset);\n      offset += buffer.length - buffer.position;\n    }\n    return new _xgplayerUtils.Stream(data.buffer);\n  }\n\n  static read(stream, ts, frags) {\n    TsDemuxer.readHeader(stream, ts);\n    TsDemuxer.readPayload(stream, ts, frags);\n    if (ts.header.packet === 'MEDIA' && ts.header.payload === 1 && !ts.unknownPIDs) {\n      ts.pes = TsDemuxer.PES(ts);\n    }\n  }\n\n  static readPayload(stream, ts, frags) {\n    let header = ts.header;\n    let pid = header.pid;\n    switch (pid) {\n      case 0:\n        TsDemuxer.PAT(stream, ts, frags);\n        break;\n      case 1:\n        TsDemuxer.CAT(stream, ts, frags);\n        break;\n      case 2:\n        TsDemuxer.TSDT(stream, ts, frags);\n        break;\n      case 0x1fff:\n        break;\n      default:\n        // TODO: some的写法不太好，得改\n        if (frags.pat.some(item => {\n          return item.pid === pid;\n        })) {\n          TsDemuxer.PMT(stream, ts, frags);\n        } else {\n          let sts = frags.pmt ? frags.pmt.filter(item => item.pid === pid) : [];\n          if (sts.length > 0) {\n            TsDemuxer.Media(stream, ts, StreamType[sts[0].streamType][0]);\n          } else {\n            ts.unknownPIDs = true;\n          };\n        }\n    }\n  }\n\n  static readHeader(stream, ts) {\n    let header = {};\n    header.sync = stream.readUint8();\n    let next = stream.readUint16();\n    header.error = next >>> 15;\n    header.payload = next >>> 14 & 1;\n    header.priority = next >>> 13 & 1;\n    header.pid = next & 0x1fff;\n\n    next = stream.readUint8();\n\n    header.scrambling = next >> 6 & 0x3; // 是否加密，00表示不加密\n\n    /**\n     * 00 ISO/IEC未来使用保留\n     * 01 没有调整字段，仅含有184B有效净荷\n     * 02 没有有效净荷，仅含有183B调整字段\n     * 03 0~182B调整字段后为有效净荷\n     */\n    header.adaptation = next >> 4 & 0x3;\n    header.continuity = next & 15;\n    header.packet = header.pid === 0 ? 'PAT' : 'MEDIA';\n    ts.header = header;\n  }\n\n  static PAT(stream, ts, frags) {\n    let ret = {};\n    let next = stream.readUint8();\n    stream.skip(next);\n    next = stream.readUint8();\n    ret.tabelID = next;\n    next = stream.readUint16();\n    ret.error = next >>> 7;\n    ret.zero = next >>> 6 & 1;\n    ret.sectionLength = next & 0xfff;\n    ret.streamID = stream.readUint16();\n    ret.current = stream.readUint8() & 1;\n    ret.sectionNumber = stream.readUint8();\n    ret.lastSectionNumber = stream.readUint8();\n    let N = (ret.sectionLength - 9) / 4;\n    let list = [];\n    for (let i = 0; i < N; i++) {\n      let programNumber = stream.readUint16();\n      let pid = stream.readUint16() & 0x1fff;\n      list.push({\n        program: programNumber,\n        pid,\n        type: programNumber === 0 ? 'network' : 'mapPID'\n      });\n    }\n    if (list.length > 0) {\n      frags.pat = frags.pat.concat(list);\n    }\n    ret.list = list;\n    ret.program = stream.readUint16();\n    ret.pid = stream.readUint16() & 0x1fff;\n    ts.payload = ret;\n    // TODO CRC\n  }\n\n  static PMT(stream, ts, frags) {\n    let ret = {};\n    let header = ts.header;\n    header.packet = 'PMT';\n    let next = stream.readUint8();\n    stream.skip(next);\n    next = stream.readUint8();\n    ret.tableID = next;\n    next = stream.readUint16();\n    ret.sectionLength = next & 0xfff;\n    ret.program = stream.readUint16();\n    ret.current = stream.readUint8() & 1;\n    ret.order = stream.readUint8();\n    ret.lastOrder = stream.readUint8();\n    ret.PCR_PID = stream.readUint16() & 0x1fff;\n    ret.programLength = stream.readUint16() & 0xfff;\n    let N = (ret.sectionLength - 13) / 5;\n    let list = [];\n    for (let i = 0; i < N; i++) {\n      list.push({\n        streamType: stream.readUint8(),\n        pid: stream.readUint16() & 0x1fff, // 0x07e5 视频，0x07e6\n        es: stream.readUint16() & 0xfff\n      });\n    }\n    ret.list = list;\n    if (!this.pmt) {\n      this.pmt = [];\n    }\n    frags.pmt = this.pmt.concat(list.map(item => {\n      return {\n        pid: item.pid,\n        es: item.es,\n        streamType: item.streamType,\n        program: ret.program\n      };\n    }));\n    ts.payload = ret;\n  }\n\n  static Media(stream, ts, type) {\n    let header = ts.header;\n    let payload = {};\n    header.type = type;\n    if (header.adaptation === 0x03) {\n      payload.adaptationLength = stream.readUint8();\n      if (payload.adaptationLength > 0) {\n        let next = stream.readUint8();\n        payload.discontinue = next >>> 7;\n        payload.access = next >>> 6 & 0x01;\n        payload.priority = next >>> 5 & 0x01;\n        payload.PCR = next >>> 4 & 0x01;\n        payload.OPCR = next >>> 3 & 0x01;\n        payload.splicePoint = next >>> 2 & 0x01;\n        payload.transportPrivate = next >>> 1 & 0x01;\n        payload.adaptationField = next & 0x01;\n        let _start = stream.position;\n        if (payload.PCR === 1) {\n          payload.programClockBase = stream.readUint32() << 1;\n          next = stream.readUint16();\n          payload.programClockBase |= next >>> 15;\n          payload.programClockExtension = next & 0x1ff;\n        }\n        if (payload.OPCR === 1) {\n          payload.originProgramClockBase = stream.readUint32() << 1;\n          next = stream.readUint16();\n          payload.originProgramClockBase += next >>> 15;\n          payload.originProgramClockExtension = next & 0x1ff;\n        }\n        if (payload.splicePoint === 1) {\n          payload.spliceCountdown = stream.readUint8();\n        }\n        if (payload.transportPrivate === 1) {\n          let length = stream.readUint8();\n          let transportPrivateData = [];\n          for (let i = 0; i < length; i++) {\n            transportPrivateData.push(stream.readUint8());\n          }\n        }\n        if (payload.adaptationField === 1) {\n          let length = stream.readUint8();\n          let next = stream.readUint8();\n          let start = stream.position;\n          let ltw = next >>> 7;\n          let piecewise = next >>> 6 & 0x1;\n          let seamless = next >>> 5 & 0x1;\n          if (ltw === 1) {\n            next = stream.readUint16();\n            payload.ltwValid = next >>> 15;\n            payload.ltwOffset = next & 0xefff;\n          }\n          if (piecewise === 1) {\n            next = stream.readUint24();\n            payload.piecewiseRate = next & 0x3fffff;\n          }\n          if (seamless === 1) {\n            next = stream.readInt8();\n            payload.spliceType = next >>> 4;\n            payload.dtsNextAU1 = next >>> 1 & 0x7;\n            payload.marker1 = next & 0x1;\n            next = stream.readUint16();\n            payload.dtsNextAU2 = next >>> 1;\n            payload.marker2 = next & 0x1;\n            next = stream.readUint16();\n            payload.dtsNextAU3 = next;\n          }\n          stream.skip(length - 1 - (stream.position - start));\n        }\n        let lastStuffing = payload.adaptationLength - 1 - (stream.position - _start);\n        stream.skip(lastStuffing);\n      }\n    }\n    payload.stream = new _xgplayerUtils.Stream(stream.buffer.slice(stream.position));\n    ts.payload = payload;\n  }\n\n  static PES(ts) {\n    let ret = {};\n    let buffer = ts.payload.stream;\n\n    let next = buffer.readUint24();\n    if (next !== 1) {\n      ret.ES = {};\n      ret.ES.buffer = buffer;\n    } else {\n      let streamID = buffer.readUint8();\n      if (streamID >= 0xe0 && streamID <= 0xef) {\n        ret.type = 'video';\n      }\n      if (streamID >= 0xc0 && streamID <= 0xdf) {\n        ret.type = 'audio';\n      }\n      let packetLength = buffer.readUint16();\n      ret.packetLength = packetLength;\n      if (ret.type === 'video' || ret.type === 'audio') {\n        let next = buffer.readUint8();\n        let first = next >>> 6;\n        if (first !== 0x02) {\n          throw new Error('error when parse pes header');\n        }\n        next = buffer.readUint8();\n        ret.ptsDTSFlag = next >>> 6;\n        ret.escrFlag = next >>> 5 & 0x01;\n        ret.esRateFlag = next >>> 4 & 0x01;\n        ret.dsmFlag = next >>> 3 & 0x01;\n        ret.additionalFlag = next >>> 2 & 0x01;\n        ret.crcFlag = next >>> 1 & 0x01;\n        ret.extensionFlag = next & 0x01;\n        ret.pesHeaderLength = buffer.readUint8();\n        let N1 = ret.pesHeaderLength;\n\n        if (ret.ptsDTSFlag === 2) {\n          let pts = [];\n          next = buffer.readUint8();\n          pts.push(next >>> 1 & 0x07);\n          next = buffer.readUint16();\n          pts.push(next >>> 1);\n          next = buffer.readUint16();\n          pts.push(next >>> 1);\n          ret.pts = pts[0] << 30 | pts[1] << 15 | pts[2];\n          N1 -= 5;\n          // 视频如果没有dts用pts\n          if (ret.type === 'video') {\n            ret.dts = ret.pts;\n          }\n        }\n        if (ret.ptsDTSFlag === 3) {\n          let pts = [];\n          next = buffer.readUint8();\n          pts.push(next >>> 1 & 0x07);\n          next = buffer.readUint16();\n          pts.push(next >>> 1);\n          next = buffer.readUint16();\n          pts.push(next >>> 1);\n          ret.pts = pts[0] << 30 | pts[1] << 15 | pts[2];\n          let dts = [];\n          next = buffer.readUint8();\n          dts.push(next >>> 1 & 0x07);\n          next = buffer.readUint16();\n          dts.push(next >>> 1);\n          next = buffer.readUint16();\n          dts.push(next >>> 1);\n          ret.dts = dts[0] << 30 | dts[1] << 15 | dts[2];\n          N1 -= 10;\n        }\n        if (ret.escrFlag === 1) {\n          let escr = [];\n          let ex = [];\n          next = buffer.readUint8();\n          escr.push(next >>> 3 & 0x07);\n          escr.push(next & 0x03);\n          next = buffer.readUint16();\n          escr.push(next >>> 13);\n          escr.push(next & 0x03);\n          next = buffer.readUint16();\n          escr.push(next >>> 13);\n          ex.push(next & 0x03);\n          next = buffer.readUint8();\n          ex.push(next >>> 1);\n          ret.escr = (escr[0] << 30 | escr[1] << 28 | escr[2] << 15 | escr[3] << 13 | escr[4]) * 300 + (ex[0] << 7 | ex[1]);\n          N1 -= 6;\n        }\n        if (ret.esRateFlag === 1) {\n          next = buffer.readUint24();\n          ret.esRate = next >>> 1 & 0x3fffff;\n          N1 -= 3;\n        }\n        if (ret.dsmFlag === 1) {\n          throw new Error('not support DSM_trick_mode');\n        }\n        if (ret.additionalFlag === 1) {\n          next = buffer.readUint8();\n          ret.additionalCopyInfo = next & 0x7f;\n          N1 -= 1;\n        }\n        if (ret.crcFlag === 1) {\n          ret.pesCRC = buffer.readUint16();\n          N1 -= 2;\n        }\n        if (ret.extensionFlag === 1) {\n          throw new Error('not support extension');\n        }\n        if (N1 > 0) {\n          buffer.skip(N1);\n        }\n        ret.ES = TsDemuxer.ES(buffer, ret.type);\n      } else {\n        throw new Error('format is not supported');\n      }\n    }\n    return ret;\n  }\n\n  static ES(buffer, type) {\n    let next;\n    let ret = {};\n    if (type === 'video') {\n      next = buffer.readUint32();\n      if (next !== 1) {\n        buffer.back(4);\n        next = buffer.readUint24();\n        if (next !== 1) {\n          throw new Error('h264 nal header parse failed');\n        }\n      }\n      buffer.skip(2); // 09 F0\n      // TODO readnalu\n      ret.buffer = buffer;\n    } else if (type === 'audio') {\n      next = buffer.readUint16();\n      // adts的同步字节，12位\n      if (next >>> 4 !== 0xfff) {\n        throw new Error('aac ES parse Error');\n      }\n      const fq = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n      ret.id = (next >>> 3 & 0x01) === 0 ? 'MPEG-4' : 'MPEG-2';\n      ret.layer = next >>> 1 & 0x03;\n      ret.absent = next & 0x01;\n      next = buffer.readUint16();\n      ret.audioObjectType = (next >>> 14 & 0x03) + 1;\n      ret.profile = ret.audioObjectType - 1;\n      ret.frequencyIndex = next >>> 10 & 0x0f;\n      ret.frequence = fq[ret.frequencyIndex];\n      ret.channel = next >>> 6 & 0x07;\n      ret.frameLength = (next & 0x03) << 11 | buffer.readUint16() >>> 5;\n      TsDemuxer.getAudioConfig(ret);\n      buffer.skip(1);\n      ret.buffer = buffer;\n    } else {\n      throw new Error(`ES ${type} is not supported`);\n    }\n\n    return ret;\n  }\n\n  static TSDT(stream, ts, frags) {\n    // TODO\n    ts.payload = {};\n  }\n\n  static CAT(stream, ts, frags) {\n    let ret = {};\n    ret.tableID = stream.readUint8();\n    let next = stream.readUint16();\n    ret.sectionIndicator = next >>> 7;\n    ret.sectionLength = next & 0x0fff;\n    stream.skip(2);\n    next = stream.readUint8();\n    ret.version = next >>> 3;\n    ret.currentNextIndicator = next & 0x01;\n    ret.sectionNumber = stream.readUint8();\n    ret.lastSectionNumber = stream.readUint8();\n    let N = (this.sectionLength - 9) / 4;\n    let list = [];\n    for (let i = 0; i < N; i++) {\n      list.push({});\n    }\n    ret.crc32 = stream.readUint32();\n    ts.payload = ret;\n  }\n\n  static getAudioConfig(ret) {\n    let userAgent = navigator.userAgent.toLowerCase();\n    let config;\n    let extensionSampleIndex;\n    if (/firefox/i.test(userAgent)) {\n      if (ret.frequencyIndex >= 6) {\n        ret.audioObjectType = 5;\n        config = new Array(4);\n        extensionSampleIndex = ret.frequencyIndex - 3;\n      } else {\n        ret.audioObjectType = 2;\n        config = new Array(2);\n        extensionSampleIndex = ret.frequencyIndex;\n      }\n    } else if (userAgent.indexOf('android') !== -1) {\n      ret.audioObjectType = 2;\n      config = new Array(2);\n      extensionSampleIndex = ret.frequencyIndex;\n    } else {\n      ret.audioObjectType = 5;\n      config = new Array(4);\n      if (ret.frequencyIndex >= 6) {\n        extensionSampleIndex = ret.frequencyIndex - 3;\n      } else {\n        if (ret.channel === 1) {\n          ret.audioObjectType = 2;\n          config = new Array(2);\n        }\n        extensionSampleIndex = ret.frequencyIndex;\n      }\n    }\n\n    config[0] = ret.audioObjectType << 3;\n    config[0] |= (ret.frequencyIndex & 0x0e) >> 1;\n    config[1] = (ret.frequencyIndex & 0x01) << 7;\n    config[1] |= ret.channel << 3;\n    if (ret.audioObjectType === 5) {\n      config[1] |= (extensionSampleIndex & 0x0e) >> 1;\n      config[2] = (extensionSampleIndex & 0x01) << 7;\n      config[2] |= 2 << 2;\n      config[3] = 0;\n    }\n    ret.audioConfig = config;\n  }\n\n  get inputBuffer() {\n    return this._context.getInstance(this.configs.inputbuffer);\n  }\n\n  get _tracks() {\n    return this._context.getInstance('TRACKS');\n  }\n}\n\nexports.default = TsDemuxer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-demux/src/hls/demuxer/ts.js?")},"../xgplayer-demux/src/hls/playlist.js":
/*!*********************************************!*\
      !*** ../xgplayer-demux/src/hls/playlist.js ***!
      \*********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass Playlist {\n  constructor(configs) {\n    this._baseURL = '';\n    this._list = {};\n    this._ts = {};\n    this.version = 0;\n    this.sequence = -1;\n    this.targetduration = 0;\n    this.duration = 0;\n    this.fragLength = 0;\n    this._lastget = undefined;\n    this._audoclear = configs.autoclear || false;\n  }\n\n  get list() {\n    return this._list;\n  }\n\n  set baseURL(baseURL) {\n    if (this.baseURL !== baseURL) {\n      this.clear();\n      this._baseURL = baseURL;\n    }\n  }\n\n  get baseURL() {\n    return this._baseURL;\n  }\n\n  push(ts, duration, discontinue) {\n    if (!this._ts[ts]) {\n      this._ts[ts] = { duration: duration,\n        downloaded: false,\n        downloading: false,\n        start: this.duration,\n        discontinue: discontinue ? true : false\n      };\n      this._list[this.duration] = ts;\n      this.duration += duration;\n      this.fragLength += 1;\n    }\n  }\n\n  deleteFrag(url) {\n    if (this._ts[url]) {\n      if (this._ts[url].start > this._lastget.time) {\n        this._lastget = {\n          duration: this._ts[url].duration,\n          time: this._ts[url].start,\n          downloaded: false,\n          downloading: false,\n          url: url\n        };\n      }\n      delete this._list[this._ts[url].start];\n      delete this._ts[url];\n      this.fragLength -= 1;\n    }\n  }\n\n  pushM3U8(data, deletepre) {\n    // 常规信息替换\n    if (!data) {\n      throw new Error(`No m3u8 data received.`);\n      return;\n    }\n    this.version = data.version;\n    this.targetduration = data.targetduration;\n    if (data.encrypt && !this.encrypt) {\n      this.encrypt = data.encrypt;\n    }\n    // 新分片信息\n    if (data.sequence > this.sequence) {\n      this.sequence = data.sequence;\n      let newfraglist = [];\n      for (let i = 0; i < data.frags.length; i++) {\n        let frag = data.frags[i];\n        if (!this._ts[frag.url]) {\n          newfraglist.push(frag.url);\n          this.push(frag.url, frag.duration, frag.discontinue);\n        }\n      }\n\n      if (newfraglist.length < 1) {\n        throw new Error(`Can not read ts file list.`);\n      }\n\n      if (deletepre) {\n        let tslist = this.getTsList();\n        for (let i = 0; i < tslist.length; i++) {\n          if (newfraglist.indexOf(tslist[i]) < 0) {\n            this.deleteFrag(tslist[i]);\n          }\n        }\n      }\n    } else {\n      throw new Error(`Old m3u8 file received, ${data.sequence}`);\n    }\n  }\n\n  getTsList() {\n    return Object.keys(this._ts);\n  }\n\n  downloaded(tsname, isloaded) {\n    let ts = this._ts[tsname];\n    if (ts) {\n      ts.downloaded = isloaded;\n    }\n  }\n\n  downloading(tsname, loading) {\n    let ts = this._ts[tsname];\n    if (ts) {\n      ts.downloading = loading;\n    }\n  }\n\n  getTsByName(name) {\n    return this._ts[name];\n  }\n\n  getTs(time) {\n    let timelist = Object.keys(this._list);\n    let ts;\n\n    if (time === undefined) {\n      if (this._lastget) {\n        time = this._lastget.time + this._lastget.duration;\n      } else {\n        time = 0;\n      }\n    }\n\n    if (timelist.length < 1 || time >= this.duration) {\n      return undefined;\n    }\n    timelist.sort((a, b) => {\n      return parseFloat(a) - parseFloat(b);\n    });\n    for (let i = 0; i < timelist.length; i++) {\n      if (time >= parseInt(timelist[i])) {\n        let url = this._list[timelist[i]];\n        let downloaded = this._ts[url].downloaded;\n        let downloading = this._ts[url].downloading;\n        ts = { url, downloaded, downloading, time: parseInt(timelist[i]), duration: parseInt(this._ts[url].duration) };\n        if (this.autoclear) {\n          delete this._ts[this._lastget.url];\n          delete this._list[this._lastget.time];\n        }\n        this._lastget = ts;\n      } else {\n        break;\n      }\n    }\n    return ts;\n  }\n\n  clear() {\n    this._baseURL = '';\n    this._list = {};\n    this._ts = {};\n    this.version = 0;\n    this.sequence = -1;\n    this.targetduration = 0;\n    this.duration = 0;\n  }\n\n  clearDownloaded() {\n    for (let i = 0, l = Object.keys(this._ts).length; i < l; i++) {\n      let ts = this._ts[Object.keys(this._ts)[i]];\n      ts.downloaded = false;\n      ts.downloading = false;\n    }\n  }\n\n  destroy() {\n    this._baseURL = '';\n    this._list = {};\n    this._ts = {};\n    this.version = 0;\n    this.sequence = -1;\n    this.targetduration = 0;\n    this.duration = 0;\n    this.fragLength = 0;\n    this._lastget = undefined;\n    this._audoclear = false;\n  }\n}\n\nexports.default = Playlist;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-demux/src/hls/playlist.js?")},"../xgplayer-loader/index.js":
/*!***********************************!*\
      !*** ../xgplayer-loader/index.js ***!
      \***********************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nmodule.exports = {\n  FetchLoader: __webpack_require__(/*! ./src/fetch-loader */ "../xgplayer-loader/src/fetch-loader.js").default\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-loader/index.js?')},"../xgplayer-loader/src/fetch-loader.js":
/*!**********************************************!*\
      !*** ../xgplayer-loader/src/fetch-loader.js ***!
      \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nconst LOADER_EVENTS = _xgplayerUtils.EVENTS.LOADER_EVENTS;\nconst READ_STREAM = 0;\nconst READ_TEXT = 1;\nconst READ_JSON = 2;\nconst READ_BUFFER = 3;\nclass FetchLoader {\n  constructor(configs) {\n    this.configs = Object.assign({}, configs);\n    this.url = null;\n    this.status = 0;\n    this.error = null;\n    this._reader = null;\n    this._canceled = false;\n    this._destroyed = false;\n    this.readtype = this.configs.readtype;\n    this.buffer = this.configs.buffer || 'LOADER_BUFFER';\n    this._loaderTaskNo = 0;\n  }\n\n  init() {\n    this.on(LOADER_EVENTS.LADER_START, this.load.bind(this));\n  }\n\n  static get type() {\n    return 'loader';\n  }\n\n  load(url, opts) {\n    let _this = this;\n    this.url = url;\n    this._canceled = false;\n\n    // TODO: Add Ranges\n    let params = this.getParams(opts);\n    _this.loading = true;\n    return fetch(this.url, params).then(function (response) {\n      if (response.ok) {\n        _this.status = response.status;\n        return _this._onFetchResponse(response);\n      }\n      _this.loading = false;\n      _this.emit(LOADER_EVENTS.LOADER_ERROR, _this.TAG, new Error(`invalid response.`));\n    }).catch(function (error) {\n      _this.loading = false;\n      _this.emit(LOADER_EVENTS.LOADER_ERROR, _this.TAG, error);\n      throw new Error(error.message);\n    });\n  }\n\n  _onFetchResponse(response) {\n    let _this = this;\n    let buffer = this._context.getInstance(this.buffer);\n    this._loaderTaskNo++;\n    let taskno = this._loaderTaskNo;\n    if (response.ok === true) {\n      switch (this.readtype) {\n        case READ_JSON:\n          response.json().then(data => {\n            _this.loading = false;\n            if (!_this._canceled && !_this._destroyed) {\n              if (buffer) {\n                buffer.push(data);\n                _this.emit(LOADER_EVENTS.LOADER_COMPLETE, buffer);\n              } else {\n                _this.emit(LOADER_EVENTS.LOADER_COMPLETE, data);\n              }\n            }\n          });\n          break;\n        case READ_TEXT:\n          response.text().then(data => {\n            _this.loading = false;\n            if (!_this._canceled && !_this._destroyed) {\n              if (buffer) {\n                buffer.push(data);\n                _this.emit(LOADER_EVENTS.LOADER_COMPLETE, buffer);\n              } else {\n                _this.emit(LOADER_EVENTS.LOADER_COMPLETE, data);\n              }\n            }\n          });\n          break;\n        case READ_BUFFER:\n          response.arrayBuffer().then(data => {\n            _this.loading = false;\n            if (!_this._canceled && !_this._destroyed) {\n              if (buffer) {\n                buffer.push(new Uint8Array(data));\n                _this.emit(LOADER_EVENTS.LOADER_COMPLETE, buffer);\n              } else {\n                _this.emit(LOADER_EVENTS.LOADER_COMPLETE, data);\n              }\n            }\n          });\n          break;\n        case READ_STREAM:\n        default:\n          return this._onReader(response.body.getReader(), taskno);\n      }\n    }\n  }\n\n  _onReader(reader, taskno) {\n    let buffer = this._context.getInstance(this.buffer);\n    if (!buffer && this._reader || this._destroyed) {\n      try {\n        this._reader.cancel();\n      } catch (e) {\n        // DO NOTHING\n      }\n    }\n\n    this._reader = reader;\n    if (this.loading === false) {\n      return;\n    }\n\n    let _this = this;\n    // reader read function returns a Promise. get data when callback and has value.done when disconnected.\n    // read方法返回一个Promise. 回调中可以获取到数据。当value.done存在时，说明链接断开。\n    this._reader && this._reader.read().then(function (val) {\n      if (val.done) {\n        // TODO: 完成处理\n        _this.loading = false;\n        _this.status = 0;\n        _this.emit(LOADER_EVENTS.LOADER_COMPLETE, buffer);\n        return;\n      }\n\n      if (_this._canceled || _this._destroyed) {\n        if (_this._reader) {\n          try {\n            _this._reader.cancel();\n          } catch (e) {\n            // DO NOTHING\n          }\n        }\n\n        return;\n      }\n      buffer.push(val.value);\n      _this.emit(LOADER_EVENTS.LOADER_DATALOADED, buffer);\n      return _this._onReader(reader, taskno);\n    }).catch(error => {\n      _this.loading = false;\n      _this.emit(LOADER_EVENTS.LOADER_ERROR, _this.TAG, error);\n    });\n  }\n\n  getParams(opts) {\n    let options = Object.assign({}, opts);\n    let headers = new Headers();\n\n    let params = {\n      method: 'GET',\n      headers: headers,\n      mode: 'cors',\n      cache: 'default'\n\n      // add custmor headers\n      // 添加自定义头\n    };if (typeof this.configs.headers === 'object') {\n      let configHeaders = this.configs.headers;\n      for (let key in configHeaders) {\n        if (configHeaders.hasOwnProperty(key)) {\n          headers.append(key, configHeaders[key]);\n        }\n      }\n    }\n\n    if (typeof options.headers === 'object') {\n      let optHeaders = options.headers;\n      for (let key in optHeaders) {\n        if (optHeaders.hasOwnProperty(key)) {\n          headers.append(key, optHeaders[key]);\n        }\n      }\n    }\n\n    if (options.cors === false) {\n      params.mode = 'same-origin';\n    }\n\n    // withCredentials is disabled by default\n    // withCredentials 在默认情况下不被使用。\n    if (options.withCredentials) {\n      params.credentials = 'include';\n    }\n\n    // TODO: Add ranges;\n    return params;\n  }\n\n  cancel() {\n    if (this._reader) {\n      try {\n        this._reader.cancel();\n      } catch (e) {\n        // 防止failed: 200错误被打印到控制台上\n      }\n      this._reader = null;\n      this.loading = false;\n      this._canceled = true;\n    }\n  }\n\n  destroy() {\n    this._destroyed = true;\n    this.cancel();\n  }\n}\n\nexports.default = FetchLoader;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-loader/src/fetch-loader.js?")},"../xgplayer-remux/index.js":
/*!**********************************!*\
      !*** ../xgplayer-remux/index.js ***!
      \**********************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nmodule.exports = {\n  Mp4Remuxer: __webpack_require__(/*! ./src/mp4 */ "../xgplayer-remux/src/mp4/index.js").default\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-remux/index.js?')},"../xgplayer-remux/src/mp4/fmp4.js":
/*!*****************************************!*\
      !*** ../xgplayer-remux/src/mp4/fmp4.js ***!
      \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\n// const UINT32_MAX = Math.pow(2, 32) - 1;\nclass Fmp4 {\n  static size(value) {\n    return _xgplayerUtils.Buffer.writeUint32(value);\n  }\n  static initBox(size, name, ...content) {\n    const buffer = new _xgplayerUtils.Buffer();\n    buffer.write(Fmp4.size(size), Fmp4.type(name), ...content);\n    return buffer.buffer;\n  }\n  static extension(version, flag) {\n    return new Uint8Array([version, flag >> 16 & 0xff, flag >> 8 & 0xff, flag & 0xff]);\n  }\n  static ftyp() {\n    return Fmp4.initBox(24, 'ftyp', new Uint8Array([0x69, 0x73, 0x6F, 0x6D, // isom,\n    0x0, 0x0, 0x00, 0x01, // minor_version: 0x01\n    0x69, 0x73, 0x6F, 0x6D, // isom\n    0x61, 0x76, 0x63, 0x31 // avc1\n    ]));\n  }\n  static moov({ type, meta }) {\n    let size = 8;\n    let mvhd = Fmp4.mvhd(meta.duration, meta.timescale);\n    let trak;\n\n    if (type === 'video') {\n      trak = Fmp4.videoTrak(meta);\n    } else {\n      trak = Fmp4.audioTrak(meta);\n    }\n\n    let mvex = Fmp4.mvex(meta.duration, meta.timescale || 1000, meta.id);\n    [mvhd, trak, mvex].forEach(item => {\n      size += item.byteLength;\n    });\n    return Fmp4.initBox(size, 'moov', mvhd, trak, mvex);\n  }\n  static mvhd(duration, timescale = 1000) {\n    // duration *= timescale;\n    let bytes = new Uint8Array([0x00, 0x00, 0x00, 0x00, // version(0) + flags     1位的box版本+3位flags   box版本，0或1，一般为0。（以下字节数均按version=0）\n    0x00, 0x00, 0x00, 0x00, // creation_time    创建时间  （相对于UTC时间1904-01-01零点的秒数）\n    0x00, 0x00, 0x00, 0x00, // modification_time   修改时间\n\n    /**\n           * timescale: 4 bytes文件媒体在1秒时间内的刻度值，可以理解为1秒长度\n           */\n    timescale >>> 24 & 0xFF, timescale >>> 16 & 0xFF, timescale >>> 8 & 0xFF, timescale & 0xFF,\n\n    /**\n           * duration: 4 bytes该track的时间长度，用duration和time scale值可以计算track时长，比如audio track的time scale = 8000,\n           * duration = 560128，时长为70.016，video track的time scale = 600, duration = 42000，时长为70\n           */\n    duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, 0x00, 0x01, 0x00, 0x00, // Preferred rate: 1.0   推荐播放速率，高16位和低16位分别为小数点整数部分和小数部分，即[16.16] 格式，该值为1.0（0x00010000）表示正常前向播放\n    /**\n           * PreferredVolume(1.0, 2bytes) + reserved(2bytes)\n           * 与rate类似，[8.8] 格式，1.0（0x0100）表示最大音量\n           */\n    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //  reserved: 4 + 4 bytes保留位\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, // ----begin composition matrix----\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 视频变换矩阵   线性代数\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // ----end composition matrix----\n    0x00, 0x00, 0x00, 0x00, // ----begin pre_defined 6 * 4 bytes----\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre-defined 保留位\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ----end pre_defined 6 * 4 bytes----\n    0xFF, 0xFF, 0xFF, 0xFF // next_track_ID 下一个track使用的id号\n    ]);\n    return Fmp4.initBox(8 + bytes.length, 'mvhd', new Uint8Array(bytes));\n  }\n  static videoTrak(data) {\n    let size = 8;\n\n    let tkhd = Fmp4.tkhd({\n      id: 1,\n      duration: data.duration,\n      timescale: data.timescale || 1000,\n      width: data.presentWidth,\n      height: data.presentHeight,\n      type: 'video'\n    });\n    let mdia = Fmp4.mdia({\n      type: 'video',\n      timescale: data.timescale || 1000,\n      duration: data.duration,\n      avcc: data.avcc,\n      parRatio: data.parRatio,\n      width: data.presentWidth,\n      height: data.presentHeight\n    });\n    [tkhd, mdia].forEach(item => {\n      size += item.byteLength;\n    });\n    return Fmp4.initBox(size, 'trak', tkhd, mdia);\n  }\n  static audioTrak(data) {\n    let size = 8;\n    let tkhd = Fmp4.tkhd({\n      id: 2,\n      duration: data.duration,\n      timescale: data.timescale || 1000,\n      width: 0,\n      height: 0,\n      type: 'audio'\n    });\n    let mdia = Fmp4.mdia({\n      type: 'audio',\n      timescale: data.timescale || 1000,\n      duration: data.duration,\n      channelCount: data.channelCount,\n      samplerate: data.sampleRate,\n      config: data.config\n    });\n    [tkhd, mdia].forEach(item => {\n      size += item.byteLength;\n    });\n    return Fmp4.initBox(size, 'trak', tkhd, mdia);\n  }\n  static tkhd(data) {\n    let id = data.id;\n    let duration = data.duration;\n    let width = data.width;\n    let height = data.height;\n    let content = new Uint8Array([0x00, 0x00, 0x00, 0x07, // version(0) + flags 1位版本 box版本，0或1，一般为0。（以下字节数均按version=0）按位或操作结果值，预定义如下：\n    // 0x000001 track_enabled，否则该track不被播放；\n    // 0x000002 track_in_movie，表示该track在播放中被引用；\n    // 0x000004 track_in_preview，表示该track在预览时被引用。\n    // 一般该值为7，1+2+4 如果一个媒体所有track均未设置track_in_movie和track_in_preview，将被理解为所有track均设置了这两项；对于hint track，该值为0\n    // hint track 这个特殊的track并不包含媒体数据，而是包含了一些将其他数据track打包成流媒体的指示信息。\n    0x00, 0x00, 0x00, 0x00, // creation_time创建时间（相对于UTC时间1904-01-01零点的秒数）\n    0x00, 0x00, 0x00, 0x00, // modification time 修改时间\n    id >>> 24 & 0xFF, // track_ID: 4 bytes id号，不能重复且不能为0\n    id >>> 16 & 0xFF, id >>> 8 & 0xFF, id & 0xFF, 0x00, 0x00, 0x00, 0x00, // reserved: 4 bytes    保留位\n    duration >>> 24 & 0xFF, // duration: 4 bytes track的时间长度\n    duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, 0x00, 0x00, 0x00, 0x00, // reserved: 2 * 4 bytes    保留位\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // layer(2bytes) + alternate_group(2bytes)  视频层，默认为0，值小的在上层.track分组信息，默认为0表示该track未与其他track有群组关系\n    0x00, 0x00, 0x00, 0x00, // volume(2bytes) + reserved(2bytes)    [8.8] 格式，如果为音频track，1.0（0x0100）表示最大音量；否则为0   +保留位\n    0x00, 0x01, 0x00, 0x00, // ----begin composition matrix----\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, // 视频变换矩阵\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // ----end composition matrix----\n    width >>> 8 & 0xFF, // //宽度\n    width & 0xFF, 0x00, 0x00, height >>> 8 & 0xFF, // 高度\n    height & 0xFF, 0x00, 0x00]);\n    return Fmp4.initBox(8 + content.byteLength, 'tkhd', content);\n  }\n  static edts(data) {\n    let buffer = new _xgplayerUtils.Buffer();\n    let duration = data.duration;\n    let mediaTime = data.mediaTime;\n    buffer.write(Fmp4.size(36), Fmp4.type('edts'));\n    // elst\n    buffer.write(Fmp4.size(28), Fmp4.type('elst'));\n    buffer.write(new Uint8Array([0x00, 0x00, 0x00, 0x01, // entry count\n    duration >> 24 & 0xff, duration >> 16 & 0xff, duration >> 8 & 0xff, duration & 0xff, mediaTime >> 24 & 0xff, mediaTime >> 16 & 0xff, mediaTime >> 8 & 0xff, mediaTime & 0xff, 0x00, 0x00, 0x00, 0x01 // media rate\n    ]));\n    return buffer.buffer;\n  }\n  static mdia(data) {\n    let size = 8;\n    let mdhd = Fmp4.mdhd(data.timescale, data.duration);\n    let hdlr = Fmp4.hdlr(data.type);\n    let minf = Fmp4.minf(data);\n    [mdhd, hdlr, minf].forEach(item => {\n      size += item.byteLength;\n    });\n    return Fmp4.initBox(size, 'mdia', mdhd, hdlr, minf);\n  }\n  static mdhd(timescale = 1000, duration) {\n    let content = new Uint8Array([0x00, 0x00, 0x00, 0x00, // creation_time    创建时间\n    0x00, 0x00, 0x00, 0x00, // modification_time修改时间\n    timescale >>> 24 & 0xFF, // timescale: 4 bytes    文件媒体在1秒时间内的刻度值，可以理解为1秒长度\n    timescale >>> 16 & 0xFF, timescale >>> 8 & 0xFF, timescale & 0xFF, duration >>> 24 & 0xFF, // duration: 4 bytes  track的时间长度\n    duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, 0x55, 0xC4, // language: und (undetermined) 媒体语言码。最高位为0，后面15位为3个字符（见ISO 639-2/T标准中定义）\n    0x00, 0x00 // pre_defined = 0\n    ]);\n    return Fmp4.initBox(12 + content.byteLength, 'mdhd', Fmp4.extension(0, 0), content);\n  }\n  static hdlr(type) {\n    let value = [0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ];\n    if (type === 'audio') {\n      value.splice(8, 4, ...[0x73, 0x6f, 0x75, 0x6e]);\n      value.splice(24, 13, ...[0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00]);\n    }\n    return Fmp4.initBox(8 + value.length, 'hdlr', new Uint8Array(value));\n  }\n  static minf(data) {\n    let size = 8;\n    let vmhd = data.type === 'video' ? Fmp4.vmhd() : Fmp4.smhd();\n    let dinf = Fmp4.dinf();\n    let stbl = Fmp4.stbl(data);\n    [vmhd, dinf, stbl].forEach(item => {\n      size += item.byteLength;\n    });\n    return Fmp4.initBox(size, 'minf', vmhd, dinf, stbl);\n  }\n  static vmhd() {\n    return Fmp4.initBox(20, 'vmhd', new Uint8Array([0x00, // version\n    0x00, 0x00, 0x01, // flags\n    0x00, 0x00, // graphicsmode\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n    ]));\n  }\n  static smhd() {\n    return Fmp4.initBox(16, 'smhd', new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, // balance\n    0x00, 0x00 // reserved\n    ]));\n  }\n  static dinf() {\n    let buffer = new _xgplayerUtils.Buffer();\n    let dref = [0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // entry_count\n    0x00, 0x00, 0x00, 0x0c, // entry_size\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\n    0x00, // version 0\n    0x00, 0x00, 0x01 // entry_flags\n    ];\n    buffer.write(Fmp4.size(36), Fmp4.type('dinf'), Fmp4.size(28), Fmp4.type('dref'), new Uint8Array(dref));\n    return buffer.buffer;\n  }\n  static stbl(data) {\n    let size = 8;\n    let stsd = Fmp4.stsd(data);\n    let stts = Fmp4.stts();\n    let stsc = Fmp4.stsc();\n    let stsz = Fmp4.stsz();\n    let stco = Fmp4.stco();\n    [stsd, stts, stsc, stsz, stco].forEach(item => {\n      size += item.byteLength;\n    });\n    return Fmp4.initBox(size, 'stbl', stsd, stts, stsc, stsz, stco);\n  }\n  static stsd(data) {\n    let content;\n    if (data.type === 'audio') {\n      // if (!data.isAAC && data.codec === 'mp4') {\n      //     content = FMP4.mp3(data);\n      // } else {\n      //\n      // }\n      // 支持mp4a\n      content = Fmp4.mp4a(data);\n    } else {\n      content = Fmp4.avc1(data);\n    }\n    return Fmp4.initBox(16 + content.byteLength, 'stsd', Fmp4.extension(0, 0), new Uint8Array([0x00, 0x00, 0x00, 0x01]), content);\n  }\n  static mp4a(data) {\n    let content = new Uint8Array([0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, // data_reference_index\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, data.channelCount, // channelcount\n    0x00, 0x10, // sampleSize:16bits\n    0x00, 0x00, 0x00, 0x00, // reserved2\n    data.samplerate >> 8 & 0xff, data.samplerate & 0xff, //\n    0x00, 0x00]);\n    let esds = Fmp4.esds(data.config);\n    return Fmp4.initBox(8 + content.byteLength + esds.byteLength, 'mp4a', content, esds);\n  }\n  static esds(config = [43, 146, 8, 0]) {\n    const configlen = config.length;\n    let buffer = new _xgplayerUtils.Buffer();\n    let content = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n\n    0x03, // descriptor_type\n    0x17 + configlen, // length\n    0x00, 0x01, // es_id\n    0x00, // stream_priority\n\n    0x04, // descriptor_type\n    0x0f + configlen, // length\n    0x40, // codec : mpeg4_audio\n    0x15, // stream_type\n    0x00, 0x00, 0x00, // buffer_size\n    0x00, 0x00, 0x00, 0x00, // maxBitrate\n    0x00, 0x00, 0x00, 0x00, // avgBitrate\n\n    0x05 // descriptor_type\n    ].concat([configlen]).concat(config).concat([0x06, 0x01, 0x02]));\n    buffer.write(Fmp4.size(8 + content.byteLength), Fmp4.type('esds'), content);\n    return buffer.buffer;\n  }\n  static avc1(data) {\n    let buffer = new _xgplayerUtils.Buffer();\n    let size = 40; // 8(avc1)+8(avcc)+8(btrt)+16(pasp)\n    // let sps = data.sps\n    // let pps = data.pps\n    let width = data.width;\n    let height = data.height;\n    let hSpacing = data.parRatio.height;\n    let vSpacing = data.parRatio.width;\n    // let avccBuffer = new Buffer()\n    // avccBuffer.write(new Uint8Array([\n    //   0x01, // version\n    //   sps[1], // profile\n    //   sps[2], // profile compatible\n    //   sps[3], // level\n    //   0xfc | 3,\n    //   0xE0 | 1 // 目前只处理一个sps\n    // ].concat([sps.length >>> 8 & 0xff, sps.length & 0xff])))\n    // avccBuffer.write(sps, new Uint8Array([1, pps.length >>> 8 & 0xff, pps.length & 0xff]), pps)\n\n    let avcc = data.avcc;\n    let avc1 = new Uint8Array([0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, // data_reference_index\n    0x00, 0x00, // pre_defined\n    0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n    width >> 8 & 0xff, width & 0xff, // width\n    height >> 8 & 0xff, height & 0xff, // height\n    0x00, 0x48, 0x00, 0x00, // horizresolution\n    0x00, 0x48, 0x00, 0x00, // vertresolution\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, // frame_count\n    0x12, 0x64, 0x61, 0x69, 0x6C, // dailymotion/hls.js\n    0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname\n    0x00, 0x18, // depth = 24\n    0x11, 0x11]); // pre_defined = -1\n    let btrt = new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n    0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n    0x00, 0x2d, 0xc6, 0xc0 // avgBitrate\n    ]);\n    let pasp = new Uint8Array([hSpacing >> 24, // hSpacing\n    hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24, // vSpacing\n    vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff]);\n\n    buffer.write(Fmp4.size(size + avc1.byteLength + avcc.byteLength + btrt.byteLength), Fmp4.type('avc1'), avc1, Fmp4.size(8 + avcc.byteLength), Fmp4.type('avcC'), avcc, Fmp4.size(20), Fmp4.type('btrt'), btrt, Fmp4.size(16), Fmp4.type('pasp'), pasp);\n    return buffer.buffer;\n  }\n  static stts() {\n    let content = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n    return Fmp4.initBox(16, 'stts', content);\n  }\n  static stsc() {\n    let content = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n    return Fmp4.initBox(16, 'stsc', content);\n  }\n  static stco() {\n    let content = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n    return Fmp4.initBox(16, 'stco', content);\n  }\n  static stsz() {\n    let content = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n    ]);\n    return Fmp4.initBox(20, 'stsz', content);\n  }\n  static mvex(duration, timescale = 1000, trackID) {\n    let buffer = new _xgplayerUtils.Buffer();\n    let mehd = _xgplayerUtils.Buffer.writeUint32(duration);\n    buffer.write(Fmp4.size(56), Fmp4.type('mvex'), Fmp4.size(16), Fmp4.type('mehd'), Fmp4.extension(0, 0), mehd, Fmp4.trex(trackID));\n    return buffer.buffer;\n  }\n  static trex(id) {\n    let content = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff, // track_ID\n    0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]);\n    return Fmp4.initBox(8 + content.byteLength, 'trex', content);\n  }\n  static moof(data) {\n    let size = 8;\n    let mfhd = Fmp4.mfhd();\n    let traf = Fmp4.traf(data);\n    [mfhd, traf].forEach(item => {\n      size += item.byteLength;\n    });\n    return Fmp4.initBox(size, 'moof', mfhd, traf);\n  }\n  static mfhd() {\n    let content = _xgplayerUtils.Buffer.writeUint32(Fmp4.sequence);\n    Fmp4.sequence += 1;\n    return Fmp4.initBox(16, 'mfhd', Fmp4.extension(0, 0), content);\n  }\n  static traf(data) {\n    let size = 8;\n    let tfhd = Fmp4.tfhd(data.id);\n    let tfdt = Fmp4.tfdt(data.time);\n    let sdtp = Fmp4.sdtp(data);\n    let trun = Fmp4.trun(data, sdtp.byteLength);\n\n    [tfhd, tfdt, trun, sdtp].forEach(item => {\n      size += item.byteLength;\n    });\n    return Fmp4.initBox(size, 'traf', tfhd, tfdt, trun, sdtp);\n  }\n  static tfhd(id) {\n    let content = _xgplayerUtils.Buffer.writeUint32(id);\n    return Fmp4.initBox(16, 'tfhd', Fmp4.extension(0, 0), content);\n  }\n  static tfdt(time) {\n    // let upper = Math.floor(time / (UINT32_MAX + 1)),\n    //     lower = Math.floor(time % (UINT32_MAX + 1));\n    return Fmp4.initBox(16, 'tfdt', Fmp4.extension(0, 0), _xgplayerUtils.Buffer.writeUint32(time));\n  }\n  static trun(data, sdtpLength) {\n    // let id = data.id;\n    // let ceil = id === 1 ? 16 : 12;\n    let buffer = new _xgplayerUtils.Buffer();\n    let sampleCount = _xgplayerUtils.Buffer.writeUint32(data.samples.length);\n    // mdat-header 8\n    // moof-header 8\n    // mfhd 16\n    // traf-header 8\n    // thhd 16\n    // tfdt 20\n    // trun-header 12\n    // sampleCount 4\n    // data-offset 4\n    // samples.length\n    let offset = _xgplayerUtils.Buffer.writeUint32(8 + 8 + 16 + 8 + 16 + 16 + 12 + 4 + 4 + 16 * data.samples.length + sdtpLength);\n    buffer.write(Fmp4.size(20 + 16 * data.samples.length), Fmp4.type('trun'), new Uint8Array([0x00, 0x00, 0x0F, 0x01]), sampleCount, offset);\n\n    // let size = buffer.buffer.byteLength\n    // let writeOffset = 0\n    // data.samples.forEach(() => {\n    //   size += 16\n    // })\n    //\n    // let trunBox = new Uint8Array(size)\n\n    // trunBox.set(buffer.buffer, 0)\n\n    data.samples.forEach(item => {\n      const flags = item.flags;\n      // console.log(item.type, item.dts, item.duration)\n\n      buffer.write(new Uint8Array([item.duration >>> 24 & 0xFF, // sample_duration\n      item.duration >>> 16 & 0xFF, item.duration >>> 8 & 0xFF, item.duration & 0xFF, item.size >>> 24 & 0xFF, // sample_size\n      item.size >>> 16 & 0xFF, item.size >>> 8 & 0xFF, item.size & 0xFF, flags.isLeading << 2 | flags.dependsOn, // sample_flags\n      flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.isNonSync, 0x00, 0x00, // sample_degradation_priority\n      item.cts >>> 24 & 0xFF, // sample_composition_time_offset\n      item.cts >>> 16 & 0xFF, item.cts >>> 8 & 0xFF, item.cts & 0xFF]));\n      // writeOffset += 16\n      // buffer.write(Buffer.writeUint32(0));\n    });\n    return buffer.buffer;\n  }\n  static sdtp(data) {\n    let buffer = new _xgplayerUtils.Buffer();\n    buffer.write(Fmp4.size(12 + data.samples.length), Fmp4.type('sdtp'), Fmp4.extension(0, 0));\n    data.samples.forEach(item => {\n      const flags = item.flags;\n      const num = flags.isLeading << 6 | // is_leading: 2 (bit)\n      flags.dependsOn << 4 | // sample_depends_on\n      flags.isDependedOn << 2 | // sample_is_depended_on\n      flags.hasRedundancy; // sample_has_redundancy\n\n      buffer.write(new Uint8Array([num]));\n    });\n    return buffer.buffer;\n  }\n  static mdat(data) {\n    let buffer = new _xgplayerUtils.Buffer();\n    let size = 8;\n    data.samples.forEach(item => {\n      size += item.size;\n    });\n    buffer.write(Fmp4.size(size), Fmp4.type('mdat'));\n    let mdatBox = new Uint8Array(size);\n    let offset = 0;\n    mdatBox.set(buffer.buffer, offset);\n    offset += 8;\n    data.samples.forEach(item => {\n      item.buffer.forEach(unit => {\n        mdatBox.set(unit, offset);\n        offset += unit.byteLength;\n        // buffer.write(unit.data);\n      });\n    });\n    return mdatBox;\n  }\n}\nFmp4.type = name => {\n  return new Uint8Array([name.charCodeAt(0), name.charCodeAt(1), name.charCodeAt(2), name.charCodeAt(3)]);\n};\nFmp4.sequence = 1;\n\nexports.default = Fmp4;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-remux/src/mp4/fmp4.js?")},"../xgplayer-remux/src/mp4/index.js":
/*!******************************************!*\
      !*** ../xgplayer-remux/src/mp4/index.js ***!
      \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nvar _fmp = __webpack_require__(/*! ./fmp4 */ \"../xgplayer-remux/src/mp4/fmp4.js\");\n\nvar _fmp2 = _interopRequireDefault(_fmp);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst REMUX_EVENTS = _xgplayerUtils.EVENTS.REMUX_EVENTS;\n\nclass Mp4Remuxer {\n  constructor() {\n    this._dtsBase = 0;\n    this._isDtsBaseInited = false;\n\n    this.isFirstVideo = true;\n    this.isFirstAudio = true;\n\n    this.videoAllDuration = 0;\n    this.audioAllDuration = 0;\n  }\n\n  init() {\n    this.on(REMUX_EVENTS.REMUX_MEDIA, this.remux.bind(this));\n    this.on(REMUX_EVENTS.REMUX_METADATA, this.onMetaDataReady.bind(this));\n    this.on(REMUX_EVENTS.DETECT_CHANGE_STREAM, this.resetDtsBase.bind(this));\n  }\n\n  destroy() {\n    this._dtsBase = -1;\n    this._dtsBaseInited = false;\n  }\n\n  reset() {\n    this._dtsBase = 0;\n    this._isDtsBaseInited = false;\n  }\n\n  remux() {\n    const { audioTrack, videoTrack } = this._context.getInstance('TRACKS');\n    !this._isDtsBaseInited && this.calcDtsBase(audioTrack, videoTrack);\n\n    this._remuxVideo(videoTrack);\n    this._remuxAudio(audioTrack);\n  }\n\n  resetDtsBase() {\n    // for hls 中途切换 meta后seek\n    this._dtsBase = 0;\n    this._dtsBaseInited = false;\n  }\n\n  seek() {}\n\n  onMetaDataReady(type) {\n    let track;\n\n    if (type === 'audio') {\n      const { audioTrack } = this._context.getInstance('TRACKS');\n      track = audioTrack;\n    } else {\n      const { videoTrack } = this._context.getInstance('TRACKS');\n      track = videoTrack;\n    }\n\n    let presourcebuffer = this._context.getInstance('PRE_SOURCE_BUFFER');\n    let source = presourcebuffer.getSource(type);\n    if (!source) {\n      source = presourcebuffer.createSource(type);\n    }\n\n    source.mimetype = track.meta.codec;\n    source.init = this.remuxInitSegment(type, track.meta);\n    // source.inited = false;\n\n    // this.resetDtsBase()\n    this.emit(REMUX_EVENTS.INIT_SEGMENT, type);\n  }\n\n  remuxInitSegment(type, meta) {\n    let initSegment = new _xgplayerUtils.Buffer();\n    let ftyp = _fmp2.default.ftyp();\n    let moov = _fmp2.default.moov({ type, meta: meta });\n\n    initSegment.write(ftyp, moov);\n    return initSegment;\n  }\n\n  calcDtsBase(audioTrack, videoTrack) {\n    if (!audioTrack.samples.length && !videoTrack.samples.length) {\n      return;\n    }\n\n    let audioBase = Infinity;\n    let videoBase = Infinity;\n\n    if (audioTrack.samples && audioTrack.samples.length) {\n      audioBase = audioTrack.samples[0].dts;\n    }\n    if (videoTrack.samples && videoTrack.samples.length) {\n      videoBase = videoTrack.samples[0].dts;\n    }\n\n    this._dtsBase = Math.min(audioBase, videoBase);\n    this._isDtsBaseInited = true;\n  }\n\n  _remuxVideo(videoTrack) {\n    const track = videoTrack;\n\n    if (!videoTrack.samples || !videoTrack.samples.length) {\n      return;\n    }\n\n    let { samples } = track;\n    let firstDts = -1;\n\n    let initSegment = null;\n    const mp4Samples = [];\n    const mdatBox = {\n      samples: []\n    };\n\n    while (samples.length) {\n      const avcSample = samples.shift();\n\n      const { isKeyframe, options } = avcSample;\n      if (!this.isFirstAudio && options && options.meta) {\n        initSegment = this.remuxInitSegment('video', options.meta);\n        options.meta = null;\n        samples.unshift(avcSample);\n        if (!options.isContinue) {\n          this.resetDtsBase();\n        }\n        break;\n      }\n\n      let dts = avcSample.dts - this._dtsBase;\n\n      if (firstDts === -1) {\n        firstDts = dts;\n      }\n\n      let cts;\n      let pts;\n      if (avcSample.pts !== undefined) {\n        pts = avcSample.pts - this._dtsBase;\n        cts = pts - dts;\n      }\n      if (avcSample.cts !== undefined) {\n        pts = avcSample.cts + dts;\n        cts = avcSample.cts;\n      }\n\n      let mdatSample = {\n        buffer: [],\n        size: 0\n      };\n      mdatBox.samples.push(mdatSample);\n      mdatSample.buffer.push(avcSample.data);\n      mdatSample.size += avcSample.data.byteLength;\n\n      let sampleDuration = 0;\n      if (samples.length >= 1) {\n        const nextDts = samples[0].dts - this._dtsBase;\n        sampleDuration = nextDts - dts;\n      } else {\n        if (mp4Samples.length >= 1) {\n          // lastest sample, use second last duration\n          sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n        } else {\n          // the only one sample, use reference duration\n          sampleDuration = this.videoMeta.refSampleDuration;\n        }\n      }\n      this.videoAllDuration += sampleDuration;\n      // console.log(`dts ${dts}`, `pts ${pts}`, `cts: ${cts}`, `duration: ${sampleDuration}`, avcSample)\n      mp4Samples.push({\n        dts,\n        cts,\n        pts,\n        data: avcSample.data,\n        size: avcSample.data.byteLength,\n        isKeyframe,\n        duration: sampleDuration,\n        flags: {\n          isLeading: 0,\n          dependsOn: isKeyframe ? 2 : 1,\n          isDependedOn: isKeyframe ? 1 : 0,\n          hasRedundancy: 0,\n          isNonSync: isKeyframe ? 0 : 1\n        },\n        originDts: dts,\n        type: 'video'\n      });\n    }\n\n    let moofMdat = new _xgplayerUtils.Buffer();\n    if (mp4Samples.length) {\n      const moof = _fmp2.default.moof({\n        id: track.meta.id,\n        time: firstDts,\n        samples: mp4Samples\n      });\n      const mdat = _fmp2.default.mdat(mdatBox);\n      moofMdat.write(moof, mdat);\n\n      this.writeToSource('video', moofMdat);\n    }\n\n    if (initSegment) {\n      this.writeToSource('video', initSegment);\n\n      if (samples.length) {\n        // second part of stream change\n        track.samples = samples;\n        return this._remuxVideo(track);\n      }\n    }\n\n    this.isFirstVideo = false;\n    this.emit(REMUX_EVENTS.MEDIA_SEGMENT, 'video');\n\n    const lastSample = mp4Samples[mp4Samples.length - 1];\n    this._videoNextDts = lastSample.dts + lastSample.duration;\n    track.samples = [];\n    track.length = 0;\n  }\n\n  _remuxAudio(track) {\n    const { samples } = track;\n    let firstDts = -1;\n    let mp4Samples = [];\n\n    let initSegment = null;\n    const mdatBox = {\n      samples: []\n    };\n    if (!samples || !samples.length) {\n      return;\n    }\n    let isFirstDtsInited = false;\n    while (samples.length) {\n      let sample = samples.shift();\n      const { data, options } = sample;\n      if (!this.isFirstAudio && options && options.meta) {\n        initSegment = this.remuxInitSegment('audio', options.meta);\n        options.meta = null;\n        samples.unshift(sample);\n        if (!options.isContinue) {\n          this.resetDtsBase();\n        }\n        break;\n      }\n\n      let dts = sample.dts - this._dtsBase;\n      const originDts = dts;\n      if (!isFirstDtsInited) {\n        firstDts = dts;\n        isFirstDtsInited = true;\n      }\n\n      let sampleDuration = 0;\n\n      if (this.audioMeta.refSampleDurationFixed) {\n        sampleDuration = this.audioMeta.refSampleDurationFixed;\n      } else if (samples.length >= 1) {\n        const nextDts = samples[0].dts - this._dtsBase;\n        sampleDuration = nextDts - dts;\n      } else {\n        if (mp4Samples.length >= 1) {\n          // use second last sample duration\n          sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n        } else {\n          // the only one sample, use reference sample duration\n          sampleDuration = this.audioMeta.refSampleDuration;\n        }\n      }\n\n      // console.log('remux audio ', dts)\n      this.audioAllDuration += sampleDuration;\n      const mp4Sample = {\n        dts,\n        pts: dts,\n        cts: 0,\n        size: data.byteLength,\n        duration: sample.duration ? sample.duration : sampleDuration,\n        flags: {\n          isLeading: 0,\n          dependsOn: 2,\n          isDependedOn: 1,\n          hasRedundancy: 0,\n          isNonSync: 0\n        },\n        isKeyframe: true,\n        originDts,\n        type: 'audio'\n      };\n\n      let mdatSample = {\n        buffer: [],\n        size: 0\n      };\n      mdatSample.buffer.push(data);\n      mdatSample.size += data.byteLength;\n\n      mdatBox.samples.push(mdatSample);\n\n      mp4Samples.push(mp4Sample);\n    }\n\n    const moofMdat = new _xgplayerUtils.Buffer();\n\n    if (mp4Samples.length) {\n      const moof = _fmp2.default.moof({\n        id: track.meta.id,\n        time: firstDts,\n        samples: mp4Samples\n      });\n      const mdat = _fmp2.default.mdat(mdatBox);\n      moofMdat.write(moof, mdat);\n\n      this.writeToSource('audio', moofMdat);\n    }\n\n    if (initSegment) {\n      this.writeToSource('audio', initSegment);\n      if (samples.length) {\n        // second part of stream change\n        track.samples = samples;\n        return this._remuxAudio(track);\n      }\n    }\n\n    this.isFirstAudio = false;\n    this.emit(REMUX_EVENTS.MEDIA_SEGMENT, 'audio', moofMdat);\n\n    const lastSample = mp4Samples[mp4Samples.length - 1];\n    this._videoNextDts = lastSample.dts + lastSample.duration;\n    track.samples = [];\n    track.length = 0;\n  }\n\n  writeToSource(type, buffer) {\n    let presourcebuffer = this._context.getInstance('PRE_SOURCE_BUFFER');\n    let source = presourcebuffer.getSource(type);\n    if (!source) {\n      source = presourcebuffer.createSource(type);\n    }\n\n    source.data.push(buffer);\n  }\n\n  initSilentAudio(dts, duration) {\n    const unit = Mp4Remuxer.getSilentFrame(this.audioMeta.channelCount);\n    return {\n      dts,\n      pts: dts,\n      cts: 0,\n      duration,\n      unit,\n      size: unit.byteLength,\n      originDts: dts,\n      type: 'video'\n    };\n  }\n\n  get videoMeta() {\n    return this._context.getInstance('TRACKS').videoTrack.meta;\n  }\n  get audioMeta() {\n    return this._context.getInstance('TRACKS').audioTrack.meta;\n  }\n\n  static getSilentFrame(channelCount) {\n    if (channelCount === 1) {\n      return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n    } else if (channelCount === 2) {\n      return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n    } else if (channelCount === 3) {\n      return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n    } else if (channelCount === 4) {\n      return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n    } else if (channelCount === 5) {\n      return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n    } else if (channelCount === 6) {\n      return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n    }\n    return null;\n  }\n}\nexports.default = Mp4Remuxer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-remux/src/mp4/index.js?")},"../xgplayer-utils/index.js":
/*!**********************************!*\
      !*** ../xgplayer-utils/index.js ***!
      \**********************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nmodule.exports = {\n  Context: __webpack_require__(/*! ./src/context */ "../xgplayer-utils/src/context.js").default,\n\n  // Modules from constants\n  EVENTS: __webpack_require__(/*! ./src/constants/events */ "../xgplayer-utils/src/constants/events.js").default,\n  WORKER_COMMANDS: __webpack_require__(/*! ./src/constants/worker-commands */ "../xgplayer-utils/src/constants/worker-commands.js").default,\n\n  // Modules from env\n  sniffer: __webpack_require__(/*! ./src/env/sniffer */ "../xgplayer-utils/src/env/sniffer.js").default,\n  isLe: __webpack_require__(/*! ./src/env/isle */ "../xgplayer-utils/src/env/isle.js").default,\n  UTF8: __webpack_require__(/*! ./src/env/utf8 */ "../xgplayer-utils/src/env/utf8.js").default,\n\n  // Models\n  MediaInfo: __webpack_require__(/*! ./src/models/media-info */ "../xgplayer-utils/src/models/media-info.js").default,\n  MediaSample: __webpack_require__(/*! ./src/models/media-sample */ "../xgplayer-utils/src/models/media-sample.js").default,\n  MediaSegment: __webpack_require__(/*! ./src/models/media-segment */ "../xgplayer-utils/src/models/media-segment.js").default,\n  MediaSegmentList: __webpack_require__(/*! ./src/models/media-segment-list */ "../xgplayer-utils/src/models/media-segment-list.js").default,\n  AudioTrackMeta: __webpack_require__(/*! ./src/models/track-meta */ "../xgplayer-utils/src/models/track-meta.js").AudioTrackMeta,\n  VideoTrackMeta: __webpack_require__(/*! ./src/models/track-meta */ "../xgplayer-utils/src/models/track-meta.js").VideoTrackMeta,\n  AudioTrackSample: __webpack_require__(/*! ./src/models/track-sample */ "../xgplayer-utils/src/models/track-sample.js").AudioTrackSample,\n  VideoTrackSample: __webpack_require__(/*! ./src/models/track-sample */ "../xgplayer-utils/src/models/track-sample.js").VideoTrackSample,\n\n  // Modules from mse\n  Mse: __webpack_require__(/*! ./src/mse/index */ "../xgplayer-utils/src/mse/index.js").default,\n\n  // Modules from write\n  Stream: __webpack_require__(/*! ./src/write/stream */ "../xgplayer-utils/src/write/stream.js").default,\n  Buffer: __webpack_require__(/*! ./src/write/buffer */ "../xgplayer-utils/src/write/buffer.js").default,\n\n  MobileVideo: __webpack_require__(/*! ./src/mobile/mobile-video */ "../xgplayer-utils/src/mobile/mobile-video.js"),\n  // Crypto\n  Crypto: __webpack_require__(/*! ./src/crypto */ "../xgplayer-utils/src/crypto/index.js").default\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/index.js?')},"../xgplayer-utils/node_modules/concat-typed-array/lib/concat.js":
/*!***********************************************************************!*\
      !*** ../xgplayer-utils/node_modules/concat-typed-array/lib/concat.js ***!
      \***********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nexports.default = function (ResultConstructor) {\n  var totalLength = 0;\n\n  for (var _len = arguments.length, arrays = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    arrays[_key - 1] = arguments[_key];\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = arrays[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var arr = _step.value;\n\n      totalLength += arr.length;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var result = new ResultConstructor(totalLength);\n  var offset = 0;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = arrays[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _arr = _step2.value;\n\n      result.set(_arr, offset);\n      offset += _arr.length;\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return result;\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/node_modules/concat-typed-array/lib/concat.js?')},"../xgplayer-utils/node_modules/concat-typed-array/lib/index.js":
/*!**********************************************************************!*\
      !*** ../xgplayer-utils/node_modules/concat-typed-array/lib/index.js ***!
      \**********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nvar _concat = __webpack_require__(/*! ./concat */ "../xgplayer-utils/node_modules/concat-typed-array/lib/concat.js");\n\nvar _concat2 = _interopRequireDefault(_concat);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nmodule.exports = _concat2.default;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/node_modules/concat-typed-array/lib/index.js?')},"../xgplayer-utils/node_modules/webworkify-webpack/index.js":
/*!******************************************************************!*\
      !*** ../xgplayer-utils/node_modules/webworkify-webpack/index.js ***!
      \******************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nfunction webpackBootstrapFunc(modules) {\n  /******/ // The module cache\n  /******/var installedModules = {};\n\n  /******/ // The require function\n  /******/function __webpack_require__(moduleId) {\n\n    /******/ // Check if module is in cache\n    /******/if (installedModules[moduleId])\n      /******/return installedModules[moduleId].exports;\n\n    /******/ // Create a new module (and put it into the cache)\n    /******/var module = installedModules[moduleId] = {\n      /******/i: moduleId,\n      /******/l: false,\n      /******/exports: {}\n      /******/ };\n\n    /******/ // Execute the module function\n    /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n    /******/ // Flag the module as loaded\n    /******/module.l = true;\n\n    /******/ // Return the exports of the module\n    /******/return module.exports;\n    /******/\n  }\n\n  /******/ // expose the modules object (__webpack_modules__)\n  /******/__webpack_require__.m = modules;\n\n  /******/ // expose the module cache\n  /******/__webpack_require__.c = installedModules;\n\n  /******/ // identity function for calling harmony imports with the correct context\n  /******/__webpack_require__.i = function (value) {\n    return value;\n  };\n\n  /******/ // define getter function for harmony exports\n  /******/__webpack_require__.d = function (exports, name, getter) {\n    /******/if (!__webpack_require__.o(exports, name)) {\n      /******/Object.defineProperty(exports, name, {\n        /******/configurable: false,\n        /******/enumerable: true,\n        /******/get: getter\n        /******/ });\n      /******/\n    }\n    /******/\n  };\n\n  /******/ // define __esModule on exports\n  /******/__webpack_require__.r = function (exports) {\n    /******/Object.defineProperty(exports, '__esModule', { value: true });\n    /******/\n  };\n\n  /******/ // getDefaultExport function for compatibility with non-harmony modules\n  /******/__webpack_require__.n = function (module) {\n    /******/var getter = module && module.__esModule ?\n    /******/function getDefault() {\n      return module['default'];\n    } :\n    /******/function getModuleExports() {\n      return module;\n    };\n    /******/__webpack_require__.d(getter, 'a', getter);\n    /******/return getter;\n    /******/\n  };\n\n  /******/ // Object.prototype.hasOwnProperty.call\n  /******/__webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n\n  /******/ // __webpack_public_path__\n  /******/__webpack_require__.p = \"/\";\n\n  /******/ // on error function for async loading\n  /******/__webpack_require__.oe = function (err) {\n    console.error(err);throw err;\n  };\n\n  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE);\n  return f.default || f; // try to call default if defined to also support babel esmodule exports\n}\n\nvar moduleNameReqExp = '[\\\\.|\\\\-|\\\\+|\\\\w|\\/|@]+';\nvar dependencyRegExp = '\\\\(\\\\s*(\\/\\\\*.*?\\\\*\\/)?\\\\s*.*?(' + moduleNameReqExp + ').*?\\\\)'; // additional chars when output.pathinfo is true\n\n// http://stackoverflow.com/a/2593661/130442\nfunction quoteRegExp(str) {\n  return (str + '').replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&');\n}\n\nfunction isNumeric(n) {\n  return !isNaN(1 * n); // 1 * n converts integers, integers as string (\"123\"), 1e3 and \"1e3\" to integers and strings to NaN\n}\n\nfunction getModuleDependencies(sources, module, queueName) {\n  var retval = {};\n  retval[queueName] = [];\n\n  var fnString = module.toString();\n  var wrapperSignature = fnString.match(/^function\\s?\\w*\\(\\w+,\\s*\\w+,\\s*(\\w+)\\)/);\n  if (!wrapperSignature) return retval;\n  var webpackRequireName = wrapperSignature[1];\n\n  // main bundle deps\n  var re = new RegExp('(\\\\\\\\n|\\\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g');\n  var match;\n  while (match = re.exec(fnString)) {\n    if (match[3] === 'dll-reference') continue;\n    retval[queueName].push(match[3]);\n  }\n\n  // dll deps\n  re = new RegExp('\\\\(' + quoteRegExp(webpackRequireName) + '\\\\(\"(dll-reference\\\\s(' + moduleNameReqExp + '))\"\\\\)\\\\)' + dependencyRegExp, 'g');\n  while (match = re.exec(fnString)) {\n    if (!sources[match[2]]) {\n      retval[queueName].push(match[1]);\n      sources[match[2]] = __webpack_require__(match[1]).m;\n    }\n    retval[match[2]] = retval[match[2]] || [];\n    retval[match[2]].push(match[4]);\n  }\n\n  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3\n  var keys = Object.keys(retval);\n  for (var i = 0; i < keys.length; i++) {\n    for (var j = 0; j < retval[keys[i]].length; j++) {\n      if (isNumeric(retval[keys[i]][j])) {\n        retval[keys[i]][j] = 1 * retval[keys[i]][j];\n      }\n    }\n  }\n\n  return retval;\n}\n\nfunction hasValuesInQueues(queues) {\n  var keys = Object.keys(queues);\n  return keys.reduce(function (hasValues, key) {\n    return hasValues || queues[key].length > 0;\n  }, false);\n}\n\nfunction getRequiredModules(sources, moduleId) {\n  var modulesQueue = {\n    main: [moduleId]\n  };\n  var requiredModules = {\n    main: []\n  };\n  var seenModules = {\n    main: {}\n  };\n\n  while (hasValuesInQueues(modulesQueue)) {\n    var queues = Object.keys(modulesQueue);\n    for (var i = 0; i < queues.length; i++) {\n      var queueName = queues[i];\n      var queue = modulesQueue[queueName];\n      var moduleToCheck = queue.pop();\n      seenModules[queueName] = seenModules[queueName] || {};\n      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue;\n      seenModules[queueName][moduleToCheck] = true;\n      requiredModules[queueName] = requiredModules[queueName] || [];\n      requiredModules[queueName].push(moduleToCheck);\n      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName);\n      var newModulesKeys = Object.keys(newModules);\n      for (var j = 0; j < newModulesKeys.length; j++) {\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || [];\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]]);\n      }\n    }\n  }\n\n  return requiredModules;\n}\n\nmodule.exports = function (moduleId, options) {\n  options = options || {};\n  var sources = {\n    main: __webpack_require__.m\n  };\n\n  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId);\n\n  var src = '';\n\n  Object.keys(requiredModules).filter(function (m) {\n    return m !== 'main';\n  }).forEach(function (module) {\n    var entryModule = 0;\n    while (requiredModules[module][entryModule]) {\n      entryModule++;\n    }\n    requiredModules[module].push(entryModule);\n    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })';\n    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) {\n      return '' + JSON.stringify(id) + ': ' + sources[module][id].toString();\n    }).join(',') + '});\\n';\n  });\n\n  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) {\n    return '' + JSON.stringify(id) + ': ' + sources.main[id].toString();\n  }).join(',') + '}))(self);';\n\n  var blob = new window.Blob([src], { type: 'text/javascript' });\n  if (options.bare) {\n    return blob;\n  }\n\n  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\n  var workerUrl = URL.createObjectURL(blob);\n  var worker = new window.Worker(workerUrl);\n  worker.objectURL = workerUrl;\n\n  return worker;\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/node_modules/webworkify-webpack/index.js?")},"../xgplayer-utils/src/constants/events.js":
/*!*************************************************!*\
      !*** ../xgplayer-utils/src/constants/events.js ***!
      \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst LOADER_EVENTS = {\n  LADER_START: 'LOADER_START',\n  LOADER_DATALOADED: 'LOADER_DATALOADED',\n  LOADER_COMPLETE: 'LOADER_COMPLETE',\n  LOADER_ERROR: 'LOADER_ERROR'\n};\n\nconst DEMUX_EVENTS = {\n  DEMUX_START: 'DEMUX_START',\n  DEMUX_COMPLETE: 'DEMUX_COMPLETE',\n  DEMUX_ERROR: 'DEMUX_ERROR',\n  METADATA_PARSED: 'METADATA_PARSED',\n  VIDEO_METADATA_CHANGE: 'VIDEO_METADATA_CHANGE',\n  AUDIO_METADATA_CHANGE: 'AUDIO_METADATA_CHANGE',\n  MEDIA_INFO: 'MEDIA_INFO'\n};\n\nconst REMUX_EVENTS = {\n  REMUX_METADATA: 'REMUX_METADATA',\n  REMUX_MEDIA: 'REMUX_MEDIA',\n  MEDIA_SEGMENT: 'MEDIA_SEGMENT',\n  REMUX_ERROR: 'REMUX_ERROR',\n  INIT_SEGMENT: 'INIT_SEGMENT',\n  DETECT_CHANGE_STREAM: 'DETECT_CHANGE_STREAM'\n};\n\nconst MSE_EVENTS = {\n  SOURCE_UPDATE_END: 'SOURCE_UPDATE_END'\n\n  // hls专有events\n};const HLS_EVENTS = {\n  RETRY_TIME_EXCEEDED: 'RETRY_TIME_EXCEEDED'\n};\n\nconst CRYTO_EVENTS = {\n  START_DECRYPT: 'START_DECRYPT',\n  DECRYPTED: 'DECRYPTED'\n};\nconst ALLEVENTS = Object.assign({}, LOADER_EVENTS, DEMUX_EVENTS, REMUX_EVENTS, MSE_EVENTS, HLS_EVENTS);\n\nconst FlvAllowedEvents = [];\nconst HlsAllowedEvents = [];\n\nfor (let key in ALLEVENTS) {\n  if (ALLEVENTS.hasOwnProperty(key)) {\n    FlvAllowedEvents.push(ALLEVENTS[key]);\n  }\n}\n\nfor (let key in ALLEVENTS) {\n  if (ALLEVENTS.hasOwnProperty(key)) {\n    HlsAllowedEvents.push(ALLEVENTS[key]);\n  }\n}\n\nexports.default = {\n  ALLEVENTS,\n  HLS_EVENTS,\n  REMUX_EVENTS,\n  DEMUX_EVENTS,\n  MSE_EVENTS,\n  LOADER_EVENTS,\n  FlvAllowedEvents,\n  HlsAllowedEvents,\n  CRYTO_EVENTS\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/constants/events.js?")},"../xgplayer-utils/src/constants/worker-commands.js":
/*!**********************************************************!*\
      !*** ../xgplayer-utils/src/constants/worker-commands.js ***!
      \**********************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst CONTEXT_COMOMANDS = exports.CONTEXT_COMOMANDS = {\n  ON: 'on',\n  ONCE: 'once',\n  OFF: 'off',\n  EMIT: 'emit',\n  DESTROY: 'destroy'\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/constants/worker-commands.js?")},"../xgplayer-utils/src/context.js":
/*!****************************************!*\
      !*** ../xgplayer-utils/src/context.js ***!
      \****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _mediaInfo = __webpack_require__(/*! ./models/media-info */ "../xgplayer-utils/src/models/media-info.js");\n\nvar _mediaInfo2 = _interopRequireDefault(_mediaInfo);\n\nvar _events = __webpack_require__(/*! events */ "../../node_modules/events/events.js");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst DIRECT_EMIT_FLAG = \'__TO__\';\n\nclass Context {\n  constructor(allowedEvents = []) {\n    this._emitter = new _events.EventEmitter();\n    this._instanceMap = {}; // 所有的解码流程实例\n    this._clsMap = {}; // 构造函数的map\n    this._inited = false;\n    this.mediaInfo = new _mediaInfo2.default();\n    this.allowedEvents = allowedEvents;\n    this._hooks = {}; // 注册在事件前/后的钩子，例如 before(\'DEMUX_COMPLETE\')\n  }\n\n  /**\n   * 从上下文中获取解码流程实例，如果没有实例，构造一个\n   * @param tag\n   * @param args\n   * @returns {*}\n   */\n  getInstance(tag) {\n    const instance = this._instanceMap[tag];\n    if (instance) {\n      return instance;\n    } else {\n      // throw new Error(`${tag}实例尚未初始化`)\n      return null;\n    }\n  }\n\n  /**\n   * 初始化具体实例\n   * @param tag\n   * @param args\n   */\n  initInstance(tag, ...args) {\n    if (this._clsMap[tag]) {\n      const newInstance = new this._clsMap[tag](...args);\n      this._instanceMap[tag] = newInstance;\n      if (newInstance.init) {\n        newInstance.init(); // TODO: lifecircle\n      }\n      return newInstance;\n    } else {\n      throw new Error(`${tag}未在context中注册`);\n    }\n  }\n\n  /**\n   * 避免大量的initInstance调用，初始化所有的组件\n   * @param config\n   */\n  init(config) {\n    if (this._inited) {\n      return;\n    }\n    for (let tag in this._clsMap) {\n      // if not inited, init an instance\n      if (this._clsMap.hasOwnProperty(tag) && !this._instanceMap[tag]) {\n        this.initInstance(tag, config);\n      }\n    }\n    this._inited = true;\n  }\n\n  /**\n   * 注册一个上下文流程，提供安全的事件发送机制\n   * @param tag\n   * @param cls\n   */\n  registry(tag, cls) {\n    const emitter = this._emitter;\n    const checkMessageName = this._isMessageNameValid.bind(this);\n    const self = this;\n    const enhanced = class extends cls {\n      constructor(...args) {\n        super(...args);\n        this.listeners = {};\n        this.onceListeners = {};\n        this.TAG = tag;\n        this._context = self;\n      }\n\n      on(messageName, callback) {\n        checkMessageName(messageName);\n\n        if (this.listeners[messageName]) {\n          this.listeners[messageName].push(callback);\n        } else {\n          this.listeners[messageName] = [callback];\n        }\n\n        emitter.on(`${messageName}${DIRECT_EMIT_FLAG}${tag}`, callback); // 建立定向通信监听\n        return emitter.on(messageName, callback);\n      }\n\n      /**\n       * 在某个事件触发前执行\n       * @param messageName\n       * @param callback\n       */\n      before(messageName, callback) {\n        checkMessageName(messageName);\n        if (self._hooks[messageName]) {\n          self._hooks[messageName].push(callback);\n        } else {\n          self._hooks[messageName] = [callback];\n        }\n      }\n\n      once(messageName, callback) {\n        checkMessageName(messageName);\n\n        if (this.onceListeners[messageName]) {\n          this.onceListeners[messageName].push(callback);\n        } else {\n          this.onceListeners[messageName] = [callback];\n        }\n\n        emitter.once(`${messageName}${DIRECT_EMIT_FLAG}${tag}`, callback);\n        return emitter.once(messageName, callback);\n      }\n\n      emit(messageName, ...args) {\n        checkMessageName(messageName);\n\n        const beforeList = self._hooks ? self._hooks[messageName] : null;\n\n        if (beforeList) {\n          for (let i = 0, len = beforeList.length; i < len; i++) {\n            const callback = beforeList[i];\n            callback();\n          }\n        }\n        return emitter.emit(messageName, ...args);\n      }\n\n      /**\n       * 定向发送给某个组件单例的消息\n       * @param messageName\n       * @param args\n       */\n      emitTo(tag, messageName, ...args) {\n        checkMessageName(messageName);\n\n        return emitter.emit(`${messageName}${DIRECT_EMIT_FLAG}${tag}`, ...args);\n      }\n\n      off(messageName, callback) {\n        checkMessageName(messageName);\n        return emitter.off(messageName, callback);\n      }\n\n      removeListeners() {\n        const hasOwn = Object.prototype.hasOwnProperty.bind(this.listeners);\n\n        for (let messageName in this.listeners) {\n          if (hasOwn(messageName)) {\n            const callbacks = this.listeners[messageName] || [];\n            for (let i = 0; i < callbacks.length; i++) {\n              const callback = callbacks[i];\n              emitter.off(messageName, callback);\n              emitter.off(`${messageName}${DIRECT_EMIT_FLAG}${tag}`, callback);\n            }\n          }\n        }\n\n        for (let messageName in this.onceListeners) {\n          if (hasOwn(messageName)) {\n            const callbacks = this.onceListeners[messageName] || [];\n            for (let i = 0; i < callbacks.length; i++) {\n              const callback = callbacks[i];\n              emitter.off(messageName, callback);\n              emitter.off(`${messageName}${DIRECT_EMIT_FLAG}${tag}`, callback);\n            }\n          }\n        }\n      }\n\n      /**\n       * 在组件销毁时，默认将它注册的事件全部卸载，确保不会造成内存泄漏\n       */\n      destroy() {\n        // step1 unlisten events\n        this.removeListeners();\n        this.listeners = {};\n\n        // step2 release from context\n        delete self._instanceMap[tag];\n        if (super.destroy) {\n          return super.destroy();\n        }\n      }\n    };\n    this._clsMap[tag] = enhanced;\n\n    /**\n     * get instance immediately\n     * e.g const instance = context.registry(tag, Cls)(config)\n     * */\n    return (...args) => {\n      return this.initInstance(tag, ...args);\n    };\n  }\n\n  /**\n   * 对存在的实例进行\n   */\n  destroyInstances() {\n    Object.keys(this._instanceMap).forEach(tag => {\n      if (this._instanceMap[tag].destroy) {\n        this._instanceMap[tag].destroy();\n      }\n    });\n  }\n\n  /**\n   * 编解码流程无需关注事件的解绑\n   */\n  destroy() {\n    this._emitter = null;\n    this.allowedEvents = [];\n    this._clsMap = null;\n    this._context = null;\n    this._hooks = null;\n    this.destroyInstances();\n  }\n\n  /**\n   * 对信道进行收拢\n   * @param messageName\n   * @private\n   */\n  _isMessageNameValid(messageName) {\n    if (!this.allowedEvents.indexOf(messageName) < 0) {\n      throw new Error(`unregistered message name: ${messageName}`);\n    }\n  }\n}\n\nexports.default = Context;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/context.js?')},"../xgplayer-utils/src/crypto/index.js":
/*!*********************************************!*\
      !*** ../xgplayer-utils/src/crypto/index.js ***!
      \*********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _events = __webpack_require__(/*! ../constants/events */ \"../xgplayer-utils/src/constants/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst CRYTO_EVENTS = _events2.default.CRYTO_EVENTS;\nclass Crypto {\n    constructor(config) {\n        this.inputBuffer = config.inputbuffer;\n        this.outputBuffer = config.outputbuffer;\n        this.key = config.key;\n        this.iv = config.iv;\n        this.method = config.method;\n\n        this.crypto = window.crypto || window.msCrypto;\n    }\n\n    init() {\n        this.on(CRYTO_EVENTS.START_DECRYPT, this.decript.bind(this));\n    }\n\n    decript() {\n        if (!this.aeskey) {\n            let sbkey = this.crypto.subtle.importKey('raw', this.key.buffer, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);\n            sbkey.then(key => {\n                this.aeskey = key;\n                this.decriptData();\n            });\n        } else {\n            this.decriptData();\n        }\n    }\n\n    decriptData() {\n        let inputbuffer = this._context.getInstance(this.inputBuffer);\n        let outputbuffer = this._context.getInstance(this.outputBuffer);\n        let data = inputbuffer.shift();\n        if (data) {\n            this.crypto.subtle.decrypt({ name: 'AES-CBC', iv: this.iv.buffer }, this.aeskey, data).then(res => {\n                outputbuffer.push(new Uint8Array(res));\n                this.emit(CRYTO_EVENTS.DECRYPTED);\n                this.decriptData(data);\n            });\n        }\n    }\n}\nexports.default = Crypto;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/crypto/index.js?")},"../xgplayer-utils/src/env/isle.js":
/*!*****************************************!*\
      !*** ../xgplayer-utils/src/env/isle.js ***!
      \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nconst le = function () {\n  const buf = new ArrayBuffer(2);\n  new DataView(buf).setInt16(0, 256, true); // little-endian write\n  return new Int16Array(buf)[0] === 256; // platform-spec read, if equal then LE\n}();\n\nexports.default = le;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/env/isle.js?')},"../xgplayer-utils/src/env/sniffer.js":
/*!********************************************!*\
      !*** ../xgplayer-utils/src/env/sniffer.js ***!
      \********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst le = function () {\n  const buf = new ArrayBuffer(2);\n  new DataView(buf).setInt16(0, 256, true); // little-endian write\n  return new Int16Array(buf)[0] === 256; // platform-spec read, if equal then LE\n}();\n\nconst sniffer = {\n  get device() {\n    let r = sniffer.os;\n    return r.isPc ? 'pc' : r.isTablet ? 'tablet' : 'mobile';\n  },\n  get browser() {\n    let ua = navigator.userAgent.toLowerCase();\n    let reg = {\n      ie: /rv:([\\d.]+)\\) like gecko/,\n      firfox: /firefox\\/([\\d.]+)/,\n      chrome: /chrome\\/([\\d.]+)/,\n      opera: /opera.([\\d.]+)/,\n      safari: /version\\/([\\d.]+).*safari/\n    };\n    return [].concat(Object.keys(reg).filter(key => reg[key].test(ua)))[0];\n  },\n  get os() {\n    let ua = navigator.userAgent;\n    let isWindowsPhone = /(?:Windows Phone)/.test(ua);\n    let isSymbian = /(?:SymbianOS)/.test(ua) || isWindowsPhone;\n    let isAndroid = /(?:Android)/.test(ua);\n    let isFireFox = /(?:Firefox)/.test(ua);\n    let isTablet = /(?:iPad|PlayBook)/.test(ua) || isAndroid && !/(?:Mobile)/.test(ua) || isFireFox && /(?:Tablet)/.test(ua);\n    let isPhone = /(?:iPhone)/.test(ua) && !isTablet;\n    let isPc = !isPhone && !isAndroid && !isSymbian;\n    return {\n      isTablet,\n      isPhone,\n      isAndroid,\n      isPc,\n      isSymbian,\n      isWindowsPhone,\n      isFireFox\n    };\n  },\n\n  get isLe() {\n    return le;\n  }\n};\n\nexports.default = sniffer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/env/sniffer.js?")},"../xgplayer-utils/src/env/utf8.js":
/*!*****************************************!*\
      !*** ../xgplayer-utils/src/env/utf8.js ***!
      \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass UTF8 {\n  static decode(uint8array) {\n    const out = [];\n    const input = uint8array;\n    let i = 0;\n    const length = uint8array.length;\n\n    while (i < length) {\n      if (input[i] < 0x80) {\n        out.push(String.fromCharCode(input[i]));\n        ++i;\n        continue;\n      } else if (input[i] < 0xC0) {\n        // fallthrough\n      } else if (input[i] < 0xE0) {\n        if (UTF8._checkContinuation(input, i, 1)) {\n          const ucs4 = (input[i] & 0x1F) << 6 | input[i + 1] & 0x3F;\n          if (ucs4 >= 0x80) {\n            out.push(String.fromCharCode(ucs4 & 0xFFFF));\n            i += 2;\n            continue;\n          }\n        }\n      } else if (input[i] < 0xF0) {\n        if (UTF8._checkContinuation(input, i, 2)) {\n          const ucs4 = (input[i] & 0xF) << 12 | (input[i + 1] & 0x3F) << 6 | input[i + 2] & 0x3F;\n          if (ucs4 >= 0x800 && (ucs4 & 0xF800) !== 0xD800) {\n            out.push(String.fromCharCode(ucs4 & 0xFFFF));\n            i += 3;\n            continue;\n          }\n        }\n      } else if (input[i] < 0xF8) {\n        if (UTF8._checkContinuation(input, i, 3)) {\n          let ucs4 = (input[i] & 0x7) << 18 | (input[i + 1] & 0x3F) << 12 | (input[i + 2] & 0x3F) << 6 | input[i + 3] & 0x3F;\n          if (ucs4 > 0x10000 && ucs4 < 0x110000) {\n            ucs4 -= 0x10000;\n            out.push(String.fromCharCode(ucs4 >>> 10 | 0xD800));\n            out.push(String.fromCharCode(ucs4 & 0x3FF | 0xDC00));\n            i += 4;\n            continue;\n          }\n        }\n      }\n      out.push(String.fromCharCode(0xFFFD));\n      ++i;\n    }\n\n    return out.join('');\n  }\n\n  static _checkContinuation(uint8array, start, checkLength) {\n    let array = uint8array;\n    if (start + checkLength < array.length) {\n      while (checkLength--) {\n        if ((array[++start] & 0xC0) !== 0x80) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n\nexports.default = UTF8;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/env/utf8.js?")},"../xgplayer-utils/src/mobile/audio-context.js":
/*!*****************************************************!*\
      !*** ../xgplayer-utils/src/mobile/audio-context.js ***!
      \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _events = __webpack_require__(/*! events */ "../../node_modules/events/events.js");\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass AudioCtx extends _events2.default {\n  constructor(config) {\n    super();\n    this.config = Object.assign({}, config);\n    let AudioContext = window.AudioContext || window.webkitAudioContext;\n    this.context = new AudioContext();\n    this.gainNode = this.context.createGain();\n    this.gainNode.connect(this.context.destination);\n    this.meta = undefined;\n    this.samples = [];\n    this.preloadTime = this.config.preloadTime || 3;\n    this.duration = 0;\n\n    this._currentBuffer = undefined;\n    this._nextBuffer = undefined;\n    this._lastpts = undefined;\n    this._preDecode = [];\n    this._currentTime = 0;\n    this._decoding = false;\n    // 记录外部传输的状态\n    this._played = false;\n  }\n\n  get currentTime() {\n    return this._currentTime;\n  }\n\n  decodeAudio(audioTrack) {\n    let { samples } = audioTrack;\n    let data = samples;\n    audioTrack.samples = [];\n    this.setAudioData(data);\n  }\n  setAudioData(data) {\n    for (let i = 0; i < data.length; i++) {\n      data[i].pts = data[i].pts === undefined ? data[i].dts : data[i].pts;\n      this._preDecode.push(data[i]);\n    }\n    if (this._preDecode.length > 0) {\n      if (this._lastpts === undefined) {\n        this._lastpts = this._preDecode[0].pts;\n      }\n      if ((this._preDecode[this._preDecode.length - 1].pts - this._lastpts) / 1000 > this.preloadTime) {\n        this.decodeAAC();\n      }\n    }\n  }\n\n  decodeAAC() {\n    if (this._decoding) {\n      return;\n    }\n    this._decoding = true;\n    let data = this._preDecode;\n    let samples = [];\n    let _this = this;\n    let sample = data.shift();\n    while (sample) {\n      let sampleData = AudioCtx.getAACData(this.meta, sample);\n      samples.push(sampleData);\n      this._lastpts = sample.pts;\n      sample = data.shift();\n    }\n    let buffer = AudioCtx.combileData(samples);\n    try {\n      this.context.decodeAudioData(buffer.buffer, function (buffer) {\n        let audioSource = _this.context.createBufferSource();\n        audioSource.buffer = buffer;\n        audioSource.onended = _this.onSourceEnded.bind(_this);\n        _this.samples.push({\n          time: _this.duration,\n          duration: buffer.duration,\n          data: audioSource\n        });\n\n        _this.duration += buffer.duration;\n\n        if (!_this._currentBuffer) {\n          _this._currentBuffer = _this.getTimeBuffer(_this.currentTime);\n\n          if (_this._played) {\n            _this.play();\n          }\n        }\n\n        if (!_this._nextBuffer && _this._currentBuffer) {\n          _this._nextBuffer = _this.getTimeBuffer(_this.currentTime + _this._currentBuffer.duration);\n        }\n        _this._decoding = false;\n\n        if ((_this._preDecode.length > 0 && _this._preDecode[_this._preDecode.length - 1].pts - _this._lastpts) / 1000 >= _this.preloadTime) {\n          _this.decodeAAC();\n        }\n      });\n    } catch (err) {\n      console.error(err);\n    }\n  }\n\n  onSourceEnded() {\n    if (!this._nextBuffer || !this._played) {\n      return;\n    }\n    let audioSource = this._nextBuffer.data;\n    audioSource.start();\n    audioSource.connect(this.gainNode);\n    this._currentBuffer = this._nextBuffer;\n    this._currentTime = this._currentBuffer.time;\n    this._nextBuffer = this.getTimeBuffer(this.currentTime);\n    if (this._currentBuffer) {\n      this._nextBuffer = this.getTimeBuffer(this.currentTime + this._currentBuffer.duration);\n    }\n    this.emit(\'AUDIO_SOURCE_END\');\n  }\n\n  play() {\n    this._played = true;\n    if (!this._currentBuffer) {\n      return;\n    }\n    let audioSource = this._currentBuffer.data;\n    audioSource.connect(this.gainNode);\n    audioSource.start();\n  }\n\n  getTimeBuffer(time) {\n    let ret;\n    for (let i = 0; i < this.samples.length; i++) {\n      let sample = this.samples[i];\n      if (sample.time <= time && sample.time + sample.duration > time) {\n        ret = sample;\n        break;\n      }\n    }\n    return ret;\n  }\n\n  setAudioMetaData(meta) {\n    this.meta = meta;\n  }\n\n  static getAACData(meta, sample) {\n    let buffer = new Uint8Array(sample.data.byteLength + 7);\n    let adts = AudioCtx.getAdts(meta, sample.data);\n    buffer.set(adts);\n    buffer.set(sample.data, 7);\n    return buffer;\n  }\n\n  static combileData(samples) {\n    // get length\n    let length = 0;\n    for (let i = 0, k = samples.length; i < k; i++) {\n      length += samples[i].byteLength;\n    }\n\n    let ret = new Uint8Array(length);\n    let offset = 0;\n    // combile data;\n    for (let i = 0, k = samples.length; i < k; i++) {\n      ret.set(samples[i], offset);\n      offset += samples[i].byteLength;\n    }\n    return ret;\n  }\n\n  static getAdts(meta, data) {\n    let adts = new Uint8Array(7);\n\n    // 设置同步位 0xfff 12bit\n    adts[0] = 0xff;\n    adts[1] = 0xf0;\n\n    // Object data (没什么人用MPEG-2了，HLS和FLV也全是MPEG-4，这里直接0)  1bit\n    // Level always 00 2bit\n    // CRC always 1 1bit\n    adts[1] = adts[1] | 0x01;\n\n    // profile 2bit\n    adts[2] = 0xc0 & meta.objectType - 1 << 6;\n\n    //sampleFrequencyIndex\n    adts[2] = adts[2] | 0x3c & meta.sampleRateIndex << 2;\n\n    //private bit 0 1bit\n    // chanel configuration 3bit\n    adts[2] = adts[2] | 0x01 & meta.channelCount >> 2;\n    adts[3] = 0xc0 & meta.channelCount << 6;\n\n    // original_copy: 0 1bit\n    // home: 0 1bit\n\n    // adts_variable_header()\n    // copyrighted_id_bit 0 1bit\n    // copyrighted_id_start 0 1bit\n\n    // aac_frame_length 13bit;\n    let aacframelength = data.byteLength + 7;\n\n    adts[3] = adts[3] | 0x03 & aacframelength >> 11;\n    adts[4] = 0xff & aacframelength >> 3;\n    adts[5] = 0xe0 & aacframelength << 5;\n\n    // adts_buffer_fullness 0x7ff 11bit\n    adts[5] = adts[5] | 0x1f;\n    adts[6] = 0xfc;\n\n    // number_of_raw_data_blocks_in_frame 0 2bit;\n    return adts;\n  }\n}\n\nexports.default = AudioCtx;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/audio-context.js?')},"../xgplayer-utils/src/mobile/mobile-video.js":
/*!****************************************************!*\
      !*** ../xgplayer-utils/src/mobile/mobile-video.js ***!
      \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nvar _videoContext = __webpack_require__(/*! ./video-context */ \"../xgplayer-utils/src/mobile/video-context.js\");\n\nvar _videoContext2 = _interopRequireDefault(_videoContext);\n\nvar _audioContext = __webpack_require__(/*! ./audio-context */ \"../xgplayer-utils/src/mobile/audio-context.js\");\n\nvar _audioContext2 = _interopRequireDefault(_audioContext);\n\nvar _ticker = __webpack_require__(/*! ./ticker */ \"../xgplayer-utils/src/mobile/ticker.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * 音画同步调和器\n */\nclass AVReconciler {\n  constructor(props) {\n    this.aCtx = props.aCtx;\n    this.vCtx = props.vCtx;\n    this.video = props.video;\n    this.timeoutId = null;\n    this.start = null;\n  }\n\n  doReconcile() {\n    const vCurTime = (this.video.currentTime || 0) * 1000;\n    const aCurTime = (this.aCtx.currentTime || 0) * 1000;\n\n    const gap = vCurTime - aCurTime;\n    if (this.timeoutId) {\n      return;\n    }\n    if (gap > 200) {\n      // audio delayed for more than 100ms\n      console.log(gap);\n      this.video.start += gap;\n      this.vCtx.pause();\n      this.timeoutId = setTimeout(() => {\n        this.vCtx.play();\n        this.timeoutId = null;\n      }, gap);\n    } else if (gap < -120) {\n      this.vCtx.currentTime = this.vCtx.currentTime + Math.abs(gap);\n    }\n  }\n\n  destroy() {\n    this.aCtx = null;\n    this.vCtx = null;\n  }\n}\n\n// eslint-disable-next-line no-undef\nclass MobileVideo extends HTMLElement {\n  constructor(config) {\n    super();\n    let _this = this;\n    this.vCtx = new _videoContext2.default();\n    this.aCtx = new _audioContext2.default(config);\n    this.ticker = new ((0, _ticker.getTicker)())();\n    this.historyTime = 0;\n    this.reconciler = new AVReconciler({\n      vCtx: this.vCtx,\n      aCtx: this.aCtx,\n      video: this\n    });\n    this.handleAudioSourceEnd = this.handleAudioSourceEnd.bind(this);\n    this.init();\n  }\n\n  init() {\n    this.vCtx.oncanplay = () => {\n      this.appendChild(this.vCtx.canvas);\n      // eslint-disable-next-line no-undef\n      this.dispatchEvent(new Event('canplay'));\n    };\n\n    this.ticker.start(() => {\n      //\n      if (!this.start) {\n        this.start = Date.now();\n      }\n      this._currentTime = Date.now() - this.start;\n      this.vCtx._onTimer(this._currentTime);\n    });\n\n    this.aCtx.on('AUDIO_SOURCE_END', this.handleAudioSourceEnd);\n  }\n\n  handleAudioSourceEnd() {\n    console.log(this.aCtx.currentTime);\n    this.reconciler.doReconcile();\n  }\n\n  _cleanBuffer() {\n    this.vCtx.cleanBuffer();\n  }\n\n  destroy() {\n    this.reconciler.destroy();\n  }\n\n  onDemuxComplete(videoTrack, audioTrack) {\n    this.aCtx.decodeAudio(audioTrack);\n    this.vCtx.decodeVideo(videoTrack);\n  }\n\n  setAudioMeta(meta) {\n    this.aCtx.setAudioMetaData(meta);\n  }\n\n  setVideoMeta(meta) {\n    this.vCtx.setVideoMetaData(meta);\n  }\n\n  get currentTime() {\n    return this._currentTime / 1000;\n  }\n\n  play() {\n    // if (!this.vCtx.)\n    this.vCtx.play();\n    this.aCtx.play();\n  }\n}\n// eslint-disable-next-line no-undef\ncustomElements.define('mobile-video', MobileVideo);\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/mobile-video.js?")},"../xgplayer-utils/src/mobile/sourcebuffer.js":
/*!****************************************************!*\
      !*** ../xgplayer-utils/src/mobile/sourcebuffer.js ***!
      \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass SourceBuffer {\n  constructor(config) {\n    this.config = Object.assign({}, config);\n    this.type = this.config.type;\n    this.buffer = [];\n    this.currentGop = undefined;\n    this._lastGet = undefined;\n  }\n\n  push(frame) {\n    if (this.type === 'video') {\n      if (frame.isKeyframe) {\n        let currentGop = {\n          samples: [],\n          start: frame.dts,\n          end: frame.dts,\n          nextGop: undefined\n        };\n        if (this.currentGop) {\n          this.currentGop.nextGop = currentGop;\n        }\n        this.currentGop = currentGop;\n        this.buffer.push(this.currentGop);\n      }\n\n      if (this.currentGop) {\n        this.currentGop.samples.push(frame);\n\n        if (frame.dts < this.currentGop.start) {\n          this.currentGop.start = frame.dts;\n        }\n\n        if (frame.dts > this.currentGop.end) {\n          this.currentGop.end = frame.dts;\n        }\n      }\n    }\n  }\n\n  get(time) {\n    if (this.type === 'video') {\n      if (this.buffer.length < 1) {\n        return;\n      }\n\n      if (time === undefined) {\n        let sample = this._getNext();\n        return sample;\n      }\n    }\n  }\n\n  _getNext() {\n    if (!this._lastGet) {\n      let gop = this.buffer[0];\n      if (gop.samples.length < 1) {\n        return;\n      }\n\n      this._lastGet = {\n        gop,\n        index: 0\n      };\n      return gop.samples[0];\n    } else {\n      let gop = this._lastGet.gop;\n      let sample = gop.samples[this._lastGet.index + 1];\n      if (sample) {\n        this._lastGet.index = this._lastGet.index + 1;\n        return sample;\n      } else {\n        gop = gop.nextGop;\n        if (!gop || gop.samples.length < 1) {\n          return;\n        }\n        sample = gop.samples[0];\n        this._lastGet = {\n          gop,\n          index: 0\n        };\n        return sample;\n      }\n    }\n  }\n\n  remove(start, end) {\n    if (this.buffer.length < 0) {\n      return;\n    }\n\n    let i = 0;\n    let gop = this.buffer[0];\n    while (gop) {\n      if (gop.end < end && gop.start >= start) {\n        delete this.buffer[i];\n        gop = this.buffer[i];\n      } else {\n        i += 1;\n        gop = this.buffer[i];\n      }\n    }\n  }\n}\n\nexports.default = SourceBuffer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/sourcebuffer.js?")},"../xgplayer-utils/src/mobile/ticker.js":
/*!**********************************************!*\
      !*** ../xgplayer-utils/src/mobile/ticker.js ***!
      \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n/**\n * @author fuyuhao@bytedance.com\n */\n\nclass Ticker {\n  constructor(options) {\n    this.options = Object.assign({}, options || {}, {\n      interval: 16\n    });\n\n    this.callbacks = [];\n  }\n\n  start(...callbacks) {\n    this.callbacks = callbacks;\n  }\n\n  onTick() {\n    for (let i = 0, len = this.callbacks.length; i < len; i++) {\n      const callback = this.callbacks[i];\n      callback();\n    }\n  }\n\n  setInterval(interval) {\n    this.options.interval = interval;\n    return this;\n  }\n}\n\n/**\n * ticker use requestAnimationFrame\n */\nclass RafTicker extends Ticker {\n  constructor(props) {\n    super(props);\n    this.prev = null;\n    this.timerId = null;\n    this._subTimerId = null;\n\n    this._tickFunc = RafTicker.getTickFunc();\n    this.tick = this.tick.bind(this);\n  }\n\n  start(...callbacks) {\n    super.start(...callbacks);\n    this.tick();\n  }\n\n  tick(timestamp) {\n    this.nextTick();\n    this.onTick();\n  }\n\n  nextTick() {\n    const { _tickFunc } = this;\n    this.timerId = _tickFunc(this.tick);\n  }\n\n  stop() {\n    if (this.timerId) {\n      const cancelFunc = RafTicker.getCancelFunc();\n\n      cancelFunc(this.timerId);\n    }\n  }\n\n  static getTickFunc() {\n    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;\n  }\n\n  static getCancelFunc() {\n    return window.cancelAnimationFrame || window.webkitCancelAnimationFrame;\n  }\n\n  static isSupported() {\n    return RafTicker.getTickFunc() !== undefined;\n  }\n}\n\n/**\n * use setTimeout for browsers without raf support\n */\nclass TimeoutTicker extends Ticker {\n  constructor(config) {\n    super(config);\n    this.timeoutId = null;\n  }\n\n  start(...callbacks) {\n    super.nextTick(...callbacks);\n    this.timeoutId = window.setInterval(() => {\n      this.onTick();\n    }, this.options.interval || 16);\n  }\n\n  stop() {\n    if (this.timeoutId) {\n      window.clearInterval(this.timeoutId);\n    }\n  }\n\n}\n\n/**\n * 返回Ticker构造函数\n * @returns {Ticker}\n */\nconst getTicker = exports.getTicker = () => {\n  if (RafTicker.isSupported()) {\n    return RafTicker;\n  } else {\n    return TimeoutTicker;\n  }\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/ticker.js?')},"../xgplayer-utils/src/mobile/video-context.js":
/*!*****************************************************!*\
      !*** ../xgplayer-utils/src/mobile/video-context.js ***!
      \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _webworkifyWebpack = __webpack_require__(/*! webworkify-webpack */ \"../xgplayer-utils/node_modules/webworkify-webpack/index.js\");\n\nvar _webworkifyWebpack2 = _interopRequireDefault(_webworkifyWebpack);\n\nvar _stream = __webpack_require__(/*! ../write/stream */ \"../xgplayer-utils/src/write/stream.js\");\n\nvar _stream2 = _interopRequireDefault(_stream);\n\nvar _nalunit = __webpack_require__(/*! ../../../xgplayer-codec/src/h264/nalunit */ \"../xgplayer-codec/src/h264/nalunit/index.js\");\n\nvar _nalunit2 = _interopRequireDefault(_nalunit);\n\nvar _yuvCanvas = __webpack_require__(/*! ./yuv-canvas */ \"../xgplayer-utils/src/mobile/yuv-canvas.js\");\n\nvar _yuvCanvas2 = _interopRequireDefault(_yuvCanvas);\n\nvar _sourcebuffer = __webpack_require__(/*! ./sourcebuffer */ \"../xgplayer-utils/src/mobile/sourcebuffer.js\");\n\nvar _sourcebuffer2 = _interopRequireDefault(_sourcebuffer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass VideoCanvas {\n  constructor(config) {\n    this.config = Object.assign({}, config);\n    this.canvas = this.config.canvas ? this.config.canvas : document.createElement('canvas');\n    this.source = new _sourcebuffer2.default({ type: 'video' });\n    this.preloadTime = this.config.preloadTime || 3;\n    this.oncanplay = undefined;\n    this.onFirstFrame = undefined;\n    this.meta = undefined;\n    this.readyStatus = 0;\n    this.paused = true;\n    this.count = 0;\n    this.currentTime = 0;\n    this.lastPlayed = 0;\n\n    this._decoderInited = false;\n    this._avccpushed = false;\n    this._decodedFrames = {};\n    this._lastSampleDts = undefined;\n    this._baseDts = undefined;\n    this._lastRenderTime = null;\n    this.playFinish = null;\n  }\n\n  pause() {\n    this.paused = true;\n  }\n\n  initWasmWorker() {\n    let _this = this;\n    this.wasmworker = (0, _webworkifyWebpack2.default)(/*require.resolve*/(/*! ./worker.js */ \"../xgplayer-utils/src/mobile/worker.js\"));\n    this.wasmworker.postMessage({\n      msg: 'init',\n      meta: this.meta\n    });\n    this.wasmworker.addEventListener('message', msg => {\n      switch (msg.data.msg) {\n        case 'DECODER_READY':\n          _this._decoderInited = true;\n          break;\n        case 'DECODED':\n          this._onDecoded(msg.data);\n          break;\n      }\n    });\n  }\n\n  setVideoMetaData(meta) {\n    this.meta = meta;\n    if (!this._decoderInited) {\n      this.initWasmWorker();\n      return;\n    }\n    this._avccpushed = true;\n    let data = new Uint8Array(meta.sps.byteLength + 4);\n    data.set([0, 0, 0, 1]);\n    data.set(meta.sps, 4);\n    this.wasmworker.postMessage({\n      msg: 'decode',\n      data: data\n    });\n\n    data = new Uint8Array(meta.pps.byteLength + 4);\n    data.set([0, 0, 0, 1]);\n    data.set(meta.pps, 4);\n    this.wasmworker.postMessage({\n      msg: 'decode',\n      data: data\n    });\n\n    if (!this.yuvCanvas) {\n      let config = Object.assign({ meta, canvas: this.canvas }, this.config);\n      this.yuvCanvas = new _yuvCanvas2.default(config);\n    }\n    this.readyStatus = 1;\n  }\n\n  decodeVideo(videoTrack) {\n    if (!this._decoderInited) {\n      return;\n    }\n\n    if (!this._avccpushed) {\n      this.setVideoMetaData(this.meta);\n    }\n    let { samples } = videoTrack;\n    let sample = samples.shift();\n\n    while (sample) {\n      if (!this._baseDts) {\n        this._baseDts = sample.dts;\n      }\n      this.source.push(sample);\n      sample = samples.shift();\n    }\n\n    this._preload();\n  }\n\n  _preload() {\n    if (!this._lastSampleDts || this._lastSampleDts - this._baseDts < this.currentTime + this.preloadTime * 1000) {\n      let sample = this.source.get();\n      if (sample) {\n        this._lastSampleDts = sample.dts;\n        this._analyseNal(sample);\n      }\n\n      while (sample && this._lastSampleDts - this._baseDts < this.currentTime + this.preloadTime * 1000) {\n        sample = this.source.get();\n        if (sample) {\n          this._analyseNal(sample);\n          this._lastSampleDts = sample.dts;\n        }\n      }\n    }\n  }\n\n  _analyseNal(sample) {\n    let nals = _nalunit2.default.getAvccNals(new _stream2.default(sample.data.buffer));\n\n    let length = 0;\n    for (let i = 0; i < nals.length; i++) {\n      let nal = nals[i];\n      length += nal.body.byteLength + 4;\n    }\n    let offset = 0;\n    let data = new Uint8Array(length);\n    for (let i = 0; i < nals.length; i++) {\n      let nal = nals[i];\n      data.set([0, 0, 0, 1], offset);\n      offset += 4;\n      data.set(new Uint8Array(nal.body), offset);\n      offset += nal.body.byteLength;\n    }\n    this.wasmworker.postMessage({\n      msg: 'decode',\n      data: data,\n      info: {\n        dts: sample.dts,\n        pts: sample.pts ? sample.pts : sample.dts + sample.cts,\n        key: sample.isKeyframe\n      }\n    });\n  }\n\n  _onDecoded(data) {\n    let { dts } = data.info;\n    this._decodedFrames[dts] = data;\n  }\n\n  play() {\n    this.paused = false;\n    return new Promise(resolve => {\n      this.playFinish = resolve;\n    });\n  }\n\n  _onTimer(currentTime) {\n    if (this.paused) {\n      return;\n    }\n    if (this.meta) {\n      if (this.meta.frameRate && this.meta.frameRate.fixed && this.meta.frameRate.fps) {}\n      let frameTimes = Object.keys(this._decodedFrames);\n      if (frameTimes.length > 0) {\n        this.currentTime = currentTime;\n        let frameTime = -1;\n        let currentIdx = 0;\n        for (let i = 0; i < frameTimes.length && Number.parseInt(frameTimes[i]) - this._baseDts <= this.currentTime; i++) {\n          frameTime = Number.parseInt(frameTimes[i - 1]);\n          currentIdx = i;\n        }\n\n        let frame = this._decodedFrames[frameTime];\n        if (frame) {\n\n          if (this.oncanplay && this.readyStatus < 4) {\n            this.oncanplay();\n            this.readyStatus = 4;\n          }\n          this.yuvCanvas.render(frame.buffer, frame.width, frame.height, frame.yLinesize, frame.uvLinesize);\n\n          if (this.playFinish) {\n            this.playFinish();\n          }\n          for (let i = 0; i < currentIdx; i++) {\n            delete this._decodedFrames[i];\n          }\n        }\n      }\n    }\n    this._lastRenderTime = Date.now();\n  }\n\n  cleanBuffer() {\n    if (this.currentTime > 1) {\n      this.source.remove(0, this.currentTime - 1);\n    }\n  }\n}\nexports.default = VideoCanvas;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/video-context.js?")},"../xgplayer-utils/src/mobile/worker.js":
/*!**********************************************!*\
      !*** ../xgplayer-utils/src/mobile/worker.js ***!
      \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nconst MAX_STREAM_BUFFER_LENGTH = 1024 * 1024;\nvar Decoder = function (self) {\n  this.inited = false;\n  this.self = self;\n  this.meta = this.self.meta;\n  this.infolist = {};\n  self.par_broadwayOnBroadwayInited = this.broadwayOnBroadwayInited.bind(this);\n  self.par_broadwayOnPictureDecoded = this.broadwayOnPictureDecoded.bind(this);\n};\n\nDecoder.prototype.toU8Array = function (ptr, length) {\n  return this.self.HEAPU8.subarray(ptr, ptr + length);\n};\n\nDecoder.prototype.init = function () {\n  Module._broadwayInit();\n  this.streamBuffer = this.toU8Array(Module._broadwayCreateStream(MAX_STREAM_BUFFER_LENGTH), MAX_STREAM_BUFFER_LENGTH);\n};\n\nDecoder.prototype.broadwayOnPictureDecoded = function (offset, width, height, yLinesize, uvLinesize, infoid) {\n  let info = Object.assign({}, this.infolist[infoid]);\n  let yRowcount = height;\n  let uvRowcount = height / 2;\n  if (this.meta.chromaFormat === 444 || this.meta.chromaFormat === 422) {\n    uvRowcount = height;\n  }\n  let data = this.toU8Array(offset, yLinesize * yRowcount + 2 * (uvLinesize * uvRowcount));\n  this.infolist[infoid] = null;\n  let datetemp = new Uint8Array(data.length);\n  datetemp.set(data);\n  let buffer = datetemp.buffer;\n  this.self.postMessage({\n    msg: 'DECODED',\n    width,\n    height,\n    yLinesize,\n    uvLinesize,\n    info,\n    buffer\n  }, [buffer]);\n};\n\nDecoder.prototype.broadwayOnBroadwayInited = function () {\n  this.inited = true;\n  this.self.postMessage({ msg: 'DECODER_READY' });\n};\n\nDecoder.prototype.decode = function (data, info) {\n  let time = parseInt(new Date().getTime());\n  let infoid = time - Math.floor(time / 10e8) * 10e8;\n  this.infolist[infoid] = info;\n  this.streamBuffer.set(data);\n  Module._broadwayPlayStream(data.length, infoid);\n};\n\nvar decoder;\n\nfunction onPostRun() {\n  decoder = new Decoder(this);\n  decoder.init();\n}\n\nfunction init(meta) {\n  self.importScripts('https://sf1-vcloudcdn.pstatp.com/obj/ttfe/media/decoder/h264/decoder.js');\n  addOnPostRun(onPostRun.bind(self));\n}\n\nmodule.exports = function (self) {\n  self.addEventListener('message', function (e) {\n    var data = e.data;\n    if (!data.msg) {\n      self.postMessage({\n        msg: 'ERROR:invalid message'\n      });\n    } else {\n      switch (data.msg) {\n        case 'init':\n          console.log(data);\n          self.meta = data.meta;\n          init();\n          break;\n        case 'decode':\n          decoder.decode(data.data, data.info);\n          break;\n        default:\n          break;\n      }\n    }\n  }, false);\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/worker.js?")},"../xgplayer-utils/src/mobile/yuv-canvas.js":
/*!**************************************************!*\
      !*** ../xgplayer-utils/src/mobile/yuv-canvas.js ***!
      \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass YUVCanvas {\n  constructor(configs) {\n    this.configs = Object.assign({}, configs);\n    this.canvas = this.configs.canvas;\n    this.meta = Object.assign({}, this.configs.meta);\n    this.chroma = this.meta.chromaFormat;\n    this.height = this.meta.presentHeight;\n    this.width = this.meta.presentWidth;\n    this.canvas.width = 1280;\n    this.canvas.height = 720;\n    this.canvas.style.width = '100%';\n    this.canvas.style.height = '100%';\n    this._initContextGL();\n    if (this.contextGL) {\n      this._initProgram();\n      this._initBuffers();\n      this._initTextures();\n    };\n  }\n\n  _initContextGL() {\n    var canvas = this.canvas;\n    var gl = null;\n\n    var validContextNames = ['webgl', 'experimental-webgl', 'moz-webgl', 'webkit-3d'];\n    var nameIndex = 0;\n\n    while (!gl && nameIndex < validContextNames.length) {\n      var contextName = validContextNames[nameIndex];\n\n      try {\n        if (this.contextOptions) {\n          gl = canvas.getContext(contextName, this.contextOptions);\n        } else {\n          gl = canvas.getContext(contextName);\n        };\n      } catch (e) {\n        gl = null;\n      }\n\n      if (!gl || typeof gl.getParameter !== 'function') {\n        gl = null;\n      }\n\n      ++nameIndex;\n    };\n\n    this.contextGL = gl;\n  }\n\n  _initProgram() {\n    var gl = this.contextGL;\n\n    // vertex shader is the same for all types\n    var vertexShaderScript;\n    var fragmentShaderScript;\n    vertexShaderScript = ['attribute vec4 vertexPos;', 'attribute vec4 texturePos;', 'attribute vec4 uTexturePos;', 'attribute vec4 vTexturePos;', 'varying vec2 textureCoord;', 'varying vec2 uTextureCoord;', 'varying vec2 vTextureCoord;', 'void main()', '{', '  gl_Position = vertexPos;', '  textureCoord = texturePos.xy;', '  uTextureCoord = uTexturePos.xy;', '  vTextureCoord = vTexturePos.xy;', '}'].join('\\n');\n\n    fragmentShaderScript = ['precision highp float;', 'varying highp vec2 textureCoord;', 'varying highp vec2 uTextureCoord;', 'varying highp vec2 vTextureCoord;', 'uniform sampler2D ySampler;', 'uniform sampler2D uSampler;', 'uniform sampler2D vSampler;', 'uniform mat4 YUV2RGB;', 'void main(void) {', '  highp float y = texture2D(ySampler,  textureCoord).r;', '  highp float u = texture2D(uSampler,  uTextureCoord).r;', '  highp float v = texture2D(vSampler,  vTextureCoord).r;', '  gl_FragColor = vec4(y, u, v, 1) * YUV2RGB;', '}'].join('\\n');\n\n    var YUV2RGB = [1.16438, 0.00000, 1.59603, -0.87079, 1.16438, -0.39176, -0.81297, 0.52959, 1.16438, 2.01723, 0.00000, -1.08139, 0, 0, 0, 1];\n    var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(vertexShader, vertexShaderScript);\n    gl.compileShader(vertexShader);\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      console.log('Vertex shader failed to compile: ' + gl.getShaderInfoLog(vertexShader));\n    }\n\n    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(fragmentShader, fragmentShaderScript);\n    gl.compileShader(fragmentShader);\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      console.log('Fragment shader failed to compile: ' + gl.getShaderInfoLog(fragmentShader));\n    }\n\n    var program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      console.log('Program failed to compile: ' + gl.getProgramInfoLog(program));\n    }\n\n    gl.useProgram(program);\n\n    var YUV2RGBRef = gl.getUniformLocation(program, 'YUV2RGB');\n    gl.uniformMatrix4fv(YUV2RGBRef, false, YUV2RGB);\n\n    this.shaderProgram = program;\n  }\n\n  _initBuffers() {\n    var gl = this.contextGL;\n    var program = this.shaderProgram;\n\n    var vertexPosBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]), gl.STATIC_DRAW);\n\n    var vertexPosRef = gl.getAttribLocation(program, 'vertexPos');\n    gl.enableVertexAttribArray(vertexPosRef);\n    gl.vertexAttribPointer(vertexPosRef, 2, gl.FLOAT, false, 0, 0);\n\n    var texturePosBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, texturePosBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]), gl.STATIC_DRAW);\n\n    var texturePosRef = gl.getAttribLocation(program, 'texturePos');\n    gl.enableVertexAttribArray(texturePosRef);\n    gl.vertexAttribPointer(texturePosRef, 2, gl.FLOAT, false, 0, 0);\n\n    this.texturePosBuffer = texturePosBuffer;\n\n    var uTexturePosBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, uTexturePosBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]), gl.STATIC_DRAW);\n\n    var uTexturePosRef = gl.getAttribLocation(program, 'uTexturePos');\n    gl.enableVertexAttribArray(uTexturePosRef);\n    gl.vertexAttribPointer(uTexturePosRef, 2, gl.FLOAT, false, 0, 0);\n\n    this.uTexturePosBuffer = uTexturePosBuffer;\n\n    var vTexturePosBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, vTexturePosBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]), gl.STATIC_DRAW);\n\n    var vTexturePosRef = gl.getAttribLocation(program, 'vTexturePos');\n    gl.enableVertexAttribArray(vTexturePosRef);\n    gl.vertexAttribPointer(vTexturePosRef, 2, gl.FLOAT, false, 0, 0);\n\n    this.vTexturePosBuffer = vTexturePosBuffer;\n  }\n\n  _initTextures() {\n    var gl = this.contextGL;\n    var program = this.shaderProgram;\n    var yTextureRef = this._initTexture();\n    var ySamplerRef = gl.getUniformLocation(program, 'ySampler');\n    gl.uniform1i(ySamplerRef, 0);\n    this.yTextureRef = yTextureRef;\n\n    var uTextureRef = this._initTexture();\n    var uSamplerRef = gl.getUniformLocation(program, 'uSampler');\n    gl.uniform1i(uSamplerRef, 1);\n    this.uTextureRef = uTextureRef;\n\n    var vTextureRef = this._initTexture();\n    var vSamplerRef = gl.getUniformLocation(program, 'vSampler');\n    gl.uniform1i(vSamplerRef, 2);\n    this.vTextureRef = vTextureRef;\n  }\n\n  _initTexture() {\n    var gl = this.contextGL;\n\n    var textureRef = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, textureRef);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    return textureRef;\n  }\n\n  _drawPictureGL(data, width, height, yLinesize, uvLinesize) {\n    var ylen = yLinesize * height;\n    var uvlen = uvLinesize * height / 2;\n    if (this.chroma === 444 || this.chroma === 422) {\n      uvlen *= 2;\n    }\n    data = new Uint8Array(data);\n    let renderData = {\n      yData: data.subarray(0, ylen),\n      uData: data.subarray(ylen, ylen + uvlen),\n      vData: data.subarray(ylen + uvlen, ylen + uvlen + uvlen)\n    };\n    this._drawPictureGL420(renderData, width, height, yLinesize, uvLinesize);\n  }\n\n  _drawPictureGL420(data, width, height, yLinesize, uvLinesize) {\n    var gl = this.contextGL;\n    var texturePosBuffer = this.texturePosBuffer;\n    var uTexturePosBuffer = this.uTexturePosBuffer;\n    var vTexturePosBuffer = this.vTexturePosBuffer;\n\n    var yTextureRef = this.yTextureRef;\n    var uTextureRef = this.uTextureRef;\n    var vTextureRef = this.vTextureRef;\n\n    var yData = data.yData;\n    var uData = data.uData;\n    var vData = data.vData;\n\n    var yDataPerRow = yLinesize;\n    var yRowCnt = height;\n\n    var uDataPerRow = width / 2;\n    var uRowCnt = height / 2;\n\n    if (this.chroma === 422 || this.chroma === 444) {\n      uRowCnt = height;\n    }\n\n    var vDataPerRow = uvLinesize;\n    var vRowCnt = uRowCnt;\n\n    let ratiow = this.canvas.width / this.width;\n    let ratioh = this.canvas.height / this.height;\n    let left = 0;\n    let top = 0;\n    let w = this.canvas.width;\n    let h = this.canvas.height;\n    if (ratiow < ratioh) {\n      h = this.height * this.canvas.width / this.width;\n      top = parseInt((this.canvas.height - this.height * this.canvas.width / this.width) / 2);\n    } else {\n      w = this.width * this.canvas.height / this.height;\n      left = parseInt((this.canvas.width - this.width * this.canvas.height / this.height) / 2);\n    }\n    gl.viewport(left, top, w, h);\n\n    var texturePosValues = new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]);\n    gl.bindBuffer(gl.ARRAY_BUFFER, texturePosBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, texturePosValues, gl.DYNAMIC_DRAW);\n\n    var uTexturePosValues = new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]);\n    gl.bindBuffer(gl.ARRAY_BUFFER, uTexturePosBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, uTexturePosValues, gl.DYNAMIC_DRAW);\n\n    var vTexturePosValues = new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]);\n    gl.bindBuffer(gl.ARRAY_BUFFER, vTexturePosBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vTexturePosValues, gl.DYNAMIC_DRAW);\n\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, yTextureRef);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, yDataPerRow, yRowCnt, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, yData);\n\n    gl.activeTexture(gl.TEXTURE1);\n    gl.bindTexture(gl.TEXTURE_2D, uTextureRef);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, uDataPerRow, uRowCnt, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, uData);\n\n    gl.activeTexture(gl.TEXTURE2);\n    gl.bindTexture(gl.TEXTURE_2D, vTextureRef);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, vDataPerRow, vRowCnt, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, vData);\n\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n  }\n\n  _drawPictureRGB(data) {}\n\n  render(data, width, height, yLinesize, uvLinesize) {\n    var gl = this.contextGL;\n    if (gl) {\n      this._drawPictureGL(data, width, height, yLinesize, uvLinesize);\n    } else {\n      this._drawPictureRGB(data);\n    }\n  }\n}\n\nexports.default = YUVCanvas;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/yuv-canvas.js?")},"../xgplayer-utils/src/models/media-info.js":
/*!**************************************************!*\
      !*** ../xgplayer-utils/src/models/media-info.js ***!
      \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nconst isObjectFilled = obj => {\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      if (obj[key] === null) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\nclass MediaInfo {\n  constructor() {\n    this.mimeType = null;\n    this.duration = null;\n\n    this.hasVideo = null;\n    this.video = {\n      codec: null,\n      width: null,\n      height: null,\n      profile: null,\n      level: null,\n      frameRate: {\n        fixed: true,\n        fps: 25,\n        fps_num: 25000,\n        fps_den: 1000\n      },\n      chromaFormat: null,\n      parRatio: {\n        width: 1,\n        height: 1\n      }\n    };\n\n    this.hasAudio = null;\n\n    this.audio = {\n      codec: null,\n      sampleRate: null,\n      sampleRateIndex: null,\n      channelCount: null\n    };\n  }\n\n  isComplete() {\n    return MediaInfo.isBaseInfoReady(this) && MediaInfo.isVideoReady(this) && MediaInfo.isAudioReady(this);\n  }\n\n  static isBaseInfoReady(mediaInfo) {\n    return isObjectFilled(mediaInfo);\n  }\n\n  static isVideoReady(mediaInfo) {\n    if (!mediaInfo.hasVideo) {\n      return true;\n    }\n\n    return isObjectFilled(mediaInfo.video);\n  }\n\n  static isAudioReady(mediaInfo) {\n    if (!mediaInfo.hasAudio) {\n      return true;\n    }\n\n    return isObjectFilled(mediaInfo.video);\n  }\n}\nexports.default = MediaInfo;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/media-info.js?')},"../xgplayer-utils/src/models/media-sample.js":
/*!****************************************************!*\
      !*** ../xgplayer-utils/src/models/media-sample.js ***!
      \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass MediaSample {\n  constructor(info) {\n    let _default = MediaSample.getDefaultInf();\n\n    if (!info || Object.prototype.toString.call(info) !== '[object Object]') {\n      return _default;\n    }\n    let sample = Object.assign({}, _default, info);\n\n    Object.entries(sample).forEach(([k, v]) => {\n      this[k] = v;\n    });\n  }\n\n  static getDefaultInf() {\n    return {\n      dts: null,\n      pts: null,\n      duration: null,\n      position: null,\n      isRAP: false, // is Random access point\n      originDts: null\n    };\n  }\n}\nexports.default = MediaSample;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/media-sample.js?")},"../xgplayer-utils/src/models/media-segment-list.js":
/*!**********************************************************!*\
      !*** ../xgplayer-utils/src/models/media-segment-list.js ***!
      \**********************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nclass MediaSegmentList {\n\n    constructor(type) {\n        this._type = type;\n        this._list = [];\n        this._lastAppendLocation = -1; // cached last insert location\n    }\n\n    get type() {\n        return this._type;\n    }\n\n    get length() {\n        return this._list.length;\n    }\n\n    isEmpty() {\n        return this._list.length === 0;\n    }\n\n    clear() {\n        this._list = [];\n        this._lastAppendLocation = -1;\n    }\n\n    _searchNearestSegmentBefore(beginDts) {\n        let list = this._list;\n        if (list.length === 0) {\n            return -2;\n        }\n        let last = list.length - 1;\n        let mid = 0;\n        let lbound = 0;\n        let ubound = last;\n\n        let idx = 0;\n\n        if (beginDts < list[0].originDts) {\n            idx = -1;\n            return idx;\n        }\n\n        while (lbound <= ubound) {\n            mid = lbound + Math.floor((ubound - lbound) / 2);\n            if (mid === last || beginDts > list[mid].lastSample.originDts && beginDts < list[mid + 1].originDts) {\n                idx = mid;\n                break;\n            } else if (list[mid].originDts < beginDts) {\n                lbound = mid + 1;\n            } else {\n                ubound = mid - 1;\n            }\n        }\n        return idx;\n    }\n\n    _searchNearestSegmentAfter(beginDts) {\n        return this._searchNearestSegmentBefore(beginDts) + 1;\n    }\n\n    append(segment) {\n        let list = this._list;\n        let lastAppendIdx = this._lastAppendLocation;\n        let insertIdx = 0;\n\n        if (lastAppendIdx !== -1 && lastAppendIdx < list.length && segment.originStartDts >= list[lastAppendIdx].lastSample.originDts && (lastAppendIdx === list.length - 1 || lastAppendIdx < list.length - 1 && segment.originStartDts < list[lastAppendIdx + 1].originStartDts)) {\n            insertIdx = lastAppendIdx + 1; // use cached location idx\n        } else {\n            if (list.length > 0) {\n                insertIdx = this._searchNearestSegmentBefore(segment.originStartDts) + 1;\n            }\n        }\n\n        this._lastAppendLocation = insertIdx;\n        this._list.splice(insertIdx, 0, segment);\n    }\n\n    getLastSegmentBefore(beginDts) {\n        let idx = this._searchNearestSegmentBefore(beginDts);\n        if (idx >= 0) {\n            return this._list[idx];\n        } else {\n            // -1\n            return null;\n        }\n    }\n\n    getLastSampleBefore(beginDts) {\n        let segment = this.getLastSegmentBefore(beginDts);\n        if (segment !== null) {\n            return segment.lastSample;\n        } else {\n            return null;\n        }\n    }\n\n    getLastRAPBefore(beginDts) {\n        let segmentIdx = this._searchNearestSegmentBefore(beginDts);\n        let randomAccessPoints = this._list[segmentIdx].randomAccessPoints;\n        while (randomAccessPoints.length === 0 && segmentIdx > 0) {\n            segmentIdx--;\n            randomAccessPoints = this._list[segmentIdx].randomAccessPoints;\n        }\n        if (randomAccessPoints.length > 0) {\n            return randomAccessPoints[randomAccessPoints.length - 1];\n        } else {\n            return null;\n        }\n    }\n\n}\nexports.default = MediaSegmentList;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/media-segment-list.js?')},"../xgplayer-utils/src/models/media-segment.js":
/*!*****************************************************!*\
      !*** ../xgplayer-utils/src/models/media-segment.js ***!
      \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nclass MediaSegment {\n    constructor() {\n        this.startDts = -1;\n        this.endDts = -1;\n        this.startPts = -1;\n        this.endPts = -1;\n        this.originStartDts = -1;\n        this.originEndDts = -1;\n        this.randomAccessPoints = [];\n        this.firstSample = null;\n        this.lastSample = null;\n    }\n\n    addRAP(sample) {\n        sample.isRAP = true;\n        this.randomAccessPoints.push(sample);\n    }\n}\nexports.default = MediaSegment;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/media-segment.js?')},"../xgplayer-utils/src/models/track-meta.js":
/*!**************************************************!*\
      !*** ../xgplayer-utils/src/models/track-meta.js ***!
      \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass AudioTrackMeta {\n  constructor(meta) {\n    const _default = {\n      sampleRate: 48000,\n      channelCount: 2,\n      codec: 'mp4a.40.2',\n      config: [41, 401, 136, 0],\n      duration: 0,\n      id: 2,\n      refSampleDuration: 21,\n      sampleRateIndex: 3,\n      timescale: 1000,\n      type: 'audio'\n    };\n    if (meta) {\n      return Object.assign({}, _default, meta);\n    }\n    return _default;\n  }\n\n  destroy() {\n    this.init = null;\n  }\n}\n\nexports.AudioTrackMeta = AudioTrackMeta;\nclass VideoTrackMeta {\n  constructor(meta) {\n    const _default = {\n      avcc: null,\n      sps: new Uint8Array(0),\n      pps: new Uint8Array(0),\n      chromaFormat: 420,\n      codec: 'avc1.640020',\n      codecHeight: 720,\n      codecWidth: 1280,\n      duration: 0,\n      frameRate: {\n        fixed: true,\n        fps: 25,\n        fps_num: 25000,\n        fps_den: 1000\n      },\n      id: 1,\n      level: '3.2',\n      presentHeight: 720,\n      presentWidth: 1280,\n      profile: 'High',\n      refSampleDuration: 40,\n      parRatio: {\n        height: 1,\n        width: 1\n      },\n      timescale: 1000,\n      type: 'video'\n    };\n\n    if (meta) {\n      return Object.assign({}, _default, meta);\n    }\n    return _default;\n  }\n\n  destroy() {\n    this.init = null;\n    this.sps = null;\n    this.pps = null;\n  }\n}\nexports.VideoTrackMeta = VideoTrackMeta;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/track-meta.js?")},"../xgplayer-utils/src/models/track-sample.js":
/*!****************************************************!*\
      !*** ../xgplayer-utils/src/models/track-sample.js ***!
      \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nclass AudioTrackSample {\n  constructor(info) {\n    let _default = AudioTrackSample.getDefault();\n    if (!info) {\n      return _default;\n    }\n    let sample = Object.assign({}, _default, info);\n\n    return sample;\n  }\n\n  static getDefault() {\n    return {\n      dts: null,\n      pts: null,\n      data: new Uint8Array()\n    };\n  }\n}\n\nexports.AudioTrackSample = AudioTrackSample;\nclass VideoTrackSample {\n  constructor(info) {\n    let _default = VideoTrackSample.getDefault();\n\n    if (!info) {\n      return _default;\n    }\n    let sample = Object.assign({}, _default, info);\n\n    return sample;\n  }\n\n  static getDefault() {\n    return {\n      dts: null,\n      pts: null,\n      isKeyframe: false, // is Random access point\n      originDts: null,\n      data: new Uint8Array()\n    };\n  }\n}\nexports.VideoTrackSample = VideoTrackSample;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/track-sample.js?')},"../xgplayer-utils/src/mse/index.js":
/*!******************************************!*\
      !*** ../xgplayer-utils/src/mse/index.js ***!
      \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass MSE {\n  constructor(configs) {\n    this.configs = Object.assign({}, configs);\n    this.container = this.configs.container;\n    this.mediaSource = null;\n    this.sourceBuffers = {};\n    this.preloadTime = this.configs.preloadTime || 1;\n    this.onSourceOpen = this.onSourceOpen.bind(this);\n    this.onTimeUpdate = this.onTimeUpdate.bind(this);\n    this.onUpdateEnd = this.onUpdateEnd.bind(this);\n    this.onWaiting = this.onWaiting.bind(this);\n  }\n\n  init() {\n    // eslint-disable-next-line no-undef\n    this.mediaSource = new self.MediaSource();\n    this.mediaSource.addEventListener('sourceopen', this.onSourceOpen);\n    this.container.src = URL.createObjectURL(this.mediaSource);\n    this.url = this.container.src;\n    this.container.addEventListener('timeupdate', this.onTimeUpdate);\n    this.container.addEventListener('waiting', this.onWaiting);\n  }\n\n  onTimeUpdate() {\n    this.emit('TIME_UPDATE', this.container);\n  }\n\n  onWaiting() {\n    this.emit('WAITING', this.container);\n  }\n\n  onSourceOpen() {\n    this.addSourceBuffers();\n  }\n\n  onUpdateEnd() {\n    this.emit('SOURCE_UPDATE_END');\n    this.doAppend();\n  }\n  addSourceBuffers() {\n    if (this.mediaSource.readyState !== 'open') {\n      return;\n    }\n    let sources = this._context.getInstance('PRE_SOURCE_BUFFER');\n    let tracks = this._context.getInstance('TRACKS');\n    let track;\n\n    sources = sources.sources;\n    let add = false;\n    for (let i = 0, k = Object.keys(sources).length; i < k; i++) {\n      let type = Object.keys(sources)[i];\n      if (type === 'audio') {\n        track = tracks.audioTrack;\n      } else if (type === 'video') {\n        track = tracks.videoTrack;\n        // return;\n      }\n      if (track) {\n        let dur = type === 'audio' ? 21 : 40;\n        if (track.meta && track.meta.refSampleDuration) dur = track.meta.refSampleDuration;\n        if (sources[type].data.length >= this.preloadTime / dur) {\n          add = true;\n        }\n      }\n    }\n\n    if (add) {\n      if (Object.keys(this.sourceBuffers).length > 0) {\n        return;\n      }\n      for (let i = 0, k = Object.keys(sources).length; i < k; i++) {\n        let type = Object.keys(sources)[i];\n        let source = sources[type];\n        let mime = type === 'video' ? 'video/mp4;codecs=' + source.mimetype : 'audio/mp4;codecs=' + source.mimetype;\n        let sourceBuffer = this.mediaSource.addSourceBuffer(mime);\n        this.sourceBuffers[type] = sourceBuffer;\n        sourceBuffer.addEventListener('updateend', this.onUpdateEnd);\n        this.doAppend();\n      }\n    }\n  }\n\n  doAppend() {\n    let sources = this._context.getInstance('PRE_SOURCE_BUFFER');\n    if (sources) {\n      for (let i = 0; i < Object.keys(this.sourceBuffers).length; i++) {\n        let type = Object.keys(this.sourceBuffers)[i];\n        let sourceBuffer = this.sourceBuffers[type];\n        if (!sourceBuffer.updating) {\n          let source = sources.sources[type];\n          if (source && !source.inited) {\n            // console.log('append initial segment')\n            sourceBuffer.appendBuffer(source.init.buffer.buffer);\n            source.inited = true;\n          } else if (source) {\n            let data = source.data.shift();\n            if (data) {\n              sourceBuffer.appendBuffer(data.buffer.buffer);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  endOfStream() {\n    const { readyState, activeSourceBuffers } = this.mediaSource;\n    if (readyState === 'open' && activeSourceBuffers.length === 0) {\n      try {\n        this.mediaSource.endOfStream();\n      } catch (e) {\n        // log\n      }\n    }\n  }\n\n  remove(end, start = 0) {\n    for (let i = 0; i < Object.keys(this.sourceBuffers).length; i++) {\n      let buffer = this.sourceBuffers[Object.keys(this.sourceBuffers)[i]];\n      if (!buffer.updating) {\n        // console.log(start, end)\n        buffer.remove(start, end);\n      }\n    }\n  }\n  removeBuffers() {\n    const taskList = [];\n    for (let i = 0; i < Object.keys(this.sourceBuffers).length; i++) {\n      let buffer = this.sourceBuffers[Object.keys(this.sourceBuffers)[i]];\n      buffer.removeEventListener('updateend', this.onUpdateEnd);\n\n      let task;\n      if (buffer.updating) {\n        task = new Promise(resolve => {\n          const doCleanBuffer = function () {\n            let retryTime = 3;\n\n            const clean = () => {\n              if (!buffer.updating) {\n                MSE.clearBuffer(buffer);\n                resolve();\n              } else if (retryTime > 0) {\n                setTimeout(clean, 200);\n                retryTime--;\n              } else {\n                resolve();\n              }\n            };\n\n            setTimeout(clean, 200);\n            buffer.removeEventListener('updateend', doCleanBuffer);\n          };\n          buffer.addEventListener('updateend', doCleanBuffer);\n        });\n      } else {\n        MSE.clearBuffer(buffer);\n        task = Promise.resolve();\n      }\n\n      taskList.push(task);\n    }\n\n    return Promise.all(taskList);\n  }\n\n  destroy() {\n    return this.removeBuffers().then(() => {\n      for (let i = 0; i < Object.keys(this.sourceBuffers).length; i++) {\n        let buffer = this.sourceBuffers[Object.keys(this.sourceBuffers)[i]];\n        this.mediaSource.removeSourceBuffer(buffer);\n        delete this.sourceBuffers[Object.keys(this.sourceBuffers)[i]];\n      }\n\n      this.container.removeEventListener('timeupdate', this.onTimeUpdate);\n      this.container.removeEventListener('waiting', this.onWaiting);\n      this.mediaSource.removeEventListener('sourceopen', this.onSourceOpen);\n\n      this.endOfStream();\n      window.URL.revokeObjectURL(this.url);\n\n      this.url = null;\n      this.configs = {};\n      this.container = null;\n      this.mediaSource = null;\n      this.sourceBuffers = {};\n      this.preloadTime = 1;\n    });\n  }\n\n  static clearBuffer(buffer) {\n    const buffered = buffer.buffered;\n    let bEnd = 0.1;\n    for (let i = 0, len = buffered.length; i < len; i++) {\n      bEnd = buffered.end(i);\n    }\n    try {\n      buffer.remove(0, bEnd);\n    } catch (e) {\n      // DO NOTHING\n    }\n  }\n}\nexports.default = MSE;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mse/index.js?")},"../xgplayer-utils/src/write/buffer.js":
/*!*********************************************!*\
      !*** ../xgplayer-utils/src/write/buffer.js ***!
      \*********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _concatTypedArray = __webpack_require__(/*! concat-typed-array */ \"../xgplayer-utils/node_modules/concat-typed-array/lib/index.js\");\n\nvar _concatTypedArray2 = _interopRequireDefault(_concatTypedArray);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Buffer {\n  constructor(buffer) {\n    this.buffer = buffer || new Uint8Array(0);\n  }\n\n  write(...buffer) {\n    buffer.forEach(item => {\n      this.buffer = (0, _concatTypedArray2.default)(Uint8Array, this.buffer, item);\n    });\n  }\n\n  static writeUint32(value) {\n    return new Uint8Array([value >> 24, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff]);\n  }\n\n  static readAsInt(arr) {\n    let temp = '';\n\n    function padStart4Hex(hexNum) {\n      let hexStr = hexNum.toString(16);\n      return hexStr.padStart(2, '0');\n    }\n\n    arr.forEach(num => {\n      temp += padStart4Hex(num);\n    });\n    return parseInt(temp, 16);\n  }\n}\n\nexports.default = Buffer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/write/buffer.js?")},"../xgplayer-utils/src/write/stream.js":
/*!*********************************************!*\
      !*** ../xgplayer-utils/src/write/stream.js ***!
      \*********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass Stream {\n  constructor(buffer) {\n    if (buffer instanceof ArrayBuffer) {\n      this.buffer = buffer;\n      this.dataview = new DataView(buffer);\n      this.dataview.position = 0;\n    } else {\n      throw new Error('data is invalid');\n    }\n  }\n\n  get length() {\n    return this.buffer.byteLength;\n  }\n\n  set position(value) {\n    this.dataview.position = value;\n  }\n\n  get position() {\n    return this.dataview.position;\n  }\n\n  back(count) {\n    this.position -= count;\n  }\n\n  skip(count) {\n    let loop = Math.floor(count / 4);\n    let last = count % 4;\n    for (let i = 0; i < loop; i++) {\n      Stream.readByte(this.dataview, 4);\n    }\n    if (last > 0) {\n      Stream.readByte(this.dataview, last);\n    }\n  }\n\n  /**\n   * [readByte 从DataView中读取数据]\n   * @param  {DataView} buffer [DataView实例]\n   * @param  {Number} size   [读取字节数]\n   * @return {Number}        [整数]\n   */\n  static readByte(buffer, size, sign) {\n    let res;\n    switch (size) {\n      case 1:\n        if (sign) {\n          res = buffer.getInt8(buffer.position);\n        } else {\n          res = buffer.getUint8(buffer.position);\n        }\n        break;\n      case 2:\n        if (sign) {\n          res = buffer.getInt16(buffer.position);\n        } else {\n          res = buffer.getUint16(buffer.position);\n        }\n        break;\n      case 3:\n        if (sign) {\n          throw new Error('not supported for readByte 3');\n        } else {\n          res = buffer.getUint8(buffer.position) << 16;\n          res |= buffer.getUint8(buffer.position + 1) << 8;\n          res |= buffer.getUint8(buffer.position + 2);\n        }\n        break;\n      case 4:\n        if (sign) {\n          res = buffer.getInt32(buffer.position);\n        } else {\n          res = buffer.getUint32(buffer.position);\n        }\n        break;\n      case 8:\n        if (sign) {\n          throw new Error('not supported for readBody 8');\n        } else {\n          res = buffer.getUint32(buffer.position) << 32;\n          res |= buffer.getUint32(buffer.position + 4);\n        }\n        break;\n      default:\n        res = '';\n    }\n    buffer.position += size;\n    return res;\n  }\n\n  readUint8() {\n    return Stream.readByte(this.dataview, 1);\n  }\n\n  readUint16() {\n    return Stream.readByte(this.dataview, 2);\n  }\n\n  readUint24() {\n    return Stream.readByte(this.dataview, 3);\n  }\n\n  readUint32() {\n    return Stream.readByte(this.dataview, 4);\n  }\n\n  readUint64() {\n    return Stream.readByte(this.dataview, 8);\n  }\n\n  readInt8() {\n    return Stream.readByte(this.dataview, 1, true);\n  }\n  readInt16() {\n    return Stream.readByte(this.dataview, 2, true);\n  }\n\n  readInt32() {\n    return Stream.readByte(this.dataview, 4, true);\n  }\n\n  writeUint32(value) {\n    return new Uint8Array([value >>> 24 & 0xff, value >>> 16 & 0xff, value >>> 8 & 0xff, value & 0xff]);\n  }\n}\n\nexports.default = Stream;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/write/stream.js?")},"./src/flv-live.js":
/*!*************************!*\
      !*** ./src/flv-live.js ***!
      \*************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _xgplayerRemux = __webpack_require__(/*! xgplayer-remux */ \"../xgplayer-remux/index.js\");\n\nvar _xgplayerRemux2 = _interopRequireDefault(_xgplayerRemux);\n\nvar _xgplayerLoader = __webpack_require__(/*! xgplayer-loader */ \"../xgplayer-loader/index.js\");\n\nvar _xgplayerDemux = __webpack_require__(/*! xgplayer-demux */ \"../xgplayer-demux/index.js\");\n\nvar _xgplayerBuffer = __webpack_require__(/*! xgplayer-buffer */ \"../xgplayer-buffer/index.js\");\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nvar _xgplayerCodec = __webpack_require__(/*! xgplayer-codec */ \"../xgplayer-codec/index.js\");\n\nvar _xgplayer = __webpack_require__(/*! xgplayer */ \"xgplayer\");\n\nvar _xgplayer2 = _interopRequireDefault(_xgplayer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst REMUX_EVENTS = _xgplayerUtils.EVENTS.REMUX_EVENTS;\nconst DEMUX_EVENTS = _xgplayerUtils.EVENTS.DEMUX_EVENTS;\nconst LOADER_EVENTS = _xgplayerUtils.EVENTS.LOADER_EVENTS;\nconst MSE_EVENTS = _xgplayerUtils.EVENTS.MSE_EVENTS;\n\nconst Tag = 'FLVController';\n\nclass Logger {\n  warn() {}\n}\n\nconst FLV_ERROR = 'FLV_ERROR';\n\nclass FlvController {\n  constructor(player) {\n    this.TAG = Tag;\n    this._player = player;\n\n    this.state = {\n      initSegmentArrived: false\n    };\n\n    this.bufferClearTimer = null;\n  }\n\n  init() {\n    this._context.registry('FETCH_LOADER', _xgplayerLoader.FetchLoader);\n    this._context.registry('LOADER_BUFFER', _xgplayerBuffer.XgBuffer);\n\n    this._context.registry('FLV_DEMUXER', _xgplayerDemux.FlvDemuxer);\n    this._context.registry('TRACKS', _xgplayerBuffer.Tracks);\n\n    this._context.registry('MP4_REMUXER', _xgplayerRemux2.default.Mp4Remuxer);\n    this._context.registry('PRE_SOURCE_BUFFER', _xgplayerBuffer.PreSource);\n\n    if (this._player.config.compatibility !== false) {\n      this._context.registry('COMPATIBILITY', _xgplayerCodec.Compatibility);\n    }\n\n    this._context.registry('LOGGER', Logger);\n    this.mse = this._context.registry('MSE', _xgplayerUtils.Mse)({ container: this._player.video });\n\n    this._handleTimeUpdate = this._handleTimeUpdate.bind(this);\n\n    this.initListeners();\n  }\n\n  initListeners() {\n    this.on(LOADER_EVENTS.LOADER_DATALOADED, this._handleLoaderDataLoaded.bind(this));\n    this.on(LOADER_EVENTS.LOADER_ERROR, this._handleNetworkError.bind(this));\n\n    this.on(DEMUX_EVENTS.MEDIA_INFO, this._handleMediaInfo.bind(this));\n    this.on(DEMUX_EVENTS.METADATA_PARSED, this._handleMetadataParsed.bind(this));\n    this.on(DEMUX_EVENTS.DEMUX_COMPLETE, this._handleDemuxComplete.bind(this));\n    this.on(DEMUX_EVENTS.DEMUX_ERROR, this._handleDemuxError.bind(this));\n\n    this.on(REMUX_EVENTS.INIT_SEGMENT, this._handleAppendInitSegment.bind(this));\n    this.on(REMUX_EVENTS.MEDIA_SEGMENT, this._handleMediaSegment.bind(this));\n\n    this.on(MSE_EVENTS.SOURCE_UPDATE_END, this._handleSourceUpdateEnd.bind(this));\n\n    this._player.on('timeupdate', this._handleTimeUpdate);\n  }\n\n  _handleMediaInfo() {\n    if (!this._context.mediaInfo) {\n      this.emit(DEMUX_EVENTS.DEMUX_ERROR, new Error('failed to get mediainfo'));\n    }\n  }\n\n  _handleLoaderDataLoaded() {\n    this.emitTo('FLV_DEMUXER', DEMUX_EVENTS.DEMUX_START);\n  }\n\n  _handleMetadataParsed(type) {\n    this.emit(REMUX_EVENTS.REMUX_METADATA, type);\n  }\n  _handleDemuxComplete() {\n    this.emit(REMUX_EVENTS.REMUX_MEDIA);\n  }\n\n  _handleAppendInitSegment() {\n    this.state.initSegmentArrived = true;\n    this.mse.addSourceBuffers();\n  }\n\n  _handleMediaSegment() {\n    this.mse.addSourceBuffers();\n    this.mse.doAppend();\n  }\n\n  _handleSourceUpdateEnd() {\n    const time = this._player.currentTime;\n    const video = this._player.video;\n    const preloadTime = this._player.config.preloadTime || 5;\n\n    const { length } = video.buffered;\n\n    if (length === 0) {\n      return;\n    }\n\n    const bufferEnd = video.buffered.end(length - 1);\n    if (bufferEnd - time > preloadTime * 2) {\n      this._player.currentTime = bufferEnd - preloadTime;\n    }\n    this.mse.doAppend();\n  }\n\n  _handleTimeUpdate() {\n    const time = this._player.currentTime;\n\n    const video = this._player.video;\n    let buffered = video.buffered;\n\n    if (!buffered || !buffered.length) {\n      return;\n    }\n\n    const bufferStart = buffered.start(buffered.length - 1);\n    // const bufferStart = this._player.getBufferedRange()[0]\n    if (time - bufferStart > 10) {\n      // 在直播时及时清空buffer，降低直播内存占用\n      if (this.bufferClearTimer) {\n        return;\n      }\n\n      this.mse.remove(time - 1, bufferStart);\n      this.bufferClearTimer = setTimeout(() => {\n        this.bufferClearTimer = null;\n      }, 5000);\n    }\n  }\n\n  _handleNetworkError(tag, err) {\n    this._player.emit('error', new _xgplayer2.default.Errors('network', this._player.config.url));\n    this._onError(LOADER_EVENTS.LOADER_ERROR, tag, err, true);\n  }\n\n  _handleDemuxError(tag, err, fatal) {\n    if (fatal === undefined) {\n      fatal = false;\n    }\n    this._player.emit('error', new _xgplayer2.default.Errors('parse', this._player.config.url));\n    this._onError(LOADER_EVENTS.LOADER_ERROR, tag, err, fatal);\n  }\n\n  _onError(type, mod, err, fatal) {\n    let error = {\n      errorType: type,\n      errorDetails: `[${mod}]: ${err.message}`,\n      errorFatal: fatal || false\n    };\n    this._player.emit(FLV_ERROR, error);\n  }\n\n  seek() {\n    if (!this.state.initSegmentArrived) {\n      this.loadData();\n    }\n  }\n\n  loadData() {\n    this.emit(LOADER_EVENTS.LADER_START, this._player.config.url);\n  }\n\n  pause() {\n    const loader = this._context.getInstance('FETCH_LOADER');\n\n    if (loader) {\n      loader.cancel();\n    }\n  }\n\n  destroy() {\n    this._player.off('timeupdate', this._handleTimeUpdate);\n    this._player = null;\n    this.mse = null;\n  }\n}\nexports.default = FlvController;\n\n//# sourceURL=webpack://xgplayer-flv/./src/flv-live.js?")},"./src/index.js":
/*!**********************!*\
      !*** ./src/index.js ***!
      \**********************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nvar _xgplayer = __webpack_require__(/*! xgplayer */ \"xgplayer\");\n\nvar _xgplayer2 = _interopRequireDefault(_xgplayer);\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nvar _flvLive = __webpack_require__(/*! ./flv-live */ \"./src/flv-live.js\");\n\nvar _flvLive2 = _interopRequireDefault(_flvLive);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst flvAllowedEvents = _xgplayerUtils.EVENTS.FlvAllowedEvents;\n\nclass FlvPlayer extends _xgplayer2.default {\n  constructor(config) {\n    super(config);\n    this.context = new _xgplayerUtils.Context(flvAllowedEvents);\n    this.initEvents();\n    this.loaderCompleteTimer = null;\n    // const preloadTime = player.config.preloadTime || 15\n  }\n\n  start() {\n    this.initFlv();\n    this.context.init();\n    super.start(this.flv.mse.url);\n  }\n\n  initFlvEvents(flv) {\n    const player = this;\n    flv.once(_xgplayerUtils.EVENTS.REMUX_EVENTS.INIT_SEGMENT, () => {\n      _xgplayer2.default.util.addClass(player.root, 'xgplayer-is-live');\n      if (!_xgplayer2.default.util.findDom(this.root, 'xg-live')) {\n        const live = _xgplayer2.default.util.createDom('xg-live', '正在直播', {}, 'xgplayer-live');\n        player.controls.appendChild(live);\n      }\n    });\n\n    flv.once(_xgplayerUtils.EVENTS.LOADER_EVENTS.LOADER_COMPLETE, () => {\n      // 直播完成，待播放器播完缓存后发送关闭事件\n      if (!player.paused) {\n        this.loaderCompleteTimer = setInterval(() => {\n          const end = player.getBufferedRange()[1];\n          if (Math.abs(player.currentTime - end) < 0.5) {\n            player.emit('ended');\n            window.clearInterval(this.loaderCompleteTimer);\n          }\n        }, 200);\n      }\n    });\n  }\n\n  initEvents() {\n    this.on('timeupdate', () => {\n      this.loadData();\n    });\n\n    this.on('seeking', () => {\n      const time = this.currentTime;\n      const range = this.getBufferedRange();\n      if (time > range[1] || time < range[0]) {\n        this.flv.seek(this.currentTime);\n      }\n    });\n  }\n\n  initFlv() {\n    const flv = this.context.registry('FLV_CONTROLLER', _flvLive2.default)(this);\n    this.initFlvEvents(flv);\n    this.flv = flv;\n  }\n\n  play() {\n    if (this._hasStart) {\n      this._destroy().then(() => {\n        this.context = new _xgplayerUtils.Context(flvAllowedEvents);\n        const flv = this.context.registry('FLV_CONTROLLER', _flvLive2.default)(this);\n        this.initFlvEvents(flv);\n        this.flv = flv;\n        this.context.init();\n        super.start(flv.mse.url);\n        super.play();\n      });\n    } else {\n      super.play();\n    }\n  }\n\n  pause() {\n    super.pause();\n    if (this.flv) {\n      this.flv.pause();\n    }\n  }\n\n  loadData(time = this.currentTime) {\n    if (this.flv) {\n      this.flv.seek(time);\n    }\n  }\n\n  destroy() {\n    this._destroy().then(() => {\n      super.destroy();\n    });\n  }\n\n  _destroy() {\n    return this.flv.mse.destroy().then(() => {\n      this.context.destroy();\n      this.flv = null;\n      this.context = null;\n      if (this.loaderCompleteTimer) {\n        window.clearInterval(this.loaderCompleteTimer);\n      }\n    });\n  }\n\n  get src() {\n    return this.currentSrc;\n  }\n\n  set src(url) {\n    this.player.config.url = url;\n    if (!this.paused) {\n      this.pause();\n      this.once('pause', () => {\n        this.start(url);\n      });\n      this.once('canplay', () => {\n        this.play();\n      });\n    } else {\n      this.start(url);\n    }\n    this.once('canplay', () => {\n      this.currentTime = 0;\n    });\n  }\n}\n\nmodule.exports = FlvPlayer;\n\n//# sourceURL=webpack://xgplayer-flv/./src/index.js?")},0:
/*!****************************!*\
      !*** multi ./src/index.js ***!
      \****************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__(/*! ./src/index.js */"./src/index.js");\n\n\n//# sourceURL=webpack://xgplayer-flv/multi_./src/index.js?')},xgplayer:
/*!***************************!*\
      !*** external "xgplayer" ***!
      \***************************/
/*! no static exports found */function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_xgplayer__;\n\n//# sourceURL=webpack://xgplayer-flv/external_%22xgplayer%22?")}})},module.exports=n(__webpack_require__(/*! xgplayer */"xgplayer"))},"../xgplayer-flv-vod/dist/index.js":
/*!***************************!*\
  !*** .-vod/dist/index.js ***!
  \***************************/
/*! no static exports found */function(e,t,n){"use strict";var s;window,e.exports=(s=n(/*! xgplayer */"xgplayer"),function(e){var t={};function n(s){if(t[s])return t[s].exports;var i=t[s]={i:s,l:!1,exports:{}};return e[s].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,s){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(n.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(s,i,function(t){return e[t]}.bind(null,i));return s},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=11)}([function(e,t,n){e.exports={Context:n(13).default,EVENTS:n(4).default,WORKER_COMMANDS:n(15).default,sniffer:n(16).default,isLe:n(17).default,UTF8:n(18).default,MediaInfo:n(3).default,MediaSample:n(19).default,MediaSegment:n(20).default,MediaSegmentList:n(21).default,AudioTrackMeta:n(5).AudioTrackMeta,VideoTrackMeta:n(5).VideoTrackMeta,AudioTrackSample:n(6).AudioTrackSample,VideoTrackSample:n(6).VideoTrackSample,Mse:n(22).default,Stream:n(23).default,Buffer:n(24).default,Crypto:n(27).default}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});class s{constructor(){this.id=-1,this.sequenceNumber=0,this.samples=[],this.droppedSamples=[],this.length=0}reset(){this.sequenceNumber=0,this.samples=[],this.length=0}distroy(){this.reset(),this.id=-1}}t.default=s,t.AudioTrack=class extends s{constructor(){super(),this.TAG="AudioTrack",this.type="audio"}},t.VideoTrack=class extends s{constructor(){super(),this.TAG="VideoTrack",this.type="video",this.dropped=0}reset(){this.sequenceNumber=0,this.samples=[],this.length=0,this.dropped=0}},t.Tracks=class{constructor(){this.audioTrack=null,this.videoTrack=null}destroy(){this.audioTrack=null,this.videoTrack=null}}},function(e,t){e.exports=s},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});const s=e=>{for(let t in e)if(e.hasOwnProperty(t)&&null===e[t])return!1;return!0};class i{constructor(){this.mimeType=null,this.duration=null,this.hasVideo=null,this.video={codec:null,width:null,height:null,profile:null,level:null,frameRate:{fixed:!0,fps:25,fps_num:25e3,fps_den:1e3},chromaFormat:null,parRatio:{width:1,height:1}},this.hasAudio=null,this.audio={codec:null,sampleRate:null,sampleRateIndex:null,channelCount:null}}isComplete(){return i.isBaseInfoReady(this)&&i.isVideoReady(this)&&i.isAudioReady(this)}static isBaseInfoReady(e){return s(e)}static isVideoReady(e){return!e.hasVideo||s(e.video)}static isAudioReady(e){return!e.hasAudio||s(e.video)}}t.default=i},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});const s={LADER_START:"LOADER_START",LOADER_DATALOADED:"LOADER_DATALOADED",LOADER_COMPLETE:"LOADER_COMPLETE",LOADER_ERROR:"LOADER_ERROR"},i={DEMUX_START:"DEMUX_START",DEMUX_COMPLETE:"DEMUX_COMPLETE",DEMUX_ERROR:"DEMUX_ERROR",METADATA_PARSED:"METADATA_PARSED",VIDEO_METADATA_CHANGE:"VIDEO_METADATA_CHANGE",AUDIO_METADATA_CHANGE:"AUDIO_METADATA_CHANGE",MEDIA_INFO:"MEDIA_INFO"},r={REMUX_METADATA:"REMUX_METADATA",REMUX_MEDIA:"REMUX_MEDIA",MEDIA_SEGMENT:"MEDIA_SEGMENT",REMUX_ERROR:"REMUX_ERROR",INIT_SEGMENT:"INIT_SEGMENT",DETECT_CHANGE_STREAM:"DETECT_CHANGE_STREAM"},a={SOURCE_UPDATE_END:"SOURCE_UPDATE_END"},o={RETRY_TIME_EXCEEDED:"RETRY_TIME_EXCEEDED"},l=Object.assign({},s,i,r,a,o),d=[],u=[];for(let e in l)l.hasOwnProperty(e)&&d.push(l[e]);for(let e in l)l.hasOwnProperty(e)&&u.push(l[e]);t.default={ALLEVENTS:l,HLS_EVENTS:o,REMUX_EVENTS:r,DEMUX_EVENTS:i,MSE_EVENTS:a,LOADER_EVENTS:s,FlvAllowedEvents:d,HlsAllowedEvents:u,CRYTO_EVENTS:{START_DECRYPT:"START_DECRYPT",DECRYPTED:"DECRYPTED"}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.AudioTrackMeta=class{constructor(e){const t={sampleRate:48e3,channelCount:2,codec:"mp4a.40.2",config:[41,401,136,0],duration:0,id:2,refSampleDuration:21,sampleRateIndex:3,timescale:1e3,type:"audio"};return e?Object.assign({},t,e):t}destroy(){this.init=null}},t.VideoTrackMeta=class{constructor(e){const t={avcc:null,sps:new Uint8Array(0),pps:new Uint8Array(0),chromaFormat:420,codec:"avc1.640020",codecHeight:720,codecWidth:1280,duration:0,frameRate:{fixed:!0,fps:25,fps_num:25e3,fps_den:1e3},id:1,level:"3.2",presentHeight:720,presentWidth:1280,profile:"High",refSampleDuration:40,parRatio:{height:1,width:1},timescale:1e3,type:"video"};return e?Object.assign({},t,e):t}destroy(){this.init=null,this.sps=null,this.pps=null}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});class s{constructor(e){let t=s.getDefault();return e?Object.assign({},t,e):t}static getDefault(){return{dts:null,pts:null,data:new Uint8Array}}}t.AudioTrackSample=s;class i{constructor(e){let t=i.getDefault();return e?Object.assign({},t,e):t}static getDefault(){return{dts:null,pts:null,isKeyframe:!1,originDts:null,data:new Uint8Array}}}t.VideoTrackSample=i},function(e,t,n){e.exports={Nalunit:n(30).default,SpsParser:n(8).default,Compatibility:n(32).default}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s,i=(s=n(31))&&s.__esModule?s:{default:s};class r{static _ebsp2rbsp(e){let t=e,n=t.byteLength,s=new Uint8Array(n),i=0;for(let e=0;e<n;e++)e>=2&&3===t[e]&&0===t[e-1]&&0===t[e-2]||(s[i]=t[e],i++);return new Uint8Array(s.buffer,0,i)}static parseSPS(e){let t=r._ebsp2rbsp(e),n=new i.default(t);n.readByte();let s=n.readByte();n.readByte();let a=n.readByte();n.readUEG();let o=r.getProfileString(s),l=r.getLevelString(a),d=1,u=420,f=8;if((100===s||110===s||122===s||244===s||44===s||83===s||86===s||118===s||128===s||138===s||144===s)&&(3===(d=n.readUEG())&&n.readBits(1),d<=3&&(u=[0,420,422,444][d]),f=n.readUEG()+8,n.readUEG(),n.readBits(1),n.readBool())){let e=3!==d?8:12;for(let t=0;t<e;t++)n.readBool()&&(t<6?r._skipScalingList(n,16):r._skipScalingList(n,64))}n.readUEG();let c=n.readUEG();if(0===c)n.readUEG();else if(1===c){n.readBits(1),n.readSEG(),n.readSEG();let e=n.readUEG();for(let t=0;t<e;t++)n.readSEG()}n.readUEG(),n.readBits(1);let h=n.readUEG(),p=n.readUEG(),m=n.readBits(1);0===m&&n.readBits(1),n.readBits(1);let _=0,g=0,x=0,y=0;n.readBool()&&(_=n.readUEG(),g=n.readUEG(),x=n.readUEG(),y=n.readUEG());let b=1,v=1,E=0,S=!0,T=0,w=0;if(n.readBool()){if(n.readBool()){let e=n.readByte(),t=[1,12,10,16,40,24,20,32,80,18,15,64,160,4,3,2],s=[1,11,11,11,33,11,11,11,33,11,11,33,99,3,2,1];e>0&&e<16?(b=t[e-1],v=s[e-1]):255===e&&(b=n.readByte()<<8|n.readByte(),v=n.readByte()<<8|n.readByte())}if(n.readBool()&&n.readBool(),n.readBool()&&(n.readBits(4),n.readBool()&&n.readBits(24)),n.readBool()&&(n.readUEG(),n.readUEG()),n.readBool()){let e=n.readBits(32),t=n.readBits(32);S=n.readBool(),E=(T=t)/(w=2*e)}}let k=1;1===b&&1===v||(k=b/v);let A=0,D=0;0===d?(A=1,D=2-m):(A=3===d?1:2,D=(1===d?2:1)*(2-m));let R=16*(h+1),L=16*(p+1)*(2-m);R-=(_+g)*A,L-=(x+y)*D;let M=Math.ceil(R*k);return n.destroy(),n=null,{profile_string:o,level_string:l,bit_depth:f,chroma_format:u,chroma_format_string:r.getChromaFormatString(u),frame_rate:{fixed:S,fps:E,fps_den:w,fps_num:T},par_ratio:{width:b,height:v},codec_size:{width:R,height:L},present_size:{width:M,height:L}}}static _skipScalingList(e,t){let n=8,s=8,i=0;for(let r=0;r<t;r++)0!==s&&(s=(n+(i=e.readSEG())+256)%256),n=0===s?n:s}static getProfileString(e){switch(e){case 66:return"Baseline";case 77:return"Main";case 88:return"Extended";case 100:return"High";case 110:return"High10";case 122:return"High422";case 244:return"High444";default:return"Unknown"}}static getLevelString(e){return(e/10).toFixed(1)}static getChromaFormatString(e){switch(e){case 420:return"4:2:0";case 422:return"4:2:2";case 444:return"4:4:4";default:return"Unknown"}}static toVideoMeta(e){let t={};e&&e.codec_size&&(t.codecWidth=e.codec_size.width,t.codecHeight=e.codec_size.height,t.presentWidth=e.present_size.width,t.presentHeight=e.present_size.height),t.profile=e.profile_string,t.level=e.level_string,t.bitDepth=e.bit_depth,t.chromaFormat=e.chroma_format,t.parRatio={width:e.par_ratio.width,height:e.par_ratio.height},t.frameRate=e.frame_rate;let n=t.frameRate.fps_den,s=t.frameRate.fps_num;t.refSampleDuration=Math.floor(t.timescale*(n/s))}}t.default=r},function(e,t,n){e.exports={Track:n(1).default,Tracks:n(1).Tracks,AudioTrack:n(1).AudioTrack,VideoTrack:n(1).VideoTrack,XgBuffer:n(10).XgBuffer,RemuxBuffer:n(10).RemuxBuffer,PreSource:n(34).default}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.XgBuffer=class{constructor(e){this.length=e||0,this.historyLen=e||0,this.array=[],this.offset=0}push(e){this.array.push(e),this.length+=e.byteLength,this.historyLen+=e.byteLength}shift(e){if(this.array.length<1)return new Uint8Array(0);if(void 0===e)return this._shiftBuffer();if(this.offset+e===this.array[0].length){let t=this.array[0].slice(this.offset,this.offset+e);return this.offset=0,this.array.shift(),this.length-=e,t}if(this.offset+e<this.array[0].length){let t=this.array[0].slice(this.offset,this.offset+e);return this.offset+=e,this.length-=e,t}let t=new Uint8Array(e),n=0;for(;this.array.length>0&&e>0;){if(this.offset+e<this.array[0].length){let s=this.array[0].slice(this.offset,this.offset+e);t.set(s,n),this.offset+=e,this.length-=e,e=0;break}{let s=this.array[0].length-this.offset;t.set(this.array[0].slice(this.offset,this.array[0].length),n),this.array.shift(),this.offset=0,n+=s,this.length-=s,e-=s}}return t}clear(){this.array=[],this.length=0,this.offset=0}destroy(){this.clear(),this.historyLen=0}_shiftBuffer(){return this.length-=this.array[0].length,this.offset=0,this.array.shift()}toInt(e,t){let n=0,s=this.offset+e;for(;s<this.offset+t+e;)s<this.array[0].length?n=256*n+this.array[0][s]:this.array[1]&&(n=256*n+this.array[1][s-this.array[0].length]),s++;return n}},t.RemuxBuffer=class{constructor(){this.video=[],this.audio=[]}destroy(){this.video=[],this.audio=[]}}},function(e,t,n){e.exports=n(12)},function(e,t,n){var s=a(n(2)),i=n(0),r=a(n(28));function a(e){return e&&e.__esModule?e:{default:e}}const o=i.EVENTS.FlvAllowedEvents,l=(e,t)=>{if(!e.config.isLive&&e.duration-e.currentTime<2){const n=e.getBufferedRange();e.currentTime-n[1]<.1&&(e.emit("ended"),t.mse.endOfStream())}};class d extends s.default{constructor(e){super(e),this.context=new i.Context(o),this.initEvents()}start(){const e=this.context.registry("FLV_CONTROLLER",r.default)(this);this.flv=e,this.context.init(),super.start(e.mse.url)}initEvents(){this.on("timeupdate",this.handleTimeUpdate.bind(this)),this.on("seeking",this.handleSeek.bind(this)),this.once("destroy",this._destroy.bind(this))}handleTimeUpdate(){this.loadData(),l(this,this.flv)}handleSeek(){const e=this.currentTime,t=this.getBufferedRange();(e>t[1]||e<t[0])&&this.flv.seek(this.currentTime)}_destroy(){this.context.destroy(),this.context=null,this.flv=null}loadData(e=this.currentTime){const t=this.getBufferedRange();t[1]-e<(this.config.preloadTime||15)-5&&this.flv.loadNext(t[1]+1)}get src(){return this.currentSrc}set src(e){this.player.config.url=e,this.paused?this.start(e):(this.pause(),this.once("pause",()=>{this.start(e)}),this.once("canplay",()=>{this.play()})),this.once("canplay",()=>{this.currentTime=0})}}e.exports=d},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s,i=(s=n(3))&&s.__esModule?s:{default:s},r=n(14);const a="__TO__";t.default=class{constructor(e=[]){this._emitter=new r.EventEmitter,this._instanceMap={},this._clsMap={},this._inited=!1,this.mediaInfo=new i.default,this.allowedEvents=e,this._hooks={}}getInstance(e){return this._instanceMap[e]||null}initInstance(e,...t){if(this._clsMap[e]){const n=new this._clsMap[e](...t);return this._instanceMap[e]=n,n.init&&n.init(),n}throw new Error(`${e}未在context中注册`)}init(e){if(!this._inited){for(let t in this._clsMap)this._clsMap.hasOwnProperty(t)&&!this._instanceMap[t]&&this.initInstance(t,e);this._inited=!0}}registry(e,t){const n=this._emitter,s=this._isMessageNameValid.bind(this),i=this;return this._clsMap[e]=class extends t{constructor(...t){super(...t),this.listeners={},this.onceListeners={},this.TAG=e,this._context=i}on(t,i){return s(t),this.listeners[t]?this.listeners[t].push(i):this.listeners[t]=[i],n.on(`${t}${a}${e}`,i),n.on(t,i)}before(e,t){s(e),i._hooks[e]?i._hooks[e].push(t):i._hooks[e]=[t]}once(t,i){return s(t),this.onceListeners[t]?this.onceListeners[t].push(i):this.onceListeners[t]=[i],n.once(`${t}${a}${e}`,i),n.once(t,i)}emit(e,...t){s(e);const r=i._hooks?i._hooks[e]:null;if(r)for(let e=0,t=r.length;e<t;e++)(0,r[e])();return n.emit(e,...t)}emitTo(e,t,...i){return s(t),n.emit(`${t}${a}${e}`,...i)}off(e,t){return s(e),n.off(e,t)}removeListeners(){const t=Object.prototype.hasOwnProperty.bind(this.listeners);for(let s in this.listeners)if(t(s)){const t=this.listeners[s]||[];for(let i=0;i<t.length;i++){const r=t[i];n.off(s,r),n.off(`${s}${a}${e}`,r)}}for(let s in this.onceListeners)if(t(s)){const t=this.onceListeners[s]||[];for(let i=0;i<t.length;i++){const r=t[i];n.off(s,r),n.off(`${s}${a}${e}`,r)}}}destroy(){if(this.removeListeners(),this.listeners={},delete i._instanceMap[e],super.destroy)return super.destroy()}},(...t)=>this.initInstance(e,...t)}destroyInstances(){Object.keys(this._instanceMap).forEach(e=>{this._instanceMap[e].destroy&&this._instanceMap[e].destroy()})}destroy(){this._emitter=null,this.allowedEvents=[],this._clsMap=null,this._context=null,this._hooks=null,this.destroyInstances()}_isMessageNameValid(e){if(!this.allowedEvents.indexOf(e)<0)throw new Error(`unregistered message name: ${e}`)}}},function(e,t,n){var s,i="object"==typeof Reflect?Reflect:null,r=i&&"function"==typeof i.apply?i.apply:function(e,t,n){return Function.prototype.apply.call(e,t,n)};s=i&&"function"==typeof i.ownKeys?i.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var a=Number.isNaN||function(e){return e!=e};function o(){o.init.call(this)}e.exports=o,o.EventEmitter=o,o.prototype._events=void 0,o.prototype._eventsCount=0,o.prototype._maxListeners=void 0;var l=10;function d(e){return void 0===e._maxListeners?o.defaultMaxListeners:e._maxListeners}function u(e,t,n,s){var i,r,a,o;if("function"!=typeof n)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof n);if(void 0===(r=e._events)?(r=e._events=Object.create(null),e._eventsCount=0):(void 0!==r.newListener&&(e.emit("newListener",t,n.listener?n.listener:n),r=e._events),a=r[t]),void 0===a)a=r[t]=n,++e._eventsCount;else if("function"==typeof a?a=r[t]=s?[n,a]:[a,n]:s?a.unshift(n):a.push(n),(i=d(e))>0&&a.length>i&&!a.warned){a.warned=!0;var l=new Error("Possible EventEmitter memory leak detected. "+a.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");l.name="MaxListenersExceededWarning",l.emitter=e,l.type=t,l.count=a.length,o=l,console&&console.warn&&console.warn(o)}return e}function f(){for(var e=[],t=0;t<arguments.length;t++)e.push(arguments[t]);this.fired||(this.target.removeListener(this.type,this.wrapFn),this.fired=!0,r(this.listener,this.target,e))}function c(e,t,n){var s={fired:!1,wrapFn:void 0,target:e,type:t,listener:n},i=f.bind(s);return i.listener=n,s.wrapFn=i,i}function h(e,t,n){var s=e._events;if(void 0===s)return[];var i=s[t];return void 0===i?[]:"function"==typeof i?n?[i.listener||i]:[i]:n?function(e){for(var t=new Array(e.length),n=0;n<t.length;++n)t[n]=e[n].listener||e[n];return t}(i):m(i,i.length)}function p(e){var t=this._events;if(void 0!==t){var n=t[e];if("function"==typeof n)return 1;if(void 0!==n)return n.length}return 0}function m(e,t){for(var n=new Array(t),s=0;s<t;++s)n[s]=e[s];return n}Object.defineProperty(o,"defaultMaxListeners",{enumerable:!0,get:function(){return l},set:function(e){if("number"!=typeof e||e<0||a(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");l=e}}),o.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},o.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||a(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},o.prototype.getMaxListeners=function(){return d(this)},o.prototype.emit=function(e){for(var t=[],n=1;n<arguments.length;n++)t.push(arguments[n]);var s="error"===e,i=this._events;if(void 0!==i)s=s&&void 0===i.error;else if(!s)return!1;if(s){var a;if(t.length>0&&(a=t[0]),a instanceof Error)throw a;var o=new Error("Unhandled error."+(a?" ("+a.message+")":""));throw o.context=a,o}var l=i[e];if(void 0===l)return!1;if("function"==typeof l)r(l,this,t);else{var d=l.length,u=m(l,d);for(n=0;n<d;++n)r(u[n],this,t)}return!0},o.prototype.addListener=function(e,t){return u(this,e,t,!1)},o.prototype.on=o.prototype.addListener,o.prototype.prependListener=function(e,t){return u(this,e,t,!0)},o.prototype.once=function(e,t){if("function"!=typeof t)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof t);return this.on(e,c(this,e,t)),this},o.prototype.prependOnceListener=function(e,t){if("function"!=typeof t)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof t);return this.prependListener(e,c(this,e,t)),this},o.prototype.removeListener=function(e,t){var n,s,i,r,a;if("function"!=typeof t)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof t);if(void 0===(s=this._events))return this;if(void 0===(n=s[e]))return this;if(n===t||n.listener===t)0==--this._eventsCount?this._events=Object.create(null):(delete s[e],s.removeListener&&this.emit("removeListener",e,n.listener||t));else if("function"!=typeof n){for(i=-1,r=n.length-1;r>=0;r--)if(n[r]===t||n[r].listener===t){a=n[r].listener,i=r;break}if(i<0)return this;0===i?n.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(n,i),1===n.length&&(s[e]=n[0]),void 0!==s.removeListener&&this.emit("removeListener",e,a||t)}return this},o.prototype.off=o.prototype.removeListener,o.prototype.removeAllListeners=function(e){var t,n,s;if(void 0===(n=this._events))return this;if(void 0===n.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==n[e]&&(0==--this._eventsCount?this._events=Object.create(null):delete n[e]),this;if(0===arguments.length){var i,r=Object.keys(n);for(s=0;s<r.length;++s)"removeListener"!==(i=r[s])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(t=n[e]))this.removeListener(e,t);else if(void 0!==t)for(s=t.length-1;s>=0;s--)this.removeListener(e,t[s]);return this},o.prototype.listeners=function(e){return h(this,e,!0)},o.prototype.rawListeners=function(e){return h(this,e,!1)},o.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):p.call(e,t)},o.prototype.listenerCount=p,o.prototype.eventNames=function(){return this._eventsCount>0?s(this._events):[]}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.CONTEXT_COMOMANDS={ON:"on",ONCE:"once",OFF:"off",EMIT:"emit",DESTROY:"destroy"}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});const s=function(){const e=new ArrayBuffer(2);return new DataView(e).setInt16(0,256,!0),256===new Int16Array(e)[0]}(),i={get device(){let e=i.os;return e.isPc?"pc":e.isTablet?"tablet":"mobile"},get browser(){let e=navigator.userAgent.toLowerCase(),t={ie:/rv:([\d.]+)\) like gecko/,firfox:/firefox\/([\d.]+)/,chrome:/chrome\/([\d.]+)/,opera:/opera.([\d.]+)/,safari:/version\/([\d.]+).*safari/};return[].concat(Object.keys(t).filter(n=>t[n].test(e)))[0]},get os(){let e=navigator.userAgent,t=/(?:Windows Phone)/.test(e),n=/(?:SymbianOS)/.test(e)||t,s=/(?:Android)/.test(e),i=/(?:Firefox)/.test(e),r=/(?:iPad|PlayBook)/.test(e)||s&&!/(?:Mobile)/.test(e)||i&&/(?:Tablet)/.test(e),a=/(?:iPhone)/.test(e)&&!r;return{isTablet:r,isPhone:a,isAndroid:s,isPc:!a&&!s&&!n,isSymbian:n,isWindowsPhone:t,isFireFox:i}},get isLe(){return s}};t.default=i},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});const s=function(){const e=new ArrayBuffer(2);return new DataView(e).setInt16(0,256,!0),256===new Int16Array(e)[0]}();t.default=s},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});class s{static decode(e){const t=[],n=e;let i=0;const r=e.length;for(;i<r;)if(n[i]<128)t.push(String.fromCharCode(n[i])),++i;else{if(n[i]<192);else if(n[i]<224){if(s._checkContinuation(n,i,1)){const e=(31&n[i])<<6|63&n[i+1];if(e>=128){t.push(String.fromCharCode(65535&e)),i+=2;continue}}}else if(n[i]<240){if(s._checkContinuation(n,i,2)){const e=(15&n[i])<<12|(63&n[i+1])<<6|63&n[i+2];if(e>=2048&&55296!=(63488&e)){t.push(String.fromCharCode(65535&e)),i+=3;continue}}}else if(n[i]<248&&s._checkContinuation(n,i,3)){let e=(7&n[i])<<18|(63&n[i+1])<<12|(63&n[i+2])<<6|63&n[i+3];if(e>65536&&e<1114112){e-=65536,t.push(String.fromCharCode(e>>>10|55296)),t.push(String.fromCharCode(1023&e|56320)),i+=4;continue}}t.push(String.fromCharCode(65533)),++i}return t.join("")}static _checkContinuation(e,t,n){let s=e;if(t+n<s.length){for(;n--;)if(128!=(192&s[++t]))return!1;return!0}return!1}}t.default=s},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});class s{constructor(e){let t=s.getDefaultInf();if(!e||"[object Object]"!==Object.prototype.toString.call(e))return t;let n=Object.assign({},t,e);Object.entries(n).forEach(([e,t])=>{this[e]=t})}static getDefaultInf(){return{dts:null,pts:null,duration:null,position:null,isRAP:!1,originDts:null}}}t.default=s},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=class{constructor(){this.startDts=-1,this.endDts=-1,this.startPts=-1,this.endPts=-1,this.originStartDts=-1,this.originEndDts=-1,this.randomAccessPoints=[],this.firstSample=null,this.lastSample=null}addRAP(e){e.isRAP=!0,this.randomAccessPoints.push(e)}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=class{constructor(e){this._type=e,this._list=[],this._lastAppendLocation=-1}get type(){return this._type}get length(){return this._list.length}isEmpty(){return 0===this._list.length}clear(){this._list=[],this._lastAppendLocation=-1}_searchNearestSegmentBefore(e){let t=this._list;if(0===t.length)return-2;let n=t.length-1,s=0,i=0,r=n,a=0;if(e<t[0].originDts)return-1;for(;i<=r;){if((s=i+Math.floor((r-i)/2))===n||e>t[s].lastSample.originDts&&e<t[s+1].originDts){a=s;break}t[s].originDts<e?i=s+1:r=s-1}return a}_searchNearestSegmentAfter(e){return this._searchNearestSegmentBefore(e)+1}append(e){let t=this._list,n=this._lastAppendLocation,s=0;-1!==n&&n<t.length&&e.originStartDts>=t[n].lastSample.originDts&&(n===t.length-1||n<t.length-1&&e.originStartDts<t[n+1].originStartDts)?s=n+1:t.length>0&&(s=this._searchNearestSegmentBefore(e.originStartDts)+1),this._lastAppendLocation=s,this._list.splice(s,0,e)}getLastSegmentBefore(e){let t=this._searchNearestSegmentBefore(e);return t>=0?this._list[t]:null}getLastSampleBefore(e){let t=this.getLastSegmentBefore(e);return null!==t?t.lastSample:null}getLastRAPBefore(e){let t=this._searchNearestSegmentBefore(e),n=this._list[t].randomAccessPoints;for(;0===n.length&&t>0;)t--,n=this._list[t].randomAccessPoints;return n.length>0?n[n.length-1]:null}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});class s{constructor(e){this.configs=Object.assign({},e),this.container=this.configs.container,this.mediaSource=null,this.sourceBuffers={},this.preloadTime=this.configs.preloadTime||1,this.onSourceOpen=this.onSourceOpen.bind(this),this.onTimeUpdate=this.onTimeUpdate.bind(this),this.onUpdateEnd=this.onUpdateEnd.bind(this),this.onWaiting=this.onWaiting.bind(this)}init(){this.mediaSource=new self.MediaSource,this.mediaSource.addEventListener("sourceopen",this.onSourceOpen),this.container.src=URL.createObjectURL(this.mediaSource),this.url=this.container.src,this.container.addEventListener("timeupdate",this.onTimeUpdate),this.container.addEventListener("waiting",this.onWaiting)}onTimeUpdate(){this.emit("TIME_UPDATE",this.container)}onWaiting(){this.emit("WAITING",this.container)}onSourceOpen(){this.addSourceBuffers()}onUpdateEnd(){this.emit("SOURCE_UPDATE_END"),this.doAppend()}addSourceBuffers(){if("open"!==this.mediaSource.readyState)return;let e,t=this._context.getInstance("PRE_SOURCE_BUFFER"),n=this._context.getInstance("TRACKS");t=t.sources;let s=!1;for(let i=0,r=Object.keys(t).length;i<r;i++){let r=Object.keys(t)[i];if("audio"===r?e=n.audioTrack:"video"===r&&(e=n.videoTrack),e){let n="audio"===r?21:40;e.meta&&e.meta.refSampleDuration&&(n=e.meta.refSampleDuration),t[r].data.length>=this.preloadTime/n&&(s=!0)}}if(s){if(Object.keys(this.sourceBuffers).length>0)return;for(let e=0,n=Object.keys(t).length;e<n;e++){let n=Object.keys(t)[e],s=t[n],i="video"===n?"video/mp4;codecs="+s.mimetype:"audio/mp4;codecs="+s.mimetype,r=this.mediaSource.addSourceBuffer(i);this.sourceBuffers[n]=r,r.addEventListener("updateend",this.onUpdateEnd),this.doAppend()}}}doAppend(){let e=this._context.getInstance("PRE_SOURCE_BUFFER");if(e)for(let t=0;t<Object.keys(this.sourceBuffers).length;t++){let n=Object.keys(this.sourceBuffers)[t],s=this.sourceBuffers[n];if(!s.updating){let t=e.sources[n];if(t&&!t.inited)s.appendBuffer(t.init.buffer.buffer),t.inited=!0;else if(t){let e=t.data.shift();e&&s.appendBuffer(e.buffer.buffer)}}}}endOfStream(){const{readyState:e,activeSourceBuffers:t}=this.mediaSource;if("open"===e&&0===t.length)try{this.mediaSource.endOfStream()}catch(e){}}remove(e,t=0){for(let n=0;n<Object.keys(this.sourceBuffers).length;n++){let s=this.sourceBuffers[Object.keys(this.sourceBuffers)[n]];s.updating||s.remove(t,e)}}removeBuffers(){const e=[];for(let t=0;t<Object.keys(this.sourceBuffers).length;t++){let n,i=this.sourceBuffers[Object.keys(this.sourceBuffers)[t]];i.removeEventListener("updateend",this.onUpdateEnd),i.updating?n=new Promise(e=>{const t=function(){let n=3;const r=()=>{i.updating?n>0?(setTimeout(r,200),n--):e():(s.clearBuffer(i),e())};setTimeout(r,200),i.removeEventListener("updateend",t)};i.addEventListener("updateend",t)}):(s.clearBuffer(i),n=Promise.resolve()),e.push(n)}return Promise.all(e)}destroy(){return this.removeBuffers().then(()=>{for(let e=0;e<Object.keys(this.sourceBuffers).length;e++){let t=this.sourceBuffers[Object.keys(this.sourceBuffers)[e]];this.mediaSource.removeSourceBuffer(t),delete this.sourceBuffers[Object.keys(this.sourceBuffers)[e]]}this.container.removeEventListener("timeupdate",this.onTimeUpdate),this.container.removeEventListener("waiting",this.onWaiting),this.mediaSource.removeEventListener("sourceopen",this.onSourceOpen),this.endOfStream(),window.URL.revokeObjectURL(this.url),this.url=null,this.configs={},this.container=null,this.mediaSource=null,this.sourceBuffers={},this.preloadTime=1})}static clearBuffer(e){const t=e.buffered;let n=.1;for(let e=0,s=t.length;e<s;e++)n=t.end(e);try{e.remove(0,n)}catch(e){}}}t.default=s},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});class s{constructor(e){if(!(e instanceof ArrayBuffer))throw new Error("data is invalid");this.buffer=e,this.dataview=new DataView(e),this.dataview.position=0}get length(){return this.buffer.byteLength}set position(e){this.dataview.position=e}get position(){return this.dataview.position}back(e){this.position-=e}skip(e){let t=Math.floor(e/4),n=e%4;for(let e=0;e<t;e++)s.readByte(this.dataview,4);n>0&&s.readByte(this.dataview,n)}static readByte(e,t,n){let s;switch(t){case 1:s=n?e.getInt8(e.position):e.getUint8(e.position);break;case 2:s=n?e.getInt16(e.position):e.getUint16(e.position);break;case 3:if(n)throw new Error("not supported for readByte 3");s=e.getUint8(e.position)<<16,s|=e.getUint8(e.position+1)<<8,s|=e.getUint8(e.position+2);break;case 4:s=n?e.getInt32(e.position):e.getUint32(e.position);break;case 8:if(n)throw new Error("not supported for readBody 8");s=e.getUint32(e.position)<<32,s|=e.getUint32(e.position+4);break;default:s=""}return e.position+=t,s}readUint8(){return s.readByte(this.dataview,1)}readUint16(){return s.readByte(this.dataview,2)}readUint24(){return s.readByte(this.dataview,3)}readUint32(){return s.readByte(this.dataview,4)}readUint64(){return s.readByte(this.dataview,8)}readInt8(){return s.readByte(this.dataview,1,!0)}readInt16(){return s.readByte(this.dataview,2,!0)}readInt32(){return s.readByte(this.dataview,4,!0)}writeUint32(e){return new Uint8Array([e>>>24&255,e>>>16&255,e>>>8&255,255&e])}}t.default=s},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s,i=(s=n(25))&&s.__esModule?s:{default:s};t.default=class{constructor(e){this.buffer=e||new Uint8Array(0)}write(...e){e.forEach(e=>{this.buffer=(0,i.default)(Uint8Array,this.buffer,e)})}static writeUint32(e){return new Uint8Array([e>>24,e>>16&255,e>>8&255,255&e])}static readAsInt(e){let t="";return e.forEach(e=>{t+=function(e){return e.toString(16).padStart(2,"0")}(e)}),parseInt(t,16)}}},function(e,t,n){var s,i=(s=n(26))&&s.__esModule?s:{default:s};e.exports=i.default},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){for(var t=0,n=arguments.length,s=Array(n>1?n-1:0),i=1;i<n;i++)s[i-1]=arguments[i];var r=!0,a=!1,o=void 0;try{for(var l,d=s[Symbol.iterator]();!(r=(l=d.next()).done);r=!0){var u=l.value;t+=u.length}}catch(e){a=!0,o=e}finally{try{!r&&d.return&&d.return()}finally{if(a)throw o}}var f=new e(t),c=0,h=!0,p=!1,m=void 0;try{for(var _,g=s[Symbol.iterator]();!(h=(_=g.next()).done);h=!0){var x=_.value;f.set(x,c),c+=x.length}}catch(e){p=!0,m=e}finally{try{!h&&g.return&&g.return()}finally{if(p)throw m}}return f}},function(e,t,n){var s;Object.defineProperty(t,"__esModule",{value:!0});const i=((s=n(4))&&s.__esModule?s:{default:s}).default.CRYTO_EVENTS;t.default=class{constructor(e){this.inputBuffer=e.inputbuffer,this.outputBuffer=e.outputbuffer,this.key=e.key,this.iv=e.iv,this.method=e.method,this.crypto=window.crypto||window.msCrypto}init(){this.on(i.START_DECRYPT,this.decript.bind(this))}decript(){this.aeskey?this.decriptData():this.crypto.subtle.importKey("raw",this.key.buffer,{name:"AES-CBC"},!1,["encrypt","decrypt"]).then(e=>{this.aeskey=e,this.decriptData()})}decriptData(){let e=this._context.getInstance(this.inputBuffer),t=this._context.getInstance(this.outputBuffer),n=e.shift();n&&this.crypto.subtle.decrypt({name:"AES-CBC",iv:this.iv.buffer},this.aeskey,n).then(e=>{t.push(new Uint8Array(e)),this.emit(i.DECRYPTED),this.decriptData(n)})}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s=u(n(29)),i=u(n(36)),r=n(39),a=n(9),o=n(0),l=n(7),d=u(n(2));function u(e){return e&&e.__esModule?e:{default:e}}const f=o.EVENTS.REMUX_EVENTS,c=o.EVENTS.DEMUX_EVENTS,h=o.EVENTS.LOADER_EVENTS,p="FLVController";class m{warn(){}}const _="FLV_ERROR";class g{constructor(e){this.TAG=p,this._player=e,this.state={initSegmentArrived:!1,range:{start:0,end:""},rangeSupport:!0}}static findFilePosition(e,t){for(let n=0,s=t.times.length;n<s;n++){const i=t.times[n],r=n+1<s?t.times[n+1]:Number.MAX_SAFE_INTEGER;if(i<=e&&e<=r)return t.filepositions[n]}return""}init(){this._context.registry("FETCH_LOADER",r.FetchLoader),this._context.registry("LOADER_BUFFER",a.XgBuffer),this._context.registry("FLV_DEMUXER",s.default),this._context.registry("TRACKS",a.Tracks),this._context.registry("MP4_REMUXER",i.default.Mp4Remuxer),this._context.registry("PRE_SOURCE_BUFFER",a.PreSource),this._context.registry("COMPATIBILITY",l.Compatibility),this._context.registry("LOGGER",m),this.mse=this._context.registry("MSE",o.Mse)({container:this._player.video}),this.initListeners(),setTimeout(()=>{this.loadMeta()},0)}initListeners(){this.on(h.LOADER_DATALOADED,this._handleLoaderDataLoaded.bind(this)),this.on(h.LOADER_ERROR,this._handleNetworkError.bind(this)),this.on(c.MEDIA_INFO,this._handleMediaInfo.bind(this)),this.on(c.METADATA_PARSED,this._handleMetadataParsed.bind(this)),this.on(c.DEMUX_COMPLETE,this._handleDemuxComplete.bind(this)),this.on(c.DEMUX_ERROR,this._handleDemuxError.bind(this)),this.on(f.INIT_SEGMENT,this._handleAppendInitSegment.bind(this)),this.on(f.MEDIA_SEGMENT,this._handleMediaSegment.bind(this))}_handleMediaInfo(){this._context.onMetaData||this.emit(c.DEMUX_ERROR,new Error("failed to get mediainfo"));const e=this._context.getInstance("LOADER_BUFFER"),t=this._context.getInstance("FETCH_LOADER");this.isSeekable&&(t.cancel(),this.state.range={start:0,end:e.historyLen-1},setTimeout(()=>{this.loadNext(0)}))}_handleLoaderDataLoaded(){this.emitTo("FLV_DEMUXER",c.DEMUX_START)}_handleMetadataParsed(e){this.emit(f.REMUX_METADATA,e)}_handleDemuxComplete(){this.emit(f.REMUX_MEDIA)}_handleAppendInitSegment(){this.state.initSegmentArrived=!0,this.mse.addSourceBuffers()}_handleMediaSegment(){this.mse.addSourceBuffers(),this.mse.doAppend()}_handleNetworkError(e,t){this._player.emit("error",new d.default.Errors("network",this._player.config.url)),this._onError(h.LOADER_ERROR,e,t,!0)}_handleDemuxError(e,t,n){void 0===n&&(n=!1),this._player.emit("error",new d.default.Errors("parse",this._player.config.url)),this._onError(h.LOADER_ERROR,e,t,n)}_onError(e,t,n,s){let i={errorType:e,errorDetails:`[${t}]: ${n.message}`,errorFatal:s||!1};this._player.emit(_,i)}seek(e){if(!this._context.onMetaData)return void this.loadMeta();if(!this.isSeekable)return;this._context.getInstance("LOADER_BUFFER").clear();const{preloadTime:t=15}=this._player.config,n=this.getSeekRange(e,t);this.state.range=n,this.compat&&this.compat.reset(),this.loadData()}loadNext(e){this._context.onMetaData&&(this.loader.loading||this.getNextRange(e)&&this.loadData())}loadData(){const{start:e,end:t}=this.state.range;this.emit(h.LADER_START,this._player.config.url,{headers:{method:"get",Range:`bytes=${e}-${t}`}})}loadMeta(){this.loader.load(this._player.config.url,{headers:{Range:"bytes=0-"}}).catch(()=>{this.state.rangeSupport=!1,this.loadFallback()})}loadFallback(){this.loader.load(this._player.config.url).catch(()=>{this._player.emit("error",new d.default.Errors("network",this._player.config.url))})}getSeekRange(e,t){const{keyframes:n}=this._context.onMetaData,s=this._context.mediaInfo.duration,i=e,r=e+t,a=g.findFilePosition(i,n);return r>=s||i>=s?{start:a,end:""}:{start:a,end:g.findFilePosition(r,n)}}getNextRange(e){if(""===this.state.range.end)return;const{end:t}=this.getSeekRange(e,this.config.preloadTime||15);return t<=this.state.range.end&&""!==t?void 0:(this.state.range={start:this.state.range.end+1,end:t},!0)}destroy(){this._player=null,this.mse=null,this.state={initSegmentArrived:!1,range:{start:0,end:""},rangeSupport:!0}}get isSeekable(){return!!this.state.rangeSupport&&(!this._context||!this._context.mediaInfo.isComplete()||null!==this._context.mediaInfo.keyframes&&void 0!==this._context.mediaInfo.keyframes)}get config(){return this._player.config}get loader(){return this._context.getInstance("FETCH_LOADER")}get compat(){return this._context.getInstance("COMPATIBILITY")}}t.default=g},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s,i=n(0),r=n(7),a=n(9),o=(s=n(35))&&s.__esModule?s:{default:s};const l=i.EVENTS.DEMUX_EVENTS;class d{constructor(){this._firstFragmentLoaded=!1,this._trackNum=0,this._hasScript=!1}init(){this.on(l.DEMUX_START,this.doParseFlv.bind(this))}static isFlvFile(e){return!(70!==e[0]||76!==e[1]||86!==e[2]||1!==e[3])}static getPlayType(e){const t={hasVideo:!1,hasAudio:!1};return!0&e&&(t.hasVideo=!0),!0&e&&(t.hasAudio=!0),t}doParseFlv(){if(this._firstFragmentLoaded){if(this.loaderBuffer.length<11)return;let e,t=1e5;do{e=this._parseFlvTag()}while(e&&t-- >0);this.emit(l.DEMUX_COMPLETE)}else{if(this.loaderBuffer.length<13)return;const e=this.loaderBuffer.shift(13);this.parseFlvHeader(e),this.doParseFlv()}}parseFlvHeader(e){if(d.isFlvFile(e)){this._firstFragmentLoaded=!0;const t=d.getPlayType(e[4]);t.hasVideo&&this.initVideoTrack(),t.hasAudio&&this.initAudioTrack()}else this.emit(l.DEMUX_ERROR,new Error("invalid flv file")),this.doParseFlv();this.doParseFlv()}initVideoTrack(){this._trackNum++;let e=new a.VideoTrack;e.meta=new i.VideoTrackMeta,e.id=e.meta.id=this._trackNum,this.tracks.videoTrack=e}initAudioTrack(){this._trackNum++;let e=new a.AudioTrack;e.meta=new i.AudioTrackMeta,e.id=e.meta.id=this._trackNum,this.tracks.audioTrack=e}_parseFlvTag(){if(this.loaderBuffer.length<11)return null;let e=this._parseFlvTagHeader();return e&&this._processChunk(e),e}_parseFlvTagHeader(){let e=0,t={},n=this.loaderBuffer.toInt(e,1);if(e+=1,t.filtered=(32&n)>>>5,t.tagType=31&n,t.datasize=this.loaderBuffer.toInt(e,3),e+=3,8!==t.tagType&&9!==t.tagType&&11!==t.tagType&&18!==t.tagType||0!==this.loaderBuffer.toInt(8,3))return this.loaderBuffer&&this.loaderBuffer.length>0&&this.loaderBuffer.shift(1),this.emit(l.DEMUX_ERROR,this.TAG,new Error("tagType "+t.tagType),!1),null;if(this.loaderBuffer.length<t.datasize+15)return null;this.loaderBuffer.shift(4);let s=this.loaderBuffer.toInt(0,3);this.loaderBuffer.shift(3);let i=this.loaderBuffer.shift(1)[0];return i>0&&(s+=16777216*i),t.dts=s,this.loaderBuffer.shift(3),t}_processChunk(e){switch(e.tagType){case 18:this._parseScriptData(e);break;case 8:this._parseAACData(e);break;case 9:this._parseHevcData(e);break;case 11:this.loaderBuffer.shift(3);break;default:this.loaderBuffer.shift(1)}}_parseScriptData(e){let t=this.tracks.audioTrack,n=this.tracks.videoTrack,s=this.loaderBuffer.shift(e.datasize);const i=(new o.default).resolve(s,s.length),r=this._context.onMetaData=i?i.onMetaData:void 0;if(this._context.mediaInfo.duration=r.duration,this._context.mediaInfo.hasVideo=r.hasVideo,this._context.mediaInfo.hsaAudio=r.hasAudio,this._datasizeValidator(e.datasize)&&(this.emit(l.MEDIA_INFO),this._hasScript=!0),t&&!t.hasSpecificConfig){let e=t.meta;switch(r.audiosamplerate&&(e.sampleRate=r.audiosamplerate),r.audiochannels&&(e.channelCount=r.audiochannels),r.audiosamplerate){case 44100:e.sampleRateIndex=4;break;case 22050:e.sampleRateIndex=7;break;case 11025:e.sampleRateIndex=10}}if(n&&!n.hasSpecificConfig){let e=n.meta;if("number"==typeof r.framerate){let t=Math.floor(1e3*r.framerate);if(t>0){let n=t/1e3;e.frameRate||(e.frameRate={}),e.frameRate.fixed=!0,e.frameRate.fps=n,e.frameRate.fps_num=t,e.frameRate.fps_den=1e3}}}}_aacSequenceHeaderParser(e){let t={hasSpecificConfig:!0};t.objectType=e[1]>>>3,t.sampleRateIndex=(7&e[1])<<1|e[2]>>>7,t.audiosamplerate=this._switchAudioSampleRate(t.sampleRateIndex),t.channelCount=(120&e[2])>>>3,t.frameLength=(4&e[2])>>>2,t.dependsOnCoreCoder=(2&e[2])>>>1,t.extensionFlagIndex=1&e[2],t.codec=`mp4a.40.${t.objectType}`;let n,s,i=window.navigator.userAgent.toLowerCase(),r=t.sampleRateIndex;return-1!==i.indexOf("firefox")?t.sampleRateIndex>=6?(t.objectType=5,s=new Array(4),n=r-3):(t.objectType=2,s=new Array(2),n=r):-1!==i.indexOf("android")?(t.objectType=2,s=new Array(2),n=r):(t.objectType=5,n=t.sampleRateIndex,s=new Array(4),t.sampleRateIndex>=6?n=t.sampleRateIndex-3:1===t.channelCount&&(t.objectType=2,s=new Array(2),n=t.sampleRateIndex)),s[0]=t.objectType<<3,s[0]|=(15&t.sampleRateIndex)>>>1,s[1]=(15&t.sampleRateIndex)<<7,s[1]|=(15&t.channelCount)<<3,5===t.objectType&&(s[1]|=(15&n)>>>1,s[2]=(1&n)<<7,s[2]|=8,s[3]=0),t.config=s,t}_parseAACData(e){let t=this.tracks.audioTrack;if(!t)return;let n=t.meta;n||(t.meta=new i.AudioTrackMeta,n=t.meta);let s=this.loaderBuffer.shift(1)[0];e.data=this.loaderBuffer.shift(e.datasize-1);let r=(240&s)>>>4;t.format=r,10!==r&&this.emit(l.DEMUX_ERROR,new Error(`invalid audio format: ${r}`)),10!==r||this._hasAudioSequence||(n.sampleRate=this._switchAudioSamplingFrequency(s),n.sampleRateIndex=(12&s)>>>2,n.frameLenth=(2&s)>>>1,n.channelCount=1&s,n.refSampleDuration=Math.floor(1024/n.audioSampleRate*n.timescale));let a=n.audioSampleRate,o=n.sampleRateIndex,d=n.refSampleDuration;delete e.tagType;let u=this._datasizeValidator(e.datasize);if(0===e.data[0]){let t=this._aacSequenceHeaderParser(e.data);a=t.audiosamplerate||n.audioSampleRate,o=t.sampleRateIndex||n.sampleRateIndex,d=Math.floor(1024/a*n.timescale),n.channelCount=t.channelCount,n.sampleRate=a,n.sampleRateIndex=o,n.refSampleDuration=d,n.duration=this._context.mediaInfo.duration*n.timescale,n.config=t.config;const s=this._context.mediaInfo.audio;s.codec=t.codec,s.channelCount=t.channelCount,s.sampleRate=a,s.sampleRateIndex=t.audioSampleRateIndex,this._hasScript&&!this._hasAudioSequence?this.emit(l.METADATA_PARSED,"audio"):this._hasScript&&this._hasAudioSequence&&this.emit(l.AUDIO_METADATA_CHANGE),this._hasAudioSequence=!0,this._metaChange=!0}else this._metaChange&&(e.options={meta:t.meta},this._metaChange=!1),e.data=e.data.slice(1,e.data.length),t.samples.push(e);u||this.emit(l.DEMUX_ERROR,this.TAG,new Error("TAG length error at "+e.datasize),!1)}_parseHevcData(e){let t=this.loaderBuffer.shift(1)[0];e.frameType=(240&t)>>>4,e.isKeyframe=1===e.frameType;let n=15&t;if(this.tracks.videoTrack.codecID=n,e.avcPacketType=this.loaderBuffer.shift(1)[0],e.cts=this.loaderBuffer.toInt(0,3),this.loaderBuffer.shift(3),12===n){const t=this.loaderBuffer.shift(e.datasize-5);if(e.data=t,0!==Number.parseInt(e.avcPacketType)){this._datasizeValidator(e.datasize)||this.emit(l.DEMUX_ERROR,this.TAG,new Error(`invalid video tag datasize: ${e.datasize}`),!1);let t={},n=0;for(t.cts=e.cts,t.dts=e.dts;e.data.length>n;){let s=e.data.slice(Number.parseInt(n),4+n);t.size=s[3],t.size+=256*s[2],t.size+=256*s[1]*256,t.size+=256*s[0]*256*256,n+=4,t.data=e.data.slice(Number.parseInt(n),t.size+n),n+=t.size,this.tracks.videoTrack.samples.push(t),this.emit(l.METADATA_PARSED,"video")}}else 0===Number.parseInt(e.avcPacketType)&&(this._datasizeValidator(e.datasize)?this.emit(l.METADATA_PARSED,"video"):this.emit(l.DEMUX_ERROR,this.TAG,new Error(`invalid video tag datasize: ${e.datasize}`),!1))}else if(7===n){let t=this.loaderBuffer.shift(e.datasize-5);if(0===t[4]&&0===t[5]&&0===t[6]&&1===t[7]){let e=0;for(let n=0;n<4;n++)e=256*e+t[n];e-=4,(t=t.slice(4,t.length))[3]=e%256,e=(e-t[3])/256,t[2]=e%256,e=(e-t[2])/256,t[1]=e%256,t[0]=(e-t[1])/256}if(e.data=t,0===e.avcPacketType)this._avcSequenceHeaderParser(e.data),this._datasizeValidator(e.datasize)&&(this._hasScript&&!this._hasVideoSequence?this.emit(l.METADATA_PARSED,"video"):this._hasScript&&this._hasVideoSequence&&this.emit(l.VIDEO_METADATA_CHANGE),this._hasVideoSequence=!0),this._metaChange=!0;else{if(!this._datasizeValidator(e.datasize))return void this.emit(l.DEMUX_ERROR,this.TAG,new Error(`invalid video tag datasize: ${e.datasize}`),!1);this._metaChange&&(e.options={meta:Object.assign({},this.tracks.videoTrack.meta)},this._metaChange=!1),this.tracks.videoTrack.samples.push(e)}}else this.emit(l.DEMUX_ERROR,this.TAG,new Error(`video codeid is ${n}`),!1),e.data=this.loaderBuffer.shift(e.datasize-1),this._datasizeValidator(e.datasize)||this.emit(l.DEMUX_ERROR,this.TAG,new Error(`invalid video tag datasize: ${e.datasize}`),!1),this.tracks.videoTrack.samples.push(e),this.emit(l.DEMUX_COMPLETE);delete e.tagType}_avcSequenceHeaderParser(e){let t=this.tracks.videoTrack;if(!t)return;let n=0;t.meta||(t.meta=new i.VideoTrackMeta);let s=t.meta;s.configurationVersion=e[0],s.avcProfileIndication=e[1],s.profileCompatibility=e[2],s.avcLevelIndication=e[3]/10,s.nalUnitLength=1+(3&e[4]);let a=31&e[5];n=6;let o={};for(let t=0;t<a;t++){let t=255*e[n]+e[n+1];n+=2;let i=new Uint8Array(t);for(let s=0;s<t;s++)i[s]=e[n+s];let a="avc1.";for(let e=1;e<4;e++){let t=i[e].toString(16);t.length<2&&(t="0"+t),a+=t}s.codec=a,n+=t,this.tracks.videoTrack.meta.sps=i,o=r.SpsParser.parseSPS(i)}let l=e[n];n++;for(let t=0;t<l;t++){let t=255*e[n]+e[n+1];n+=2;let s=new Uint8Array(t);for(let i=0;i<t;i++)s[i]=e[n+i];n+=t,this.tracks.videoTrack.meta.pps=s}Object.assign(s,r.SpsParser.toVideoMeta(o));const d=this._context.mediaInfo.video;d.codec=s.codec,d.profile=s.profile,d.level=s.level,d.chromaFormat=s.chromaFormat,d.frameRate=s.frameRate,d.parRatio=s.parRatio,d.width=d.width===s.presentWidth?d.width:s.presentWidth,d.height=d.height===s.presentHeight?d.width:s.presentHeight,s.duration=this._context.mediaInfo.duration*s.timescale,s.avcc=new Uint8Array(e.length),s.avcc.set(e),t.meta=s}_switchAudioSampleRate(e){return[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350][e]}_switchAudioSamplingFrequency(e){return[5500,11025,22050,44100,48e3][(12&e)>>>2]}_switchAudioChannel(e){return[1,2][1&e]}_datasizeValidator(e){let t=this.loaderBuffer.toInt(0,4);return this.loaderBuffer.shift(4),t===e+11}get loaderBuffer(){const e=this._context.getInstance("LOADER_BUFFER");if(e)return e;this.emit(l.DEMUX_ERROR,new Error("找不到 loaderBuffer 实例"))}get tracks(){return this._context.getInstance("TRACKS")}get logger(){return this._context.getInstance("LOGGER")}}t.default=d},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s,i=(s=n(8))&&s.__esModule?s:{default:s};class r{static getNalunits(e){if(e.length-e.position<4)return[];let t=e.dataview,n=e.position;return 1===t.getInt32(n)||0===t.getInt16(n)&&1===t.getInt8(n+2)?r.getAnnexbNals(e):r.getAvccNals(e)}static getAnnexbNals(e){let t=[],n=r.getHeaderPositionAnnexB(e),s=n.pos,i=s;for(;s<e.length-4;){let a=e.buffer.slice(s,s+n.headerLength);n.pos===e.position&&e.skip(n.headerLength),i=(n=r.getHeaderPositionAnnexB(e)).pos;let o={header:a,body:new Uint8Array(e.buffer.slice(s+a.byteLength,i))};r.analyseNal(o),t.push(o),e.skip(i-e.position),s=i}return t}static getAvccNals(e){let t=[];for(;e.position<e.length-4;){let n=e.dataview.getInt32();if(!(e.length-e.position>=n))break;{let s=e.buffer.slice(e.position,e.position+4);e.skip(4);let i=e.buffer.slice(e.position,e.position+n);e.skip(n);let a={header:s,body:i};r.analyseNal(a),t.push(a)}}return t}static analyseNal(e){switch(31&e.body[0]){case 1:e.ndr=!0;break;case 5:e.idr=!0;break;case 6:break;case 7:e.sps=i.default.parseSPS(e.body);break;case 8:e.pps=!0}}static getHeaderPositionAnnexB(e){let t=e.position,n=0;for(;3!==n&&4!==n&&t<e.length-4;)0===e.dataview.getInt16(t)?1===e.dataview.getInt16(t+2)?n=4:1===e.dataview.getInt8(t+2)?n=3:t++:t++;return t===e.length-4&&(0===e.dataview.getInt16(t)?1===e.dataview.getInt16(t+2)&&(n=4):(t++,0===e.dataview.getInt16(t)&&1===e.dataview.getInt8(t)?n=3:t=e.length)),{pos:t,headerLength:n}}static getAvcc(e,t){let n=new Uint8Array(e.byteLength+t.byteLength+11);n[0]=1,n[1]=e[1],n[2]=e[2],n[3]=e[3],n[4]=255,n[5]=225;let s=6;return n.set(new Uint8Array([e.byteLength>>>8&255,255&e.byteLength]),s),s+=2,n.set(e,s),n[s+=e.byteLength]=1,s++,n.set(new Uint8Array([t.byteLength>>>8&255,255&t.byteLength]),s),s+=2,n.set(t,s),n}}t.default=r},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=class{constructor(e){this.TAG="Golomb",this._buffer=e,this._bufferIndex=0,this._totalBytes=e.byteLength,this._totalBits=8*e.byteLength,this._currentWord=0,this._currentWordBitsLeft=0}destroy(){this._buffer=null}_fillCurrentWord(){let e=this._totalBytes-this._bufferIndex,t=Math.min(4,e),n=new Uint8Array(4);n.set(this._buffer.subarray(this._bufferIndex,this._bufferIndex+t)),this._currentWord=new DataView(n.buffer).getUint32(0),this._bufferIndex+=t,this._currentWordBitsLeft=8*t}readBits(e){let t=Math.min(this._currentWordBitsLeft,e),n=this._currentWord>>>32-t;if(e>32)throw new Error("Cannot read more than 32 bits at a time");return this._currentWordBitsLeft-=t,this._currentWordBitsLeft>0?this._currentWord<<=t:this._totalBytes-this._bufferIndex>0&&this._fillCurrentWord(),(t=e-t)>0&&this._currentWordBitsLeft?n<<t|this.readBits(t):n}readBool(){return 1===this.readBits(1)}readByte(){return this.readBits(8)}_skipLeadingZero(){let e;for(e=0;e<this._currentWordBitsLeft;e++)if(0!=(this._currentWord&2147483648>>>e))return this._currentWord<<=e,this._currentWordBitsLeft-=e,e;return this._fillCurrentWord(),e+this._skipLeadingZero()}readUEG(){let e=this._skipLeadingZero();return this.readBits(e+1)-1}readSEG(){let e=this.readUEG();return 1&e?e+1>>>1:-1*(e>>>1)}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s,i=n(0),r=(s=n(33))&&s.__esModule?s:{default:s};const{REMUX_EVENTS:a,DEMUX_EVENTS:o}=i.EVENTS;class l{constructor(){this.nextAudioDts=0,this.nextVideoDts=0,this.lastAudioSamplesLen=0,this.lastVideoSamplesLen=0,this.lastVideoDts=void 0,this.lastAudioDts=void 0,this.allAudioSamplesCount=0,this.allVideoSamplesCount=0,this._firstAudioSample=null,this._firstVideoSample=null,this.filledAudioSamples=[],this.filledVideoSamples=[],this._videoLargeGap=0,this._audioLargeGap=0}init(){this.before(a.REMUX_MEDIA,this.doFix.bind(this))}reset(){this.nextAudioDts=null,this.nextVideoDts=null,this.lastAudioSamplesLen=0,this.lastVideoSamplesLen=0,this.lastVideoDts=void 0,this.lastAudioDts=void 0,this.filledAudioSamples=[],this.filledVideoSamples=[]}doFix(){const{isFirstAudioSamples:e,isFirstVideoSamples:t}=this.getFirstSample();this.recordSamplesCount(),this._firstVideoSample&&this.fixRefSampleDuration(this.videoTrack.meta,this.videoTrack.samples),this._firstAudioSample&&this.fixRefSampleDuration(this.audioTrack.meta,this.audioTrack.samples);const{changed:n,changedIdx:s}=l.detactChangeStream(this.videoTrack.samples);n&&!e?this.fixChangeStreamVideo(s):this.doFixVideo(t);const{changed:i,changedIdx:r}=l.detactChangeStream(this.audioTrack.samples);i?this.fixChangeStreamAudio(r):this.doFixAudio(e)}doFixVideo(e,t){let{samples:n,meta:s}=this.videoTrack;if(s.frameRate&&!1===s.frameRate.fixed)return;if(!n||!n.length||!this._firstVideoSample)return;const i=n[0],r=n.length;this._videoLargeGap>0&&l.doFixLargeGap(n,this._videoLargeGap),i.dts!==this._firstVideoSample.dts&&(t||l.detectLargeGap(this.nextVideoDts,i))&&(t&&(this.nextVideoDts=t),this._videoLargeGap=this.nextVideoDts-i.dts,l.doFixLargeGap(n,this._videoLargeGap));const a=i.dts;if(e&&this._firstAudioSample){const e=this._firstVideoSample.dts,t=e-this._firstAudioSample.dts;if(t>2*s.refSampleDuration){const r=Math.floor(t/s.refSampleDuration);for(let t=0;t<r;t++){const r=Object.assign({},i);r.dts=e-(t+1)*s.refSampleDuration,r.pts=r.dts+r.cts,n.unshift(r),this.filledVideoSamples.push({dts:r.dts,size:r.data.byteLength})}}}let o;if(this.nextVideoDts){o=a-this.nextVideoDts;const e=Math.abs(o);if(o>2*s.refSampleDuration){const e=Math.floor(o/s.refSampleDuration);for(let t=0;t<e;t++){const e=Object.assign({},n[0]),i=a-(t+1)*s.refSampleDuration;e.dts=i>this.nextVideoDts?i:this.nextVideoDts,e.pts=e.dts+e.cts,this.videoTrack.samples.unshift(e),this.filledVideoSamples.push({dts:e.dts,size:e.data.byteLength})}}else e<=s.refSampleDuration&&e>0?(n[0].dts=this.nextVideoDts,n[0].originDts=n[0].dts,n[0].cts=void 0!==n[0].cts?n[0].cts:n[0].pts-n[0].dts,n[0].pts=n[0].dts+n[0].cts):o<0&&l.doFixLargeGap(n,-1*o)}const d=n[n.length-1].dts,u=n.length>=2?d-n[n.length-2].dts:s.refSampleDuration;this.lastVideoSamplesLen=r,this.nextVideoDts=d+u,this.lastVideoDts=d;for(let e=0,t=n.length;e<t;e++){const t=n[e],i=n[e+1];if(!i)break;const r=i.dts-t.dts;if(r>2*s.refSampleDuration){let a=Math.floor(r/s.refSampleDuration),o=0;for(;o<a;){const r=Object.assign({},i);r.dts=t.dts+(o+1)*s.refSampleDuration,r.pts=r.dts+r.cts,r<i.dts&&(n.splice(e,0,r),this.filledVideoSamples.push({dts:r.dts,size:r.data.byteLength})),o++,e++}}}this.videoTrack.samples=n}doFixAudio(e,t){let{samples:n,meta:s}=this.audioTrack;if(!n||!n.length)return;const i=n.length,a=r.default.getSilentFrame(s.codec,s.channelCount),o=this._firstAudioSample,d=n[0];if(this._audioLargeGap>0&&l.doFixLargeGap(n,this._audioLargeGap),d.dts!==this._firstAudioSample.dts&&(t||l.detectLargeGap(this.nextAudioDts,d))&&(t&&(this.nextAudioDts=t),this._audioLargeGap=this.nextAudioDts-d.dts,l.doFixLargeGap(n,this._audioLargeGap)),this._firstVideoSample&&e){const e=this._firstVideoSample.pts?this._firstVideoSample.pts:this._firstVideoSample.dts+this._firstVideoSample.cts;if(o.dts-e>s.refSampleDuration){const t=Math.floor((o.dts-e)/s.refSampleDuration);for(let e=0;e<t;e++){const t={data:a,datasize:a.byteLength,dts:o.dts-(e+1)*s.refSampleDuration,filtered:0};n.unshift(t),this.filledAudioSamples.push({dts:t.dts,size:t.data.byteLength})}}}let u;const f=n[0].dts;if(this.nextAudioDts){u=f-this.nextAudioDts;const e=Math.abs(u);if(e>s.refSampleDuration&&1===i&&1===this.lastAudioSamplesLen&&(s.refSampleDurationFixed=void 0),u>2*s.refSampleDuration)if(1===i&&1===this.lastAudioSamplesLen)s.refSampleDurationFixed=void 0!==s.refSampleDurationFixed?s.refSampleDurationFixed+u:s.refSampleDuration+u;else{const e=Math.floor(u/s.refSampleDuration);for(let t=0;t<e;t++){const e=f-(t+1)*s.refSampleDuration,i=Object.assign({},n[0],{dts:e>this.nextAudioDts?e:this.nextAudioDts});this.filledAudioSamples.push({dts:i.dts,size:i.data.byteLength}),this.audioTrack.samples.unshift(i)}}else e<=s.refSampleDuration&&e>0?(n[0].dts=this.nextAudioDts,n[0].pts=this.nextAudioDts):u<0&&l.doFixLargeGap(n,-1*u)}const c=n[n.length-1].dts,h=n.length>=2?c-n[n.length-2].dts:s.refSampleDuration;this.lastAudioSamplesLen=i,this.nextAudioDts=s.refSampleDurationFixed?c+s.refSampleDurationFixed:c+h,this.lastAudioDts=c;for(let e=0,t=n.length;e<t;e++){const t=n[e],s=n[e+1];if(!s)break;const i=s.dts-t.dts;n[e].duration=i}this.audioTrack.samples=l.sortAudioSamples(n)}fixChangeStreamVideo(e){const{samples:t,meta:n}=this.videoTrack,s=0===e?this.getStreamChangeStart(t[0]):t[e-1].dts,i=t[e].dts;if(Math.abs(s-i)<=2*n.refSampleDuration)return t[e].options?t[e].options.isContinue=!0:t[e].options={isContinue:!0},this.doFixVideo(!1);const r=t.slice(0,e),a=t.slice(e),o=t[0],l=a[0].dts-o.dts,d=o.options&&o.options.start+l?o.options.start:null;this.videoTrack.samples=t.slice(0,e),this.doFixVideo(!1),this.videoTrack.samples=t.slice(e),this.doFixVideo(!1,d),this.videoTrack.samples=r.concat(a)}fixChangeStreamAudio(e){const{samples:t,meta:n}=this.audioTrack,s=0===e?this.getStreamChangeStart(t[0]):t[e-1].dts,i=t[e].dts;if(Math.abs(s-i)<=2*n.refSampleDuration)return t[e].options?t[e].options.isContinue=!0:t[e].options={isContinue:!0},this.doFixAudio(!1);const r=t.slice(0,e),a=t.slice(e),o=t[0],l=a[0].dts-o.dts,d=o.options&&o.options.start+l?o.options.start:null;this.audioTrack.samples=r,this.doFixAudio(!1),this.audioTrack.samples=a,this.doFixAudio(!1,d),this.audioTrack.samples=r.concat(a)}getFirstSample(){let{samples:e}=this.videoTrack,{samples:t}=this.audioTrack,n=!1,s=!1;return!this._firstVideoSample&&e.length&&(this._firstVideoSample=l.findFirstVideoSample(e),n=!0),!this._firstAudioSample&&t.length&&(this._firstAudioSample=l.findFirstAudioSample(t),s=!0),{isFirstVideoSamples:n,isFirstAudioSamples:s}}fixRefSampleDuration(e,t){const n="video"===e.type,s=n?this.allVideoSamplesCount:this.allAudioSamplesCount,i=n?this._firstVideoSample.dts:this._firstAudioSample.dts,r=n?this.filledVideoSamples.length:this.filledAudioSamples.length;if(!e.refSampleDuration||e.refSampleDuration<=0||Number.isNaN(e.refSampleDuration)){if(t.length>=1){const n=t[t.length-1].dts;e.refSampleDuration=Math.floor((n-i)/(s+r-1))}}else if(e.refSampleDuration&&t.length>=5){const n=(t[t.length-1].dts-t[0].dts)/(t.length-1);e.refSampleDuration=Math.floor(Math.abs(e.refSampleDuration-n)<=5?e.refSampleDuration:n)}}recordSamplesCount(){const{audioTrack:e,videoTrack:t}=this;this.allAudioSamplesCount+=e.samples.length,this.allVideoSamplesCount+=t.samples.length}removeInvalidSamples(){const{_firstVideoSample:e,_firstAudioSample:t}=this;this.audioTrack.samples=this.audioTrack.samples.filter(e=>e.dts>=t.dts&&(void 0===this.lastAudioDts||e.dts>this.lastAudioDts)),this.videoTrack.samples=this.videoTrack.samples.filter(t=>t.dts>=e.dts&&(void 0===this.lastVideoDts||t.dts>this.lastVideoDts))}getStreamChangeStart(e){return e.options&&e.options.start?e.options.start-this.dtsBase:1/0}static sortAudioSamples(e){return 1===e.length?e:e.sort((e,t)=>e.dts-t.dts)}static findFirstAudioSample(e){return e&&0!==e.length?l.sortAudioSamples(e)[0]:null}static findFirstVideoSample(e){if(!e.length)return null;const t=e.sort((e,t)=>e.dts-t.dts);for(let e=0,n=t.length;e<n;e++)if(t[e].isKeyframe)return t[e]}static detectLargeGap(e,t){if(null===e)return;const n=t.dts||0,s=e-n>=1e3||n-e>=1e3,i=t.options&&t.options.discontinue;return s||i}static doFixLargeGap(e,t){console.log("fix large gap");for(let n=0,s=e.length;n<s;n++){const s=e[n];s.dts+=t,s.pts&&(s.pts+=t)}}static detactChangeStream(e){let t=!1,n=-1;for(let s=0,i=e.length;s<i;s++)if(e[s].options&&e[s].options.meta){t=!0,n=s;break}return{changed:t,changedIdx:n}}get tracks(){return this._context.getInstance("TRACKS")}get audioTrack(){return this.tracks?this.tracks.audioTrack:null}get videoTrack(){return this.tracks?this.tracks.videoTrack:null}get dtsBase(){const e=this._context.getInstance("MP4_REMUXER");return e?e._dtsBase:0}}t.default=l},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=class{static getSilentFrame(e,t){if("mp4a.40.2"===e){if(1===t)return new Uint8Array([0,200,0,128,35,128]);if(2===t)return new Uint8Array([33,0,73,144,2,25,0,35,128]);if(3===t)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,142]);if(4===t)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,128,44,128,8,2,56]);if(5===t)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,130,48,4,153,0,33,144,2,56]);if(6===t)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,130,48,4,153,0,33,144,2,0,178,0,32,8,224])}else{if(1===t)return new Uint8Array([1,64,34,128,163,78,230,128,186,8,0,0,0,28,6,241,193,10,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,94]);if(2===t)return new Uint8Array([1,64,34,128,163,94,230,128,186,8,0,0,0,0,149,0,6,241,161,10,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,94]);if(3===t)return new Uint8Array([1,64,34,128,163,94,230,128,186,8,0,0,0,0,149,0,6,241,161,10,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,94])}return null}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});class s{constructor(){this.mimetype="",this.init=null,this.data=[]}}t.default=class{constructor(){this.sources={}}getSource(e){return this.sources[e]}createSource(e){return this.sources[e]=new s,this.sources[e]}clear(){this.sources={}}destroy(){this.sources={}}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s=n(0);const i={NUMBER:0,BOOLEAN:1,STRING:2,OBJECT:3,MIX_ARRAY:8,OBJECT_END:9,STRICT_ARRAY:10,DATE:11,LONE_STRING:12};t.default=class{constructor(){this.offset=0,this.readOffset=this.offset}resolve(e,t){if(t<3)throw new Error("not enough data for metainfo");const n={},s=this.parseValue(e),i=this.parseValue(e,t-s.bodySize);return n[s.data]=i.data,this.resetStatus(),n}resetStatus(){this.offset=0,this.readOffset=this.offset}parseString(e){const t=new DataView(e,this.readOffset).getUint16(0,!s.isLe);let n="";n=t>0?s.UTF8.decode(new Uint8Array(e,this.readOffset+2,t)):"";let i=t+2;return this.readOffset+=i,{data:n,bodySize:t+2}}parseDate(e,t){const n=new DataView(e,this.readOffset,t);let i=n.getFloat64(0,!s.isLe);return i+=60*n.getInt16(8,!s.isLe)*1e3,this.readOffset+=10,{data:new Date(i),bodySize:10}}parseObject(e,t){const n=this.parseString(e,t),s=this.parseValue(e,t-n.bodySize);return{data:{name:n.data,value:s.data},bodySize:n.bodySize+s.bodySize,isObjEnd:s.isObjEnd}}parseLongString(e){const t=new DataView(e,this.readOffset).getUint32(0,!s.isLe);let n="";return n=t>0?s.UTF8.decode(new Uint8Array(e,this.readOffset+2,t)):"",this.readOffset+=t+4,{data:n,bodySize:t+4}}parseValue(e,t){let n=new ArrayBuffer;n=e instanceof ArrayBuffer?e:e.buffer;const{NUMBER:r,BOOLEAN:a,STRING:o,OBJECT:l,MIX_ARRAY:d,OBJECT_END:u,STRICT_ARRAY:f,DATE:c,LONE_STRING:h}=i,p=new DataView(n,this.readOffset,t);let m=!1;const _=p.getUint8(0);let g=1;this.readOffset+=1;let x=null;switch(_){case r:x=p.getFloat64(1,!s.isLe),this.readOffset+=8,g+=8;break;case a:x=!!p.getUint8(1),this.readOffset+=1,g+=1;break;case o:{const e=this.parseString(n);x=e.data,g+=e.bodySize;break}case l:{x={};let e=0;for(16777215&p.getUint32(t-4,!s.isLe)&&(e=3);g<t-4;){const s=this.parseObject(n,t-g-e);if(s.isObjectEnd)break;x[s.data.name]=s.data.value,g+=s.bodySize}g<=t-3&&9==(16777215&p.getUint32(g-1,!s.isLe))&&(this.readOffset+=3,g+=3);break}case d:{x={},g+=4,this.readOffset+=4;let e=0;for(9==(16777215&p.getUint32(t-4,!s.isLe))&&(e=3);g<t-8;){const s=this.parseObject(n,t-g-e);if(s.isObjectEnd)break;x[s.data.name]=s.data.value,g+=s.bodySize}g<=t-3&&9==(16777215&p.getUint32(g-1,!s.isLe))&&(g+=3,this.readOffset+=3);break}case u:x=null,m=!0;break;case f:{x=[];const e=p.getUint32(1,!s.isLe);g+=4,this.readOffset+=4;for(let s=0;s<e;s++){const e=this.parseValue(n,t-g);x.push(e.data),g+=e.bodySize}break}case c:{const e=this.parseDate(n,t-1);x=e.data,g+=e.bodySize;break}case h:{const e=this.parseLongString(n,t-1);x=e.data,g+=e.bodySize;break}default:g=t}return{data:x,bodySize:g,isObjEnd:m}}}},function(e,t,n){e.exports={Mp4Remuxer:n(37).default}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s,i=n(0),r=(s=n(38))&&s.__esModule?s:{default:s};const a=i.EVENTS.REMUX_EVENTS;class o{constructor(){this._dtsBase=0,this._isDtsBaseInited=!1,this._audioNextDts=null,this._videoNextDts=null,this._videoSegmentList=new i.MediaSegmentList("video"),this._audioSegmentList=new i.MediaSegmentList("audio");const{browser:e}=i.sniffer;this._fillSilenceFrame="ie"===e,this.isFirstVideo=!0,this.isFirstAudio=!0,this.videoAllDuration=0,this.audioAllDuration=0}init(){this.on(a.REMUX_MEDIA,this.remux.bind(this)),this.on(a.REMUX_METADATA,this.onMetaDataReady.bind(this)),this.on(a.DETECT_CHANGE_STREAM,this.resetDtsBase.bind(this))}destroy(){this._dtsBase=-1,this._dtsBaseInited=!1,this._videoNextDts=null,this._audioNextDts=null,this._videoSegmentList.clear(),this._audioSegmentList.clear(),this._videoSegmentList=null,this._audioSegmentList=null}remux(){const{audioTrack:e,videoTrack:t}=this._context.getInstance("TRACKS");!this._isDtsBaseInited&&this.calcDtsBase(e,t),this._remuxVideo(t),this._remuxAudio(e)}resetDtsBase(){this._dtsBase=0,this._dtsBaseInited=!1}seek(){this._videoNextDts=null,this._audioNextDts=null,this._videoSegmentList.clear(),this._audioSegmentList.clear()}onMetaDataReady(e){let t;if("audio"===e){const{audioTrack:e}=this._context.getInstance("TRACKS");t=e}else{const{videoTrack:e}=this._context.getInstance("TRACKS");t=e}let n=this._context.getInstance("PRE_SOURCE_BUFFER"),s=n.getSource(e);s||(s=n.createSource(e)),s.mimetype=t.meta.codec,s.init=this.remuxInitSegment(e,t.meta),this.emit(a.INIT_SEGMENT,e)}remuxInitSegment(e,t){let n=new i.Buffer,s=r.default.ftyp(),a=r.default.moov({type:e,meta:t});return n.write(s,a),n}calcDtsBase(e,t){if(!e.samples.length&&!t.samples.length)return;let n=1/0,s=1/0;e.samples&&e.samples.length&&(n=e.samples[0].dts),t.samples&&t.samples.length&&(s=t.samples[0].dts),this._dtsBase=Math.min(n,s),this._isDtsBaseInited=!0}_remuxVideo(e){const t=e;if(!e.samples||!e.samples.length)return;let{samples:n}=t,s=-1,o=null;const l=[],d={samples:[]};for(;n.length;){const e=n.shift(),{isKeyframe:t,options:i}=e;if(!this.isFirstAudio&&i&&i.meta){o=this.remuxInitSegment("video",i.meta),i.meta=null,n.unshift(e),i.isContinue||this.resetDtsBase();break}let r,a,u=e.dts-this._dtsBase;-1===s&&(s=u),void 0!==e.pts&&(r=(a=e.pts-this._dtsBase)-u),void 0!==e.cts&&(a=e.cts+u,r=e.cts);let f={buffer:[],size:0};d.samples.push(f),f.buffer.push(e.data),f.size+=e.data.byteLength;let c=0;c=n.length>=1?n[0].dts-this._dtsBase-u:l.length>=1?l[l.length-1].duration:this.videoMeta.refSampleDuration,this.videoAllDuration+=c,l.push({dts:u,cts:r,pts:a,data:e.data,size:e.data.byteLength,isKeyframe:t,duration:c,flags:{isLeading:0,dependsOn:t?2:1,isDependedOn:t?1:0,hasRedundancy:0,isNonSync:t?0:1},originDts:u,type:"video"})}let u=new i.Buffer;if(l.length){const e=r.default.moof({id:t.meta.id,time:s,samples:l}),n=r.default.mdat(d);u.write(e,n),this.writeToSource("video",u)}if(o&&(this.writeToSource("video",o),n.length))return t.samples=n,this._remuxVideo(t);this.isFirstVideo=!1,this.emit(a.MEDIA_SEGMENT,"video");const f=l[l.length-1];this._videoNextDts=f.dts+f.duration,t.samples=[],t.length=0}_remuxAudio(e){const{samples:t}=e;let n=-1,s=[],o=null;const l={samples:[]};if(!t||!t.length)return;let d=!1;for(;t.length;){let e=t.shift();const{data:i,options:r}=e;if(!this.isFirstAudio&&r&&r.meta){o=this.remuxInitSegment("audio",r.meta),r.meta=null,t.unshift(e),r.isContinue||this.resetDtsBase();break}let a=e.dts-this._dtsBase;const u=a;d||(n=a,d=!0);let f=0;f=this.audioMeta.refSampleDurationFixed?this.audioMeta.refSampleDurationFixed:t.length>=1?t[0].dts-this._dtsBase-a:s.length>=1?s[s.length-1].duration:this.audioMeta.refSampleDuration,this.audioAllDuration+=f;const c={dts:a,pts:a,cts:0,size:i.byteLength,duration:e.duration?e.duration:f,flags:{isLeading:0,dependsOn:2,isDependedOn:1,hasRedundancy:0,isNonSync:0},isKeyframe:!0,originDts:u,type:"audio"};let h={buffer:[],size:0};h.buffer.push(i),h.size+=i.byteLength,l.samples.push(h),s.push(c)}const u=new i.Buffer;if(s.length){const t=r.default.moof({id:e.meta.id,time:n,samples:s}),i=r.default.mdat(l);u.write(t,i),this.writeToSource("audio",u)}if(o&&(this.writeToSource("audio",o),t.length))return e.samples=t,this._remuxAudio(e);this.isFirstAudio=!1,this.emit(a.MEDIA_SEGMENT,"audio",u);const f=s[s.length-1];this._videoNextDts=f.dts+f.duration,e.samples=[],e.length=0}writeToSource(e,t){let n=this._context.getInstance("PRE_SOURCE_BUFFER"),s=n.getSource(e);s||(s=n.createSource(e)),s.data.push(t)}initSilentAudio(e,t){const n=o.getSilentFrame(this._audioMeta.channelCount);return{dts:e,pts:e,cts:0,duration:t,unit:n,size:n.byteLength,originDts:e,type:"video"}}get videoMeta(){return this._context.getInstance("TRACKS").videoTrack.meta}get audioMeta(){return this._context.getInstance("TRACKS").audioTrack.meta}static getSilentFrame(e){return 1===e?new Uint8Array([0,200,0,128,35,128]):2===e?new Uint8Array([33,0,73,144,2,25,0,35,128]):3===e?new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,142]):4===e?new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,128,44,128,8,2,56]):5===e?new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,130,48,4,153,0,33,144,2,56]):6===e?new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,130,48,4,153,0,33,144,2,0,178,0,32,8,224]):null}}t.default=o},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s=n(0);class i{static size(e){return s.Buffer.writeUint32(e)}static initBox(e,t,...n){const r=new s.Buffer;return r.write(i.size(e),i.type(t),...n),r.buffer}static extension(e,t){return new Uint8Array([e,t>>16&255,t>>8&255,255&t])}static ftyp(){return i.initBox(24,"ftyp",new Uint8Array([105,115,111,109,0,0,0,1,105,115,111,109,97,118,99,49]))}static moov({type:e,meta:t}){let n,s=8,r=i.mvhd(t.duration,t.timescale);n="video"===e?i.videoTrak(t):i.audioTrak(t);let a=i.mvex(t.duration,t.timescale||1e3,t.id);return[r,n,a].forEach(e=>{s+=e.byteLength}),i.initBox(s,"moov",r,n,a)}static mvhd(e,t=1e3){let n=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,t>>>24&255,t>>>16&255,t>>>8&255,255&t,e>>>24&255,e>>>16&255,e>>>8&255,255&e,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255]);return i.initBox(8+n.length,"mvhd",new Uint8Array(n))}static videoTrak(e){let t=8,n=i.tkhd({id:1,duration:e.duration,timescale:e.timescale||1e3,width:e.presentWidth,height:e.presentHeight,type:"video"}),s=i.mdia({type:"video",timescale:e.timescale||1e3,duration:e.duration,avcc:e.avcc,parRatio:e.parRatio,width:e.presentWidth,height:e.presentHeight});return[n,s].forEach(e=>{t+=e.byteLength}),i.initBox(t,"trak",n,s)}static audioTrak(e){let t=8,n=i.tkhd({id:2,duration:e.duration,timescale:e.timescale||1e3,width:0,height:0,type:"audio"}),s=i.mdia({type:"audio",timescale:e.timescale||1e3,duration:e.duration,channelCount:e.channelCount,samplerate:e.sampleRate,config:e.config});return[n,s].forEach(e=>{t+=e.byteLength}),i.initBox(t,"trak",n,s)}static tkhd(e){let t=e.id,n=e.duration,s=e.width,r=e.height,a=new Uint8Array([0,0,0,7,0,0,0,0,0,0,0,0,t>>>24&255,t>>>16&255,t>>>8&255,255&t,0,0,0,0,n>>>24&255,n>>>16&255,n>>>8&255,255&n,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,s>>>8&255,255&s,0,0,r>>>8&255,255&r,0,0]);return i.initBox(8+a.byteLength,"tkhd",a)}static edts(e){let t=new s.Buffer,n=e.duration,r=e.mediaTime;return t.write(i.size(36),i.type("edts")),t.write(i.size(28),i.type("elst")),t.write(new Uint8Array([0,0,0,1,n>>24&255,n>>16&255,n>>8&255,255&n,r>>24&255,r>>16&255,r>>8&255,255&r,0,0,0,1])),t.buffer}static mdia(e){let t=8,n=i.mdhd(e.timescale,e.duration),s=i.hdlr(e.type),r=i.minf(e);return[n,s,r].forEach(e=>{t+=e.byteLength}),i.initBox(t,"mdia",n,s,r)}static mdhd(e=1e3,t){let n=new Uint8Array([0,0,0,0,0,0,0,0,e>>>24&255,e>>>16&255,e>>>8&255,255&e,t>>>24&255,t>>>16&255,t>>>8&255,255&t,85,196,0,0]);return i.initBox(12+n.byteLength,"mdhd",i.extension(0,0),n)}static hdlr(e){let t=[0,0,0,0,0,0,0,0,118,105,100,101,0,0,0,0,0,0,0,0,0,0,0,0,86,105,100,101,111,72,97,110,100,108,101,114,0];return"audio"===e&&(t.splice(8,4,115,111,117,110),t.splice(24,13,83,111,117,110,100,72,97,110,100,108,101,114,0)),i.initBox(8+t.length,"hdlr",new Uint8Array(t))}static minf(e){let t=8,n="video"===e.type?i.vmhd():i.smhd(),s=i.dinf(),r=i.stbl(e);return[n,s,r].forEach(e=>{t+=e.byteLength}),i.initBox(t,"minf",n,s,r)}static vmhd(){return i.initBox(20,"vmhd",new Uint8Array([0,0,0,1,0,0,0,0,0,0,0,0]))}static smhd(){return i.initBox(16,"smhd",new Uint8Array([0,0,0,0,0,0,0,0]))}static dinf(){let e=new s.Buffer;return e.write(i.size(36),i.type("dinf"),i.size(28),i.type("dref"),new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,12,117,114,108,32,0,0,0,1])),e.buffer}static stbl(e){let t=8,n=i.stsd(e),s=i.stts(),r=i.stsc(),a=i.stsz(),o=i.stco();return[n,s,r,a,o].forEach(e=>{t+=e.byteLength}),i.initBox(t,"stbl",n,s,r,a,o)}static stsd(e){let t;return t="audio"===e.type?i.mp4a(e):i.avc1(e),i.initBox(16+t.byteLength,"stsd",i.extension(0,0),new Uint8Array([0,0,0,1]),t)}static mp4a(e){let t=new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,e.channelCount,0,16,0,0,0,0,e.samplerate>>8&255,255&e.samplerate,0,0]),n=i.esds(e.config);return i.initBox(8+t.byteLength+n.byteLength,"mp4a",t,n)}static esds(e=[43,146,8,0]){const t=e.length;let n=new s.Buffer,r=new Uint8Array([0,0,0,0,3,23+t,0,1,0,4,15+t,64,21,0,0,0,0,0,0,0,0,0,0,0,5].concat([t]).concat(e).concat([6,1,2]));return n.write(i.size(8+r.byteLength),i.type("esds"),r),n.buffer}static avc1(e){let t=new s.Buffer,n=e.width,r=e.height,a=e.parRatio.height,o=e.parRatio.width,l=e.avcc,d=new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,n>>8&255,255&n,r>>8&255,255&r,0,72,0,0,0,72,0,0,0,0,0,0,0,1,18,100,97,105,108,121,109,111,116,105,111,110,47,104,108,115,46,106,115,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,17,17]),u=new Uint8Array([0,28,156,128,0,45,198,192,0,45,198,192]),f=new Uint8Array([a>>24,a>>16&255,a>>8&255,255&a,o>>24,o>>16&255,o>>8&255,255&o]);return t.write(i.size(40+d.byteLength+l.byteLength+u.byteLength),i.type("avc1"),d,i.size(8+l.byteLength),i.type("avcC"),l,i.size(20),i.type("btrt"),u,i.size(16),i.type("pasp"),f),t.buffer}static stts(){let e=new Uint8Array([0,0,0,0,0,0,0,0]);return i.initBox(16,"stts",e)}static stsc(){let e=new Uint8Array([0,0,0,0,0,0,0,0]);return i.initBox(16,"stsc",e)}static stco(){let e=new Uint8Array([0,0,0,0,0,0,0,0]);return i.initBox(16,"stco",e)}static stsz(){let e=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0]);return i.initBox(20,"stsz",e)}static mvex(e,t=1e3,n){let r=new s.Buffer,a=s.Buffer.writeUint32(e);return r.write(i.size(56),i.type("mvex"),i.size(16),i.type("mehd"),i.extension(0,0),a,i.trex(n)),r.buffer}static trex(e){let t=new Uint8Array([0,0,0,0,e>>24,e>>16&255,e>>8&255,255&e,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1]);return i.initBox(8+t.byteLength,"trex",t)}static moof(e){let t=8,n=i.mfhd(),s=i.traf(e);return[n,s].forEach(e=>{t+=e.byteLength}),i.initBox(t,"moof",n,s)}static mfhd(){let e=s.Buffer.writeUint32(i.sequence);return i.sequence+=1,i.initBox(16,"mfhd",i.extension(0,0),e)}static traf(e){let t=8,n=i.tfhd(e.id),s=i.tfdt(e.time),r=i.sdtp(e),a=i.trun(e,r.byteLength);return[n,s,a,r].forEach(e=>{t+=e.byteLength}),i.initBox(t,"traf",n,s,a,r)}static tfhd(e){let t=s.Buffer.writeUint32(e);return i.initBox(16,"tfhd",i.extension(0,0),t)}static tfdt(e){return i.initBox(16,"tfdt",i.extension(0,0),s.Buffer.writeUint32(e))}static trun(e,t){let n=new s.Buffer,r=s.Buffer.writeUint32(e.samples.length),a=s.Buffer.writeUint32(92+16*e.samples.length+t);return n.write(i.size(20+16*e.samples.length),i.type("trun"),new Uint8Array([0,0,15,1]),r,a),e.samples.forEach(e=>{const t=e.flags;n.write(new Uint8Array([e.duration>>>24&255,e.duration>>>16&255,e.duration>>>8&255,255&e.duration,e.size>>>24&255,e.size>>>16&255,e.size>>>8&255,255&e.size,t.isLeading<<2|t.dependsOn,t.isDependedOn<<6|t.hasRedundancy<<4|t.isNonSync,0,0,e.cts>>>24&255,e.cts>>>16&255,e.cts>>>8&255,255&e.cts]))}),n.buffer}static sdtp(e){let t=new s.Buffer;return t.write(i.size(12+e.samples.length),i.type("sdtp"),i.extension(0,0)),e.samples.forEach(e=>{const n=e.flags,s=n.isLeading<<6|n.dependsOn<<4|n.isDependedOn<<2|n.hasRedundancy;t.write(new Uint8Array([s]))}),t.buffer}static mdat(e){let t=new s.Buffer,n=8;e.samples.forEach(e=>{n+=e.size}),t.write(i.size(n),i.type("mdat"));let r=new Uint8Array(n),a=0;return r.set(t.buffer,a),a+=8,e.samples.forEach(e=>{e.buffer.forEach(e=>{r.set(e,a),a+=e.byteLength})}),r}}i.type=e=>new Uint8Array([e.charCodeAt(0),e.charCodeAt(1),e.charCodeAt(2),e.charCodeAt(3)]),i.sequence=1,t.default=i},function(e,t,n){e.exports={FetchLoader:n(40).default}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});const s=n(0).EVENTS.LOADER_EVENTS;t.default=class{constructor(e){this.configs=Object.assign({},e),this.url=null,this.status=0,this.error=null,this._reader=null,this._canceled=!1,this._destroyed=!1,this.readtype=this.configs.readtype,this.buffer=this.configs.buffer||"LOADER_BUFFER",this._loaderTaskNo=0}init(){this.on(s.LADER_START,this.load.bind(this))}static get type(){return"loader"}load(e,t){let n=this;this.url=e,this._canceled=!1;let i=this.getParams(t);return n.loading=!0,fetch(this.url,i).then((function(e){if(e.ok)return n.status=e.status,n._onFetchResponse(e);n.loading=!1,n.emit(s.LOADER_ERROR,n.TAG,new Error("invalid response."))})).catch((function(e){throw n.loading=!1,n.emit(s.LOADER_ERROR,n.TAG,e),new Error(e.message)}))}_onFetchResponse(e){let t=this,n=this._context.getInstance(this.buffer);this._loaderTaskNo++;let i=this._loaderTaskNo;if(!0===e.ok)switch(this.readtype){case 2:e.json().then(e=>{t.loading=!1,t._canceled||t._destroyed||(n?(n.push(e),t.emit(s.LOADER_COMPLETE,n)):t.emit(s.LOADER_COMPLETE,e))});break;case 1:e.text().then(e=>{t.loading=!1,t._canceled||t._destroyed||(n?(n.push(e),t.emit(s.LOADER_COMPLETE,n)):t.emit(s.LOADER_COMPLETE,e))});break;case 3:e.arrayBuffer().then(e=>{t.loading=!1,t._canceled||t._destroyed||(n?(n.push(new Uint8Array(e)),t.emit(s.LOADER_COMPLETE,n)):t.emit(s.LOADER_COMPLETE,e))});break;case 0:default:return this._onReader(e.body.getReader(),i)}}_onReader(e,t){let n=this._context.getInstance(this.buffer);if(!n&&this._reader||this._destroyed)try{this._reader.cancel()}catch(e){}if(this._reader=e,!1===this.loading)return;let i=this;this._reader&&this._reader.read().then((function(r){if(r.done)return i.loading=!1,i.status=0,void i.emit(s.LOADER_COMPLETE,n);if(!i._canceled&&!i._destroyed)return n.push(r.value),i.emit(s.LOADER_DATALOADED,n),i._onReader(e,t);if(i._reader)try{i._reader.cancel()}catch(e){}})).catch(e=>{i.loading=!1,i.emit(s.LOADER_ERROR,i.TAG,e)})}getParams(e){let t=Object.assign({},e),n=new Headers,s={method:"GET",headers:n,mode:"cors",cache:"default"};if("object"==typeof this.configs.headers){let e=this.configs.headers;for(let t in e)e.hasOwnProperty(t)&&n.append(t,e[t])}if("object"==typeof t.headers){let e=t.headers;for(let t in e)e.hasOwnProperty(t)&&n.append(t,e[t])}return!1===t.cors&&(s.mode="same-origin"),t.withCredentials&&(s.credentials="include"),s}cancel(){if(this._reader){try{this._reader.cancel()}catch(e){}this._reader=null,this.loading=!1,this._canceled=!0}}destroy(){this._destroyed=!0,this.cancel()}}}]))},"./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */function(e,t,n){"use strict";var s=r(n(/*! xgplayer-flv-live */"../xgplayer-flv-live/dist/index.js")),i=r(n(/*! xgplayer-flv-vod */"../xgplayer-flv-vod/dist/index.js"));function r(e){return e&&e.__esModule?e:{default:e}}e.exports=function e(t){return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),t.isLive?new s.default(t):new i.default(t)}},0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */function(e,t,n){e.exports=n(/*! ./src/index.js */"./src/index.js")},xgplayer:
/*!***************************!*\
  !*** external "xgplayer" ***!
  \***************************/
/*! no static exports found */function(e,t){e.exports=__WEBPACK_EXTERNAL_MODULE_xgplayer__}})}));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly94Z3BsYXllci1mbHYvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL3hncGxheWVyLWZsdi93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi1saXZlL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4tdm9kL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4vc3JjL2luZGV4LmpzIiwid2VicGFjazovL3hncGxheWVyLWZsdi9leHRlcm5hbCBcInhncGxheWVyXCIiXSwibmFtZXMiOlsicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIndpbmRvdyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfeGdwbGF5ZXJfXyIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJpIiwibCIsIm1vZHVsZXMiLCJjYWxsIiwibSIsImMiLCJkIiwibmFtZSIsImdldHRlciIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJyIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsInQiLCJtb2RlIiwiX19lc01vZHVsZSIsIm5zIiwiY3JlYXRlIiwia2V5IiwiYmluZCIsIm4iLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJlIiwiYSIsImRlZmF1bHQiLCJldmFsIiwiMCIsInhncGxheWVyIiwiQ29udGV4dCIsIkVWRU5UUyIsIldPUktFUl9DT01NQU5EUyIsInNuaWZmZXIiLCJpc0xlIiwiVVRGOCIsIk1lZGlhSW5mbyIsIk1lZGlhU2FtcGxlIiwiTWVkaWFTZWdtZW50IiwiTWVkaWFTZWdtZW50TGlzdCIsIkF1ZGlvVHJhY2tNZXRhIiwiVmlkZW9UcmFja01ldGEiLCJBdWRpb1RyYWNrU2FtcGxlIiwiVmlkZW9UcmFja1NhbXBsZSIsIk1zZSIsIlN0cmVhbSIsIkJ1ZmZlciIsIkNyeXB0byIsImNvbnN0cnVjdG9yIiwidGhpcyIsImlkIiwic2VxdWVuY2VOdW1iZXIiLCJzYW1wbGVzIiwiZHJvcHBlZFNhbXBsZXMiLCJsZW5ndGgiLCJyZXNldCIsIkF1ZGlvVHJhY2siLCJzdXBlciIsIlRBRyIsInR5cGUiLCJWaWRlb1RyYWNrIiwiZHJvcHBlZCIsIlRyYWNrcyIsImF1ZGlvVHJhY2siLCJ2aWRlb1RyYWNrIiwibWltZVR5cGUiLCJkdXJhdGlvbiIsImhhc1ZpZGVvIiwidmlkZW8iLCJjb2RlYyIsIndpZHRoIiwiaGVpZ2h0IiwicHJvZmlsZSIsImxldmVsIiwiZnJhbWVSYXRlIiwiZml4ZWQiLCJmcHMiLCJmcHNfbnVtIiwiZnBzX2RlbiIsImNocm9tYUZvcm1hdCIsInBhclJhdGlvIiwiaGFzQXVkaW8iLCJhdWRpbyIsInNhbXBsZVJhdGUiLCJzYW1wbGVSYXRlSW5kZXgiLCJjaGFubmVsQ291bnQiLCJpc0Jhc2VJbmZvUmVhZHkiLCJpc1ZpZGVvUmVhZHkiLCJpc0F1ZGlvUmVhZHkiLCJMQURFUl9TVEFSVCIsIkxPQURFUl9EQVRBTE9BREVEIiwiTE9BREVSX0NPTVBMRVRFIiwiTE9BREVSX0VSUk9SIiwiREVNVVhfU1RBUlQiLCJERU1VWF9DT01QTEVURSIsIkRFTVVYX0VSUk9SIiwiTUVUQURBVEFfUEFSU0VEIiwiVklERU9fTUVUQURBVEFfQ0hBTkdFIiwiQVVESU9fTUVUQURBVEFfQ0hBTkdFIiwiTUVESUFfSU5GTyIsIlJFTVVYX01FVEFEQVRBIiwiUkVNVVhfTUVESUEiLCJNRURJQV9TRUdNRU5UIiwiUkVNVVhfRVJST1IiLCJJTklUX1NFR01FTlQiLCJERVRFQ1RfQ0hBTkdFX1NUUkVBTSIsIlNPVVJDRV9VUERBVEVfRU5EIiwiUkVUUllfVElNRV9FWENFRURFRCIsImFzc2lnbiIsImgiLCJwdXNoIiwiQUxMRVZFTlRTIiwiSExTX0VWRU5UUyIsIlJFTVVYX0VWRU5UUyIsIkRFTVVYX0VWRU5UUyIsIk1TRV9FVkVOVFMiLCJMT0FERVJfRVZFTlRTIiwiRmx2QWxsb3dlZEV2ZW50cyIsIkhsc0FsbG93ZWRFdmVudHMiLCJDUllUT19FVkVOVFMiLCJTVEFSVF9ERUNSWVBUIiwiREVDUllQVEVEIiwiY29uZmlnIiwicmVmU2FtcGxlRHVyYXRpb24iLCJ0aW1lc2NhbGUiLCJpbml0IiwiYXZjYyIsInNwcyIsIlVpbnQ4QXJyYXkiLCJwcHMiLCJjb2RlY0hlaWdodCIsImNvZGVjV2lkdGgiLCJwcmVzZW50SGVpZ2h0IiwicHJlc2VudFdpZHRoIiwiZ2V0RGVmYXVsdCIsImR0cyIsInB0cyIsImRhdGEiLCJpc0tleWZyYW1lIiwib3JpZ2luRHRzIiwiTmFsdW5pdCIsIlNwc1BhcnNlciIsIkNvbXBhdGliaWxpdHkiLCJieXRlTGVuZ3RoIiwiYnVmZmVyIiwiX2Vic3AycmJzcCIsInJlYWRCeXRlIiwicmVhZFVFRyIsImdldFByb2ZpbGVTdHJpbmciLCJnZXRMZXZlbFN0cmluZyIsInJlYWRCaXRzIiwicmVhZEJvb2wiLCJfc2tpcFNjYWxpbmdMaXN0IiwiZiIsInJlYWRTRUciLCJnIiwiXyIsInkiLCJFIiwiUyIsIkEiLCJ2IiwiVCIsImIiLCJSIiwiRCIsInciLCJ4IiwiTCIsIk8iLCJNIiwiQiIsIk1hdGgiLCJjZWlsIiwiZGVzdHJveSIsInByb2ZpbGVfc3RyaW5nIiwibGV2ZWxfc3RyaW5nIiwiYml0X2RlcHRoIiwiY2hyb21hX2Zvcm1hdCIsImNocm9tYV9mb3JtYXRfc3RyaW5nIiwiZ2V0Q2hyb21hRm9ybWF0U3RyaW5nIiwiZnJhbWVfcmF0ZSIsInBhcl9yYXRpbyIsImNvZGVjX3NpemUiLCJwcmVzZW50X3NpemUiLCJ0b0ZpeGVkIiwiYml0RGVwdGgiLCJmbG9vciIsIlRyYWNrIiwiWGdCdWZmZXIiLCJSZW11eEJ1ZmZlciIsIlByZVNvdXJjZSIsImhpc3RvcnlMZW4iLCJhcnJheSIsIm9mZnNldCIsIl9zaGlmdEJ1ZmZlciIsInNsaWNlIiwic2hpZnQiLCJzZXQiLCJjbGVhciIsImlzTGl2ZSIsImN1cnJlbnRUaW1lIiwiZ2V0QnVmZmVyZWRSYW5nZSIsImVtaXQiLCJtc2UiLCJlbmRPZlN0cmVhbSIsImNvbnRleHQiLCJpbml0RXZlbnRzIiwicmVnaXN0cnkiLCJmbHYiLCJzdGFydCIsInVybCIsIm9uIiwiaGFuZGxlVGltZVVwZGF0ZSIsImhhbmRsZVNlZWsiLCJvbmNlIiwiX2Rlc3Ryb3kiLCJsb2FkRGF0YSIsInNlZWsiLCJwcmVsb2FkVGltZSIsImxvYWROZXh0IiwiY3VycmVudFNyYyIsInBsYXllciIsInBhdXNlZCIsInBhdXNlIiwicGxheSIsIl9lbWl0dGVyIiwiRXZlbnRFbWl0dGVyIiwiX2luc3RhbmNlTWFwIiwiX2Nsc01hcCIsIl9pbml0ZWQiLCJtZWRpYUluZm8iLCJhbGxvd2VkRXZlbnRzIiwiX2hvb2tzIiwiRXJyb3IiLCJpbml0SW5zdGFuY2UiLCJfaXNNZXNzYWdlTmFtZVZhbGlkIiwibGlzdGVuZXJzIiwib25jZUxpc3RlbmVycyIsIl9jb250ZXh0Iiwib2ZmIiwicmVtb3ZlTGlzdGVuZXJzIiwia2V5cyIsImZvckVhY2giLCJkZXN0cm95SW5zdGFuY2VzIiwiaW5kZXhPZiIsIlJlZmxlY3QiLCJhcHBseSIsIkZ1bmN0aW9uIiwib3duS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5TmFtZXMiLCJjb25jYXQiLCJOdW1iZXIiLCJpc05hTiIsIl9ldmVudHMiLCJfZXZlbnRzQ291bnQiLCJfbWF4TGlzdGVuZXJzIiwiZGVmYXVsdE1heExpc3RlbmVycyIsIlR5cGVFcnJvciIsIm5ld0xpc3RlbmVyIiwibGlzdGVuZXIiLCJ1bnNoaWZ0Iiwid2FybmVkIiwiU3RyaW5nIiwiZW1pdHRlciIsImNvdW50IiwiY29uc29sZSIsIndhcm4iLCJ1IiwiYXJndW1lbnRzIiwiZmlyZWQiLCJ0YXJnZXQiLCJyZW1vdmVMaXN0ZW5lciIsIndyYXBGbiIsIkFycmF5IiwiUmFuZ2VFcnJvciIsImdldFByb3RvdHlwZU9mIiwic2V0TWF4TGlzdGVuZXJzIiwiZ2V0TWF4TGlzdGVuZXJzIiwiZXJyb3IiLCJtZXNzYWdlIiwiYWRkTGlzdGVuZXIiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwicG9wIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicmF3TGlzdGVuZXJzIiwibGlzdGVuZXJDb3VudCIsImV2ZW50TmFtZXMiLCJDT05URVhUX0NPTU9NQU5EUyIsIk9OIiwiT05DRSIsIk9GRiIsIkVNSVQiLCJERVNUUk9ZIiwiQXJyYXlCdWZmZXIiLCJEYXRhVmlldyIsInNldEludDE2IiwiSW50MTZBcnJheSIsIm9zIiwiaXNQYyIsImlzVGFibGV0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidG9Mb3dlckNhc2UiLCJpZSIsImZpcmZveCIsImNocm9tZSIsIm9wZXJhIiwic2FmYXJpIiwiZmlsdGVyIiwidGVzdCIsImlzUGhvbmUiLCJpc0FuZHJvaWQiLCJpc1N5bWJpYW4iLCJpc1dpbmRvd3NQaG9uZSIsImlzRmlyZUZveCIsImZyb21DaGFyQ29kZSIsIl9jaGVja0NvbnRpbnVhdGlvbiIsImpvaW4iLCJnZXREZWZhdWx0SW5mIiwidG9TdHJpbmciLCJlbnRyaWVzIiwicG9zaXRpb24iLCJpc1JBUCIsInN0YXJ0RHRzIiwiZW5kRHRzIiwic3RhcnRQdHMiLCJlbmRQdHMiLCJvcmlnaW5TdGFydER0cyIsIm9yaWdpbkVuZER0cyIsInJhbmRvbUFjY2Vzc1BvaW50cyIsImZpcnN0U2FtcGxlIiwibGFzdFNhbXBsZSIsIl90eXBlIiwiX2xpc3QiLCJfbGFzdEFwcGVuZExvY2F0aW9uIiwiX3NlYXJjaE5lYXJlc3RTZWdtZW50QmVmb3JlIiwic3BsaWNlIiwiZ2V0TGFzdFNlZ21lbnRCZWZvcmUiLCJjb25maWdzIiwiY29udGFpbmVyIiwibWVkaWFTb3VyY2UiLCJzb3VyY2VCdWZmZXJzIiwib25Tb3VyY2VPcGVuIiwib25UaW1lVXBkYXRlIiwib25VcGRhdGVFbmQiLCJvbldhaXRpbmciLCJzZWxmIiwiTWVkaWFTb3VyY2UiLCJhZGRFdmVudExpc3RlbmVyIiwic3JjIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiYWRkU291cmNlQnVmZmVycyIsImRvQXBwZW5kIiwicmVhZHlTdGF0ZSIsImdldEluc3RhbmNlIiwic291cmNlcyIsIm1ldGEiLCJtaW1ldHlwZSIsImFkZFNvdXJjZUJ1ZmZlciIsInVwZGF0aW5nIiwiaW5pdGVkIiwiYXBwZW5kQnVmZmVyIiwiYWN0aXZlU291cmNlQnVmZmVycyIsInJlbW92ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJQcm9taXNlIiwic2V0VGltZW91dCIsImNsZWFyQnVmZmVyIiwicmVzb2x2ZSIsImFsbCIsInJlbW92ZUJ1ZmZlcnMiLCJ0aGVuIiwicmVtb3ZlU291cmNlQnVmZmVyIiwicmV2b2tlT2JqZWN0VVJMIiwiYnVmZmVyZWQiLCJlbmQiLCJkYXRhdmlldyIsImdldEludDgiLCJnZXRVaW50OCIsImdldEludDE2IiwiZ2V0VWludDE2IiwiZ2V0SW50MzIiLCJnZXRVaW50MzIiLCJwYWRTdGFydCIsInBhcnNlSW50IiwiaXRlcmF0b3IiLCJuZXh0IiwiZG9uZSIsInJldHVybiIsImlucHV0QnVmZmVyIiwiaW5wdXRidWZmZXIiLCJvdXRwdXRCdWZmZXIiLCJvdXRwdXRidWZmZXIiLCJpdiIsIm1ldGhvZCIsImNyeXB0byIsIm1zQ3J5cHRvIiwiZGVjcmlwdCIsImFlc2tleSIsImRlY3JpcHREYXRhIiwic3VidGxlIiwiaW1wb3J0S2V5IiwiZGVjcnlwdCIsIl9wbGF5ZXIiLCJzdGF0ZSIsImluaXRTZWdtZW50QXJyaXZlZCIsInJhbmdlIiwicmFuZ2VTdXBwb3J0IiwidGltZXMiLCJNQVhfU0FGRV9JTlRFR0VSIiwiZmlsZXBvc2l0aW9ucyIsIkZldGNoTG9hZGVyIiwiTXA0UmVtdXhlciIsImluaXRMaXN0ZW5lcnMiLCJsb2FkTWV0YSIsIl9oYW5kbGVMb2FkZXJEYXRhTG9hZGVkIiwiX2hhbmRsZU5ldHdvcmtFcnJvciIsIl9oYW5kbGVNZWRpYUluZm8iLCJfaGFuZGxlTWV0YWRhdGFQYXJzZWQiLCJfaGFuZGxlRGVtdXhDb21wbGV0ZSIsIl9oYW5kbGVEZW11eEVycm9yIiwiX2hhbmRsZUFwcGVuZEluaXRTZWdtZW50IiwiX2hhbmRsZU1lZGlhU2VnbWVudCIsIm9uTWV0YURhdGEiLCJpc1NlZWthYmxlIiwiY2FuY2VsIiwiZW1pdFRvIiwiRXJyb3JzIiwiX29uRXJyb3IiLCJlcnJvclR5cGUiLCJlcnJvckRldGFpbHMiLCJlcnJvckZhdGFsIiwiZ2V0U2Vla1JhbmdlIiwiY29tcGF0IiwibG9hZGVyIiwibG9hZGluZyIsImdldE5leHRSYW5nZSIsImhlYWRlcnMiLCJSYW5nZSIsImxvYWQiLCJjYXRjaCIsImxvYWRGYWxsYmFjayIsImtleWZyYW1lcyIsImZpbmRGaWxlUG9zaXRpb24iLCJpc0NvbXBsZXRlIiwiX2ZpcnN0RnJhZ21lbnRMb2FkZWQiLCJfdHJhY2tOdW0iLCJfaGFzU2NyaXB0IiwiZG9QYXJzZUZsdiIsImxvYWRlckJ1ZmZlciIsIl9wYXJzZUZsdlRhZyIsInBhcnNlRmx2SGVhZGVyIiwiaXNGbHZGaWxlIiwiZ2V0UGxheVR5cGUiLCJpbml0VmlkZW9UcmFjayIsImluaXRBdWRpb1RyYWNrIiwidHJhY2tzIiwiX3BhcnNlRmx2VGFnSGVhZGVyIiwiX3Byb2Nlc3NDaHVuayIsInRvSW50IiwiZmlsdGVyZWQiLCJ0YWdUeXBlIiwiZGF0YXNpemUiLCJfcGFyc2VTY3JpcHREYXRhIiwiX3BhcnNlQUFDRGF0YSIsIl9wYXJzZUhldmNEYXRhIiwiaHNhQXVkaW8iLCJfZGF0YXNpemVWYWxpZGF0b3IiLCJoYXNTcGVjaWZpY0NvbmZpZyIsImF1ZGlvc2FtcGxlcmF0ZSIsImF1ZGlvY2hhbm5lbHMiLCJmcmFtZXJhdGUiLCJvYmplY3RUeXBlIiwiX3N3aXRjaEF1ZGlvU2FtcGxlUmF0ZSIsImZyYW1lTGVuZ3RoIiwiZGVwZW5kc09uQ29yZUNvZGVyIiwiZXh0ZW5zaW9uRmxhZ0luZGV4IiwiZm9ybWF0IiwiX2hhc0F1ZGlvU2VxdWVuY2UiLCJfc3dpdGNoQXVkaW9TYW1wbGluZ0ZyZXF1ZW5jeSIsImZyYW1lTGVudGgiLCJhdWRpb1NhbXBsZVJhdGUiLCJfYWFjU2VxdWVuY2VIZWFkZXJQYXJzZXIiLCJhdWRpb1NhbXBsZVJhdGVJbmRleCIsIl9tZXRhQ2hhbmdlIiwib3B0aW9ucyIsImZyYW1lVHlwZSIsImNvZGVjSUQiLCJhdmNQYWNrZXRUeXBlIiwiY3RzIiwic2l6ZSIsIl9hdmNTZXF1ZW5jZUhlYWRlclBhcnNlciIsIl9oYXNWaWRlb1NlcXVlbmNlIiwiY29uZmlndXJhdGlvblZlcnNpb24iLCJhdmNQcm9maWxlSW5kaWNhdGlvbiIsInByb2ZpbGVDb21wYXRpYmlsaXR5IiwiYXZjTGV2ZWxJbmRpY2F0aW9uIiwibmFsVW5pdExlbmd0aCIsInBhcnNlU1BTIiwidG9WaWRlb01ldGEiLCJnZXRBbm5leGJOYWxzIiwiZ2V0QXZjY05hbHMiLCJnZXRIZWFkZXJQb3NpdGlvbkFubmV4QiIsInBvcyIsImhlYWRlckxlbmd0aCIsInNraXAiLCJoZWFkZXIiLCJib2R5IiwiYW5hbHlzZU5hbCIsIm5kciIsImlkciIsIl9idWZmZXIiLCJfYnVmZmVySW5kZXgiLCJfdG90YWxCeXRlcyIsIl90b3RhbEJpdHMiLCJfY3VycmVudFdvcmQiLCJfY3VycmVudFdvcmRCaXRzTGVmdCIsIm1pbiIsInN1YmFycmF5IiwiX2ZpbGxDdXJyZW50V29yZCIsIl9za2lwTGVhZGluZ1plcm8iLCJuZXh0QXVkaW9EdHMiLCJuZXh0VmlkZW9EdHMiLCJsYXN0QXVkaW9TYW1wbGVzTGVuIiwibGFzdFZpZGVvU2FtcGxlc0xlbiIsImxhc3RWaWRlb0R0cyIsImxhc3RBdWRpb0R0cyIsImFsbEF1ZGlvU2FtcGxlc0NvdW50IiwiYWxsVmlkZW9TYW1wbGVzQ291bnQiLCJfZmlyc3RBdWRpb1NhbXBsZSIsIl9maXJzdFZpZGVvU2FtcGxlIiwiZmlsbGVkQXVkaW9TYW1wbGVzIiwiZmlsbGVkVmlkZW9TYW1wbGVzIiwiX3ZpZGVvTGFyZ2VHYXAiLCJfYXVkaW9MYXJnZUdhcCIsImJlZm9yZSIsImRvRml4IiwiaXNGaXJzdEF1ZGlvU2FtcGxlcyIsImlzRmlyc3RWaWRlb1NhbXBsZXMiLCJnZXRGaXJzdFNhbXBsZSIsInJlY29yZFNhbXBsZXNDb3VudCIsImZpeFJlZlNhbXBsZUR1cmF0aW9uIiwiY2hhbmdlZCIsImNoYW5nZWRJZHgiLCJkZXRhY3RDaGFuZ2VTdHJlYW0iLCJmaXhDaGFuZ2VTdHJlYW1WaWRlbyIsImRvRml4VmlkZW8iLCJmaXhDaGFuZ2VTdHJlYW1BdWRpbyIsImRvRml4QXVkaW8iLCJkb0ZpeExhcmdlR2FwIiwiZGV0ZWN0TGFyZ2VHYXAiLCJhYnMiLCJnZXRTaWxlbnRGcmFtZSIsInJlZlNhbXBsZUR1cmF0aW9uRml4ZWQiLCJzb3J0QXVkaW9TYW1wbGVzIiwiZ2V0U3RyZWFtQ2hhbmdlU3RhcnQiLCJpc0NvbnRpbnVlIiwiZmluZEZpcnN0VmlkZW9TYW1wbGUiLCJmaW5kRmlyc3RBdWRpb1NhbXBsZSIsImR0c0Jhc2UiLCJzb3J0IiwiZGlzY29udGludWUiLCJsb2ciLCJfZHRzQmFzZSIsIk5VTUJFUiIsIkJPT0xFQU4iLCJTVFJJTkciLCJPQkpFQ1QiLCJNSVhfQVJSQVkiLCJPQkpFQ1RfRU5EIiwiU1RSSUNUX0FSUkFZIiwiREFURSIsIkxPTkVfU1RSSU5HIiwicmVhZE9mZnNldCIsInBhcnNlVmFsdWUiLCJib2R5U2l6ZSIsInJlc2V0U3RhdHVzIiwiZGVjb2RlIiwiZ2V0RmxvYXQ2NCIsIkRhdGUiLCJwYXJzZVN0cmluZyIsImlzT2JqRW5kIiwicGFyc2VPYmplY3QiLCJpc09iamVjdEVuZCIsInBhcnNlRGF0ZSIsInBhcnNlTG9uZ1N0cmluZyIsIl9pc0R0c0Jhc2VJbml0ZWQiLCJfYXVkaW9OZXh0RHRzIiwiX3ZpZGVvTmV4dER0cyIsIl92aWRlb1NlZ21lbnRMaXN0IiwiX2F1ZGlvU2VnbWVudExpc3QiLCJicm93c2VyIiwiX2ZpbGxTaWxlbmNlRnJhbWUiLCJpc0ZpcnN0VmlkZW8iLCJpc0ZpcnN0QXVkaW8iLCJ2aWRlb0FsbER1cmF0aW9uIiwiYXVkaW9BbGxEdXJhdGlvbiIsInJlbXV4Iiwib25NZXRhRGF0YVJlYWR5IiwicmVzZXREdHNCYXNlIiwiX2R0c0Jhc2VJbml0ZWQiLCJjYWxjRHRzQmFzZSIsIl9yZW11eFZpZGVvIiwiX3JlbXV4QXVkaW8iLCJnZXRTb3VyY2UiLCJjcmVhdGVTb3VyY2UiLCJyZW11eEluaXRTZWdtZW50IiwiZnR5cCIsIm1vb3YiLCJ3cml0ZSIsInZpZGVvTWV0YSIsImZsYWdzIiwiaXNMZWFkaW5nIiwiZGVwZW5kc09uIiwiaXNEZXBlbmRlZE9uIiwiaGFzUmVkdW5kYW5jeSIsImlzTm9uU3luYyIsIm1vb2YiLCJ0aW1lIiwibWRhdCIsIndyaXRlVG9Tb3VyY2UiLCJhdWRpb01ldGEiLCJfYXVkaW9NZXRhIiwidW5pdCIsIndyaXRlVWludDMyIiwiaW5pdEJveCIsIm12aGQiLCJ2aWRlb1RyYWsiLCJhdWRpb1RyYWsiLCJtdmV4IiwidGtoZCIsIm1kaWEiLCJzYW1wbGVyYXRlIiwibWVkaWFUaW1lIiwibWRoZCIsImhkbHIiLCJtaW5mIiwiZXh0ZW5zaW9uIiwidm1oZCIsInNtaGQiLCJkaW5mIiwic3RibCIsInN0c2QiLCJzdHRzIiwic3RzYyIsInN0c3oiLCJzdGNvIiwibXA0YSIsImF2YzEiLCJlc2RzIiwidHJleCIsIm1maGQiLCJ0cmFmIiwic2VxdWVuY2UiLCJ0ZmhkIiwidGZkdCIsInNkdHAiLCJ0cnVuIiwiY2hhckNvZGVBdCIsInN0YXR1cyIsIl9yZWFkZXIiLCJfY2FuY2VsZWQiLCJfZGVzdHJveWVkIiwicmVhZHR5cGUiLCJfbG9hZGVyVGFza05vIiwiZ2V0UGFyYW1zIiwiZmV0Y2giLCJvayIsIl9vbkZldGNoUmVzcG9uc2UiLCJqc29uIiwidGV4dCIsImFycmF5QnVmZmVyIiwiX29uUmVhZGVyIiwiZ2V0UmVhZGVyIiwicmVhZCIsIkhlYWRlcnMiLCJjYWNoZSIsImFwcGVuZCIsImNvcnMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJjcmVkZW50aWFscyIsIkZs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QUFJLEVBQUUsR0FBRyxFQUFFLFVBQVUsQ0FBQyxHQUFHLElBQUl0SCxFQUFFLE9BQU8sSUFBSXNILFdBQVcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxJQUFJLElBQUksR0FBRyxJQUFJLElBQUksSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxJQUFJLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxJQUFJdEgsRUFBRSxPQUFPLElBQUlzSCxXQUFXLENBQUMsRUFBRSxHQUFHLEdBQUcsSUFBSSxJQUFJLEdBQUcsSUFBSSxJQUFJLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLElBQUksSUFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsSUFBSXRILEVBQUUsT0FBTyxJQUFJc0gsV0FBVyxDQUFDLEVBQUUsR0FBRyxHQUFHLElBQUksSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxJQUFJLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsS0FBSyxPQUFPLFFBQVEsU0FBU3hHLEVBQUVkLEVBQUVsQixHQUFnQlUsT0FBT0MsZUFBZU8sRUFBRSxhQUFhLENBQUNELE9BQU0sSUFBSyxNQUFNYyxFQUFFeUIsY0FBY0MsS0FBS3dULFNBQVMsR0FBR3hULEtBQUs0RSxLQUFLLEtBQUs1RSxLQUFLd0YsS0FBSyxJQUFJL0gsRUFBRWdCLFFBQVEsTUFBTXNCLGNBQWNDLEtBQUtzVCxRQUFRLEdBQUcsVUFBVS9VLEdBQUcsT0FBT3lCLEtBQUtzVCxRQUFRL1UsR0FBRyxhQUFhQSxHQUFHLE9BQU95QixLQUFLc1QsUUFBUS9VLEdBQUcsSUFBSUQsRUFBRTBCLEtBQUtzVCxRQUFRL1UsR0FBRyxRQUFReUIsS0FBS3NULFFBQVEsR0FBRyxVQUFVdFQsS0FBS3NULFFBQVEsTUFBTSxTQUFTL1UsRUFBRWQsRUFBRWxCLEdBQWdCVSxPQUFPQyxlQUFlTyxFQUFFLGFBQWEsQ0FBQ0QsT0FBTSxJQUFLLElBQUljLEVBQUUvQixFQUFFLEdBQUcsTUFBTWMsRUFBRSxDQUFDa2pCLE9BQU8sRUFBRUMsUUFBUSxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxXQUFXLEVBQUVDLGFBQWEsR0FBR0MsS0FBSyxHQUFHQyxZQUFZLElBQUl0akIsRUFBRWdCLFFBQVEsTUFBTXNCLGNBQWNDLEtBQUtpSixPQUFPLEVBQUVqSixLQUFLZ2hCLFdBQVdoaEIsS0FBS2lKLE9BQU8sUUFBUTFLLEVBQUVkLEdBQUcsR0FBR0EsRUFBRSxFQUFFLE1BQU0sSUFBSWdPLE1BQU0sZ0NBQWdDLE1BQU1sUCxFQUFFLEdBQUcrQixFQUFFMEIsS0FBS2loQixXQUFXMWlCLEdBQUdsQixFQUFFMkMsS0FBS2loQixXQUFXMWlCLEVBQUVkLEVBQUVhLEVBQUU0aUIsVUFBVSxPQUFPM2tCLEVBQUUrQixFQUFFa0gsTUFBTW5JLEVBQUVtSSxLQUFLeEYsS0FBS21oQixjQUFjNWtCLEVBQUUsY0FBY3lELEtBQUtpSixPQUFPLEVBQUVqSixLQUFLZ2hCLFdBQVdoaEIsS0FBS2lKLE9BQU8sWUFBWTFLLEdBQUcsTUFBTWQsRUFBRSxJQUFJK1IsU0FBU2pSLEVBQUV5QixLQUFLZ2hCLFlBQVlqTSxVQUFVLEdBQUd6VyxFQUFFVyxNQUFNLElBQUkxQyxFQUFFLEdBQUdBLEVBQUVrQixFQUFFLEVBQUVhLEVBQUVZLEtBQUtraUIsT0FBTyxJQUFJcmMsV0FBV3hHLEVBQUV5QixLQUFLZ2hCLFdBQVcsRUFBRXZqQixJQUFJLEdBQUcsSUFBSUosRUFBRUksRUFBRSxFQUFFLE9BQU91QyxLQUFLZ2hCLFlBQVkzakIsRUFBRSxDQUFDbUksS0FBS2pKLEVBQUUya0IsU0FBU3pqQixFQUFFLEdBQUcsVUFBVWMsRUFBRWQsR0FBRyxNQUFNbEIsRUFBRSxJQUFJaVQsU0FBU2pSLEVBQUV5QixLQUFLZ2hCLFdBQVd2akIsR0FBRyxJQUFJSixFQUFFZCxFQUFFOGtCLFdBQVcsR0FBRy9pQixFQUFFVyxNQUFNLE9BQU81QixHQUFHLEdBQUdkLEVBQUV1WSxTQUFTLEdBQUd4VyxFQUFFVyxNQUFNLElBQUllLEtBQUtnaEIsWUFBWSxHQUFHLENBQUN4YixLQUFLLElBQUk4YixLQUFLamtCLEdBQUc2akIsU0FBUyxJQUFJLFlBQVkzaUIsRUFBRWQsR0FBRyxNQUFNbEIsRUFBRXlELEtBQUt1aEIsWUFBWWhqQixFQUFFZCxHQUFHYSxFQUFFMEIsS0FBS2loQixXQUFXMWlCLEVBQUVkLEVBQUVsQixFQUFFMmtCLFVBQVUsTUFBTSxDQUFDMWIsS0FBSyxDQUFDMUksS0FBS1AsRUFBRWlKLEtBQUtoSSxNQUFNYyxFQUFFa0gsTUFBTTBiLFNBQVMza0IsRUFBRTJrQixTQUFTNWlCLEVBQUU0aUIsU0FBU00sU0FBU2xqQixFQUFFa2pCLFVBQVUsZ0JBQWdCampCLEdBQUcsTUFBTWQsRUFBRSxJQUFJK1IsU0FBU2pSLEVBQUV5QixLQUFLZ2hCLFlBQVkvTCxVQUFVLEdBQUczVyxFQUFFVyxNQUFNLElBQUkxQyxFQUFFLEdBQUcsT0FBT0EsRUFBRWtCLEVBQUUsRUFBRWEsRUFBRVksS0FBS2tpQixPQUFPLElBQUlyYyxXQUFXeEcsRUFBRXlCLEtBQUtnaEIsV0FBVyxFQUFFdmpCLElBQUksR0FBR3VDLEtBQUtnaEIsWUFBWXZqQixFQUFFLEVBQUUsQ0FBQytILEtBQUtqSixFQUFFMmtCLFNBQVN6akIsRUFBRSxHQUFHLFdBQVdjLEVBQUVkLEdBQUcsSUFBSWxCLEVBQUUsSUFBSWdULFlBQVloVCxFQUFFZ0MsYUFBYWdSLFlBQVloUixFQUFFQSxFQUFFd0gsT0FBTyxNQUFNd2EsT0FBTy9oQixFQUFFZ2lCLFFBQVF4aUIsRUFBRXlpQixPQUFPempCLEVBQUUwakIsT0FBTzdqQixFQUFFOGpCLFVBQVVua0IsRUFBRW9rQixXQUFXaGQsRUFBRWlkLGFBQWFqVCxFQUFFa1QsS0FBS2xrQixFQUFFbWtCLFlBQVl2YSxHQUFHbkosRUFBRWdCLEVBQUUsSUFBSW1SLFNBQVNqVCxFQUFFeUQsS0FBS2doQixXQUFXdmpCLEdBQUcsSUFBSWQsR0FBRSxFQUFHLE1BQU0rSixFQUFFckksRUFBRXdXLFNBQVMsR0FBRyxJQUFJbE8sRUFBRSxFQUFFM0csS0FBS2doQixZQUFZLEVBQUUsSUFBSXBhLEVBQUUsS0FBSyxPQUFPRixHQUFHLEtBQUtsSSxFQUFFb0ksRUFBRXZJLEVBQUVnakIsV0FBVyxHQUFHL2lCLEVBQUVXLE1BQU1lLEtBQUtnaEIsWUFBWSxFQUFFcmEsR0FBRyxFQUFFLE1BQU0sS0FBSzNJLEVBQUU0SSxJQUFJdkksRUFBRXdXLFNBQVMsR0FBRzdVLEtBQUtnaEIsWUFBWSxFQUFFcmEsR0FBRyxFQUFFLE1BQU0sS0FBSzNKLEVBQUUsQ0FBQyxNQUFNdUIsRUFBRXlCLEtBQUt1aEIsWUFBWWhsQixHQUFHcUssRUFBRXJJLEVBQUVpSCxLQUFLbUIsR0FBR3BJLEVBQUUyaUIsU0FBUyxNQUFNLEtBQUtya0IsRUFBRSxDQUFDK0osRUFBRSxHQUFHLElBQUlySSxFQUFFLEVBQUUsSUFBSSxTQUFTRixFQUFFNFcsVUFBVXhYLEVBQUUsR0FBR2EsRUFBRVcsUUFBUVYsRUFBRSxHQUFHb0ksRUFBRWxKLEVBQUUsR0FBRyxDQUFDLE1BQU1hLEVBQUUwQixLQUFLeWhCLFlBQVlsbEIsRUFBRWtCLEVBQUVrSixFQUFFcEksR0FBRyxHQUFHRCxFQUFFb2pCLFlBQVksTUFBTTlhLEVBQUV0SSxFQUFFa0gsS0FBSzFJLE1BQU13QixFQUFFa0gsS0FBS2hJLE1BQU1tSixHQUFHckksRUFBRTRpQixTQUFZdmEsR0FBR2xKLEVBQUUsR0FBRyxJQUFLLFNBQVNZLEVBQUU0VyxVQUFVdE8sRUFBRSxHQUFHckksRUFBRVcsU0FBU2UsS0FBS2doQixZQUFZLEVBQUVyYSxHQUFHLEdBQUcsTUFBTSxLQUFLbkssRUFBRSxDQUFDb0ssRUFBRSxHQUFHRCxHQUFHLEVBQUUzRyxLQUFLZ2hCLFlBQVksRUFBRSxJQUFJemlCLEVBQUUsRUFBRSxJQUFJLElBQUksU0FBU0YsRUFBRTRXLFVBQVV4WCxFQUFFLEdBQUdhLEVBQUVXLFNBQVNWLEVBQUUsR0FBR29JLEVBQUVsSixFQUFFLEdBQUcsQ0FBQyxNQUFNYSxFQUFFMEIsS0FBS3loQixZQUFZbGxCLEVBQUVrQixFQUFFa0osRUFBRXBJLEdBQUcsR0FBR0QsRUFBRW9qQixZQUFZLE1BQU05YSxFQUFFdEksRUFBRWtILEtBQUsxSSxNQUFNd0IsRUFBRWtILEtBQUtoSSxNQUFNbUosR0FBR3JJLEVBQUU0aUIsU0FBWXZhLEdBQUdsSixFQUFFLEdBQUcsSUFBSyxTQUFTWSxFQUFFNFcsVUFBVXRPLEVBQUUsR0FBR3JJLEVBQUVXLFNBQVMwSCxHQUFHLEVBQUUzRyxLQUFLZ2hCLFlBQVksR0FBRyxNQUFNLEtBQUtwZCxFQUFFZ0QsRUFBRSxLQUFLakssR0FBRSxFQUFHLE1BQU0sS0FBS2lSLEVBQUUsQ0FBQ2hILEVBQUUsR0FBRyxNQUFNckksRUFBRUYsRUFBRTRXLFVBQVUsR0FBRzNXLEVBQUVXLE1BQU0wSCxHQUFHLEVBQUUzRyxLQUFLZ2hCLFlBQVksRUFBRSxJQUFJLElBQUkxaUIsRUFBRSxFQUFFQSxFQUFFQyxFQUFFRCxJQUFJLENBQUMsTUFBTUMsRUFBRXlCLEtBQUtpaEIsV0FBVzFrQixFQUFFa0IsRUFBRWtKLEdBQUdDLEVBQUUvQyxLQUFLdEYsRUFBRWlILE1BQU1tQixHQUFHcEksRUFBRTJpQixTQUFTLE1BQU0sS0FBS3RrQixFQUFFLENBQUMsTUFBTTJCLEVBQUV5QixLQUFLMmhCLFVBQVVwbEIsRUFBRWtCLEVBQUUsR0FBR21KLEVBQUVySSxFQUFFaUgsS0FBS21CLEdBQUdwSSxFQUFFMmlCLFNBQVMsTUFBTSxLQUFLMWEsRUFBRSxDQUFDLE1BQU1qSSxFQUFFeUIsS0FBSzRoQixnQkFBZ0JybEIsRUFBRWtCLEVBQUUsR0FBR21KLEVBQUVySSxFQUFFaUgsS0FBS21CLEdBQUdwSSxFQUFFMmlCLFNBQVMsTUFBTSxRQUFRdmEsRUFBRWxKLEVBQUUsTUFBTSxDQUFDK0gsS0FBS29CLEVBQUVzYSxTQUFTdmEsRUFBRTZhLFNBQVM3a0IsTUFBTSxTQUFTNEIsRUFBRWQsRUFBRWxCLEdBQWdCZ0MsRUFBRTFDLFFBQVEsQ0FBQ2tiLFdBQVd4YSxFQUFFLElBQUlrQyxVQUFVLFNBQVNGLEVBQUVkLEVBQUVsQixHQUFnQlUsT0FBT0MsZUFBZU8sRUFBRSxhQUFhLENBQUNELE9BQU0sSUFBSyxJQUFJYyxFQUFFakIsRUFBRWQsRUFBRSxHQUFXeUIsR0FBR00sRUFBVC9CLEVBQUUsTUFBYStCLEVBQUVYLFdBQVdXLEVBQUUsQ0FBQ0csUUFBUUgsR0FBRyxNQUFNdEIsRUFBRUssRUFBRXlCLE9BQU9rRixhQUFhLE1BQU1uSCxFQUFFa0QsY0FBY0MsS0FBS3NnQixTQUFTLEVBQUV0Z0IsS0FBSzZoQixrQkFBaUIsRUFBRzdoQixLQUFLOGhCLGNBQWMsS0FBSzloQixLQUFLK2hCLGNBQWMsS0FBSy9oQixLQUFLZ2lCLGtCQUFrQixJQUFJM2tCLEVBQUVpQyxpQkFBaUIsU0FBU1UsS0FBS2lpQixrQkFBa0IsSUFBSTVrQixFQUFFaUMsaUJBQWlCLFNBQVMsTUFBTTRpQixRQUFRM2pCLEdBQUdsQixFQUFFMkIsUUFBUWdCLEtBQUttaUIsa0JBQWtCLE9BQU81akIsRUFBRXlCLEtBQUtvaUIsY0FBYSxFQUFHcGlCLEtBQUtxaUIsY0FBYSxFQUFHcmlCLEtBQUtzaUIsaUJBQWlCLEVBQUV0aUIsS0FBS3VpQixpQkFBaUIsRUFBRSxPQUFPdmlCLEtBQUttSyxHQUFHbk4sRUFBRW9HLFlBQVlwRCxLQUFLd2lCLE1BQU16a0IsS0FBS2lDLE9BQU9BLEtBQUttSyxHQUFHbk4sRUFBRW1HLGVBQWVuRCxLQUFLeWlCLGdCQUFnQjFrQixLQUFLaUMsT0FBT0EsS0FBS21LLEdBQUduTixFQUFFd0cscUJBQXFCeEQsS0FBSzBpQixhQUFhM2tCLEtBQUtpQyxPQUFPLFVBQVVBLEtBQUtzZ0IsVUFBVSxFQUFFdGdCLEtBQUsyaUIsZ0JBQWUsRUFBRzNpQixLQUFLK2hCLGNBQWMsS0FBSy9oQixLQUFLOGhCLGNBQWMsS0FBSzloQixLQUFLZ2lCLGtCQUFrQjFZLFFBQVF0SixLQUFLaWlCLGtCQUFrQjNZLFFBQVF0SixLQUFLZ2lCLGtCQUFrQixLQUFLaGlCLEtBQUtpaUIsa0JBQWtCLEtBQUssUUFBUSxNQUFNbmhCLFdBQVd2QyxFQUFFd0MsV0FBV3RELEdBQUd1QyxLQUFLOEwsU0FBU3VILFlBQVksV0FBV3JULEtBQUs2aEIsa0JBQWtCN2hCLEtBQUs0aUIsWUFBWXJrQixFQUFFZCxHQUFHdUMsS0FBSzZpQixZQUFZcGxCLEdBQUd1QyxLQUFLOGlCLFlBQVl2a0IsR0FBRyxlQUFleUIsS0FBS3NnQixTQUFTLEVBQUV0Z0IsS0FBSzJpQixnQkFBZSxFQUFHLE9BQU8zaUIsS0FBSytoQixjQUFjLEtBQUsvaEIsS0FBSzhoQixjQUFjLEtBQUs5aEIsS0FBS2dpQixrQkFBa0IxWSxRQUFRdEosS0FBS2lpQixrQkFBa0IzWSxRQUFRLGdCQUFnQi9LLEdBQUcsSUFBSWQsRUFBRSxHQUFHLFVBQVVjLEVBQUUsQ0FBQyxNQUFNdUMsV0FBV3ZDLEdBQUd5QixLQUFLOEwsU0FBU3VILFlBQVksVUFBVTVWLEVBQUVjLE1BQU0sQ0FBQyxNQUFNd0MsV0FBV3hDLEdBQUd5QixLQUFLOEwsU0FBU3VILFlBQVksVUFBVTVWLEVBQUVjLEVBQUUsSUFBSWhDLEVBQUV5RCxLQUFLOEwsU0FBU3VILFlBQVkscUJBQXFCL1UsRUFBRS9CLEVBQUV3bUIsVUFBVXhrQixHQUFHRCxJQUFJQSxFQUFFL0IsRUFBRXltQixhQUFhemtCLElBQUlELEVBQUVrVixTQUFTL1YsRUFBRThWLEtBQUtuUyxNQUFNOUMsRUFBRXNHLEtBQUs1RSxLQUFLaWpCLGlCQUFpQjFrQixFQUFFZCxFQUFFOFYsTUFBTXZULEtBQUswSixLQUFLMU0sRUFBRXVHLGFBQWFoRixHQUFHLGlCQUFpQkEsRUFBRWQsR0FBRyxJQUFJbEIsRUFBRSxJQUFJYyxFQUFFd0MsT0FBT3ZCLEVBQUVOLEVBQUVTLFFBQVF5a0IsT0FBTzFrQixFQUFFUixFQUFFUyxRQUFRMGtCLEtBQUssQ0FBQ3ppQixLQUFLbkMsRUFBRWdWLEtBQUs5VixJQUFJLE9BQU9sQixFQUFFNm1CLE1BQU05a0IsRUFBRUUsR0FBR2pDLEVBQUUsWUFBWWdDLEVBQUVkLEdBQUcsSUFBSWMsRUFBRTRCLFFBQVFFLFNBQVM1QyxFQUFFMEMsUUFBUUUsT0FBTyxPQUFPLElBQUk5RCxFQUFFLElBQUkrQixFQUFFLElBQUlDLEVBQUU0QixTQUFTNUIsRUFBRTRCLFFBQVFFLFNBQVM5RCxFQUFFZ0MsRUFBRTRCLFFBQVEsR0FBR21GLEtBQUs3SCxFQUFFMEMsU0FBUzFDLEVBQUUwQyxRQUFRRSxTQUFTL0IsRUFBRWIsRUFBRTBDLFFBQVEsR0FBR21GLEtBQUt0RixLQUFLc2dCLFNBQVMzWSxLQUFLNlYsSUFBSWpoQixFQUFFK0IsR0FBRzBCLEtBQUs2aEIsa0JBQWlCLEVBQUcsWUFBWXRqQixHQUFHLE1BQU1kLEVBQUVjLEVBQUUsSUFBSUEsRUFBRTRCLFVBQVU1QixFQUFFNEIsUUFBUUUsT0FBTyxPQUFPLElBQUlGLFFBQVE1RCxHQUFHa0IsRUFBRWEsR0FBRyxFQUFFRSxFQUFFLEtBQUssTUFBTTNCLEVBQUUsR0FBR0wsRUFBRSxDQUFDMkQsUUFBUSxJQUFJLEtBQUs1RCxFQUFFOEQsUUFBUSxDQUFDLE1BQU05QixFQUFFaEMsRUFBRTZNLFNBQVMzRCxXQUFXaEksRUFBRStkLFFBQVFuZSxHQUFHa0IsRUFBRSxJQUFJeUIsS0FBS3FpQixjQUFjaGxCLEdBQUdBLEVBQUVrVyxLQUFLLENBQUMvVSxFQUFFd0IsS0FBS2lqQixpQkFBaUIsUUFBUTVsQixFQUFFa1csTUFBTWxXLEVBQUVrVyxLQUFLLEtBQUtoWCxFQUFFOFEsUUFBUTlPLEdBQUdsQixFQUFFMGlCLFlBQVkvZixLQUFLMGlCLGVBQWUsTUFBTSxJQUFJMWtCLEVBQUVoQixFQUFFNEcsRUFBRXJGLEVBQUUrRyxJQUFJdEYsS0FBS3NnQixVQUFVLElBQUloaUIsSUFBSUEsRUFBRXNGLFFBQUcsSUFBU3JGLEVBQUVnSCxNQUFNdkgsR0FBR2hCLEVBQUV1QixFQUFFZ0gsSUFBSXZGLEtBQUtzZ0IsVUFBVTFjLFFBQUcsSUFBU3JGLEVBQUVxZCxNQUFNNWUsRUFBRXVCLEVBQUVxZCxJQUFJaFksRUFBRTVGLEVBQUVPLEVBQUVxZCxLQUFLLElBQUloTyxFQUFFLENBQUM3SCxPQUFPLEdBQUc4VixLQUFLLEdBQUdyZixFQUFFMkQsUUFBUTBELEtBQUsrSixHQUFHQSxFQUFFN0gsT0FBT2xDLEtBQUt0RixFQUFFaUgsTUFBTW9JLEVBQUVpTyxNQUFNdGQsRUFBRWlILEtBQUtNLFdBQVcsSUFBSWxKLEVBQUUsRUFBa0JBLEVBQWJMLEVBQUU4RCxRQUFRLEVBQUs5RCxFQUFFLEdBQUcrSSxJQUFJdEYsS0FBS3NnQixTQUFTMWMsRUFBUy9HLEVBQUV3RCxRQUFRLEVBQUV4RCxFQUFFQSxFQUFFd0QsT0FBTyxHQUFHWSxTQUFTakIsS0FBS3FqQixVQUFVM2Usa0JBQWtCMUUsS0FBS3NpQixrQkFBa0IxbEIsRUFBRUMsRUFBRWdILEtBQUssQ0FBQ3lCLElBQUkxQixFQUFFZ1ksSUFBSTVkLEVBQUV1SCxJQUFJdkksRUFBRXdJLEtBQUtqSCxFQUFFaUgsS0FBS3FXLEtBQUt0ZCxFQUFFaUgsS0FBS00sV0FBV0wsV0FBV2hJLEVBQUV3RCxTQUFTckUsRUFBRTBtQixNQUFNLENBQUNDLFVBQVUsRUFBRUMsVUFBVS9sQixFQUFFLEVBQUUsRUFBRWdtQixhQUFhaG1CLEVBQUUsRUFBRSxFQUFFaW1CLGNBQWMsRUFBRUMsVUFBVWxtQixFQUFFLEVBQUUsR0FBR2lJLFVBQVU5QixFQUFFbEQsS0FBSyxVQUFVLElBQUlrRCxFQUFFLElBQUl2RyxFQUFFd0MsT0FBTyxHQUFHaEQsRUFBRXdELE9BQU8sQ0FBQyxNQUFNOUIsRUFBRVAsRUFBRVMsUUFBUW1sQixLQUFLLENBQUMzakIsR0FBR3hDLEVBQUU4VixLQUFLdFQsR0FBRzRqQixLQUFLdmxCLEVBQUU2QixRQUFRdEQsSUFBSU4sRUFBRXlCLEVBQUVTLFFBQVFxbEIsS0FBS3RuQixHQUFHb0gsRUFBRXdmLE1BQU03a0IsRUFBRWhDLEdBQUd5RCxLQUFLK2pCLGNBQWMsUUFBUW5nQixHQUFHLEdBQUdwRixJQUFJd0IsS0FBSytqQixjQUFjLFFBQVF2bEIsR0FBR2pDLEVBQUU4RCxRQUFRLE9BQU81QyxFQUFFMEMsUUFBUTVELEVBQUV5RCxLQUFLNmlCLFlBQVlwbEIsR0FBR3VDLEtBQUtvaUIsY0FBYSxFQUFHcGlCLEtBQUswSixLQUFLMU0sRUFBRXFHLGNBQWMsU0FBUyxNQUFNdUssRUFBRS9RLEVBQUVBLEVBQUV3RCxPQUFPLEdBQUdMLEtBQUsraEIsY0FBY25VLEVBQUV0SSxJQUFJc0ksRUFBRTNNLFNBQVN4RCxFQUFFMEMsUUFBUSxHQUFHMUMsRUFBRTRDLE9BQU8sRUFBRSxZQUFZOUIsR0FBRyxNQUFNNEIsUUFBUTFDLEdBQUdjLEVBQUUsSUFBSWhDLEdBQUcsRUFBRStCLEVBQUUsR0FBR0UsRUFBRSxLQUFLLE1BQU0zQixFQUFFLENBQUNzRCxRQUFRLElBQUksSUFBSTFDLElBQUlBLEVBQUU0QyxPQUFPLE9BQU8sSUFBSTdELEdBQUUsRUFBRyxLQUFLaUIsRUFBRTRDLFFBQVEsQ0FBQyxJQUFJOUIsRUFBRWQsRUFBRTJMLFFBQVEsTUFBTTVELEtBQUtuSSxFQUFFbWUsUUFBUXhkLEdBQUdPLEVBQUUsSUFBSXlCLEtBQUtxaUIsY0FBY3JrQixHQUFHQSxFQUFFdVYsS0FBSyxDQUFDL1UsRUFBRXdCLEtBQUtpakIsaUJBQWlCLFFBQVFqbEIsRUFBRXVWLE1BQU12VixFQUFFdVYsS0FBSyxLQUFLOVYsRUFBRTRQLFFBQVE5TyxHQUFHUCxFQUFFK2hCLFlBQVkvZixLQUFLMGlCLGVBQWUsTUFBTSxJQUFJMWxCLEVBQUV1QixFQUFFK0csSUFBSXRGLEtBQUtzZ0IsU0FBUyxNQUFNMWMsRUFBRTVHLEVBQUVSLElBQUlELEVBQUVTLEVBQUVSLEdBQUUsR0FBSSxJQUFJb1IsRUFBRSxFQUEyQ0EsRUFBdEM1TixLQUFLZ2tCLFVBQVVwRSx1QkFBeUI1ZixLQUFLZ2tCLFVBQVVwRSx1QkFBK0JuaUIsRUFBRTRDLFFBQVEsRUFBSzVDLEVBQUUsR0FBRzZILElBQUl0RixLQUFLc2dCLFNBQVN0akIsRUFBU3NCLEVBQUUrQixRQUFRLEVBQUUvQixFQUFFQSxFQUFFK0IsT0FBTyxHQUFHWSxTQUFTakIsS0FBS2drQixVQUFVdGYsa0JBQWtCMUUsS0FBS3VpQixrQkFBa0IzVSxFQUFFLE1BQU1oUixFQUFFLENBQUMwSSxJQUFJdEksRUFBRXVJLElBQUl2SSxFQUFFNGUsSUFBSSxFQUFFQyxLQUFLeGUsRUFBRXlJLFdBQVc3RSxTQUFTMUMsRUFBRTBDLFNBQVMxQyxFQUFFMEMsU0FBUzJNLEVBQUUwVixNQUFNLENBQUNDLFVBQVUsRUFBRUMsVUFBVSxFQUFFQyxhQUFhLEVBQUVDLGNBQWMsRUFBRUMsVUFBVSxHQUFHbGUsWUFBVyxFQUFHQyxVQUFVOUIsRUFBRWxELEtBQUssU0FBUyxJQUFJOEYsRUFBRSxDQUFDVCxPQUFPLEdBQUc4VixLQUFLLEdBQUdyVixFQUFFVCxPQUFPbEMsS0FBS3hHLEdBQUdtSixFQUFFcVYsTUFBTXhlLEVBQUV5SSxXQUFXakosRUFBRXNELFFBQVEwRCxLQUFLMkMsR0FBR2xJLEVBQUV1RixLQUFLakgsR0FBRyxNQUFNZ0gsRUFBRSxJQUFJdkcsRUFBRXdDLE9BQU8sR0FBR3ZCLEVBQUUrQixPQUFPLENBQUMsTUFBTTVDLEVBQUVPLEVBQUVTLFFBQVFtbEIsS0FBSyxDQUFDM2pCLEdBQUcxQixFQUFFZ1YsS0FBS3RULEdBQUc0akIsS0FBS3RuQixFQUFFNEQsUUFBUTdCLElBQUlqQixFQUFFVyxFQUFFUyxRQUFRcWxCLEtBQUtqbkIsR0FBRytHLEVBQUV3ZixNQUFNM2xCLEVBQUVKLEdBQUcyQyxLQUFLK2pCLGNBQWMsUUFBUW5nQixHQUFHLEdBQUdwRixJQUFJd0IsS0FBSytqQixjQUFjLFFBQVF2bEIsR0FBR2YsRUFBRTRDLFFBQVEsT0FBTzlCLEVBQUU0QixRQUFRMUMsRUFBRXVDLEtBQUs4aUIsWUFBWXZrQixHQUFHeUIsS0FBS3FpQixjQUFhLEVBQUdyaUIsS0FBSzBKLEtBQUsxTSxFQUFFcUcsY0FBYyxRQUFRTyxHQUFHLE1BQU1nSyxFQUFFdFAsRUFBRUEsRUFBRStCLE9BQU8sR0FBR0wsS0FBSytoQixjQUFjblUsRUFBRXRJLElBQUlzSSxFQUFFM00sU0FBUzFDLEVBQUU0QixRQUFRLEdBQUc1QixFQUFFOEIsT0FBTyxFQUFFLGNBQWM5QixFQUFFZCxHQUFHLElBQUlsQixFQUFFeUQsS0FBSzhMLFNBQVN1SCxZQUFZLHFCQUFxQi9VLEVBQUUvQixFQUFFd21CLFVBQVV4a0IsR0FBR0QsSUFBSUEsRUFBRS9CLEVBQUV5bUIsYUFBYXprQixJQUFJRCxFQUFFa0gsS0FBSzNCLEtBQUtwRyxHQUFHLGdCQUFnQmMsRUFBRWQsR0FBRyxNQUFNbEIsRUFBRU0sRUFBRThpQixlQUFlM2YsS0FBS2lrQixXQUFXN2hCLGNBQWMsTUFBTSxDQUFDa0QsSUFBSS9HLEVBQUVnSCxJQUFJaEgsRUFBRXFkLElBQUksRUFBRTNhLFNBQVN4RCxFQUFFeW1CLEtBQUszbkIsRUFBRXNmLEtBQUt0ZixFQUFFdUosV0FBV0osVUFBVW5ILEVBQUVtQyxLQUFLLFNBQVMsZ0JBQWdCLE9BQU9WLEtBQUs4TCxTQUFTdUgsWUFBWSxVQUFVdFMsV0FBV3dTLEtBQUssZ0JBQWdCLE9BQU92VCxLQUFLOEwsU0FBU3VILFlBQVksVUFBVXZTLFdBQVd5UyxLQUFLLHNCQUFzQmhWLEdBQUcsT0FBTyxJQUFJQSxFQUFFLElBQUl3RyxXQUFXLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxHQUFHLE1BQU0sSUFBSXhHLEVBQUUsSUFBSXdHLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUcsTUFBTSxJQUFJeEcsRUFBRSxJQUFJd0csV0FBVyxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksR0FBRyxJQUFJLEVBQUUsR0FBRyxHQUFHLEVBQUUsSUFBSSxFQUFFLE1BQU0sSUFBSXhHLEVBQUUsSUFBSXdHLFdBQVcsQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLEdBQUcsSUFBSSxFQUFFLEdBQUcsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEdBQUcsSUFBSSxFQUFFLEVBQUUsS0FBSyxJQUFJeEcsRUFBRSxJQUFJd0csV0FBVyxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksR0FBRyxJQUFJLEVBQUUsR0FBRyxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLElBQUksRUFBRSxLQUFLLElBQUl4RyxFQUFFLElBQUl3RyxXQUFXLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxHQUFHLElBQUksRUFBRSxHQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsSUFBSSxFQUFFLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxNQUFNLE1BQU10SCxFQUFFZ0IsUUFBUTVCLEdBQUcsU0FBUzBCLEVBQUVkLEVBQUVsQixHQUFnQlUsT0FBT0MsZUFBZU8sRUFBRSxhQUFhLENBQUNELE9BQU0sSUFBSyxJQUFJYyxFQUFFL0IsRUFBRSxHQUFHLE1BQU1jLEVBQUUsWUFBWWtCLEdBQUcsT0FBT0QsRUFBRXVCLE9BQU9za0IsWUFBWTVsQixHQUFHLGVBQWVBLEVBQUVkLEtBQUtsQixHQUFHLE1BQU1pQyxFQUFFLElBQUlGLEVBQUV1QixPQUFPLE9BQU9yQixFQUFFNGtCLE1BQU0vbEIsRUFBRXdlLEtBQUt0ZCxHQUFHbEIsRUFBRXFELEtBQUtqRCxNQUFNbEIsR0FBR2lDLEVBQUV1SCxPQUFPLGlCQUFpQnhILEVBQUVkLEdBQUcsT0FBTyxJQUFJc0gsV0FBVyxDQUFDeEcsRUFBRWQsR0FBRyxHQUFHLElBQUlBLEdBQUcsRUFBRSxJQUFJLElBQUlBLElBQUksY0FBYyxPQUFPSixFQUFFK21CLFFBQVEsR0FBRyxPQUFPLElBQUlyZixXQUFXLENBQUMsSUFBSSxJQUFJLElBQUksSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLElBQUksSUFBSSxJQUFJLElBQUksR0FBRyxJQUFJLEdBQUcsTUFBTSxhQUFhckUsS0FBS25DLEVBQUVnVixLQUFLOVYsSUFBSSxJQUFJbEIsRUFBRStCLEVBQUUsRUFBRUUsRUFBRW5CLEVBQUVnbkIsS0FBSzVtQixFQUFFd0QsU0FBU3hELEVBQUVrSCxXQUFXcEksRUFBRSxVQUFVZ0MsRUFBRWxCLEVBQUVpbkIsVUFBVTdtQixHQUFHSixFQUFFa25CLFVBQVU5bUIsR0FBRyxJQUFJTyxFQUFFWCxFQUFFbW5CLEtBQUsvbUIsRUFBRXdELFNBQVN4RCxFQUFFa0gsV0FBVyxJQUFJbEgsRUFBRXdDLElBQUksTUFBTSxDQUFDekIsRUFBRWpDLEVBQUV5QixHQUFHa08sUUFBUTNOLElBQUlELEdBQUdDLEVBQUV1SCxhQUFhekksRUFBRSttQixRQUFROWxCLEVBQUUsT0FBT0UsRUFBRWpDLEVBQUV5QixHQUFHLFlBQVlPLEVBQUVkLEVBQUUsS0FBSyxJQUFJbEIsRUFBRSxJQUFJd0ksV0FBVyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFdEgsSUFBSSxHQUFHLElBQUlBLElBQUksR0FBRyxJQUFJQSxJQUFJLEVBQUUsSUFBSSxJQUFJQSxFQUFFYyxJQUFJLEdBQUcsSUFBSUEsSUFBSSxHQUFHLElBQUlBLElBQUksRUFBRSxJQUFJLElBQUlBLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxJQUFJLElBQUksSUFBSSxNQUFNLE9BQU9sQixFQUFFK21CLFFBQVEsRUFBRTduQixFQUFFOEQsT0FBTyxPQUFPLElBQUkwRSxXQUFXeEksSUFBSSxpQkFBaUJnQyxHQUFHLElBQUlkLEVBQUUsRUFBRWxCLEVBQUVjLEVBQUVvbkIsS0FBSyxDQUFDeGtCLEdBQUcsRUFBRWdCLFNBQVMxQyxFQUFFMEMsU0FBUzBELFVBQVVwRyxFQUFFb0csV0FBVyxJQUFJdEQsTUFBTTlDLEVBQUU2RyxhQUFhOUQsT0FBTy9DLEVBQUU0RyxjQUFjekUsS0FBSyxVQUFVcEMsRUFBRWpCLEVBQUVxbkIsS0FBSyxDQUFDaGtCLEtBQUssUUFBUWlFLFVBQVVwRyxFQUFFb0csV0FBVyxJQUFJMUQsU0FBUzFDLEVBQUUwQyxTQUFTNEQsS0FBS3RHLEVBQUVzRyxLQUFLOUMsU0FBU3hELEVBQUV3RCxTQUFTVixNQUFNOUMsRUFBRTZHLGFBQWE5RCxPQUFPL0MsRUFBRTRHLGdCQUFnQixNQUFNLENBQUM1SSxFQUFFK0IsR0FBRzROLFFBQVEzTixJQUFJZCxHQUFHYyxFQUFFdUgsYUFBYXpJLEVBQUUrbUIsUUFBUTNtQixFQUFFLE9BQU9sQixFQUFFK0IsR0FBRyxpQkFBaUJDLEdBQUcsSUFBSWQsRUFBRSxFQUFFbEIsRUFBRWMsRUFBRW9uQixLQUFLLENBQUN4a0IsR0FBRyxFQUFFZ0IsU0FBUzFDLEVBQUUwQyxTQUFTMEQsVUFBVXBHLEVBQUVvRyxXQUFXLElBQUl0RCxNQUFNLEVBQUVDLE9BQU8sRUFBRVosS0FBSyxVQUFVcEMsRUFBRWpCLEVBQUVxbkIsS0FBSyxDQUFDaGtCLEtBQUssUUFBUWlFLFVBQVVwRyxFQUFFb0csV0FBVyxJQUFJMUQsU0FBUzFDLEVBQUUwQyxTQUFTbUIsYUFBYTdELEVBQUU2RCxhQUFhdWlCLFdBQVdwbUIsRUFBRTJELFdBQVd1QyxPQUFPbEcsRUFBRWtHLFNBQVMsTUFBTSxDQUFDbEksRUFBRStCLEdBQUc0TixRQUFRM04sSUFBSWQsR0FBR2MsRUFBRXVILGFBQWF6SSxFQUFFK21CLFFBQVEzbUIsRUFBRSxPQUFPbEIsRUFBRStCLEdBQUcsWUFBWUMsR0FBRyxJQUFJZCxFQUFFYyxFQUFFMEIsR0FBRzFELEVBQUVnQyxFQUFFMEMsU0FBUzNDLEVBQUVDLEVBQUU4QyxNQUFNN0MsRUFBRUQsRUFBRStDLE9BQU90RCxFQUFFLElBQUkrRyxXQUFXLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUV0SCxJQUFJLEdBQUcsSUFBSUEsSUFBSSxHQUFHLElBQUlBLElBQUksRUFBRSxJQUFJLElBQUlBLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRWxCLElBQUksR0FBRyxJQUFJQSxJQUFJLEdBQUcsSUFBSUEsSUFBSSxFQUFFLElBQUksSUFBSUEsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFK0IsSUFBSSxFQUFFLElBQUksSUFBSUEsRUFBRSxFQUFFLEVBQUVFLElBQUksRUFBRSxJQUFJLElBQUlBLEVBQUUsRUFBRSxJQUFJLE9BQU9uQixFQUFFK21CLFFBQVEsRUFBRXBtQixFQUFFOEgsV0FBVyxPQUFPOUgsR0FBRyxZQUFZTyxHQUFHLElBQUlkLEVBQUUsSUFBSWEsRUFBRXVCLE9BQU90RCxFQUFFZ0MsRUFBRTBDLFNBQVN6QyxFQUFFRCxFQUFFcW1CLFVBQVUsT0FBT25uQixFQUFFMmxCLE1BQU0vbEIsRUFBRXdlLEtBQUssSUFBSXhlLEVBQUVxRCxLQUFLLFNBQVNqRCxFQUFFMmxCLE1BQU0vbEIsRUFBRXdlLEtBQUssSUFBSXhlLEVBQUVxRCxLQUFLLFNBQVNqRCxFQUFFMmxCLE1BQU0sSUFBSXJlLFdBQVcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFeEksR0FBRyxHQUFHLElBQUlBLEdBQUcsR0FBRyxJQUFJQSxHQUFHLEVBQUUsSUFBSSxJQUFJQSxFQUFFaUMsR0FBRyxHQUFHLElBQUlBLEdBQUcsR0FBRyxJQUFJQSxHQUFHLEVBQUUsSUFBSSxJQUFJQSxFQUFFLEVBQUUsRUFBRSxFQUFFLEtBQUtmLEVBQUVzSSxPQUFPLFlBQVl4SCxHQUFHLElBQUlkLEVBQUUsRUFBRWxCLEVBQUVjLEVBQUV3bkIsS0FBS3RtQixFQUFFb0csVUFBVXBHLEVBQUUwQyxVQUFVM0MsRUFBRWpCLEVBQUV5bkIsS0FBS3ZtQixFQUFFbUMsTUFBTWxDLEVBQUVuQixFQUFFMG5CLEtBQUt4bUIsR0FBRyxNQUFNLENBQUNoQyxFQUFFK0IsRUFBRUUsR0FBRzBOLFFBQVEzTixJQUFJZCxHQUFHYyxFQUFFdUgsYUFBYXpJLEVBQUUrbUIsUUFBUTNtQixFQUFFLE9BQU9sQixFQUFFK0IsRUFBRUUsR0FBRyxZQUFZRCxFQUFFLElBQUlkLEdBQUcsSUFBSWxCLEVBQUUsSUFBSXdJLFdBQVcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUV4RyxJQUFJLEdBQUcsSUFBSUEsSUFBSSxHQUFHLElBQUlBLElBQUksRUFBRSxJQUFJLElBQUlBLEVBQUVkLElBQUksR0FBRyxJQUFJQSxJQUFJLEdBQUcsSUFBSUEsSUFBSSxFQUFFLElBQUksSUFBSUEsRUFBRSxHQUFHLElBQUksRUFBRSxJQUFJLE9BQU9KLEVBQUUrbUIsUUFBUSxHQUFHN25CLEVBQUV1SixXQUFXLE9BQU96SSxFQUFFMm5CLFVBQVUsRUFBRSxHQUFHem9CLEdBQUcsWUFBWWdDLEdBQUcsSUFBSWQsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxJQUFJLElBQUksSUFBSSxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsSUFBSSxJQUFJLElBQUksSUFBSSxHQUFHLEdBQUcsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLEdBQUcsTUFBTSxVQUFVYyxJQUFJZCxFQUFFeVUsT0FBTyxFQUFFLEVBQUUsSUFBSSxJQUFJLElBQUksS0FBS3pVLEVBQUV5VSxPQUFPLEdBQUcsR0FBRyxHQUFHLElBQUksSUFBSSxJQUFJLElBQUksR0FBRyxHQUFHLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJN1UsRUFBRSttQixRQUFRLEVBQUUzbUIsRUFBRTRDLE9BQU8sT0FBTyxJQUFJMEUsV0FBV3RILElBQUksWUFBWWMsR0FBRyxJQUFJZCxFQUFFLEVBQUVsQixFQUFFLFVBQVVnQyxFQUFFbUMsS0FBS3JELEVBQUU0bkIsT0FBTzVuQixFQUFFNm5CLE9BQU81bUIsRUFBRWpCLEVBQUU4bkIsT0FBTzNtQixFQUFFbkIsRUFBRStuQixLQUFLN21CLEdBQUcsTUFBTSxDQUFDaEMsRUFBRStCLEVBQUVFLEdBQUcwTixRQUFRM04sSUFBSWQsR0FBR2MsRUFBRXVILGFBQWF6SSxFQUFFK21CLFFBQVEzbUIsRUFBRSxPQUFPbEIsRUFBRStCLEVBQUVFLEdBQUcsY0FBYyxPQUFPbkIsRUFBRSttQixRQUFRLEdBQUcsT0FBTyxJQUFJcmYsV0FBVyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxLQUFLLGNBQWMsT0FBTzFILEVBQUUrbUIsUUFBUSxHQUFHLE9BQU8sSUFBSXJmLFdBQVcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEtBQUssY0FBYyxJQUFJeEcsRUFBRSxJQUFJRCxFQUFFdUIsT0FBTyxPQUFPdEIsRUFBRTZrQixNQUFNL2xCLEVBQUV3ZSxLQUFLLElBQUl4ZSxFQUFFcUQsS0FBSyxRQUFRckQsRUFBRXdlLEtBQUssSUFBSXhlLEVBQUVxRCxLQUFLLFFBQVEsSUFBSXFFLFdBQVcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxJQUFJLElBQUksSUFBSSxHQUFHLEVBQUUsRUFBRSxFQUFFLEtBQUt4RyxFQUFFd0gsT0FBTyxZQUFZeEgsR0FBRyxJQUFJZCxFQUFFLEVBQUVsQixFQUFFYyxFQUFFZ29CLEtBQUs5bUIsR0FBR0QsRUFBRWpCLEVBQUVpb0IsT0FBTzltQixFQUFFbkIsRUFBRWtvQixPQUFPdm5CLEVBQUVYLEVBQUVtb0IsT0FBT3hvQixFQUFFSyxFQUFFb29CLE9BQU8sTUFBTSxDQUFDbHBCLEVBQUUrQixFQUFFRSxFQUFFUixFQUFFaEIsR0FBR2tQLFFBQVEzTixJQUFJZCxHQUFHYyxFQUFFdUgsYUFBYXpJLEVBQUUrbUIsUUFBUTNtQixFQUFFLE9BQU9sQixFQUFFK0IsRUFBRUUsRUFBRVIsRUFBRWhCLEdBQUcsWUFBWXVCLEdBQUcsSUFBSWQsRUFBRSxPQUFPQSxFQUFFLFVBQVVjLEVBQUVtQyxLQUFLckQsRUFBRXFvQixLQUFLbm5CLEdBQUdsQixFQUFFc29CLEtBQUtwbkIsR0FBR2xCLEVBQUUrbUIsUUFBUSxHQUFHM21CLEVBQUVxSSxXQUFXLE9BQU96SSxFQUFFMm5CLFVBQVUsRUFBRSxHQUFHLElBQUlqZ0IsV0FBVyxDQUFDLEVBQUUsRUFBRSxFQUFFLElBQUl0SCxHQUFHLFlBQVljLEdBQUcsSUFBSWQsRUFBRSxJQUFJc0gsV0FBVyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRXhHLEVBQUU2RCxhQUFhLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFN0QsRUFBRW9tQixZQUFZLEVBQUUsSUFBSSxJQUFJcG1CLEVBQUVvbUIsV0FBVyxFQUFFLElBQUlwb0IsRUFBRWMsRUFBRXVvQixLQUFLcm5CLEVBQUVrRyxRQUFRLE9BQU9wSCxFQUFFK21CLFFBQVEsRUFBRTNtQixFQUFFcUksV0FBV3ZKLEVBQUV1SixXQUFXLE9BQU9ySSxFQUFFbEIsR0FBRyxZQUFZZ0MsRUFBRSxDQUFDLEdBQUcsSUFBSSxFQUFFLElBQUksTUFBTWQsRUFBRWMsRUFBRThCLE9BQU8sSUFBSTlELEVBQUUsSUFBSStCLEVBQUV1QixPQUFPckIsRUFBRSxJQUFJdUcsV0FBVyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxHQUFHdEgsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUdBLEVBQUUsR0FBRyxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxHQUFHa1AsT0FBTyxDQUFDbFAsSUFBSWtQLE9BQU9wTyxHQUFHb08sT0FBTyxDQUFDLEVBQUUsRUFBRSxLQUFLLE9BQU9wUSxFQUFFNm1CLE1BQU0vbEIsRUFBRXdlLEtBQUssRUFBRXJkLEVBQUVzSCxZQUFZekksRUFBRXFELEtBQUssUUFBUWxDLEdBQUdqQyxFQUFFd0osT0FBTyxZQUFZeEgsR0FBRyxJQUFJZCxFQUFFLElBQUlhLEVBQUV1QixPQUFPdEQsRUFBRWdDLEVBQUU4QyxNQUFNN0MsRUFBRUQsRUFBRStDLE9BQU90RCxFQUFFTyxFQUFFd0QsU0FBU1QsT0FBT3RFLEVBQUV1QixFQUFFd0QsU0FBU1YsTUFBTXhFLEVBQUUwQixFQUFFc0csS0FBS3JJLEVBQUUsSUFBSXVJLFdBQVcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRXhJLEdBQUcsRUFBRSxJQUFJLElBQUlBLEVBQUVpQyxHQUFHLEVBQUUsSUFBSSxJQUFJQSxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxHQUFHLElBQUksR0FBRyxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxHQUFHLEdBQUcsS0FBS29GLEVBQUUsSUFBSW1CLFdBQVcsQ0FBQyxFQUFFLEdBQUcsSUFBSSxJQUFJLEVBQUUsR0FBRyxJQUFJLElBQUksRUFBRSxHQUFHLElBQUksTUFBTTZJLEVBQUUsSUFBSTdJLFdBQVcsQ0FBQy9HLEdBQUcsR0FBR0EsR0FBRyxHQUFHLElBQUlBLEdBQUcsRUFBRSxJQUFJLElBQUlBLEVBQUVoQixHQUFHLEdBQUdBLEdBQUcsR0FBRyxJQUFJQSxHQUFHLEVBQUUsSUFBSSxJQUFJQSxJQUFJLE9BQU9TLEVBQUUybEIsTUFBTS9sQixFQUFFd2UsS0FBSyxHQUFHcmYsRUFBRXNKLFdBQVdqSixFQUFFaUosV0FBV2xDLEVBQUVrQyxZQUFZekksRUFBRXFELEtBQUssUUFBUWxFLEVBQUVhLEVBQUV3ZSxLQUFLLEVBQUVoZixFQUFFaUosWUFBWXpJLEVBQUVxRCxLQUFLLFFBQVE3RCxFQUFFUSxFQUFFd2UsS0FBSyxJQUFJeGUsRUFBRXFELEtBQUssUUFBUWtELEVBQUV2RyxFQUFFd2UsS0FBSyxJQUFJeGUsRUFBRXFELEtBQUssUUFBUWtOLEdBQUduUSxFQUFFc0ksT0FBTyxjQUFjLElBQUl4SCxFQUFFLElBQUl3RyxXQUFXLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxJQUFJLE9BQU8xSCxFQUFFK21CLFFBQVEsR0FBRyxPQUFPN2xCLEdBQUcsY0FBYyxJQUFJQSxFQUFFLElBQUl3RyxXQUFXLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxJQUFJLE9BQU8xSCxFQUFFK21CLFFBQVEsR0FBRyxPQUFPN2xCLEdBQUcsY0FBYyxJQUFJQSxFQUFFLElBQUl3RyxXQUFXLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxJQUFJLE9BQU8xSCxFQUFFK21CLFFBQVEsR0FBRyxPQUFPN2xCLEdBQUcsY0FBYyxJQUFJQSxFQUFFLElBQUl3RyxXQUFXLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLElBQUksT0FBTzFILEVBQUUrbUIsUUFBUSxHQUFHLE9BQU83bEIsR0FBRyxZQUFZQSxFQUFFZCxFQUFFLElBQUlsQixHQUFHLElBQUlpQyxFQUFFLElBQUlGLEVBQUV1QixPQUFPN0IsRUFBRU0sRUFBRXVCLE9BQU9za0IsWUFBWTVsQixHQUFHLE9BQU9DLEVBQUU0a0IsTUFBTS9sQixFQUFFd2UsS0FBSyxJQUFJeGUsRUFBRXFELEtBQUssUUFBUXJELEVBQUV3ZSxLQUFLLElBQUl4ZSxFQUFFcUQsS0FBSyxRQUFRckQsRUFBRTJuQixVQUFVLEVBQUUsR0FBR2huQixFQUFFWCxFQUFFd29CLEtBQUt0cEIsSUFBSWlDLEVBQUV1SCxPQUFPLFlBQVl4SCxHQUFHLElBQUlkLEVBQUUsSUFBSXNILFdBQVcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFeEcsR0FBRyxHQUFHQSxHQUFHLEdBQUcsSUFBSUEsR0FBRyxFQUFFLElBQUksSUFBSUEsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxJQUFJLE9BQU9sQixFQUFFK21CLFFBQVEsRUFBRTNtQixFQUFFcUksV0FBVyxPQUFPckksR0FBRyxZQUFZYyxHQUFHLElBQUlkLEVBQUUsRUFBRWxCLEVBQUVjLEVBQUV5b0IsT0FBT3huQixFQUFFakIsRUFBRTBvQixLQUFLeG5CLEdBQUcsTUFBTSxDQUFDaEMsRUFBRStCLEdBQUc0TixRQUFRM04sSUFBSWQsR0FBR2MsRUFBRXVILGFBQWF6SSxFQUFFK21CLFFBQVEzbUIsRUFBRSxPQUFPbEIsRUFBRStCLEdBQUcsY0FBYyxJQUFJQyxFQUFFRCxFQUFFdUIsT0FBT3NrQixZQUFZOW1CLEVBQUUyb0IsVUFBVSxPQUFPM29CLEVBQUUyb0IsVUFBVSxFQUFFM29CLEVBQUUrbUIsUUFBUSxHQUFHLE9BQU8vbUIsRUFBRTJuQixVQUFVLEVBQUUsR0FBR3ptQixHQUFHLFlBQVlBLEdBQUcsSUFBSWQsRUFBRSxFQUFFbEIsRUFBRWMsRUFBRTRvQixLQUFLMW5CLEVBQUUwQixJQUFJM0IsRUFBRWpCLEVBQUU2b0IsS0FBSzNuQixFQUFFc2xCLE1BQU1ybEIsRUFBRW5CLEVBQUU4b0IsS0FBSzVuQixHQUFHUCxFQUFFWCxFQUFFK29CLEtBQUs3bkIsRUFBRUMsRUFBRXNILFlBQVksTUFBTSxDQUFDdkosRUFBRStCLEVBQUVOLEVBQUVRLEdBQUcwTixRQUFRM04sSUFBSWQsR0FBR2MsRUFBRXVILGFBQWF6SSxFQUFFK21CLFFBQVEzbUIsRUFBRSxPQUFPbEIsRUFBRStCLEVBQUVOLEVBQUVRLEdBQUcsWUFBWUQsR0FBRyxJQUFJZCxFQUFFYSxFQUFFdUIsT0FBT3NrQixZQUFZNWxCLEdBQUcsT0FBT2xCLEVBQUUrbUIsUUFBUSxHQUFHLE9BQU8vbUIsRUFBRTJuQixVQUFVLEVBQUUsR0FBR3ZuQixHQUFHLFlBQVljLEdBQUcsT0FBT2xCLEVBQUUrbUIsUUFBUSxHQUFHLE9BQU8vbUIsRUFBRTJuQixVQUFVLEVBQUUsR0FBRzFtQixFQUFFdUIsT0FBT3NrQixZQUFZNWxCLElBQUksWUFBWUEsRUFBRWQsR0FBRyxJQUFJbEIsRUFBRSxJQUFJK0IsRUFBRXVCLE9BQU9yQixFQUFFRixFQUFFdUIsT0FBT3NrQixZQUFZNWxCLEVBQUU0QixRQUFRRSxRQUFRckMsRUFBRU0sRUFBRXVCLE9BQU9za0IsWUFBWSxHQUFHLEdBQUc1bEIsRUFBRTRCLFFBQVFFLE9BQU81QyxHQUFHLE9BQU9sQixFQUFFNm1CLE1BQU0vbEIsRUFBRXdlLEtBQUssR0FBRyxHQUFHdGQsRUFBRTRCLFFBQVFFLFFBQVFoRCxFQUFFcUQsS0FBSyxRQUFRLElBQUlxRSxXQUFXLENBQUMsRUFBRSxFQUFFLEdBQUcsSUFBSXZHLEVBQUVSLEdBQUdPLEVBQUU0QixRQUFRK0wsUUFBUTNOLElBQUksTUFBTWQsRUFBRWMsRUFBRStrQixNQUFNL21CLEVBQUU2bUIsTUFBTSxJQUFJcmUsV0FBVyxDQUFDeEcsRUFBRTBDLFdBQVcsR0FBRyxJQUFJMUMsRUFBRTBDLFdBQVcsR0FBRyxJQUFJMUMsRUFBRTBDLFdBQVcsRUFBRSxJQUFJLElBQUkxQyxFQUFFMEMsU0FBUzFDLEVBQUVzZCxPQUFPLEdBQUcsSUFBSXRkLEVBQUVzZCxPQUFPLEdBQUcsSUFBSXRkLEVBQUVzZCxPQUFPLEVBQUUsSUFBSSxJQUFJdGQsRUFBRXNkLEtBQUtwZSxFQUFFOGxCLFdBQVcsRUFBRTlsQixFQUFFK2xCLFVBQVUvbEIsRUFBRWdtQixjQUFjLEVBQUVobUIsRUFBRWltQixlQUFlLEVBQUVqbUIsRUFBRWttQixVQUFVLEVBQUUsRUFBRXBsQixFQUFFcWQsTUFBTSxHQUFHLElBQUlyZCxFQUFFcWQsTUFBTSxHQUFHLElBQUlyZCxFQUFFcWQsTUFBTSxFQUFFLElBQUksSUFBSXJkLEVBQUVxZCxTQUFTcmYsRUFBRXdKLE9BQU8sWUFBWXhILEdBQUcsSUFBSWQsRUFBRSxJQUFJYSxFQUFFdUIsT0FBTyxPQUFPcEMsRUFBRTJsQixNQUFNL2xCLEVBQUV3ZSxLQUFLLEdBQUd0ZCxFQUFFNEIsUUFBUUUsUUFBUWhELEVBQUVxRCxLQUFLLFFBQVFyRCxFQUFFMm5CLFVBQVUsRUFBRSxJQUFJem1CLEVBQUU0QixRQUFRK0wsUUFBUTNOLElBQUksTUFBTWhDLEVBQUVnQyxFQUFFK2tCLE1BQU1obEIsRUFBRS9CLEVBQUVnbkIsV0FBVyxFQUFFaG5CLEVBQUVpbkIsV0FBVyxFQUFFam5CLEVBQUVrbkIsY0FBYyxFQUFFbG5CLEVBQUVtbkIsY0FBY2ptQixFQUFFMmxCLE1BQU0sSUFBSXJlLFdBQVcsQ0FBQ3pHLE9BQU9iLEVBQUVzSSxPQUFPLFlBQVl4SCxHQUFHLElBQUlkLEVBQUUsSUFBSWEsRUFBRXVCLE9BQU90RCxFQUFFLEVBQUVnQyxFQUFFNEIsUUFBUStMLFFBQVEzTixJQUFJaEMsR0FBR2dDLEVBQUVzZCxPQUFPcGUsRUFBRTJsQixNQUFNL2xCLEVBQUV3ZSxLQUFLdGYsR0FBR2MsRUFBRXFELEtBQUssU0FBUyxJQUFJbEMsRUFBRSxJQUFJdUcsV0FBV3hJLEdBQUd5QixFQUFFLEVBQUUsT0FBT1EsRUFBRTZLLElBQUk1TCxFQUFFc0ksT0FBTy9ILEdBQUdBLEdBQUcsRUFBRU8sRUFBRTRCLFFBQVErTCxRQUFRM04sSUFBSUEsRUFBRXdILE9BQU9tRyxRQUFRM04sSUFBSUMsRUFBRTZLLElBQUk5SyxFQUFFUCxHQUFHQSxHQUFHTyxFQUFFdUgsZUFBZXRILEdBQUduQixFQUFFcUQsS0FBS25DLEdBQUcsSUFBSXdHLFdBQVcsQ0FBQ3hHLEVBQUU4bkIsV0FBVyxHQUFHOW5CLEVBQUU4bkIsV0FBVyxHQUFHOW5CLEVBQUU4bkIsV0FBVyxHQUFHOW5CLEVBQUU4bkIsV0FBVyxLQUFLaHBCLEVBQUUyb0IsU0FBUyxFQUFFdm9CLEVBQUVnQixRQUFRcEIsR0FBRyxTQUFTa0IsRUFBRWQsRUFBRWxCLEdBQWdCZ0MsRUFBRTFDLFFBQVEsQ0FBQ2liLFlBQVl2YSxFQUFFLElBQUlrQyxVQUFVLFNBQVNGLEVBQUVkLEVBQUVsQixHQUFnQlUsT0FBT0MsZUFBZU8sRUFBRSxhQUFhLENBQUNELE9BQU0sSUFBSyxNQUFNYyxFQUFFL0IsRUFBRSxHQUFHdUMsT0FBT3FGLGNBQThCMUcsRUFBRWdCLFFBQVEsTUFBTXNCLFlBQVl4QixHQUFHeUIsS0FBS29TLFFBQVFuVixPQUFPMEcsT0FBTyxHQUFHcEYsR0FBR3lCLEtBQUtrSyxJQUFJLEtBQUtsSyxLQUFLc21CLE9BQU8sRUFBRXRtQixLQUFLdU8sTUFBTSxLQUFLdk8sS0FBS3VtQixRQUFRLEtBQUt2bUIsS0FBS3dtQixXQUFVLEVBQUd4bUIsS0FBS3ltQixZQUFXLEVBQUd6bUIsS0FBSzBtQixTQUFTMW1CLEtBQUtvUyxRQUFRc1UsU0FBUzFtQixLQUFLK0YsT0FBTy9GLEtBQUtvUyxRQUFRck0sUUFBUSxnQkFBZ0IvRixLQUFLMm1CLGNBQWMsRUFBRSxPQUFPM21CLEtBQUttSyxHQUFHN0wsRUFBRWtFLFlBQVl4QyxLQUFLMFksS0FBSzNhLEtBQUtpQyxPQUFPLGtCQUFrQixNQUFNLFNBQVMsS0FBS3pCLEVBQUVkLEdBQUcsSUFBSWxCLEVBQUV5RCxLQUFLQSxLQUFLa0ssSUFBSTNMLEVBQUV5QixLQUFLd21CLFdBQVUsRUFBRyxJQUFJbnBCLEVBQUUyQyxLQUFLNG1CLFVBQVVucEIsR0FBRyxPQUFPbEIsRUFBRStiLFNBQVEsRUFBR3VPLE1BQU03bUIsS0FBS2tLLElBQUk3TSxHQUFHaVgsTUFBTSxTQUFTL1YsR0FBRyxHQUFHQSxFQUFFdW9CLEdBQUcsT0FBT3ZxQixFQUFFK3BCLE9BQU8vbkIsRUFBRStuQixPQUFPL3BCLEVBQUV3cUIsaUJBQWlCeG9CLEdBQUdoQyxFQUFFK2IsU0FBUSxFQUFHL2IsRUFBRW1OLEtBQUtwTCxFQUFFcUUsYUFBYXBHLEVBQUVrRSxJQUFJLElBQUlnTCxNQUFNLHlCQUF5QmtOLE9BQU8sU0FBU3BhLEdBQUcsTUFBTWhDLEVBQUUrYixTQUFRLEVBQUcvYixFQUFFbU4sS0FBS3BMLEVBQUVxRSxhQUFhcEcsRUFBRWtFLElBQUlsQyxHQUFHLElBQUlrTixNQUFNbE4sRUFBRWlRLFlBQVksaUJBQWlCalEsR0FBRyxJQUFJZCxFQUFFdUMsS0FBS3pELEVBQUV5RCxLQUFLOEwsU0FBU3VILFlBQVlyVCxLQUFLK0YsUUFBUS9GLEtBQUsybUIsZ0JBQWdCLElBQUk5cEIsRUFBRW1ELEtBQUsybUIsY0FBYyxJQUFHLElBQUtwb0IsRUFBRXVvQixHQUFHLE9BQU85bUIsS0FBSzBtQixVQUFVLEtBQWwyQixFQUF5MkJub0IsRUFBRXlvQixPQUFPMVMsS0FBSy9WLElBQUlkLEVBQUU2YSxTQUFRLEVBQUc3YSxFQUFFK29CLFdBQVcvb0IsRUFBRWdwQixhQUFhbHFCLEdBQUdBLEVBQUVzSCxLQUFLdEYsR0FBR2QsRUFBRWlNLEtBQUtwTCxFQUFFb0UsZ0JBQWdCbkcsSUFBSWtCLEVBQUVpTSxLQUFLcEwsRUFBRW9FLGdCQUFnQm5FLE1BQU0sTUFBTSxLQUF2L0IsRUFBOC9CQSxFQUFFMG9CLE9BQU8zUyxLQUFLL1YsSUFBSWQsRUFBRTZhLFNBQVEsRUFBRzdhLEVBQUUrb0IsV0FBVy9vQixFQUFFZ3BCLGFBQWFscUIsR0FBR0EsRUFBRXNILEtBQUt0RixHQUFHZCxFQUFFaU0sS0FBS3BMLEVBQUVvRSxnQkFBZ0JuRyxJQUFJa0IsRUFBRWlNLEtBQUtwTCxFQUFFb0UsZ0JBQWdCbkUsTUFBTSxNQUFNLEtBQWhvQyxFQUF1b0NBLEVBQUUyb0IsY0FBYzVTLEtBQUsvVixJQUFJZCxFQUFFNmEsU0FBUSxFQUFHN2EsRUFBRStvQixXQUFXL29CLEVBQUVncEIsYUFBYWxxQixHQUFHQSxFQUFFc0gsS0FBSyxJQUFJa0IsV0FBV3hHLElBQUlkLEVBQUVpTSxLQUFLcEwsRUFBRW9FLGdCQUFnQm5HLElBQUlrQixFQUFFaU0sS0FBS3BMLEVBQUVvRSxnQkFBZ0JuRSxNQUFNLE1BQU0sS0FBcHpDLEVBQTJ6QyxRQUFRLE9BQU95QixLQUFLbW5CLFVBQVU1b0IsRUFBRXVlLEtBQUtzSyxZQUFZdnFCLElBQUksVUFBVTBCLEVBQUVkLEdBQUcsSUFBSWxCLEVBQUV5RCxLQUFLOEwsU0FBU3VILFlBQVlyVCxLQUFLK0YsUUFBUSxJQUFJeEosR0FBR3lELEtBQUt1bUIsU0FBU3ZtQixLQUFLeW1CLFdBQVcsSUFBSXptQixLQUFLdW1CLFFBQVEzTyxTQUFTLE1BQU1yWixJQUFJLEdBQUd5QixLQUFLdW1CLFFBQVFob0IsR0FBRSxJQUFLeUIsS0FBS3NZLFFBQVEsT0FBTyxJQUFJamIsRUFBRTJDLEtBQUtBLEtBQUt1bUIsU0FBU3ZtQixLQUFLdW1CLFFBQVFjLE9BQU8vUyxNQUFNLFNBQVM5VixHQUFHLEdBQUdBLEVBQUU4VyxLQUFLLE9BQU9qWSxFQUFFaWIsU0FBUSxFQUFHamIsRUFBRWlwQixPQUFPLE9BQU9qcEIsRUFBRXFNLEtBQUtwTCxFQUFFb0UsZ0JBQWdCbkcsR0FBRyxJQUFJYyxFQUFFbXBCLFlBQVlucEIsRUFBRW9wQixXQUFXLE9BQU9scUIsRUFBRXNILEtBQUtyRixFQUFFaEIsT0FBT0gsRUFBRXFNLEtBQUtwTCxFQUFFbUUsa0JBQWtCbEcsR0FBR2MsRUFBRThwQixVQUFVNW9CLEVBQUVkLEdBQUcsR0FBR0osRUFBRWtwQixRQUFRLElBQUlscEIsRUFBRWtwQixRQUFRM08sU0FBUyxNQUFNclosUUFBUW9hLE1BQU1wYSxJQUFJbEIsRUFBRWliLFNBQVEsRUFBR2piLEVBQUVxTSxLQUFLcEwsRUFBRXFFLGFBQWF0RixFQUFFb0QsSUFBSWxDLEtBQUssVUFBVUEsR0FBRyxJQUFJZCxFQUFFUixPQUFPMEcsT0FBTyxHQUFHcEYsR0FBR2hDLEVBQUUsSUFBSStxQixRQUFRaHBCLEVBQUUsQ0FBQ3VYLE9BQU8sTUFBTTJDLFFBQVFqYyxFQUFFbUIsS0FBSyxPQUFPNnBCLE1BQU0sV0FBVyxHQUFHLGlCQUFpQnZuQixLQUFLb1MsUUFBUW9HLFFBQVEsQ0FBQyxJQUFJamEsRUFBRXlCLEtBQUtvUyxRQUFRb0csUUFBUSxJQUFJLElBQUkvYSxLQUFLYyxFQUFFQSxFQUFFSCxlQUFlWCxJQUFJbEIsRUFBRWlyQixPQUFPL3BCLEVBQUVjLEVBQUVkLElBQUksR0FBRyxpQkFBaUJBLEVBQUUrYSxRQUFRLENBQUMsSUFBSWphLEVBQUVkLEVBQUUrYSxRQUFRLElBQUksSUFBSS9hLEtBQUtjLEVBQUVBLEVBQUVILGVBQWVYLElBQUlsQixFQUFFaXJCLE9BQU8vcEIsRUFBRWMsRUFBRWQsSUFBSSxPQUFNLElBQUtBLEVBQUVncUIsT0FBT25wQixFQUFFWixLQUFLLGVBQWVELEVBQUVpcUIsa0JBQWtCcHBCLEVBQUVxcEIsWUFBWSxXQUFXcnBCLEVBQUUsU0FBUyxHQUFHMEIsS0FBS3VtQixRQUFRLENBQUMsSUFBSXZtQixLQUFLdW1CLFFBQVEzTyxTQUFTLE1BQU1yWixJQUFJeUIsS0FBS3VtQixRQUFRLEtBQUt2bUIsS0FBS3NZLFNBQVEsRUFBR3RZLEtBQUt3bUIsV0FBVSxHQUFJLFVBQVV4bUIsS0FBS3ltQixZQUFXLEVBQUd6bUIsS0FBSzRYLGdCOzs7OzJEQ0F4ajNFLEksSUFBQSxpRSxJQUNBLCtELG1EQVlBOWIsRUFBT0QsUUFUTCxXQUFhNEksR0FDWCxPLDRGQURtQixTQUNmQSxFQUFPOEUsT0FDRixJQUFJcWUsVUFBY25qQixHQUVsQixJQUFJb2pCLFVBQWFwakIsSzs7Ozs7Ozs7NENDUjlCM0ksRUFBT0QsUUFBVU0iLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJ4Z3BsYXllclwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJ4Z3BsYXllclwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJ4Z3BsYXllci1mbHZcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJ4Z3BsYXllclwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wieGdwbGF5ZXItZmx2XCJdID0gZmFjdG9yeShyb290W1wieGdwbGF5ZXJcIl0pO1xufSkod2luZG93LCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX3hncGxheWVyX18pIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG4iLCIhZnVuY3Rpb24oZSxuKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1uKHJlcXVpcmUoXCJ4Z3BsYXllclwiKSk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJ4Z3BsYXllclwiXSxuKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzW1wieGdwbGF5ZXItZmx2XCJdPW4ocmVxdWlyZShcInhncGxheWVyXCIpKTplW1wieGdwbGF5ZXItZmx2XCJdPW4oZS54Z3BsYXllcil9KHdpbmRvdywoZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV94Z3BsYXllcl9fKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIG49e307ZnVuY3Rpb24gdChhKXtpZihuW2FdKXJldHVybiBuW2FdLmV4cG9ydHM7dmFyIHI9blthXT17aTphLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbYV0uY2FsbChyLmV4cG9ydHMscixyLmV4cG9ydHMsdCksci5sPSEwLHIuZXhwb3J0c31yZXR1cm4gdC5tPWUsdC5jPW4sdC5kPWZ1bmN0aW9uKGUsbixhKXt0Lm8oZSxuKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7ZW51bWVyYWJsZTohMCxnZXQ6YX0pfSx0LnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sdC50PWZ1bmN0aW9uKGUsbil7aWYoMSZuJiYoZT10KGUpKSw4Jm4pcmV0dXJuIGU7aWYoNCZuJiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBhPU9iamVjdC5jcmVhdGUobnVsbCk7aWYodC5yKGEpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJm4mJlwic3RyaW5nXCIhPXR5cGVvZiBlKWZvcih2YXIgciBpbiBlKXQuZChhLHIsZnVuY3Rpb24obil7cmV0dXJuIGVbbl19LmJpbmQobnVsbCxyKSk7cmV0dXJuIGF9LHQubj1mdW5jdGlvbihlKXt2YXIgbj1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gdC5kKG4sXCJhXCIsbiksbn0sdC5vPWZ1bmN0aW9uKGUsbil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pfSx0LnA9XCJcIix0KHQucz0wKX0oe1wiLi4vLi4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC9Vc2Vycy9sZW9uYXJkby9Eb2N1bWVudHMvZnJvbnQtZW5kL3BsYXllci94Z3BsYXllci9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxuXFxuXFxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbDtcXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJyA/IFIuYXBwbHkgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xcbiAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xcbn07XFxuXFxudmFyIFJlZmxlY3RPd25LZXlzO1xcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcXG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzO1xcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcXG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCkuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XFxuICB9O1xcbn0gZWxzZSB7XFxuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcXG4gIH07XFxufVxcblxcbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XFxuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcXG59XFxuXFxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XFxuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xcbn07XFxuXFxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcXG59XFxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XFxuXFxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcXG5cXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxcbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XFxuICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xcbiAgfSxcXG4gIHNldDogZnVuY3Rpb24gKGFyZykge1xcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XFxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcXFwiZGVmYXVsdE1heExpc3RlbmVyc1xcXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XFxuICAgIH1cXG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcXG4gIH1cXG59KTtcXG5cXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uICgpIHtcXG5cXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XFxuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XFxuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcXG4gIH1cXG5cXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XFxufTtcXG5cXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3NcXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XFxuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXFxcIm5cXFwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcXG4gIH1cXG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XFxuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xcbn1cXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcXG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XFxuICB2YXIgYXJncyA9IFtdO1xcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xcbiAgdmFyIGRvRXJyb3IgPSB0eXBlID09PSAnZXJyb3InO1xcblxcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkgZG9FcnJvciA9IGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQ7ZWxzZSBpZiAoIWRvRXJyb3IpIHJldHVybiBmYWxzZTtcXG5cXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cXG4gIGlmIChkb0Vycm9yKSB7XFxuICAgIHZhciBlcjtcXG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkgZXIgPSBhcmdzWzBdO1xcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXFxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XFxuICAgIH1cXG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcXG4gICAgZXJyLmNvbnRleHQgPSBlcjtcXG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxcbiAgfVxcblxcbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XFxuXFxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XFxuXFxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xcbiAgfSBlbHNlIHtcXG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcXG4gIH1cXG5cXG4gIHJldHVybiB0cnVlO1xcbn07XFxuXFxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcXG4gIHZhciBtO1xcbiAgdmFyIGV2ZW50cztcXG4gIHZhciBleGlzdGluZztcXG5cXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFxcXCJsaXN0ZW5lclxcXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xcbiAgfVxcblxcbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XFxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcXG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFxcXCJuZXdMaXN0ZW5lclxcXCIhIEJlZm9yZVxcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcXFwibmV3TGlzdGVuZXJcXFwiLlxcbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xcblxcbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XFxuICAgIH1cXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XFxuICB9XFxuXFxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcXG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xcbiAgfSBlbHNlIHtcXG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxcbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XFxuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxcbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcXG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcXG4gICAgfVxcblxcbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xcbiAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XFxuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcXG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgKyBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICsgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICsgJ2luY3JlYXNlIGxpbWl0Jyk7XFxuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XFxuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xcbiAgICAgIHcudHlwZSA9IHR5cGU7XFxuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcXG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB0YXJnZXQ7XFxufVxcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcXG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xcbn07XFxuXFxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XFxuICB2YXIgYXJncyA9IFtdO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XFxuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcXG4gICAgUmVmbGVjdEFwcGx5KHRoaXMubGlzdGVuZXIsIHRoaXMudGFyZ2V0LCBhcmdzKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcXG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcXG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcXG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XFxuICByZXR1cm4gd3JhcHBlZDtcXG59XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXFxcImxpc3RlbmVyXFxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XFxuICB9XFxuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XFxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcXFwibGlzdGVuZXJcXFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcXG4gIH1cXG4gIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xcbiAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XFxuXFxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcXFwibGlzdGVuZXJcXFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcXG4gIH1cXG5cXG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XFxuXFxuICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xcbiAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XFxuXFxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcXG4gICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7ZWxzZSB7XFxuICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcXG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcXG4gICAgcG9zaXRpb24gPSAtMTtcXG5cXG4gICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xcbiAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XFxuICAgICAgICBwb3NpdGlvbiA9IGk7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKHBvc2l0aW9uIDwgMCkgcmV0dXJuIHRoaXM7XFxuXFxuICAgIGlmIChwb3NpdGlvbiA9PT0gMCkgbGlzdC5zaGlmdCgpO2Vsc2Uge1xcbiAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XFxuICAgIH1cXG5cXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xcblxcbiAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcXG4gIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcXG5cXG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XFxuXFxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XFxuICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcXG4gICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcbiAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcXG4gICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xcbiAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO2Vsc2UgZGVsZXRlIGV2ZW50c1t0eXBlXTtcXG4gICAgfVxcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG5cXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xcbiAgICB2YXIga2V5O1xcbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xcbiAgICAgIGtleSA9IGtleXNbaV07XFxuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XFxuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcXG4gICAgfVxcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcXG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcXG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG5cXG4gIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcXG5cXG4gIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcXG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcXG4gICAgLy8gTElGTyBvcmRlclxcbiAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xcblxcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XFxuXFxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcXG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpIHJldHVybiBbXTtcXG5cXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xcblxcbiAgcmV0dXJuIHVud3JhcCA/IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xcbn1cXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XFxuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcXG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcXG59O1xcblxcbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcXG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xcbiAgfVxcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcXG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XFxuXFxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcXG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XFxuXFxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIHJldHVybiAxO1xcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIDA7XFxufVxcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XFxuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xcbn07XFxuXFxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcXG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIGNvcHlbaV0gPSBhcnJbaV07XFxuICByZXR1cm4gY29weTtcXG59XFxuXFxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XFxuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xcbiAgbGlzdC5wb3AoKTtcXG59XFxuXFxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XFxuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XFxuICB9XFxuICByZXR1cm4gcmV0O1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvL1VzZXJzL2xlb25hcmRvL0RvY3VtZW50cy9mcm9udC1lbmQvcGxheWVyL3hncGxheWVyL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzP1wiKX0sXCIuLi94Z3BsYXllci1idWZmZXIvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLWJ1ZmZlci9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKCdcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHtcXG4gIFRyYWNrOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy90cmFjayAqLyBcIi4uL3hncGxheWVyLWJ1ZmZlci9zcmMvdHJhY2suanNcIikuZGVmYXVsdCxcXG4gIFRyYWNrczogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvdHJhY2sgKi8gXCIuLi94Z3BsYXllci1idWZmZXIvc3JjL3RyYWNrLmpzXCIpLlRyYWNrcyxcXG4gIEF1ZGlvVHJhY2s6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3RyYWNrICovIFwiLi4veGdwbGF5ZXItYnVmZmVyL3NyYy90cmFjay5qc1wiKS5BdWRpb1RyYWNrLFxcbiAgVmlkZW9UcmFjazogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvdHJhY2sgKi8gXCIuLi94Z3BsYXllci1idWZmZXIvc3JjL3RyYWNrLmpzXCIpLlZpZGVvVHJhY2ssXFxuXFxuICBYZ0J1ZmZlcjogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvYnVmZmVyICovIFwiLi4veGdwbGF5ZXItYnVmZmVyL3NyYy9idWZmZXIuanNcIikuWGdCdWZmZXIsXFxuICBSZW11eEJ1ZmZlcjogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvYnVmZmVyICovIFwiLi4veGdwbGF5ZXItYnVmZmVyL3NyYy9idWZmZXIuanNcIikuUmVtdXhCdWZmZXIsXFxuXFxuICBQcmVTb3VyY2U6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3ByZXNvdWNlICovIFwiLi4veGdwbGF5ZXItYnVmZmVyL3NyYy9wcmVzb3VjZS5qc1wiKS5kZWZhdWx0XFxufTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItYnVmZmVyL2luZGV4LmpzPycpfSxcIi4uL3hncGxheWVyLWJ1ZmZlci9zcmMvYnVmZmVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLWJ1ZmZlci9zcmMvYnVmZmVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbCgnXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbmNsYXNzIFhnQnVmZmVyIHtcXG4gIC8qKlxcbiAgICogQSBidWZmZXIgdG8gc3RvcmUgbG9hZGVkIGRhdGEuXFxuICAgKlxcbiAgICogQGNsYXNzIExvYWRlckJ1ZmZlclxcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCAtIE9wdGlvbmFsIHRoZSBidWZmZXIgc2l6ZVxcbiAgICovXFxuICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcXG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGggfHwgMDtcXG4gICAgdGhpcy5oaXN0b3J5TGVuID0gbGVuZ3RoIHx8IDA7XFxuICAgIHRoaXMuYXJyYXkgPSBbXTtcXG4gICAgdGhpcy5vZmZzZXQgPSAwO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBUaGUgZnVuY3Rpb24gdG8gcHVzaCBkYXRhLlxcbiAgICpcXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhIC0gVGhlIGRhdGEgdG8gcHVzaCBpbnRvIHRoZSBidWZmZXJcXG4gICAqL1xcbiAgcHVzaChkYXRhKSB7XFxuICAgIHRoaXMuYXJyYXkucHVzaChkYXRhKTtcXG4gICAgdGhpcy5sZW5ndGggKz0gZGF0YS5ieXRlTGVuZ3RoO1xcbiAgICB0aGlzLmhpc3RvcnlMZW4gKz0gZGF0YS5ieXRlTGVuZ3RoO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBUaGUgZnVuY3Rpb24gdG8gc2hpZnQgZGF0YS5cXG4gICAqXFxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIC0gVGhlIHNpemUgb2Ygc2hpZnQuXFxuICAgKi9cXG4gIHNoaWZ0KGxlbmd0aCkge1xcbiAgICBpZiAodGhpcy5hcnJheS5sZW5ndGggPCAxKSB7XFxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xcbiAgICB9XFxuXFxuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9zaGlmdEJ1ZmZlcigpO1xcbiAgICB9XFxuICAgIGlmICh0aGlzLm9mZnNldCArIGxlbmd0aCA9PT0gdGhpcy5hcnJheVswXS5sZW5ndGgpIHtcXG4gICAgICBsZXQgcmV0ID0gdGhpcy5hcnJheVswXS5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyBsZW5ndGgpO1xcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcXG4gICAgICB0aGlzLmFycmF5LnNoaWZ0KCk7XFxuICAgICAgdGhpcy5sZW5ndGggLT0gbGVuZ3RoO1xcbiAgICAgIHJldHVybiByZXQ7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMub2Zmc2V0ICsgbGVuZ3RoIDwgdGhpcy5hcnJheVswXS5sZW5ndGgpIHtcXG4gICAgICBsZXQgcmV0ID0gdGhpcy5hcnJheVswXS5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyBsZW5ndGgpO1xcbiAgICAgIHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcXG4gICAgICB0aGlzLmxlbmd0aCAtPSBsZW5ndGg7XFxuICAgICAgcmV0dXJuIHJldDtcXG4gICAgfVxcblxcbiAgICBsZXQgcmV0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcXG4gICAgbGV0IHRtcG9mZiA9IDA7XFxuICAgIHdoaWxlICh0aGlzLmFycmF5Lmxlbmd0aCA+IDAgJiYgbGVuZ3RoID4gMCkge1xcbiAgICAgIGlmICh0aGlzLm9mZnNldCArIGxlbmd0aCA8IHRoaXMuYXJyYXlbMF0ubGVuZ3RoKSB7XFxuICAgICAgICBsZXQgdG1wID0gdGhpcy5hcnJheVswXS5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyBsZW5ndGgpO1xcbiAgICAgICAgcmV0LnNldCh0bXAsIHRtcG9mZik7XFxuICAgICAgICB0aGlzLm9mZnNldCArPSBsZW5ndGg7XFxuICAgICAgICB0aGlzLmxlbmd0aCAtPSBsZW5ndGg7XFxuICAgICAgICBsZW5ndGggPSAwO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGxldCB0ZW1wbGVuZ3RoID0gdGhpcy5hcnJheVswXS5sZW5ndGggLSB0aGlzLm9mZnNldDtcXG4gICAgICAgIHJldC5zZXQodGhpcy5hcnJheVswXS5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5hcnJheVswXS5sZW5ndGgpLCB0bXBvZmYpO1xcbiAgICAgICAgdGhpcy5hcnJheS5zaGlmdCgpO1xcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xcbiAgICAgICAgdG1wb2ZmICs9IHRlbXBsZW5ndGg7XFxuICAgICAgICB0aGlzLmxlbmd0aCAtPSB0ZW1wbGVuZ3RoO1xcbiAgICAgICAgbGVuZ3RoIC09IHRlbXBsZW5ndGg7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiByZXQ7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIEZ1bmN0aW9uIHRvIGNsZWFyIHRoZSBidWZmZXIuXFxuICAgKi9cXG4gIGNsZWFyKCkge1xcbiAgICB0aGlzLmFycmF5ID0gW107XFxuICAgIHRoaXMubGVuZ3RoID0gMDtcXG4gICAgdGhpcy5vZmZzZXQgPSAwO1xcbiAgfVxcblxcbiAgZGVzdHJveSgpIHtcXG4gICAgdGhpcy5jbGVhcigpO1xcbiAgICB0aGlzLmhpc3RvcnlMZW4gPSAwO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBGdW5jdGlvbiB0byBzaGlmdCBvbmUgdW5pdDhBcnJheS5cXG4gICAqL1xcbiAgX3NoaWZ0QnVmZmVyKCkge1xcbiAgICB0aGlzLmxlbmd0aCAtPSB0aGlzLmFycmF5WzBdLmxlbmd0aDtcXG4gICAgdGhpcy5vZmZzZXQgPSAwO1xcbiAgICByZXR1cm4gdGhpcy5hcnJheS5zaGlmdCgpO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBDb252ZXJ0IHVpbnQ4IGRhdGEgdG8gbnVtYmVyLlxcbiAgICpcXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHRoZSBzdGFydCBwb3N0aW9uLlxcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCAtIHRoZSBsZW5ndGggb2YgZGF0YS5cXG4gICAqL1xcbiAgdG9JbnQoc3RhcnQsIGxlbmd0aCkge1xcbiAgICBsZXQgcmV0SW50ID0gMDtcXG4gICAgbGV0IGkgPSB0aGlzLm9mZnNldCArIHN0YXJ0O1xcbiAgICB3aGlsZSAoaSA8IHRoaXMub2Zmc2V0ICsgbGVuZ3RoICsgc3RhcnQpIHtcXG4gICAgICBpZiAoaSA8IHRoaXMuYXJyYXlbMF0ubGVuZ3RoKSB7XFxuICAgICAgICByZXRJbnQgPSByZXRJbnQgKiAyNTYgKyB0aGlzLmFycmF5WzBdW2ldO1xcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5hcnJheVsxXSkge1xcbiAgICAgICAgcmV0SW50ID0gcmV0SW50ICogMjU2ICsgdGhpcy5hcnJheVsxXVtpIC0gdGhpcy5hcnJheVswXS5sZW5ndGhdO1xcbiAgICAgIH1cXG5cXG4gICAgICBpKys7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJldEludDtcXG4gIH1cXG59XFxuXFxuZXhwb3J0cy5YZ0J1ZmZlciA9IFhnQnVmZmVyO1xcbmNsYXNzIFJlbXV4QnVmZmVyIHtcXG4gIGNvbnN0cnVjdG9yKCkge1xcbiAgICB0aGlzLnZpZGVvID0gW107XFxuICAgIHRoaXMuYXVkaW8gPSBbXTtcXG4gIH1cXG5cXG4gIGRlc3Ryb3koKSB7XFxuICAgIHRoaXMudmlkZW8gPSBbXTtcXG4gICAgdGhpcy5hdWRpbyA9IFtdO1xcbiAgfVxcbn1cXG5leHBvcnRzLlJlbXV4QnVmZmVyID0gUmVtdXhCdWZmZXI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLWJ1ZmZlci9zcmMvYnVmZmVyLmpzPycpfSxcIi4uL3hncGxheWVyLWJ1ZmZlci9zcmMvcHJlc291Y2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci1idWZmZXIvc3JjL3ByZXNvdWNlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5jbGFzcyBTb3VyY2Uge1xcbiAgY29uc3RydWN0b3IoKSB7XFxuICAgIHRoaXMubWltZXR5cGUgPSAnJztcXG4gICAgdGhpcy5pbml0ID0gbnVsbDtcXG4gICAgdGhpcy5kYXRhID0gW107XFxuICB9XFxufVxcblxcbmNsYXNzIFByZVNvdXJjZSB7XFxuICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgdGhpcy5zb3VyY2VzID0ge307XFxuICB9XFxuXFxuICBnZXRTb3VyY2Uoc291cmNlKSB7XFxuICAgIHJldHVybiB0aGlzLnNvdXJjZXNbc291cmNlXTtcXG4gIH1cXG5cXG4gIGNyZWF0ZVNvdXJjZShuYW1lKSB7XFxuICAgIHRoaXMuc291cmNlc1tuYW1lXSA9IG5ldyBTb3VyY2UoKTtcXG4gICAgcmV0dXJuIHRoaXMuc291cmNlc1tuYW1lXTtcXG4gIH1cXG5cXG4gIGNsZWFyKCkge1xcbiAgICB0aGlzLnNvdXJjZXMgPSB7fTtcXG4gIH1cXG5cXG4gIGRlc3Ryb3koKSB7XFxuICAgIHRoaXMuc291cmNlcyA9IHt9O1xcbiAgfVxcbn1cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBQcmVTb3VyY2U7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLWJ1ZmZlci9zcmMvcHJlc291Y2UuanM/XCIpfSxcIi4uL3hncGxheWVyLWJ1ZmZlci9zcmMvdHJhY2suanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci1idWZmZXIvc3JjL3RyYWNrLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5jbGFzcyBUcmFjayB7XFxuICAvKipcXG4gICAqIFRoZSBjb25zdHJ1Y3Rvci5cXG4gICAqL1xcbiAgY29uc3RydWN0b3IoKSB7XFxuICAgIHRoaXMuaWQgPSAtMTtcXG4gICAgdGhpcy5zZXF1ZW5jZU51bWJlciA9IDA7XFxuICAgIHRoaXMuc2FtcGxlcyA9IFtdO1xcbiAgICB0aGlzLmRyb3BwZWRTYW1wbGVzID0gW107XFxuICAgIHRoaXMubGVuZ3RoID0gMDtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogUmVzZXQgdGhlIHRyYWNrLlxcbiAgICovXFxuICByZXNldCgpIHtcXG4gICAgdGhpcy5zZXF1ZW5jZU51bWJlciA9IDA7XFxuICAgIHRoaXMuc2FtcGxlcyA9IFtdO1xcbiAgICB0aGlzLmxlbmd0aCA9IDA7XFxuICB9XFxuICAvKipcXG4gICAqIGRlc3Ryb3kgdGhlIHRyYWNrLlxcbiAgICovXFxuICBkaXN0cm95KCkge1xcbiAgICB0aGlzLnJlc2V0KCk7XFxuICAgIHRoaXMuaWQgPSAtMTtcXG4gIH1cXG59XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gVHJhY2s7XFxuY2xhc3MgQXVkaW9UcmFjayBleHRlbmRzIFRyYWNrIHtcXG4gIC8qKlxcbiAgICogVGhlIGNvbnN0cnVjdG9yIGZvciBhdWRpbyB0cmFjay5cXG4gICAqL1xcbiAgY29uc3RydWN0b3IoKSB7XFxuICAgIHN1cGVyKCk7XFxuICAgIHRoaXMuVEFHID0gJ0F1ZGlvVHJhY2snO1xcbiAgICB0aGlzLnR5cGUgPSAnYXVkaW8nO1xcbiAgfVxcbn1cXG5cXG5leHBvcnRzLkF1ZGlvVHJhY2sgPSBBdWRpb1RyYWNrO1xcbmNsYXNzIFZpZGVvVHJhY2sgZXh0ZW5kcyBUcmFjayB7XFxuICAvKipcXG4gICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgdmlkZW8gdHJhY2suXFxuICAgKi9cXG4gIGNvbnN0cnVjdG9yKCkge1xcbiAgICBzdXBlcigpO1xcbiAgICB0aGlzLlRBRyA9ICdWaWRlb1RyYWNrJztcXG4gICAgdGhpcy50eXBlID0gJ3ZpZGVvJztcXG4gICAgdGhpcy5kcm9wcGVkID0gMDtcXG4gIH1cXG4gIC8qKlxcbiAgICogcmVzZXQgdGhlIHZpZGVvIHRyYWNrLlxcbiAgICovXFxuICByZXNldCgpIHtcXG4gICAgdGhpcy5zZXF1ZW5jZU51bWJlciA9IDA7XFxuICAgIHRoaXMuc2FtcGxlcyA9IFtdO1xcbiAgICB0aGlzLmxlbmd0aCA9IDA7XFxuICAgIHRoaXMuZHJvcHBlZCA9IDA7XFxuICB9XFxufVxcblxcbmV4cG9ydHMuVmlkZW9UcmFjayA9IFZpZGVvVHJhY2s7XFxuY2xhc3MgVHJhY2tzIHtcXG4gIGNvbnN0cnVjdG9yKCkge1xcbiAgICB0aGlzLmF1ZGlvVHJhY2sgPSBudWxsO1xcbiAgICB0aGlzLnZpZGVvVHJhY2sgPSBudWxsO1xcbiAgfVxcblxcbiAgZGVzdHJveSgpIHtcXG4gICAgdGhpcy5hdWRpb1RyYWNrID0gbnVsbDtcXG4gICAgdGhpcy52aWRlb1RyYWNrID0gbnVsbDtcXG4gIH1cXG59XFxuZXhwb3J0cy5UcmFja3MgPSBUcmFja3M7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLWJ1ZmZlci9zcmMvdHJhY2suanM/XCIpfSxcIi4uL3hncGxheWVyLWNvZGVjL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLWNvZGVjL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbCgnXFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBOYWx1bml0OiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9oMjY0L25hbHVuaXQgKi8gXCIuLi94Z3BsYXllci1jb2RlYy9zcmMvaDI2NC9uYWx1bml0L2luZGV4LmpzXCIpLmRlZmF1bHQsXFxuICBTcHNQYXJzZXI6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2gyNjQvbmFsdW5pdC9zcHMgKi8gXCIuLi94Z3BsYXllci1jb2RlYy9zcmMvaDI2NC9uYWx1bml0L3Nwcy5qc1wiKS5kZWZhdWx0LFxcblxcbiAgQ29tcGF0aWJpbGl0eTogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvY29tcGF0aWJpbGl0eSAqLyBcIi4uL3hncGxheWVyLWNvZGVjL3NyYy9jb21wYXRpYmlsaXR5LmpzXCIpLmRlZmF1bHRcXG59O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci1jb2RlYy9pbmRleC5qcz8nKX0sXCIuLi94Z3BsYXllci1jb2RlYy9zcmMvYWFjL2FhYy1oZWxwZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLWNvZGVjL3NyYy9hYWMvYWFjLWhlbHBlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKCdcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxuY2xhc3MgQUFDIHtcXG5cXG4gIHN0YXRpYyBnZXRTaWxlbnRGcmFtZShjb2RlYywgY2hhbm5lbENvdW50KSB7XFxuICAgIGlmIChjb2RlYyA9PT0gXFwnbXA0YS40MC4yXFwnKSB7XFxuICAgICAgLy8gaGFuZGxlIExDLUFBQ1xcbiAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMywgMHg4MF0pO1xcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MjEsIDB4MDAsIDB4NDksIDB4OTAsIDB4MDIsIDB4MTksIDB4MDAsIDB4MjMsIDB4ODBdKTtcXG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDhlXSk7XFxuICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDQpIHtcXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MCwgMHgyYywgMHg4MCwgMHgwOCwgMHgwMiwgMHgzOF0pO1xcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA1KSB7XFxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MzhdKTtcXG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNikge1xcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDAwLCAweGIyLCAweDAwLCAweDIwLCAweDA4LCAweGUwXSk7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIGhhbmRsZSBIRS1BQUMgKG1wNGEuNDAuNSAvIG1wNGEuNDAuMjkpXFxuICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xcbiAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGUgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgXFwnMTYvMSBcIjB4JXgsXCIgXCJcXFxcblwiXFwnIC12IG91dHB1dC5hYWNcXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDRlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLCAweDAsIDB4MWMsIDB4NiwgMHhmMSwgMHhjMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XFxuICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcXG4gICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgXFwnMTYvMSBcIjB4JXgsXCIgXCJcXFxcblwiXFwnIC12IG91dHB1dC5hYWNcXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDVlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHg5NSwgMHgwLCAweDYsIDB4ZjEsIDB4YTEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XFxuICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgXFwnMTYvMSBcIjB4JXgsXCIgXCJcXFxcblwiXFwnIC12IG91dHB1dC5hYWNcXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDVlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLCAweDAsIDB4MCwgMHg5NSwgMHgwLCAweDYsIDB4ZjEsIDB4YTEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gbnVsbDtcXG4gIH1cXG5cXG59XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gQUFDO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci1jb2RlYy9zcmMvYWFjL2FhYy1oZWxwZXIuanM/Jyl9LFwiLi4veGdwbGF5ZXItY29kZWMvc3JjL2NvbXBhdGliaWxpdHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItY29kZWMvc3JjL2NvbXBhdGliaWxpdHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgX3hncGxheWVyVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB4Z3BsYXllci11dGlscyAqLyBcXFwiLi4veGdwbGF5ZXItdXRpbHMvaW5kZXguanNcXFwiKTtcXG5cXG52YXIgX2FhY0hlbHBlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWFjL2FhYy1oZWxwZXIgKi8gXFxcIi4uL3hncGxheWVyLWNvZGVjL3NyYy9hYWMvYWFjLWhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBfYWFjSGVscGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FhY0hlbHBlcik7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG5jb25zdCB7IFJFTVVYX0VWRU5UUywgREVNVVhfRVZFTlRTIH0gPSBfeGdwbGF5ZXJVdGlscy5FVkVOVFM7XFxuXFxuY2xhc3MgQ29tcGF0aWJpbGl0eSB7XFxuICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgdGhpcy5uZXh0QXVkaW9EdHMgPSAwOyAvLyDmqKHmi5/kuIvkuIDmrrXpn7PpopHmlbDmja7nmoRkdHNcXG4gICAgdGhpcy5uZXh0VmlkZW9EdHMgPSAwOyAvLyDmqKHmi5/kuIvkuIDmrrXop4bpopHmlbDmja7nmoRkdHNcXG5cXG4gICAgdGhpcy5sYXN0QXVkaW9TYW1wbGVzTGVuID0gMDsgLy8g5LiK5LiA5q616Z+z6aKR5pWw5o2u55qE6ZW/5bqmXFxuICAgIHRoaXMubGFzdFZpZGVvU2FtcGxlc0xlbiA9IDA7IC8vIOS4iuS4gOauteinhumikeaVsOaNrueahOmVv+W6plxcblxcbiAgICB0aGlzLmxhc3RWaWRlb0R0cyA9IHVuZGVmaW5lZDsgLy8g5LiK5LiA5q616Z+z6aKR5pWw5o2u55qE6ZW/5bqmXFxuICAgIHRoaXMubGFzdEF1ZGlvRHRzID0gdW5kZWZpbmVkOyAvLyDkuIrkuIDmrrXop4bpopHmlbDmja7nmoTplb/luqZcXG5cXG4gICAgdGhpcy5hbGxBdWRpb1NhbXBsZXNDb3VudCA9IDA7IC8vIOmfs+mikeaAu+aVsOaNrumHjyjljp/lp4vluKcpXFxuICAgIHRoaXMuYWxsVmlkZW9TYW1wbGVzQ291bnQgPSAwOyAvLyDop4bpopHmgLvmlbDmja7ph48o5Y6f5aeL5binKVxcblxcbiAgICB0aGlzLl9maXJzdEF1ZGlvU2FtcGxlID0gbnVsbDtcXG4gICAgdGhpcy5fZmlyc3RWaWRlb1NhbXBsZSA9IG51bGw7XFxuXFxuICAgIHRoaXMuZmlsbGVkQXVkaW9TYW1wbGVzID0gW107IC8vIOihpeWFhemfs+mikeW4p++8iO+8iVxcbiAgICB0aGlzLmZpbGxlZFZpZGVvU2FtcGxlcyA9IFtdOyAvLyDooaXlhYXop4bpopHluKfvvIjvvIlcXG5cXG4gICAgdGhpcy5fdmlkZW9MYXJnZUdhcCA9IDA7XFxuICAgIHRoaXMuX2F1ZGlvTGFyZ2VHYXAgPSAwO1xcbiAgfVxcblxcbiAgaW5pdCgpIHtcXG4gICAgdGhpcy5iZWZvcmUoUkVNVVhfRVZFTlRTLlJFTVVYX01FRElBLCB0aGlzLmRvRml4LmJpbmQodGhpcykpO1xcbiAgfVxcblxcbiAgcmVzZXQoKSB7XFxuICAgIHRoaXMubmV4dEF1ZGlvRHRzID0gbnVsbDsgLy8g5Lyw566X5LiL5LiA5q616Z+z6aKR5pWw5o2u55qEZHRzXFxuICAgIHRoaXMubmV4dFZpZGVvRHRzID0gbnVsbDsgLy8g5Lyw566X5LiL5LiA5q616KeG6aKR5pWw5o2u55qEZHRzXFxuXFxuICAgIHRoaXMubGFzdEF1ZGlvU2FtcGxlc0xlbiA9IDA7IC8vIOS4iuS4gOautemfs+mikeaVsOaNrueahOmVv+W6plxcbiAgICB0aGlzLmxhc3RWaWRlb1NhbXBsZXNMZW4gPSAwOyAvLyDkuIrkuIDmrrXop4bpopHmlbDmja7nmoTplb/luqZcXG5cXG4gICAgdGhpcy5sYXN0VmlkZW9EdHMgPSB1bmRlZmluZWQ7IC8vIOS4iuS4gOautemfs+mikeaVsOaNrueahOmVv+W6plxcbiAgICB0aGlzLmxhc3RBdWRpb0R0cyA9IHVuZGVmaW5lZDsgLy8g5LiK5LiA5q616KeG6aKR5pWw5o2u55qE6ZW/5bqmXFxuXFxuICAgIC8vIHRoaXMuYWxsQXVkaW9TYW1wbGVzQ291bnQgPSAwIC8vIOmfs+mikeaAu+aVsOaNrumHjyjljp/lp4vluKcpXFxuICAgIC8vIHRoaXMuYWxsVmlkZW9TYW1wbGVzQ291bnQgPSAwIC8vIOinhumikeaAu+aVsOaNrumHjyjljp/lp4vluKcpXFxuXFxuICAgIC8vIHRoaXMuX2ZpcnN0QXVkaW9TYW1wbGUgPSBudWxsXFxuICAgIC8vIHRoaXMuX2ZpcnN0VmlkZW9TYW1wbGUgPSBudWxsXFxuXFxuICAgIHRoaXMuZmlsbGVkQXVkaW9TYW1wbGVzID0gW107IC8vIOihpeWFhemfs+mikeW4p++8iO+8iVxcbiAgICB0aGlzLmZpbGxlZFZpZGVvU2FtcGxlcyA9IFtdOyAvLyDooaXlhYXop4bpopHluKfvvIjvvIlcXG4gIH1cXG5cXG4gIGRvRml4KCkge1xcbiAgICBjb25zdCB7IGlzRmlyc3RBdWRpb1NhbXBsZXMsIGlzRmlyc3RWaWRlb1NhbXBsZXMgfSA9IHRoaXMuZ2V0Rmlyc3RTYW1wbGUoKTtcXG5cXG4gICAgLy8gdGhpcy5yZW1vdmVJbnZhbGlkU2FtcGxlcygpXFxuXFxuICAgIHRoaXMucmVjb3JkU2FtcGxlc0NvdW50KCk7XFxuXFxuICAgIGlmICh0aGlzLl9maXJzdFZpZGVvU2FtcGxlKSB7XFxuICAgICAgdGhpcy5maXhSZWZTYW1wbGVEdXJhdGlvbih0aGlzLnZpZGVvVHJhY2subWV0YSwgdGhpcy52aWRlb1RyYWNrLnNhbXBsZXMpO1xcbiAgICB9XFxuICAgIGlmICh0aGlzLl9maXJzdEF1ZGlvU2FtcGxlKSB7XFxuICAgICAgdGhpcy5maXhSZWZTYW1wbGVEdXJhdGlvbih0aGlzLmF1ZGlvVHJhY2subWV0YSwgdGhpcy5hdWRpb1RyYWNrLnNhbXBsZXMpO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHsgY2hhbmdlZDogdmlkZW9DaGFuZ2VkLCBjaGFuZ2VkSWR4OiB2aWRlb0NoYW5nZWRJZHggfSA9IENvbXBhdGliaWxpdHkuZGV0YWN0Q2hhbmdlU3RyZWFtKHRoaXMudmlkZW9UcmFjay5zYW1wbGVzKTtcXG4gICAgaWYgKHZpZGVvQ2hhbmdlZCAmJiAhaXNGaXJzdEF1ZGlvU2FtcGxlcykge1xcbiAgICAgIHRoaXMuZml4Q2hhbmdlU3RyZWFtVmlkZW8odmlkZW9DaGFuZ2VkSWR4KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLmRvRml4VmlkZW8oaXNGaXJzdFZpZGVvU2FtcGxlcyk7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgeyBjaGFuZ2VkOiBhdWRpb0NoYW5nZWQsIGNoYW5nZWRJZHg6IGF1ZGlvQ2hhbmdlZElkeCB9ID0gQ29tcGF0aWJpbGl0eS5kZXRhY3RDaGFuZ2VTdHJlYW0odGhpcy5hdWRpb1RyYWNrLnNhbXBsZXMpO1xcbiAgICBpZiAoYXVkaW9DaGFuZ2VkKSB7XFxuICAgICAgdGhpcy5maXhDaGFuZ2VTdHJlYW1BdWRpbyhhdWRpb0NoYW5nZWRJZHgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRoaXMuZG9GaXhBdWRpbyhpc0ZpcnN0QXVkaW9TYW1wbGVzKTtcXG4gICAgfVxcblxcbiAgICAvLyB0aGlzLnJlbW92ZUludmFsaWRTYW1wbGVzKClcXG4gIH1cXG5cXG4gIGRvRml4VmlkZW8oZmlyc3QsIHN0cmVhbUNoYW5nZVN0YXJ0KSB7XFxuICAgIGxldCB7IHNhbXBsZXM6IHZpZGVvU2FtcGxlcywgbWV0YSB9ID0gdGhpcy52aWRlb1RyYWNrO1xcblxcbiAgICBpZiAobWV0YS5mcmFtZVJhdGUgJiYgbWV0YS5mcmFtZVJhdGUuZml4ZWQgPT09IGZhbHNlKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmICghdmlkZW9TYW1wbGVzIHx8ICF2aWRlb1NhbXBsZXMubGVuZ3RoIHx8ICF0aGlzLl9maXJzdFZpZGVvU2FtcGxlKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIC8vIGNvbnNvbGUubG9nKGB2aWRlbyBsYXN0U2FtcGxlLCAke3ZpZGVvU2FtcGxlc1t2aWRlb1NhbXBsZXMubGVuZ3RoIC0gMV0uZHRzfWApXFxuXFxuICAgIGNvbnN0IGZpcnN0U2FtcGxlID0gdmlkZW9TYW1wbGVzWzBdO1xcblxcbiAgICBjb25zdCBzYW1wbGVzTGVuID0gdmlkZW9TYW1wbGVzLmxlbmd0aDtcXG5cXG4gICAgLy8gc3RlcDAu5L+u5aSNaGxz5rWB5Ye6546w5beo5aSnZ2Fw77yM6ZyA6KaB5by65Yi26YeN5a6a5L2N55qE6Zeu6aKYXFxuICAgIGlmICh0aGlzLl92aWRlb0xhcmdlR2FwID4gMCkge1xcbiAgICAgIENvbXBhdGliaWxpdHkuZG9GaXhMYXJnZUdhcCh2aWRlb1NhbXBsZXMsIHRoaXMuX3ZpZGVvTGFyZ2VHYXApO1xcbiAgICB9XFxuXFxuICAgIGlmIChmaXJzdFNhbXBsZS5kdHMgIT09IHRoaXMuX2ZpcnN0VmlkZW9TYW1wbGUuZHRzICYmIChzdHJlYW1DaGFuZ2VTdGFydCB8fCBDb21wYXRpYmlsaXR5LmRldGVjdExhcmdlR2FwKHRoaXMubmV4dFZpZGVvRHRzLCBmaXJzdFNhbXBsZSkpKSB7XFxuICAgICAgaWYgKHN0cmVhbUNoYW5nZVN0YXJ0KSB7XFxuICAgICAgICB0aGlzLm5leHRWaWRlb0R0cyA9IHN0cmVhbUNoYW5nZVN0YXJ0OyAvLyBGSVg6IEhsc+S4remAlOWIh2NvZGVj77yM5Zyo5aaC5p6c55u05o6lc2Vla+WIsOWQjumdoueahOeCueS8muWvvOiHtGxhcmdlR2Fw6K6h566X5aSx6LSlXFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3ZpZGVvTGFyZ2VHYXAgPSB0aGlzLm5leHRWaWRlb0R0cyAtIGZpcnN0U2FtcGxlLmR0cztcXG4gICAgICBDb21wYXRpYmlsaXR5LmRvRml4TGFyZ2VHYXAodmlkZW9TYW1wbGVzLCB0aGlzLl92aWRlb0xhcmdlR2FwKTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBmaXJzdER0cyA9IGZpcnN0U2FtcGxlLmR0cztcXG5cXG4gICAgLy8gc3RlcDEuIOS/ruWkjeS4jmF1ZGlv6aaW5bin5beu6Led5aSq5aSn55qE6Zeu6aKYXFxuICAgIGlmIChmaXJzdCAmJiB0aGlzLl9maXJzdEF1ZGlvU2FtcGxlKSB7XFxuICAgICAgY29uc3QgdmlkZW9GaXJzdER0cyA9IHRoaXMuX2ZpcnN0VmlkZW9TYW1wbGUuZHRzO1xcbiAgICAgIGNvbnN0IGF1ZGlvRmlyc3REdHMgPSB0aGlzLl9maXJzdEF1ZGlvU2FtcGxlLmR0cztcXG4gICAgICBjb25zdCBnYXAgPSB2aWRlb0ZpcnN0RHRzIC0gYXVkaW9GaXJzdER0cztcXG4gICAgICBpZiAoZ2FwID4gMiAqIG1ldGEucmVmU2FtcGxlRHVyYXRpb24pIHtcXG4gICAgICAgIGNvbnN0IGZpbGxDb3VudCA9IE1hdGguZmxvb3IoZ2FwIC8gbWV0YS5yZWZTYW1wbGVEdXJhdGlvbik7XFxuXFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGxDb3VudDsgaSsrKSB7XFxuICAgICAgICAgIGNvbnN0IGNsb25lZEZpcnN0U2FtcGxlID0gT2JqZWN0LmFzc2lnbih7fSwgZmlyc3RTYW1wbGUpOyAvLyDop4bpopHlpLTpg6jluKfnvLrlpLHpnIDopoHlpI3liLbnrKzkuIDluKdcXG4gICAgICAgICAgLy8g6YeN5paw6K6h566Xc2FtcGxl55qEZHRz5ZKMcHRzXFxuICAgICAgICAgIGNsb25lZEZpcnN0U2FtcGxlLmR0cyA9IHZpZGVvRmlyc3REdHMgLSAoaSArIDEpICogbWV0YS5yZWZTYW1wbGVEdXJhdGlvbjtcXG4gICAgICAgICAgY2xvbmVkRmlyc3RTYW1wbGUucHRzID0gY2xvbmVkRmlyc3RTYW1wbGUuZHRzICsgY2xvbmVkRmlyc3RTYW1wbGUuY3RzO1xcblxcbiAgICAgICAgICB2aWRlb1NhbXBsZXMudW5zaGlmdChjbG9uZWRGaXJzdFNhbXBsZSk7XFxuXFxuICAgICAgICAgIHRoaXMuZmlsbGVkVmlkZW9TYW1wbGVzLnB1c2goe1xcbiAgICAgICAgICAgIGR0czogY2xvbmVkRmlyc3RTYW1wbGUuZHRzLFxcbiAgICAgICAgICAgIHNpemU6IGNsb25lZEZpcnN0U2FtcGxlLmRhdGEuYnl0ZUxlbmd0aFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgbGV0IGdhcDtcXG4gICAgLy8gc3RlcDIuIOS/ruWkjXNhbXBsZXPmrrXkuYvpl7TnmoTpl7Tot53pl67popjjgIFcXG4gICAgaWYgKHRoaXMubmV4dFZpZGVvRHRzKSB7XFxuICAgICAgLy8gc3RlcDEuIOWkhOeQhnNhbXBsZXPmrrXkuYvpl7TnmoTkuKLluKfmg4XlhrVcXG4gICAgICAvLyDlvZPlj5HnjrBkdXJhdGlvbuW3rui3neWkp+S6jjLluKfml7bov5vooYzooaXluKdcXG4gICAgICBnYXAgPSBmaXJzdER0cyAtIHRoaXMubmV4dFZpZGVvRHRzO1xcbiAgICAgIGNvbnN0IGFic0dhcCA9IE1hdGguYWJzKGdhcCk7XFxuICAgICAgaWYgKGdhcCA+IDIgKiBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uKSB7XFxuICAgICAgICBjb25zdCBmaWxsRnJhbWVDb3VudCA9IE1hdGguZmxvb3IoZ2FwIC8gbWV0YS5yZWZTYW1wbGVEdXJhdGlvbik7XFxuXFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGxGcmFtZUNvdW50OyBpKyspIHtcXG4gICAgICAgICAgY29uc3QgY2xvbmVkU2FtcGxlID0gT2JqZWN0LmFzc2lnbih7fSwgdmlkZW9TYW1wbGVzWzBdKTtcXG4gICAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBmaXJzdER0cyAtIChpICsgMSkgKiBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uO1xcblxcbiAgICAgICAgICBjbG9uZWRTYW1wbGUuZHRzID0gY29tcHV0ZWQgPiB0aGlzLm5leHRWaWRlb0R0cyA/IGNvbXB1dGVkIDogdGhpcy5uZXh0VmlkZW9EdHM7IC8vIOihpeeahOesrOS4gOW4p+S4gOWumuimgeaYr25leHRWaWRlb0R0c1xcbiAgICAgICAgICBjbG9uZWRTYW1wbGUucHRzID0gY2xvbmVkU2FtcGxlLmR0cyArIGNsb25lZFNhbXBsZS5jdHM7XFxuXFxuICAgICAgICAgIHRoaXMudmlkZW9UcmFjay5zYW1wbGVzLnVuc2hpZnQoY2xvbmVkU2FtcGxlKTtcXG5cXG4gICAgICAgICAgdGhpcy5maWxsZWRWaWRlb1NhbXBsZXMucHVzaCh7XFxuICAgICAgICAgICAgZHRzOiBjbG9uZWRTYW1wbGUuZHRzLFxcbiAgICAgICAgICAgIHNpemU6IGNsb25lZFNhbXBsZS5kYXRhLmJ5dGVMZW5ndGhcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmIChhYnNHYXAgPD0gbWV0YS5yZWZTYW1wbGVEdXJhdGlvbiAmJiBhYnNHYXAgPiAwKSB7XFxuICAgICAgICAvLyDlvZPlt67ot53lnKgrLeS4gOW4p+S5i+mXtOaXtuWwhuesrOS4gOW4p+eahGR0c+W8uuihjOWumuS9jeWIsOacn+acm+S9jee9rlxcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ+mHjeWumuS9jeinhumikeW4p2R0cycsIHZpZGVvU2FtcGxlc1swXS5kdHMsIHRoaXMubmV4dFZpZGVvRHRzKVxcbiAgICAgICAgdmlkZW9TYW1wbGVzWzBdLmR0cyA9IHRoaXMubmV4dFZpZGVvRHRzO1xcbiAgICAgICAgdmlkZW9TYW1wbGVzWzBdLm9yaWdpbkR0cyA9IHZpZGVvU2FtcGxlc1swXS5kdHM7XFxuICAgICAgICB2aWRlb1NhbXBsZXNbMF0uY3RzID0gdmlkZW9TYW1wbGVzWzBdLmN0cyAhPT0gdW5kZWZpbmVkID8gdmlkZW9TYW1wbGVzWzBdLmN0cyA6IHZpZGVvU2FtcGxlc1swXS5wdHMgLSB2aWRlb1NhbXBsZXNbMF0uZHRzO1xcbiAgICAgICAgdmlkZW9TYW1wbGVzWzBdLnB0cyA9IHZpZGVvU2FtcGxlc1swXS5kdHMgKyB2aWRlb1NhbXBsZXNbMF0uY3RzO1xcbiAgICAgIH0gZWxzZSBpZiAoZ2FwIDwgMCkge1xcbiAgICAgICAgLy8g5Ye6546w5aSn55qEZ2FwXFxuICAgICAgICBDb21wYXRpYmlsaXR5LmRvRml4TGFyZ2VHYXAodmlkZW9TYW1wbGVzLCAtMSAqIGdhcCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGNvbnN0IGxhc3REdHMgPSB2aWRlb1NhbXBsZXNbdmlkZW9TYW1wbGVzLmxlbmd0aCAtIDFdLmR0cztcXG5cXG4gICAgY29uc3QgbGFzdFNhbXBsZUR1cmF0aW9uID0gdmlkZW9TYW1wbGVzLmxlbmd0aCA+PSAyID8gbGFzdER0cyAtIHZpZGVvU2FtcGxlc1t2aWRlb1NhbXBsZXMubGVuZ3RoIC0gMl0uZHRzIDogbWV0YS5yZWZTYW1wbGVEdXJhdGlvbjtcXG5cXG4gICAgdGhpcy5sYXN0VmlkZW9TYW1wbGVzTGVuID0gc2FtcGxlc0xlbjtcXG4gICAgdGhpcy5uZXh0VmlkZW9EdHMgPSBsYXN0RHRzICsgbGFzdFNhbXBsZUR1cmF0aW9uO1xcbiAgICB0aGlzLmxhc3RWaWRlb0R0cyA9IGxhc3REdHM7XFxuXFxuICAgIC8vIHN0ZXAyLiDkv67lpI1zYW1wbGXmrrXkuYvlhoXnmoTpl7Tot53pl67pophcXG4gICAgLy8gc3RlcDMuIOS/ruWkjXNhbXBsZXPmrrXlhoXpg6jnmoRkdHPlvILluLjpl67pophcXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZpZGVvU2FtcGxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSB2aWRlb1NhbXBsZXNbaV07XFxuICAgICAgY29uc3QgbmV4dCA9IHZpZGVvU2FtcGxlc1tpICsgMV07XFxuXFxuICAgICAgaWYgKCFuZXh0KSB7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgZHVyYXRpb24gPSBuZXh0LmR0cyAtIGN1cnJlbnQuZHRzO1xcblxcbiAgICAgIGlmIChkdXJhdGlvbiA+IDIgKiBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uKSB7XFxuICAgICAgICAvLyDkuKTluKfkuYvpl7Tpl7TpmpTlpKrlpKfvvIzpnIDopoHooaXnqbrnmb3luKdcXG4gICAgICAgIGxldCBmaWxsRnJhbWVDb3VudCA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uKTtcXG5cXG4gICAgICAgIGxldCBmaWxsRnJhbWVJZHggPSAwO1xcbiAgICAgICAgd2hpbGUgKGZpbGxGcmFtZUlkeCA8IGZpbGxGcmFtZUNvdW50KSB7XFxuICAgICAgICAgIGNvbnN0IGZpbGxGcmFtZSA9IE9iamVjdC5hc3NpZ24oe30sIG5leHQpO1xcbiAgICAgICAgICBmaWxsRnJhbWUuZHRzID0gY3VycmVudC5kdHMgKyAoZmlsbEZyYW1lSWR4ICsgMSkgKiBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uO1xcbiAgICAgICAgICBmaWxsRnJhbWUucHRzID0gZmlsbEZyYW1lLmR0cyArIGZpbGxGcmFtZS5jdHM7XFxuICAgICAgICAgIGlmIChmaWxsRnJhbWUgPCBuZXh0LmR0cykge1xcbiAgICAgICAgICAgIHZpZGVvU2FtcGxlcy5zcGxpY2UoaSwgMCwgZmlsbEZyYW1lKTtcXG5cXG4gICAgICAgICAgICB0aGlzLmZpbGxlZFZpZGVvU2FtcGxlcy5wdXNoKHtcXG4gICAgICAgICAgICAgIGR0czogZmlsbEZyYW1lLmR0cyxcXG4gICAgICAgICAgICAgIHNpemU6IGZpbGxGcmFtZS5kYXRhLmJ5dGVMZW5ndGhcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmaWxsRnJhbWVJZHgrKztcXG4gICAgICAgICAgaSsrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB0aGlzLnZpZGVvVHJhY2suc2FtcGxlcyA9IHZpZGVvU2FtcGxlcztcXG4gIH1cXG5cXG4gIGRvRml4QXVkaW8oZmlyc3QsIHN0cmVhbUNoYW5nZVN0YXJ0KSB7XFxuICAgIGxldCB7IHNhbXBsZXM6IGF1ZGlvU2FtcGxlcywgbWV0YSB9ID0gdGhpcy5hdWRpb1RyYWNrO1xcblxcbiAgICBpZiAoIWF1ZGlvU2FtcGxlcyB8fCAhYXVkaW9TYW1wbGVzLmxlbmd0aCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICAvLyBjb25zb2xlLmxvZyhgYXVkaW8gbGFzdFNhbXBsZSwgJHthdWRpb1NhbXBsZXNbYXVkaW9TYW1wbGVzLmxlbmd0aCAtIDFdLmR0c31gKVxcblxcbiAgICBjb25zdCBzYW1wbGVzTGVuID0gYXVkaW9TYW1wbGVzLmxlbmd0aDtcXG4gICAgY29uc3Qgc2lsZW50RnJhbWUgPSBfYWFjSGVscGVyMi5kZWZhdWx0LmdldFNpbGVudEZyYW1lKG1ldGEuY29kZWMsIG1ldGEuY2hhbm5lbENvdW50KTtcXG5cXG4gICAgY29uc3QgZmlyc3RTYW1wbGUgPSB0aGlzLl9maXJzdEF1ZGlvU2FtcGxlO1xcblxcbiAgICBjb25zdCBfZmlyc3RTYW1wbGUgPSBhdWRpb1NhbXBsZXNbMF07XFxuICAgIC8vIOWvuWF1ZGlvU2FtcGxlc+aMieeFp2R0c+WBmuaOkuW6j1xcbiAgICAvLyBhdWRpb1NhbXBsZXMgPSBDb21wYXRpYmlsaXR5LnNvcnRBdWRpb1NhbXBsZXMoYXVkaW9TYW1wbGVzKVxcbiAgICBpZiAodGhpcy5fYXVkaW9MYXJnZUdhcCA+IDApIHtcXG4gICAgICBDb21wYXRpYmlsaXR5LmRvRml4TGFyZ2VHYXAoYXVkaW9TYW1wbGVzLCB0aGlzLl9hdWRpb0xhcmdlR2FwKTtcXG4gICAgfVxcblxcbiAgICBpZiAoX2ZpcnN0U2FtcGxlLmR0cyAhPT0gdGhpcy5fZmlyc3RBdWRpb1NhbXBsZS5kdHMgJiYgKHN0cmVhbUNoYW5nZVN0YXJ0IHx8IENvbXBhdGliaWxpdHkuZGV0ZWN0TGFyZ2VHYXAodGhpcy5uZXh0QXVkaW9EdHMsIF9maXJzdFNhbXBsZSkpKSB7XFxuICAgICAgaWYgKHN0cmVhbUNoYW5nZVN0YXJ0KSB7XFxuICAgICAgICB0aGlzLm5leHRBdWRpb0R0cyA9IHN0cmVhbUNoYW5nZVN0YXJ0OyAvLyBGSVg6IEhsc+S4remAlOWIh2NvZGVj77yM5Zyo5aaC5p6c55u05o6lc2Vla+WIsOWQjumdoueahOeCueS8muWvvOiHtGxhcmdlR2Fw6K6h566X5aSx6LSlXFxuICAgICAgfVxcbiAgICAgIHRoaXMuX2F1ZGlvTGFyZ2VHYXAgPSB0aGlzLm5leHRBdWRpb0R0cyAtIF9maXJzdFNhbXBsZS5kdHM7XFxuICAgICAgQ29tcGF0aWJpbGl0eS5kb0ZpeExhcmdlR2FwKGF1ZGlvU2FtcGxlcywgdGhpcy5fYXVkaW9MYXJnZUdhcCk7XFxuICAgIH1cXG4gICAgLy8gc3RlcDAuIOmmluW4p+S4jnZpZGVv6aaW5bin6Ze06Led5aSn55qE6Zeu6aKYXFxuICAgIGlmICh0aGlzLl9maXJzdFZpZGVvU2FtcGxlICYmIGZpcnN0KSB7XFxuICAgICAgY29uc3QgdmlkZW9GaXJzdFB0cyA9IHRoaXMuX2ZpcnN0VmlkZW9TYW1wbGUucHRzID8gdGhpcy5fZmlyc3RWaWRlb1NhbXBsZS5wdHMgOiB0aGlzLl9maXJzdFZpZGVvU2FtcGxlLmR0cyArIHRoaXMuX2ZpcnN0VmlkZW9TYW1wbGUuY3RzO1xcblxcbiAgICAgIGlmIChmaXJzdFNhbXBsZS5kdHMgLSB2aWRlb0ZpcnN0UHRzID4gbWV0YS5yZWZTYW1wbGVEdXJhdGlvbikge1xcbiAgICAgICAgY29uc3Qgc2lsZW50U2FtcGxlQ291bnQgPSBNYXRoLmZsb29yKChmaXJzdFNhbXBsZS5kdHMgLSB2aWRlb0ZpcnN0UHRzKSAvIG1ldGEucmVmU2FtcGxlRHVyYXRpb24pO1xcblxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWxlbnRTYW1wbGVDb3VudDsgaSsrKSB7XFxuICAgICAgICAgIGNvbnN0IHNpbGVudFNhbXBsZSA9IHtcXG4gICAgICAgICAgICBkYXRhOiBzaWxlbnRGcmFtZSxcXG4gICAgICAgICAgICBkYXRhc2l6ZTogc2lsZW50RnJhbWUuYnl0ZUxlbmd0aCxcXG4gICAgICAgICAgICBkdHM6IGZpcnN0U2FtcGxlLmR0cyAtIChpICsgMSkgKiBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uLFxcbiAgICAgICAgICAgIGZpbHRlcmVkOiAwXFxuICAgICAgICAgIH07XFxuXFxuICAgICAgICAgIGF1ZGlvU2FtcGxlcy51bnNoaWZ0KHNpbGVudFNhbXBsZSk7XFxuXFxuICAgICAgICAgIHRoaXMuZmlsbGVkQXVkaW9TYW1wbGVzLnB1c2goe1xcbiAgICAgICAgICAgIGR0czogc2lsZW50U2FtcGxlLmR0cyxcXG4gICAgICAgICAgICBzaXplOiBzaWxlbnRTYW1wbGUuZGF0YS5ieXRlTGVuZ3RoXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBsZXQgZ2FwO1xcbiAgICBjb25zdCBmaXJzdER0cyA9IGF1ZGlvU2FtcGxlc1swXS5kdHM7XFxuXFxuICAgIGlmICh0aGlzLm5leHRBdWRpb0R0cykge1xcbiAgICAgIC8vIHN0ZXAxLiDlpITnkIZzYW1wbGVz5q615LmL6Ze055qE5Lii5bin5oOF5Ya1XFxuICAgICAgLy8g5b2T5Y+R546wZHVyYXRpb27lt67ot53lpKfkuo4x5bin5pe26L+b6KGM6KGl5binXFxuICAgICAgZ2FwID0gZmlyc3REdHMgLSB0aGlzLm5leHRBdWRpb0R0cztcXG4gICAgICBjb25zdCBhYnNHYXAgPSBNYXRoLmFicyhnYXApO1xcblxcbiAgICAgIGlmIChhYnNHYXAgPiBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uICYmIHNhbXBsZXNMZW4gPT09IDEgJiYgdGhpcy5sYXN0QXVkaW9TYW1wbGVzTGVuID09PSAxKSB7XFxuICAgICAgICBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uRml4ZWQgPSB1bmRlZmluZWQ7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChnYXAgPiAyICogbWV0YS5yZWZTYW1wbGVEdXJhdGlvbikge1xcbiAgICAgICAgaWYgKHNhbXBsZXNMZW4gPT09IDEgJiYgdGhpcy5sYXN0QXVkaW9TYW1wbGVzTGVuID09PSAxKSB7XFxuICAgICAgICAgIC8vIOWmguaenHNhbXBsZeeahGxlbmd0aOS4gOebtOaYrzHvvIzogIzkuJTkuIDnm7TkuI3nrKblkIhyZWZTYW1wbGVEdXJhdGlvbu+8jOmcgOimgeWKqOaAgeS/ruaUuXJlZlNhbXBsZUR1cmF0aW9uXFxuICAgICAgICAgIG1ldGEucmVmU2FtcGxlRHVyYXRpb25GaXhlZCA9IG1ldGEucmVmU2FtcGxlRHVyYXRpb25GaXhlZCAhPT0gdW5kZWZpbmVkID8gbWV0YS5yZWZTYW1wbGVEdXJhdGlvbkZpeGVkICsgZ2FwIDogbWV0YS5yZWZTYW1wbGVEdXJhdGlvbiArIGdhcDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGNvbnN0IHNpbGVudEZyYW1lQ291bnQgPSBNYXRoLmZsb29yKGdhcCAvIG1ldGEucmVmU2FtcGxlRHVyYXRpb24pO1xcblxcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpbGVudEZyYW1lQ291bnQ7IGkrKykge1xcbiAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkID0gZmlyc3REdHMgLSAoaSArIDEpICogbWV0YS5yZWZTYW1wbGVEdXJhdGlvbjtcXG4gICAgICAgICAgICBjb25zdCBzaWxlbnRTYW1wbGUgPSBPYmplY3QuYXNzaWduKHt9LCBhdWRpb1NhbXBsZXNbMF0sIHtcXG4gICAgICAgICAgICAgIGR0czogY29tcHV0ZWQgPiB0aGlzLm5leHRBdWRpb0R0cyA/IGNvbXB1dGVkIDogdGhpcy5uZXh0QXVkaW9EdHNcXG4gICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICB0aGlzLmZpbGxlZEF1ZGlvU2FtcGxlcy5wdXNoKHtcXG4gICAgICAgICAgICAgIGR0czogc2lsZW50U2FtcGxlLmR0cyxcXG4gICAgICAgICAgICAgIHNpemU6IHNpbGVudFNhbXBsZS5kYXRhLmJ5dGVMZW5ndGhcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB0aGlzLmF1ZGlvVHJhY2suc2FtcGxlcy51bnNoaWZ0KHNpbGVudFNhbXBsZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKGFic0dhcCA8PSBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uICYmIGFic0dhcCA+IDApIHtcXG4gICAgICAgIC8vIOW9k+W3rui3neavlOi+g+Wwj+eahOaXtuWAmeWwhumfs+mikeW4p+mHjeWumuS9jVxcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ+mHjeWumuS9jemfs+mikeW4p2R0cycsIGF1ZGlvU2FtcGxlc1swXS5kdHMsIHRoaXMubmV4dEF1ZGlvRHRzKVxcbiAgICAgICAgYXVkaW9TYW1wbGVzWzBdLmR0cyA9IHRoaXMubmV4dEF1ZGlvRHRzO1xcbiAgICAgICAgYXVkaW9TYW1wbGVzWzBdLnB0cyA9IHRoaXMubmV4dEF1ZGlvRHRzO1xcbiAgICAgIH0gZWxzZSBpZiAoZ2FwIDwgMCkge1xcbiAgICAgICAgQ29tcGF0aWJpbGl0eS5kb0ZpeExhcmdlR2FwKGF1ZGlvU2FtcGxlcywgLTEgKiBnYXApO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBjb25zdCBsYXN0RHRzID0gYXVkaW9TYW1wbGVzW2F1ZGlvU2FtcGxlcy5sZW5ndGggLSAxXS5kdHM7XFxuICAgIGNvbnN0IGxhc3RTYW1wbGVEdXJhdGlvbiA9IGF1ZGlvU2FtcGxlcy5sZW5ndGggPj0gMiA/IGxhc3REdHMgLSBhdWRpb1NhbXBsZXNbYXVkaW9TYW1wbGVzLmxlbmd0aCAtIDJdLmR0cyA6IG1ldGEucmVmU2FtcGxlRHVyYXRpb247XFxuXFxuICAgIHRoaXMubGFzdEF1ZGlvU2FtcGxlc0xlbiA9IHNhbXBsZXNMZW47XFxuICAgIHRoaXMubmV4dEF1ZGlvRHRzID0gbWV0YS5yZWZTYW1wbGVEdXJhdGlvbkZpeGVkID8gbGFzdER0cyArIG1ldGEucmVmU2FtcGxlRHVyYXRpb25GaXhlZCA6IGxhc3REdHMgKyBsYXN0U2FtcGxlRHVyYXRpb247XFxuICAgIHRoaXMubGFzdEF1ZGlvRHRzID0gbGFzdER0cztcXG5cXG4gICAgLy8gc3RlcDMuIOS/ruWkjXNhbXBsZXPmrrXlhoXpg6jnmoRkdHPlvILluLjpl67pophcXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGF1ZGlvU2FtcGxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBhdWRpb1NhbXBsZXNbaV07XFxuICAgICAgY29uc3QgbmV4dCA9IGF1ZGlvU2FtcGxlc1tpICsgMV07XFxuXFxuICAgICAgaWYgKCFuZXh0KSB7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgZHVyYXRpb24gPSBuZXh0LmR0cyAtIGN1cnJlbnQuZHRzO1xcbiAgICAgIGF1ZGlvU2FtcGxlc1tpXS5kdXJhdGlvbiA9IGR1cmF0aW9uO1xcbiAgICAgIC8qXFxuICAgICAgaWYgKGR1cmF0aW9uID4gKDIgKiBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uKSkge1xcbiAgICAgICAgLy8g5Lik5bin5LmL6Ze06Ze06ZqU5aSq5aSn77yM6ZyA6KaB6KGl56m655m95binXFxuICAgICAgICAvKipcXG4gICAgICAgIGxldCBzaWxlbnRGcmFtZUNvdW50ID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIG1ldGEucmVmU2FtcGxlRHVyYXRpb24pXFxuICAgICAgICBsZXQgZnJhbWVJZHggPSAwXFxuICAgICAgICAgd2hpbGUgKGZyYW1lSWR4IDwgc2lsZW50RnJhbWVDb3VudCkge1xcbiAgICAgICAgICBjb25zdCBzaWxlbnRTYW1wbGUgPSB7XFxuICAgICAgICAgICAgZGF0YTogc2lsZW50RnJhbWUsXFxuICAgICAgICAgICAgZGF0YXNpemU6IHNpbGVudEZyYW1lLmJ5dGVMZW5ndGgsXFxuICAgICAgICAgICAgZHRzOiBjdXJyZW50LmR0cyArIChmcmFtZUlkeCArIDEpICogbWV0YS5yZWZTYW1wbGVEdXJhdGlvbixcXG4gICAgICAgICAgICBmaWx0ZXJlZDogMCxcXG4gICAgICAgICAgICBpc1NpbGVudDogdHJ1ZVxcbiAgICAgICAgICB9XFxuICAgICAgICAgICBhdWRpb1NhbXBsZXMuc3BsaWNlKGksIDAsIHNpbGVudFNhbXBsZSlcXG4gICAgICAgICAgIHRoaXMuZmlsbGVkQXVkaW9TYW1wbGVzLnB1c2goe1xcbiAgICAgICAgICAgIGR0czogc2lsZW50U2FtcGxlLmR0cyxcXG4gICAgICAgICAgICBzaXplOiBzaWxlbnRTYW1wbGUuZGF0YS5ieXRlTGVuZ3RoXFxuICAgICAgICAgIH0pXFxuICAgICAgICAgICBmcmFtZUlkeCsrXFxuICAgICAgICAgIGkrKyAvLyDkuI3lr7npnZnpn7PluKflgZrmr5TovoNcXG4gICAgICAgIH1cXG4gICAgICB9ICovXFxuICAgIH1cXG5cXG4gICAgdGhpcy5hdWRpb1RyYWNrLnNhbXBsZXMgPSBDb21wYXRpYmlsaXR5LnNvcnRBdWRpb1NhbXBsZXMoYXVkaW9TYW1wbGVzKTtcXG4gIH1cXG5cXG4gIGZpeENoYW5nZVN0cmVhbVZpZGVvKGNoYW5nZUlkeCkge1xcbiAgICBjb25zdCB7IHNhbXBsZXMsIG1ldGEgfSA9IHRoaXMudmlkZW9UcmFjaztcXG4gICAgY29uc3QgcHJldkR0cyA9IGNoYW5nZUlkeCA9PT0gMCA/IHRoaXMuZ2V0U3RyZWFtQ2hhbmdlU3RhcnQoc2FtcGxlc1swXSkgOiBzYW1wbGVzW2NoYW5nZUlkeCAtIDFdLmR0cztcXG4gICAgY29uc3QgY3VyRHRzID0gc2FtcGxlc1tjaGFuZ2VJZHhdLmR0cztcXG4gICAgY29uc3QgaXNDb250aW51ZSA9IE1hdGguYWJzKHByZXZEdHMgLSBjdXJEdHMpIDw9IDIgKiBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uO1xcblxcbiAgICBpZiAoaXNDb250aW51ZSkge1xcbiAgICAgIGlmICghc2FtcGxlc1tjaGFuZ2VJZHhdLm9wdGlvbnMpIHtcXG4gICAgICAgIHNhbXBsZXNbY2hhbmdlSWR4XS5vcHRpb25zID0ge1xcbiAgICAgICAgICBpc0NvbnRpbnVlOiB0cnVlXFxuICAgICAgICB9O1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzYW1wbGVzW2NoYW5nZUlkeF0ub3B0aW9ucy5pc0NvbnRpbnVlID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHRoaXMuZG9GaXhWaWRlbyhmYWxzZSk7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgZmlyc3RQYXJ0U2FtcGxlcyA9IHNhbXBsZXMuc2xpY2UoMCwgY2hhbmdlSWR4KTtcXG4gICAgY29uc3Qgc2Vjb25kUGFydFNhbXBsZXMgPSBzYW1wbGVzLnNsaWNlKGNoYW5nZUlkeCk7XFxuICAgIGNvbnN0IGZpcnN0U2FtcGxlID0gc2FtcGxlc1swXTtcXG5cXG4gICAgY29uc3QgY2hhbmdlU2FtcGxlID0gc2Vjb25kUGFydFNhbXBsZXNbMF07XFxuICAgIGNvbnN0IGZpcnN0UGFydER1cmF0aW9uID0gY2hhbmdlU2FtcGxlLmR0cyAtIGZpcnN0U2FtcGxlLmR0cztcXG4gICAgY29uc3Qgc3RyZWFtQ2hhbmdlU3RhcnQgPSBmaXJzdFNhbXBsZS5vcHRpb25zICYmIGZpcnN0U2FtcGxlLm9wdGlvbnMuc3RhcnQgKyBmaXJzdFBhcnREdXJhdGlvbiA/IGZpcnN0U2FtcGxlLm9wdGlvbnMuc3RhcnQgOiBudWxsO1xcblxcbiAgICB0aGlzLnZpZGVvVHJhY2suc2FtcGxlcyA9IHNhbXBsZXMuc2xpY2UoMCwgY2hhbmdlSWR4KTtcXG5cXG4gICAgdGhpcy5kb0ZpeFZpZGVvKGZhbHNlKTtcXG5cXG4gICAgdGhpcy52aWRlb1RyYWNrLnNhbXBsZXMgPSBzYW1wbGVzLnNsaWNlKGNoYW5nZUlkeCk7XFxuXFxuICAgIHRoaXMuZG9GaXhWaWRlbyhmYWxzZSwgc3RyZWFtQ2hhbmdlU3RhcnQpO1xcblxcbiAgICB0aGlzLnZpZGVvVHJhY2suc2FtcGxlcyA9IGZpcnN0UGFydFNhbXBsZXMuY29uY2F0KHNlY29uZFBhcnRTYW1wbGVzKTtcXG4gIH1cXG5cXG4gIGZpeENoYW5nZVN0cmVhbUF1ZGlvKGNoYW5nZUlkeCkge1xcbiAgICBjb25zdCB7IHNhbXBsZXMsIG1ldGEgfSA9IHRoaXMuYXVkaW9UcmFjaztcXG5cXG4gICAgY29uc3QgcHJldkR0cyA9IGNoYW5nZUlkeCA9PT0gMCA/IHRoaXMuZ2V0U3RyZWFtQ2hhbmdlU3RhcnQoc2FtcGxlc1swXSkgOiBzYW1wbGVzW2NoYW5nZUlkeCAtIDFdLmR0cztcXG4gICAgY29uc3QgY3VyRHRzID0gc2FtcGxlc1tjaGFuZ2VJZHhdLmR0cztcXG4gICAgY29uc3QgaXNDb250aW51ZSA9IE1hdGguYWJzKHByZXZEdHMgLSBjdXJEdHMpIDw9IDIgKiBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uO1xcblxcbiAgICBpZiAoaXNDb250aW51ZSkge1xcbiAgICAgIGlmICghc2FtcGxlc1tjaGFuZ2VJZHhdLm9wdGlvbnMpIHtcXG4gICAgICAgIHNhbXBsZXNbY2hhbmdlSWR4XS5vcHRpb25zID0ge1xcbiAgICAgICAgICBpc0NvbnRpbnVlOiB0cnVlXFxuICAgICAgICB9O1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzYW1wbGVzW2NoYW5nZUlkeF0ub3B0aW9ucy5pc0NvbnRpbnVlID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHRoaXMuZG9GaXhBdWRpbyhmYWxzZSk7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgZmlyc3RQYXJ0U2FtcGxlcyA9IHNhbXBsZXMuc2xpY2UoMCwgY2hhbmdlSWR4KTtcXG4gICAgY29uc3Qgc2Vjb25kUGFydFNhbXBsZXMgPSBzYW1wbGVzLnNsaWNlKGNoYW5nZUlkeCk7XFxuICAgIGNvbnN0IGZpcnN0U2FtcGxlID0gc2FtcGxlc1swXTtcXG5cXG4gICAgY29uc3QgY2hhbmdlU2FtcGxlID0gc2Vjb25kUGFydFNhbXBsZXNbMF07XFxuICAgIGNvbnN0IGZpcnN0UGFydER1cmF0aW9uID0gY2hhbmdlU2FtcGxlLmR0cyAtIGZpcnN0U2FtcGxlLmR0cztcXG4gICAgY29uc3Qgc3RyZWFtQ2hhbmdlU3RhcnQgPSBmaXJzdFNhbXBsZS5vcHRpb25zICYmIGZpcnN0U2FtcGxlLm9wdGlvbnMuc3RhcnQgKyBmaXJzdFBhcnREdXJhdGlvbiA/IGZpcnN0U2FtcGxlLm9wdGlvbnMuc3RhcnQgOiBudWxsO1xcblxcbiAgICB0aGlzLmF1ZGlvVHJhY2suc2FtcGxlcyA9IGZpcnN0UGFydFNhbXBsZXM7XFxuXFxuICAgIHRoaXMuZG9GaXhBdWRpbyhmYWxzZSk7XFxuXFxuICAgIHRoaXMuYXVkaW9UcmFjay5zYW1wbGVzID0gc2Vjb25kUGFydFNhbXBsZXM7XFxuXFxuICAgIHRoaXMuZG9GaXhBdWRpbyhmYWxzZSwgc3RyZWFtQ2hhbmdlU3RhcnQpO1xcblxcbiAgICB0aGlzLmF1ZGlvVHJhY2suc2FtcGxlcyA9IGZpcnN0UGFydFNhbXBsZXMuY29uY2F0KHNlY29uZFBhcnRTYW1wbGVzKTtcXG4gIH1cXG5cXG4gIGdldEZpcnN0U2FtcGxlKCkge1xcbiAgICAvLyDojrflj5Z2aWRlb+WSjGF1ZGlv55qE6aaW5bin5pWw5o2uXFxuICAgIGxldCB7IHNhbXBsZXM6IHZpZGVvU2FtcGxlcyB9ID0gdGhpcy52aWRlb1RyYWNrO1xcbiAgICBsZXQgeyBzYW1wbGVzOiBhdWRpb1NhbXBsZXMgfSA9IHRoaXMuYXVkaW9UcmFjaztcXG5cXG4gICAgbGV0IGlzRmlyc3RWaWRlb1NhbXBsZXMgPSBmYWxzZTtcXG4gICAgbGV0IGlzRmlyc3RBdWRpb1NhbXBsZXMgPSBmYWxzZTtcXG5cXG4gICAgaWYgKCF0aGlzLl9maXJzdFZpZGVvU2FtcGxlICYmIHZpZGVvU2FtcGxlcy5sZW5ndGgpIHtcXG4gICAgICB0aGlzLl9maXJzdFZpZGVvU2FtcGxlID0gQ29tcGF0aWJpbGl0eS5maW5kRmlyc3RWaWRlb1NhbXBsZSh2aWRlb1NhbXBsZXMpO1xcbiAgICAgIGlzRmlyc3RWaWRlb1NhbXBsZXMgPSB0cnVlO1xcbiAgICB9XFxuXFxuICAgIGlmICghdGhpcy5fZmlyc3RBdWRpb1NhbXBsZSAmJiBhdWRpb1NhbXBsZXMubGVuZ3RoKSB7XFxuICAgICAgdGhpcy5fZmlyc3RBdWRpb1NhbXBsZSA9IENvbXBhdGliaWxpdHkuZmluZEZpcnN0QXVkaW9TYW1wbGUoYXVkaW9TYW1wbGVzKTsgLy8g5a+75om+ZHRz5pyA5bCP55qE5bin5L2c5Li66aaW5Liq6Z+z6aKR5binXFxuICAgICAgaXNGaXJzdEF1ZGlvU2FtcGxlcyA9IHRydWU7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHtcXG4gICAgICBpc0ZpcnN0VmlkZW9TYW1wbGVzLFxcbiAgICAgIGlzRmlyc3RBdWRpb1NhbXBsZXNcXG4gICAgfTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICog5Zyo5rKh5pyJcmVmU2FtcGxlRHVyYXRpb27nmoTpl67popjmtYHkuK3vvIxcXG4gICAqL1xcbiAgZml4UmVmU2FtcGxlRHVyYXRpb24obWV0YSwgc2FtcGxlcykge1xcbiAgICBjb25zdCBpc1ZpZGVvID0gbWV0YS50eXBlID09PSAndmlkZW8nO1xcbiAgICBjb25zdCBhbGxTYW1wbGVzQ291bnQgPSBpc1ZpZGVvID8gdGhpcy5hbGxWaWRlb1NhbXBsZXNDb3VudCA6IHRoaXMuYWxsQXVkaW9TYW1wbGVzQ291bnQ7XFxuICAgIGNvbnN0IGZpcnN0RHRzID0gaXNWaWRlbyA/IHRoaXMuX2ZpcnN0VmlkZW9TYW1wbGUuZHRzIDogdGhpcy5fZmlyc3RBdWRpb1NhbXBsZS5kdHM7XFxuICAgIGNvbnN0IGZpbGxlZFNhbXBsZXNDb3VudCA9IGlzVmlkZW8gPyB0aGlzLmZpbGxlZFZpZGVvU2FtcGxlcy5sZW5ndGggOiB0aGlzLmZpbGxlZEF1ZGlvU2FtcGxlcy5sZW5ndGg7XFxuXFxuICAgIGlmICghbWV0YS5yZWZTYW1wbGVEdXJhdGlvbiB8fCBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uIDw9IDAgfHwgTnVtYmVyLmlzTmFOKG1ldGEucmVmU2FtcGxlRHVyYXRpb24pKSB7XFxuICAgICAgaWYgKHNhbXBsZXMubGVuZ3RoID49IDEpIHtcXG4gICAgICAgIGNvbnN0IGxhc3REdHMgPSBzYW1wbGVzW3NhbXBsZXMubGVuZ3RoIC0gMV0uZHRzO1xcblxcbiAgICAgICAgbWV0YS5yZWZTYW1wbGVEdXJhdGlvbiA9IE1hdGguZmxvb3IoKGxhc3REdHMgLSBmaXJzdER0cykgLyAoYWxsU2FtcGxlc0NvdW50ICsgZmlsbGVkU2FtcGxlc0NvdW50IC0gMSkpOyAvLyDlsIZyZWZTYW1wbGVEdXJhdGlvbumHjee9ruS4uuiuoeeul+WQjueahOW5s+Wdh+WAvFxcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChtZXRhLnJlZlNhbXBsZUR1cmF0aW9uKSB7XFxuICAgICAgaWYgKHNhbXBsZXMubGVuZ3RoID49IDUpIHtcXG4gICAgICAgIGNvbnN0IGxhc3REdHMgPSBzYW1wbGVzW3NhbXBsZXMubGVuZ3RoIC0gMV0uZHRzO1xcbiAgICAgICAgY29uc3QgZmlyc3REdHMgPSBzYW1wbGVzWzBdLmR0cztcXG4gICAgICAgIGNvbnN0IGR1cmF0aW9uQXZnID0gKGxhc3REdHMgLSBmaXJzdER0cykgLyAoc2FtcGxlcy5sZW5ndGggLSAxKTtcXG5cXG4gICAgICAgIG1ldGEucmVmU2FtcGxlRHVyYXRpb24gPSBNYXRoLmZsb29yKE1hdGguYWJzKG1ldGEucmVmU2FtcGxlRHVyYXRpb24gLSBkdXJhdGlvbkF2ZykgPD0gNSA/IG1ldGEucmVmU2FtcGxlRHVyYXRpb24gOiBkdXJhdGlvbkF2Zyk7IC8vIOWwhnJlZlNhbXBsZUR1cmF0aW9u6YeN572u5Li66K6h566X5ZCO55qE5bmz5Z2H5YC8XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICAvKipcXG4gICAqIOiusOW9leaIquatouebruWJjeS4gOWFseaSreaUvuS6huWkmuWwkeW4p1xcbiAgICovXFxuICByZWNvcmRTYW1wbGVzQ291bnQoKSB7XFxuICAgIGNvbnN0IHsgYXVkaW9UcmFjaywgdmlkZW9UcmFjayB9ID0gdGhpcztcXG5cXG4gICAgdGhpcy5hbGxBdWRpb1NhbXBsZXNDb3VudCArPSBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoO1xcbiAgICB0aGlzLmFsbFZpZGVvU2FtcGxlc0NvdW50ICs9IHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGg7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIOWOu+mZpOS4jeWQiOazleeahOW4p++8iOWAkumAgOOAgemHjeWkjeW4p++8iVxcbiAgICovXFxuICByZW1vdmVJbnZhbGlkU2FtcGxlcygpIHtcXG4gICAgY29uc3QgeyBfZmlyc3RWaWRlb1NhbXBsZSwgX2ZpcnN0QXVkaW9TYW1wbGUgfSA9IHRoaXM7XFxuXFxuICAgIHRoaXMuYXVkaW9UcmFjay5zYW1wbGVzID0gdGhpcy5hdWRpb1RyYWNrLnNhbXBsZXMuZmlsdGVyKHNhbXBsZSA9PiB7XFxuICAgICAgcmV0dXJuIHNhbXBsZS5kdHMgPj0gX2ZpcnN0QXVkaW9TYW1wbGUuZHRzICYmICh0aGlzLmxhc3RBdWRpb0R0cyA9PT0gdW5kZWZpbmVkIHx8IHNhbXBsZS5kdHMgPiB0aGlzLmxhc3RBdWRpb0R0cyk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLnZpZGVvVHJhY2suc2FtcGxlcyA9IHRoaXMudmlkZW9UcmFjay5zYW1wbGVzLmZpbHRlcihzYW1wbGUgPT4ge1xcbiAgICAgIHJldHVybiBzYW1wbGUuZHRzID49IF9maXJzdFZpZGVvU2FtcGxlLmR0cyAmJiAodGhpcy5sYXN0VmlkZW9EdHMgPT09IHVuZGVmaW5lZCB8fCBzYW1wbGUuZHRzID4gdGhpcy5sYXN0VmlkZW9EdHMpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGdldFN0cmVhbUNoYW5nZVN0YXJ0KHNhbXBsZSkge1xcbiAgICBpZiAoc2FtcGxlLm9wdGlvbnMgJiYgc2FtcGxlLm9wdGlvbnMuc3RhcnQpIHtcXG4gICAgICByZXR1cm4gc2FtcGxlLm9wdGlvbnMuc3RhcnQgLSB0aGlzLmR0c0Jhc2U7XFxuICAgIH1cXG4gICAgcmV0dXJuIEluZmluaXR5O1xcbiAgfVxcblxcbiAgc3RhdGljIHNvcnRBdWRpb1NhbXBsZXMoc2FtcGxlcykge1xcbiAgICBpZiAoc2FtcGxlcy5sZW5ndGggPT09IDEpIHtcXG4gICAgICByZXR1cm4gc2FtcGxlcztcXG4gICAgfVxcblxcbiAgICByZXR1cm4gc2FtcGxlcy5zb3J0KChhLCBiKSA9PiB7XFxuICAgICAgcmV0dXJuIGEuZHRzIC0gYi5kdHM7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiDlr7vmib5kdHPmnIDlsI/nmoRzYW1wbGVcXG4gICAqIEBwYXJhbSBzYW1wbGVzXFxuICAgKi9cXG4gIHN0YXRpYyBmaW5kRmlyc3RBdWRpb1NhbXBsZShzYW1wbGVzKSB7XFxuICAgIGlmICghc2FtcGxlcyB8fCBzYW1wbGVzLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBDb21wYXRpYmlsaXR5LnNvcnRBdWRpb1NhbXBsZXMoc2FtcGxlcylbMF07XFxuICB9XFxuXFxuICBzdGF0aWMgZmluZEZpcnN0VmlkZW9TYW1wbGUoc2FtcGxlcykge1xcbiAgICBpZiAoIXNhbXBsZXMubGVuZ3RoKSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG5cXG4gICAgY29uc3Qgc29ydGVkID0gc2FtcGxlcy5zb3J0KChhLCBiKSA9PiB7XFxuICAgICAgcmV0dXJuIGEuZHRzIC0gYi5kdHM7XFxuICAgIH0pO1xcblxcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc29ydGVkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgaWYgKHNvcnRlZFtpXS5pc0tleWZyYW1lKSB7XFxuICAgICAgICByZXR1cm4gc29ydGVkW2ldO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgc3RhdGljIGRldGVjdExhcmdlR2FwKG5leHREdHMsIGZpcnN0U2FtcGxlKSB7XFxuICAgIGlmIChuZXh0RHRzID09PSBudWxsKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGNvbnN0IGN1ckR0cyA9IGZpcnN0U2FtcGxlLmR0cyB8fCAwO1xcbiAgICBjb25zdCBjb25kMSA9IG5leHREdHMgLSBjdXJEdHMgPj0gMTAwMCB8fCBjdXJEdHMgLSBuZXh0RHRzID49IDEwMDA7IC8vIGZpeCBobHPmtYHlh7rnjrDlpKfph4/mtYFkdHPpl7Tot53pl67pophcXG4gICAgY29uc3QgY29uZDIgPSBmaXJzdFNhbXBsZS5vcHRpb25zICYmIGZpcnN0U2FtcGxlLm9wdGlvbnMuZGlzY29udGludWU7XFxuXFxuICAgIHJldHVybiBjb25kMSB8fCBjb25kMjtcXG4gIH1cXG5cXG4gIHN0YXRpYyBkb0ZpeExhcmdlR2FwKHNhbXBsZXMsIGdhcCkge1xcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc2FtcGxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgIGNvbnN0IHNhbXBsZSA9IHNhbXBsZXNbaV07XFxuICAgICAgc2FtcGxlLmR0cyArPSBnYXA7XFxuICAgICAgaWYgKHNhbXBsZS5wdHMpIHtcXG4gICAgICAgIHNhbXBsZS5wdHMgKz0gZ2FwO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiDkuK3pgJTmjaLmtYFcXG4gICAqL1xcbiAgc3RhdGljIGRldGFjdENoYW5nZVN0cmVhbShzYW1wbGVzKSB7XFxuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XFxuICAgIGxldCBjaGFuZ2VkSWR4ID0gLTE7XFxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzYW1wbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgaWYgKHNhbXBsZXNbaV0ub3B0aW9ucyAmJiBzYW1wbGVzW2ldLm9wdGlvbnMubWV0YSkge1xcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XFxuICAgICAgICBjaGFuZ2VkSWR4ID0gaTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4ge1xcbiAgICAgIGNoYW5nZWQsXFxuICAgICAgY2hhbmdlZElkeFxcbiAgICB9O1xcbiAgfVxcblxcbiAgZ2V0IHRyYWNrcygpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoJ1RSQUNLUycpO1xcbiAgfVxcblxcbiAgZ2V0IGF1ZGlvVHJhY2soKSB7XFxuICAgIGlmICh0aGlzLnRyYWNrcykge1xcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrcy5hdWRpb1RyYWNrO1xcbiAgICB9XFxuICAgIHJldHVybiBudWxsO1xcbiAgfVxcblxcbiAgZ2V0IHZpZGVvVHJhY2soKSB7XFxuICAgIGlmICh0aGlzLnRyYWNrcykge1xcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrcy52aWRlb1RyYWNrO1xcbiAgICB9XFxuICAgIHJldHVybiBudWxsO1xcbiAgfVxcblxcbiAgZ2V0IGR0c0Jhc2UoKSB7XFxuICAgIGNvbnN0IHJlbXV4ZXIgPSB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKCdNUDRfUkVNVVhFUicpO1xcbiAgICBpZiAocmVtdXhlcikge1xcbiAgICAgIHJldHVybiByZW11eGVyLl9kdHNCYXNlO1xcbiAgICB9XFxuICAgIHJldHVybiAwO1xcbiAgfVxcbn1cXG5leHBvcnRzLmRlZmF1bHQgPSBDb21wYXRpYmlsaXR5O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci1jb2RlYy9zcmMvY29tcGF0aWJpbGl0eS5qcz9cIil9LFwiLi4veGdwbGF5ZXItY29kZWMvc3JjL2gyNjQvbmFsdW5pdC9nb2xvbWIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItY29kZWMvc3JjL2gyNjQvbmFsdW5pdC9nb2xvbWIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5jbGFzcyBHb2xvbWIge1xcbiAgY29uc3RydWN0b3IodWludDhhcnJheSkge1xcbiAgICB0aGlzLlRBRyA9ICdHb2xvbWInO1xcbiAgICB0aGlzLl9idWZmZXIgPSB1aW50OGFycmF5O1xcbiAgICB0aGlzLl9idWZmZXJJbmRleCA9IDA7XFxuICAgIHRoaXMuX3RvdGFsQnl0ZXMgPSB1aW50OGFycmF5LmJ5dGVMZW5ndGg7XFxuICAgIHRoaXMuX3RvdGFsQml0cyA9IHVpbnQ4YXJyYXkuYnl0ZUxlbmd0aCAqIDg7XFxuICAgIHRoaXMuX2N1cnJlbnRXb3JkID0gMDtcXG4gICAgdGhpcy5fY3VycmVudFdvcmRCaXRzTGVmdCA9IDA7XFxuICB9XFxuXFxuICBkZXN0cm95KCkge1xcbiAgICB0aGlzLl9idWZmZXIgPSBudWxsO1xcbiAgfVxcblxcbiAgX2ZpbGxDdXJyZW50V29yZCgpIHtcXG4gICAgbGV0IGJ1ZmZlckJ5dGVzTGVmdCA9IHRoaXMuX3RvdGFsQnl0ZXMgLSB0aGlzLl9idWZmZXJJbmRleDtcXG4gICAgaWYgKGJ1ZmZlckJ5dGVzTGVmdCA8PSAwKSB7XFxuICAgICAgLy8gVE9ETyDlvILluLjlpITnkIZcXG4gICAgfVxcblxcbiAgICBsZXQgYnl0ZXNSZWFkID0gTWF0aC5taW4oNCwgYnVmZmVyQnl0ZXNMZWZ0KTtcXG4gICAgbGV0IHdvcmQgPSBuZXcgVWludDhBcnJheSg0KTtcXG4gICAgd29yZC5zZXQodGhpcy5fYnVmZmVyLnN1YmFycmF5KHRoaXMuX2J1ZmZlckluZGV4LCB0aGlzLl9idWZmZXJJbmRleCArIGJ5dGVzUmVhZCkpO1xcbiAgICB0aGlzLl9jdXJyZW50V29yZCA9IG5ldyBEYXRhVmlldyh3b3JkLmJ1ZmZlcikuZ2V0VWludDMyKDApO1xcblxcbiAgICB0aGlzLl9idWZmZXJJbmRleCArPSBieXRlc1JlYWQ7XFxuICAgIHRoaXMuX2N1cnJlbnRXb3JkQml0c0xlZnQgPSBieXRlc1JlYWQgKiA4O1xcbiAgfVxcblxcbiAgcmVhZEJpdHMoc2l6ZSkge1xcbiAgICBsZXQgYml0cyA9IE1hdGgubWluKHRoaXMuX2N1cnJlbnRXb3JkQml0c0xlZnQsIHNpemUpOyAvLyA6dWludFxcbiAgICBsZXQgdmFsdSA9IHRoaXMuX2N1cnJlbnRXb3JkID4+PiAzMiAtIGJpdHM7XFxuICAgIGlmIChzaXplID4gMzIpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIG1vcmUgdGhhbiAzMiBiaXRzIGF0IGEgdGltZScpO1xcbiAgICB9XFxuICAgIHRoaXMuX2N1cnJlbnRXb3JkQml0c0xlZnQgLT0gYml0cztcXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRXb3JkQml0c0xlZnQgPiAwKSB7XFxuICAgICAgdGhpcy5fY3VycmVudFdvcmQgPDw9IGJpdHM7XFxuICAgIH0gZWxzZSBpZiAodGhpcy5fdG90YWxCeXRlcyAtIHRoaXMuX2J1ZmZlckluZGV4ID4gMCkge1xcbiAgICAgIHRoaXMuX2ZpbGxDdXJyZW50V29yZCgpO1xcbiAgICB9XFxuXFxuICAgIGJpdHMgPSBzaXplIC0gYml0cztcXG4gICAgaWYgKGJpdHMgPiAwICYmIHRoaXMuX2N1cnJlbnRXb3JkQml0c0xlZnQpIHtcXG4gICAgICByZXR1cm4gdmFsdSA8PCBiaXRzIHwgdGhpcy5yZWFkQml0cyhiaXRzKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gdmFsdTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmVhZEJvb2woKSB7XFxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDEpID09PSAxO1xcbiAgfVxcblxcbiAgcmVhZEJ5dGUoKSB7XFxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDgpO1xcbiAgfVxcblxcbiAgX3NraXBMZWFkaW5nWmVybygpIHtcXG4gICAgbGV0IHplcm9Db3VudDtcXG4gICAgZm9yICh6ZXJvQ291bnQgPSAwOyB6ZXJvQ291bnQgPCB0aGlzLl9jdXJyZW50V29yZEJpdHNMZWZ0OyB6ZXJvQ291bnQrKykge1xcbiAgICAgIGlmICgodGhpcy5fY3VycmVudFdvcmQgJiAweDgwMDAwMDAwID4+PiB6ZXJvQ291bnQpICE9PSAwKSB7XFxuICAgICAgICB0aGlzLl9jdXJyZW50V29yZCA8PD0gemVyb0NvdW50O1xcbiAgICAgICAgdGhpcy5fY3VycmVudFdvcmRCaXRzTGVmdCAtPSB6ZXJvQ291bnQ7XFxuICAgICAgICByZXR1cm4gemVyb0NvdW50O1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICB0aGlzLl9maWxsQ3VycmVudFdvcmQoKTtcXG4gICAgcmV0dXJuIHplcm9Db3VudCArIHRoaXMuX3NraXBMZWFkaW5nWmVybygpO1xcbiAgfVxcblxcbiAgcmVhZFVFRygpIHtcXG4gICAgLy8gdW5zaWduZWQgZXhwb25lbnRpYWwgZ29sb21iXFxuICAgIGxldCBsZWFkaW5nWmVyb3MgPSB0aGlzLl9za2lwTGVhZGluZ1plcm8oKTtcXG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMobGVhZGluZ1plcm9zICsgMSkgLSAxO1xcbiAgfVxcblxcbiAgcmVhZFNFRygpIHtcXG4gICAgLy8gc2lnbmVkIGV4cG9uZW50aWFsIGdvbG9tYlxcbiAgICBsZXQgdmFsdWUgPSB0aGlzLnJlYWRVRUcoKTtcXG4gICAgaWYgKHZhbHVlICYgMHgwMSkge1xcbiAgICAgIHJldHVybiB2YWx1ZSArIDEgPj4+IDE7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIC0xICogKHZhbHVlID4+PiAxKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBHb2xvbWI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLWNvZGVjL3NyYy9oMjY0L25hbHVuaXQvZ29sb21iLmpzP1wiKX0sXCIuLi94Z3BsYXllci1jb2RlYy9zcmMvaDI2NC9uYWx1bml0L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItY29kZWMvc3JjL2gyNjQvbmFsdW5pdC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbCgnXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBfc3BzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcHMgKi8gXCIuLi94Z3BsYXllci1jb2RlYy9zcmMvaDI2NC9uYWx1bml0L3Nwcy5qc1wiKTtcXG5cXG52YXIgX3NwczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zcHMpO1xcblxcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFxuY2xhc3MgTmFsdW5pdCB7XFxuICBzdGF0aWMgZ2V0TmFsdW5pdHMoYnVmZmVyKSB7XFxuICAgIGlmIChidWZmZXIubGVuZ3RoIC0gYnVmZmVyLnBvc2l0aW9uIDwgNCkge1xcbiAgICAgIHJldHVybiBbXTtcXG4gICAgfVxcblxcbiAgICBsZXQgYnVmID0gYnVmZmVyLmRhdGF2aWV3O1xcbiAgICBsZXQgcG9zaXRpb24gPSBidWZmZXIucG9zaXRpb247XFxuICAgIGlmIChidWYuZ2V0SW50MzIocG9zaXRpb24pID09PSAxIHx8IGJ1Zi5nZXRJbnQxNihwb3NpdGlvbikgPT09IDAgJiYgYnVmLmdldEludDgocG9zaXRpb24gKyAyKSA9PT0gMSkge1xcbiAgICAgIHJldHVybiBOYWx1bml0LmdldEFubmV4Yk5hbHMoYnVmZmVyKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gTmFsdW5pdC5nZXRBdmNjTmFscyhidWZmZXIpO1xcbiAgICB9XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0QW5uZXhiTmFscyhidWZmZXIpIHtcXG4gICAgbGV0IG5hbHMgPSBbXTtcXG4gICAgbGV0IHBvc2l0aW9uID0gTmFsdW5pdC5nZXRIZWFkZXJQb3NpdGlvbkFubmV4QihidWZmZXIpO1xcbiAgICBsZXQgc3RhcnQgPSBwb3NpdGlvbi5wb3M7XFxuICAgIGxldCBlbmQgPSBzdGFydDtcXG4gICAgd2hpbGUgKHN0YXJ0IDwgYnVmZmVyLmxlbmd0aCAtIDQpIHtcXG4gICAgICBsZXQgaGVhZGVyID0gYnVmZmVyLmJ1ZmZlci5zbGljZShzdGFydCwgc3RhcnQgKyBwb3NpdGlvbi5oZWFkZXJMZW5ndGgpO1xcbiAgICAgIGlmIChwb3NpdGlvbi5wb3MgPT09IGJ1ZmZlci5wb3NpdGlvbikge1xcbiAgICAgICAgYnVmZmVyLnNraXAocG9zaXRpb24uaGVhZGVyTGVuZ3RoKTtcXG4gICAgICB9XFxuICAgICAgcG9zaXRpb24gPSBOYWx1bml0LmdldEhlYWRlclBvc2l0aW9uQW5uZXhCKGJ1ZmZlcik7XFxuICAgICAgZW5kID0gcG9zaXRpb24ucG9zO1xcbiAgICAgIGxldCBib2R5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmJ1ZmZlci5zbGljZShzdGFydCArIGhlYWRlci5ieXRlTGVuZ3RoLCBlbmQpKTtcXG4gICAgICBsZXQgdW5pdCA9IHsgaGVhZGVyLCBib2R5IH07XFxuICAgICAgTmFsdW5pdC5hbmFseXNlTmFsKHVuaXQpO1xcbiAgICAgIG5hbHMucHVzaCh1bml0KTtcXG4gICAgICBidWZmZXIuc2tpcChlbmQgLSBidWZmZXIucG9zaXRpb24pO1xcbiAgICAgIHN0YXJ0ID0gZW5kO1xcbiAgICB9XFxuICAgIHJldHVybiBuYWxzO1xcbiAgfVxcblxcbiAgc3RhdGljIGdldEF2Y2NOYWxzKGJ1ZmZlcikge1xcbiAgICBsZXQgbmFscyA9IFtdO1xcbiAgICB3aGlsZSAoYnVmZmVyLnBvc2l0aW9uIDwgYnVmZmVyLmxlbmd0aCAtIDQpIHtcXG4gICAgICBsZXQgbGVuZ3RoID0gYnVmZmVyLmRhdGF2aWV3LmdldEludDMyKGJ1ZmZlci5wb3NpdGlvbik7XFxuICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggLSBidWZmZXIucG9zaXRpb24gPj0gbGVuZ3RoKSB7XFxuICAgICAgICBsZXQgaGVhZGVyID0gYnVmZmVyLmJ1ZmZlci5zbGljZShidWZmZXIucG9zaXRpb24sIGJ1ZmZlci5wb3NpdGlvbiArIDQpO1xcbiAgICAgICAgYnVmZmVyLnNraXAoNCk7XFxuICAgICAgICBsZXQgYm9keSA9IGJ1ZmZlci5idWZmZXIuc2xpY2UoYnVmZmVyLnBvc2l0aW9uLCBidWZmZXIucG9zaXRpb24gKyBsZW5ndGgpO1xcbiAgICAgICAgYnVmZmVyLnNraXAobGVuZ3RoKTtcXG4gICAgICAgIGxldCB1bml0ID0geyBoZWFkZXIsIGJvZHkgfTtcXG4gICAgICAgIE5hbHVuaXQuYW5hbHlzZU5hbCh1bml0KTtcXG4gICAgICAgIG5hbHMucHVzaCh1bml0KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBuYWxzO1xcbiAgfVxcblxcbiAgc3RhdGljIGFuYWx5c2VOYWwodW5pdCkge1xcbiAgICBsZXQgdHlwZSA9IHVuaXQuYm9keVswXSAmIDB4MWY7XFxuICAgIHN3aXRjaCAodHlwZSkge1xcbiAgICAgIGNhc2UgMTpcXG4gICAgICAgIC8vIE5EUlxcbiAgICAgICAgdW5pdC5uZHIgPSB0cnVlO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSA1OlxcbiAgICAgICAgLy8gSURSXFxuICAgICAgICB1bml0LmlkciA9IHRydWU7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIDY6XFxuICAgICAgICAvLyBTRUlcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgNzpcXG4gICAgICAgIC8vIFNQU1xcbiAgICAgICAgdW5pdC5zcHMgPSBfc3BzMi5kZWZhdWx0LnBhcnNlU1BTKHVuaXQuYm9keSk7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIDg6XFxuICAgICAgICAvLyBQUFNcXG4gICAgICAgIHVuaXQucHBzID0gdHJ1ZTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgOTpcXG4gICAgICAgIC8vIEFVRFxcbiAgICAgICAgYnJlYWs7XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIGJyZWFrO1xcbiAgICB9XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0SGVhZGVyUG9zaXRpb25Bbm5leEIoYnVmZmVyKSB7XFxuICAgIC8vIHNlcGVyYXRlXFxuICAgIGxldCBwb3MgPSBidWZmZXIucG9zaXRpb247XFxuICAgIGxldCBoZWFkZXJMZW5ndGggPSAwO1xcbiAgICB3aGlsZSAoaGVhZGVyTGVuZ3RoICE9PSAzICYmIGhlYWRlckxlbmd0aCAhPT0gNCAmJiBwb3MgPCBidWZmZXIubGVuZ3RoIC0gNCkge1xcbiAgICAgIGlmIChidWZmZXIuZGF0YXZpZXcuZ2V0SW50MTYocG9zKSA9PT0gMCkge1xcbiAgICAgICAgaWYgKGJ1ZmZlci5kYXRhdmlldy5nZXRJbnQxNihwb3MgKyAyKSA9PT0gMSkge1xcbiAgICAgICAgICAvLyAweDAwMDAwMVxcbiAgICAgICAgICBoZWFkZXJMZW5ndGggPSA0O1xcbiAgICAgICAgfSBlbHNlIGlmIChidWZmZXIuZGF0YXZpZXcuZ2V0SW50OChwb3MgKyAyKSA9PT0gMSkge1xcbiAgICAgICAgICBoZWFkZXJMZW5ndGggPSAzO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcG9zKys7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHBvcysrO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAocG9zID09PSBidWZmZXIubGVuZ3RoIC0gNCkge1xcbiAgICAgIGlmIChidWZmZXIuZGF0YXZpZXcuZ2V0SW50MTYocG9zKSA9PT0gMCkge1xcbiAgICAgICAgaWYgKGJ1ZmZlci5kYXRhdmlldy5nZXRJbnQxNihwb3MgKyAyKSA9PT0gMSkge1xcbiAgICAgICAgICAvLyAweDAwMDAwMVxcbiAgICAgICAgICBoZWFkZXJMZW5ndGggPSA0O1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBwb3MrKztcXG4gICAgICAgIGlmIChidWZmZXIuZGF0YXZpZXcuZ2V0SW50MTYocG9zKSA9PT0gMCAmJiBidWZmZXIuZGF0YXZpZXcuZ2V0SW50OChwb3MpID09PSAxKSB7XFxuICAgICAgICAgIC8vIDB4MDAwMDAwMVxcbiAgICAgICAgICBoZWFkZXJMZW5ndGggPSAzO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcG9zID0gYnVmZmVyLmxlbmd0aDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHsgcG9zLCBoZWFkZXJMZW5ndGggfTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXRBdmNjKHNwcywgcHBzKSB7XFxuICAgIGxldCByZXQgPSBuZXcgVWludDhBcnJheShzcHMuYnl0ZUxlbmd0aCArIHBwcy5ieXRlTGVuZ3RoICsgMTEpO1xcbiAgICByZXRbMF0gPSAweDAxO1xcbiAgICByZXRbMV0gPSBzcHNbMV07XFxuICAgIHJldFsyXSA9IHNwc1syXTtcXG4gICAgcmV0WzNdID0gc3BzWzNdO1xcbiAgICByZXRbNF0gPSAyNTU7XFxuICAgIHJldFs1XSA9IDIyNTtcXG5cXG4gICAgbGV0IG9mZnNldCA9IDY7XFxuXFxuICAgIHJldC5zZXQobmV3IFVpbnQ4QXJyYXkoW3Nwcy5ieXRlTGVuZ3RoID4+PiA4ICYgMHhmZiwgc3BzLmJ5dGVMZW5ndGggJiAweGZmXSksIG9mZnNldCk7XFxuICAgIG9mZnNldCArPSAyO1xcbiAgICByZXQuc2V0KHNwcywgb2Zmc2V0KTtcXG4gICAgb2Zmc2V0ICs9IHNwcy5ieXRlTGVuZ3RoO1xcblxcbiAgICByZXRbb2Zmc2V0XSA9IDE7XFxuICAgIG9mZnNldCsrO1xcblxcbiAgICByZXQuc2V0KG5ldyBVaW50OEFycmF5KFtwcHMuYnl0ZUxlbmd0aCA+Pj4gOCAmIDB4ZmYsIHBwcy5ieXRlTGVuZ3RoICYgMHhmZl0pLCBvZmZzZXQpO1xcbiAgICBvZmZzZXQgKz0gMjtcXG4gICAgcmV0LnNldChwcHMsIG9mZnNldCk7XFxuICAgIHJldHVybiByZXQ7XFxuICB9XFxufVxcblxcbmV4cG9ydHMuZGVmYXVsdCA9IE5hbHVuaXQ7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLWNvZGVjL3NyYy9oMjY0L25hbHVuaXQvaW5kZXguanM/Jyl9LFwiLi4veGdwbGF5ZXItY29kZWMvc3JjL2gyNjQvbmFsdW5pdC9zcHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItY29kZWMvc3JjL2gyNjQvbmFsdW5pdC9zcHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgX2dvbG9tYiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ29sb21iICovIFxcXCIuLi94Z3BsYXllci1jb2RlYy9zcmMvaDI2NC9uYWx1bml0L2dvbG9tYi5qc1xcXCIpO1xcblxcbnZhciBfZ29sb21iMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dvbG9tYik7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG5jbGFzcyBTUFNQYXJzZXIge1xcbiAgc3RhdGljIF9lYnNwMnJic3AodWludDhhcnJheSkge1xcbiAgICBsZXQgc3JjID0gdWludDhhcnJheTtcXG4gICAgbGV0IHNyY0xlbmd0aCA9IHNyYy5ieXRlTGVuZ3RoO1xcbiAgICBsZXQgZHN0ID0gbmV3IFVpbnQ4QXJyYXkoc3JjTGVuZ3RoKTtcXG4gICAgbGV0IGRzdElkeCA9IDA7XFxuXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3JjTGVuZ3RoOyBpKyspIHtcXG4gICAgICBpZiAoaSA+PSAyKSB7XFxuICAgICAgICBpZiAoc3JjW2ldID09PSAweDAzICYmIHNyY1tpIC0gMV0gPT09IDB4MDAgJiYgc3JjW2kgLSAyXSA9PT0gMHgwMCkge1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgZHN0W2RzdElkeF0gPSBzcmNbaV07XFxuICAgICAgZHN0SWR4Kys7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRzdC5idWZmZXIsIDAsIGRzdElkeCk7XFxuICB9XFxuXFxuICBzdGF0aWMgcGFyc2VTUFModWludDhhcnJheSkge1xcbiAgICBsZXQgcmJzcCA9IFNQU1BhcnNlci5fZWJzcDJyYnNwKHVpbnQ4YXJyYXkpO1xcbiAgICBsZXQgZ2IgPSBuZXcgX2dvbG9tYjIuZGVmYXVsdChyYnNwKTtcXG5cXG4gICAgZ2IucmVhZEJ5dGUoKTtcXG4gICAgbGV0IHByb2ZpbGVJZGMgPSBnYi5yZWFkQnl0ZSgpO1xcbiAgICBnYi5yZWFkQnl0ZSgpO1xcbiAgICBsZXQgbGV2ZWxJZGMgPSBnYi5yZWFkQnl0ZSgpO1xcbiAgICBnYi5yZWFkVUVHKCk7XFxuXFxuICAgIGxldCBwcm9maWxlX3N0cmluZyA9IFNQU1BhcnNlci5nZXRQcm9maWxlU3RyaW5nKHByb2ZpbGVJZGMpO1xcbiAgICBsZXQgbGV2ZWxfc3RyaW5nID0gU1BTUGFyc2VyLmdldExldmVsU3RyaW5nKGxldmVsSWRjKTtcXG4gICAgbGV0IGNocm9tYV9mb3JtYXRfaWRjID0gMTtcXG4gICAgbGV0IGNocm9tYV9mb3JtYXQgPSA0MjA7XFxuICAgIGxldCBjaHJvbWFfZm9ybWF0X3RhYmxlID0gWzAsIDQyMCwgNDIyLCA0NDRdO1xcbiAgICBsZXQgYml0X2RlcHRoID0gODtcXG5cXG4gICAgaWYgKHByb2ZpbGVJZGMgPT09IDEwMCB8fCBwcm9maWxlSWRjID09PSAxMTAgfHwgcHJvZmlsZUlkYyA9PT0gMTIyIHx8IHByb2ZpbGVJZGMgPT09IDI0NCB8fCBwcm9maWxlSWRjID09PSA0NCB8fCBwcm9maWxlSWRjID09PSA4MyB8fCBwcm9maWxlSWRjID09PSA4NiB8fCBwcm9maWxlSWRjID09PSAxMTggfHwgcHJvZmlsZUlkYyA9PT0gMTI4IHx8IHByb2ZpbGVJZGMgPT09IDEzOCB8fCBwcm9maWxlSWRjID09PSAxNDQpIHtcXG4gICAgICBjaHJvbWFfZm9ybWF0X2lkYyA9IGdiLnJlYWRVRUcoKTtcXG4gICAgICBpZiAoY2hyb21hX2Zvcm1hdF9pZGMgPT09IDMpIHtcXG4gICAgICAgIGdiLnJlYWRCaXRzKDEpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoY2hyb21hX2Zvcm1hdF9pZGMgPD0gMykge1xcbiAgICAgICAgY2hyb21hX2Zvcm1hdCA9IGNocm9tYV9mb3JtYXRfdGFibGVbY2hyb21hX2Zvcm1hdF9pZGNdO1xcbiAgICAgIH1cXG5cXG4gICAgICBiaXRfZGVwdGggPSBnYi5yZWFkVUVHKCkgKyA4O1xcbiAgICAgIGdiLnJlYWRVRUcoKTtcXG4gICAgICBnYi5yZWFkQml0cygxKTtcXG4gICAgICBpZiAoZ2IucmVhZEJvb2woKSkge1xcbiAgICAgICAgbGV0IHNjYWxpbmdfbGlzdF9jb3VudCA9IGNocm9tYV9mb3JtYXRfaWRjICE9PSAzID8gOCA6IDEyO1xcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2FsaW5nX2xpc3RfY291bnQ7IGkrKykge1xcbiAgICAgICAgICBpZiAoZ2IucmVhZEJvb2woKSkge1xcbiAgICAgICAgICAgIGlmIChpIDwgNikge1xcbiAgICAgICAgICAgICAgU1BTUGFyc2VyLl9za2lwU2NhbGluZ0xpc3QoZ2IsIDE2KTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgU1BTUGFyc2VyLl9za2lwU2NhbGluZ0xpc3QoZ2IsIDY0KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgZ2IucmVhZFVFRygpO1xcbiAgICBsZXQgcGljX29yZGVyX2NudF90eXBlID0gZ2IucmVhZFVFRygpO1xcbiAgICBpZiAocGljX29yZGVyX2NudF90eXBlID09PSAwKSB7XFxuICAgICAgZ2IucmVhZFVFRygpO1xcbiAgICB9IGVsc2UgaWYgKHBpY19vcmRlcl9jbnRfdHlwZSA9PT0gMSkge1xcbiAgICAgIGdiLnJlYWRCaXRzKDEpO1xcbiAgICAgIGdiLnJlYWRTRUcoKTtcXG4gICAgICBnYi5yZWFkU0VHKCk7XFxuICAgICAgbGV0IG51bV9yZWZfZnJhbWVzX2luX3BpY19vcmRlcl9jbnRfY3ljbGUgPSBnYi5yZWFkVUVHKCk7XFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1fcmVmX2ZyYW1lc19pbl9waWNfb3JkZXJfY250X2N5Y2xlOyBpKyspIHtcXG4gICAgICAgIGdiLnJlYWRTRUcoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgZ2IucmVhZFVFRygpO1xcbiAgICBnYi5yZWFkQml0cygxKTtcXG5cXG4gICAgbGV0IHBpY193aWR0aF9pbl9tYnNfbWludXMxID0gZ2IucmVhZFVFRygpO1xcbiAgICBsZXQgcGljX2hlaWdodF9pbl9tYXBfdW5pdHNfbWludXMxID0gZ2IucmVhZFVFRygpO1xcblxcbiAgICBsZXQgZnJhbWVfbWJzX29ubHlfZmxhZyA9IGdiLnJlYWRCaXRzKDEpO1xcbiAgICBpZiAoZnJhbWVfbWJzX29ubHlfZmxhZyA9PT0gMCkge1xcbiAgICAgIGdiLnJlYWRCaXRzKDEpO1xcbiAgICB9XFxuICAgIGdiLnJlYWRCaXRzKDEpO1xcblxcbiAgICBsZXQgZnJhbWVfY3JvcF9sZWZ0X29mZnNldCA9IDA7XFxuICAgIGxldCBmcmFtZV9jcm9wX3JpZ2h0X29mZnNldCA9IDA7XFxuICAgIGxldCBmcmFtZV9jcm9wX3RvcF9vZmZzZXQgPSAwO1xcbiAgICBsZXQgZnJhbWVfY3JvcF9ib3R0b21fb2Zmc2V0ID0gMDtcXG5cXG4gICAgbGV0IGZyYW1lX2Nyb3BwaW5nX2ZsYWcgPSBnYi5yZWFkQm9vbCgpO1xcbiAgICBpZiAoZnJhbWVfY3JvcHBpbmdfZmxhZykge1xcbiAgICAgIGZyYW1lX2Nyb3BfbGVmdF9vZmZzZXQgPSBnYi5yZWFkVUVHKCk7XFxuICAgICAgZnJhbWVfY3JvcF9yaWdodF9vZmZzZXQgPSBnYi5yZWFkVUVHKCk7XFxuICAgICAgZnJhbWVfY3JvcF90b3Bfb2Zmc2V0ID0gZ2IucmVhZFVFRygpO1xcbiAgICAgIGZyYW1lX2Nyb3BfYm90dG9tX29mZnNldCA9IGdiLnJlYWRVRUcoKTtcXG4gICAgfVxcblxcbiAgICBsZXQgcGFyX3dpZHRoID0gMSxcXG4gICAgICAgIHBhcl9oZWlnaHQgPSAxO1xcbiAgICBsZXQgZnBzID0gMCxcXG4gICAgICAgIGZwc19maXhlZCA9IHRydWUsXFxuICAgICAgICBmcHNfbnVtID0gMCxcXG4gICAgICAgIGZwc19kZW4gPSAwO1xcblxcbiAgICBsZXQgdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnID0gZ2IucmVhZEJvb2woKTtcXG4gICAgaWYgKHZ1aV9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZykge1xcbiAgICAgIGlmIChnYi5yZWFkQm9vbCgpKSB7XFxuICAgICAgICAvLyBhc3BlY3RfcmF0aW9faW5mb19wcmVzZW50X2ZsYWdcXG4gICAgICAgIGxldCBhc3BlY3RfcmF0aW9faWRjID0gZ2IucmVhZEJ5dGUoKTtcXG4gICAgICAgIGxldCBwYXJfd190YWJsZSA9IFsxLCAxMiwgMTAsIDE2LCA0MCwgMjQsIDIwLCAzMiwgODAsIDE4LCAxNSwgNjQsIDE2MCwgNCwgMywgMl07XFxuICAgICAgICBsZXQgcGFyX2hfdGFibGUgPSBbMSwgMTEsIDExLCAxMSwgMzMsIDExLCAxMSwgMTEsIDMzLCAxMSwgMTEsIDMzLCA5OSwgMywgMiwgMV07XFxuXFxuICAgICAgICBpZiAoYXNwZWN0X3JhdGlvX2lkYyA+IDAgJiYgYXNwZWN0X3JhdGlvX2lkYyA8IDE2KSB7XFxuICAgICAgICAgIHBhcl93aWR0aCA9IHBhcl93X3RhYmxlW2FzcGVjdF9yYXRpb19pZGMgLSAxXTtcXG4gICAgICAgICAgcGFyX2hlaWdodCA9IHBhcl9oX3RhYmxlW2FzcGVjdF9yYXRpb19pZGMgLSAxXTtcXG4gICAgICAgIH0gZWxzZSBpZiAoYXNwZWN0X3JhdGlvX2lkYyA9PT0gMjU1KSB7XFxuICAgICAgICAgIHBhcl93aWR0aCA9IGdiLnJlYWRCeXRlKCkgPDwgOCB8IGdiLnJlYWRCeXRlKCk7XFxuICAgICAgICAgIHBhcl9oZWlnaHQgPSBnYi5yZWFkQnl0ZSgpIDw8IDggfCBnYi5yZWFkQnl0ZSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZ2IucmVhZEJvb2woKSkge1xcbiAgICAgICAgZ2IucmVhZEJvb2woKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGdiLnJlYWRCb29sKCkpIHtcXG4gICAgICAgIGdiLnJlYWRCaXRzKDQpO1xcbiAgICAgICAgaWYgKGdiLnJlYWRCb29sKCkpIHtcXG4gICAgICAgICAgZ2IucmVhZEJpdHMoMjQpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAoZ2IucmVhZEJvb2woKSkge1xcbiAgICAgICAgZ2IucmVhZFVFRygpO1xcbiAgICAgICAgZ2IucmVhZFVFRygpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoZ2IucmVhZEJvb2woKSkge1xcbiAgICAgICAgbGV0IG51bV91bml0c19pbl90aWNrID0gZ2IucmVhZEJpdHMoMzIpO1xcbiAgICAgICAgbGV0IHRpbWVfc2NhbGUgPSBnYi5yZWFkQml0cygzMik7XFxuICAgICAgICBmcHNfZml4ZWQgPSBnYi5yZWFkQm9vbCgpO1xcblxcbiAgICAgICAgZnBzX251bSA9IHRpbWVfc2NhbGU7XFxuICAgICAgICBmcHNfZGVuID0gbnVtX3VuaXRzX2luX3RpY2sgKiAyO1xcbiAgICAgICAgZnBzID0gZnBzX251bSAvIGZwc19kZW47XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGxldCBwYXJTY2FsZSA9IDE7XFxuICAgIGlmIChwYXJfd2lkdGggIT09IDEgfHwgcGFyX2hlaWdodCAhPT0gMSkge1xcbiAgICAgIHBhclNjYWxlID0gcGFyX3dpZHRoIC8gcGFyX2hlaWdodDtcXG4gICAgfVxcblxcbiAgICBsZXQgY3JvcF91bml0X3ggPSAwLFxcbiAgICAgICAgY3JvcF91bml0X3kgPSAwO1xcbiAgICBpZiAoY2hyb21hX2Zvcm1hdF9pZGMgPT09IDApIHtcXG4gICAgICBjcm9wX3VuaXRfeCA9IDE7XFxuICAgICAgY3JvcF91bml0X3kgPSAyIC0gZnJhbWVfbWJzX29ubHlfZmxhZztcXG4gICAgfSBlbHNlIHtcXG4gICAgICBsZXQgc3ViX3djID0gY2hyb21hX2Zvcm1hdF9pZGMgPT09IDMgPyAxIDogMjtcXG4gICAgICBsZXQgc3ViX2hjID0gY2hyb21hX2Zvcm1hdF9pZGMgPT09IDEgPyAyIDogMTtcXG4gICAgICBjcm9wX3VuaXRfeCA9IHN1Yl93YztcXG4gICAgICBjcm9wX3VuaXRfeSA9IHN1Yl9oYyAqICgyIC0gZnJhbWVfbWJzX29ubHlfZmxhZyk7XFxuICAgIH1cXG5cXG4gICAgbGV0IGNvZGVjX3dpZHRoID0gKHBpY193aWR0aF9pbl9tYnNfbWludXMxICsgMSkgKiAxNjtcXG4gICAgbGV0IGNvZGVjX2hlaWdodCA9ICgyIC0gZnJhbWVfbWJzX29ubHlfZmxhZykgKiAoKHBpY19oZWlnaHRfaW5fbWFwX3VuaXRzX21pbnVzMSArIDEpICogMTYpO1xcblxcbiAgICBjb2RlY193aWR0aCAtPSAoZnJhbWVfY3JvcF9sZWZ0X29mZnNldCArIGZyYW1lX2Nyb3BfcmlnaHRfb2Zmc2V0KSAqIGNyb3BfdW5pdF94O1xcbiAgICBjb2RlY19oZWlnaHQgLT0gKGZyYW1lX2Nyb3BfdG9wX29mZnNldCArIGZyYW1lX2Nyb3BfYm90dG9tX29mZnNldCkgKiBjcm9wX3VuaXRfeTtcXG5cXG4gICAgbGV0IHByZXNlbnRfd2lkdGggPSBNYXRoLmNlaWwoY29kZWNfd2lkdGggKiBwYXJTY2FsZSk7XFxuXFxuICAgIGdiLmRlc3Ryb3koKTtcXG4gICAgZ2IgPSBudWxsO1xcblxcbiAgICByZXR1cm4ge1xcbiAgICAgIHByb2ZpbGVfc3RyaW5nOiBwcm9maWxlX3N0cmluZyxcXG4gICAgICBsZXZlbF9zdHJpbmc6IGxldmVsX3N0cmluZyxcXG4gICAgICBiaXRfZGVwdGg6IGJpdF9kZXB0aCxcXG4gICAgICBjaHJvbWFfZm9ybWF0OiBjaHJvbWFfZm9ybWF0LFxcbiAgICAgIGNocm9tYV9mb3JtYXRfc3RyaW5nOiBTUFNQYXJzZXIuZ2V0Q2hyb21hRm9ybWF0U3RyaW5nKGNocm9tYV9mb3JtYXQpLFxcblxcbiAgICAgIGZyYW1lX3JhdGU6IHtcXG4gICAgICAgIGZpeGVkOiBmcHNfZml4ZWQsXFxuICAgICAgICBmcHM6IGZwcyxcXG4gICAgICAgIGZwc19kZW46IGZwc19kZW4sXFxuICAgICAgICBmcHNfbnVtOiBmcHNfbnVtXFxuICAgICAgfSxcXG5cXG4gICAgICBwYXJfcmF0aW86IHtcXG4gICAgICAgIHdpZHRoOiBwYXJfd2lkdGgsXFxuICAgICAgICBoZWlnaHQ6IHBhcl9oZWlnaHRcXG4gICAgICB9LFxcblxcbiAgICAgIGNvZGVjX3NpemU6IHtcXG4gICAgICAgIHdpZHRoOiBjb2RlY193aWR0aCxcXG4gICAgICAgIGhlaWdodDogY29kZWNfaGVpZ2h0XFxuICAgICAgfSxcXG5cXG4gICAgICBwcmVzZW50X3NpemU6IHtcXG4gICAgICAgIHdpZHRoOiBwcmVzZW50X3dpZHRoLFxcbiAgICAgICAgaGVpZ2h0OiBjb2RlY19oZWlnaHRcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICBzdGF0aWMgX3NraXBTY2FsaW5nTGlzdChnYiwgY291bnQpIHtcXG4gICAgbGV0IGxhc3Rfc2NhbGUgPSA4LFxcbiAgICAgICAgbmV4dF9zY2FsZSA9IDg7XFxuICAgIGxldCBkZWx0YV9zY2FsZSA9IDA7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xcbiAgICAgIGlmIChuZXh0X3NjYWxlICE9PSAwKSB7XFxuICAgICAgICBkZWx0YV9zY2FsZSA9IGdiLnJlYWRTRUcoKTtcXG4gICAgICAgIG5leHRfc2NhbGUgPSAobGFzdF9zY2FsZSArIGRlbHRhX3NjYWxlICsgMjU2KSAlIDI1NjtcXG4gICAgICB9XFxuICAgICAgbGFzdF9zY2FsZSA9IG5leHRfc2NhbGUgPT09IDAgPyBsYXN0X3NjYWxlIDogbmV4dF9zY2FsZTtcXG4gICAgfVxcbiAgfVxcblxcbiAgc3RhdGljIGdldFByb2ZpbGVTdHJpbmcocHJvZmlsZUlkYykge1xcbiAgICBzd2l0Y2ggKHByb2ZpbGVJZGMpIHtcXG4gICAgICBjYXNlIDY2OlxcbiAgICAgICAgcmV0dXJuICdCYXNlbGluZSc7XFxuICAgICAgY2FzZSA3NzpcXG4gICAgICAgIHJldHVybiAnTWFpbic7XFxuICAgICAgY2FzZSA4ODpcXG4gICAgICAgIHJldHVybiAnRXh0ZW5kZWQnO1xcbiAgICAgIGNhc2UgMTAwOlxcbiAgICAgICAgcmV0dXJuICdIaWdoJztcXG4gICAgICBjYXNlIDExMDpcXG4gICAgICAgIHJldHVybiAnSGlnaDEwJztcXG4gICAgICBjYXNlIDEyMjpcXG4gICAgICAgIHJldHVybiAnSGlnaDQyMic7XFxuICAgICAgY2FzZSAyNDQ6XFxuICAgICAgICByZXR1cm4gJ0hpZ2g0NDQnO1xcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICByZXR1cm4gJ1Vua25vd24nO1xcbiAgICB9XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0TGV2ZWxTdHJpbmcobGV2ZWxJZGMpIHtcXG4gICAgcmV0dXJuIChsZXZlbElkYyAvIDEwKS50b0ZpeGVkKDEpO1xcbiAgfVxcblxcbiAgc3RhdGljIGdldENocm9tYUZvcm1hdFN0cmluZyhjaHJvbWEpIHtcXG4gICAgc3dpdGNoIChjaHJvbWEpIHtcXG4gICAgICBjYXNlIDQyMDpcXG4gICAgICAgIHJldHVybiAnNDoyOjAnO1xcbiAgICAgIGNhc2UgNDIyOlxcbiAgICAgICAgcmV0dXJuICc0OjI6Mic7XFxuICAgICAgY2FzZSA0NDQ6XFxuICAgICAgICByZXR1cm4gJzQ6NDo0JztcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgcmV0dXJuICdVbmtub3duJztcXG4gICAgfVxcbiAgfVxcblxcbiAgc3RhdGljIHRvVmlkZW9NZXRhKHNwc0NvbmZpZykge1xcbiAgICBsZXQgbWV0YSA9IHt9O1xcbiAgICBpZiAoc3BzQ29uZmlnICYmIHNwc0NvbmZpZy5jb2RlY19zaXplKSB7XFxuICAgICAgbWV0YS5jb2RlY1dpZHRoID0gc3BzQ29uZmlnLmNvZGVjX3NpemUud2lkdGg7XFxuICAgICAgbWV0YS5jb2RlY0hlaWdodCA9IHNwc0NvbmZpZy5jb2RlY19zaXplLmhlaWdodDtcXG4gICAgICBtZXRhLnByZXNlbnRXaWR0aCA9IHNwc0NvbmZpZy5wcmVzZW50X3NpemUud2lkdGg7XFxuICAgICAgbWV0YS5wcmVzZW50SGVpZ2h0ID0gc3BzQ29uZmlnLnByZXNlbnRfc2l6ZS5oZWlnaHQ7XFxuICAgIH1cXG5cXG4gICAgbWV0YS5wcm9maWxlID0gc3BzQ29uZmlnLnByb2ZpbGVfc3RyaW5nO1xcbiAgICBtZXRhLmxldmVsID0gc3BzQ29uZmlnLmxldmVsX3N0cmluZztcXG4gICAgbWV0YS5iaXREZXB0aCA9IHNwc0NvbmZpZy5iaXRfZGVwdGg7XFxuICAgIG1ldGEuY2hyb21hRm9ybWF0ID0gc3BzQ29uZmlnLmNocm9tYV9mb3JtYXQ7XFxuXFxuICAgIG1ldGEucGFyUmF0aW8gPSB7XFxuICAgICAgd2lkdGg6IHNwc0NvbmZpZy5wYXJfcmF0aW8ud2lkdGgsXFxuICAgICAgaGVpZ2h0OiBzcHNDb25maWcucGFyX3JhdGlvLmhlaWdodFxcbiAgICB9O1xcblxcbiAgICBtZXRhLmZyYW1lUmF0ZSA9IHNwc0NvbmZpZy5mcmFtZV9yYXRlO1xcblxcbiAgICBsZXQgZnBzRGVuID0gbWV0YS5mcmFtZVJhdGUuZnBzX2RlbjtcXG4gICAgbGV0IGZwc051bSA9IG1ldGEuZnJhbWVSYXRlLmZwc19udW07XFxuICAgIG1ldGEucmVmU2FtcGxlRHVyYXRpb24gPSBNYXRoLmZsb29yKG1ldGEudGltZXNjYWxlICogKGZwc0RlbiAvIGZwc051bSkpO1xcbiAgICByZXR1cm4gbWV0YTtcXG4gIH1cXG59IC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAgKi9cXG4vKiBlc2xpbnQtZGlzYWJsZSBvbmUtdmFyICAqL1xcbmV4cG9ydHMuZGVmYXVsdCA9IFNQU1BhcnNlcjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItY29kZWMvc3JjL2gyNjQvbmFsdW5pdC9zcHMuanM/XCIpfSxcIi4uL3hncGxheWVyLWRlbXV4L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLWRlbXV4L2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbCgnXFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICAvLyBITFNcXG4gIE0zVThQYXJzZXI6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2hscy9kZW11eGVyL20zdThwYXJzZXIgKi8gXCIuLi94Z3BsYXllci1kZW11eC9zcmMvaGxzL2RlbXV4ZXIvbTN1OHBhcnNlci5qc1wiKS5kZWZhdWx0LFxcbiAgVHNEZW11eGVyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9obHMvZGVtdXhlci90cyAqLyBcIi4uL3hncGxheWVyLWRlbXV4L3NyYy9obHMvZGVtdXhlci90cy5qc1wiKS5kZWZhdWx0LFxcbiAgUGxheWxpc3Q6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2hscy9wbGF5bGlzdCAqLyBcIi4uL3hncGxheWVyLWRlbXV4L3NyYy9obHMvcGxheWxpc3QuanNcIikuZGVmYXVsdCxcXG4gIEZsdkRlbXV4ZXI6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2Zsdi9pbmRleCAqLyBcIi4uL3hncGxheWVyLWRlbXV4L3NyYy9mbHYvaW5kZXguanNcIikuZGVmYXVsdFxcbn07XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLWRlbXV4L2luZGV4LmpzPycpfSxcIi4uL3hncGxheWVyLWRlbXV4L3NyYy9mbHYvYW1mLXBhcnNlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItZGVtdXgvc3JjL2Zsdi9hbWYtcGFyc2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBfeGdwbGF5ZXJVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHhncGxheWVyLXV0aWxzICovIFxcXCIuLi94Z3BsYXllci11dGlscy9pbmRleC5qc1xcXCIpO1xcblxcbmNvbnN0IERBVEFfVFlQRVMgPSB7XFxuICBOVU1CRVI6IDAsXFxuICBCT09MRUFOOiAxLFxcbiAgU1RSSU5HOiAyLFxcbiAgT0JKRUNUOiAzLFxcbiAgTUlYX0FSUkFZOiA4LFxcbiAgT0JKRUNUX0VORDogOSxcXG4gIFNUUklDVF9BUlJBWTogMTAsXFxuICBEQVRFOiAxMSxcXG4gIExPTkVfU1RSSU5HOiAxMlxcblxcbiAgLyoqXFxuICAgKiBtZXRh5L+h5oGv6Kej5p6QXFxuICAgKi9cXG59O2NsYXNzIEFNRlBhcnNlciB7XFxuICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgdGhpcy5vZmZzZXQgPSAwO1xcbiAgICB0aGlzLnJlYWRPZmZzZXQgPSB0aGlzLm9mZnNldDtcXG4gIH1cXG5cXG4gIHJlc29sdmUobWV0YSwgc2l6ZSkge1xcbiAgICBpZiAoc2l6ZSA8IDMpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBlbm91Z2ggZGF0YSBmb3IgbWV0YWluZm8nKTtcXG4gICAgfVxcbiAgICBjb25zdCBtZXRhRGF0YSA9IHt9O1xcbiAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZVZhbHVlKG1ldGEpO1xcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMucGFyc2VWYWx1ZShtZXRhLCBzaXplIC0gbmFtZS5ib2R5U2l6ZSk7XFxuICAgIG1ldGFEYXRhW25hbWUuZGF0YV0gPSB2YWx1ZS5kYXRhO1xcblxcbiAgICB0aGlzLnJlc2V0U3RhdHVzKCk7XFxuICAgIHJldHVybiBtZXRhRGF0YTtcXG4gIH1cXG5cXG4gIHJlc2V0U3RhdHVzKCkge1xcbiAgICB0aGlzLm9mZnNldCA9IDA7XFxuICAgIHRoaXMucmVhZE9mZnNldCA9IHRoaXMub2Zmc2V0O1xcbiAgfVxcblxcbiAgcGFyc2VTdHJpbmcoYnVmZmVyKSB7XFxuICAgIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KGJ1ZmZlciwgdGhpcy5yZWFkT2Zmc2V0KTtcXG4gICAgY29uc3Qgc3RyTGVuID0gZHYuZ2V0VWludDE2KDAsICFfeGdwbGF5ZXJVdGlscy5pc0xlKTtcXG4gICAgbGV0IHN0ciA9ICcnO1xcbiAgICBpZiAoc3RyTGVuID4gMCkge1xcbiAgICAgIHN0ciA9IF94Z3BsYXllclV0aWxzLlVURjguZGVjb2RlKG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgdGhpcy5yZWFkT2Zmc2V0ICsgMiwgc3RyTGVuKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3RyID0gJyc7XFxuICAgIH1cXG4gICAgbGV0IHNpemUgPSBzdHJMZW4gKyAyO1xcbiAgICB0aGlzLnJlYWRPZmZzZXQgKz0gc2l6ZTtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBkYXRhOiBzdHIsXFxuICAgICAgYm9keVNpemU6IHN0ckxlbiArIDJcXG4gICAgfTtcXG4gIH1cXG5cXG4gIHBhcnNlRGF0ZShidWZmZXIsIHNpemUpIHtcXG4gICAgY29uc3QgZHYgPSBuZXcgRGF0YVZpZXcoYnVmZmVyLCB0aGlzLnJlYWRPZmZzZXQsIHNpemUpO1xcbiAgICBsZXQgdHMgPSBkdi5nZXRGbG9hdDY0KDAsICFfeGdwbGF5ZXJVdGlscy5pc0xlKTtcXG4gICAgY29uc3QgdGltZU9mZnNldCA9IGR2LmdldEludDE2KDgsICFfeGdwbGF5ZXJVdGlscy5pc0xlKTtcXG4gICAgdHMgKz0gdGltZU9mZnNldCAqIDYwICogMTAwMDtcXG5cXG4gICAgdGhpcy5yZWFkT2Zmc2V0ICs9IDEwO1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGRhdGE6IG5ldyBEYXRlKHRzKSxcXG4gICAgICBib2R5U2l6ZTogMTBcXG4gICAgfTtcXG4gIH1cXG5cXG4gIHBhcnNlT2JqZWN0KGJ1ZmZlciwgc2l6ZSkge1xcbiAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZVN0cmluZyhidWZmZXIsIHNpemUpO1xcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMucGFyc2VWYWx1ZShidWZmZXIsIHNpemUgLSBuYW1lLmJvZHlTaXplKTtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBkYXRhOiB7XFxuICAgICAgICBuYW1lOiBuYW1lLmRhdGEsXFxuICAgICAgICB2YWx1ZTogdmFsdWUuZGF0YVxcbiAgICAgIH0sXFxuICAgICAgYm9keVNpemU6IG5hbWUuYm9keVNpemUgKyB2YWx1ZS5ib2R5U2l6ZSxcXG4gICAgICBpc09iakVuZDogdmFsdWUuaXNPYmpFbmRcXG4gICAgfTtcXG4gIH1cXG5cXG4gIHBhcnNlTG9uZ1N0cmluZyhidWZmZXIpIHtcXG4gICAgY29uc3QgZHYgPSBuZXcgRGF0YVZpZXcoYnVmZmVyLCB0aGlzLnJlYWRPZmZzZXQpO1xcbiAgICBjb25zdCBzdHJMZW4gPSBkdi5nZXRVaW50MzIoMCwgIV94Z3BsYXllclV0aWxzLmlzTGUpO1xcbiAgICBsZXQgc3RyID0gJyc7XFxuICAgIGlmIChzdHJMZW4gPiAwKSB7XFxuICAgICAgc3RyID0gX3hncGxheWVyVXRpbHMuVVRGOC5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCB0aGlzLnJlYWRPZmZzZXQgKyAyLCBzdHJMZW4pKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHIgPSAnJztcXG4gICAgfVxcbiAgICAvLyBjb25zdCBzaXplID0gc3RyTGVuICsgNDtcXG4gICAgdGhpcy5yZWFkT2Zmc2V0ICs9IHN0ckxlbiArIDQ7XFxuICAgIHJldHVybiB7XFxuICAgICAgZGF0YTogc3RyLFxcbiAgICAgIGJvZHlTaXplOiBzdHJMZW4gKyA0XFxuICAgIH07XFxuICB9XFxuXFxuICAvKipcXG4gICAqIOino+aekG1ldGHkuK3nmoTlj5jph49cXG4gICAqL1xcbiAgcGFyc2VWYWx1ZShkYXRhLCBzaXplKSB7XFxuICAgIGxldCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoKTtcXG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xcbiAgICAgIGJ1ZmZlciA9IGRhdGE7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgYnVmZmVyID0gZGF0YS5idWZmZXI7XFxuICAgIH1cXG4gICAgY29uc3Qge1xcbiAgICAgIE5VTUJFUixcXG4gICAgICBCT09MRUFOLFxcbiAgICAgIFNUUklORyxcXG4gICAgICBPQkpFQ1QsXFxuICAgICAgTUlYX0FSUkFZLFxcbiAgICAgIE9CSkVDVF9FTkQsXFxuICAgICAgU1RSSUNUX0FSUkFZLFxcbiAgICAgIERBVEUsXFxuICAgICAgTE9ORV9TVFJJTkdcXG4gICAgfSA9IERBVEFfVFlQRVM7XFxuICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlciwgdGhpcy5yZWFkT2Zmc2V0LCBzaXplKTtcXG4gICAgbGV0IGlzT2JqRW5kID0gZmFsc2U7XFxuICAgIGNvbnN0IHR5cGUgPSBkYXRhVmlldy5nZXRVaW50OCgwKTtcXG4gICAgbGV0IG9mZnNldCA9IDE7XFxuICAgIHRoaXMucmVhZE9mZnNldCArPSAxO1xcbiAgICBsZXQgdmFsdWUgPSBudWxsO1xcblxcbiAgICBzd2l0Y2ggKHR5cGUpIHtcXG4gICAgICBjYXNlIE5VTUJFUjpcXG4gICAgICAgIHtcXG4gICAgICAgICAgdmFsdWUgPSBkYXRhVmlldy5nZXRGbG9hdDY0KDEsICFfeGdwbGF5ZXJVdGlscy5pc0xlKTtcXG4gICAgICAgICAgdGhpcy5yZWFkT2Zmc2V0ICs9IDg7XFxuICAgICAgICAgIG9mZnNldCArPSA4O1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICBjYXNlIEJPT0xFQU46XFxuICAgICAgICB7XFxuICAgICAgICAgIGNvbnN0IGJvb2xOdW0gPSBkYXRhVmlldy5nZXRVaW50OCgxKTtcXG4gICAgICAgICAgdmFsdWUgPSAhIWJvb2xOdW07XFxuICAgICAgICAgIHRoaXMucmVhZE9mZnNldCArPSAxO1xcbiAgICAgICAgICBvZmZzZXQgKz0gMTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgY2FzZSBTVFJJTkc6XFxuICAgICAgICB7XFxuICAgICAgICAgIGNvbnN0IHN0ciA9IHRoaXMucGFyc2VTdHJpbmcoYnVmZmVyKTtcXG4gICAgICAgICAgdmFsdWUgPSBzdHIuZGF0YTtcXG4gICAgICAgICAgb2Zmc2V0ICs9IHN0ci5ib2R5U2l6ZTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgY2FzZSBPQkpFQ1Q6XFxuICAgICAgICB7XFxuICAgICAgICAgIHZhbHVlID0ge307XFxuICAgICAgICAgIGxldCBvYmpFbmRTaXplID0gMDtcXG4gICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQzMihzaXplIC0gNCwgIV94Z3BsYXllclV0aWxzLmlzTGUpICYgMHgwMEZGRkZGRikge1xcbiAgICAgICAgICAgIG9iakVuZFNpemUgPSAzO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIC8vIHRoaXMucmVhZE9mZnNldCArPSBvZmZzZXQgLSAxO1xcbiAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgc2l6ZSAtIDQpIHtcXG4gICAgICAgICAgICBjb25zdCBhbWZPYmogPSB0aGlzLnBhcnNlT2JqZWN0KGJ1ZmZlciwgc2l6ZSAtIG9mZnNldCAtIG9iakVuZFNpemUpO1xcbiAgICAgICAgICAgIGlmIChhbWZPYmouaXNPYmplY3RFbmQpIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2YWx1ZVthbWZPYmouZGF0YS5uYW1lXSA9IGFtZk9iai5kYXRhLnZhbHVlO1xcbiAgICAgICAgICAgIG9mZnNldCArPSBhbWZPYmouYm9keVNpemU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKG9mZnNldCA8PSBzaXplIC0gMykge1xcbiAgICAgICAgICAgIGNvbnN0IG1hcmsgPSBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0IC0gMSwgIV94Z3BsYXllclV0aWxzLmlzTGUpICYgMHgwMEZGRkZGRjtcXG4gICAgICAgICAgICBpZiAobWFyayA9PT0gOSkge1xcbiAgICAgICAgICAgICAgdGhpcy5yZWFkT2Zmc2V0ICs9IDM7XFxuICAgICAgICAgICAgICBvZmZzZXQgKz0gMztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgY2FzZSBNSVhfQVJSQVk6XFxuICAgICAgICB7XFxuICAgICAgICAgIHZhbHVlID0ge307XFxuICAgICAgICAgIG9mZnNldCArPSA0O1xcbiAgICAgICAgICB0aGlzLnJlYWRPZmZzZXQgKz0gNDtcXG4gICAgICAgICAgbGV0IG9iakVuZFNpemUgPSAwO1xcbiAgICAgICAgICBpZiAoKGRhdGFWaWV3LmdldFVpbnQzMihzaXplIC0gNCwgIV94Z3BsYXllclV0aWxzLmlzTGUpICYgMHgwMEZGRkZGRikgPT09IDkpIHtcXG4gICAgICAgICAgICBvYmpFbmRTaXplID0gMztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgc2l6ZSAtIDgpIHtcXG4gICAgICAgICAgICBjb25zdCBhbWZWYXIgPSB0aGlzLnBhcnNlT2JqZWN0KGJ1ZmZlciwgc2l6ZSAtIG9mZnNldCAtIG9iakVuZFNpemUpO1xcbiAgICAgICAgICAgIGlmIChhbWZWYXIuaXNPYmplY3RFbmQpIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2YWx1ZVthbWZWYXIuZGF0YS5uYW1lXSA9IGFtZlZhci5kYXRhLnZhbHVlO1xcbiAgICAgICAgICAgIG9mZnNldCArPSBhbWZWYXIuYm9keVNpemU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKG9mZnNldCA8PSBzaXplIC0gMykge1xcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQgLSAxLCAhX3hncGxheWVyVXRpbHMuaXNMZSkgJiAweDAwRkZGRkZGO1xcbiAgICAgICAgICAgIGlmIChtYXJrZXIgPT09IDkpIHtcXG4gICAgICAgICAgICAgIG9mZnNldCArPSAzO1xcbiAgICAgICAgICAgICAgdGhpcy5yZWFkT2Zmc2V0ICs9IDM7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcblxcbiAgICAgIGNhc2UgT0JKRUNUX0VORDpcXG4gICAgICAgIHtcXG4gICAgICAgICAgdmFsdWUgPSBudWxsO1xcbiAgICAgICAgICBpc09iakVuZCA9IHRydWU7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcblxcbiAgICAgIGNhc2UgU1RSSUNUX0FSUkFZOlxcbiAgICAgICAge1xcbiAgICAgICAgICB2YWx1ZSA9IFtdO1xcbiAgICAgICAgICBjb25zdCBhcnJMZW5ndGggPSBkYXRhVmlldy5nZXRVaW50MzIoMSwgIV94Z3BsYXllclV0aWxzLmlzTGUpO1xcbiAgICAgICAgICBvZmZzZXQgKz0gNDtcXG4gICAgICAgICAgdGhpcy5yZWFkT2Zmc2V0ICs9IDQ7XFxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICBjb25zdCBzY3JpcHQgPSB0aGlzLnBhcnNlVmFsdWUoYnVmZmVyLCBzaXplIC0gb2Zmc2V0KTtcXG4gICAgICAgICAgICB2YWx1ZS5wdXNoKHNjcmlwdC5kYXRhKTtcXG4gICAgICAgICAgICBvZmZzZXQgKz0gc2NyaXB0LmJvZHlTaXplO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcblxcbiAgICAgIGNhc2UgREFURTpcXG4gICAgICAgIHtcXG4gICAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMucGFyc2VEYXRlKGJ1ZmZlciwgc2l6ZSAtIDEpO1xcbiAgICAgICAgICB2YWx1ZSA9IGRhdGUuZGF0YTtcXG4gICAgICAgICAgb2Zmc2V0ICs9IGRhdGUuYm9keVNpemU7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcblxcbiAgICAgIGNhc2UgTE9ORV9TVFJJTkc6XFxuICAgICAgICB7XFxuICAgICAgICAgIGNvbnN0IGxvbmdTdHIgPSB0aGlzLnBhcnNlTG9uZ1N0cmluZyhidWZmZXIsIHNpemUgLSAxKTtcXG4gICAgICAgICAgdmFsdWUgPSBsb25nU3RyLmRhdGE7XFxuICAgICAgICAgIG9mZnNldCArPSBsb25nU3RyLmJvZHlTaXplO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG5cXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAge1xcbiAgICAgICAgICBvZmZzZXQgPSBzaXplO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgZGF0YTogdmFsdWUsXFxuICAgICAgYm9keVNpemU6IG9mZnNldCxcXG4gICAgICBpc09iakVuZDogaXNPYmpFbmRcXG4gICAgfTtcXG4gIH1cXG59XFxuZXhwb3J0cy5kZWZhdWx0ID0gQU1GUGFyc2VyO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci1kZW11eC9zcmMvZmx2L2FtZi1wYXJzZXIuanM/XCIpfSxcIi4uL3hncGxheWVyLWRlbXV4L3NyYy9mbHYvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci1kZW11eC9zcmMvZmx2L2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgX3hncGxheWVyVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB4Z3BsYXllci11dGlscyAqLyBcXFwiLi4veGdwbGF5ZXItdXRpbHMvaW5kZXguanNcXFwiKTtcXG5cXG52YXIgX3hncGxheWVyQ29kZWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB4Z3BsYXllci1jb2RlYyAqLyBcXFwiLi4veGdwbGF5ZXItY29kZWMvaW5kZXguanNcXFwiKTtcXG5cXG52YXIgX3hncGxheWVyQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgeGdwbGF5ZXItYnVmZmVyICovIFxcXCIuLi94Z3BsYXllci1idWZmZXIvaW5kZXguanNcXFwiKTtcXG5cXG52YXIgX2FtZlBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYW1mLXBhcnNlciAqLyBcXFwiLi4veGdwbGF5ZXItZGVtdXgvc3JjL2Zsdi9hbWYtcGFyc2VyLmpzXFxcIik7XFxuXFxudmFyIF9hbWZQYXJzZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYW1mUGFyc2VyKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxcblxcbmNvbnN0IERFTVVYX0VWRU5UUyA9IF94Z3BsYXllclV0aWxzLkVWRU5UUy5ERU1VWF9FVkVOVFM7XFxuXFxuY2xhc3MgRmx2RGVtdXhlciB7XFxuICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgdGhpcy5fZmlyc3RGcmFnbWVudExvYWRlZCA9IGZhbHNlO1xcbiAgICB0aGlzLl90cmFja051bSA9IDA7XFxuICAgIHRoaXMuX2hhc1NjcmlwdCA9IGZhbHNlO1xcbiAgfVxcblxcbiAgaW5pdCgpIHtcXG4gICAgdGhpcy5vbihERU1VWF9FVkVOVFMuREVNVVhfU1RBUlQsIHRoaXMuZG9QYXJzZUZsdi5iaW5kKHRoaXMpKTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogaWYgdGhlIGZsdiBoZWFkIGlzIHZhbGlkXFxuICAgKiBAcGFyYW0gZGF0YVxcbiAgICogQHJldHVybnMge2Jvb2xlYW59XFxuICAgKi9cXG4gIHN0YXRpYyBpc0ZsdkZpbGUoZGF0YSkge1xcbiAgICByZXR1cm4gIShkYXRhWzBdICE9PSAweDQ2IHx8IGRhdGFbMV0gIT09IDB4NEMgfHwgZGF0YVsyXSAhPT0gMHg1NiB8fCBkYXRhWzNdICE9PSAweDAxKTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogSWYgdGhlIHN0cmVhbSBoYXMgYXVkaW8gb3IgdmlkZW8uXFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RyZWFtRmxhZyAtIERhdGEgZnJvbSB0aGUgc3RyZWFtIHdoaWNoIGlzIGRlZmluZSB3aGV0aGVyIHRoZSBhdWRpbyAvIHZpZGVvIHRyYWNrIGlzIGV4aXN0LlxcbiAgICovXFxuICBzdGF0aWMgZ2V0UGxheVR5cGUoc3RyZWFtRmxhZykge1xcbiAgICBjb25zdCByZXN1bHQgPSB7XFxuICAgICAgaGFzVmlkZW86IGZhbHNlLFxcbiAgICAgIGhhc0F1ZGlvOiBmYWxzZVxcbiAgICB9O1xcblxcbiAgICBpZiAoc3RyZWFtRmxhZyAmIDB4MDEgPiAwKSB7XFxuICAgICAgcmVzdWx0Lmhhc1ZpZGVvID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBpZiAoc3RyZWFtRmxhZyAmIDB4MDQgPiAwKSB7XFxuICAgICAgcmVzdWx0Lmhhc0F1ZGlvID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfVxcblxcbiAgZG9QYXJzZUZsdigpIHtcXG4gICAgaWYgKCF0aGlzLl9maXJzdEZyYWdtZW50TG9hZGVkKSB7XFxuICAgICAgaWYgKHRoaXMubG9hZGVyQnVmZmVyLmxlbmd0aCA8IDEzKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICAgIGNvbnN0IGhlYWRlciA9IHRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDEzKTtcXG4gICAgICB0aGlzLnBhcnNlRmx2SGVhZGVyKGhlYWRlcik7XFxuICAgICAgdGhpcy5kb1BhcnNlRmx2KCk7IC8vIOmAkuW9kuiwg+eUqO+8jOe7p+e7reino+aekGZsdua1gVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGlmICh0aGlzLmxvYWRlckJ1ZmZlci5sZW5ndGggPCAxMSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICBsZXQgY2h1bms7XFxuXFxuICAgICAgbGV0IGxvb3BNYXggPSAxMDAwMDA7IC8vIOmYsuatouatu+W+queOr+S6p+eUn1xcbiAgICAgIGRvIHtcXG4gICAgICAgIGNodW5rID0gdGhpcy5fcGFyc2VGbHZUYWcoKTtcXG4gICAgICB9IHdoaWxlIChjaHVuayAmJiBsb29wTWF4LS0gPiAwKTtcXG5cXG4gICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLkRFTVVYX0NPTVBMRVRFKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcGFyc2VGbHZIZWFkZXIoaGVhZGVyKSB7XFxuICAgIGlmICghRmx2RGVtdXhlci5pc0ZsdkZpbGUoaGVhZGVyKSkge1xcbiAgICAgIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuREVNVVhfRVJST1IsIG5ldyBFcnJvcignaW52YWxpZCBmbHYgZmlsZScpKTtcXG4gICAgICB0aGlzLmRvUGFyc2VGbHYoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLl9maXJzdEZyYWdtZW50TG9hZGVkID0gdHJ1ZTtcXG4gICAgICBjb25zdCBwbGF5VHlwZSA9IEZsdkRlbXV4ZXIuZ2V0UGxheVR5cGUoaGVhZGVyWzRdKTtcXG5cXG4gICAgICBpZiAocGxheVR5cGUuaGFzVmlkZW8pIHtcXG4gICAgICAgIHRoaXMuaW5pdFZpZGVvVHJhY2soKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHBsYXlUeXBlLmhhc0F1ZGlvKSB7XFxuICAgICAgICB0aGlzLmluaXRBdWRpb1RyYWNrKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHRoaXMuZG9QYXJzZUZsdigpO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBpbml0IGRlZmF1bHQgdmlkZW8gdHJhY2sgY29uZmlnc1xcbiAgICovXFxuICBpbml0VmlkZW9UcmFjaygpIHtcXG4gICAgdGhpcy5fdHJhY2tOdW0rKztcXG4gICAgbGV0IHZpZGVvVHJhY2sgPSBuZXcgX3hncGxheWVyQnVmZmVyLlZpZGVvVHJhY2soKTtcXG4gICAgdmlkZW9UcmFjay5tZXRhID0gbmV3IF94Z3BsYXllclV0aWxzLlZpZGVvVHJhY2tNZXRhKCk7XFxuICAgIHZpZGVvVHJhY2suaWQgPSB2aWRlb1RyYWNrLm1ldGEuaWQgPSB0aGlzLl90cmFja051bTtcXG5cXG4gICAgdGhpcy50cmFja3MudmlkZW9UcmFjayA9IHZpZGVvVHJhY2s7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIGluaXQgZGVmYXVsdCBhdWRpbyB0cmFjayBjb25maWdzXFxuICAgKi9cXG4gIGluaXRBdWRpb1RyYWNrKCkge1xcbiAgICB0aGlzLl90cmFja051bSsrO1xcbiAgICBsZXQgYXVkaW9UcmFjayA9IG5ldyBfeGdwbGF5ZXJCdWZmZXIuQXVkaW9UcmFjaygpO1xcbiAgICBhdWRpb1RyYWNrLm1ldGEgPSBuZXcgX3hncGxheWVyVXRpbHMuQXVkaW9UcmFja01ldGEoKTtcXG4gICAgYXVkaW9UcmFjay5pZCA9IGF1ZGlvVHJhY2subWV0YS5pZCA9IHRoaXMuX3RyYWNrTnVtO1xcblxcbiAgICB0aGlzLnRyYWNrcy5hdWRpb1RyYWNrID0gYXVkaW9UcmFjaztcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogUGFja2FnZSB0aGUgZGF0YSBhcyB0aGUgZm9sbG93aW5nIGRhdGEgc3RydWN0dXJlXFxuICAgKiB7XFxuICAgKiAgICBkYXRhOiBVaW50OEFycmF5LiB0aGUgU3RyZWFtIGRhdGEuXFxuICAgKiAgICBpbmZvOiBUaGUgZmlyc3QgYnl0ZSBpbmZvIG9mIHRoZSBUYWcuXFxuICAgKiAgICB0YWdUeXBlOiA444CBOeOAgTE4XFxuICAgKiAgICB0aW1lU3RhbXA6IHRoZSB0aW1lc3RlbXBcXG4gICAqIH1cXG4gICAqL1xcbiAgX3BhcnNlRmx2VGFnKCkge1xcbiAgICBpZiAodGhpcy5sb2FkZXJCdWZmZXIubGVuZ3RoIDwgMTEpIHtcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgICBsZXQgY2h1bmsgPSB0aGlzLl9wYXJzZUZsdlRhZ0hlYWRlcigpO1xcbiAgICBpZiAoY2h1bmspIHtcXG4gICAgICB0aGlzLl9wcm9jZXNzQ2h1bmsoY2h1bmspO1xcbiAgICB9XFxuICAgIHJldHVybiBjaHVuaztcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogUGFyc2UgdGhlIDExIGJ5dGUgdGFnIEhlYWRlclxcbiAgICovXFxuICBfcGFyc2VGbHZUYWdIZWFkZXIoKSB7XFxuICAgIGxldCBvZmZzZXQgPSAwO1xcbiAgICBsZXQgY2h1bmsgPSB7fTtcXG5cXG4gICAgbGV0IHRhZ1R5cGUgPSB0aGlzLmxvYWRlckJ1ZmZlci50b0ludChvZmZzZXQsIDEpO1xcbiAgICBvZmZzZXQgKz0gMTtcXG5cXG4gICAgLy8gMiBiaXQgRk1TIHJlc2VydmVkLCAxIGJpdCBmaWx0ZXJlZCwgNSBiaXQgdGFnIHR5cGVcXG4gICAgY2h1bmsuZmlsdGVyZWQgPSAodGFnVHlwZSAmIDMyKSA+Pj4gNTtcXG4gICAgY2h1bmsudGFnVHlwZSA9IHRhZ1R5cGUgJiAzMTtcXG5cXG4gICAgLy8gMyBCeXRlIGRhdGFzaXplXFxuICAgIGNodW5rLmRhdGFzaXplID0gdGhpcy5sb2FkZXJCdWZmZXIudG9JbnQob2Zmc2V0LCAzKTtcXG4gICAgb2Zmc2V0ICs9IDM7XFxuXFxuICAgIGlmIChjaHVuay50YWdUeXBlICE9PSA4ICYmIGNodW5rLnRhZ1R5cGUgIT09IDkgJiYgY2h1bmsudGFnVHlwZSAhPT0gMTEgJiYgY2h1bmsudGFnVHlwZSAhPT0gMTggfHwgdGhpcy5sb2FkZXJCdWZmZXIudG9JbnQoOCwgMykgIT09IDApIHtcXG4gICAgICBpZiAodGhpcy5sb2FkZXJCdWZmZXIgJiYgdGhpcy5sb2FkZXJCdWZmZXIubGVuZ3RoID4gMCkge1xcbiAgICAgICAgdGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoMSk7XFxuICAgICAgfVxcbiAgICAgIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuREVNVVhfRVJST1IsIHRoaXMuVEFHLCBuZXcgRXJyb3IoJ3RhZ1R5cGUgJyArIGNodW5rLnRhZ1R5cGUpLCBmYWxzZSk7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMubG9hZGVyQnVmZmVyLmxlbmd0aCA8IGNodW5rLmRhdGFzaXplICsgMTUpIHtcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcblxcbiAgICAvLyByZWFkIHRoZSBkYXRhLlxcbiAgICB0aGlzLmxvYWRlckJ1ZmZlci5zaGlmdCg0KTtcXG5cXG4gICAgLy8gMyBCeXRlIHRpbWVzdGFtcFxcbiAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5sb2FkZXJCdWZmZXIudG9JbnQoMCwgMyk7XFxuICAgIHRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDMpO1xcblxcbiAgICAvLyAxIEJ5dGUgdGltZXN0YW1wRXh0XFxuICAgIGxldCB0aW1lc3RhbXBFeHQgPSB0aGlzLmxvYWRlckJ1ZmZlci5zaGlmdCgxKVswXTtcXG4gICAgaWYgKHRpbWVzdGFtcEV4dCA+IDApIHtcXG4gICAgICB0aW1lc3RhbXAgKz0gdGltZXN0YW1wRXh0ICogMHgxMDAwMDAwO1xcbiAgICB9XFxuXFxuICAgIGNodW5rLmR0cyA9IHRpbWVzdGFtcDtcXG5cXG4gICAgLy8gc3RyZWFtSWRcXG4gICAgdGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoMyk7XFxuICAgIHJldHVybiBjaHVuaztcXG4gIH1cXG5cXG4gIF9wcm9jZXNzQ2h1bmsoY2h1bmspIHtcXG4gICAgc3dpdGNoIChjaHVuay50YWdUeXBlKSB7XFxuICAgICAgY2FzZSAxODpcXG4gICAgICAgIHRoaXMuX3BhcnNlU2NyaXB0RGF0YShjaHVuayk7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIDg6XFxuICAgICAgICB0aGlzLl9wYXJzZUFBQ0RhdGEoY2h1bmspO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSA5OlxcbiAgICAgICAgdGhpcy5fcGFyc2VIZXZjRGF0YShjaHVuayk7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIDExOlxcbiAgICAgICAgLy8gZm9yIHNvbWUgQ0ROIHRoYXQgZGlkIG5vdCBwcm9jZXNzIHRoZSBjdXJyZWN0IFJUTVAgbWVzc2FnZXNcXG4gICAgICAgIHRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDMpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDEpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvKipcXG4gICAqIHBhcnNlIGZsdiBzY3JpcHQgZGF0YVxcbiAgICogQHBhcmFtIGNodW5rXFxuICAgKiBAcHJpdmF0ZVxcbiAgICovXFxuICBfcGFyc2VTY3JpcHREYXRhKGNodW5rKSB7XFxuICAgIGxldCBhdWRpb1RyYWNrID0gdGhpcy50cmFja3MuYXVkaW9UcmFjaztcXG4gICAgbGV0IHZpZGVvVHJhY2sgPSB0aGlzLnRyYWNrcy52aWRlb1RyYWNrO1xcblxcbiAgICBsZXQgZGF0YSA9IHRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KGNodW5rLmRhdGFzaXplKTtcXG5cXG4gICAgY29uc3QgaW5mbyA9IG5ldyBfYW1mUGFyc2VyMi5kZWZhdWx0KCkucmVzb2x2ZShkYXRhLCBkYXRhLmxlbmd0aCk7XFxuXFxuICAgIGNvbnN0IG9uTWV0YURhdGEgPSB0aGlzLl9jb250ZXh0Lm9uTWV0YURhdGEgPSBpbmZvID8gaW5mby5vbk1ldGFEYXRhIDogdW5kZWZpbmVkO1xcblxcbiAgICAvLyBmaWxsIG1lZGlhSW5mb1xcbiAgICB0aGlzLl9jb250ZXh0Lm1lZGlhSW5mby5kdXJhdGlvbiA9IG9uTWV0YURhdGEuZHVyYXRpb247XFxuICAgIHRoaXMuX2NvbnRleHQubWVkaWFJbmZvLmhhc1ZpZGVvID0gb25NZXRhRGF0YS5oYXNWaWRlbztcXG4gICAgdGhpcy5fY29udGV4dC5tZWRpYUluZm8uaHNhQXVkaW8gPSBvbk1ldGFEYXRhLmhhc0F1ZGlvO1xcblxcbiAgICBsZXQgdmFsaWRhdGUgPSB0aGlzLl9kYXRhc2l6ZVZhbGlkYXRvcihjaHVuay5kYXRhc2l6ZSk7XFxuICAgIGlmICh2YWxpZGF0ZSkge1xcbiAgICAgIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuTUVESUFfSU5GTyk7XFxuICAgICAgdGhpcy5faGFzU2NyaXB0ID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICAvLyBFZGl0IGRlZmF1bHQgbWV0YS5cXG4gICAgaWYgKGF1ZGlvVHJhY2sgJiYgIWF1ZGlvVHJhY2suaGFzU3BlY2lmaWNDb25maWcpIHtcXG4gICAgICBsZXQgbWV0YSA9IGF1ZGlvVHJhY2subWV0YTtcXG4gICAgICBpZiAob25NZXRhRGF0YS5hdWRpb3NhbXBsZXJhdGUpIHtcXG4gICAgICAgIG1ldGEuc2FtcGxlUmF0ZSA9IG9uTWV0YURhdGEuYXVkaW9zYW1wbGVyYXRlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob25NZXRhRGF0YS5hdWRpb2NoYW5uZWxzKSB7XFxuICAgICAgICBtZXRhLmNoYW5uZWxDb3VudCA9IG9uTWV0YURhdGEuYXVkaW9jaGFubmVscztcXG4gICAgICB9XFxuXFxuICAgICAgc3dpdGNoIChvbk1ldGFEYXRhLmF1ZGlvc2FtcGxlcmF0ZSkge1xcbiAgICAgICAgY2FzZSA0NDEwMDpcXG4gICAgICAgICAgbWV0YS5zYW1wbGVSYXRlSW5kZXggPSA0O1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgMjIwNTA6XFxuICAgICAgICAgIG1ldGEuc2FtcGxlUmF0ZUluZGV4ID0gNztcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlIDExMDI1OlxcbiAgICAgICAgICBtZXRhLnNhbXBsZVJhdGVJbmRleCA9IDEwO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKHZpZGVvVHJhY2sgJiYgIXZpZGVvVHJhY2suaGFzU3BlY2lmaWNDb25maWcpIHtcXG4gICAgICBsZXQgbWV0YSA9IHZpZGVvVHJhY2subWV0YTtcXG4gICAgICBpZiAodHlwZW9mIG9uTWV0YURhdGEuZnJhbWVyYXRlID09PSAnbnVtYmVyJykge1xcbiAgICAgICAgbGV0IGZwc051bSA9IE1hdGguZmxvb3Iob25NZXRhRGF0YS5mcmFtZXJhdGUgKiAxMDAwKTtcXG4gICAgICAgIGlmIChmcHNOdW0gPiAwKSB7XFxuICAgICAgICAgIGxldCBmcHMgPSBmcHNOdW0gLyAxMDAwO1xcbiAgICAgICAgICBpZiAoIW1ldGEuZnJhbWVSYXRlKSB7XFxuICAgICAgICAgICAgbWV0YS5mcmFtZVJhdGUgPSB7fTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBtZXRhLmZyYW1lUmF0ZS5maXhlZCA9IHRydWU7XFxuICAgICAgICAgIG1ldGEuZnJhbWVSYXRlLmZwcyA9IGZwcztcXG4gICAgICAgICAgbWV0YS5mcmFtZVJhdGUuZnBzX251bSA9IGZwc051bTtcXG4gICAgICAgICAgbWV0YS5mcmFtZVJhdGUuZnBzX2RlbiA9IDEwMDA7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBfYWFjU2VxdWVuY2VIZWFkZXJQYXJzZXIoZGF0YSkge1xcbiAgICBsZXQgcmV0ID0ge307XFxuICAgIHJldC5oYXNTcGVjaWZpY0NvbmZpZyA9IHRydWU7XFxuICAgIHJldC5vYmplY3RUeXBlID0gZGF0YVsxXSA+Pj4gMztcXG4gICAgcmV0LnNhbXBsZVJhdGVJbmRleCA9IChkYXRhWzFdICYgNykgPDwgMSB8IGRhdGFbMl0gPj4+IDc7XFxuICAgIHJldC5hdWRpb3NhbXBsZXJhdGUgPSB0aGlzLl9zd2l0Y2hBdWRpb1NhbXBsZVJhdGUocmV0LnNhbXBsZVJhdGVJbmRleCk7XFxuICAgIHJldC5jaGFubmVsQ291bnQgPSAoZGF0YVsyXSAmIDEyMCkgPj4+IDM7XFxuICAgIHJldC5mcmFtZUxlbmd0aCA9IChkYXRhWzJdICYgNCkgPj4+IDI7XFxuICAgIHJldC5kZXBlbmRzT25Db3JlQ29kZXIgPSAoZGF0YVsyXSAmIDIpID4+PiAxO1xcbiAgICByZXQuZXh0ZW5zaW9uRmxhZ0luZGV4ID0gZGF0YVsyXSAmIDE7XFxuXFxuICAgIHJldC5jb2RlYyA9IGBtcDRhLjQwLiR7cmV0Lm9iamVjdFR5cGV9YDtcXG4gICAgbGV0IHVzZXJBZ2VudCA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XFxuICAgIGxldCBleHRlbnNpb25TYW1wbGluZ0luZGV4O1xcblxcbiAgICBsZXQgY29uZmlnO1xcbiAgICBsZXQgc2FtcGxpbmdJbmRleCA9IHJldC5zYW1wbGVSYXRlSW5kZXg7XFxuXFxuICAgIGlmICh1c2VyQWdlbnQuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMSkge1xcbiAgICAgIC8vIGZpcmVmb3g6IHVzZSBTQlIgKEhFLUFBQykgaWYgZnJlcSBsZXNzIHRoYW4gMjRrSHpcXG4gICAgICBpZiAocmV0LnNhbXBsZVJhdGVJbmRleCA+PSA2KSB7XFxuICAgICAgICByZXQub2JqZWN0VHlwZSA9IDU7XFxuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XFxuICAgICAgICBleHRlbnNpb25TYW1wbGluZ0luZGV4ID0gc2FtcGxpbmdJbmRleCAtIDM7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIC8vIHVzZSBMQy1BQUNcXG4gICAgICAgIHJldC5vYmplY3RUeXBlID0gMjtcXG4gICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcXG4gICAgICAgIGV4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBzYW1wbGluZ0luZGV4O1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSkge1xcbiAgICAgIC8vIGFuZHJvaWQ6IGFsd2F5cyB1c2UgTEMtQUFDXFxuICAgICAgcmV0Lm9iamVjdFR5cGUgPSAyO1xcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcXG4gICAgICBleHRlbnNpb25TYW1wbGluZ0luZGV4ID0gc2FtcGxpbmdJbmRleDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBmb3Igb3RoZXIgYnJvd3NlcnMsIGUuZy4gY2hyb21lLi4uXFxuICAgICAgLy8gQWx3YXlzIHVzZSBIRS1BQUMgdG8gbWFrZSBpdCBlYXNpZXIgdG8gc3dpdGNoIGFhYyBjb2RlYyBwcm9maWxlXFxuICAgICAgcmV0Lm9iamVjdFR5cGUgPSA1O1xcbiAgICAgIGV4dGVuc2lvblNhbXBsaW5nSW5kZXggPSByZXQuc2FtcGxlUmF0ZUluZGV4O1xcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSg0KTtcXG5cXG4gICAgICBpZiAocmV0LnNhbXBsZVJhdGVJbmRleCA+PSA2KSB7XFxuICAgICAgICBleHRlbnNpb25TYW1wbGluZ0luZGV4ID0gcmV0LnNhbXBsZVJhdGVJbmRleCAtIDM7XFxuICAgICAgfSBlbHNlIGlmIChyZXQuY2hhbm5lbENvdW50ID09PSAxKSB7XFxuICAgICAgICAvLyBNb25vIGNoYW5uZWxcXG4gICAgICAgIHJldC5vYmplY3RUeXBlID0gMjtcXG4gICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcXG4gICAgICAgIGV4dGVuc2lvblNhbXBsaW5nSW5kZXggPSByZXQuc2FtcGxlUmF0ZUluZGV4O1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBjb25maWdbMF0gPSByZXQub2JqZWN0VHlwZSA8PCAzO1xcbiAgICBjb25maWdbMF0gfD0gKHJldC5zYW1wbGVSYXRlSW5kZXggJiAweDBGKSA+Pj4gMTtcXG4gICAgY29uZmlnWzFdID0gKHJldC5zYW1wbGVSYXRlSW5kZXggJiAweDBGKSA8PCA3O1xcbiAgICBjb25maWdbMV0gfD0gKHJldC5jaGFubmVsQ291bnQgJiAweDBGKSA8PCAzO1xcbiAgICBpZiAocmV0Lm9iamVjdFR5cGUgPT09IDUpIHtcXG4gICAgICBjb25maWdbMV0gfD0gKGV4dGVuc2lvblNhbXBsaW5nSW5kZXggJiAweDBGKSA+Pj4gMTtcXG4gICAgICBjb25maWdbMl0gPSAoZXh0ZW5zaW9uU2FtcGxpbmdJbmRleCAmIDB4MDEpIDw8IDc7XFxuICAgICAgLy8gZXh0ZW5kZWQgYXVkaW8gb2JqZWN0IHR5cGU6IGZvcmNlIHRvIDIgKExDLUFBQylcXG4gICAgICBjb25maWdbMl0gfD0gMiA8PCAyO1xcbiAgICAgIGNvbmZpZ1szXSA9IDA7XFxuICAgIH1cXG4gICAgcmV0LmNvbmZpZyA9IGNvbmZpZztcXG4gICAgcmV0dXJuIHJldDtcXG4gIH1cXG5cXG4gIF9wYXJzZUFBQ0RhdGEoY2h1bmspIHtcXG4gICAgbGV0IHRyYWNrID0gdGhpcy50cmFja3MuYXVkaW9UcmFjaztcXG4gICAgaWYgKCF0cmFjaykge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBsZXQgbWV0YSA9IHRyYWNrLm1ldGE7XFxuXFxuICAgIGlmICghbWV0YSkge1xcbiAgICAgIHRyYWNrLm1ldGEgPSBuZXcgX3hncGxheWVyVXRpbHMuQXVkaW9UcmFja01ldGEoKTtcXG4gICAgICBtZXRhID0gdHJhY2subWV0YTtcXG4gICAgfVxcblxcbiAgICBsZXQgaW5mbyA9IHRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDEpWzBdO1xcblxcbiAgICBjaHVuay5kYXRhID0gdGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoY2h1bmsuZGF0YXNpemUgLSAxKTtcXG5cXG4gICAgbGV0IGZvcm1hdCA9IChpbmZvICYgMjQwKSA+Pj4gNDtcXG5cXG4gICAgdHJhY2suZm9ybWF0ID0gZm9ybWF0O1xcblxcbiAgICBpZiAoZm9ybWF0ICE9PSAxMCkge1xcbiAgICAgIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuREVNVVhfRVJST1IsIG5ldyBFcnJvcihgaW52YWxpZCBhdWRpbyBmb3JtYXQ6ICR7Zm9ybWF0fWApKTtcXG4gICAgfVxcblxcbiAgICBpZiAoZm9ybWF0ID09PSAxMCAmJiAhdGhpcy5faGFzQXVkaW9TZXF1ZW5jZSkge1xcbiAgICAgIG1ldGEuc2FtcGxlUmF0ZSA9IHRoaXMuX3N3aXRjaEF1ZGlvU2FtcGxpbmdGcmVxdWVuY3koaW5mbyk7XFxuICAgICAgbWV0YS5zYW1wbGVSYXRlSW5kZXggPSAoaW5mbyAmIDEyKSA+Pj4gMjtcXG4gICAgICBtZXRhLmZyYW1lTGVudGggPSAoaW5mbyAmIDIpID4+PiAxO1xcbiAgICAgIG1ldGEuY2hhbm5lbENvdW50ID0gaW5mbyAmIDE7XFxuICAgICAgbWV0YS5yZWZTYW1wbGVEdXJhdGlvbiA9IE1hdGguZmxvb3IoMTAyNCAvIG1ldGEuYXVkaW9TYW1wbGVSYXRlICogbWV0YS50aW1lc2NhbGUpO1xcbiAgICB9XFxuXFxuICAgIGxldCBhdWRpb1NhbXBsZVJhdGUgPSBtZXRhLmF1ZGlvU2FtcGxlUmF0ZTtcXG4gICAgbGV0IGF1ZGlvU2FtcGxlUmF0ZUluZGV4ID0gbWV0YS5zYW1wbGVSYXRlSW5kZXg7XFxuICAgIGxldCByZWZTYW1wbGVEdXJhdGlvbiA9IG1ldGEucmVmU2FtcGxlRHVyYXRpb247XFxuXFxuICAgIGRlbGV0ZSBjaHVuay50YWdUeXBlO1xcbiAgICBsZXQgdmFsaWRhdGUgPSB0aGlzLl9kYXRhc2l6ZVZhbGlkYXRvcihjaHVuay5kYXRhc2l6ZSk7XFxuXFxuICAgIGlmIChjaHVuay5kYXRhWzBdID09PSAwKSB7XFxuICAgICAgLy8gQUFDIFNlcXVlbmNlIEhlYWRlclxcbiAgICAgIGxldCBhYWNIZWFkZXIgPSB0aGlzLl9hYWNTZXF1ZW5jZUhlYWRlclBhcnNlcihjaHVuay5kYXRhKTtcXG4gICAgICBhdWRpb1NhbXBsZVJhdGUgPSBhYWNIZWFkZXIuYXVkaW9zYW1wbGVyYXRlIHx8IG1ldGEuYXVkaW9TYW1wbGVSYXRlO1xcbiAgICAgIGF1ZGlvU2FtcGxlUmF0ZUluZGV4ID0gYWFjSGVhZGVyLnNhbXBsZVJhdGVJbmRleCB8fCBtZXRhLnNhbXBsZVJhdGVJbmRleDtcXG4gICAgICByZWZTYW1wbGVEdXJhdGlvbiA9IE1hdGguZmxvb3IoMTAyNCAvIGF1ZGlvU2FtcGxlUmF0ZSAqIG1ldGEudGltZXNjYWxlKTtcXG5cXG4gICAgICBtZXRhLmNoYW5uZWxDb3VudCA9IGFhY0hlYWRlci5jaGFubmVsQ291bnQ7XFxuICAgICAgbWV0YS5zYW1wbGVSYXRlID0gYXVkaW9TYW1wbGVSYXRlO1xcbiAgICAgIG1ldGEuc2FtcGxlUmF0ZUluZGV4ID0gYXVkaW9TYW1wbGVSYXRlSW5kZXg7XFxuICAgICAgbWV0YS5yZWZTYW1wbGVEdXJhdGlvbiA9IHJlZlNhbXBsZUR1cmF0aW9uO1xcbiAgICAgIG1ldGEuZHVyYXRpb24gPSB0aGlzLl9jb250ZXh0Lm1lZGlhSW5mby5kdXJhdGlvbiAqIG1ldGEudGltZXNjYWxlO1xcbiAgICAgIG1ldGEuY29uZmlnID0gYWFjSGVhZGVyLmNvbmZpZztcXG4gICAgICBtZXRhLm9iamVjdFR5cGUgPSBhYWNIZWFkZXIub2JqZWN0VHlwZTtcXG5cXG4gICAgICBjb25zdCBhdWRpb01lZGlhID0gdGhpcy5fY29udGV4dC5tZWRpYUluZm8uYXVkaW87XFxuXFxuICAgICAgLy8gZmlsbCBhdWRpbyBtZWRpYSBpbmZvXFxuICAgICAgYXVkaW9NZWRpYS5jb2RlYyA9IGFhY0hlYWRlci5jb2RlYztcXG4gICAgICBhdWRpb01lZGlhLmNoYW5uZWxDb3VudCA9IGFhY0hlYWRlci5jaGFubmVsQ291bnQ7XFxuICAgICAgYXVkaW9NZWRpYS5zYW1wbGVSYXRlID0gYXVkaW9TYW1wbGVSYXRlO1xcbiAgICAgIGF1ZGlvTWVkaWEuc2FtcGxlUmF0ZUluZGV4ID0gYWFjSGVhZGVyLmF1ZGlvU2FtcGxlUmF0ZUluZGV4O1xcblxcbiAgICAgIGlmICh0aGlzLl9oYXNTY3JpcHQgJiYgIXRoaXMuX2hhc0F1ZGlvU2VxdWVuY2UpIHtcXG4gICAgICAgIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuTUVUQURBVEFfUEFSU0VELCAnYXVkaW8nKTtcXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2hhc1NjcmlwdCAmJiB0aGlzLl9oYXNBdWRpb1NlcXVlbmNlKSB7XFxuICAgICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLk1FVEFEQVRBX1BBUlNFRCwgJ2F1ZGlvJyk7XFxuICAgICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLkFVRElPX01FVEFEQVRBX0NIQU5HRSk7XFxuICAgICAgICAvLyB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLk1FVEFEQVRBX1BBUlNFRCwgJ2F1ZGlvJylcXG4gICAgICB9XFxuICAgICAgdGhpcy5faGFzQXVkaW9TZXF1ZW5jZSA9IHRydWU7XFxuXFxuICAgICAgdGhpcy5fbWV0YUNoYW5nZSA9IHRydWU7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKHRoaXMuX21ldGFDaGFuZ2UpIHtcXG4gICAgICAgIGNodW5rLm9wdGlvbnMgPSB7XFxuICAgICAgICAgIG1ldGE6IHRyYWNrLm1ldGFcXG4gICAgICAgIH07XFxuICAgICAgICB0aGlzLl9tZXRhQ2hhbmdlID0gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGNodW5rLmRhdGEgPSBjaHVuay5kYXRhLnNsaWNlKDEsIGNodW5rLmRhdGEubGVuZ3RoKTtcXG4gICAgICB0cmFjay5zYW1wbGVzLnB1c2goY2h1bmspO1xcbiAgICB9XFxuICAgIGlmICghdmFsaWRhdGUpIHtcXG4gICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLkRFTVVYX0VSUk9SLCB0aGlzLlRBRywgbmV3IEVycm9yKCdUQUcgbGVuZ3RoIGVycm9yIGF0ICcgKyBjaHVuay5kYXRhc2l6ZSksIGZhbHNlKTtcXG4gICAgICAvLyB0aGlzLmxvZ2dlci53YXJuKHRoaXMuVEFHLCBlcnJvci5tZXNzYWdlKVxcbiAgICB9XFxuICB9XFxuXFxuICAvKipcXG4gICAqIHBhcnNlIGhldmMvYXZjIHZpZGVvIGRhdGFcXG4gICAqIEBwYXJhbSBjaHVua1xcbiAgICogQHByaXZhdGVcXG4gICAqL1xcbiAgX3BhcnNlSGV2Y0RhdGEoY2h1bmspIHtcXG4gICAgLy8gaGVhZGVyXFxuICAgIGxldCBpbmZvID0gdGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoMSlbMF07XFxuICAgIGNodW5rLmZyYW1lVHlwZSA9IChpbmZvICYgMHhmMCkgPj4+IDQ7XFxuICAgIGNodW5rLmlzS2V5ZnJhbWUgPSBjaHVuay5mcmFtZVR5cGUgPT09IDE7XFxuICAgIC8vIGxldCB0ZW1wQ29kZWNJRCA9IHRoaXMudHJhY2tzLnZpZGVvVHJhY2suY29kZWNJRFxcbiAgICBsZXQgY29kZWNJRCA9IGluZm8gJiAweDBmO1xcbiAgICB0aGlzLnRyYWNrcy52aWRlb1RyYWNrLmNvZGVjSUQgPSBjb2RlY0lEO1xcblxcbiAgICAvLyBoZXZj5ZKMYXZj55qEaGVhZGVy6Kej5p6Q5pa55byP5LiA5qC3XFxuICAgIGNodW5rLmF2Y1BhY2tldFR5cGUgPSB0aGlzLmxvYWRlckJ1ZmZlci5zaGlmdCgxKVswXTtcXG4gICAgY2h1bmsuY3RzID0gdGhpcy5sb2FkZXJCdWZmZXIudG9JbnQoMCwgMyk7XFxuICAgIHRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDMpO1xcblxcbiAgICAvLyAxMiBmb3IgaGV2YywgNyBmb3IgYXZjXFxuICAgIGlmIChjb2RlY0lEID09PSAxMikge1xcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmxvYWRlckJ1ZmZlci5zaGlmdChjaHVuay5kYXRhc2l6ZSAtIDUpO1xcbiAgICAgIGNodW5rLmRhdGEgPSBkYXRhO1xcblxcbiAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoY2h1bmsuYXZjUGFja2V0VHlwZSkgIT09IDApIHtcXG4gICAgICAgIGlmICghdGhpcy5fZGF0YXNpemVWYWxpZGF0b3IoY2h1bmsuZGF0YXNpemUpKSB7XFxuICAgICAgICAgIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuREVNVVhfRVJST1IsIHRoaXMuVEFHLCBuZXcgRXJyb3IoYGludmFsaWQgdmlkZW8gdGFnIGRhdGFzaXplOiAke2NodW5rLmRhdGFzaXplfWApLCBmYWxzZSk7XFxuICAgICAgICB9XFxuICAgICAgICBsZXQgbmFsdSA9IHt9O1xcbiAgICAgICAgbGV0IHIgPSAwO1xcbiAgICAgICAgbmFsdS5jdHMgPSBjaHVuay5jdHM7XFxuICAgICAgICBuYWx1LmR0cyA9IGNodW5rLmR0cztcXG4gICAgICAgIHdoaWxlIChjaHVuay5kYXRhLmxlbmd0aCA+IHIpIHtcXG4gICAgICAgICAgbGV0IHNpemVzID0gY2h1bmsuZGF0YS5zbGljZShOdW1iZXIucGFyc2VJbnQociksIDQgKyByKTtcXG4gICAgICAgICAgbmFsdS5zaXplID0gc2l6ZXNbM107XFxuICAgICAgICAgIG5hbHUuc2l6ZSArPSBzaXplc1syXSAqIDI1NjtcXG4gICAgICAgICAgbmFsdS5zaXplICs9IHNpemVzWzFdICogMjU2ICogMjU2O1xcbiAgICAgICAgICBuYWx1LnNpemUgKz0gc2l6ZXNbMF0gKiAyNTYgKiAyNTYgKiAyNTY7XFxuICAgICAgICAgIHIgKz0gNDtcXG4gICAgICAgICAgbmFsdS5kYXRhID0gY2h1bmsuZGF0YS5zbGljZShOdW1iZXIucGFyc2VJbnQociksIG5hbHUuc2l6ZSArIHIpO1xcbiAgICAgICAgICByICs9IG5hbHUuc2l6ZTtcXG4gICAgICAgICAgdGhpcy50cmFja3MudmlkZW9UcmFjay5zYW1wbGVzLnB1c2gobmFsdSk7XFxuICAgICAgICAgIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuTUVUQURBVEFfUEFSU0VELCAndmlkZW8nKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKE51bWJlci5wYXJzZUludChjaHVuay5hdmNQYWNrZXRUeXBlKSA9PT0gMCkge1xcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhc2l6ZVZhbGlkYXRvcihjaHVuay5kYXRhc2l6ZSkpIHtcXG4gICAgICAgICAgdGhpcy5lbWl0KERFTVVYX0VWRU5UUy5ERU1VWF9FUlJPUiwgdGhpcy5UQUcsIG5ldyBFcnJvcihgaW52YWxpZCB2aWRlbyB0YWcgZGF0YXNpemU6ICR7Y2h1bmsuZGF0YXNpemV9YCksIGZhbHNlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuTUVUQURBVEFfUEFSU0VELCAndmlkZW8nKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoY29kZWNJRCA9PT0gNykge1xcbiAgICAgIGxldCBkYXRhID0gdGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoY2h1bmsuZGF0YXNpemUgLSA1KTtcXG4gICAgICBpZiAoZGF0YVs0XSA9PT0gMCAmJiBkYXRhWzVdID09PSAwICYmIGRhdGFbNl0gPT09IDAgJiYgZGF0YVs3XSA9PT0gMSkge1xcbiAgICAgICAgbGV0IGF2Y2NsZW5ndGggPSAwO1xcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcXG4gICAgICAgICAgYXZjY2xlbmd0aCA9IGF2Y2NsZW5ndGggKiAyNTYgKyBkYXRhW2ldO1xcbiAgICAgICAgfVxcbiAgICAgICAgYXZjY2xlbmd0aCAtPSA0O1xcbiAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoNCwgZGF0YS5sZW5ndGgpO1xcbiAgICAgICAgZGF0YVszXSA9IGF2Y2NsZW5ndGggJSAyNTY7XFxuICAgICAgICBhdmNjbGVuZ3RoID0gKGF2Y2NsZW5ndGggLSBkYXRhWzNdKSAvIDI1NjtcXG4gICAgICAgIGRhdGFbMl0gPSBhdmNjbGVuZ3RoICUgMjU2O1xcbiAgICAgICAgYXZjY2xlbmd0aCA9IChhdmNjbGVuZ3RoIC0gZGF0YVsyXSkgLyAyNTY7XFxuICAgICAgICBkYXRhWzFdID0gYXZjY2xlbmd0aCAlIDI1NjtcXG4gICAgICAgIGRhdGFbMF0gPSAoYXZjY2xlbmd0aCAtIGRhdGFbMV0pIC8gMjU2O1xcbiAgICAgIH1cXG5cXG4gICAgICBjaHVuay5kYXRhID0gZGF0YTtcXG4gICAgICAvLyBJZiBpdCBpcyBBVkMgc2VxdWVjZSBIZWFkZXIuXFxuICAgICAgaWYgKGNodW5rLmF2Y1BhY2tldFR5cGUgPT09IDApIHtcXG4gICAgICAgIHRoaXMuX2F2Y1NlcXVlbmNlSGVhZGVyUGFyc2VyKGNodW5rLmRhdGEpO1xcbiAgICAgICAgbGV0IHZhbGlkYXRlID0gdGhpcy5fZGF0YXNpemVWYWxpZGF0b3IoY2h1bmsuZGF0YXNpemUpO1xcbiAgICAgICAgaWYgKHZhbGlkYXRlKSB7XFxuICAgICAgICAgIGlmICh0aGlzLl9oYXNTY3JpcHQgJiYgIXRoaXMuX2hhc1ZpZGVvU2VxdWVuY2UpIHtcXG4gICAgICAgICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLk1FVEFEQVRBX1BBUlNFRCwgJ3ZpZGVvJyk7XFxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5faGFzU2NyaXB0ICYmIHRoaXMuX2hhc1ZpZGVvU2VxdWVuY2UpIHtcXG4gICAgICAgICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLk1FVEFEQVRBX1BBUlNFRCwgJ2F1ZGlvJyk7XFxuICAgICAgICAgICAgdGhpcy5lbWl0KERFTVVYX0VWRU5UUy5WSURFT19NRVRBREFUQV9DSEFOR0UpO1xcbiAgICAgICAgICAgIC8vIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuTUVUQURBVEFfUEFSU0VELCAndmlkZW8nKVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHRoaXMuX2hhc1ZpZGVvU2VxdWVuY2UgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5fbWV0YUNoYW5nZSA9IHRydWU7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmICghdGhpcy5fZGF0YXNpemVWYWxpZGF0b3IoY2h1bmsuZGF0YXNpemUpKSB7XFxuICAgICAgICAgIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuREVNVVhfRVJST1IsIHRoaXMuVEFHLCBuZXcgRXJyb3IoYGludmFsaWQgdmlkZW8gdGFnIGRhdGFzaXplOiAke2NodW5rLmRhdGFzaXplfWApLCBmYWxzZSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLl9tZXRhQ2hhbmdlKSB7XFxuICAgICAgICAgIGNodW5rLm9wdGlvbnMgPSB7XFxuICAgICAgICAgICAgbWV0YTogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy50cmFja3MudmlkZW9UcmFjay5tZXRhKVxcbiAgICAgICAgICB9O1xcbiAgICAgICAgICB0aGlzLl9tZXRhQ2hhbmdlID0gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLnRyYWNrcy52aWRlb1RyYWNrLnNhbXBsZXMucHVzaChjaHVuayk7XFxuICAgICAgICAvLyB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLkRFTVVYX0NPTVBMRVRFKVxcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLkRFTVVYX0VSUk9SLCB0aGlzLlRBRywgbmV3IEVycm9yKGB2aWRlbyBjb2RlaWQgaXMgJHtjb2RlY0lEfWApLCBmYWxzZSk7XFxuICAgICAgY2h1bmsuZGF0YSA9IHRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KGNodW5rLmRhdGFzaXplIC0gMSk7XFxuICAgICAgaWYgKCF0aGlzLl9kYXRhc2l6ZVZhbGlkYXRvcihjaHVuay5kYXRhc2l6ZSkpIHtcXG4gICAgICAgIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuREVNVVhfRVJST1IsIHRoaXMuVEFHLCBuZXcgRXJyb3IoYGludmFsaWQgdmlkZW8gdGFnIGRhdGFzaXplOiAke2NodW5rLmRhdGFzaXplfWApLCBmYWxzZSk7XFxuICAgICAgfVxcbiAgICAgIHRoaXMudHJhY2tzLnZpZGVvVHJhY2suc2FtcGxlcy5wdXNoKGNodW5rKTtcXG4gICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLkRFTVVYX0NPTVBMRVRFKTtcXG4gICAgfVxcbiAgICBkZWxldGUgY2h1bmsudGFnVHlwZTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogcGFyc2UgYXZjIG1ldGFkYXRhXFxuICAgKiBAcGFyYW0gZGF0YVxcbiAgICogQHByaXZhdGVcXG4gICAqL1xcbiAgX2F2Y1NlcXVlbmNlSGVhZGVyUGFyc2VyKGRhdGEpIHtcXG4gICAgbGV0IHRyYWNrID0gdGhpcy50cmFja3MudmlkZW9UcmFjaztcXG5cXG4gICAgaWYgKCF0cmFjaykge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBsZXQgb2Zmc2V0ID0gMDtcXG5cXG4gICAgaWYgKCF0cmFjay5tZXRhKSB7XFxuICAgICAgdHJhY2subWV0YSA9IG5ldyBfeGdwbGF5ZXJVdGlscy5WaWRlb1RyYWNrTWV0YSgpO1xcbiAgICB9XFxuICAgIGxldCBtZXRhID0gdHJhY2subWV0YTtcXG5cXG4gICAgbWV0YS5jb25maWd1cmF0aW9uVmVyc2lvbiA9IGRhdGFbMF07XFxuICAgIG1ldGEuYXZjUHJvZmlsZUluZGljYXRpb24gPSBkYXRhWzFdO1xcbiAgICBtZXRhLnByb2ZpbGVDb21wYXRpYmlsaXR5ID0gZGF0YVsyXTtcXG4gICAgbWV0YS5hdmNMZXZlbEluZGljYXRpb24gPSBkYXRhWzNdIC8gMTA7XFxuICAgIG1ldGEubmFsVW5pdExlbmd0aCA9IChkYXRhWzRdICYgMHgwMykgKyAxO1xcblxcbiAgICBsZXQgbnVtT2ZTcHMgPSBkYXRhWzVdICYgMHgxZjtcXG4gICAgb2Zmc2V0ID0gNjtcXG4gICAgbGV0IGNvbmZpZyA9IHt9O1xcblxcbiAgICAvLyBwYXJzZSBTUFNcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PZlNwczsgaSsrKSB7XFxuICAgICAgbGV0IHNpemUgPSBkYXRhW29mZnNldF0gKiAyNTUgKyBkYXRhW29mZnNldCArIDFdO1xcbiAgICAgIG9mZnNldCArPSAyO1xcblxcbiAgICAgIGxldCBzcHMgPSBuZXcgVWludDhBcnJheShzaXplKTtcXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNpemU7IGorKykge1xcbiAgICAgICAgc3BzW2pdID0gZGF0YVtvZmZzZXQgKyBqXTtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gY29kZWMgc3RyaW5nXFxuICAgICAgbGV0IGNvZGVjU3RyaW5nID0gJ2F2YzEuJztcXG4gICAgICBmb3IgKGxldCBqID0gMTsgaiA8IDQ7IGorKykge1xcbiAgICAgICAgbGV0IGggPSBzcHNbal0udG9TdHJpbmcoMTYpO1xcbiAgICAgICAgaWYgKGgubGVuZ3RoIDwgMikge1xcbiAgICAgICAgICBoID0gJzAnICsgaDtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvZGVjU3RyaW5nICs9IGg7XFxuICAgICAgfVxcblxcbiAgICAgIG1ldGEuY29kZWMgPSBjb2RlY1N0cmluZztcXG5cXG4gICAgICBvZmZzZXQgKz0gc2l6ZTtcXG4gICAgICB0aGlzLnRyYWNrcy52aWRlb1RyYWNrLm1ldGEuc3BzID0gc3BzO1xcbiAgICAgIGNvbmZpZyA9IF94Z3BsYXllckNvZGVjLlNwc1BhcnNlci5wYXJzZVNQUyhzcHMpO1xcbiAgICB9XFxuXFxuICAgIGxldCBudW1PZlBwcyA9IGRhdGFbb2Zmc2V0XTtcXG5cXG4gICAgb2Zmc2V0Kys7XFxuXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtT2ZQcHM7IGkrKykge1xcbiAgICAgIGxldCBzaXplID0gZGF0YVtvZmZzZXRdICogMjU1ICsgZGF0YVtvZmZzZXQgKyAxXTtcXG4gICAgICBvZmZzZXQgKz0gMjtcXG4gICAgICBsZXQgcHBzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XFxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzaXplOyBqKyspIHtcXG4gICAgICAgIHBwc1tqXSA9IGRhdGFbb2Zmc2V0ICsgal07XFxuICAgICAgfVxcbiAgICAgIG9mZnNldCArPSBzaXplO1xcbiAgICAgIHRoaXMudHJhY2tzLnZpZGVvVHJhY2subWV0YS5wcHMgPSBwcHM7XFxuICAgIH1cXG5cXG4gICAgT2JqZWN0LmFzc2lnbihtZXRhLCBfeGdwbGF5ZXJDb2RlYy5TcHNQYXJzZXIudG9WaWRlb01ldGEoY29uZmlnKSk7XFxuXFxuICAgIC8vIGZpbGwgdmlkZW8gbWVkaWEgaW5mb1xcbiAgICBjb25zdCB2aWRlb01lZGlhID0gdGhpcy5fY29udGV4dC5tZWRpYUluZm8udmlkZW87XFxuXFxuICAgIHZpZGVvTWVkaWEuY29kZWMgPSBtZXRhLmNvZGVjO1xcbiAgICB2aWRlb01lZGlhLnByb2ZpbGUgPSBtZXRhLnByb2ZpbGU7XFxuICAgIHZpZGVvTWVkaWEubGV2ZWwgPSBtZXRhLmxldmVsO1xcbiAgICB2aWRlb01lZGlhLmNocm9tYUZvcm1hdCA9IG1ldGEuY2hyb21hRm9ybWF0O1xcbiAgICB2aWRlb01lZGlhLmZyYW1lUmF0ZSA9IG1ldGEuZnJhbWVSYXRlO1xcbiAgICB2aWRlb01lZGlhLnBhclJhdGlvID0gbWV0YS5wYXJSYXRpbztcXG4gICAgdmlkZW9NZWRpYS53aWR0aCA9IHZpZGVvTWVkaWEud2lkdGggPT09IG1ldGEucHJlc2VudFdpZHRoID8gdmlkZW9NZWRpYS53aWR0aCA6IG1ldGEucHJlc2VudFdpZHRoO1xcbiAgICB2aWRlb01lZGlhLmhlaWdodCA9IHZpZGVvTWVkaWEuaGVpZ2h0ID09PSBtZXRhLnByZXNlbnRIZWlnaHQgPyB2aWRlb01lZGlhLndpZHRoIDogbWV0YS5wcmVzZW50SGVpZ2h0O1xcblxcbiAgICBtZXRhLmR1cmF0aW9uID0gdGhpcy5fY29udGV4dC5tZWRpYUluZm8uZHVyYXRpb24gKiBtZXRhLnRpbWVzY2FsZTtcXG4gICAgbWV0YS5hdmNjID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xcbiAgICBtZXRhLmF2Y2Muc2V0KGRhdGEpO1xcbiAgICB0cmFjay5tZXRhID0gbWV0YTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogY2hvb3NlIGF1ZGlvIHNhbXBsZSByYXRlXFxuICAgKiBAcGFyYW0gc2FtcGxpbmdGcmVxdWVuY3lJbmRleFxcbiAgICogQHJldHVybnMge251bWJlcn1cXG4gICAqIEBwcml2YXRlXFxuICAgKi9cXG4gIF9zd2l0Y2hBdWRpb1NhbXBsZVJhdGUoc2FtcGxpbmdGcmVxdWVuY3lJbmRleCkge1xcbiAgICBsZXQgc2FtcGxpbmdGcmVxdWVuY3lMaXN0ID0gWzk2MDAwLCA4ODIwMCwgNjQwMDAsIDQ4MDAwLCA0NDEwMCwgMzIwMDAsIDI0MDAwLCAyMjA1MCwgMTYwMDAsIDEyMDAwLCAxMTAyNSwgODAwMCwgNzM1MF07XFxuICAgIHJldHVybiBzYW1wbGluZ0ZyZXF1ZW5jeUxpc3Rbc2FtcGxpbmdGcmVxdWVuY3lJbmRleF07XFxuICB9XFxuXFxuICAvKipcXG4gICAqIGNob29zZSBhdWRpbyBzYW1wbGluZyBmcmVxdWVuY2VcXG4gICAqIEBwYXJhbSBpbmZvXFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxcbiAgICogQHByaXZhdGVcXG4gICAqL1xcbiAgX3N3aXRjaEF1ZGlvU2FtcGxpbmdGcmVxdWVuY3koaW5mbykge1xcbiAgICBsZXQgc2FtcGxpbmdGcmVxdWVuY3lJbmRleCA9IChpbmZvICYgMTIpID4+PiAyO1xcbiAgICBsZXQgc2FtcGxpbmdGcmVxdWVuY3lMaXN0ID0gWzU1MDAsIDExMDI1LCAyMjA1MCwgNDQxMDAsIDQ4MDAwXTtcXG4gICAgcmV0dXJuIHNhbXBsaW5nRnJlcXVlbmN5TGlzdFtzYW1wbGluZ0ZyZXF1ZW5jeUluZGV4XTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogY2hvb3NlIGF1ZGlvIGNoYW5uZWwgY291bnRcXG4gICAqIEBwYXJhbSBpbmZvXFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxcbiAgICogQHByaXZhdGVcXG4gICAqL1xcbiAgX3N3aXRjaEF1ZGlvQ2hhbm5lbChpbmZvKSB7XFxuICAgIGxldCBzYW1wbGVUcmFja051bUluZGV4ID0gaW5mbyAmIDE7XFxuICAgIGxldCBzYW1wbGVUcmFja051bUxpc3QgPSBbMSwgMl07XFxuICAgIHJldHVybiBzYW1wbGVUcmFja051bUxpc3Rbc2FtcGxlVHJhY2tOdW1JbmRleF07XFxuICB9XFxuXFxuICAvKipcXG4gICAqIGNoZWNrIGRhdGFzaXplIGlzIHZhbGlkIHVzZSA0IEJ5dGUgYWZ0ZXIgY3VycmVudCB0YWdcXG4gICAqIEBwYXJhbSBkYXRhc2l6ZVxcbiAgICogQHJldHVybnMge2Jvb2xlYW59XFxuICAgKiBAcHJpdmF0ZVxcbiAgICovXFxuICBfZGF0YXNpemVWYWxpZGF0b3IoZGF0YXNpemUpIHtcXG4gICAgbGV0IGRhdGFzaXplQ29uZmlybSA9IHRoaXMubG9hZGVyQnVmZmVyLnRvSW50KDAsIDQpO1xcbiAgICB0aGlzLmxvYWRlckJ1ZmZlci5zaGlmdCg0KTtcXG4gICAgcmV0dXJuIGRhdGFzaXplQ29uZmlybSA9PT0gZGF0YXNpemUgKyAxMTtcXG4gIH1cXG5cXG4gIGdldCBsb2FkZXJCdWZmZXIoKSB7XFxuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoJ0xPQURFUl9CVUZGRVInKTtcXG4gICAgaWYgKGJ1ZmZlcikge1xcbiAgICAgIHJldHVybiBidWZmZXI7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhpcy5lbWl0KERFTVVYX0VWRU5UUy5ERU1VWF9FUlJPUiwgbmV3IEVycm9yKCfmib7kuI3liLAgbG9hZGVyQnVmZmVyIOWunuS+iycpKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZ2V0IHRyYWNrcygpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoJ1RSQUNLUycpO1xcbiAgfVxcblxcbiAgZ2V0IGxvZ2dlcigpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoJ0xPR0dFUicpO1xcbiAgfVxcbn1cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBGbHZEZW11eGVyO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci1kZW11eC9zcmMvZmx2L2luZGV4LmpzP1wiKX0sXCIuLi94Z3BsYXllci1kZW11eC9zcmMvaGxzL2RlbXV4ZXIvbTN1OHBhcnNlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci1kZW11eC9zcmMvaGxzL2RlbXV4ZXIvbTN1OHBhcnNlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbi8qKlxcbiAqIFJlZmVyZW5jZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzgyMTYjc2VjdGlvbi00LjNcXG4gKi9cXG5jbGFzcyBNM1U4UGFyc2VyIHtcXG4gIHN0YXRpYyBwYXJzZSh0ZXh0LCBiYXNldXJsID0gJycpIHtcXG4gICAgbGV0IHJldCA9IHtcXG4gICAgICBkdXJhdGlvbjogMFxcbiAgICB9O1xcbiAgICBpZiAoIXRleHQgfHwgIXRleHQuc3BsaXQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgbGV0IHJlZnMgPSB0ZXh0LnNwbGl0KC9cXFxccnxcXFxcbi8pO1xcbiAgICByZWZzID0gcmVmcy5maWx0ZXIocmVmID0+IHtcXG4gICAgICByZXR1cm4gcmVmO1xcbiAgICB9KTtcXG4gICAgbGV0IHJlZiA9IHJlZnMuc2hpZnQoKTtcXG4gICAgaWYgKCFyZWYubWF0Y2goJyNFWFRNM1UnKSkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtM3U4IGZpbGU6IG5vdCBcXFwiI0VYVE0zVVxcXCJgKTtcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgICByZWYgPSByZWZzLnNoaWZ0KCk7XFxuICAgIHdoaWxlIChyZWYpIHtcXG4gICAgICBsZXQgcmVmbSA9IHJlZi5tYXRjaCgvIyguW0EtWnwtXSopOiguKikvKTtcXG4gICAgICBsZXQgcmVmZCA9IHJlZi5tYXRjaCgvIyguW0EtWnwtXSopLyk7XFxuICAgICAgaWYgKHJlZmQgJiYgcmVmbSAmJiByZWZtLmxlbmd0aCA+IDIpIHtcXG4gICAgICAgIHN3aXRjaCAocmVmbVsxXSkge1xcbiAgICAgICAgICBjYXNlICdFWFQtWC1WRVJTSU9OJzpcXG4gICAgICAgICAgICByZXQudmVyc2lvbiA9IHBhcnNlSW50KHJlZm1bMl0pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlICdFWFQtWC1NRURJQS1TRVFVRU5DRSc6XFxuICAgICAgICAgICAgcmV0LnNlcXVlbmNlID0gcGFyc2VJbnQocmVmbVsyXSk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIGNhc2UgJ0VYVC1YLVRBUkdFVERVUkFUSU9OJzpcXG4gICAgICAgICAgICByZXQudGFyZ2V0ZHVyYXRpb24gPSBwYXJzZUZsb2F0KHJlZm1bMl0pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlICdFWFRJTkYnOlxcbiAgICAgICAgICAgIE0zVThQYXJzZXIucGFyc2VGcmFnKHJlZm0sIHJlZnMsIHJldCwgYmFzZXVybCk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIGNhc2UgJ0VYVC1YLUtFWSc6XFxuICAgICAgICAgICAgTTNVOFBhcnNlci5wYXJzZURlY3J5cHQocmVmbVsyXSwgcmV0KTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICB9aWYgKHJlZmQgJiYgcmVmZC5sZW5ndGggPiAxKSB7XFxuICAgICAgICBzd2l0Y2ggKHJlZmRbMV0pIHtcXG4gICAgICAgICAgY2FzZSAnRVhULVgtRElTQ09OVElOVUlUWSc6XFxuICAgICAgICAgICAgcmVmID0gcmVmcy5zaGlmdCgpO1xcbiAgICAgICAgICAgIGxldCByZWZtID0gcmVmLm1hdGNoKC8jKC5bQS1afC1dKik6KC4qKS8pO1xcbiAgICAgICAgICAgIGlmIChyZWZtLmxlbmd0aCA+IDIgJiYgcmVmbVsxXSA9PT0gJ0VYVElORicpIHtcXG4gICAgICAgICAgICAgIE0zVThQYXJzZXIucGFyc2VGcmFnKHJlZm0sIHJlZnMsIHJldCwgYmFzZXVybCwgdHJ1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZWYgPSByZWZzLnNoaWZ0KCk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJldDtcXG4gIH1cXG5cXG4gIHN0YXRpYyBwYXJzZUZyYWcocmVmbSwgcmVmcywgcmV0LCBiYXNldXJsLCBkaXNjb250aW51ZSkge1xcbiAgICBpZiAoIXJldC5mcmFncykge1xcbiAgICAgIHJldC5mcmFncyA9IFtdO1xcbiAgICB9XFxuXFxuICAgIGxldCBmcmVnID0ge1xcbiAgICAgIHN0YXJ0OiByZXQuZHVyYXRpb24sXFxuICAgICAgZHVyYXRpb246IHBhcnNlRmxvYXQocmVmbVsyXSkgKiAxMDAwXFxuICAgIH07XFxuXFxuICAgIHJldC5kdXJhdGlvbiArPSBmcmVnLmR1cmF0aW9uO1xcbiAgICBsZXQgbmV4dGxpbmUgPSByZWZzLnNoaWZ0KCk7XFxuICAgIGlmIChuZXh0bGluZS5tYXRjaCgvIyguKik6KC4qKS8pKSB7XFxuICAgICAgbmV4dGxpbmUgPSByZWZzLnNoaWZ0KCk7XFxuICAgIH1cXG4gICAgaWYgKG5leHRsaW5lLmxlbmd0aCA+IDAgJiYgbmV4dGxpbmUuY2hhckF0KDApID09PSAnLycgJiYgYmFzZXVybC5tYXRjaCgvLipcXFxcL1xcXFwvLipcXFxcLlxcXFx3Ky9nKSkge1xcbiAgICAgIGJhc2V1cmwgPSBiYXNldXJsLm1hdGNoKC8uKlxcXFwvXFxcXC8uKlxcXFwuXFxcXHcrL2cpWzBdO1xcbiAgICB9XFxuICAgIGlmIChuZXh0bGluZS5tYXRjaCgvLio6XFxcXC9cXFxcLy4qLykpIHtcXG4gICAgICBmcmVnLnVybCA9IG5leHRsaW5lO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZyZWcudXJsID0gYmFzZXVybCArIG5leHRsaW5lO1xcbiAgICB9XFxuICAgIGZyZWcuZGlzY29udGludWUgPSBkaXNjb250aW51ZTtcXG4gICAgcmV0LmZyYWdzLnB1c2goZnJlZyk7XFxuICB9XFxuXFxuICBzdGF0aWMgcGFyc2VVUkwodXJsKSB7XFxuICAgIGxldCBiYXNldXJsID0gJyc7XFxuICAgIGxldCB1cmxzID0gdXJsLm1hdGNoKC8oLipcXFxcLykuKlxcXFwubTN1OC8pO1xcbiAgICBpZiAodXJscyAmJiB1cmxzLmxlbmd0aCA+IDApIHtcXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGlmICh1cmxzW2ldLm1hdGNoKC8uKlxcXFwvJC9nKSAmJiB1cmxzW2ldLmxlbmd0aCA+IGJhc2V1cmwubGVuZ3RoKSB7XFxuICAgICAgICAgIGJhc2V1cmwgPSB1cmxzW2ldO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gYmFzZXVybDtcXG4gIH1cXG5cXG4gIHN0YXRpYyBwYXJzZURlY3J5cHQocmVmbSwgcmV0KSB7XFxuICAgIHJldC5lbmNyeXB0ID0ge307XFxuICAgIGxldCByZWZzID0gcmVmbS5zcGxpdCgnLCcpO1xcbiAgICBmb3IgKGxldCBpIGluIHJlZnMpIHtcXG4gICAgICBsZXQgY21kID0gcmVmc1tpXTtcXG4gICAgICBpZiAoY21kLm1hdGNoKC9NRVRIT0Q9KC4qKS8pKSB7XFxuICAgICAgICByZXQuZW5jcnlwdC5tZXRob2QgPSBjbWQubWF0Y2goL01FVEhPRD0oLiopLylbMV07XFxuICAgICAgfVxcbiAgICAgIGlmIChjbWQubWF0Y2goL1VSST1cXFwiKC4qKVxcXCIvKSkge1xcbiAgICAgICAgcmV0LmVuY3J5cHQudXJpID0gY21kLm1hdGNoKC9VUkk9XFxcIiguKilcXFwiLylbMV07XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChjbWQubWF0Y2goL0lWPTB4KC4qKS8pKSB7XFxuICAgICAgICBsZXQgaXYgPSBjbWQubWF0Y2goL0lWPTB4KC4qKS8pWzFdO1xcbiAgICAgICAgbGV0IGxlbmd0aCA9IE1hdGguY2VpbChpdi5sZW5ndGggLyAyKTtcXG4gICAgICAgIHJldC5lbmNyeXB0Lml2YiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XFxuICAgICAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG4gICAgICAgICAgbGV0IGltID0gcGFyc2VJbnQoaXYuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xcbiAgICAgICAgICByZXQuZW5jcnlwdC5pdmJbaV0gPSBpbTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldC5lbmNyeXB0Lml2ID0gaXY7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcbn1cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBNM1U4UGFyc2VyO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci1kZW11eC9zcmMvaGxzL2RlbXV4ZXIvbTN1OHBhcnNlci5qcz9cIil9LFwiLi4veGdwbGF5ZXItZGVtdXgvc3JjL2hscy9kZW11eGVyL3RzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci1kZW11eC9zcmMvaGxzL2RlbXV4ZXIvdHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIF94Z3BsYXllckNvZGVjID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgeGdwbGF5ZXItY29kZWMgKi8gXFxcIi4uL3hncGxheWVyLWNvZGVjL2luZGV4LmpzXFxcIik7XFxuXFxudmFyIF94Z3BsYXllckJ1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHhncGxheWVyLWJ1ZmZlciAqLyBcXFwiLi4veGdwbGF5ZXItYnVmZmVyL2luZGV4LmpzXFxcIik7XFxuXFxudmFyIF94Z3BsYXllclV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgeGdwbGF5ZXItdXRpbHMgKi8gXFxcIi4uL3hncGxheWVyLXV0aWxzL2luZGV4LmpzXFxcIik7XFxuXFxuY29uc3QgREVNVVhfRVZFTlRTID0gX3hncGxheWVyVXRpbHMuRVZFTlRTLkRFTVVYX0VWRU5UUztcXG5jb25zdCBTdHJlYW1UeXBlID0ge1xcbiAgMHgwMTogWyd2aWRlbycsICdNUEVHLTEnXSxcXG4gIDB4MDI6IFsndmlkZW8nLCAnTVBFRy0yJ10sXFxuICAweDFiOiBbJ3ZpZGVvJywgJ0FWQy5IMjY0J10sXFxuICAweGVhOiBbJ3ZpZGVvJywgJ1ZDLTEnXSxcXG4gIDB4MDM6IFsnYXVkaW8nLCAnTVBFRy0xJ10sXFxuICAweDA0OiBbJ2F1ZGlvJywgJ01QRUctMiddLFxcbiAgMHgwZjogWydhdWRpbycsICdNUEVHLTIuQUFDJ10sXFxuICAweDExOiBbJ2F1ZGlvJywgJ01QRUctNC5BQUMnXSxcXG4gIDB4ODA6IFsnYXVkaW8nLCAnTFBDTSddLFxcbiAgMHg4MTogWydhdWRpbycsICdBQzMnXSxcXG4gIDB4MDY6IFsnYXVkaW8nLCAnQUMzJ10sXFxuICAweDgyOiBbJ2F1ZGlvJywgJ0RUUyddLFxcbiAgMHg4MzogWydhdWRpbycsICdEb2xieSBUcnVlSEQnXSxcXG4gIDB4ODQ6IFsnYXVkaW8nLCAnQUMzLVBsdXMnXSxcXG4gIDB4ODU6IFsnYXVkaW8nLCAnRFRTLUhEJ10sXFxuICAweDg2OiBbJ2F1ZGlvJywgJ0RUUy1NQSddLFxcbiAgMHhhMTogWydhdWRpbycsICdBQzMtUGx1cy1TRUMnXSxcXG4gIDB4YTI6IFsnYXVkaW8nLCAnRFRTLUhELVNFQyddXFxufTtcXG5cXG5jbGFzcyBUc0RlbXV4ZXIge1xcbiAgY29uc3RydWN0b3IoY29uZmlncykge1xcbiAgICB0aGlzLmNvbmZpZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWdzKTtcXG4gICAgdGhpcy5kZW11eGluZyA9IGZhbHNlO1xcbiAgICB0aGlzLnBhdCA9IFtdO1xcbiAgICB0aGlzLnBtdCA9IFtdO1xcbiAgICB0aGlzLl9oYXNWaWRlb01ldGEgPSBmYWxzZTtcXG4gICAgdGhpcy5faGFzQXVkaW9NZXRhID0gZmFsc2U7XFxuICB9XFxuXFxuICBpbml0KCkge1xcbiAgICB0aGlzLm9uKERFTVVYX0VWRU5UUy5ERU1VWF9TVEFSVCwgdGhpcy5kZW11eC5iaW5kKHRoaXMpKTtcXG4gIH1cXG5cXG4gIGRlbXV4KGZyYWcpIHtcXG4gICAgaWYgKHRoaXMuZGVtdXhpbmcpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgbGV0IGJ1ZmZlciA9IHRoaXMuaW5wdXRCdWZmZXI7XFxuICAgIGxldCBmcmFncyA9IHsgcGF0OiBbXSwgcG10OiBbXSB9O1xcbiAgICBsZXQgcGVzZXMgPSB7fTtcXG5cXG4gICAgLy8gUmVhZCBUUyBzZWdtZW50XFxuICAgIHdoaWxlIChidWZmZXIubGVuZ3RoID49IDE4OCkge1xcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoID49IDEgJiYgYnVmZmVyLmFycmF5WzBdW2J1ZmZlci5vZmZzZXRdICE9PSA3MSkge1xcbiAgICAgICAgdGhpcy5lbWl0KERFTVVYX0VWRU5UUy5ERU1VWF9FUlJPUiwgdGhpcy5UQUcsIG5ldyBFcnJvcihgVW50cnVzdCBzeW5jIGNvZGU6ICR7YnVmZmVyLmFycmF5WzBdW2J1ZmZlci5vZmZzZXRdfSwgdHJ5IHRvIHJlY292ZXI7YCksIGZhbHNlKTtcXG4gICAgICB9XFxuICAgICAgd2hpbGUgKGJ1ZmZlci5sZW5ndGggPj0gMSAmJiBidWZmZXIuYXJyYXlbMF1bYnVmZmVyLm9mZnNldF0gIT09IDcxKSB7XFxuICAgICAgICBidWZmZXIuc2hpZnQoMSk7XFxuICAgICAgfVxcbiAgICAgIGxldCBidWYgPSBidWZmZXIuc2hpZnQoMTg4KTtcXG4gICAgICAvLyBjb25zb2xlLmxvZyhidWYpO1xcbiAgICAgIGxldCB0c1N0cmVhbSA9IG5ldyBfeGdwbGF5ZXJVdGlscy5TdHJlYW0oYnVmLmJ1ZmZlcik7XFxuICAgICAgbGV0IHRzID0ge307XFxuICAgICAgVHNEZW11eGVyLnJlYWQodHNTdHJlYW0sIHRzLCBmcmFncyk7XFxuICAgICAgaWYgKHRzLnBlcykge1xcbiAgICAgICAgaWYgKCFwZXNlc1t0cy5oZWFkZXIucGlkXSkge1xcbiAgICAgICAgICBwZXNlc1t0cy5oZWFkZXIucGlkXSA9IFtdO1xcbiAgICAgICAgfVxcbiAgICAgICAgcGVzZXNbdHMuaGVhZGVyLnBpZF0ucHVzaCh0cy5wZXMpO1xcbiAgICAgICAgdHMucGVzLkVTLmJ1ZmZlciA9IFt0cy5wZXMuRVMuYnVmZmVyXTtcXG4gICAgICB9IGVsc2UgaWYgKHBlc2VzW3RzLmhlYWRlci5waWRdKSB7XFxuICAgICAgICBwZXNlc1t0cy5oZWFkZXIucGlkXVtwZXNlc1t0cy5oZWFkZXIucGlkXS5sZW5ndGggLSAxXS5FUy5idWZmZXIucHVzaCh0cy5wYXlsb2FkLnN0cmVhbSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGxldCBBdWRpb09wdGlvbnMgPSBmcmFnO1xcbiAgICBsZXQgVmlkZW9PcHRpb25zID0gZnJhZztcXG5cXG4gICAgLy8gR2V0IEZyYW1lcyBkYXRhXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgT2JqZWN0LmtleXMocGVzZXMpLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgbGV0IGVwZXNlcyA9IHBlc2VzW09iamVjdC5rZXlzKHBlc2VzKVtpXV07XFxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBlcGVzZXMubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgIGVwZXNlc1tqXS5pZCA9IE9iamVjdC5rZXlzKHBlc2VzKVtpXTtcXG4gICAgICAgIGVwZXNlc1tqXS5FUy5idWZmZXIgPSBUc0RlbXV4ZXIuTWVyZ2UoZXBlc2VzW2pdLkVTLmJ1ZmZlcik7XFxuICAgICAgICBpZiAoZXBlc2VzW2pdLnR5cGUgPT09ICdhdWRpbycpIHtcXG4gICAgICAgICAgdGhpcy5wdXNoQXVkaW9TYW1wbGUoZXBlc2VzW2pdLCBBdWRpb09wdGlvbnMpO1xcbiAgICAgICAgICBBdWRpb09wdGlvbnMgPSB7fTtcXG4gICAgICAgIH0gZWxzZSBpZiAoZXBlc2VzW2pdLnR5cGUgPT09ICd2aWRlbycpIHtcXG4gICAgICAgICAgdGhpcy5wdXNoVmlkZW9TYW1wbGUoZXBlc2VzW2pdLCBWaWRlb09wdGlvbnMpO1xcbiAgICAgICAgICBWaWRlb09wdGlvbnMgPSB7fTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuX2hhc0F1ZGlvTWV0YSkge1xcbiAgICAgIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuREVNVVhfQ09NUExFVEUsICdhdWRpbycpO1xcbiAgICB9XFxuICAgIGlmICh0aGlzLl9oYXNWaWRlb01ldGEpIHtcXG4gICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLkRFTVVYX0NPTVBMRVRFLCAndmlkZW8nKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcHVzaEF1ZGlvU2FtcGxlKHBlcywgb3B0aW9ucykge1xcbiAgICBsZXQgdHJhY2s7XFxuICAgIGlmICghdGhpcy5fdHJhY2tzLmF1ZGlvVHJhY2spIHtcXG4gICAgICB0aGlzLl90cmFja3MuYXVkaW9UcmFjayA9IG5ldyBfeGdwbGF5ZXJCdWZmZXIuQXVkaW9UcmFjaygpO1xcbiAgICAgIHRyYWNrID0gdGhpcy5fdHJhY2tzLmF1ZGlvVHJhY2s7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdHJhY2sgPSB0aGlzLl90cmFja3MuYXVkaW9UcmFjaztcXG4gICAgfVxcbiAgICBsZXQgbWV0YSA9IG5ldyBfeGdwbGF5ZXJVdGlscy5BdWRpb1RyYWNrTWV0YSh7XFxuICAgICAgYXVkaW9TYW1wbGVSYXRlOiBwZXMuRVMuZnJlcXVlbmNlLFxcbiAgICAgIHNhbXBsZVJhdGU6IHBlcy5FUy5mcmVxdWVuY2UsXFxuICAgICAgY2hhbm5lbENvdW50OiBwZXMuRVMuY2hhbm5lbCxcXG4gICAgICBjb2RlYzogJ21wNGEuNDAuJyArIHBlcy5FUy5hdWRpb09iamVjdFR5cGUsXFxuICAgICAgY29uZmlnOiBwZXMuRVMuYXVkaW9Db25maWcsXFxuICAgICAgaWQ6IDIsXFxuICAgICAgc2FtcGxlUmF0ZUluZGV4OiBwZXMuRVMuZnJlcXVlbmN5SW5kZXhcXG4gICAgfSk7XFxuICAgIG1ldGEucmVmU2FtcGxlRHVyYXRpb24gPSBNYXRoLmZsb29yKDEwMjQgLyBtZXRhLmF1ZGlvU2FtcGxlUmF0ZSAqIG1ldGEudGltZXNjYWxlKTtcXG5cXG4gICAgbGV0IG1ldGFFcXVhbCA9IFRzRGVtdXhlci5jb21wYWlyZU1ldGEodHJhY2subWV0YSwgbWV0YSwgdHJ1ZSk7XFxuXFxuICAgIGlmICghdGhpcy5faGFzQXVkaW9NZXRhIHx8ICFtZXRhRXF1YWwpIHtcXG4gICAgICB0cmFjay5tZXRhID0gbWV0YTtcXG4gICAgICB0aGlzLl9oYXNBdWRpb01ldGEgPSB0cnVlO1xcbiAgICAgIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuTUVUQURBVEFfUEFSU0VELCAnYXVkaW8nKTtcXG4gICAgfVxcblxcbiAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KHBlcy5FUy5idWZmZXIuYnVmZmVyLnNsaWNlKHBlcy5FUy5idWZmZXIucG9zaXRpb24sIHBlcy5FUy5idWZmZXIubGVuZ3RoKSk7XFxuICAgIGxldCBkdHMgPSBwYXJzZUludChwZXMucHRzIC8gOTApO1xcbiAgICBsZXQgcHRzID0gcGFyc2VJbnQocGVzLnB0cyAvIDkwKTtcXG4gICAgbGV0IHNhbXBsZSA9IG5ldyBfeGdwbGF5ZXJVdGlscy5BdWRpb1RyYWNrU2FtcGxlKHsgZHRzLCBwdHMsIGRhdGEsIG9wdGlvbnMgfSk7XFxuICAgIHRyYWNrLnNhbXBsZXMucHVzaChzYW1wbGUpO1xcbiAgfVxcblxcbiAgcHVzaFZpZGVvU2FtcGxlKHBlcywgb3B0aW9ucykge1xcbiAgICBsZXQgbmFscyA9IF94Z3BsYXllckNvZGVjLk5hbHVuaXQuZ2V0TmFsdW5pdHMocGVzLkVTLmJ1ZmZlcik7XFxuICAgIGxldCB0cmFjaztcXG4gICAgbGV0IG1ldGEgPSBuZXcgX3hncGxheWVyVXRpbHMuVmlkZW9UcmFja01ldGEoKTtcXG4gICAgaWYgKCF0aGlzLl90cmFja3MudmlkZW9UcmFjaykge1xcbiAgICAgIHRoaXMuX3RyYWNrcy52aWRlb1RyYWNrID0gbmV3IF94Z3BsYXllckJ1ZmZlci5WaWRlb1RyYWNrKCk7XFxuICAgICAgdHJhY2sgPSB0aGlzLl90cmFja3MudmlkZW9UcmFjaztcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0cmFjayA9IHRoaXMuX3RyYWNrcy52aWRlb1RyYWNrO1xcbiAgICB9XFxuICAgIGxldCBzYW1wbGVMZW5ndGggPSAwO1xcbiAgICBsZXQgc3BzID0gZmFsc2U7XFxuICAgIGxldCBwcHMgPSBmYWxzZTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYWxzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgbGV0IG5hbCA9IG5hbHNbaV07XFxuICAgICAgaWYgKG5hbC5zcHMpIHtcXG4gICAgICAgIHNwcyA9IG5hbDtcXG4gICAgICAgIHRyYWNrLnNwcyA9IG5hbC5ib2R5O1xcbiAgICAgICAgbWV0YS5jaHJvbWFGb3JtYXQgPSBzcHMuc3BzLmNocm9tYV9mb3JtYXQ7XFxuICAgICAgICBtZXRhLmNvZGVjID0gJ2F2YzEuJztcXG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgNDsgaisrKSB7XFxuICAgICAgICAgIHZhciBoID0gc3BzLmJvZHlbal0udG9TdHJpbmcoMTYpO1xcbiAgICAgICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XFxuICAgICAgICAgICAgaCA9ICcwJyArIGg7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgbWV0YS5jb2RlYyArPSBoO1xcbiAgICAgICAgfVxcbiAgICAgICAgbWV0YS5jb2RlY0hlaWdodCA9IHNwcy5zcHMuY29kZWNfc2l6ZS5oZWlnaHQ7XFxuICAgICAgICBtZXRhLmNvZGVjV2lkdGggPSBzcHMuc3BzLmNvZGVjX3NpemUud2lkdGg7XFxuICAgICAgICBtZXRhLmZyYW1lUmF0ZSA9IHNwcy5zcHMuZnJhbWVfcmF0ZTtcXG4gICAgICAgIG1ldGEuaWQgPSAxO1xcbiAgICAgICAgbWV0YS5sZXZlbCA9IHNwcy5zcHMubGV2ZWxfc3RyaW5nO1xcbiAgICAgICAgbWV0YS5wcmVzZW50SGVpZ2h0ID0gc3BzLnNwcy5wcmVzZW50X3NpemUuaGVpZ2h0O1xcbiAgICAgICAgbWV0YS5wcmVzZW50V2lkdGggPSBzcHMuc3BzLnByZXNlbnRfc2l6ZS53aWR0aDtcXG4gICAgICAgIG1ldGEucHJvZmlsZSA9IHNwcy5zcHMucHJvZmlsZV9zdHJpbmc7XFxuICAgICAgICBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uID0gTWF0aC5mbG9vcihtZXRhLnRpbWVzY2FsZSAqIChzcHMuc3BzLmZyYW1lX3JhdGUuZnBzX2RlbiAvIHNwcy5zcHMuZnJhbWVfcmF0ZS5mcHNfbnVtKSk7XFxuICAgICAgICBtZXRhLnNhclJhdGlvID0gc3BzLnNwcy5zYXJfcmF0aW8gPyBzcHMuc3BzLnNhcl9yYXRpbyA6IHNwcy5zcHMucGFyX3JhdGlvO1xcbiAgICAgIH0gZWxzZSBpZiAobmFsLnBwcykge1xcbiAgICAgICAgdHJhY2sucHBzID0gbmFsLmJvZHk7XFxuICAgICAgICBwcHMgPSBuYWw7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHNhbXBsZUxlbmd0aCArPSA0ICsgbmFsLmJvZHkuYnl0ZUxlbmd0aDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKHNwcyAmJiBwcHMpIHtcXG4gICAgICBtZXRhLmF2Y2MgPSBfeGdwbGF5ZXJDb2RlYy5OYWx1bml0LmdldEF2Y2Moc3BzLmJvZHksIHBwcy5ib2R5KTtcXG4gICAgICBsZXQgbWV0YUVxdWFsID0gVHNEZW11eGVyLmNvbXBhaXJlTWV0YSh0cmFjay5tZXRhLCBtZXRhLCB0cnVlKTtcXG4gICAgICBpZiAoIXRoaXMuX2hhc1ZpZGVvTWV0YSB8fCAhbWV0YUVxdWFsKSB7XFxuICAgICAgICBpZiAob3B0aW9ucykge1xcbiAgICAgICAgICBvcHRpb25zLm1ldGEgPSBPYmplY3QuYXNzaWduKHt9LCBtZXRhKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIG9wdGlvbnMgPSB7XFxuICAgICAgICAgICAgbWV0YTogT2JqZWN0LmFzc2lnbih7fSwgbWV0YSlcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRyYWNrLm1ldGEgPSBtZXRhO1xcbiAgICAgICAgdGhpcy5faGFzVmlkZW9NZXRhID0gdHJ1ZTtcXG4gICAgICAgIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuTUVUQURBVEFfUEFSU0VELCAndmlkZW8nKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheShzYW1wbGVMZW5ndGgpO1xcbiAgICBsZXQgb2Zmc2V0ID0gMDtcXG4gICAgbGV0IGlzS2V5ZnJhbWUgPSBmYWxzZTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYWxzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgbGV0IG5hbCA9IG5hbHNbaV07XFxuICAgICAgbGV0IGxlbmd0aCA9IG5hbC5ib2R5LmJ5dGVMZW5ndGg7XFxuICAgICAgaWYgKG5hbC5pZHIpIHtcXG4gICAgICAgIGlzS2V5ZnJhbWUgPSB0cnVlO1xcbiAgICAgIH1cXG4gICAgICBpZiAoIW5hbC5wcHMgJiYgIW5hbC5zcHMpIHtcXG4gICAgICAgIGRhdGEuc2V0KG5ldyBVaW50OEFycmF5KFtsZW5ndGggPj4+IDI0ICYgMHhmZiwgbGVuZ3RoID4+PiAxNiAmIDB4ZmYsIGxlbmd0aCA+Pj4gOCAmIDB4ZmYsIGxlbmd0aCAmIDB4ZmZdKSwgb2Zmc2V0KTtcXG4gICAgICAgIG9mZnNldCArPSA0O1xcbiAgICAgICAgZGF0YS5zZXQobmFsLmJvZHksIG9mZnNldCk7XFxuICAgICAgICBvZmZzZXQgKz0gbGVuZ3RoO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBsZXQgc2FtcGxlID0gbmV3IF94Z3BsYXllclV0aWxzLlZpZGVvVHJhY2tTYW1wbGUoe1xcbiAgICAgIGR0czogcGFyc2VJbnQocGVzLmR0cyAvIDkwKSxcXG4gICAgICBwdHM6IHBhcnNlSW50KHBlcy5wdHMgLyA5MCksXFxuICAgICAgY3RzOiAocGVzLnB0cyAtIHBlcy5kdHMpIC8gOTAsXFxuICAgICAgb3JpZ2luRHRzOiBwZXMuZHRzLFxcbiAgICAgIGlzS2V5ZnJhbWUsXFxuICAgICAgZGF0YSxcXG4gICAgICBvcHRpb25zXFxuICAgIH0pO1xcbiAgICB0cmFjay5zYW1wbGVzLnB1c2goc2FtcGxlKTtcXG4gIH1cXG5cXG4gIGRlc3RvcnkoKSB7XFxuICAgIHRoaXMub2ZmKERFTVVYX0VWRU5UUy5ERU1VWF9TVEFSVCwgdGhpcy5kZW11eCk7XFxuICAgIHRoaXMuY29uZmlncyA9IHt9O1xcbiAgICB0aGlzLmRlbXV4aW5nID0gZmFsc2U7XFxuICAgIHRoaXMucGF0ID0gW107XFxuICAgIHRoaXMucG10ID0gW107XFxuICAgIHRoaXMuX2hhc1ZpZGVvTWV0YSA9IGZhbHNlO1xcbiAgICB0aGlzLl9oYXNBdWRpb01ldGEgPSBmYWxzZTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBjb21wYWlyZUFycmF5KGEsIGIsIHR5cGUpIHtcXG4gICAgbGV0IGFsID0gMDtcXG4gICAgbGV0IGJsID0gMDtcXG4gICAgaWYgKHR5cGUgPT09ICdVaW50OEFycmF5Jykge1xcbiAgICAgIGFsID0gYS5ieXRlTGVuZ3RoO1xcbiAgICAgIGJsID0gYi5ieXRlTGVuZ3RoO1xcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdBcnJheScpIHtcXG4gICAgICBhbCA9IGEubGVuZ3RoO1xcbiAgICAgIGJsID0gYi5sZW5ndGg7XFxuICAgIH1cXG4gICAgaWYgKGFsICE9PSBibCkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsOyBpKyspIHtcXG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBjb21wYWlyZU1ldGEoYSwgYiwgaWdub3JlRHVyYXRpb24pIHtcXG4gICAgaWYgKCFhIHx8ICFiKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIGZvciAobGV0IGkgPSAwLCBrID0gT2JqZWN0LmtleXMoYSkubGVuZ3RoOyBpIDwgazsgaSsrKSB7XFxuICAgICAgbGV0IGl0ZW1hID0gYVtPYmplY3Qua2V5cyhhKVtpXV07XFxuICAgICAgbGV0IGl0ZW1iID0gYltPYmplY3Qua2V5cyhhKVtpXV07XFxuICAgICAgaWYgKHR5cGVvZiBpdGVtYSAhPT0gJ29iamVjdCcpIHtcXG4gICAgICAgIGlmIChpZ25vcmVEdXJhdGlvbiAmJiBPYmplY3Qua2V5cyhhKVtpXSAhPT0gJ2R1cmF0aW9uJyAmJiBPYmplY3Qua2V5cyhhKVtpXSAhPT0gJ3JlZlNhbXBsZUR1cmF0aW9uJyAmJiBPYmplY3Qua2V5cyhhKVtpXSAhPT0gJ3JlZlNhbXBsZUR1cmF0aW9uRml4ZWQnICYmIGl0ZW1hICE9PSBpdGVtYikge1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmIChpdGVtYS5ieXRlTGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIGlmIChpdGVtYi5ieXRlTGVuZ3RoID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFUc0RlbXV4ZXIuY29tcGFpcmVBcnJheShpdGVtYSwgaXRlbWIsICdVaW50OEFycmF5JykpIHtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAoaXRlbWEubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIGlmIChpdGVtYi5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIVRzRGVtdXhlci5jb21wYWlyZUFycmF5KGl0ZW1hLCBpdGVtYiwgJ0FycmF5JykpIHtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoIVRzRGVtdXhlci5jb21wYWlyZU1ldGEoaXRlbWEsIGl0ZW1iKSkge1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcblxcbiAgc3RhdGljIE1lcmdlKGJ1ZmZlcnMpIHtcXG4gICAgbGV0IGRhdGE7XFxuICAgIGxldCBsZW5ndGggPSAwO1xcbiAgICBsZXQgb2Zmc2V0ID0gMDtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgbGVuZ3RoICs9IGJ1ZmZlcnNbaV0ubGVuZ3RoIC0gYnVmZmVyc1tpXS5wb3NpdGlvbjtcXG4gICAgfVxcblxcbiAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgbGV0IGJ1ZmZlciA9IGJ1ZmZlcnNbaV07XFxuICAgICAgZGF0YS5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmJ1ZmZlciwgYnVmZmVyLnBvc2l0aW9uKSwgb2Zmc2V0KTtcXG4gICAgICBvZmZzZXQgKz0gYnVmZmVyLmxlbmd0aCAtIGJ1ZmZlci5wb3NpdGlvbjtcXG4gICAgfVxcbiAgICByZXR1cm4gbmV3IF94Z3BsYXllclV0aWxzLlN0cmVhbShkYXRhLmJ1ZmZlcik7XFxuICB9XFxuXFxuICBzdGF0aWMgcmVhZChzdHJlYW0sIHRzLCBmcmFncykge1xcbiAgICBUc0RlbXV4ZXIucmVhZEhlYWRlcihzdHJlYW0sIHRzKTtcXG4gICAgVHNEZW11eGVyLnJlYWRQYXlsb2FkKHN0cmVhbSwgdHMsIGZyYWdzKTtcXG4gICAgaWYgKHRzLmhlYWRlci5wYWNrZXQgPT09ICdNRURJQScgJiYgdHMuaGVhZGVyLnBheWxvYWQgPT09IDEgJiYgIXRzLnVua25vd25QSURzKSB7XFxuICAgICAgdHMucGVzID0gVHNEZW11eGVyLlBFUyh0cyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHN0YXRpYyByZWFkUGF5bG9hZChzdHJlYW0sIHRzLCBmcmFncykge1xcbiAgICBsZXQgaGVhZGVyID0gdHMuaGVhZGVyO1xcbiAgICBsZXQgcGlkID0gaGVhZGVyLnBpZDtcXG4gICAgc3dpdGNoIChwaWQpIHtcXG4gICAgICBjYXNlIDA6XFxuICAgICAgICBUc0RlbXV4ZXIuUEFUKHN0cmVhbSwgdHMsIGZyYWdzKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgMTpcXG4gICAgICAgIFRzRGVtdXhlci5DQVQoc3RyZWFtLCB0cywgZnJhZ3MpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAyOlxcbiAgICAgICAgVHNEZW11eGVyLlRTRFQoc3RyZWFtLCB0cywgZnJhZ3MpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAweDFmZmY6XFxuICAgICAgICBicmVhaztcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgLy8gVE9ETzogc29tZeeahOWGmeazleS4jeWkquWlve+8jOW+l+aUuVxcbiAgICAgICAgaWYgKGZyYWdzLnBhdC5zb21lKGl0ZW0gPT4ge1xcbiAgICAgICAgICByZXR1cm4gaXRlbS5waWQgPT09IHBpZDtcXG4gICAgICAgIH0pKSB7XFxuICAgICAgICAgIFRzRGVtdXhlci5QTVQoc3RyZWFtLCB0cywgZnJhZ3MpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgbGV0IHN0cyA9IGZyYWdzLnBtdCA/IGZyYWdzLnBtdC5maWx0ZXIoaXRlbSA9PiBpdGVtLnBpZCA9PT0gcGlkKSA6IFtdO1xcbiAgICAgICAgICBpZiAoc3RzLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICBUc0RlbXV4ZXIuTWVkaWEoc3RyZWFtLCB0cywgU3RyZWFtVHlwZVtzdHNbMF0uc3RyZWFtVHlwZV1bMF0pO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRzLnVua25vd25QSURzID0gdHJ1ZTtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgc3RhdGljIHJlYWRIZWFkZXIoc3RyZWFtLCB0cykge1xcbiAgICBsZXQgaGVhZGVyID0ge307XFxuICAgIGhlYWRlci5zeW5jID0gc3RyZWFtLnJlYWRVaW50OCgpO1xcbiAgICBsZXQgbmV4dCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XFxuICAgIGhlYWRlci5lcnJvciA9IG5leHQgPj4+IDE1O1xcbiAgICBoZWFkZXIucGF5bG9hZCA9IG5leHQgPj4+IDE0ICYgMTtcXG4gICAgaGVhZGVyLnByaW9yaXR5ID0gbmV4dCA+Pj4gMTMgJiAxO1xcbiAgICBoZWFkZXIucGlkID0gbmV4dCAmIDB4MWZmZjtcXG5cXG4gICAgbmV4dCA9IHN0cmVhbS5yZWFkVWludDgoKTtcXG5cXG4gICAgaGVhZGVyLnNjcmFtYmxpbmcgPSBuZXh0ID4+IDYgJiAweDM7IC8vIOaYr+WQpuWKoOWvhu+8jDAw6KGo56S65LiN5Yqg5a+GXFxuXFxuICAgIC8qKlxcbiAgICAgKiAwMCBJU08vSUVD5pyq5p2l5L2/55So5L+d55WZXFxuICAgICAqIDAxIOayoeacieiwg+aVtOWtl+aute+8jOS7heWQq+aciTE4NELmnInmlYjlh4DojbdcXG4gICAgICogMDIg5rKh5pyJ5pyJ5pWI5YeA6I2377yM5LuF5ZCr5pyJMTgzQuiwg+aVtOWtl+autVxcbiAgICAgKiAwMyAwfjE4MkLosIPmlbTlrZfmrrXlkI7kuLrmnInmlYjlh4DojbdcXG4gICAgICovXFxuICAgIGhlYWRlci5hZGFwdGF0aW9uID0gbmV4dCA+PiA0ICYgMHgzO1xcbiAgICBoZWFkZXIuY29udGludWl0eSA9IG5leHQgJiAxNTtcXG4gICAgaGVhZGVyLnBhY2tldCA9IGhlYWRlci5waWQgPT09IDAgPyAnUEFUJyA6ICdNRURJQSc7XFxuICAgIHRzLmhlYWRlciA9IGhlYWRlcjtcXG4gIH1cXG5cXG4gIHN0YXRpYyBQQVQoc3RyZWFtLCB0cywgZnJhZ3MpIHtcXG4gICAgbGV0IHJldCA9IHt9O1xcbiAgICBsZXQgbmV4dCA9IHN0cmVhbS5yZWFkVWludDgoKTtcXG4gICAgc3RyZWFtLnNraXAobmV4dCk7XFxuICAgIG5leHQgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XFxuICAgIHJldC50YWJlbElEID0gbmV4dDtcXG4gICAgbmV4dCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XFxuICAgIHJldC5lcnJvciA9IG5leHQgPj4+IDc7XFxuICAgIHJldC56ZXJvID0gbmV4dCA+Pj4gNiAmIDE7XFxuICAgIHJldC5zZWN0aW9uTGVuZ3RoID0gbmV4dCAmIDB4ZmZmO1xcbiAgICByZXQuc3RyZWFtSUQgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xcbiAgICByZXQuY3VycmVudCA9IHN0cmVhbS5yZWFkVWludDgoKSAmIDE7XFxuICAgIHJldC5zZWN0aW9uTnVtYmVyID0gc3RyZWFtLnJlYWRVaW50OCgpO1xcbiAgICByZXQubGFzdFNlY3Rpb25OdW1iZXIgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XFxuICAgIGxldCBOID0gKHJldC5zZWN0aW9uTGVuZ3RoIC0gOSkgLyA0O1xcbiAgICBsZXQgbGlzdCA9IFtdO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykge1xcbiAgICAgIGxldCBwcm9ncmFtTnVtYmVyID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcXG4gICAgICBsZXQgcGlkID0gc3RyZWFtLnJlYWRVaW50MTYoKSAmIDB4MWZmZjtcXG4gICAgICBsaXN0LnB1c2goe1xcbiAgICAgICAgcHJvZ3JhbTogcHJvZ3JhbU51bWJlcixcXG4gICAgICAgIHBpZCxcXG4gICAgICAgIHR5cGU6IHByb2dyYW1OdW1iZXIgPT09IDAgPyAnbmV0d29yaycgOiAnbWFwUElEJ1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIGlmIChsaXN0Lmxlbmd0aCA+IDApIHtcXG4gICAgICBmcmFncy5wYXQgPSBmcmFncy5wYXQuY29uY2F0KGxpc3QpO1xcbiAgICB9XFxuICAgIHJldC5saXN0ID0gbGlzdDtcXG4gICAgcmV0LnByb2dyYW0gPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xcbiAgICByZXQucGlkID0gc3RyZWFtLnJlYWRVaW50MTYoKSAmIDB4MWZmZjtcXG4gICAgdHMucGF5bG9hZCA9IHJldDtcXG4gICAgLy8gVE9ETyBDUkNcXG4gIH1cXG5cXG4gIHN0YXRpYyBQTVQoc3RyZWFtLCB0cywgZnJhZ3MpIHtcXG4gICAgbGV0IHJldCA9IHt9O1xcbiAgICBsZXQgaGVhZGVyID0gdHMuaGVhZGVyO1xcbiAgICBoZWFkZXIucGFja2V0ID0gJ1BNVCc7XFxuICAgIGxldCBuZXh0ID0gc3RyZWFtLnJlYWRVaW50OCgpO1xcbiAgICBzdHJlYW0uc2tpcChuZXh0KTtcXG4gICAgbmV4dCA9IHN0cmVhbS5yZWFkVWludDgoKTtcXG4gICAgcmV0LnRhYmxlSUQgPSBuZXh0O1xcbiAgICBuZXh0ID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcXG4gICAgcmV0LnNlY3Rpb25MZW5ndGggPSBuZXh0ICYgMHhmZmY7XFxuICAgIHJldC5wcm9ncmFtID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcXG4gICAgcmV0LmN1cnJlbnQgPSBzdHJlYW0ucmVhZFVpbnQ4KCkgJiAxO1xcbiAgICByZXQub3JkZXIgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XFxuICAgIHJldC5sYXN0T3JkZXIgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XFxuICAgIHJldC5QQ1JfUElEID0gc3RyZWFtLnJlYWRVaW50MTYoKSAmIDB4MWZmZjtcXG4gICAgcmV0LnByb2dyYW1MZW5ndGggPSBzdHJlYW0ucmVhZFVpbnQxNigpICYgMHhmZmY7XFxuICAgIGxldCBOID0gKHJldC5zZWN0aW9uTGVuZ3RoIC0gMTMpIC8gNTtcXG4gICAgbGV0IGxpc3QgPSBbXTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpKyspIHtcXG4gICAgICBsaXN0LnB1c2goe1xcbiAgICAgICAgc3RyZWFtVHlwZTogc3RyZWFtLnJlYWRVaW50OCgpLFxcbiAgICAgICAgcGlkOiBzdHJlYW0ucmVhZFVpbnQxNigpICYgMHgxZmZmLCAvLyAweDA3ZTUg6KeG6aKR77yMMHgwN2U2XFxuICAgICAgICBlczogc3RyZWFtLnJlYWRVaW50MTYoKSAmIDB4ZmZmXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgcmV0Lmxpc3QgPSBsaXN0O1xcbiAgICBpZiAoIXRoaXMucG10KSB7XFxuICAgICAgdGhpcy5wbXQgPSBbXTtcXG4gICAgfVxcbiAgICBmcmFncy5wbXQgPSB0aGlzLnBtdC5jb25jYXQobGlzdC5tYXAoaXRlbSA9PiB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIHBpZDogaXRlbS5waWQsXFxuICAgICAgICBlczogaXRlbS5lcyxcXG4gICAgICAgIHN0cmVhbVR5cGU6IGl0ZW0uc3RyZWFtVHlwZSxcXG4gICAgICAgIHByb2dyYW06IHJldC5wcm9ncmFtXFxuICAgICAgfTtcXG4gICAgfSkpO1xcbiAgICB0cy5wYXlsb2FkID0gcmV0O1xcbiAgfVxcblxcbiAgc3RhdGljIE1lZGlhKHN0cmVhbSwgdHMsIHR5cGUpIHtcXG4gICAgbGV0IGhlYWRlciA9IHRzLmhlYWRlcjtcXG4gICAgbGV0IHBheWxvYWQgPSB7fTtcXG4gICAgaGVhZGVyLnR5cGUgPSB0eXBlO1xcbiAgICBpZiAoaGVhZGVyLmFkYXB0YXRpb24gPT09IDB4MDMpIHtcXG4gICAgICBwYXlsb2FkLmFkYXB0YXRpb25MZW5ndGggPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XFxuICAgICAgaWYgKHBheWxvYWQuYWRhcHRhdGlvbkxlbmd0aCA+IDApIHtcXG4gICAgICAgIGxldCBuZXh0ID0gc3RyZWFtLnJlYWRVaW50OCgpO1xcbiAgICAgICAgcGF5bG9hZC5kaXNjb250aW51ZSA9IG5leHQgPj4+IDc7XFxuICAgICAgICBwYXlsb2FkLmFjY2VzcyA9IG5leHQgPj4+IDYgJiAweDAxO1xcbiAgICAgICAgcGF5bG9hZC5wcmlvcml0eSA9IG5leHQgPj4+IDUgJiAweDAxO1xcbiAgICAgICAgcGF5bG9hZC5QQ1IgPSBuZXh0ID4+PiA0ICYgMHgwMTtcXG4gICAgICAgIHBheWxvYWQuT1BDUiA9IG5leHQgPj4+IDMgJiAweDAxO1xcbiAgICAgICAgcGF5bG9hZC5zcGxpY2VQb2ludCA9IG5leHQgPj4+IDIgJiAweDAxO1xcbiAgICAgICAgcGF5bG9hZC50cmFuc3BvcnRQcml2YXRlID0gbmV4dCA+Pj4gMSAmIDB4MDE7XFxuICAgICAgICBwYXlsb2FkLmFkYXB0YXRpb25GaWVsZCA9IG5leHQgJiAweDAxO1xcbiAgICAgICAgbGV0IF9zdGFydCA9IHN0cmVhbS5wb3NpdGlvbjtcXG4gICAgICAgIGlmIChwYXlsb2FkLlBDUiA9PT0gMSkge1xcbiAgICAgICAgICBwYXlsb2FkLnByb2dyYW1DbG9ja0Jhc2UgPSBzdHJlYW0ucmVhZFVpbnQzMigpIDw8IDE7XFxuICAgICAgICAgIG5leHQgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xcbiAgICAgICAgICBwYXlsb2FkLnByb2dyYW1DbG9ja0Jhc2UgfD0gbmV4dCA+Pj4gMTU7XFxuICAgICAgICAgIHBheWxvYWQucHJvZ3JhbUNsb2NrRXh0ZW5zaW9uID0gbmV4dCAmIDB4MWZmO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHBheWxvYWQuT1BDUiA9PT0gMSkge1xcbiAgICAgICAgICBwYXlsb2FkLm9yaWdpblByb2dyYW1DbG9ja0Jhc2UgPSBzdHJlYW0ucmVhZFVpbnQzMigpIDw8IDE7XFxuICAgICAgICAgIG5leHQgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xcbiAgICAgICAgICBwYXlsb2FkLm9yaWdpblByb2dyYW1DbG9ja0Jhc2UgKz0gbmV4dCA+Pj4gMTU7XFxuICAgICAgICAgIHBheWxvYWQub3JpZ2luUHJvZ3JhbUNsb2NrRXh0ZW5zaW9uID0gbmV4dCAmIDB4MWZmO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHBheWxvYWQuc3BsaWNlUG9pbnQgPT09IDEpIHtcXG4gICAgICAgICAgcGF5bG9hZC5zcGxpY2VDb3VudGRvd24gPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAocGF5bG9hZC50cmFuc3BvcnRQcml2YXRlID09PSAxKSB7XFxuICAgICAgICAgIGxldCBsZW5ndGggPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XFxuICAgICAgICAgIGxldCB0cmFuc3BvcnRQcml2YXRlRGF0YSA9IFtdO1xcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgdHJhbnNwb3J0UHJpdmF0ZURhdGEucHVzaChzdHJlYW0ucmVhZFVpbnQ4KCkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBpZiAocGF5bG9hZC5hZGFwdGF0aW9uRmllbGQgPT09IDEpIHtcXG4gICAgICAgICAgbGV0IGxlbmd0aCA9IHN0cmVhbS5yZWFkVWludDgoKTtcXG4gICAgICAgICAgbGV0IG5leHQgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XFxuICAgICAgICAgIGxldCBzdGFydCA9IHN0cmVhbS5wb3NpdGlvbjtcXG4gICAgICAgICAgbGV0IGx0dyA9IG5leHQgPj4+IDc7XFxuICAgICAgICAgIGxldCBwaWVjZXdpc2UgPSBuZXh0ID4+PiA2ICYgMHgxO1xcbiAgICAgICAgICBsZXQgc2VhbWxlc3MgPSBuZXh0ID4+PiA1ICYgMHgxO1xcbiAgICAgICAgICBpZiAobHR3ID09PSAxKSB7XFxuICAgICAgICAgICAgbmV4dCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XFxuICAgICAgICAgICAgcGF5bG9hZC5sdHdWYWxpZCA9IG5leHQgPj4+IDE1O1xcbiAgICAgICAgICAgIHBheWxvYWQubHR3T2Zmc2V0ID0gbmV4dCAmIDB4ZWZmZjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAocGllY2V3aXNlID09PSAxKSB7XFxuICAgICAgICAgICAgbmV4dCA9IHN0cmVhbS5yZWFkVWludDI0KCk7XFxuICAgICAgICAgICAgcGF5bG9hZC5waWVjZXdpc2VSYXRlID0gbmV4dCAmIDB4M2ZmZmZmO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChzZWFtbGVzcyA9PT0gMSkge1xcbiAgICAgICAgICAgIG5leHQgPSBzdHJlYW0ucmVhZEludDgoKTtcXG4gICAgICAgICAgICBwYXlsb2FkLnNwbGljZVR5cGUgPSBuZXh0ID4+PiA0O1xcbiAgICAgICAgICAgIHBheWxvYWQuZHRzTmV4dEFVMSA9IG5leHQgPj4+IDEgJiAweDc7XFxuICAgICAgICAgICAgcGF5bG9hZC5tYXJrZXIxID0gbmV4dCAmIDB4MTtcXG4gICAgICAgICAgICBuZXh0ID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcXG4gICAgICAgICAgICBwYXlsb2FkLmR0c05leHRBVTIgPSBuZXh0ID4+PiAxO1xcbiAgICAgICAgICAgIHBheWxvYWQubWFya2VyMiA9IG5leHQgJiAweDE7XFxuICAgICAgICAgICAgbmV4dCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XFxuICAgICAgICAgICAgcGF5bG9hZC5kdHNOZXh0QVUzID0gbmV4dDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzdHJlYW0uc2tpcChsZW5ndGggLSAxIC0gKHN0cmVhbS5wb3NpdGlvbiAtIHN0YXJ0KSk7XFxuICAgICAgICB9XFxuICAgICAgICBsZXQgbGFzdFN0dWZmaW5nID0gcGF5bG9hZC5hZGFwdGF0aW9uTGVuZ3RoIC0gMSAtIChzdHJlYW0ucG9zaXRpb24gLSBfc3RhcnQpO1xcbiAgICAgICAgc3RyZWFtLnNraXAobGFzdFN0dWZmaW5nKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcGF5bG9hZC5zdHJlYW0gPSBuZXcgX3hncGxheWVyVXRpbHMuU3RyZWFtKHN0cmVhbS5idWZmZXIuc2xpY2Uoc3RyZWFtLnBvc2l0aW9uKSk7XFxuICAgIHRzLnBheWxvYWQgPSBwYXlsb2FkO1xcbiAgfVxcblxcbiAgc3RhdGljIFBFUyh0cykge1xcbiAgICBsZXQgcmV0ID0ge307XFxuICAgIGxldCBidWZmZXIgPSB0cy5wYXlsb2FkLnN0cmVhbTtcXG5cXG4gICAgbGV0IG5leHQgPSBidWZmZXIucmVhZFVpbnQyNCgpO1xcbiAgICBpZiAobmV4dCAhPT0gMSkge1xcbiAgICAgIHJldC5FUyA9IHt9O1xcbiAgICAgIHJldC5FUy5idWZmZXIgPSBidWZmZXI7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbGV0IHN0cmVhbUlEID0gYnVmZmVyLnJlYWRVaW50OCgpO1xcbiAgICAgIGlmIChzdHJlYW1JRCA+PSAweGUwICYmIHN0cmVhbUlEIDw9IDB4ZWYpIHtcXG4gICAgICAgIHJldC50eXBlID0gJ3ZpZGVvJztcXG4gICAgICB9XFxuICAgICAgaWYgKHN0cmVhbUlEID49IDB4YzAgJiYgc3RyZWFtSUQgPD0gMHhkZikge1xcbiAgICAgICAgcmV0LnR5cGUgPSAnYXVkaW8nO1xcbiAgICAgIH1cXG4gICAgICBsZXQgcGFja2V0TGVuZ3RoID0gYnVmZmVyLnJlYWRVaW50MTYoKTtcXG4gICAgICByZXQucGFja2V0TGVuZ3RoID0gcGFja2V0TGVuZ3RoO1xcbiAgICAgIGlmIChyZXQudHlwZSA9PT0gJ3ZpZGVvJyB8fCByZXQudHlwZSA9PT0gJ2F1ZGlvJykge1xcbiAgICAgICAgbGV0IG5leHQgPSBidWZmZXIucmVhZFVpbnQ4KCk7XFxuICAgICAgICBsZXQgZmlyc3QgPSBuZXh0ID4+PiA2O1xcbiAgICAgICAgaWYgKGZpcnN0ICE9PSAweDAyKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXJyb3Igd2hlbiBwYXJzZSBwZXMgaGVhZGVyJyk7XFxuICAgICAgICB9XFxuICAgICAgICBuZXh0ID0gYnVmZmVyLnJlYWRVaW50OCgpO1xcbiAgICAgICAgcmV0LnB0c0RUU0ZsYWcgPSBuZXh0ID4+PiA2O1xcbiAgICAgICAgcmV0LmVzY3JGbGFnID0gbmV4dCA+Pj4gNSAmIDB4MDE7XFxuICAgICAgICByZXQuZXNSYXRlRmxhZyA9IG5leHQgPj4+IDQgJiAweDAxO1xcbiAgICAgICAgcmV0LmRzbUZsYWcgPSBuZXh0ID4+PiAzICYgMHgwMTtcXG4gICAgICAgIHJldC5hZGRpdGlvbmFsRmxhZyA9IG5leHQgPj4+IDIgJiAweDAxO1xcbiAgICAgICAgcmV0LmNyY0ZsYWcgPSBuZXh0ID4+PiAxICYgMHgwMTtcXG4gICAgICAgIHJldC5leHRlbnNpb25GbGFnID0gbmV4dCAmIDB4MDE7XFxuICAgICAgICByZXQucGVzSGVhZGVyTGVuZ3RoID0gYnVmZmVyLnJlYWRVaW50OCgpO1xcbiAgICAgICAgbGV0IE4xID0gcmV0LnBlc0hlYWRlckxlbmd0aDtcXG5cXG4gICAgICAgIGlmIChyZXQucHRzRFRTRmxhZyA9PT0gMikge1xcbiAgICAgICAgICBsZXQgcHRzID0gW107XFxuICAgICAgICAgIG5leHQgPSBidWZmZXIucmVhZFVpbnQ4KCk7XFxuICAgICAgICAgIHB0cy5wdXNoKG5leHQgPj4+IDEgJiAweDA3KTtcXG4gICAgICAgICAgbmV4dCA9IGJ1ZmZlci5yZWFkVWludDE2KCk7XFxuICAgICAgICAgIHB0cy5wdXNoKG5leHQgPj4+IDEpO1xcbiAgICAgICAgICBuZXh0ID0gYnVmZmVyLnJlYWRVaW50MTYoKTtcXG4gICAgICAgICAgcHRzLnB1c2gobmV4dCA+Pj4gMSk7XFxuICAgICAgICAgIHJldC5wdHMgPSBwdHNbMF0gPDwgMzAgfCBwdHNbMV0gPDwgMTUgfCBwdHNbMl07XFxuICAgICAgICAgIE4xIC09IDU7XFxuICAgICAgICAgIC8vIOinhumikeWmguaenOayoeaciWR0c+eUqHB0c1xcbiAgICAgICAgICBpZiAocmV0LnR5cGUgPT09ICd2aWRlbycpIHtcXG4gICAgICAgICAgICByZXQuZHRzID0gcmV0LnB0cztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHJldC5wdHNEVFNGbGFnID09PSAzKSB7XFxuICAgICAgICAgIGxldCBwdHMgPSBbXTtcXG4gICAgICAgICAgbmV4dCA9IGJ1ZmZlci5yZWFkVWludDgoKTtcXG4gICAgICAgICAgcHRzLnB1c2gobmV4dCA+Pj4gMSAmIDB4MDcpO1xcbiAgICAgICAgICBuZXh0ID0gYnVmZmVyLnJlYWRVaW50MTYoKTtcXG4gICAgICAgICAgcHRzLnB1c2gobmV4dCA+Pj4gMSk7XFxuICAgICAgICAgIG5leHQgPSBidWZmZXIucmVhZFVpbnQxNigpO1xcbiAgICAgICAgICBwdHMucHVzaChuZXh0ID4+PiAxKTtcXG4gICAgICAgICAgcmV0LnB0cyA9IHB0c1swXSA8PCAzMCB8IHB0c1sxXSA8PCAxNSB8IHB0c1syXTtcXG4gICAgICAgICAgbGV0IGR0cyA9IFtdO1xcbiAgICAgICAgICBuZXh0ID0gYnVmZmVyLnJlYWRVaW50OCgpO1xcbiAgICAgICAgICBkdHMucHVzaChuZXh0ID4+PiAxICYgMHgwNyk7XFxuICAgICAgICAgIG5leHQgPSBidWZmZXIucmVhZFVpbnQxNigpO1xcbiAgICAgICAgICBkdHMucHVzaChuZXh0ID4+PiAxKTtcXG4gICAgICAgICAgbmV4dCA9IGJ1ZmZlci5yZWFkVWludDE2KCk7XFxuICAgICAgICAgIGR0cy5wdXNoKG5leHQgPj4+IDEpO1xcbiAgICAgICAgICByZXQuZHRzID0gZHRzWzBdIDw8IDMwIHwgZHRzWzFdIDw8IDE1IHwgZHRzWzJdO1xcbiAgICAgICAgICBOMSAtPSAxMDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChyZXQuZXNjckZsYWcgPT09IDEpIHtcXG4gICAgICAgICAgbGV0IGVzY3IgPSBbXTtcXG4gICAgICAgICAgbGV0IGV4ID0gW107XFxuICAgICAgICAgIG5leHQgPSBidWZmZXIucmVhZFVpbnQ4KCk7XFxuICAgICAgICAgIGVzY3IucHVzaChuZXh0ID4+PiAzICYgMHgwNyk7XFxuICAgICAgICAgIGVzY3IucHVzaChuZXh0ICYgMHgwMyk7XFxuICAgICAgICAgIG5leHQgPSBidWZmZXIucmVhZFVpbnQxNigpO1xcbiAgICAgICAgICBlc2NyLnB1c2gobmV4dCA+Pj4gMTMpO1xcbiAgICAgICAgICBlc2NyLnB1c2gobmV4dCAmIDB4MDMpO1xcbiAgICAgICAgICBuZXh0ID0gYnVmZmVyLnJlYWRVaW50MTYoKTtcXG4gICAgICAgICAgZXNjci5wdXNoKG5leHQgPj4+IDEzKTtcXG4gICAgICAgICAgZXgucHVzaChuZXh0ICYgMHgwMyk7XFxuICAgICAgICAgIG5leHQgPSBidWZmZXIucmVhZFVpbnQ4KCk7XFxuICAgICAgICAgIGV4LnB1c2gobmV4dCA+Pj4gMSk7XFxuICAgICAgICAgIHJldC5lc2NyID0gKGVzY3JbMF0gPDwgMzAgfCBlc2NyWzFdIDw8IDI4IHwgZXNjclsyXSA8PCAxNSB8IGVzY3JbM10gPDwgMTMgfCBlc2NyWzRdKSAqIDMwMCArIChleFswXSA8PCA3IHwgZXhbMV0pO1xcbiAgICAgICAgICBOMSAtPSA2O1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHJldC5lc1JhdGVGbGFnID09PSAxKSB7XFxuICAgICAgICAgIG5leHQgPSBidWZmZXIucmVhZFVpbnQyNCgpO1xcbiAgICAgICAgICByZXQuZXNSYXRlID0gbmV4dCA+Pj4gMSAmIDB4M2ZmZmZmO1xcbiAgICAgICAgICBOMSAtPSAzO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHJldC5kc21GbGFnID09PSAxKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IHN1cHBvcnQgRFNNX3RyaWNrX21vZGUnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChyZXQuYWRkaXRpb25hbEZsYWcgPT09IDEpIHtcXG4gICAgICAgICAgbmV4dCA9IGJ1ZmZlci5yZWFkVWludDgoKTtcXG4gICAgICAgICAgcmV0LmFkZGl0aW9uYWxDb3B5SW5mbyA9IG5leHQgJiAweDdmO1xcbiAgICAgICAgICBOMSAtPSAxO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHJldC5jcmNGbGFnID09PSAxKSB7XFxuICAgICAgICAgIHJldC5wZXNDUkMgPSBidWZmZXIucmVhZFVpbnQxNigpO1xcbiAgICAgICAgICBOMSAtPSAyO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHJldC5leHRlbnNpb25GbGFnID09PSAxKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IHN1cHBvcnQgZXh0ZW5zaW9uJyk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoTjEgPiAwKSB7XFxuICAgICAgICAgIGJ1ZmZlci5za2lwKE4xKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldC5FUyA9IFRzRGVtdXhlci5FUyhidWZmZXIsIHJldC50eXBlKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmb3JtYXQgaXMgbm90IHN1cHBvcnRlZCcpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gcmV0O1xcbiAgfVxcblxcbiAgc3RhdGljIEVTKGJ1ZmZlciwgdHlwZSkge1xcbiAgICBsZXQgbmV4dDtcXG4gICAgbGV0IHJldCA9IHt9O1xcbiAgICBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xcbiAgICAgIG5leHQgPSBidWZmZXIucmVhZFVpbnQzMigpO1xcbiAgICAgIGlmIChuZXh0ICE9PSAxKSB7XFxuICAgICAgICBidWZmZXIuYmFjayg0KTtcXG4gICAgICAgIG5leHQgPSBidWZmZXIucmVhZFVpbnQyNCgpO1xcbiAgICAgICAgaWYgKG5leHQgIT09IDEpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoMjY0IG5hbCBoZWFkZXIgcGFyc2UgZmFpbGVkJyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGJ1ZmZlci5za2lwKDIpOyAvLyAwOSBGMFxcbiAgICAgIC8vIFRPRE8gcmVhZG5hbHVcXG4gICAgICByZXQuYnVmZmVyID0gYnVmZmVyO1xcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdhdWRpbycpIHtcXG4gICAgICBuZXh0ID0gYnVmZmVyLnJlYWRVaW50MTYoKTtcXG4gICAgICAvLyBhZHRz55qE5ZCM5q2l5a2X6IqC77yMMTLkvY1cXG4gICAgICBpZiAobmV4dCA+Pj4gNCAhPT0gMHhmZmYpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWFjIEVTIHBhcnNlIEVycm9yJyk7XFxuICAgICAgfVxcbiAgICAgIGNvbnN0IGZxID0gWzk2MDAwLCA4ODIwMCwgNjQwMDAsIDQ4MDAwLCA0NDEwMCwgMzIwMDAsIDI0MDAwLCAyMjA1MCwgMTYwMDAsIDEyMDAwLCAxMTAyNSwgODAwMCwgNzM1MF07XFxuICAgICAgcmV0LmlkID0gKG5leHQgPj4+IDMgJiAweDAxKSA9PT0gMCA/ICdNUEVHLTQnIDogJ01QRUctMic7XFxuICAgICAgcmV0LmxheWVyID0gbmV4dCA+Pj4gMSAmIDB4MDM7XFxuICAgICAgcmV0LmFic2VudCA9IG5leHQgJiAweDAxO1xcbiAgICAgIG5leHQgPSBidWZmZXIucmVhZFVpbnQxNigpO1xcbiAgICAgIHJldC5hdWRpb09iamVjdFR5cGUgPSAobmV4dCA+Pj4gMTQgJiAweDAzKSArIDE7XFxuICAgICAgcmV0LnByb2ZpbGUgPSByZXQuYXVkaW9PYmplY3RUeXBlIC0gMTtcXG4gICAgICByZXQuZnJlcXVlbmN5SW5kZXggPSBuZXh0ID4+PiAxMCAmIDB4MGY7XFxuICAgICAgcmV0LmZyZXF1ZW5jZSA9IGZxW3JldC5mcmVxdWVuY3lJbmRleF07XFxuICAgICAgcmV0LmNoYW5uZWwgPSBuZXh0ID4+PiA2ICYgMHgwNztcXG4gICAgICByZXQuZnJhbWVMZW5ndGggPSAobmV4dCAmIDB4MDMpIDw8IDExIHwgYnVmZmVyLnJlYWRVaW50MTYoKSA+Pj4gNTtcXG4gICAgICBUc0RlbXV4ZXIuZ2V0QXVkaW9Db25maWcocmV0KTtcXG4gICAgICBidWZmZXIuc2tpcCgxKTtcXG4gICAgICByZXQuYnVmZmVyID0gYnVmZmVyO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRVMgJHt0eXBlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHJldDtcXG4gIH1cXG5cXG4gIHN0YXRpYyBUU0RUKHN0cmVhbSwgdHMsIGZyYWdzKSB7XFxuICAgIC8vIFRPRE9cXG4gICAgdHMucGF5bG9hZCA9IHt9O1xcbiAgfVxcblxcbiAgc3RhdGljIENBVChzdHJlYW0sIHRzLCBmcmFncykge1xcbiAgICBsZXQgcmV0ID0ge307XFxuICAgIHJldC50YWJsZUlEID0gc3RyZWFtLnJlYWRVaW50OCgpO1xcbiAgICBsZXQgbmV4dCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XFxuICAgIHJldC5zZWN0aW9uSW5kaWNhdG9yID0gbmV4dCA+Pj4gNztcXG4gICAgcmV0LnNlY3Rpb25MZW5ndGggPSBuZXh0ICYgMHgwZmZmO1xcbiAgICBzdHJlYW0uc2tpcCgyKTtcXG4gICAgbmV4dCA9IHN0cmVhbS5yZWFkVWludDgoKTtcXG4gICAgcmV0LnZlcnNpb24gPSBuZXh0ID4+PiAzO1xcbiAgICByZXQuY3VycmVudE5leHRJbmRpY2F0b3IgPSBuZXh0ICYgMHgwMTtcXG4gICAgcmV0LnNlY3Rpb25OdW1iZXIgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XFxuICAgIHJldC5sYXN0U2VjdGlvbk51bWJlciA9IHN0cmVhbS5yZWFkVWludDgoKTtcXG4gICAgbGV0IE4gPSAodGhpcy5zZWN0aW9uTGVuZ3RoIC0gOSkgLyA0O1xcbiAgICBsZXQgbGlzdCA9IFtdO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykge1xcbiAgICAgIGxpc3QucHVzaCh7fSk7XFxuICAgIH1cXG4gICAgcmV0LmNyYzMyID0gc3RyZWFtLnJlYWRVaW50MzIoKTtcXG4gICAgdHMucGF5bG9hZCA9IHJldDtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXRBdWRpb0NvbmZpZyhyZXQpIHtcXG4gICAgbGV0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcXG4gICAgbGV0IGNvbmZpZztcXG4gICAgbGV0IGV4dGVuc2lvblNhbXBsZUluZGV4O1xcbiAgICBpZiAoL2ZpcmVmb3gvaS50ZXN0KHVzZXJBZ2VudCkpIHtcXG4gICAgICBpZiAocmV0LmZyZXF1ZW5jeUluZGV4ID49IDYpIHtcXG4gICAgICAgIHJldC5hdWRpb09iamVjdFR5cGUgPSA1O1xcbiAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xcbiAgICAgICAgZXh0ZW5zaW9uU2FtcGxlSW5kZXggPSByZXQuZnJlcXVlbmN5SW5kZXggLSAzO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXQuYXVkaW9PYmplY3RUeXBlID0gMjtcXG4gICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcXG4gICAgICAgIGV4dGVuc2lvblNhbXBsZUluZGV4ID0gcmV0LmZyZXF1ZW5jeUluZGV4O1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSkge1xcbiAgICAgIHJldC5hdWRpb09iamVjdFR5cGUgPSAyO1xcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcXG4gICAgICBleHRlbnNpb25TYW1wbGVJbmRleCA9IHJldC5mcmVxdWVuY3lJbmRleDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXQuYXVkaW9PYmplY3RUeXBlID0gNTtcXG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XFxuICAgICAgaWYgKHJldC5mcmVxdWVuY3lJbmRleCA+PSA2KSB7XFxuICAgICAgICBleHRlbnNpb25TYW1wbGVJbmRleCA9IHJldC5mcmVxdWVuY3lJbmRleCAtIDM7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmIChyZXQuY2hhbm5lbCA9PT0gMSkge1xcbiAgICAgICAgICByZXQuYXVkaW9PYmplY3RUeXBlID0gMjtcXG4gICAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZXh0ZW5zaW9uU2FtcGxlSW5kZXggPSByZXQuZnJlcXVlbmN5SW5kZXg7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGNvbmZpZ1swXSA9IHJldC5hdWRpb09iamVjdFR5cGUgPDwgMztcXG4gICAgY29uZmlnWzBdIHw9IChyZXQuZnJlcXVlbmN5SW5kZXggJiAweDBlKSA+PiAxO1xcbiAgICBjb25maWdbMV0gPSAocmV0LmZyZXF1ZW5jeUluZGV4ICYgMHgwMSkgPDwgNztcXG4gICAgY29uZmlnWzFdIHw9IHJldC5jaGFubmVsIDw8IDM7XFxuICAgIGlmIChyZXQuYXVkaW9PYmplY3RUeXBlID09PSA1KSB7XFxuICAgICAgY29uZmlnWzFdIHw9IChleHRlbnNpb25TYW1wbGVJbmRleCAmIDB4MGUpID4+IDE7XFxuICAgICAgY29uZmlnWzJdID0gKGV4dGVuc2lvblNhbXBsZUluZGV4ICYgMHgwMSkgPDwgNztcXG4gICAgICBjb25maWdbMl0gfD0gMiA8PCAyO1xcbiAgICAgIGNvbmZpZ1szXSA9IDA7XFxuICAgIH1cXG4gICAgcmV0LmF1ZGlvQ29uZmlnID0gY29uZmlnO1xcbiAgfVxcblxcbiAgZ2V0IGlucHV0QnVmZmVyKCkge1xcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZSh0aGlzLmNvbmZpZ3MuaW5wdXRidWZmZXIpO1xcbiAgfVxcblxcbiAgZ2V0IF90cmFja3MoKSB7XFxuICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKCdUUkFDS1MnKTtcXG4gIH1cXG59XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gVHNEZW11eGVyO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci1kZW11eC9zcmMvaGxzL2RlbXV4ZXIvdHMuanM/XCIpfSxcIi4uL3hncGxheWVyLWRlbXV4L3NyYy9obHMvcGxheWxpc3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci1kZW11eC9zcmMvaGxzL3BsYXlsaXN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5jbGFzcyBQbGF5bGlzdCB7XFxuICBjb25zdHJ1Y3Rvcihjb25maWdzKSB7XFxuICAgIHRoaXMuX2Jhc2VVUkwgPSAnJztcXG4gICAgdGhpcy5fbGlzdCA9IHt9O1xcbiAgICB0aGlzLl90cyA9IHt9O1xcbiAgICB0aGlzLnZlcnNpb24gPSAwO1xcbiAgICB0aGlzLnNlcXVlbmNlID0gLTE7XFxuICAgIHRoaXMudGFyZ2V0ZHVyYXRpb24gPSAwO1xcbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcXG4gICAgdGhpcy5mcmFnTGVuZ3RoID0gMDtcXG4gICAgdGhpcy5fbGFzdGdldCA9IHVuZGVmaW5lZDtcXG4gICAgdGhpcy5fYXVkb2NsZWFyID0gY29uZmlncy5hdXRvY2xlYXIgfHwgZmFsc2U7XFxuICB9XFxuXFxuICBnZXQgbGlzdCgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2xpc3Q7XFxuICB9XFxuXFxuICBzZXQgYmFzZVVSTChiYXNlVVJMKSB7XFxuICAgIGlmICh0aGlzLmJhc2VVUkwgIT09IGJhc2VVUkwpIHtcXG4gICAgICB0aGlzLmNsZWFyKCk7XFxuICAgICAgdGhpcy5fYmFzZVVSTCA9IGJhc2VVUkw7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGdldCBiYXNlVVJMKCkge1xcbiAgICByZXR1cm4gdGhpcy5fYmFzZVVSTDtcXG4gIH1cXG5cXG4gIHB1c2godHMsIGR1cmF0aW9uLCBkaXNjb250aW51ZSkge1xcbiAgICBpZiAoIXRoaXMuX3RzW3RzXSkge1xcbiAgICAgIHRoaXMuX3RzW3RzXSA9IHsgZHVyYXRpb246IGR1cmF0aW9uLFxcbiAgICAgICAgZG93bmxvYWRlZDogZmFsc2UsXFxuICAgICAgICBkb3dubG9hZGluZzogZmFsc2UsXFxuICAgICAgICBzdGFydDogdGhpcy5kdXJhdGlvbixcXG4gICAgICAgIGRpc2NvbnRpbnVlOiBkaXNjb250aW51ZSA/IHRydWUgOiBmYWxzZVxcbiAgICAgIH07XFxuICAgICAgdGhpcy5fbGlzdFt0aGlzLmR1cmF0aW9uXSA9IHRzO1xcbiAgICAgIHRoaXMuZHVyYXRpb24gKz0gZHVyYXRpb247XFxuICAgICAgdGhpcy5mcmFnTGVuZ3RoICs9IDE7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGRlbGV0ZUZyYWcodXJsKSB7XFxuICAgIGlmICh0aGlzLl90c1t1cmxdKSB7XFxuICAgICAgaWYgKHRoaXMuX3RzW3VybF0uc3RhcnQgPiB0aGlzLl9sYXN0Z2V0LnRpbWUpIHtcXG4gICAgICAgIHRoaXMuX2xhc3RnZXQgPSB7XFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLl90c1t1cmxdLmR1cmF0aW9uLFxcbiAgICAgICAgICB0aW1lOiB0aGlzLl90c1t1cmxdLnN0YXJ0LFxcbiAgICAgICAgICBkb3dubG9hZGVkOiBmYWxzZSxcXG4gICAgICAgICAgZG93bmxvYWRpbmc6IGZhbHNlLFxcbiAgICAgICAgICB1cmw6IHVybFxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuICAgICAgZGVsZXRlIHRoaXMuX2xpc3RbdGhpcy5fdHNbdXJsXS5zdGFydF07XFxuICAgICAgZGVsZXRlIHRoaXMuX3RzW3VybF07XFxuICAgICAgdGhpcy5mcmFnTGVuZ3RoIC09IDE7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHB1c2hNM1U4KGRhdGEsIGRlbGV0ZXByZSkge1xcbiAgICAvLyDluLjop4Tkv6Hmga/mm7/mjaJcXG4gICAgaWYgKCFkYXRhKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBtM3U4IGRhdGEgcmVjZWl2ZWQuYCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHRoaXMudmVyc2lvbiA9IGRhdGEudmVyc2lvbjtcXG4gICAgdGhpcy50YXJnZXRkdXJhdGlvbiA9IGRhdGEudGFyZ2V0ZHVyYXRpb247XFxuICAgIGlmIChkYXRhLmVuY3J5cHQgJiYgIXRoaXMuZW5jcnlwdCkge1xcbiAgICAgIHRoaXMuZW5jcnlwdCA9IGRhdGEuZW5jcnlwdDtcXG4gICAgfVxcbiAgICAvLyDmlrDliIbniYfkv6Hmga9cXG4gICAgaWYgKGRhdGEuc2VxdWVuY2UgPiB0aGlzLnNlcXVlbmNlKSB7XFxuICAgICAgdGhpcy5zZXF1ZW5jZSA9IGRhdGEuc2VxdWVuY2U7XFxuICAgICAgbGV0IG5ld2ZyYWdsaXN0ID0gW107XFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmZyYWdzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBsZXQgZnJhZyA9IGRhdGEuZnJhZ3NbaV07XFxuICAgICAgICBpZiAoIXRoaXMuX3RzW2ZyYWcudXJsXSkge1xcbiAgICAgICAgICBuZXdmcmFnbGlzdC5wdXNoKGZyYWcudXJsKTtcXG4gICAgICAgICAgdGhpcy5wdXNoKGZyYWcudXJsLCBmcmFnLmR1cmF0aW9uLCBmcmFnLmRpc2NvbnRpbnVlKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG5ld2ZyYWdsaXN0Lmxlbmd0aCA8IDEpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG5vdCByZWFkIHRzIGZpbGUgbGlzdC5gKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGRlbGV0ZXByZSkge1xcbiAgICAgICAgbGV0IHRzbGlzdCA9IHRoaXMuZ2V0VHNMaXN0KCk7XFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRzbGlzdC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICBpZiAobmV3ZnJhZ2xpc3QuaW5kZXhPZih0c2xpc3RbaV0pIDwgMCkge1xcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlRnJhZyh0c2xpc3RbaV0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT2xkIG0zdTggZmlsZSByZWNlaXZlZCwgJHtkYXRhLnNlcXVlbmNlfWApO1xcbiAgICB9XFxuICB9XFxuXFxuICBnZXRUc0xpc3QoKSB7XFxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl90cyk7XFxuICB9XFxuXFxuICBkb3dubG9hZGVkKHRzbmFtZSwgaXNsb2FkZWQpIHtcXG4gICAgbGV0IHRzID0gdGhpcy5fdHNbdHNuYW1lXTtcXG4gICAgaWYgKHRzKSB7XFxuICAgICAgdHMuZG93bmxvYWRlZCA9IGlzbG9hZGVkO1xcbiAgICB9XFxuICB9XFxuXFxuICBkb3dubG9hZGluZyh0c25hbWUsIGxvYWRpbmcpIHtcXG4gICAgbGV0IHRzID0gdGhpcy5fdHNbdHNuYW1lXTtcXG4gICAgaWYgKHRzKSB7XFxuICAgICAgdHMuZG93bmxvYWRpbmcgPSBsb2FkaW5nO1xcbiAgICB9XFxuICB9XFxuXFxuICBnZXRUc0J5TmFtZShuYW1lKSB7XFxuICAgIHJldHVybiB0aGlzLl90c1tuYW1lXTtcXG4gIH1cXG5cXG4gIGdldFRzKHRpbWUpIHtcXG4gICAgbGV0IHRpbWVsaXN0ID0gT2JqZWN0LmtleXModGhpcy5fbGlzdCk7XFxuICAgIGxldCB0cztcXG5cXG4gICAgaWYgKHRpbWUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIGlmICh0aGlzLl9sYXN0Z2V0KSB7XFxuICAgICAgICB0aW1lID0gdGhpcy5fbGFzdGdldC50aW1lICsgdGhpcy5fbGFzdGdldC5kdXJhdGlvbjtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGltZSA9IDA7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmICh0aW1lbGlzdC5sZW5ndGggPCAxIHx8IHRpbWUgPj0gdGhpcy5kdXJhdGlvbikge1xcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XFxuICAgIH1cXG4gICAgdGltZWxpc3Quc29ydCgoYSwgYikgPT4ge1xcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KGEpIC0gcGFyc2VGbG9hdChiKTtcXG4gICAgfSk7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZWxpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgICBpZiAodGltZSA+PSBwYXJzZUludCh0aW1lbGlzdFtpXSkpIHtcXG4gICAgICAgIGxldCB1cmwgPSB0aGlzLl9saXN0W3RpbWVsaXN0W2ldXTtcXG4gICAgICAgIGxldCBkb3dubG9hZGVkID0gdGhpcy5fdHNbdXJsXS5kb3dubG9hZGVkO1xcbiAgICAgICAgbGV0IGRvd25sb2FkaW5nID0gdGhpcy5fdHNbdXJsXS5kb3dubG9hZGluZztcXG4gICAgICAgIHRzID0geyB1cmwsIGRvd25sb2FkZWQsIGRvd25sb2FkaW5nLCB0aW1lOiBwYXJzZUludCh0aW1lbGlzdFtpXSksIGR1cmF0aW9uOiBwYXJzZUludCh0aGlzLl90c1t1cmxdLmR1cmF0aW9uKSB9O1xcbiAgICAgICAgaWYgKHRoaXMuYXV0b2NsZWFyKSB7XFxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl90c1t0aGlzLl9sYXN0Z2V0LnVybF07XFxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9saXN0W3RoaXMuX2xhc3RnZXQudGltZV07XFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLl9sYXN0Z2V0ID0gdHM7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gdHM7XFxuICB9XFxuXFxuICBjbGVhcigpIHtcXG4gICAgdGhpcy5fYmFzZVVSTCA9ICcnO1xcbiAgICB0aGlzLl9saXN0ID0ge307XFxuICAgIHRoaXMuX3RzID0ge307XFxuICAgIHRoaXMudmVyc2lvbiA9IDA7XFxuICAgIHRoaXMuc2VxdWVuY2UgPSAtMTtcXG4gICAgdGhpcy50YXJnZXRkdXJhdGlvbiA9IDA7XFxuICAgIHRoaXMuZHVyYXRpb24gPSAwO1xcbiAgfVxcblxcbiAgY2xlYXJEb3dubG9hZGVkKCkge1xcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IE9iamVjdC5rZXlzKHRoaXMuX3RzKS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICBsZXQgdHMgPSB0aGlzLl90c1tPYmplY3Qua2V5cyh0aGlzLl90cylbaV1dO1xcbiAgICAgIHRzLmRvd25sb2FkZWQgPSBmYWxzZTtcXG4gICAgICB0cy5kb3dubG9hZGluZyA9IGZhbHNlO1xcbiAgICB9XFxuICB9XFxuXFxuICBkZXN0cm95KCkge1xcbiAgICB0aGlzLl9iYXNlVVJMID0gJyc7XFxuICAgIHRoaXMuX2xpc3QgPSB7fTtcXG4gICAgdGhpcy5fdHMgPSB7fTtcXG4gICAgdGhpcy52ZXJzaW9uID0gMDtcXG4gICAgdGhpcy5zZXF1ZW5jZSA9IC0xO1xcbiAgICB0aGlzLnRhcmdldGR1cmF0aW9uID0gMDtcXG4gICAgdGhpcy5kdXJhdGlvbiA9IDA7XFxuICAgIHRoaXMuZnJhZ0xlbmd0aCA9IDA7XFxuICAgIHRoaXMuX2xhc3RnZXQgPSB1bmRlZmluZWQ7XFxuICAgIHRoaXMuX2F1ZG9jbGVhciA9IGZhbHNlO1xcbiAgfVxcbn1cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBQbGF5bGlzdDtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItZGVtdXgvc3JjL2hscy9wbGF5bGlzdC5qcz9cIil9LFwiLi4veGdwbGF5ZXItbG9hZGVyL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci1sb2FkZXIvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbCgnXFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBGZXRjaExvYWRlcjogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvZmV0Y2gtbG9hZGVyICovIFwiLi4veGdwbGF5ZXItbG9hZGVyL3NyYy9mZXRjaC1sb2FkZXIuanNcIikuZGVmYXVsdFxcbn07XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLWxvYWRlci9pbmRleC5qcz8nKX0sXCIuLi94Z3BsYXllci1sb2FkZXIvc3JjL2ZldGNoLWxvYWRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci1sb2FkZXIvc3JjL2ZldGNoLWxvYWRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBfeGdwbGF5ZXJVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHhncGxheWVyLXV0aWxzICovIFxcXCIuLi94Z3BsYXllci11dGlscy9pbmRleC5qc1xcXCIpO1xcblxcbmNvbnN0IExPQURFUl9FVkVOVFMgPSBfeGdwbGF5ZXJVdGlscy5FVkVOVFMuTE9BREVSX0VWRU5UUztcXG5jb25zdCBSRUFEX1NUUkVBTSA9IDA7XFxuY29uc3QgUkVBRF9URVhUID0gMTtcXG5jb25zdCBSRUFEX0pTT04gPSAyO1xcbmNvbnN0IFJFQURfQlVGRkVSID0gMztcXG5jbGFzcyBGZXRjaExvYWRlciB7XFxuICBjb25zdHJ1Y3Rvcihjb25maWdzKSB7XFxuICAgIHRoaXMuY29uZmlncyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZ3MpO1xcbiAgICB0aGlzLnVybCA9IG51bGw7XFxuICAgIHRoaXMuc3RhdHVzID0gMDtcXG4gICAgdGhpcy5lcnJvciA9IG51bGw7XFxuICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XFxuICAgIHRoaXMuX2NhbmNlbGVkID0gZmFsc2U7XFxuICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xcbiAgICB0aGlzLnJlYWR0eXBlID0gdGhpcy5jb25maWdzLnJlYWR0eXBlO1xcbiAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuY29uZmlncy5idWZmZXIgfHwgJ0xPQURFUl9CVUZGRVInO1xcbiAgICB0aGlzLl9sb2FkZXJUYXNrTm8gPSAwO1xcbiAgfVxcblxcbiAgaW5pdCgpIHtcXG4gICAgdGhpcy5vbihMT0FERVJfRVZFTlRTLkxBREVSX1NUQVJULCB0aGlzLmxvYWQuYmluZCh0aGlzKSk7XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XFxuICAgIHJldHVybiAnbG9hZGVyJztcXG4gIH1cXG5cXG4gIGxvYWQodXJsLCBvcHRzKSB7XFxuICAgIGxldCBfdGhpcyA9IHRoaXM7XFxuICAgIHRoaXMudXJsID0gdXJsO1xcbiAgICB0aGlzLl9jYW5jZWxlZCA9IGZhbHNlO1xcblxcbiAgICAvLyBUT0RPOiBBZGQgUmFuZ2VzXFxuICAgIGxldCBwYXJhbXMgPSB0aGlzLmdldFBhcmFtcyhvcHRzKTtcXG4gICAgX3RoaXMubG9hZGluZyA9IHRydWU7XFxuICAgIHJldHVybiBmZXRjaCh0aGlzLnVybCwgcGFyYW1zKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xcbiAgICAgICAgX3RoaXMuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xcbiAgICAgICAgcmV0dXJuIF90aGlzLl9vbkZldGNoUmVzcG9uc2UocmVzcG9uc2UpO1xcbiAgICAgIH1cXG4gICAgICBfdGhpcy5sb2FkaW5nID0gZmFsc2U7XFxuICAgICAgX3RoaXMuZW1pdChMT0FERVJfRVZFTlRTLkxPQURFUl9FUlJPUiwgX3RoaXMuVEFHLCBuZXcgRXJyb3IoYGludmFsaWQgcmVzcG9uc2UuYCkpO1xcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcXG4gICAgICBfdGhpcy5sb2FkaW5nID0gZmFsc2U7XFxuICAgICAgX3RoaXMuZW1pdChMT0FERVJfRVZFTlRTLkxPQURFUl9FUlJPUiwgX3RoaXMuVEFHLCBlcnJvcik7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIF9vbkZldGNoUmVzcG9uc2UocmVzcG9uc2UpIHtcXG4gICAgbGV0IF90aGlzID0gdGhpcztcXG4gICAgbGV0IGJ1ZmZlciA9IHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UodGhpcy5idWZmZXIpO1xcbiAgICB0aGlzLl9sb2FkZXJUYXNrTm8rKztcXG4gICAgbGV0IHRhc2tubyA9IHRoaXMuX2xvYWRlclRhc2tObztcXG4gICAgaWYgKHJlc3BvbnNlLm9rID09PSB0cnVlKSB7XFxuICAgICAgc3dpdGNoICh0aGlzLnJlYWR0eXBlKSB7XFxuICAgICAgICBjYXNlIFJFQURfSlNPTjpcXG4gICAgICAgICAgcmVzcG9uc2UuanNvbigpLnRoZW4oZGF0YSA9PiB7XFxuICAgICAgICAgICAgX3RoaXMubG9hZGluZyA9IGZhbHNlO1xcbiAgICAgICAgICAgIGlmICghX3RoaXMuX2NhbmNlbGVkICYmICFfdGhpcy5fZGVzdHJveWVkKSB7XFxuICAgICAgICAgICAgICBpZiAoYnVmZmVyKSB7XFxuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGRhdGEpO1xcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KExPQURFUl9FVkVOVFMuTE9BREVSX0NPTVBMRVRFLCBidWZmZXIpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChMT0FERVJfRVZFTlRTLkxPQURFUl9DT01QTEVURSwgZGF0YSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlIFJFQURfVEVYVDpcXG4gICAgICAgICAgcmVzcG9uc2UudGV4dCgpLnRoZW4oZGF0YSA9PiB7XFxuICAgICAgICAgICAgX3RoaXMubG9hZGluZyA9IGZhbHNlO1xcbiAgICAgICAgICAgIGlmICghX3RoaXMuX2NhbmNlbGVkICYmICFfdGhpcy5fZGVzdHJveWVkKSB7XFxuICAgICAgICAgICAgICBpZiAoYnVmZmVyKSB7XFxuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGRhdGEpO1xcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KExPQURFUl9FVkVOVFMuTE9BREVSX0NPTVBMRVRFLCBidWZmZXIpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChMT0FERVJfRVZFTlRTLkxPQURFUl9DT01QTEVURSwgZGF0YSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlIFJFQURfQlVGRkVSOlxcbiAgICAgICAgICByZXNwb25zZS5hcnJheUJ1ZmZlcigpLnRoZW4oZGF0YSA9PiB7XFxuICAgICAgICAgICAgX3RoaXMubG9hZGluZyA9IGZhbHNlO1xcbiAgICAgICAgICAgIGlmICghX3RoaXMuX2NhbmNlbGVkICYmICFfdGhpcy5fZGVzdHJveWVkKSB7XFxuICAgICAgICAgICAgICBpZiAoYnVmZmVyKSB7XFxuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKG5ldyBVaW50OEFycmF5KGRhdGEpKTtcXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChMT0FERVJfRVZFTlRTLkxPQURFUl9DT01QTEVURSwgYnVmZmVyKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoTE9BREVSX0VWRU5UUy5MT0FERVJfQ09NUExFVEUsIGRhdGEpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSBSRUFEX1NUUkVBTTpcXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIHJldHVybiB0aGlzLl9vblJlYWRlcihyZXNwb25zZS5ib2R5LmdldFJlYWRlcigpLCB0YXNrbm8pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgX29uUmVhZGVyKHJlYWRlciwgdGFza25vKSB7XFxuICAgIGxldCBidWZmZXIgPSB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKHRoaXMuYnVmZmVyKTtcXG4gICAgaWYgKCFidWZmZXIgJiYgdGhpcy5fcmVhZGVyIHx8IHRoaXMuX2Rlc3Ryb3llZCkge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICB0aGlzLl9yZWFkZXIuY2FuY2VsKCk7XFxuICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgLy8gRE8gTk9USElOR1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB0aGlzLl9yZWFkZXIgPSByZWFkZXI7XFxuICAgIGlmICh0aGlzLmxvYWRpbmcgPT09IGZhbHNlKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGxldCBfdGhpcyA9IHRoaXM7XFxuICAgIC8vIHJlYWRlciByZWFkIGZ1bmN0aW9uIHJldHVybnMgYSBQcm9taXNlLiBnZXQgZGF0YSB3aGVuIGNhbGxiYWNrIGFuZCBoYXMgdmFsdWUuZG9uZSB3aGVuIGRpc2Nvbm5lY3RlZC5cXG4gICAgLy8gcmVhZOaWueazlei/lOWbnuS4gOS4qlByb21pc2UuIOWbnuiwg+S4reWPr+S7peiOt+WPluWIsOaVsOaNruOAguW9k3ZhbHVlLmRvbmXlrZjlnKjml7bvvIzor7TmmI7pk77mjqXmlq3lvIDjgIJcXG4gICAgdGhpcy5fcmVhZGVyICYmIHRoaXMuX3JlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAodmFsKSB7XFxuICAgICAgaWYgKHZhbC5kb25lKSB7XFxuICAgICAgICAvLyBUT0RPOiDlrozmiJDlpITnkIZcXG4gICAgICAgIF90aGlzLmxvYWRpbmcgPSBmYWxzZTtcXG4gICAgICAgIF90aGlzLnN0YXR1cyA9IDA7XFxuICAgICAgICBfdGhpcy5lbWl0KExPQURFUl9FVkVOVFMuTE9BREVSX0NPTVBMRVRFLCBidWZmZXIpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoX3RoaXMuX2NhbmNlbGVkIHx8IF90aGlzLl9kZXN0cm95ZWQpIHtcXG4gICAgICAgIGlmIChfdGhpcy5fcmVhZGVyKSB7XFxuICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgX3RoaXMuX3JlYWRlci5jYW5jZWwoKTtcXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIC8vIERPIE5PVEhJTkdcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICBidWZmZXIucHVzaCh2YWwudmFsdWUpO1xcbiAgICAgIF90aGlzLmVtaXQoTE9BREVSX0VWRU5UUy5MT0FERVJfREFUQUxPQURFRCwgYnVmZmVyKTtcXG4gICAgICByZXR1cm4gX3RoaXMuX29uUmVhZGVyKHJlYWRlciwgdGFza25vKTtcXG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xcbiAgICAgIF90aGlzLmxvYWRpbmcgPSBmYWxzZTtcXG4gICAgICBfdGhpcy5lbWl0KExPQURFUl9FVkVOVFMuTE9BREVSX0VSUk9SLCBfdGhpcy5UQUcsIGVycm9yKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBnZXRQYXJhbXMob3B0cykge1xcbiAgICBsZXQgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpO1xcbiAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XFxuXFxuICAgIGxldCBwYXJhbXMgPSB7XFxuICAgICAgbWV0aG9kOiAnR0VUJyxcXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxcbiAgICAgIG1vZGU6ICdjb3JzJyxcXG4gICAgICBjYWNoZTogJ2RlZmF1bHQnXFxuXFxuICAgICAgLy8gYWRkIGN1c3Rtb3IgaGVhZGVyc1xcbiAgICAgIC8vIOa3u+WKoOiHquWumuS5ieWktFxcbiAgICB9O2lmICh0eXBlb2YgdGhpcy5jb25maWdzLmhlYWRlcnMgPT09ICdvYmplY3QnKSB7XFxuICAgICAgbGV0IGNvbmZpZ0hlYWRlcnMgPSB0aGlzLmNvbmZpZ3MuaGVhZGVycztcXG4gICAgICBmb3IgKGxldCBrZXkgaW4gY29uZmlnSGVhZGVycykge1xcbiAgICAgICAgaWYgKGNvbmZpZ0hlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIGNvbmZpZ0hlYWRlcnNba2V5XSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5oZWFkZXJzID09PSAnb2JqZWN0Jykge1xcbiAgICAgIGxldCBvcHRIZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzO1xcbiAgICAgIGZvciAobGV0IGtleSBpbiBvcHRIZWFkZXJzKSB7XFxuICAgICAgICBpZiAob3B0SGVhZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxuICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgb3B0SGVhZGVyc1trZXldKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKG9wdGlvbnMuY29ycyA9PT0gZmFsc2UpIHtcXG4gICAgICBwYXJhbXMubW9kZSA9ICdzYW1lLW9yaWdpbic7XFxuICAgIH1cXG5cXG4gICAgLy8gd2l0aENyZWRlbnRpYWxzIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHRcXG4gICAgLy8gd2l0aENyZWRlbnRpYWxzIOWcqOm7mOiupOaDheWGteS4i+S4jeiiq+S9v+eUqOOAglxcbiAgICBpZiAob3B0aW9ucy53aXRoQ3JlZGVudGlhbHMpIHtcXG4gICAgICBwYXJhbXMuY3JlZGVudGlhbHMgPSAnaW5jbHVkZSc7XFxuICAgIH1cXG5cXG4gICAgLy8gVE9ETzogQWRkIHJhbmdlcztcXG4gICAgcmV0dXJuIHBhcmFtcztcXG4gIH1cXG5cXG4gIGNhbmNlbCgpIHtcXG4gICAgaWYgKHRoaXMuX3JlYWRlcikge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICB0aGlzLl9yZWFkZXIuY2FuY2VsKCk7XFxuICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgLy8g6Ziy5q2iZmFpbGVkOiAyMDDplJnor6/ooqvmiZPljbDliLDmjqfliLblj7DkuIpcXG4gICAgICB9XFxuICAgICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcXG4gICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcXG4gICAgICB0aGlzLl9jYW5jZWxlZCA9IHRydWU7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGRlc3Ryb3koKSB7XFxuICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XFxuICAgIHRoaXMuY2FuY2VsKCk7XFxuICB9XFxufVxcblxcbmV4cG9ydHMuZGVmYXVsdCA9IEZldGNoTG9hZGVyO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci1sb2FkZXIvc3JjL2ZldGNoLWxvYWRlci5qcz9cIil9LFwiLi4veGdwbGF5ZXItcmVtdXgvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItcmVtdXgvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKCdcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHtcXG4gIE1wNFJlbXV4ZXI6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL21wNCAqLyBcIi4uL3hncGxheWVyLXJlbXV4L3NyYy9tcDQvaW5kZXguanNcIikuZGVmYXVsdFxcbn07XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXJlbXV4L2luZGV4LmpzPycpfSxcIi4uL3hncGxheWVyLXJlbXV4L3NyYy9tcDQvZm1wNC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItcmVtdXgvc3JjL21wNC9mbXA0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBfeGdwbGF5ZXJVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHhncGxheWVyLXV0aWxzICovIFxcXCIuLi94Z3BsYXllci11dGlscy9pbmRleC5qc1xcXCIpO1xcblxcbi8vIGNvbnN0IFVJTlQzMl9NQVggPSBNYXRoLnBvdygyLCAzMikgLSAxO1xcbmNsYXNzIEZtcDQge1xcbiAgc3RhdGljIHNpemUodmFsdWUpIHtcXG4gICAgcmV0dXJuIF94Z3BsYXllclV0aWxzLkJ1ZmZlci53cml0ZVVpbnQzMih2YWx1ZSk7XFxuICB9XFxuICBzdGF0aWMgaW5pdEJveChzaXplLCBuYW1lLCAuLi5jb250ZW50KSB7XFxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBfeGdwbGF5ZXJVdGlscy5CdWZmZXIoKTtcXG4gICAgYnVmZmVyLndyaXRlKEZtcDQuc2l6ZShzaXplKSwgRm1wNC50eXBlKG5hbWUpLCAuLi5jb250ZW50KTtcXG4gICAgcmV0dXJuIGJ1ZmZlci5idWZmZXI7XFxuICB9XFxuICBzdGF0aWMgZXh0ZW5zaW9uKHZlcnNpb24sIGZsYWcpIHtcXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFt2ZXJzaW9uLCBmbGFnID4+IDE2ICYgMHhmZiwgZmxhZyA+PiA4ICYgMHhmZiwgZmxhZyAmIDB4ZmZdKTtcXG4gIH1cXG4gIHN0YXRpYyBmdHlwKCkge1xcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KDI0LCAnZnR5cCcsIG5ldyBVaW50OEFycmF5KFsweDY5LCAweDczLCAweDZGLCAweDZELCAvLyBpc29tLFxcbiAgICAweDAsIDB4MCwgMHgwMCwgMHgwMSwgLy8gbWlub3JfdmVyc2lvbjogMHgwMVxcbiAgICAweDY5LCAweDczLCAweDZGLCAweDZELCAvLyBpc29tXFxuICAgIDB4NjEsIDB4NzYsIDB4NjMsIDB4MzEgLy8gYXZjMVxcbiAgICBdKSk7XFxuICB9XFxuICBzdGF0aWMgbW9vdih7IHR5cGUsIG1ldGEgfSkge1xcbiAgICBsZXQgc2l6ZSA9IDg7XFxuICAgIGxldCBtdmhkID0gRm1wNC5tdmhkKG1ldGEuZHVyYXRpb24sIG1ldGEudGltZXNjYWxlKTtcXG4gICAgbGV0IHRyYWs7XFxuXFxuICAgIGlmICh0eXBlID09PSAndmlkZW8nKSB7XFxuICAgICAgdHJhayA9IEZtcDQudmlkZW9UcmFrKG1ldGEpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRyYWsgPSBGbXA0LmF1ZGlvVHJhayhtZXRhKTtcXG4gICAgfVxcblxcbiAgICBsZXQgbXZleCA9IEZtcDQubXZleChtZXRhLmR1cmF0aW9uLCBtZXRhLnRpbWVzY2FsZSB8fCAxMDAwLCBtZXRhLmlkKTtcXG4gICAgW212aGQsIHRyYWssIG12ZXhdLmZvckVhY2goaXRlbSA9PiB7XFxuICAgICAgc2l6ZSArPSBpdGVtLmJ5dGVMZW5ndGg7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KHNpemUsICdtb292JywgbXZoZCwgdHJhaywgbXZleCk7XFxuICB9XFxuICBzdGF0aWMgbXZoZChkdXJhdGlvbiwgdGltZXNjYWxlID0gMTAwMCkge1xcbiAgICAvLyBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XFxuICAgIGxldCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyB2ZXJzaW9uKDApICsgZmxhZ3MgICAgIDHkvY3nmoRib3jniYjmnKwrM+S9jWZsYWdzICAgYm9454mI5pys77yMMOaIljHvvIzkuIDoiKzkuLow44CC77yI5Lul5LiL5a2X6IqC5pWw5Z2H5oyJdmVyc2lvbj0w77yJXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGNyZWF0aW9uX3RpbWUgICAg5Yib5bu65pe26Ze0ICDvvIjnm7jlr7nkuo5VVEPml7bpl7QxOTA0LTAxLTAx6Zu254K555qE56eS5pWw77yJXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIG1vZGlmaWNhdGlvbl90aW1lICAg5L+u5pS55pe26Ze0XFxuXFxuICAgIC8qKlxcbiAgICAgICAgICAgKiB0aW1lc2NhbGU6IDQgYnl0ZXPmlofku7blqpLkvZPlnKgx56eS5pe26Ze05YaF55qE5Yi75bqm5YC877yM5Y+v5Lul55CG6Kej5Li6MeenkumVv+W6plxcbiAgICAgICAgICAgKi9cXG4gICAgdGltZXNjYWxlID4+PiAyNCAmIDB4RkYsIHRpbWVzY2FsZSA+Pj4gMTYgJiAweEZGLCB0aW1lc2NhbGUgPj4+IDggJiAweEZGLCB0aW1lc2NhbGUgJiAweEZGLFxcblxcbiAgICAvKipcXG4gICAgICAgICAgICogZHVyYXRpb246IDQgYnl0ZXPor6V0cmFja+eahOaXtumXtOmVv+W6pu+8jOeUqGR1cmF0aW9u5ZKMdGltZSBzY2FsZeWAvOWPr+S7peiuoeeul3RyYWNr5pe26ZW/77yM5q+U5aaCYXVkaW8gdHJhY2vnmoR0aW1lIHNjYWxlID0gODAwMCxcXG4gICAgICAgICAgICogZHVyYXRpb24gPSA1NjAxMjjvvIzml7bplb/kuLo3MC4wMTbvvIx2aWRlbyB0cmFja+eahHRpbWUgc2NhbGUgPSA2MDAsIGR1cmF0aW9uID0gNDIwMDDvvIzml7bplb/kuLo3MFxcbiAgICAgICAgICAgKi9cXG4gICAgZHVyYXRpb24gPj4+IDI0ICYgMHhGRiwgZHVyYXRpb24gPj4+IDE2ICYgMHhGRiwgZHVyYXRpb24gPj4+IDggJiAweEZGLCBkdXJhdGlvbiAmIDB4RkYsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIC8vIFByZWZlcnJlZCByYXRlOiAxLjAgICDmjqjojZDmkq3mlL7pgJ/njofvvIzpq5gxNuS9jeWSjOS9jjE25L2N5YiG5Yir5Li65bCP5pWw54K55pW05pWw6YOo5YiG5ZKM5bCP5pWw6YOo5YiG77yM5Y2zWzE2LjE2XSDmoLzlvI/vvIzor6XlgLzkuLoxLjDvvIgweDAwMDEwMDAw77yJ6KGo56S65q2j5bi45YmN5ZCR5pKt5pS+XFxuICAgIC8qKlxcbiAgICAgICAgICAgKiBQcmVmZXJyZWRWb2x1bWUoMS4wLCAyYnl0ZXMpICsgcmVzZXJ2ZWQoMmJ5dGVzKVxcbiAgICAgICAgICAgKiDkuI5yYXRl57G75Ly877yMWzguOF0g5qC85byP77yMMS4w77yIMHgwMTAw77yJ6KGo56S65pyA5aSn6Z+z6YePXFxuICAgICAgICAgICAqL1xcbiAgICAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyAgcmVzZXJ2ZWQ6IDQgKyA0IGJ5dGVz5L+d55WZ5L2NXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIC8vIC0tLS1iZWdpbiBjb21wb3NpdGlvbiBtYXRyaXgtLS0tXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIOinhumikeWPmOaNouefqemYtSAgIOe6v+aAp+S7o+aVsFxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDQwLCAweDAwLCAweDAwLCAweDAwLCAvLyAtLS0tZW5kIGNvbXBvc2l0aW9uIG1hdHJpeC0tLS1cXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gLS0tLWJlZ2luIHByZV9kZWZpbmVkIDYgKiA0IGJ5dGVzLS0tLVxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmUtZGVmaW5lZCDkv53nlZnkvY1cXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gLS0tLWVuZCBwcmVfZGVmaW5lZCA2ICogNCBieXRlcy0tLS1cXG4gICAgMHhGRiwgMHhGRiwgMHhGRiwgMHhGRiAvLyBuZXh0X3RyYWNrX0lEIOS4i+S4gOS4qnRyYWNr5L2/55So55qEaWTlj7dcXG4gICAgXSk7XFxuICAgIHJldHVybiBGbXA0LmluaXRCb3goOCArIGJ5dGVzLmxlbmd0aCwgJ212aGQnLCBuZXcgVWludDhBcnJheShieXRlcykpO1xcbiAgfVxcbiAgc3RhdGljIHZpZGVvVHJhayhkYXRhKSB7XFxuICAgIGxldCBzaXplID0gODtcXG5cXG4gICAgbGV0IHRraGQgPSBGbXA0LnRraGQoe1xcbiAgICAgIGlkOiAxLFxcbiAgICAgIGR1cmF0aW9uOiBkYXRhLmR1cmF0aW9uLFxcbiAgICAgIHRpbWVzY2FsZTogZGF0YS50aW1lc2NhbGUgfHwgMTAwMCxcXG4gICAgICB3aWR0aDogZGF0YS5wcmVzZW50V2lkdGgsXFxuICAgICAgaGVpZ2h0OiBkYXRhLnByZXNlbnRIZWlnaHQsXFxuICAgICAgdHlwZTogJ3ZpZGVvJ1xcbiAgICB9KTtcXG4gICAgbGV0IG1kaWEgPSBGbXA0Lm1kaWEoe1xcbiAgICAgIHR5cGU6ICd2aWRlbycsXFxuICAgICAgdGltZXNjYWxlOiBkYXRhLnRpbWVzY2FsZSB8fCAxMDAwLFxcbiAgICAgIGR1cmF0aW9uOiBkYXRhLmR1cmF0aW9uLFxcbiAgICAgIGF2Y2M6IGRhdGEuYXZjYyxcXG4gICAgICBwYXJSYXRpbzogZGF0YS5wYXJSYXRpbyxcXG4gICAgICB3aWR0aDogZGF0YS5wcmVzZW50V2lkdGgsXFxuICAgICAgaGVpZ2h0OiBkYXRhLnByZXNlbnRIZWlnaHRcXG4gICAgfSk7XFxuICAgIFt0a2hkLCBtZGlhXS5mb3JFYWNoKGl0ZW0gPT4ge1xcbiAgICAgIHNpemUgKz0gaXRlbS5ieXRlTGVuZ3RoO1xcbiAgICB9KTtcXG4gICAgcmV0dXJuIEZtcDQuaW5pdEJveChzaXplLCAndHJhaycsIHRraGQsIG1kaWEpO1xcbiAgfVxcbiAgc3RhdGljIGF1ZGlvVHJhayhkYXRhKSB7XFxuICAgIGxldCBzaXplID0gODtcXG4gICAgbGV0IHRraGQgPSBGbXA0LnRraGQoe1xcbiAgICAgIGlkOiAyLFxcbiAgICAgIGR1cmF0aW9uOiBkYXRhLmR1cmF0aW9uLFxcbiAgICAgIHRpbWVzY2FsZTogZGF0YS50aW1lc2NhbGUgfHwgMTAwMCxcXG4gICAgICB3aWR0aDogMCxcXG4gICAgICBoZWlnaHQ6IDAsXFxuICAgICAgdHlwZTogJ2F1ZGlvJ1xcbiAgICB9KTtcXG4gICAgbGV0IG1kaWEgPSBGbXA0Lm1kaWEoe1xcbiAgICAgIHR5cGU6ICdhdWRpbycsXFxuICAgICAgdGltZXNjYWxlOiBkYXRhLnRpbWVzY2FsZSB8fCAxMDAwLFxcbiAgICAgIGR1cmF0aW9uOiBkYXRhLmR1cmF0aW9uLFxcbiAgICAgIGNoYW5uZWxDb3VudDogZGF0YS5jaGFubmVsQ291bnQsXFxuICAgICAgc2FtcGxlcmF0ZTogZGF0YS5zYW1wbGVSYXRlLFxcbiAgICAgIGNvbmZpZzogZGF0YS5jb25maWdcXG4gICAgfSk7XFxuICAgIFt0a2hkLCBtZGlhXS5mb3JFYWNoKGl0ZW0gPT4ge1xcbiAgICAgIHNpemUgKz0gaXRlbS5ieXRlTGVuZ3RoO1xcbiAgICB9KTtcXG4gICAgcmV0dXJuIEZtcDQuaW5pdEJveChzaXplLCAndHJhaycsIHRraGQsIG1kaWEpO1xcbiAgfVxcbiAgc3RhdGljIHRraGQoZGF0YSkge1xcbiAgICBsZXQgaWQgPSBkYXRhLmlkO1xcbiAgICBsZXQgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xcbiAgICBsZXQgd2lkdGggPSBkYXRhLndpZHRoO1xcbiAgICBsZXQgaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XFxuICAgIGxldCBjb250ZW50ID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDcsIC8vIHZlcnNpb24oMCkgKyBmbGFncyAx5L2N54mI5pysIGJveOeJiOacrO+8jDDmiJYx77yM5LiA6Iis5Li6MOOAgu+8iOS7peS4i+Wtl+iKguaVsOWdh+aMiXZlcnNpb249MO+8ieaMieS9jeaIluaTjeS9nOe7k+aenOWAvO+8jOmihOWumuS5ieWmguS4i++8mlxcbiAgICAvLyAweDAwMDAwMSB0cmFja19lbmFibGVk77yM5ZCm5YiZ6K+ldHJhY2vkuI3ooqvmkq3mlL7vvJtcXG4gICAgLy8gMHgwMDAwMDIgdHJhY2tfaW5fbW92aWXvvIzooajnpLror6V0cmFja+WcqOaSreaUvuS4reiiq+W8leeUqO+8m1xcbiAgICAvLyAweDAwMDAwNCB0cmFja19pbl9wcmV2aWV377yM6KGo56S66K+ldHJhY2vlnKjpooTop4jml7booqvlvJXnlKjjgIJcXG4gICAgLy8g5LiA6Iis6K+l5YC85Li6N++8jDErMis0IOWmguaenOS4gOS4quWqkuS9k+aJgOaciXRyYWNr5Z2H5pyq6K6+572udHJhY2tfaW5fbW92aWXlkox0cmFja19pbl9wcmV2aWV377yM5bCG6KKr55CG6Kej5Li65omA5pyJdHJhY2vlnYforr7nva7kuobov5nkuKTpobnvvJvlr7nkuo5oaW50IHRyYWNr77yM6K+l5YC85Li6MFxcbiAgICAvLyBoaW50IHRyYWNrIOi/meS4queJueauiueahHRyYWNr5bm25LiN5YyF5ZCr5aqS5L2T5pWw5o2u77yM6ICM5piv5YyF5ZCr5LqG5LiA5Lqb5bCG5YW25LuW5pWw5o2udHJhY2vmiZPljIXmiJDmtYHlqpLkvZPnmoTmjIfnpLrkv6Hmga/jgIJcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gY3JlYXRpb25fdGltZeWIm+W7uuaXtumXtO+8iOebuOWvueS6jlVUQ+aXtumXtDE5MDQtMDEtMDHpm7bngrnnmoTnp5LmlbDvvIlcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gbW9kaWZpY2F0aW9uIHRpbWUg5L+u5pS55pe26Ze0XFxuICAgIGlkID4+PiAyNCAmIDB4RkYsIC8vIHRyYWNrX0lEOiA0IGJ5dGVzIGlk5Y+377yM5LiN6IO96YeN5aSN5LiU5LiN6IO95Li6MFxcbiAgICBpZCA+Pj4gMTYgJiAweEZGLCBpZCA+Pj4gOCAmIDB4RkYsIGlkICYgMHhGRiwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWQ6IDQgYnl0ZXMgICAg5L+d55WZ5L2NXFxuICAgIGR1cmF0aW9uID4+PiAyNCAmIDB4RkYsIC8vIGR1cmF0aW9uOiA0IGJ5dGVzIHRyYWNr55qE5pe26Ze06ZW/5bqmXFxuICAgIGR1cmF0aW9uID4+PiAxNiAmIDB4RkYsIGR1cmF0aW9uID4+PiA4ICYgMHhGRiwgZHVyYXRpb24gJiAweEZGLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDogMiAqIDQgYnl0ZXMgICAg5L+d55WZ5L2NXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGxheWVyKDJieXRlcykgKyBhbHRlcm5hdGVfZ3JvdXAoMmJ5dGVzKSAg6KeG6aKR5bGC77yM6buY6K6k5Li6MO+8jOWAvOWwj+eahOWcqOS4iuWxgi50cmFja+WIhue7hOS/oeaBr++8jOm7mOiupOS4ujDooajnpLror6V0cmFja+acquS4juWFtuS7lnRyYWNr5pyJ576k57uE5YWz57O7XFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHZvbHVtZSgyYnl0ZXMpICsgcmVzZXJ2ZWQoMmJ5dGVzKSAgICBbOC44XSDmoLzlvI/vvIzlpoLmnpzkuLrpn7PpopF0cmFja++8jDEuMO+8iDB4MDEwMO+8ieihqOekuuacgOWkp+mfs+mHj++8m+WQpuWImeS4ujAgICAr5L+d55WZ5L2NXFxuICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIC8vIC0tLS1iZWdpbiBjb21wb3NpdGlvbiBtYXRyaXgtLS0tXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIC8vIOinhumikeWPmOaNouefqemYtVxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDQwLCAweDAwLCAweDAwLCAweDAwLCAvLyAtLS0tZW5kIGNvbXBvc2l0aW9uIG1hdHJpeC0tLS1cXG4gICAgd2lkdGggPj4+IDggJiAweEZGLCAvLyAvL+WuveW6plxcbiAgICB3aWR0aCAmIDB4RkYsIDB4MDAsIDB4MDAsIGhlaWdodCA+Pj4gOCAmIDB4RkYsIC8vIOmrmOW6plxcbiAgICBoZWlnaHQgJiAweEZGLCAweDAwLCAweDAwXSk7XFxuICAgIHJldHVybiBGbXA0LmluaXRCb3goOCArIGNvbnRlbnQuYnl0ZUxlbmd0aCwgJ3RraGQnLCBjb250ZW50KTtcXG4gIH1cXG4gIHN0YXRpYyBlZHRzKGRhdGEpIHtcXG4gICAgbGV0IGJ1ZmZlciA9IG5ldyBfeGdwbGF5ZXJVdGlscy5CdWZmZXIoKTtcXG4gICAgbGV0IGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcXG4gICAgbGV0IG1lZGlhVGltZSA9IGRhdGEubWVkaWFUaW1lO1xcbiAgICBidWZmZXIud3JpdGUoRm1wNC5zaXplKDM2KSwgRm1wNC50eXBlKCdlZHRzJykpO1xcbiAgICAvLyBlbHN0XFxuICAgIGJ1ZmZlci53cml0ZShGbXA0LnNpemUoMjgpLCBGbXA0LnR5cGUoJ2Vsc3QnKSk7XFxuICAgIGJ1ZmZlci53cml0ZShuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZW50cnkgY291bnRcXG4gICAgZHVyYXRpb24gPj4gMjQgJiAweGZmLCBkdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIGR1cmF0aW9uID4+IDggJiAweGZmLCBkdXJhdGlvbiAmIDB4ZmYsIG1lZGlhVGltZSA+PiAyNCAmIDB4ZmYsIG1lZGlhVGltZSA+PiAxNiAmIDB4ZmYsIG1lZGlhVGltZSA+PiA4ICYgMHhmZiwgbWVkaWFUaW1lICYgMHhmZiwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSAvLyBtZWRpYSByYXRlXFxuICAgIF0pKTtcXG4gICAgcmV0dXJuIGJ1ZmZlci5idWZmZXI7XFxuICB9XFxuICBzdGF0aWMgbWRpYShkYXRhKSB7XFxuICAgIGxldCBzaXplID0gODtcXG4gICAgbGV0IG1kaGQgPSBGbXA0Lm1kaGQoZGF0YS50aW1lc2NhbGUsIGRhdGEuZHVyYXRpb24pO1xcbiAgICBsZXQgaGRsciA9IEZtcDQuaGRscihkYXRhLnR5cGUpO1xcbiAgICBsZXQgbWluZiA9IEZtcDQubWluZihkYXRhKTtcXG4gICAgW21kaGQsIGhkbHIsIG1pbmZdLmZvckVhY2goaXRlbSA9PiB7XFxuICAgICAgc2l6ZSArPSBpdGVtLmJ5dGVMZW5ndGg7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KHNpemUsICdtZGlhJywgbWRoZCwgaGRsciwgbWluZik7XFxuICB9XFxuICBzdGF0aWMgbWRoZCh0aW1lc2NhbGUgPSAxMDAwLCBkdXJhdGlvbikge1xcbiAgICBsZXQgY29udGVudCA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBjcmVhdGlvbl90aW1lICAgIOWIm+W7uuaXtumXtFxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBtb2RpZmljYXRpb25fdGltZeS/ruaUueaXtumXtFxcbiAgICB0aW1lc2NhbGUgPj4+IDI0ICYgMHhGRiwgLy8gdGltZXNjYWxlOiA0IGJ5dGVzICAgIOaWh+S7tuWqkuS9k+WcqDHnp5Lml7bpl7TlhoXnmoTliLvluqblgLzvvIzlj6/ku6XnkIbop6PkuLox56eS6ZW/5bqmXFxuICAgIHRpbWVzY2FsZSA+Pj4gMTYgJiAweEZGLCB0aW1lc2NhbGUgPj4+IDggJiAweEZGLCB0aW1lc2NhbGUgJiAweEZGLCBkdXJhdGlvbiA+Pj4gMjQgJiAweEZGLCAvLyBkdXJhdGlvbjogNCBieXRlcyAgdHJhY2vnmoTml7bpl7Tplb/luqZcXG4gICAgZHVyYXRpb24gPj4+IDE2ICYgMHhGRiwgZHVyYXRpb24gPj4+IDggJiAweEZGLCBkdXJhdGlvbiAmIDB4RkYsIDB4NTUsIDB4QzQsIC8vIGxhbmd1YWdlOiB1bmQgKHVuZGV0ZXJtaW5lZCkg5aqS5L2T6K+t6KiA56CB44CC5pyA6auY5L2N5Li6MO+8jOWQjumdojE15L2N5Li6M+S4quWtl+espu+8iOingUlTTyA2MzktMi9U5qCH5YeG5Lit5a6a5LmJ77yJXFxuICAgIDB4MDAsIDB4MDAgLy8gcHJlX2RlZmluZWQgPSAwXFxuICAgIF0pO1xcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KDEyICsgY29udGVudC5ieXRlTGVuZ3RoLCAnbWRoZCcsIEZtcDQuZXh0ZW5zaW9uKDAsIDApLCBjb250ZW50KTtcXG4gIH1cXG4gIHN0YXRpYyBoZGxyKHR5cGUpIHtcXG4gICAgbGV0IHZhbHVlID0gWzB4MDAsIC8vIHZlcnNpb24gMFxcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxcbiAgICAweDc2LCAweDY5LCAweDY0LCAweDY1LCAvLyBoYW5kbGVyX3R5cGU6ICd2aWRlJ1xcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxcbiAgICAweDU2LCAweDY5LCAweDY0LCAweDY1LCAweDZmLCAweDQ4LCAweDYxLCAweDZlLCAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwIC8vIG5hbWU6ICdWaWRlb0hhbmRsZXInXFxuICAgIF07XFxuICAgIGlmICh0eXBlID09PSAnYXVkaW8nKSB7XFxuICAgICAgdmFsdWUuc3BsaWNlKDgsIDQsIC4uLlsweDczLCAweDZmLCAweDc1LCAweDZlXSk7XFxuICAgICAgdmFsdWUuc3BsaWNlKDI0LCAxMywgLi4uWzB4NTMsIDB4NmYsIDB4NzUsIDB4NmUsIDB4NjQsIDB4NDgsIDB4NjEsIDB4NmUsIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDBdKTtcXG4gICAgfVxcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KDggKyB2YWx1ZS5sZW5ndGgsICdoZGxyJywgbmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcXG4gIH1cXG4gIHN0YXRpYyBtaW5mKGRhdGEpIHtcXG4gICAgbGV0IHNpemUgPSA4O1xcbiAgICBsZXQgdm1oZCA9IGRhdGEudHlwZSA9PT0gJ3ZpZGVvJyA/IEZtcDQudm1oZCgpIDogRm1wNC5zbWhkKCk7XFxuICAgIGxldCBkaW5mID0gRm1wNC5kaW5mKCk7XFxuICAgIGxldCBzdGJsID0gRm1wNC5zdGJsKGRhdGEpO1xcbiAgICBbdm1oZCwgZGluZiwgc3RibF0uZm9yRWFjaChpdGVtID0+IHtcXG4gICAgICBzaXplICs9IGl0ZW0uYnl0ZUxlbmd0aDtcXG4gICAgfSk7XFxuICAgIHJldHVybiBGbXA0LmluaXRCb3goc2l6ZSwgJ21pbmYnLCB2bWhkLCBkaW5mLCBzdGJsKTtcXG4gIH1cXG4gIHN0YXRpYyB2bWhkKCkge1xcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KDIwLCAndm1oZCcsIG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uXFxuICAgIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGZsYWdzXFxuICAgIDB4MDAsIDB4MDAsIC8vIGdyYXBoaWNzbW9kZVxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIG9wY29sb3JcXG4gICAgXSkpO1xcbiAgfVxcbiAgc3RhdGljIHNtaGQoKSB7XFxuICAgIHJldHVybiBGbXA0LmluaXRCb3goMTYsICdzbWhkJywgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb25cXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcXG4gICAgMHgwMCwgMHgwMCwgLy8gYmFsYW5jZVxcbiAgICAweDAwLCAweDAwIC8vIHJlc2VydmVkXFxuICAgIF0pKTtcXG4gIH1cXG4gIHN0YXRpYyBkaW5mKCkge1xcbiAgICBsZXQgYnVmZmVyID0gbmV3IF94Z3BsYXllclV0aWxzLkJ1ZmZlcigpO1xcbiAgICBsZXQgZHJlZiA9IFsweDAwLCAvLyB2ZXJzaW9uIDBcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZW50cnlfY291bnRcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwYywgLy8gZW50cnlfc2l6ZVxcbiAgICAweDc1LCAweDcyLCAweDZjLCAweDIwLCAvLyAndXJsJyB0eXBlXFxuICAgIDB4MDAsIC8vIHZlcnNpb24gMFxcbiAgICAweDAwLCAweDAwLCAweDAxIC8vIGVudHJ5X2ZsYWdzXFxuICAgIF07XFxuICAgIGJ1ZmZlci53cml0ZShGbXA0LnNpemUoMzYpLCBGbXA0LnR5cGUoJ2RpbmYnKSwgRm1wNC5zaXplKDI4KSwgRm1wNC50eXBlKCdkcmVmJyksIG5ldyBVaW50OEFycmF5KGRyZWYpKTtcXG4gICAgcmV0dXJuIGJ1ZmZlci5idWZmZXI7XFxuICB9XFxuICBzdGF0aWMgc3RibChkYXRhKSB7XFxuICAgIGxldCBzaXplID0gODtcXG4gICAgbGV0IHN0c2QgPSBGbXA0LnN0c2QoZGF0YSk7XFxuICAgIGxldCBzdHRzID0gRm1wNC5zdHRzKCk7XFxuICAgIGxldCBzdHNjID0gRm1wNC5zdHNjKCk7XFxuICAgIGxldCBzdHN6ID0gRm1wNC5zdHN6KCk7XFxuICAgIGxldCBzdGNvID0gRm1wNC5zdGNvKCk7XFxuICAgIFtzdHNkLCBzdHRzLCBzdHNjLCBzdHN6LCBzdGNvXS5mb3JFYWNoKGl0ZW0gPT4ge1xcbiAgICAgIHNpemUgKz0gaXRlbS5ieXRlTGVuZ3RoO1xcbiAgICB9KTtcXG4gICAgcmV0dXJuIEZtcDQuaW5pdEJveChzaXplLCAnc3RibCcsIHN0c2QsIHN0dHMsIHN0c2MsIHN0c3osIHN0Y28pO1xcbiAgfVxcbiAgc3RhdGljIHN0c2QoZGF0YSkge1xcbiAgICBsZXQgY29udGVudDtcXG4gICAgaWYgKGRhdGEudHlwZSA9PT0gJ2F1ZGlvJykge1xcbiAgICAgIC8vIGlmICghZGF0YS5pc0FBQyAmJiBkYXRhLmNvZGVjID09PSAnbXA0Jykge1xcbiAgICAgIC8vICAgICBjb250ZW50ID0gRk1QNC5tcDMoZGF0YSk7XFxuICAgICAgLy8gfSBlbHNlIHtcXG4gICAgICAvL1xcbiAgICAgIC8vIH1cXG4gICAgICAvLyDmlK/mjIFtcDRhXFxuICAgICAgY29udGVudCA9IEZtcDQubXA0YShkYXRhKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjb250ZW50ID0gRm1wNC5hdmMxKGRhdGEpO1xcbiAgICB9XFxuICAgIHJldHVybiBGbXA0LmluaXRCb3goMTYgKyBjb250ZW50LmJ5dGVMZW5ndGgsICdzdHNkJywgRm1wNC5leHRlbnNpb24oMCwgMCksIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLCAweDAxXSksIGNvbnRlbnQpO1xcbiAgfVxcbiAgc3RhdGljIG1wNGEoZGF0YSkge1xcbiAgICBsZXQgY29udGVudCA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxcbiAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxcbiAgICAweDAwLCBkYXRhLmNoYW5uZWxDb3VudCwgLy8gY2hhbm5lbGNvdW50XFxuICAgIDB4MDAsIDB4MTAsIC8vIHNhbXBsZVNpemU6MTZiaXRzXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkMlxcbiAgICBkYXRhLnNhbXBsZXJhdGUgPj4gOCAmIDB4ZmYsIGRhdGEuc2FtcGxlcmF0ZSAmIDB4ZmYsIC8vXFxuICAgIDB4MDAsIDB4MDBdKTtcXG4gICAgbGV0IGVzZHMgPSBGbXA0LmVzZHMoZGF0YS5jb25maWcpO1xcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KDggKyBjb250ZW50LmJ5dGVMZW5ndGggKyBlc2RzLmJ5dGVMZW5ndGgsICdtcDRhJywgY29udGVudCwgZXNkcyk7XFxuICB9XFxuICBzdGF0aWMgZXNkcyhjb25maWcgPSBbNDMsIDE0NiwgOCwgMF0pIHtcXG4gICAgY29uc3QgY29uZmlnbGVuID0gY29uZmlnLmxlbmd0aDtcXG4gICAgbGV0IGJ1ZmZlciA9IG5ldyBfeGdwbGF5ZXJVdGlscy5CdWZmZXIoKTtcXG4gICAgbGV0IGNvbnRlbnQgPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvbiAwXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXFxuXFxuICAgIDB4MDMsIC8vIGRlc2NyaXB0b3JfdHlwZVxcbiAgICAweDE3ICsgY29uZmlnbGVuLCAvLyBsZW5ndGhcXG4gICAgMHgwMCwgMHgwMSwgLy8gZXNfaWRcXG4gICAgMHgwMCwgLy8gc3RyZWFtX3ByaW9yaXR5XFxuXFxuICAgIDB4MDQsIC8vIGRlc2NyaXB0b3JfdHlwZVxcbiAgICAweDBmICsgY29uZmlnbGVuLCAvLyBsZW5ndGhcXG4gICAgMHg0MCwgLy8gY29kZWMgOiBtcGVnNF9hdWRpb1xcbiAgICAweDE1LCAvLyBzdHJlYW1fdHlwZVxcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBidWZmZXJfc2l6ZVxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBtYXhCaXRyYXRlXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGF2Z0JpdHJhdGVcXG5cXG4gICAgMHgwNSAvLyBkZXNjcmlwdG9yX3R5cGVcXG4gICAgXS5jb25jYXQoW2NvbmZpZ2xlbl0pLmNvbmNhdChjb25maWcpLmNvbmNhdChbMHgwNiwgMHgwMSwgMHgwMl0pKTtcXG4gICAgYnVmZmVyLndyaXRlKEZtcDQuc2l6ZSg4ICsgY29udGVudC5ieXRlTGVuZ3RoKSwgRm1wNC50eXBlKCdlc2RzJyksIGNvbnRlbnQpO1xcbiAgICByZXR1cm4gYnVmZmVyLmJ1ZmZlcjtcXG4gIH1cXG4gIHN0YXRpYyBhdmMxKGRhdGEpIHtcXG4gICAgbGV0IGJ1ZmZlciA9IG5ldyBfeGdwbGF5ZXJVdGlscy5CdWZmZXIoKTtcXG4gICAgbGV0IHNpemUgPSA0MDsgLy8gOChhdmMxKSs4KGF2Y2MpKzgoYnRydCkrMTYocGFzcClcXG4gICAgLy8gbGV0IHNwcyA9IGRhdGEuc3BzXFxuICAgIC8vIGxldCBwcHMgPSBkYXRhLnBwc1xcbiAgICBsZXQgd2lkdGggPSBkYXRhLndpZHRoO1xcbiAgICBsZXQgaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XFxuICAgIGxldCBoU3BhY2luZyA9IGRhdGEucGFyUmF0aW8uaGVpZ2h0O1xcbiAgICBsZXQgdlNwYWNpbmcgPSBkYXRhLnBhclJhdGlvLndpZHRoO1xcbiAgICAvLyBsZXQgYXZjY0J1ZmZlciA9IG5ldyBCdWZmZXIoKVxcbiAgICAvLyBhdmNjQnVmZmVyLndyaXRlKG5ldyBVaW50OEFycmF5KFtcXG4gICAgLy8gICAweDAxLCAvLyB2ZXJzaW9uXFxuICAgIC8vICAgc3BzWzFdLCAvLyBwcm9maWxlXFxuICAgIC8vICAgc3BzWzJdLCAvLyBwcm9maWxlIGNvbXBhdGlibGVcXG4gICAgLy8gICBzcHNbM10sIC8vIGxldmVsXFxuICAgIC8vICAgMHhmYyB8IDMsXFxuICAgIC8vICAgMHhFMCB8IDEgLy8g55uu5YmN5Y+q5aSE55CG5LiA5Liqc3BzXFxuICAgIC8vIF0uY29uY2F0KFtzcHMubGVuZ3RoID4+PiA4ICYgMHhmZiwgc3BzLmxlbmd0aCAmIDB4ZmZdKSkpXFxuICAgIC8vIGF2Y2NCdWZmZXIud3JpdGUoc3BzLCBuZXcgVWludDhBcnJheShbMSwgcHBzLmxlbmd0aCA+Pj4gOCAmIDB4ZmYsIHBwcy5sZW5ndGggJiAweGZmXSksIHBwcylcXG5cXG4gICAgbGV0IGF2Y2MgPSBkYXRhLmF2Y2M7XFxuICAgIGxldCBhdmMxID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXFxuICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XFxuICAgIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXFxuICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXFxuICAgIHdpZHRoID4+IDggJiAweGZmLCB3aWR0aCAmIDB4ZmYsIC8vIHdpZHRoXFxuICAgIGhlaWdodCA+PiA4ICYgMHhmZiwgaGVpZ2h0ICYgMHhmZiwgLy8gaGVpZ2h0XFxuICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsIC8vIGhvcml6cmVzb2x1dGlvblxcbiAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLCAvLyB2ZXJ0cmVzb2x1dGlvblxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxcbiAgICAweDAwLCAweDAxLCAvLyBmcmFtZV9jb3VudFxcbiAgICAweDEyLCAweDY0LCAweDYxLCAweDY5LCAweDZDLCAvLyBkYWlseW1vdGlvbi9obHMuanNcXG4gICAgMHg3OSwgMHg2RCwgMHg2RiwgMHg3NCwgMHg2OSwgMHg2RiwgMHg2RSwgMHgyRiwgMHg2OCwgMHg2QywgMHg3MywgMHgyRSwgMHg2QSwgMHg3MywgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gY29tcHJlc3Nvcm5hbWVcXG4gICAgMHgwMCwgMHgxOCwgLy8gZGVwdGggPSAyNFxcbiAgICAweDExLCAweDExXSk7IC8vIHByZV9kZWZpbmVkID0gLTFcXG4gICAgbGV0IGJ0cnQgPSBuZXcgVWludDhBcnJheShbMHgwMCwgMHgxYywgMHg5YywgMHg4MCwgLy8gYnVmZmVyU2l6ZURCXFxuICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzAsIC8vIG1heEJpdHJhdGVcXG4gICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMCAvLyBhdmdCaXRyYXRlXFxuICAgIF0pO1xcbiAgICBsZXQgcGFzcCA9IG5ldyBVaW50OEFycmF5KFtoU3BhY2luZyA+PiAyNCwgLy8gaFNwYWNpbmdcXG4gICAgaFNwYWNpbmcgPj4gMTYgJiAweGZmLCBoU3BhY2luZyA+PiA4ICYgMHhmZiwgaFNwYWNpbmcgJiAweGZmLCB2U3BhY2luZyA+PiAyNCwgLy8gdlNwYWNpbmdcXG4gICAgdlNwYWNpbmcgPj4gMTYgJiAweGZmLCB2U3BhY2luZyA+PiA4ICYgMHhmZiwgdlNwYWNpbmcgJiAweGZmXSk7XFxuXFxuICAgIGJ1ZmZlci53cml0ZShGbXA0LnNpemUoc2l6ZSArIGF2YzEuYnl0ZUxlbmd0aCArIGF2Y2MuYnl0ZUxlbmd0aCArIGJ0cnQuYnl0ZUxlbmd0aCksIEZtcDQudHlwZSgnYXZjMScpLCBhdmMxLCBGbXA0LnNpemUoOCArIGF2Y2MuYnl0ZUxlbmd0aCksIEZtcDQudHlwZSgnYXZjQycpLCBhdmNjLCBGbXA0LnNpemUoMjApLCBGbXA0LnR5cGUoJ2J0cnQnKSwgYnRydCwgRm1wNC5zaXplKDE2KSwgRm1wNC50eXBlKCdwYXNwJyksIHBhc3ApO1xcbiAgICByZXR1cm4gYnVmZmVyLmJ1ZmZlcjtcXG4gIH1cXG4gIHN0YXRpYyBzdHRzKCkge1xcbiAgICBsZXQgY29udGVudCA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gZW50cnlfY291bnRcXG4gICAgXSk7XFxuICAgIHJldHVybiBGbXA0LmluaXRCb3goMTYsICdzdHRzJywgY29udGVudCk7XFxuICB9XFxuICBzdGF0aWMgc3RzYygpIHtcXG4gICAgbGV0IGNvbnRlbnQgPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvblxcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIGVudHJ5X2NvdW50XFxuICAgIF0pO1xcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KDE2LCAnc3RzYycsIGNvbnRlbnQpO1xcbiAgfVxcbiAgc3RhdGljIHN0Y28oKSB7XFxuICAgIGxldCBjb250ZW50ID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb25cXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBlbnRyeV9jb3VudFxcbiAgICBdKTtcXG4gICAgcmV0dXJuIEZtcDQuaW5pdEJveCgxNiwgJ3N0Y28nLCBjb250ZW50KTtcXG4gIH1cXG4gIHN0YXRpYyBzdHN6KCkge1xcbiAgICBsZXQgY29udGVudCA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHNhbXBsZV9zaXplXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gc2FtcGxlX2NvdW50XFxuICAgIF0pO1xcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KDIwLCAnc3RzeicsIGNvbnRlbnQpO1xcbiAgfVxcbiAgc3RhdGljIG12ZXgoZHVyYXRpb24sIHRpbWVzY2FsZSA9IDEwMDAsIHRyYWNrSUQpIHtcXG4gICAgbGV0IGJ1ZmZlciA9IG5ldyBfeGdwbGF5ZXJVdGlscy5CdWZmZXIoKTtcXG4gICAgbGV0IG1laGQgPSBfeGdwbGF5ZXJVdGlscy5CdWZmZXIud3JpdGVVaW50MzIoZHVyYXRpb24pO1xcbiAgICBidWZmZXIud3JpdGUoRm1wNC5zaXplKDU2KSwgRm1wNC50eXBlKCdtdmV4JyksIEZtcDQuc2l6ZSgxNiksIEZtcDQudHlwZSgnbWVoZCcpLCBGbXA0LmV4dGVuc2lvbigwLCAwKSwgbWVoZCwgRm1wNC50cmV4KHRyYWNrSUQpKTtcXG4gICAgcmV0dXJuIGJ1ZmZlci5idWZmZXI7XFxuICB9XFxuICBzdGF0aWMgdHJleChpZCkge1xcbiAgICBsZXQgY29udGVudCA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcXG4gICAgaWQgPj4gMjQsIGlkID4+IDE2ICYgMHhmZiwgaWQgPj4gOCAmIDB4ZmYsIGlkICYgMHhmZiwgLy8gdHJhY2tfSURcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfZHVyYXRpb25cXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfc2l6ZVxcbiAgICAweDAwLCAweDAxLCAweDAwLCAweDAxIC8vIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXFxuICAgIF0pO1xcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KDggKyBjb250ZW50LmJ5dGVMZW5ndGgsICd0cmV4JywgY29udGVudCk7XFxuICB9XFxuICBzdGF0aWMgbW9vZihkYXRhKSB7XFxuICAgIGxldCBzaXplID0gODtcXG4gICAgbGV0IG1maGQgPSBGbXA0Lm1maGQoKTtcXG4gICAgbGV0IHRyYWYgPSBGbXA0LnRyYWYoZGF0YSk7XFxuICAgIFttZmhkLCB0cmFmXS5mb3JFYWNoKGl0ZW0gPT4ge1xcbiAgICAgIHNpemUgKz0gaXRlbS5ieXRlTGVuZ3RoO1xcbiAgICB9KTtcXG4gICAgcmV0dXJuIEZtcDQuaW5pdEJveChzaXplLCAnbW9vZicsIG1maGQsIHRyYWYpO1xcbiAgfVxcbiAgc3RhdGljIG1maGQoKSB7XFxuICAgIGxldCBjb250ZW50ID0gX3hncGxheWVyVXRpbHMuQnVmZmVyLndyaXRlVWludDMyKEZtcDQuc2VxdWVuY2UpO1xcbiAgICBGbXA0LnNlcXVlbmNlICs9IDE7XFxuICAgIHJldHVybiBGbXA0LmluaXRCb3goMTYsICdtZmhkJywgRm1wNC5leHRlbnNpb24oMCwgMCksIGNvbnRlbnQpO1xcbiAgfVxcbiAgc3RhdGljIHRyYWYoZGF0YSkge1xcbiAgICBsZXQgc2l6ZSA9IDg7XFxuICAgIGxldCB0ZmhkID0gRm1wNC50ZmhkKGRhdGEuaWQpO1xcbiAgICBsZXQgdGZkdCA9IEZtcDQudGZkdChkYXRhLnRpbWUpO1xcbiAgICBsZXQgc2R0cCA9IEZtcDQuc2R0cChkYXRhKTtcXG4gICAgbGV0IHRydW4gPSBGbXA0LnRydW4oZGF0YSwgc2R0cC5ieXRlTGVuZ3RoKTtcXG5cXG4gICAgW3RmaGQsIHRmZHQsIHRydW4sIHNkdHBdLmZvckVhY2goaXRlbSA9PiB7XFxuICAgICAgc2l6ZSArPSBpdGVtLmJ5dGVMZW5ndGg7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KHNpemUsICd0cmFmJywgdGZoZCwgdGZkdCwgdHJ1biwgc2R0cCk7XFxuICB9XFxuICBzdGF0aWMgdGZoZChpZCkge1xcbiAgICBsZXQgY29udGVudCA9IF94Z3BsYXllclV0aWxzLkJ1ZmZlci53cml0ZVVpbnQzMihpZCk7XFxuICAgIHJldHVybiBGbXA0LmluaXRCb3goMTYsICd0ZmhkJywgRm1wNC5leHRlbnNpb24oMCwgMCksIGNvbnRlbnQpO1xcbiAgfVxcbiAgc3RhdGljIHRmZHQodGltZSkge1xcbiAgICAvLyBsZXQgdXBwZXIgPSBNYXRoLmZsb29yKHRpbWUgLyAoVUlOVDMyX01BWCArIDEpKSxcXG4gICAgLy8gICAgIGxvd2VyID0gTWF0aC5mbG9vcih0aW1lICUgKFVJTlQzMl9NQVggKyAxKSk7XFxuICAgIHJldHVybiBGbXA0LmluaXRCb3goMTYsICd0ZmR0JywgRm1wNC5leHRlbnNpb24oMCwgMCksIF94Z3BsYXllclV0aWxzLkJ1ZmZlci53cml0ZVVpbnQzMih0aW1lKSk7XFxuICB9XFxuICBzdGF0aWMgdHJ1bihkYXRhLCBzZHRwTGVuZ3RoKSB7XFxuICAgIC8vIGxldCBpZCA9IGRhdGEuaWQ7XFxuICAgIC8vIGxldCBjZWlsID0gaWQgPT09IDEgPyAxNiA6IDEyO1xcbiAgICBsZXQgYnVmZmVyID0gbmV3IF94Z3BsYXllclV0aWxzLkJ1ZmZlcigpO1xcbiAgICBsZXQgc2FtcGxlQ291bnQgPSBfeGdwbGF5ZXJVdGlscy5CdWZmZXIud3JpdGVVaW50MzIoZGF0YS5zYW1wbGVzLmxlbmd0aCk7XFxuICAgIC8vIG1kYXQtaGVhZGVyIDhcXG4gICAgLy8gbW9vZi1oZWFkZXIgOFxcbiAgICAvLyBtZmhkIDE2XFxuICAgIC8vIHRyYWYtaGVhZGVyIDhcXG4gICAgLy8gdGhoZCAxNlxcbiAgICAvLyB0ZmR0IDIwXFxuICAgIC8vIHRydW4taGVhZGVyIDEyXFxuICAgIC8vIHNhbXBsZUNvdW50IDRcXG4gICAgLy8gZGF0YS1vZmZzZXQgNFxcbiAgICAvLyBzYW1wbGVzLmxlbmd0aFxcbiAgICBsZXQgb2Zmc2V0ID0gX3hncGxheWVyVXRpbHMuQnVmZmVyLndyaXRlVWludDMyKDggKyA4ICsgMTYgKyA4ICsgMTYgKyAxNiArIDEyICsgNCArIDQgKyAxNiAqIGRhdGEuc2FtcGxlcy5sZW5ndGggKyBzZHRwTGVuZ3RoKTtcXG4gICAgYnVmZmVyLndyaXRlKEZtcDQuc2l6ZSgyMCArIDE2ICogZGF0YS5zYW1wbGVzLmxlbmd0aCksIEZtcDQudHlwZSgndHJ1bicpLCBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwRiwgMHgwMV0pLCBzYW1wbGVDb3VudCwgb2Zmc2V0KTtcXG5cXG4gICAgLy8gbGV0IHNpemUgPSBidWZmZXIuYnVmZmVyLmJ5dGVMZW5ndGhcXG4gICAgLy8gbGV0IHdyaXRlT2Zmc2V0ID0gMFxcbiAgICAvLyBkYXRhLnNhbXBsZXMuZm9yRWFjaCgoKSA9PiB7XFxuICAgIC8vICAgc2l6ZSArPSAxNlxcbiAgICAvLyB9KVxcbiAgICAvL1xcbiAgICAvLyBsZXQgdHJ1bkJveCA9IG5ldyBVaW50OEFycmF5KHNpemUpXFxuXFxuICAgIC8vIHRydW5Cb3guc2V0KGJ1ZmZlci5idWZmZXIsIDApXFxuXFxuICAgIGRhdGEuc2FtcGxlcy5mb3JFYWNoKGl0ZW0gPT4ge1xcbiAgICAgIGNvbnN0IGZsYWdzID0gaXRlbS5mbGFncztcXG4gICAgICAvLyBjb25zb2xlLmxvZyhpdGVtLnR5cGUsIGl0ZW0uZHRzLCBpdGVtLmR1cmF0aW9uKVxcblxcbiAgICAgIGJ1ZmZlci53cml0ZShuZXcgVWludDhBcnJheShbaXRlbS5kdXJhdGlvbiA+Pj4gMjQgJiAweEZGLCAvLyBzYW1wbGVfZHVyYXRpb25cXG4gICAgICBpdGVtLmR1cmF0aW9uID4+PiAxNiAmIDB4RkYsIGl0ZW0uZHVyYXRpb24gPj4+IDggJiAweEZGLCBpdGVtLmR1cmF0aW9uICYgMHhGRiwgaXRlbS5zaXplID4+PiAyNCAmIDB4RkYsIC8vIHNhbXBsZV9zaXplXFxuICAgICAgaXRlbS5zaXplID4+PiAxNiAmIDB4RkYsIGl0ZW0uc2l6ZSA+Pj4gOCAmIDB4RkYsIGl0ZW0uc2l6ZSAmIDB4RkYsIGZsYWdzLmlzTGVhZGluZyA8PCAyIHwgZmxhZ3MuZGVwZW5kc09uLCAvLyBzYW1wbGVfZmxhZ3NcXG4gICAgICBmbGFncy5pc0RlcGVuZGVkT24gPDwgNiB8IGZsYWdzLmhhc1JlZHVuZGFuY3kgPDwgNCB8IGZsYWdzLmlzTm9uU3luYywgMHgwMCwgMHgwMCwgLy8gc2FtcGxlX2RlZ3JhZGF0aW9uX3ByaW9yaXR5XFxuICAgICAgaXRlbS5jdHMgPj4+IDI0ICYgMHhGRiwgLy8gc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XFxuICAgICAgaXRlbS5jdHMgPj4+IDE2ICYgMHhGRiwgaXRlbS5jdHMgPj4+IDggJiAweEZGLCBpdGVtLmN0cyAmIDB4RkZdKSk7XFxuICAgICAgLy8gd3JpdGVPZmZzZXQgKz0gMTZcXG4gICAgICAvLyBidWZmZXIud3JpdGUoQnVmZmVyLndyaXRlVWludDMyKDApKTtcXG4gICAgfSk7XFxuICAgIHJldHVybiBidWZmZXIuYnVmZmVyO1xcbiAgfVxcbiAgc3RhdGljIHNkdHAoZGF0YSkge1xcbiAgICBsZXQgYnVmZmVyID0gbmV3IF94Z3BsYXllclV0aWxzLkJ1ZmZlcigpO1xcbiAgICBidWZmZXIud3JpdGUoRm1wNC5zaXplKDEyICsgZGF0YS5zYW1wbGVzLmxlbmd0aCksIEZtcDQudHlwZSgnc2R0cCcpLCBGbXA0LmV4dGVuc2lvbigwLCAwKSk7XFxuICAgIGRhdGEuc2FtcGxlcy5mb3JFYWNoKGl0ZW0gPT4ge1xcbiAgICAgIGNvbnN0IGZsYWdzID0gaXRlbS5mbGFncztcXG4gICAgICBjb25zdCBudW0gPSBmbGFncy5pc0xlYWRpbmcgPDwgNiB8IC8vIGlzX2xlYWRpbmc6IDIgKGJpdClcXG4gICAgICBmbGFncy5kZXBlbmRzT24gPDwgNCB8IC8vIHNhbXBsZV9kZXBlbmRzX29uXFxuICAgICAgZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDIgfCAvLyBzYW1wbGVfaXNfZGVwZW5kZWRfb25cXG4gICAgICBmbGFncy5oYXNSZWR1bmRhbmN5OyAvLyBzYW1wbGVfaGFzX3JlZHVuZGFuY3lcXG5cXG4gICAgICBidWZmZXIud3JpdGUobmV3IFVpbnQ4QXJyYXkoW251bV0pKTtcXG4gICAgfSk7XFxuICAgIHJldHVybiBidWZmZXIuYnVmZmVyO1xcbiAgfVxcbiAgc3RhdGljIG1kYXQoZGF0YSkge1xcbiAgICBsZXQgYnVmZmVyID0gbmV3IF94Z3BsYXllclV0aWxzLkJ1ZmZlcigpO1xcbiAgICBsZXQgc2l6ZSA9IDg7XFxuICAgIGRhdGEuc2FtcGxlcy5mb3JFYWNoKGl0ZW0gPT4ge1xcbiAgICAgIHNpemUgKz0gaXRlbS5zaXplO1xcbiAgICB9KTtcXG4gICAgYnVmZmVyLndyaXRlKEZtcDQuc2l6ZShzaXplKSwgRm1wNC50eXBlKCdtZGF0JykpO1xcbiAgICBsZXQgbWRhdEJveCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xcbiAgICBsZXQgb2Zmc2V0ID0gMDtcXG4gICAgbWRhdEJveC5zZXQoYnVmZmVyLmJ1ZmZlciwgb2Zmc2V0KTtcXG4gICAgb2Zmc2V0ICs9IDg7XFxuICAgIGRhdGEuc2FtcGxlcy5mb3JFYWNoKGl0ZW0gPT4ge1xcbiAgICAgIGl0ZW0uYnVmZmVyLmZvckVhY2godW5pdCA9PiB7XFxuICAgICAgICBtZGF0Qm94LnNldCh1bml0LCBvZmZzZXQpO1xcbiAgICAgICAgb2Zmc2V0ICs9IHVuaXQuYnl0ZUxlbmd0aDtcXG4gICAgICAgIC8vIGJ1ZmZlci53cml0ZSh1bml0LmRhdGEpO1xcbiAgICAgIH0pO1xcbiAgICB9KTtcXG4gICAgcmV0dXJuIG1kYXRCb3g7XFxuICB9XFxufVxcbkZtcDQudHlwZSA9IG5hbWUgPT4ge1xcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtuYW1lLmNoYXJDb2RlQXQoMCksIG5hbWUuY2hhckNvZGVBdCgxKSwgbmFtZS5jaGFyQ29kZUF0KDIpLCBuYW1lLmNoYXJDb2RlQXQoMyldKTtcXG59O1xcbkZtcDQuc2VxdWVuY2UgPSAxO1xcblxcbmV4cG9ydHMuZGVmYXVsdCA9IEZtcDQ7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXJlbXV4L3NyYy9tcDQvZm1wNC5qcz9cIil9LFwiLi4veGdwbGF5ZXItcmVtdXgvc3JjL21wNC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXJlbXV4L3NyYy9tcDQvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBfeGdwbGF5ZXJVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHhncGxheWVyLXV0aWxzICovIFxcXCIuLi94Z3BsYXllci11dGlscy9pbmRleC5qc1xcXCIpO1xcblxcbnZhciBfZm1wID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mbXA0ICovIFxcXCIuLi94Z3BsYXllci1yZW11eC9zcmMvbXA0L2ZtcDQuanNcXFwiKTtcXG5cXG52YXIgX2ZtcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mbXApO1xcblxcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFxuY29uc3QgUkVNVVhfRVZFTlRTID0gX3hncGxheWVyVXRpbHMuRVZFTlRTLlJFTVVYX0VWRU5UUztcXG5cXG5jbGFzcyBNcDRSZW11eGVyIHtcXG4gIGNvbnN0cnVjdG9yKCkge1xcbiAgICB0aGlzLl9kdHNCYXNlID0gMDtcXG4gICAgdGhpcy5faXNEdHNCYXNlSW5pdGVkID0gZmFsc2U7XFxuXFxuICAgIHRoaXMuaXNGaXJzdFZpZGVvID0gdHJ1ZTtcXG4gICAgdGhpcy5pc0ZpcnN0QXVkaW8gPSB0cnVlO1xcblxcbiAgICB0aGlzLnZpZGVvQWxsRHVyYXRpb24gPSAwO1xcbiAgICB0aGlzLmF1ZGlvQWxsRHVyYXRpb24gPSAwO1xcbiAgfVxcblxcbiAgaW5pdCgpIHtcXG4gICAgdGhpcy5vbihSRU1VWF9FVkVOVFMuUkVNVVhfTUVESUEsIHRoaXMucmVtdXguYmluZCh0aGlzKSk7XFxuICAgIHRoaXMub24oUkVNVVhfRVZFTlRTLlJFTVVYX01FVEFEQVRBLCB0aGlzLm9uTWV0YURhdGFSZWFkeS5iaW5kKHRoaXMpKTtcXG4gICAgdGhpcy5vbihSRU1VWF9FVkVOVFMuREVURUNUX0NIQU5HRV9TVFJFQU0sIHRoaXMucmVzZXREdHNCYXNlLmJpbmQodGhpcykpO1xcbiAgfVxcblxcbiAgZGVzdHJveSgpIHtcXG4gICAgdGhpcy5fZHRzQmFzZSA9IC0xO1xcbiAgICB0aGlzLl9kdHNCYXNlSW5pdGVkID0gZmFsc2U7XFxuICB9XFxuXFxuICByZXNldCgpIHtcXG4gICAgdGhpcy5fZHRzQmFzZSA9IDA7XFxuICAgIHRoaXMuX2lzRHRzQmFzZUluaXRlZCA9IGZhbHNlO1xcbiAgfVxcblxcbiAgcmVtdXgoKSB7XFxuICAgIGNvbnN0IHsgYXVkaW9UcmFjaywgdmlkZW9UcmFjayB9ID0gdGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZSgnVFJBQ0tTJyk7XFxuICAgICF0aGlzLl9pc0R0c0Jhc2VJbml0ZWQgJiYgdGhpcy5jYWxjRHRzQmFzZShhdWRpb1RyYWNrLCB2aWRlb1RyYWNrKTtcXG5cXG4gICAgdGhpcy5fcmVtdXhWaWRlbyh2aWRlb1RyYWNrKTtcXG4gICAgdGhpcy5fcmVtdXhBdWRpbyhhdWRpb1RyYWNrKTtcXG4gIH1cXG5cXG4gIHJlc2V0RHRzQmFzZSgpIHtcXG4gICAgLy8gZm9yIGhscyDkuK3pgJTliIfmjaIgbWV0YeWQjnNlZWtcXG4gICAgdGhpcy5fZHRzQmFzZSA9IDA7XFxuICAgIHRoaXMuX2R0c0Jhc2VJbml0ZWQgPSBmYWxzZTtcXG4gIH1cXG5cXG4gIHNlZWsoKSB7fVxcblxcbiAgb25NZXRhRGF0YVJlYWR5KHR5cGUpIHtcXG4gICAgbGV0IHRyYWNrO1xcblxcbiAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJykge1xcbiAgICAgIGNvbnN0IHsgYXVkaW9UcmFjayB9ID0gdGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZSgnVFJBQ0tTJyk7XFxuICAgICAgdHJhY2sgPSBhdWRpb1RyYWNrO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNvbnN0IHsgdmlkZW9UcmFjayB9ID0gdGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZSgnVFJBQ0tTJyk7XFxuICAgICAgdHJhY2sgPSB2aWRlb1RyYWNrO1xcbiAgICB9XFxuXFxuICAgIGxldCBwcmVzb3VyY2VidWZmZXIgPSB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKCdQUkVfU09VUkNFX0JVRkZFUicpO1xcbiAgICBsZXQgc291cmNlID0gcHJlc291cmNlYnVmZmVyLmdldFNvdXJjZSh0eXBlKTtcXG4gICAgaWYgKCFzb3VyY2UpIHtcXG4gICAgICBzb3VyY2UgPSBwcmVzb3VyY2VidWZmZXIuY3JlYXRlU291cmNlKHR5cGUpO1xcbiAgICB9XFxuXFxuICAgIHNvdXJjZS5taW1ldHlwZSA9IHRyYWNrLm1ldGEuY29kZWM7XFxuICAgIHNvdXJjZS5pbml0ID0gdGhpcy5yZW11eEluaXRTZWdtZW50KHR5cGUsIHRyYWNrLm1ldGEpO1xcbiAgICAvLyBzb3VyY2UuaW5pdGVkID0gZmFsc2U7XFxuXFxuICAgIC8vIHRoaXMucmVzZXREdHNCYXNlKClcXG4gICAgdGhpcy5lbWl0KFJFTVVYX0VWRU5UUy5JTklUX1NFR01FTlQsIHR5cGUpO1xcbiAgfVxcblxcbiAgcmVtdXhJbml0U2VnbWVudCh0eXBlLCBtZXRhKSB7XFxuICAgIGxldCBpbml0U2VnbWVudCA9IG5ldyBfeGdwbGF5ZXJVdGlscy5CdWZmZXIoKTtcXG4gICAgbGV0IGZ0eXAgPSBfZm1wMi5kZWZhdWx0LmZ0eXAoKTtcXG4gICAgbGV0IG1vb3YgPSBfZm1wMi5kZWZhdWx0Lm1vb3YoeyB0eXBlLCBtZXRhOiBtZXRhIH0pO1xcblxcbiAgICBpbml0U2VnbWVudC53cml0ZShmdHlwLCBtb292KTtcXG4gICAgcmV0dXJuIGluaXRTZWdtZW50O1xcbiAgfVxcblxcbiAgY2FsY0R0c0Jhc2UoYXVkaW9UcmFjaywgdmlkZW9UcmFjaykge1xcbiAgICBpZiAoIWF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGggJiYgIXZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgbGV0IGF1ZGlvQmFzZSA9IEluZmluaXR5O1xcbiAgICBsZXQgdmlkZW9CYXNlID0gSW5maW5pdHk7XFxuXFxuICAgIGlmIChhdWRpb1RyYWNrLnNhbXBsZXMgJiYgYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCkge1xcbiAgICAgIGF1ZGlvQmFzZSA9IGF1ZGlvVHJhY2suc2FtcGxlc1swXS5kdHM7XFxuICAgIH1cXG4gICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcyAmJiB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XFxuICAgICAgdmlkZW9CYXNlID0gdmlkZW9UcmFjay5zYW1wbGVzWzBdLmR0cztcXG4gICAgfVxcblxcbiAgICB0aGlzLl9kdHNCYXNlID0gTWF0aC5taW4oYXVkaW9CYXNlLCB2aWRlb0Jhc2UpO1xcbiAgICB0aGlzLl9pc0R0c0Jhc2VJbml0ZWQgPSB0cnVlO1xcbiAgfVxcblxcbiAgX3JlbXV4VmlkZW8odmlkZW9UcmFjaykge1xcbiAgICBjb25zdCB0cmFjayA9IHZpZGVvVHJhY2s7XFxuXFxuICAgIGlmICghdmlkZW9UcmFjay5zYW1wbGVzIHx8ICF2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGxldCB7IHNhbXBsZXMgfSA9IHRyYWNrO1xcbiAgICBsZXQgZmlyc3REdHMgPSAtMTtcXG5cXG4gICAgbGV0IGluaXRTZWdtZW50ID0gbnVsbDtcXG4gICAgY29uc3QgbXA0U2FtcGxlcyA9IFtdO1xcbiAgICBjb25zdCBtZGF0Qm94ID0ge1xcbiAgICAgIHNhbXBsZXM6IFtdXFxuICAgIH07XFxuXFxuICAgIHdoaWxlIChzYW1wbGVzLmxlbmd0aCkge1xcbiAgICAgIGNvbnN0IGF2Y1NhbXBsZSA9IHNhbXBsZXMuc2hpZnQoKTtcXG5cXG4gICAgICBjb25zdCB7IGlzS2V5ZnJhbWUsIG9wdGlvbnMgfSA9IGF2Y1NhbXBsZTtcXG4gICAgICBpZiAoIXRoaXMuaXNGaXJzdEF1ZGlvICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5tZXRhKSB7XFxuICAgICAgICBpbml0U2VnbWVudCA9IHRoaXMucmVtdXhJbml0U2VnbWVudCgndmlkZW8nLCBvcHRpb25zLm1ldGEpO1xcbiAgICAgICAgb3B0aW9ucy5tZXRhID0gbnVsbDtcXG4gICAgICAgIHNhbXBsZXMudW5zaGlmdChhdmNTYW1wbGUpO1xcbiAgICAgICAgaWYgKCFvcHRpb25zLmlzQ29udGludWUpIHtcXG4gICAgICAgICAgdGhpcy5yZXNldER0c0Jhc2UoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG5cXG4gICAgICBsZXQgZHRzID0gYXZjU2FtcGxlLmR0cyAtIHRoaXMuX2R0c0Jhc2U7XFxuXFxuICAgICAgaWYgKGZpcnN0RHRzID09PSAtMSkge1xcbiAgICAgICAgZmlyc3REdHMgPSBkdHM7XFxuICAgICAgfVxcblxcbiAgICAgIGxldCBjdHM7XFxuICAgICAgbGV0IHB0cztcXG4gICAgICBpZiAoYXZjU2FtcGxlLnB0cyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBwdHMgPSBhdmNTYW1wbGUucHRzIC0gdGhpcy5fZHRzQmFzZTtcXG4gICAgICAgIGN0cyA9IHB0cyAtIGR0cztcXG4gICAgICB9XFxuICAgICAgaWYgKGF2Y1NhbXBsZS5jdHMgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgcHRzID0gYXZjU2FtcGxlLmN0cyArIGR0cztcXG4gICAgICAgIGN0cyA9IGF2Y1NhbXBsZS5jdHM7XFxuICAgICAgfVxcblxcbiAgICAgIGxldCBtZGF0U2FtcGxlID0ge1xcbiAgICAgICAgYnVmZmVyOiBbXSxcXG4gICAgICAgIHNpemU6IDBcXG4gICAgICB9O1xcbiAgICAgIG1kYXRCb3guc2FtcGxlcy5wdXNoKG1kYXRTYW1wbGUpO1xcbiAgICAgIG1kYXRTYW1wbGUuYnVmZmVyLnB1c2goYXZjU2FtcGxlLmRhdGEpO1xcbiAgICAgIG1kYXRTYW1wbGUuc2l6ZSArPSBhdmNTYW1wbGUuZGF0YS5ieXRlTGVuZ3RoO1xcblxcbiAgICAgIGxldCBzYW1wbGVEdXJhdGlvbiA9IDA7XFxuICAgICAgaWYgKHNhbXBsZXMubGVuZ3RoID49IDEpIHtcXG4gICAgICAgIGNvbnN0IG5leHREdHMgPSBzYW1wbGVzWzBdLmR0cyAtIHRoaXMuX2R0c0Jhc2U7XFxuICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IG5leHREdHMgLSBkdHM7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmIChtcDRTYW1wbGVzLmxlbmd0aCA+PSAxKSB7XFxuICAgICAgICAgIC8vIGxhc3Rlc3Qgc2FtcGxlLCB1c2Ugc2Vjb25kIGxhc3QgZHVyYXRpb25cXG4gICAgICAgICAgc2FtcGxlRHVyYXRpb24gPSBtcDRTYW1wbGVzW21wNFNhbXBsZXMubGVuZ3RoIC0gMV0uZHVyYXRpb247XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAvLyB0aGUgb25seSBvbmUgc2FtcGxlLCB1c2UgcmVmZXJlbmNlIGR1cmF0aW9uXFxuICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gdGhpcy52aWRlb01ldGEucmVmU2FtcGxlRHVyYXRpb247XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHRoaXMudmlkZW9BbGxEdXJhdGlvbiArPSBzYW1wbGVEdXJhdGlvbjtcXG4gICAgICAvLyBjb25zb2xlLmxvZyhgZHRzICR7ZHRzfWAsIGBwdHMgJHtwdHN9YCwgYGN0czogJHtjdHN9YCwgYGR1cmF0aW9uOiAke3NhbXBsZUR1cmF0aW9ufWAsIGF2Y1NhbXBsZSlcXG4gICAgICBtcDRTYW1wbGVzLnB1c2goe1xcbiAgICAgICAgZHRzLFxcbiAgICAgICAgY3RzLFxcbiAgICAgICAgcHRzLFxcbiAgICAgICAgZGF0YTogYXZjU2FtcGxlLmRhdGEsXFxuICAgICAgICBzaXplOiBhdmNTYW1wbGUuZGF0YS5ieXRlTGVuZ3RoLFxcbiAgICAgICAgaXNLZXlmcmFtZSxcXG4gICAgICAgIGR1cmF0aW9uOiBzYW1wbGVEdXJhdGlvbixcXG4gICAgICAgIGZsYWdzOiB7XFxuICAgICAgICAgIGlzTGVhZGluZzogMCxcXG4gICAgICAgICAgZGVwZW5kc09uOiBpc0tleWZyYW1lID8gMiA6IDEsXFxuICAgICAgICAgIGlzRGVwZW5kZWRPbjogaXNLZXlmcmFtZSA/IDEgOiAwLFxcbiAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxcbiAgICAgICAgICBpc05vblN5bmM6IGlzS2V5ZnJhbWUgPyAwIDogMVxcbiAgICAgICAgfSxcXG4gICAgICAgIG9yaWdpbkR0czogZHRzLFxcbiAgICAgICAgdHlwZTogJ3ZpZGVvJ1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGxldCBtb29mTWRhdCA9IG5ldyBfeGdwbGF5ZXJVdGlscy5CdWZmZXIoKTtcXG4gICAgaWYgKG1wNFNhbXBsZXMubGVuZ3RoKSB7XFxuICAgICAgY29uc3QgbW9vZiA9IF9mbXAyLmRlZmF1bHQubW9vZih7XFxuICAgICAgICBpZDogdHJhY2subWV0YS5pZCxcXG4gICAgICAgIHRpbWU6IGZpcnN0RHRzLFxcbiAgICAgICAgc2FtcGxlczogbXA0U2FtcGxlc1xcbiAgICAgIH0pO1xcbiAgICAgIGNvbnN0IG1kYXQgPSBfZm1wMi5kZWZhdWx0Lm1kYXQobWRhdEJveCk7XFxuICAgICAgbW9vZk1kYXQud3JpdGUobW9vZiwgbWRhdCk7XFxuXFxuICAgICAgdGhpcy53cml0ZVRvU291cmNlKCd2aWRlbycsIG1vb2ZNZGF0KTtcXG4gICAgfVxcblxcbiAgICBpZiAoaW5pdFNlZ21lbnQpIHtcXG4gICAgICB0aGlzLndyaXRlVG9Tb3VyY2UoJ3ZpZGVvJywgaW5pdFNlZ21lbnQpO1xcblxcbiAgICAgIGlmIChzYW1wbGVzLmxlbmd0aCkge1xcbiAgICAgICAgLy8gc2Vjb25kIHBhcnQgb2Ygc3RyZWFtIGNoYW5nZVxcbiAgICAgICAgdHJhY2suc2FtcGxlcyA9IHNhbXBsZXM7XFxuICAgICAgICByZXR1cm4gdGhpcy5fcmVtdXhWaWRlbyh0cmFjayk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHRoaXMuaXNGaXJzdFZpZGVvID0gZmFsc2U7XFxuICAgIHRoaXMuZW1pdChSRU1VWF9FVkVOVFMuTUVESUFfU0VHTUVOVCwgJ3ZpZGVvJyk7XFxuXFxuICAgIGNvbnN0IGxhc3RTYW1wbGUgPSBtcDRTYW1wbGVzW21wNFNhbXBsZXMubGVuZ3RoIC0gMV07XFxuICAgIHRoaXMuX3ZpZGVvTmV4dER0cyA9IGxhc3RTYW1wbGUuZHRzICsgbGFzdFNhbXBsZS5kdXJhdGlvbjtcXG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xcbiAgICB0cmFjay5sZW5ndGggPSAwO1xcbiAgfVxcblxcbiAgX3JlbXV4QXVkaW8odHJhY2spIHtcXG4gICAgY29uc3QgeyBzYW1wbGVzIH0gPSB0cmFjaztcXG4gICAgbGV0IGZpcnN0RHRzID0gLTE7XFxuICAgIGxldCBtcDRTYW1wbGVzID0gW107XFxuXFxuICAgIGxldCBpbml0U2VnbWVudCA9IG51bGw7XFxuICAgIGNvbnN0IG1kYXRCb3ggPSB7XFxuICAgICAgc2FtcGxlczogW11cXG4gICAgfTtcXG4gICAgaWYgKCFzYW1wbGVzIHx8ICFzYW1wbGVzLmxlbmd0aCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBsZXQgaXNGaXJzdER0c0luaXRlZCA9IGZhbHNlO1xcbiAgICB3aGlsZSAoc2FtcGxlcy5sZW5ndGgpIHtcXG4gICAgICBsZXQgc2FtcGxlID0gc2FtcGxlcy5zaGlmdCgpO1xcbiAgICAgIGNvbnN0IHsgZGF0YSwgb3B0aW9ucyB9ID0gc2FtcGxlO1xcbiAgICAgIGlmICghdGhpcy5pc0ZpcnN0QXVkaW8gJiYgb3B0aW9ucyAmJiBvcHRpb25zLm1ldGEpIHtcXG4gICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5yZW11eEluaXRTZWdtZW50KCdhdWRpbycsIG9wdGlvbnMubWV0YSk7XFxuICAgICAgICBvcHRpb25zLm1ldGEgPSBudWxsO1xcbiAgICAgICAgc2FtcGxlcy51bnNoaWZ0KHNhbXBsZSk7XFxuICAgICAgICBpZiAoIW9wdGlvbnMuaXNDb250aW51ZSkge1xcbiAgICAgICAgICB0aGlzLnJlc2V0RHRzQmFzZSgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcblxcbiAgICAgIGxldCBkdHMgPSBzYW1wbGUuZHRzIC0gdGhpcy5fZHRzQmFzZTtcXG4gICAgICBjb25zdCBvcmlnaW5EdHMgPSBkdHM7XFxuICAgICAgaWYgKCFpc0ZpcnN0RHRzSW5pdGVkKSB7XFxuICAgICAgICBmaXJzdER0cyA9IGR0cztcXG4gICAgICAgIGlzRmlyc3REdHNJbml0ZWQgPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBsZXQgc2FtcGxlRHVyYXRpb24gPSAwO1xcblxcbiAgICAgIGlmICh0aGlzLmF1ZGlvTWV0YS5yZWZTYW1wbGVEdXJhdGlvbkZpeGVkKSB7XFxuICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHRoaXMuYXVkaW9NZXRhLnJlZlNhbXBsZUR1cmF0aW9uRml4ZWQ7XFxuICAgICAgfSBlbHNlIGlmIChzYW1wbGVzLmxlbmd0aCA+PSAxKSB7XFxuICAgICAgICBjb25zdCBuZXh0RHRzID0gc2FtcGxlc1swXS5kdHMgLSB0aGlzLl9kdHNCYXNlO1xcbiAgICAgICAgc2FtcGxlRHVyYXRpb24gPSBuZXh0RHRzIC0gZHRzO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAobXA0U2FtcGxlcy5sZW5ndGggPj0gMSkge1xcbiAgICAgICAgICAvLyB1c2Ugc2Vjb25kIGxhc3Qgc2FtcGxlIGR1cmF0aW9uXFxuICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gbXA0U2FtcGxlc1ttcDRTYW1wbGVzLmxlbmd0aCAtIDFdLmR1cmF0aW9uO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy8gdGhlIG9ubHkgb25lIHNhbXBsZSwgdXNlIHJlZmVyZW5jZSBzYW1wbGUgZHVyYXRpb25cXG4gICAgICAgICAgc2FtcGxlRHVyYXRpb24gPSB0aGlzLmF1ZGlvTWV0YS5yZWZTYW1wbGVEdXJhdGlvbjtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLy8gY29uc29sZS5sb2coJ3JlbXV4IGF1ZGlvICcsIGR0cylcXG4gICAgICB0aGlzLmF1ZGlvQWxsRHVyYXRpb24gKz0gc2FtcGxlRHVyYXRpb247XFxuICAgICAgY29uc3QgbXA0U2FtcGxlID0ge1xcbiAgICAgICAgZHRzLFxcbiAgICAgICAgcHRzOiBkdHMsXFxuICAgICAgICBjdHM6IDAsXFxuICAgICAgICBzaXplOiBkYXRhLmJ5dGVMZW5ndGgsXFxuICAgICAgICBkdXJhdGlvbjogc2FtcGxlLmR1cmF0aW9uID8gc2FtcGxlLmR1cmF0aW9uIDogc2FtcGxlRHVyYXRpb24sXFxuICAgICAgICBmbGFnczoge1xcbiAgICAgICAgICBpc0xlYWRpbmc6IDAsXFxuICAgICAgICAgIGRlcGVuZHNPbjogMixcXG4gICAgICAgICAgaXNEZXBlbmRlZE9uOiAxLFxcbiAgICAgICAgICBoYXNSZWR1bmRhbmN5OiAwLFxcbiAgICAgICAgICBpc05vblN5bmM6IDBcXG4gICAgICAgIH0sXFxuICAgICAgICBpc0tleWZyYW1lOiB0cnVlLFxcbiAgICAgICAgb3JpZ2luRHRzLFxcbiAgICAgICAgdHlwZTogJ2F1ZGlvJ1xcbiAgICAgIH07XFxuXFxuICAgICAgbGV0IG1kYXRTYW1wbGUgPSB7XFxuICAgICAgICBidWZmZXI6IFtdLFxcbiAgICAgICAgc2l6ZTogMFxcbiAgICAgIH07XFxuICAgICAgbWRhdFNhbXBsZS5idWZmZXIucHVzaChkYXRhKTtcXG4gICAgICBtZGF0U2FtcGxlLnNpemUgKz0gZGF0YS5ieXRlTGVuZ3RoO1xcblxcbiAgICAgIG1kYXRCb3guc2FtcGxlcy5wdXNoKG1kYXRTYW1wbGUpO1xcblxcbiAgICAgIG1wNFNhbXBsZXMucHVzaChtcDRTYW1wbGUpO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IG1vb2ZNZGF0ID0gbmV3IF94Z3BsYXllclV0aWxzLkJ1ZmZlcigpO1xcblxcbiAgICBpZiAobXA0U2FtcGxlcy5sZW5ndGgpIHtcXG4gICAgICBjb25zdCBtb29mID0gX2ZtcDIuZGVmYXVsdC5tb29mKHtcXG4gICAgICAgIGlkOiB0cmFjay5tZXRhLmlkLFxcbiAgICAgICAgdGltZTogZmlyc3REdHMsXFxuICAgICAgICBzYW1wbGVzOiBtcDRTYW1wbGVzXFxuICAgICAgfSk7XFxuICAgICAgY29uc3QgbWRhdCA9IF9mbXAyLmRlZmF1bHQubWRhdChtZGF0Qm94KTtcXG4gICAgICBtb29mTWRhdC53cml0ZShtb29mLCBtZGF0KTtcXG5cXG4gICAgICB0aGlzLndyaXRlVG9Tb3VyY2UoJ2F1ZGlvJywgbW9vZk1kYXQpO1xcbiAgICB9XFxuXFxuICAgIGlmIChpbml0U2VnbWVudCkge1xcbiAgICAgIHRoaXMud3JpdGVUb1NvdXJjZSgnYXVkaW8nLCBpbml0U2VnbWVudCk7XFxuICAgICAgaWYgKHNhbXBsZXMubGVuZ3RoKSB7XFxuICAgICAgICAvLyBzZWNvbmQgcGFydCBvZiBzdHJlYW0gY2hhbmdlXFxuICAgICAgICB0cmFjay5zYW1wbGVzID0gc2FtcGxlcztcXG4gICAgICAgIHJldHVybiB0aGlzLl9yZW11eEF1ZGlvKHRyYWNrKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdGhpcy5pc0ZpcnN0QXVkaW8gPSBmYWxzZTtcXG4gICAgdGhpcy5lbWl0KFJFTVVYX0VWRU5UUy5NRURJQV9TRUdNRU5ULCAnYXVkaW8nLCBtb29mTWRhdCk7XFxuXFxuICAgIGNvbnN0IGxhc3RTYW1wbGUgPSBtcDRTYW1wbGVzW21wNFNhbXBsZXMubGVuZ3RoIC0gMV07XFxuICAgIHRoaXMuX3ZpZGVvTmV4dER0cyA9IGxhc3RTYW1wbGUuZHRzICsgbGFzdFNhbXBsZS5kdXJhdGlvbjtcXG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xcbiAgICB0cmFjay5sZW5ndGggPSAwO1xcbiAgfVxcblxcbiAgd3JpdGVUb1NvdXJjZSh0eXBlLCBidWZmZXIpIHtcXG4gICAgbGV0IHByZXNvdXJjZWJ1ZmZlciA9IHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoJ1BSRV9TT1VSQ0VfQlVGRkVSJyk7XFxuICAgIGxldCBzb3VyY2UgPSBwcmVzb3VyY2VidWZmZXIuZ2V0U291cmNlKHR5cGUpO1xcbiAgICBpZiAoIXNvdXJjZSkge1xcbiAgICAgIHNvdXJjZSA9IHByZXNvdXJjZWJ1ZmZlci5jcmVhdGVTb3VyY2UodHlwZSk7XFxuICAgIH1cXG5cXG4gICAgc291cmNlLmRhdGEucHVzaChidWZmZXIpO1xcbiAgfVxcblxcbiAgaW5pdFNpbGVudEF1ZGlvKGR0cywgZHVyYXRpb24pIHtcXG4gICAgY29uc3QgdW5pdCA9IE1wNFJlbXV4ZXIuZ2V0U2lsZW50RnJhbWUodGhpcy5hdWRpb01ldGEuY2hhbm5lbENvdW50KTtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBkdHMsXFxuICAgICAgcHRzOiBkdHMsXFxuICAgICAgY3RzOiAwLFxcbiAgICAgIGR1cmF0aW9uLFxcbiAgICAgIHVuaXQsXFxuICAgICAgc2l6ZTogdW5pdC5ieXRlTGVuZ3RoLFxcbiAgICAgIG9yaWdpbkR0czogZHRzLFxcbiAgICAgIHR5cGU6ICd2aWRlbydcXG4gICAgfTtcXG4gIH1cXG5cXG4gIGdldCB2aWRlb01ldGEoKSB7XFxuICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKCdUUkFDS1MnKS52aWRlb1RyYWNrLm1ldGE7XFxuICB9XFxuICBnZXQgYXVkaW9NZXRhKCkge1xcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZSgnVFJBQ0tTJykuYXVkaW9UcmFjay5tZXRhO1xcbiAgfVxcblxcbiAgc3RhdGljIGdldFNpbGVudEZyYW1lKGNoYW5uZWxDb3VudCkge1xcbiAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XFxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIzLCAweDgwXSk7XFxuICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XFxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDIxLCAweDAwLCAweDQ5LCAweDkwLCAweDAyLCAweDE5LCAweDAwLCAweDIzLCAweDgwXSk7XFxuICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XFxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDhlXSk7XFxuICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA0KSB7XFxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgwLCAweDJjLCAweDgwLCAweDA4LCAweDAyLCAweDM4XSk7XFxuICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA1KSB7XFxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDM4XSk7XFxuICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA2KSB7XFxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDAwLCAweGIyLCAweDAwLCAweDIwLCAweDA4LCAweGUwXSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIG51bGw7XFxuICB9XFxufVxcbmV4cG9ydHMuZGVmYXVsdCA9IE1wNFJlbXV4ZXI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXJlbXV4L3NyYy9tcDQvaW5kZXguanM/XCIpfSxcIi4uL3hncGxheWVyLXV0aWxzL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXV0aWxzL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbCgnXFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBDb250ZXh0OiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9jb250ZXh0ICovIFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL2NvbnRleHQuanNcIikuZGVmYXVsdCxcXG5cXG4gIC8vIE1vZHVsZXMgZnJvbSBjb25zdGFudHNcXG4gIEVWRU5UUzogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvY29uc3RhbnRzL2V2ZW50cyAqLyBcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9jb25zdGFudHMvZXZlbnRzLmpzXCIpLmRlZmF1bHQsXFxuICBXT1JLRVJfQ09NTUFORFM6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2NvbnN0YW50cy93b3JrZXItY29tbWFuZHMgKi8gXCIuLi94Z3BsYXllci11dGlscy9zcmMvY29uc3RhbnRzL3dvcmtlci1jb21tYW5kcy5qc1wiKS5kZWZhdWx0LFxcblxcbiAgLy8gTW9kdWxlcyBmcm9tIGVudlxcbiAgc25pZmZlcjogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvZW52L3NuaWZmZXIgKi8gXCIuLi94Z3BsYXllci11dGlscy9zcmMvZW52L3NuaWZmZXIuanNcIikuZGVmYXVsdCxcXG4gIGlzTGU6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2Vudi9pc2xlICovIFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL2Vudi9pc2xlLmpzXCIpLmRlZmF1bHQsXFxuICBVVEY4OiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9lbnYvdXRmOCAqLyBcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9lbnYvdXRmOC5qc1wiKS5kZWZhdWx0LFxcblxcbiAgLy8gTW9kZWxzXFxuICBNZWRpYUluZm86IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL21vZGVscy9tZWRpYS1pbmZvICovIFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vZGVscy9tZWRpYS1pbmZvLmpzXCIpLmRlZmF1bHQsXFxuICBNZWRpYVNhbXBsZTogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvbW9kZWxzL21lZGlhLXNhbXBsZSAqLyBcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvbWVkaWEtc2FtcGxlLmpzXCIpLmRlZmF1bHQsXFxuICBNZWRpYVNlZ21lbnQ6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL21vZGVscy9tZWRpYS1zZWdtZW50ICovIFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vZGVscy9tZWRpYS1zZWdtZW50LmpzXCIpLmRlZmF1bHQsXFxuICBNZWRpYVNlZ21lbnRMaXN0OiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9tb2RlbHMvbWVkaWEtc2VnbWVudC1saXN0ICovIFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vZGVscy9tZWRpYS1zZWdtZW50LWxpc3QuanNcIikuZGVmYXVsdCxcXG4gIEF1ZGlvVHJhY2tNZXRhOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9tb2RlbHMvdHJhY2stbWV0YSAqLyBcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvdHJhY2stbWV0YS5qc1wiKS5BdWRpb1RyYWNrTWV0YSxcXG4gIFZpZGVvVHJhY2tNZXRhOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9tb2RlbHMvdHJhY2stbWV0YSAqLyBcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvdHJhY2stbWV0YS5qc1wiKS5WaWRlb1RyYWNrTWV0YSxcXG4gIEF1ZGlvVHJhY2tTYW1wbGU6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL21vZGVscy90cmFjay1zYW1wbGUgKi8gXCIuLi94Z3BsYXllci11dGlscy9zcmMvbW9kZWxzL3RyYWNrLXNhbXBsZS5qc1wiKS5BdWRpb1RyYWNrU2FtcGxlLFxcbiAgVmlkZW9UcmFja1NhbXBsZTogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvbW9kZWxzL3RyYWNrLXNhbXBsZSAqLyBcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvdHJhY2stc2FtcGxlLmpzXCIpLlZpZGVvVHJhY2tTYW1wbGUsXFxuXFxuICAvLyBNb2R1bGVzIGZyb20gbXNlXFxuICBNc2U6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL21zZS9pbmRleCAqLyBcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tc2UvaW5kZXguanNcIikuZGVmYXVsdCxcXG5cXG4gIC8vIE1vZHVsZXMgZnJvbSB3cml0ZVxcbiAgU3RyZWFtOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy93cml0ZS9zdHJlYW0gKi8gXCIuLi94Z3BsYXllci11dGlscy9zcmMvd3JpdGUvc3RyZWFtLmpzXCIpLmRlZmF1bHQsXFxuICBCdWZmZXI6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3dyaXRlL2J1ZmZlciAqLyBcIi4uL3hncGxheWVyLXV0aWxzL3NyYy93cml0ZS9idWZmZXIuanNcIikuZGVmYXVsdCxcXG5cXG4gIE1vYmlsZVZpZGVvOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9tb2JpbGUvbW9iaWxlLXZpZGVvICovIFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vYmlsZS9tb2JpbGUtdmlkZW8uanNcIiksXFxuICAvLyBDcnlwdG9cXG4gIENyeXB0bzogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvY3J5cHRvICovIFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL2NyeXB0by9pbmRleC5qc1wiKS5kZWZhdWx0XFxufTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItdXRpbHMvaW5kZXguanM/Jyl9LFwiLi4veGdwbGF5ZXItdXRpbHMvbm9kZV9tb2R1bGVzL2NvbmNhdC10eXBlZC1hcnJheS9saWIvY29uY2F0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci11dGlscy9ub2RlX21vZHVsZXMvY29uY2F0LXR5cGVkLWFycmF5L2xpYi9jb25jYXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbCgnXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChSZXN1bHRDb25zdHJ1Y3Rvcikge1xcbiAgdmFyIHRvdGFsTGVuZ3RoID0gMDtcXG5cXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcnJheXMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XFxuICAgIGFycmF5c1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XFxuICB9XFxuXFxuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XFxuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcXG4gIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcXG5cXG4gIHRyeSB7XFxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGFycmF5c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcXG4gICAgICB2YXIgYXJyID0gX3N0ZXAudmFsdWU7XFxuXFxuICAgICAgdG90YWxMZW5ndGggKz0gYXJyLmxlbmd0aDtcXG4gICAgfVxcbiAgfSBjYXRjaCAoZXJyKSB7XFxuICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcXG4gICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XFxuICB9IGZpbmFsbHkge1xcbiAgICB0cnkge1xcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XFxuICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XFxuICAgICAgfVxcbiAgICB9IGZpbmFsbHkge1xcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgcmVzdWx0ID0gbmV3IFJlc3VsdENvbnN0cnVjdG9yKHRvdGFsTGVuZ3RoKTtcXG4gIHZhciBvZmZzZXQgPSAwO1xcbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcXG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcXG4gIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XFxuXFxuICB0cnkge1xcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gYXJyYXlzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XFxuICAgICAgdmFyIF9hcnIgPSBfc3RlcDIudmFsdWU7XFxuXFxuICAgICAgcmVzdWx0LnNldChfYXJyLCBvZmZzZXQpO1xcbiAgICAgIG9mZnNldCArPSBfYXJyLmxlbmd0aDtcXG4gICAgfVxcbiAgfSBjYXRjaCAoZXJyKSB7XFxuICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XFxuICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcXG4gIH0gZmluYWxseSB7XFxuICAgIHRyeSB7XFxuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xcbiAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcXG4gICAgICB9XFxuICAgIH0gZmluYWxseSB7XFxuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9ub2RlX21vZHVsZXMvY29uY2F0LXR5cGVkLWFycmF5L2xpYi9jb25jYXQuanM/Jyl9LFwiLi4veGdwbGF5ZXItdXRpbHMvbm9kZV9tb2R1bGVzL2NvbmNhdC10eXBlZC1hcnJheS9saWIvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvbm9kZV9tb2R1bGVzL2NvbmNhdC10eXBlZC1hcnJheS9saWIvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKCdcXG5cXG52YXIgX2NvbmNhdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29uY2F0ICovIFwiLi4veGdwbGF5ZXItdXRpbHMvbm9kZV9tb2R1bGVzL2NvbmNhdC10eXBlZC1hcnJheS9saWIvY29uY2F0LmpzXCIpO1xcblxcbnZhciBfY29uY2F0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbmNhdCk7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcXG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9O1xcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IF9jb25jYXQyLmRlZmF1bHQ7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL25vZGVfbW9kdWxlcy9jb25jYXQtdHlwZWQtYXJyYXkvbGliL2luZGV4LmpzPycpfSxcIi4uL3hncGxheWVyLXV0aWxzL25vZGVfbW9kdWxlcy93ZWJ3b3JraWZ5LXdlYnBhY2svaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci11dGlscy9ub2RlX21vZHVsZXMvd2Vid29ya2lmeS13ZWJwYWNrL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuZnVuY3Rpb24gd2VicGFja0Jvb3RzdHJhcEZ1bmMobW9kdWxlcykge1xcbiAgLyoqKioqKi8gLy8gVGhlIG1vZHVsZSBjYWNoZVxcbiAgLyoqKioqKi92YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xcblxcbiAgLyoqKioqKi8gLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cXG4gIC8qKioqKiovZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xcblxcbiAgICAvKioqKioqLyAvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcXG4gICAgLyoqKioqKi9pZiAoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXFxuICAgICAgLyoqKioqKi9yZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcXG5cXG4gICAgLyoqKioqKi8gLy8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcXG4gICAgLyoqKioqKi92YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XFxuICAgICAgLyoqKioqKi9pOiBtb2R1bGVJZCxcXG4gICAgICAvKioqKioqL2w6IGZhbHNlLFxcbiAgICAgIC8qKioqKiovZXhwb3J0czoge31cXG4gICAgICAvKioqKioqLyB9O1xcblxcbiAgICAvKioqKioqLyAvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cXG4gICAgLyoqKioqKi9tb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcXG5cXG4gICAgLyoqKioqKi8gLy8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxcbiAgICAvKioqKioqL21vZHVsZS5sID0gdHJ1ZTtcXG5cXG4gICAgLyoqKioqKi8gLy8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcXG4gICAgLyoqKioqKi9yZXR1cm4gbW9kdWxlLmV4cG9ydHM7XFxuICAgIC8qKioqKiovXFxuICB9XFxuXFxuICAvKioqKioqLyAvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxcbiAgLyoqKioqKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xcblxcbiAgLyoqKioqKi8gLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcXG4gIC8qKioqKiovX193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcXG5cXG4gIC8qKioqKiovIC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcXG4gIC8qKioqKiovX193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgIHJldHVybiB2YWx1ZTtcXG4gIH07XFxuXFxuICAvKioqKioqLyAvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcXG4gIC8qKioqKiovX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24gKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xcbiAgICAvKioqKioqL2lmICghX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XFxuICAgICAgLyoqKioqKi9PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xcbiAgICAgICAgLyoqKioqKi9jb25maWd1cmFibGU6IGZhbHNlLFxcbiAgICAgICAgLyoqKioqKi9lbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgLyoqKioqKi9nZXQ6IGdldHRlclxcbiAgICAgICAgLyoqKioqKi8gfSk7XFxuICAgICAgLyoqKioqKi9cXG4gICAgfVxcbiAgICAvKioqKioqL1xcbiAgfTtcXG5cXG4gIC8qKioqKiovIC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcXG4gIC8qKioqKiovX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24gKGV4cG9ydHMpIHtcXG4gICAgLyoqKioqKi9PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xcbiAgICAvKioqKioqL1xcbiAgfTtcXG5cXG4gIC8qKioqKiovIC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXFxuICAvKioqKioqL19fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uIChtb2R1bGUpIHtcXG4gICAgLyoqKioqKi92YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cXG4gICAgLyoqKioqKi9mdW5jdGlvbiBnZXREZWZhdWx0KCkge1xcbiAgICAgIHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTtcXG4gICAgfSA6XFxuICAgIC8qKioqKiovZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHtcXG4gICAgICByZXR1cm4gbW9kdWxlO1xcbiAgICB9O1xcbiAgICAvKioqKioqL19fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcXG4gICAgLyoqKioqKi9yZXR1cm4gZ2V0dGVyO1xcbiAgICAvKioqKioqL1xcbiAgfTtcXG5cXG4gIC8qKioqKiovIC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxcbiAgLyoqKioqKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eSkge1xcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xcbiAgfTtcXG5cXG4gIC8qKioqKiovIC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXFxuICAvKioqKioqL19fd2VicGFja19yZXF1aXJlX18ucCA9IFxcXCIvXFxcIjtcXG5cXG4gIC8qKioqKiovIC8vIG9uIGVycm9yIGZ1bmN0aW9uIGZvciBhc3luYyBsb2FkaW5nXFxuICAvKioqKioqL19fd2VicGFja19yZXF1aXJlX18ub2UgPSBmdW5jdGlvbiAoZXJyKSB7XFxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTt0aHJvdyBlcnI7XFxuICB9O1xcblxcbiAgdmFyIGYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IEVOVFJZX01PRFVMRSk7XFxuICByZXR1cm4gZi5kZWZhdWx0IHx8IGY7IC8vIHRyeSB0byBjYWxsIGRlZmF1bHQgaWYgZGVmaW5lZCB0byBhbHNvIHN1cHBvcnQgYmFiZWwgZXNtb2R1bGUgZXhwb3J0c1xcbn1cXG5cXG52YXIgbW9kdWxlTmFtZVJlcUV4cCA9ICdbXFxcXFxcXFwufFxcXFxcXFxcLXxcXFxcXFxcXCt8XFxcXFxcXFx3fFxcXFwvfEBdKyc7XFxudmFyIGRlcGVuZGVuY3lSZWdFeHAgPSAnXFxcXFxcXFwoXFxcXFxcXFxzKihcXFxcL1xcXFxcXFxcKi4qP1xcXFxcXFxcKlxcXFwvKT9cXFxcXFxcXHMqLio/KCcgKyBtb2R1bGVOYW1lUmVxRXhwICsgJykuKj9cXFxcXFxcXCknOyAvLyBhZGRpdGlvbmFsIGNoYXJzIHdoZW4gb3V0cHV0LnBhdGhpbmZvIGlzIHRydWVcXG5cXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNTkzNjYxLzEzMDQ0MlxcbmZ1bmN0aW9uIHF1b3RlUmVnRXhwKHN0cikge1xcbiAgcmV0dXJuIChzdHIgKyAnJykucmVwbGFjZSgvWy4/KiteJFtcXFxcXVxcXFxcXFxcKCl7fXwtXS9nLCAnXFxcXFxcXFwkJicpO1xcbn1cXG5cXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xcbiAgcmV0dXJuICFpc05hTigxICogbik7IC8vIDEgKiBuIGNvbnZlcnRzIGludGVnZXJzLCBpbnRlZ2VycyBhcyBzdHJpbmcgKFxcXCIxMjNcXFwiKSwgMWUzIGFuZCBcXFwiMWUzXFxcIiB0byBpbnRlZ2VycyBhbmQgc3RyaW5ncyB0byBOYU5cXG59XFxuXFxuZnVuY3Rpb24gZ2V0TW9kdWxlRGVwZW5kZW5jaWVzKHNvdXJjZXMsIG1vZHVsZSwgcXVldWVOYW1lKSB7XFxuICB2YXIgcmV0dmFsID0ge307XFxuICByZXR2YWxbcXVldWVOYW1lXSA9IFtdO1xcblxcbiAgdmFyIGZuU3RyaW5nID0gbW9kdWxlLnRvU3RyaW5nKCk7XFxuICB2YXIgd3JhcHBlclNpZ25hdHVyZSA9IGZuU3RyaW5nLm1hdGNoKC9eZnVuY3Rpb25cXFxccz9cXFxcdypcXFxcKFxcXFx3KyxcXFxccypcXFxcdyssXFxcXHMqKFxcXFx3KylcXFxcKS8pO1xcbiAgaWYgKCF3cmFwcGVyU2lnbmF0dXJlKSByZXR1cm4gcmV0dmFsO1xcbiAgdmFyIHdlYnBhY2tSZXF1aXJlTmFtZSA9IHdyYXBwZXJTaWduYXR1cmVbMV07XFxuXFxuICAvLyBtYWluIGJ1bmRsZSBkZXBzXFxuICB2YXIgcmUgPSBuZXcgUmVnRXhwKCcoXFxcXFxcXFxcXFxcXFxcXG58XFxcXFxcXFxXKScgKyBxdW90ZVJlZ0V4cCh3ZWJwYWNrUmVxdWlyZU5hbWUpICsgZGVwZW5kZW5jeVJlZ0V4cCwgJ2cnKTtcXG4gIHZhciBtYXRjaDtcXG4gIHdoaWxlIChtYXRjaCA9IHJlLmV4ZWMoZm5TdHJpbmcpKSB7XFxuICAgIGlmIChtYXRjaFszXSA9PT0gJ2RsbC1yZWZlcmVuY2UnKSBjb250aW51ZTtcXG4gICAgcmV0dmFsW3F1ZXVlTmFtZV0ucHVzaChtYXRjaFszXSk7XFxuICB9XFxuXFxuICAvLyBkbGwgZGVwc1xcbiAgcmUgPSBuZXcgUmVnRXhwKCdcXFxcXFxcXCgnICsgcXVvdGVSZWdFeHAod2VicGFja1JlcXVpcmVOYW1lKSArICdcXFxcXFxcXChcXFwiKGRsbC1yZWZlcmVuY2VcXFxcXFxcXHMoJyArIG1vZHVsZU5hbWVSZXFFeHAgKyAnKSlcXFwiXFxcXFxcXFwpXFxcXFxcXFwpJyArIGRlcGVuZGVuY3lSZWdFeHAsICdnJyk7XFxuICB3aGlsZSAobWF0Y2ggPSByZS5leGVjKGZuU3RyaW5nKSkge1xcbiAgICBpZiAoIXNvdXJjZXNbbWF0Y2hbMl1dKSB7XFxuICAgICAgcmV0dmFsW3F1ZXVlTmFtZV0ucHVzaChtYXRjaFsxXSk7XFxuICAgICAgc291cmNlc1ttYXRjaFsyXV0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKG1hdGNoWzFdKS5tO1xcbiAgICB9XFxuICAgIHJldHZhbFttYXRjaFsyXV0gPSByZXR2YWxbbWF0Y2hbMl1dIHx8IFtdO1xcbiAgICByZXR2YWxbbWF0Y2hbMl1dLnB1c2gobWF0Y2hbNF0pO1xcbiAgfVxcblxcbiAgLy8gY29udmVydCAxZTMgYmFjayB0byAxMDAwIC0gdGhpcyBjYW4gYmUgaW1wb3J0YW50IGFmdGVyIHVnbGlmeS1qcyBjb252ZXJ0ZWQgMTAwMCB0byAxZTNcXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmV0dmFsKTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJldHZhbFtrZXlzW2ldXS5sZW5ndGg7IGorKykge1xcbiAgICAgIGlmIChpc051bWVyaWMocmV0dmFsW2tleXNbaV1dW2pdKSkge1xcbiAgICAgICAgcmV0dmFsW2tleXNbaV1dW2pdID0gMSAqIHJldHZhbFtrZXlzW2ldXVtqXTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiByZXR2YWw7XFxufVxcblxcbmZ1bmN0aW9uIGhhc1ZhbHVlc0luUXVldWVzKHF1ZXVlcykge1xcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhxdWV1ZXMpO1xcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChoYXNWYWx1ZXMsIGtleSkge1xcbiAgICByZXR1cm4gaGFzVmFsdWVzIHx8IHF1ZXVlc1trZXldLmxlbmd0aCA+IDA7XFxuICB9LCBmYWxzZSk7XFxufVxcblxcbmZ1bmN0aW9uIGdldFJlcXVpcmVkTW9kdWxlcyhzb3VyY2VzLCBtb2R1bGVJZCkge1xcbiAgdmFyIG1vZHVsZXNRdWV1ZSA9IHtcXG4gICAgbWFpbjogW21vZHVsZUlkXVxcbiAgfTtcXG4gIHZhciByZXF1aXJlZE1vZHVsZXMgPSB7XFxuICAgIG1haW46IFtdXFxuICB9O1xcbiAgdmFyIHNlZW5Nb2R1bGVzID0ge1xcbiAgICBtYWluOiB7fVxcbiAgfTtcXG5cXG4gIHdoaWxlIChoYXNWYWx1ZXNJblF1ZXVlcyhtb2R1bGVzUXVldWUpKSB7XFxuICAgIHZhciBxdWV1ZXMgPSBPYmplY3Qua2V5cyhtb2R1bGVzUXVldWUpO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBxdWV1ZU5hbWUgPSBxdWV1ZXNbaV07XFxuICAgICAgdmFyIHF1ZXVlID0gbW9kdWxlc1F1ZXVlW3F1ZXVlTmFtZV07XFxuICAgICAgdmFyIG1vZHVsZVRvQ2hlY2sgPSBxdWV1ZS5wb3AoKTtcXG4gICAgICBzZWVuTW9kdWxlc1txdWV1ZU5hbWVdID0gc2Vlbk1vZHVsZXNbcXVldWVOYW1lXSB8fCB7fTtcXG4gICAgICBpZiAoc2Vlbk1vZHVsZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSB8fCAhc291cmNlc1txdWV1ZU5hbWVdW21vZHVsZVRvQ2hlY2tdKSBjb250aW51ZTtcXG4gICAgICBzZWVuTW9kdWxlc1txdWV1ZU5hbWVdW21vZHVsZVRvQ2hlY2tdID0gdHJ1ZTtcXG4gICAgICByZXF1aXJlZE1vZHVsZXNbcXVldWVOYW1lXSA9IHJlcXVpcmVkTW9kdWxlc1txdWV1ZU5hbWVdIHx8IFtdO1xcbiAgICAgIHJlcXVpcmVkTW9kdWxlc1txdWV1ZU5hbWVdLnB1c2gobW9kdWxlVG9DaGVjayk7XFxuICAgICAgdmFyIG5ld01vZHVsZXMgPSBnZXRNb2R1bGVEZXBlbmRlbmNpZXMoc291cmNlcywgc291cmNlc1txdWV1ZU5hbWVdW21vZHVsZVRvQ2hlY2tdLCBxdWV1ZU5hbWUpO1xcbiAgICAgIHZhciBuZXdNb2R1bGVzS2V5cyA9IE9iamVjdC5rZXlzKG5ld01vZHVsZXMpO1xcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmV3TW9kdWxlc0tleXMubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgIG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0gPSBtb2R1bGVzUXVldWVbbmV3TW9kdWxlc0tleXNbal1dIHx8IFtdO1xcbiAgICAgICAgbW9kdWxlc1F1ZXVlW25ld01vZHVsZXNLZXlzW2pdXSA9IG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0uY29uY2F0KG5ld01vZHVsZXNbbmV3TW9kdWxlc0tleXNbal1dKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiByZXF1aXJlZE1vZHVsZXM7XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1vZHVsZUlkLCBvcHRpb25zKSB7XFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gIHZhciBzb3VyY2VzID0ge1xcbiAgICBtYWluOiBfX3dlYnBhY2tfcmVxdWlyZV9fLm1cXG4gIH07XFxuXFxuICB2YXIgcmVxdWlyZWRNb2R1bGVzID0gb3B0aW9ucy5hbGwgPyB7IG1haW46IE9iamVjdC5rZXlzKHNvdXJjZXMubWFpbikgfSA6IGdldFJlcXVpcmVkTW9kdWxlcyhzb3VyY2VzLCBtb2R1bGVJZCk7XFxuXFxuICB2YXIgc3JjID0gJyc7XFxuXFxuICBPYmplY3Qua2V5cyhyZXF1aXJlZE1vZHVsZXMpLmZpbHRlcihmdW5jdGlvbiAobSkge1xcbiAgICByZXR1cm4gbSAhPT0gJ21haW4nO1xcbiAgfSkuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlKSB7XFxuICAgIHZhciBlbnRyeU1vZHVsZSA9IDA7XFxuICAgIHdoaWxlIChyZXF1aXJlZE1vZHVsZXNbbW9kdWxlXVtlbnRyeU1vZHVsZV0pIHtcXG4gICAgICBlbnRyeU1vZHVsZSsrO1xcbiAgICB9XFxuICAgIHJlcXVpcmVkTW9kdWxlc1ttb2R1bGVdLnB1c2goZW50cnlNb2R1bGUpO1xcbiAgICBzb3VyY2VzW21vZHVsZV1bZW50cnlNb2R1bGVdID0gJyhmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHsgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fOyB9KSc7XFxuICAgIHNyYyA9IHNyYyArICd2YXIgJyArIG1vZHVsZSArICcgPSAoJyArIHdlYnBhY2tCb290c3RyYXBGdW5jLnRvU3RyaW5nKCkucmVwbGFjZSgnRU5UUllfTU9EVUxFJywgSlNPTi5zdHJpbmdpZnkoZW50cnlNb2R1bGUpKSArICcpKHsnICsgcmVxdWlyZWRNb2R1bGVzW21vZHVsZV0ubWFwKGZ1bmN0aW9uIChpZCkge1xcbiAgICAgIHJldHVybiAnJyArIEpTT04uc3RyaW5naWZ5KGlkKSArICc6ICcgKyBzb3VyY2VzW21vZHVsZV1baWRdLnRvU3RyaW5nKCk7XFxuICAgIH0pLmpvaW4oJywnKSArICd9KTtcXFxcbic7XFxuICB9KTtcXG5cXG4gIHNyYyA9IHNyYyArICduZXcgKCgnICsgd2VicGFja0Jvb3RzdHJhcEZ1bmMudG9TdHJpbmcoKS5yZXBsYWNlKCdFTlRSWV9NT0RVTEUnLCBKU09OLnN0cmluZ2lmeShtb2R1bGVJZCkpICsgJykoeycgKyByZXF1aXJlZE1vZHVsZXMubWFpbi5tYXAoZnVuY3Rpb24gKGlkKSB7XFxuICAgIHJldHVybiAnJyArIEpTT04uc3RyaW5naWZ5KGlkKSArICc6ICcgKyBzb3VyY2VzLm1haW5baWRdLnRvU3RyaW5nKCk7XFxuICB9KS5qb2luKCcsJykgKyAnfSkpKHNlbGYpOyc7XFxuXFxuICB2YXIgYmxvYiA9IG5ldyB3aW5kb3cuQmxvYihbc3JjXSwgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KTtcXG4gIGlmIChvcHRpb25zLmJhcmUpIHtcXG4gICAgcmV0dXJuIGJsb2I7XFxuICB9XFxuXFxuICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMO1xcblxcbiAgdmFyIHdvcmtlclVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XFxuICB2YXIgd29ya2VyID0gbmV3IHdpbmRvdy5Xb3JrZXIod29ya2VyVXJsKTtcXG4gIHdvcmtlci5vYmplY3RVUkwgPSB3b3JrZXJVcmw7XFxuXFxuICByZXR1cm4gd29ya2VyO1xcbn07XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL25vZGVfbW9kdWxlcy93ZWJ3b3JraWZ5LXdlYnBhY2svaW5kZXguanM/XCIpfSxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9jb25zdGFudHMvZXZlbnRzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXV0aWxzL3NyYy9jb25zdGFudHMvZXZlbnRzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuY29uc3QgTE9BREVSX0VWRU5UUyA9IHtcXG4gIExBREVSX1NUQVJUOiAnTE9BREVSX1NUQVJUJyxcXG4gIExPQURFUl9EQVRBTE9BREVEOiAnTE9BREVSX0RBVEFMT0FERUQnLFxcbiAgTE9BREVSX0NPTVBMRVRFOiAnTE9BREVSX0NPTVBMRVRFJyxcXG4gIExPQURFUl9FUlJPUjogJ0xPQURFUl9FUlJPUidcXG59O1xcblxcbmNvbnN0IERFTVVYX0VWRU5UUyA9IHtcXG4gIERFTVVYX1NUQVJUOiAnREVNVVhfU1RBUlQnLFxcbiAgREVNVVhfQ09NUExFVEU6ICdERU1VWF9DT01QTEVURScsXFxuICBERU1VWF9FUlJPUjogJ0RFTVVYX0VSUk9SJyxcXG4gIE1FVEFEQVRBX1BBUlNFRDogJ01FVEFEQVRBX1BBUlNFRCcsXFxuICBWSURFT19NRVRBREFUQV9DSEFOR0U6ICdWSURFT19NRVRBREFUQV9DSEFOR0UnLFxcbiAgQVVESU9fTUVUQURBVEFfQ0hBTkdFOiAnQVVESU9fTUVUQURBVEFfQ0hBTkdFJyxcXG4gIE1FRElBX0lORk86ICdNRURJQV9JTkZPJ1xcbn07XFxuXFxuY29uc3QgUkVNVVhfRVZFTlRTID0ge1xcbiAgUkVNVVhfTUVUQURBVEE6ICdSRU1VWF9NRVRBREFUQScsXFxuICBSRU1VWF9NRURJQTogJ1JFTVVYX01FRElBJyxcXG4gIE1FRElBX1NFR01FTlQ6ICdNRURJQV9TRUdNRU5UJyxcXG4gIFJFTVVYX0VSUk9SOiAnUkVNVVhfRVJST1InLFxcbiAgSU5JVF9TRUdNRU5UOiAnSU5JVF9TRUdNRU5UJyxcXG4gIERFVEVDVF9DSEFOR0VfU1RSRUFNOiAnREVURUNUX0NIQU5HRV9TVFJFQU0nXFxufTtcXG5cXG5jb25zdCBNU0VfRVZFTlRTID0ge1xcbiAgU09VUkNFX1VQREFURV9FTkQ6ICdTT1VSQ0VfVVBEQVRFX0VORCdcXG5cXG4gIC8vIGhsc+S4k+aciWV2ZW50c1xcbn07Y29uc3QgSExTX0VWRU5UUyA9IHtcXG4gIFJFVFJZX1RJTUVfRVhDRUVERUQ6ICdSRVRSWV9USU1FX0VYQ0VFREVEJ1xcbn07XFxuXFxuY29uc3QgQ1JZVE9fRVZFTlRTID0ge1xcbiAgU1RBUlRfREVDUllQVDogJ1NUQVJUX0RFQ1JZUFQnLFxcbiAgREVDUllQVEVEOiAnREVDUllQVEVEJ1xcbn07XFxuY29uc3QgQUxMRVZFTlRTID0gT2JqZWN0LmFzc2lnbih7fSwgTE9BREVSX0VWRU5UUywgREVNVVhfRVZFTlRTLCBSRU1VWF9FVkVOVFMsIE1TRV9FVkVOVFMsIEhMU19FVkVOVFMpO1xcblxcbmNvbnN0IEZsdkFsbG93ZWRFdmVudHMgPSBbXTtcXG5jb25zdCBIbHNBbGxvd2VkRXZlbnRzID0gW107XFxuXFxuZm9yIChsZXQga2V5IGluIEFMTEVWRU5UUykge1xcbiAgaWYgKEFMTEVWRU5UUy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxuICAgIEZsdkFsbG93ZWRFdmVudHMucHVzaChBTExFVkVOVFNba2V5XSk7XFxuICB9XFxufVxcblxcbmZvciAobGV0IGtleSBpbiBBTExFVkVOVFMpIHtcXG4gIGlmIChBTExFVkVOVFMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICBIbHNBbGxvd2VkRXZlbnRzLnB1c2goQUxMRVZFTlRTW2tleV0pO1xcbiAgfVxcbn1cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSB7XFxuICBBTExFVkVOVFMsXFxuICBITFNfRVZFTlRTLFxcbiAgUkVNVVhfRVZFTlRTLFxcbiAgREVNVVhfRVZFTlRTLFxcbiAgTVNFX0VWRU5UUyxcXG4gIExPQURFUl9FVkVOVFMsXFxuICBGbHZBbGxvd2VkRXZlbnRzLFxcbiAgSGxzQWxsb3dlZEV2ZW50cyxcXG4gIENSWVRPX0VWRU5UU1xcbn07XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL3NyYy9jb25zdGFudHMvZXZlbnRzLmpzP1wiKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvY29uc3RhbnRzL3dvcmtlci1jb21tYW5kcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci11dGlscy9zcmMvY29uc3RhbnRzL3dvcmtlci1jb21tYW5kcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbmNvbnN0IENPTlRFWFRfQ09NT01BTkRTID0gZXhwb3J0cy5DT05URVhUX0NPTU9NQU5EUyA9IHtcXG4gIE9OOiAnb24nLFxcbiAgT05DRTogJ29uY2UnLFxcbiAgT0ZGOiAnb2ZmJyxcXG4gIEVNSVQ6ICdlbWl0JyxcXG4gIERFU1RST1k6ICdkZXN0cm95J1xcbn07XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL3NyYy9jb25zdGFudHMvd29ya2VyLWNvbW1hbmRzLmpzP1wiKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvY29udGV4dC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci11dGlscy9zcmMvY29udGV4dC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoJ1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgX21lZGlhSW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kZWxzL21lZGlhLWluZm8gKi8gXCIuLi94Z3BsYXllci11dGlscy9zcmMvbW9kZWxzL21lZGlhLWluZm8uanNcIik7XFxuXFxudmFyIF9tZWRpYUluZm8yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWVkaWFJbmZvKTtcXG5cXG52YXIgX2V2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGV2ZW50cyAqLyBcIi4uLy4uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzXCIpO1xcblxcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFxuY29uc3QgRElSRUNUX0VNSVRfRkxBRyA9IFxcJ19fVE9fX1xcJztcXG5cXG5jbGFzcyBDb250ZXh0IHtcXG4gIGNvbnN0cnVjdG9yKGFsbG93ZWRFdmVudHMgPSBbXSkge1xcbiAgICB0aGlzLl9lbWl0dGVyID0gbmV3IF9ldmVudHMuRXZlbnRFbWl0dGVyKCk7XFxuICAgIHRoaXMuX2luc3RhbmNlTWFwID0ge307IC8vIOaJgOacieeahOino+eggea1geeoi+WunuS+i1xcbiAgICB0aGlzLl9jbHNNYXAgPSB7fTsgLy8g5p6E6YCg5Ye95pWw55qEbWFwXFxuICAgIHRoaXMuX2luaXRlZCA9IGZhbHNlO1xcbiAgICB0aGlzLm1lZGlhSW5mbyA9IG5ldyBfbWVkaWFJbmZvMi5kZWZhdWx0KCk7XFxuICAgIHRoaXMuYWxsb3dlZEV2ZW50cyA9IGFsbG93ZWRFdmVudHM7XFxuICAgIHRoaXMuX2hvb2tzID0ge307IC8vIOazqOWGjOWcqOS6i+S7tuWJjS/lkI7nmoTpkqnlrZDvvIzkvovlpoIgYmVmb3JlKFxcJ0RFTVVYX0NPTVBMRVRFXFwnKVxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiDku47kuIrkuIvmlofkuK3ojrflj5bop6PnoIHmtYHnqIvlrp7kvovvvIzlpoLmnpzmsqHmnInlrp7kvovvvIzmnoTpgKDkuIDkuKpcXG4gICAqIEBwYXJhbSB0YWdcXG4gICAqIEBwYXJhbSBhcmdzXFxuICAgKiBAcmV0dXJucyB7Kn1cXG4gICAqL1xcbiAgZ2V0SW5zdGFuY2UodGFnKSB7XFxuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2VNYXBbdGFnXTtcXG4gICAgaWYgKGluc3RhbmNlKSB7XFxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIHRocm93IG5ldyBFcnJvcihgJHt0YWd95a6e5L6L5bCa5pyq5Yid5aeL5YyWYClcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiDliJ3lp4vljJblhbfkvZPlrp7kvotcXG4gICAqIEBwYXJhbSB0YWdcXG4gICAqIEBwYXJhbSBhcmdzXFxuICAgKi9cXG4gIGluaXRJbnN0YW5jZSh0YWcsIC4uLmFyZ3MpIHtcXG4gICAgaWYgKHRoaXMuX2Nsc01hcFt0YWddKSB7XFxuICAgICAgY29uc3QgbmV3SW5zdGFuY2UgPSBuZXcgdGhpcy5fY2xzTWFwW3RhZ10oLi4uYXJncyk7XFxuICAgICAgdGhpcy5faW5zdGFuY2VNYXBbdGFnXSA9IG5ld0luc3RhbmNlO1xcbiAgICAgIGlmIChuZXdJbnN0YW5jZS5pbml0KSB7XFxuICAgICAgICBuZXdJbnN0YW5jZS5pbml0KCk7IC8vIFRPRE86IGxpZmVjaXJjbGVcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG5ld0luc3RhbmNlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0YWd95pyq5ZyoY29udGV4dOS4reazqOWGjGApO1xcbiAgICB9XFxuICB9XFxuXFxuICAvKipcXG4gICAqIOmBv+WFjeWkp+mHj+eahGluaXRJbnN0YW5jZeiwg+eUqO+8jOWIneWni+WMluaJgOacieeahOe7hOS7tlxcbiAgICogQHBhcmFtIGNvbmZpZ1xcbiAgICovXFxuICBpbml0KGNvbmZpZykge1xcbiAgICBpZiAodGhpcy5faW5pdGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGZvciAobGV0IHRhZyBpbiB0aGlzLl9jbHNNYXApIHtcXG4gICAgICAvLyBpZiBub3QgaW5pdGVkLCBpbml0IGFuIGluc3RhbmNlXFxuICAgICAgaWYgKHRoaXMuX2Nsc01hcC5oYXNPd25Qcm9wZXJ0eSh0YWcpICYmICF0aGlzLl9pbnN0YW5jZU1hcFt0YWddKSB7XFxuICAgICAgICB0aGlzLmluaXRJbnN0YW5jZSh0YWcsIGNvbmZpZyk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHRoaXMuX2luaXRlZCA9IHRydWU7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIOazqOWGjOS4gOS4quS4iuS4i+aWh+a1geeoi++8jOaPkOS+m+WuieWFqOeahOS6i+S7tuWPkemAgeacuuWItlxcbiAgICogQHBhcmFtIHRhZ1xcbiAgICogQHBhcmFtIGNsc1xcbiAgICovXFxuICByZWdpc3RyeSh0YWcsIGNscykge1xcbiAgICBjb25zdCBlbWl0dGVyID0gdGhpcy5fZW1pdHRlcjtcXG4gICAgY29uc3QgY2hlY2tNZXNzYWdlTmFtZSA9IHRoaXMuX2lzTWVzc2FnZU5hbWVWYWxpZC5iaW5kKHRoaXMpO1xcbiAgICBjb25zdCBzZWxmID0gdGhpcztcXG4gICAgY29uc3QgZW5oYW5jZWQgPSBjbGFzcyBleHRlbmRzIGNscyB7XFxuICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XFxuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xcbiAgICAgICAgdGhpcy5vbmNlTGlzdGVuZXJzID0ge307XFxuICAgICAgICB0aGlzLlRBRyA9IHRhZztcXG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBzZWxmO1xcbiAgICAgIH1cXG5cXG4gICAgICBvbihtZXNzYWdlTmFtZSwgY2FsbGJhY2spIHtcXG4gICAgICAgIGNoZWNrTWVzc2FnZU5hbWUobWVzc2FnZU5hbWUpO1xcblxcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzW21lc3NhZ2VOYW1lXSkge1xcbiAgICAgICAgICB0aGlzLmxpc3RlbmVyc1ttZXNzYWdlTmFtZV0ucHVzaChjYWxsYmFjayk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aGlzLmxpc3RlbmVyc1ttZXNzYWdlTmFtZV0gPSBbY2FsbGJhY2tdO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZW1pdHRlci5vbihgJHttZXNzYWdlTmFtZX0ke0RJUkVDVF9FTUlUX0ZMQUd9JHt0YWd9YCwgY2FsbGJhY2spOyAvLyDlu7rnq4vlrprlkJHpgJrkv6Hnm5HlkKxcXG4gICAgICAgIHJldHVybiBlbWl0dGVyLm9uKG1lc3NhZ2VOYW1lLCBjYWxsYmFjayk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIOWcqOafkOS4quS6i+S7tuinpuWPkeWJjeaJp+ihjFxcbiAgICAgICAqIEBwYXJhbSBtZXNzYWdlTmFtZVxcbiAgICAgICAqIEBwYXJhbSBjYWxsYmFja1xcbiAgICAgICAqL1xcbiAgICAgIGJlZm9yZShtZXNzYWdlTmFtZSwgY2FsbGJhY2spIHtcXG4gICAgICAgIGNoZWNrTWVzc2FnZU5hbWUobWVzc2FnZU5hbWUpO1xcbiAgICAgICAgaWYgKHNlbGYuX2hvb2tzW21lc3NhZ2VOYW1lXSkge1xcbiAgICAgICAgICBzZWxmLl9ob29rc1ttZXNzYWdlTmFtZV0ucHVzaChjYWxsYmFjayk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzZWxmLl9ob29rc1ttZXNzYWdlTmFtZV0gPSBbY2FsbGJhY2tdO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBvbmNlKG1lc3NhZ2VOYW1lLCBjYWxsYmFjaykge1xcbiAgICAgICAgY2hlY2tNZXNzYWdlTmFtZShtZXNzYWdlTmFtZSk7XFxuXFxuICAgICAgICBpZiAodGhpcy5vbmNlTGlzdGVuZXJzW21lc3NhZ2VOYW1lXSkge1xcbiAgICAgICAgICB0aGlzLm9uY2VMaXN0ZW5lcnNbbWVzc2FnZU5hbWVdLnB1c2goY2FsbGJhY2spO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5vbmNlTGlzdGVuZXJzW21lc3NhZ2VOYW1lXSA9IFtjYWxsYmFja107XFxuICAgICAgICB9XFxuXFxuICAgICAgICBlbWl0dGVyLm9uY2UoYCR7bWVzc2FnZU5hbWV9JHtESVJFQ1RfRU1JVF9GTEFHfSR7dGFnfWAsIGNhbGxiYWNrKTtcXG4gICAgICAgIHJldHVybiBlbWl0dGVyLm9uY2UobWVzc2FnZU5hbWUsIGNhbGxiYWNrKTtcXG4gICAgICB9XFxuXFxuICAgICAgZW1pdChtZXNzYWdlTmFtZSwgLi4uYXJncykge1xcbiAgICAgICAgY2hlY2tNZXNzYWdlTmFtZShtZXNzYWdlTmFtZSk7XFxuXFxuICAgICAgICBjb25zdCBiZWZvcmVMaXN0ID0gc2VsZi5faG9va3MgPyBzZWxmLl9ob29rc1ttZXNzYWdlTmFtZV0gOiBudWxsO1xcblxcbiAgICAgICAgaWYgKGJlZm9yZUxpc3QpIHtcXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGJlZm9yZUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGJlZm9yZUxpc3RbaV07XFxuICAgICAgICAgICAgY2FsbGJhY2soKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXIuZW1pdChtZXNzYWdlTmFtZSwgLi4uYXJncyk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIOWumuWQkeWPkemAgee7meafkOS4que7hOS7tuWNleS+i+eahOa2iOaBr1xcbiAgICAgICAqIEBwYXJhbSBtZXNzYWdlTmFtZVxcbiAgICAgICAqIEBwYXJhbSBhcmdzXFxuICAgICAgICovXFxuICAgICAgZW1pdFRvKHRhZywgbWVzc2FnZU5hbWUsIC4uLmFyZ3MpIHtcXG4gICAgICAgIGNoZWNrTWVzc2FnZU5hbWUobWVzc2FnZU5hbWUpO1xcblxcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXIuZW1pdChgJHttZXNzYWdlTmFtZX0ke0RJUkVDVF9FTUlUX0ZMQUd9JHt0YWd9YCwgLi4uYXJncyk7XFxuICAgICAgfVxcblxcbiAgICAgIG9mZihtZXNzYWdlTmFtZSwgY2FsbGJhY2spIHtcXG4gICAgICAgIGNoZWNrTWVzc2FnZU5hbWUobWVzc2FnZU5hbWUpO1xcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXIub2ZmKG1lc3NhZ2VOYW1lLCBjYWxsYmFjayk7XFxuICAgICAgfVxcblxcbiAgICAgIHJlbW92ZUxpc3RlbmVycygpIHtcXG4gICAgICAgIGNvbnN0IGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuYmluZCh0aGlzLmxpc3RlbmVycyk7XFxuXFxuICAgICAgICBmb3IgKGxldCBtZXNzYWdlTmFtZSBpbiB0aGlzLmxpc3RlbmVycykge1xcbiAgICAgICAgICBpZiAoaGFzT3duKG1lc3NhZ2VOYW1lKSkge1xcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMubGlzdGVuZXJzW21lc3NhZ2VOYW1lXSB8fCBbXTtcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XFxuICAgICAgICAgICAgICBlbWl0dGVyLm9mZihtZXNzYWdlTmFtZSwgY2FsbGJhY2spO1xcbiAgICAgICAgICAgICAgZW1pdHRlci5vZmYoYCR7bWVzc2FnZU5hbWV9JHtESVJFQ1RfRU1JVF9GTEFHfSR7dGFnfWAsIGNhbGxiYWNrKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZvciAobGV0IG1lc3NhZ2VOYW1lIGluIHRoaXMub25jZUxpc3RlbmVycykge1xcbiAgICAgICAgICBpZiAoaGFzT3duKG1lc3NhZ2VOYW1lKSkge1xcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMub25jZUxpc3RlbmVyc1ttZXNzYWdlTmFtZV0gfHwgW107XFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tzW2ldO1xcbiAgICAgICAgICAgICAgZW1pdHRlci5vZmYobWVzc2FnZU5hbWUsIGNhbGxiYWNrKTtcXG4gICAgICAgICAgICAgIGVtaXR0ZXIub2ZmKGAke21lc3NhZ2VOYW1lfSR7RElSRUNUX0VNSVRfRkxBR30ke3RhZ31gLCBjYWxsYmFjayk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIOWcqOe7hOS7tumUgOavgeaXtu+8jOm7mOiupOWwhuWug+azqOWGjOeahOS6i+S7tuWFqOmDqOWNuOi9ve+8jOehruS/neS4jeS8mumAoOaIkOWGheWtmOazhOa8j1xcbiAgICAgICAqL1xcbiAgICAgIGRlc3Ryb3koKSB7XFxuICAgICAgICAvLyBzdGVwMSB1bmxpc3RlbiBldmVudHNcXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XFxuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xcblxcbiAgICAgICAgLy8gc3RlcDIgcmVsZWFzZSBmcm9tIGNvbnRleHRcXG4gICAgICAgIGRlbGV0ZSBzZWxmLl9pbnN0YW5jZU1hcFt0YWddO1xcbiAgICAgICAgaWYgKHN1cGVyLmRlc3Ryb3kpIHtcXG4gICAgICAgICAgcmV0dXJuIHN1cGVyLmRlc3Ryb3koKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuICAgIHRoaXMuX2Nsc01hcFt0YWddID0gZW5oYW5jZWQ7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBnZXQgaW5zdGFuY2UgaW1tZWRpYXRlbHlcXG4gICAgICogZS5nIGNvbnN0IGluc3RhbmNlID0gY29udGV4dC5yZWdpc3RyeSh0YWcsIENscykoY29uZmlnKVxcbiAgICAgKiAqL1xcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcXG4gICAgICByZXR1cm4gdGhpcy5pbml0SW5zdGFuY2UodGFnLCAuLi5hcmdzKTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICog5a+55a2Y5Zyo55qE5a6e5L6L6L+b6KGMXFxuICAgKi9cXG4gIGRlc3Ryb3lJbnN0YW5jZXMoKSB7XFxuICAgIE9iamVjdC5rZXlzKHRoaXMuX2luc3RhbmNlTWFwKS5mb3JFYWNoKHRhZyA9PiB7XFxuICAgICAgaWYgKHRoaXMuX2luc3RhbmNlTWFwW3RhZ10uZGVzdHJveSkge1xcbiAgICAgICAgdGhpcy5faW5zdGFuY2VNYXBbdGFnXS5kZXN0cm95KCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICog57yW6Kej56CB5rWB56iL5peg6ZyA5YWz5rOo5LqL5Lu255qE6Kej57uRXFxuICAgKi9cXG4gIGRlc3Ryb3koKSB7XFxuICAgIHRoaXMuX2VtaXR0ZXIgPSBudWxsO1xcbiAgICB0aGlzLmFsbG93ZWRFdmVudHMgPSBbXTtcXG4gICAgdGhpcy5fY2xzTWFwID0gbnVsbDtcXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XFxuICAgIHRoaXMuX2hvb2tzID0gbnVsbDtcXG4gICAgdGhpcy5kZXN0cm95SW5zdGFuY2VzKCk7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIOWvueS/oemBk+i/m+ihjOaUtuaLolxcbiAgICogQHBhcmFtIG1lc3NhZ2VOYW1lXFxuICAgKiBAcHJpdmF0ZVxcbiAgICovXFxuICBfaXNNZXNzYWdlTmFtZVZhbGlkKG1lc3NhZ2VOYW1lKSB7XFxuICAgIGlmICghdGhpcy5hbGxvd2VkRXZlbnRzLmluZGV4T2YobWVzc2FnZU5hbWUpIDwgMCkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5yZWdpc3RlcmVkIG1lc3NhZ2UgbmFtZTogJHttZXNzYWdlTmFtZX1gKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBDb250ZXh0O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9zcmMvY29udGV4dC5qcz8nKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvY3J5cHRvL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvc3JjL2NyeXB0by9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gICAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgX2V2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2NvbnN0YW50cy9ldmVudHMgKi8gXFxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9jb25zdGFudHMvZXZlbnRzLmpzXFxcIik7XFxuXFxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxcblxcbmNvbnN0IENSWVRPX0VWRU5UUyA9IF9ldmVudHMyLmRlZmF1bHQuQ1JZVE9fRVZFTlRTO1xcbmNsYXNzIENyeXB0byB7XFxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xcbiAgICAgICAgdGhpcy5pbnB1dEJ1ZmZlciA9IGNvbmZpZy5pbnB1dGJ1ZmZlcjtcXG4gICAgICAgIHRoaXMub3V0cHV0QnVmZmVyID0gY29uZmlnLm91dHB1dGJ1ZmZlcjtcXG4gICAgICAgIHRoaXMua2V5ID0gY29uZmlnLmtleTtcXG4gICAgICAgIHRoaXMuaXYgPSBjb25maWcuaXY7XFxuICAgICAgICB0aGlzLm1ldGhvZCA9IGNvbmZpZy5tZXRob2Q7XFxuXFxuICAgICAgICB0aGlzLmNyeXB0byA9IHdpbmRvdy5jcnlwdG8gfHwgd2luZG93Lm1zQ3J5cHRvO1xcbiAgICB9XFxuXFxuICAgIGluaXQoKSB7XFxuICAgICAgICB0aGlzLm9uKENSWVRPX0VWRU5UUy5TVEFSVF9ERUNSWVBULCB0aGlzLmRlY3JpcHQuYmluZCh0aGlzKSk7XFxuICAgIH1cXG5cXG4gICAgZGVjcmlwdCgpIHtcXG4gICAgICAgIGlmICghdGhpcy5hZXNrZXkpIHtcXG4gICAgICAgICAgICBsZXQgc2JrZXkgPSB0aGlzLmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCB0aGlzLmtleS5idWZmZXIsIHsgbmFtZTogJ0FFUy1DQkMnIH0sIGZhbHNlLCBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcXG4gICAgICAgICAgICBzYmtleS50aGVuKGtleSA9PiB7XFxuICAgICAgICAgICAgICAgIHRoaXMuYWVza2V5ID0ga2V5O1xcbiAgICAgICAgICAgICAgICB0aGlzLmRlY3JpcHREYXRhKCk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRoaXMuZGVjcmlwdERhdGEoKTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICBkZWNyaXB0RGF0YSgpIHtcXG4gICAgICAgIGxldCBpbnB1dGJ1ZmZlciA9IHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UodGhpcy5pbnB1dEJ1ZmZlcik7XFxuICAgICAgICBsZXQgb3V0cHV0YnVmZmVyID0gdGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZSh0aGlzLm91dHB1dEJ1ZmZlcik7XFxuICAgICAgICBsZXQgZGF0YSA9IGlucHV0YnVmZmVyLnNoaWZ0KCk7XFxuICAgICAgICBpZiAoZGF0YSkge1xcbiAgICAgICAgICAgIHRoaXMuY3J5cHRvLnN1YnRsZS5kZWNyeXB0KHsgbmFtZTogJ0FFUy1DQkMnLCBpdjogdGhpcy5pdi5idWZmZXIgfSwgdGhpcy5hZXNrZXksIGRhdGEpLnRoZW4ocmVzID0+IHtcXG4gICAgICAgICAgICAgICAgb3V0cHV0YnVmZmVyLnB1c2gobmV3IFVpbnQ4QXJyYXkocmVzKSk7XFxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChDUllUT19FVkVOVFMuREVDUllQVEVEKTtcXG4gICAgICAgICAgICAgICAgdGhpcy5kZWNyaXB0RGF0YShkYXRhKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgfVxcbn1cXG5leHBvcnRzLmRlZmF1bHQgPSBDcnlwdG87XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL3NyYy9jcnlwdG8vaW5kZXguanM/XCIpfSxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9lbnYvaXNsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvc3JjL2Vudi9pc2xlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoJ1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5jb25zdCBsZSA9IGZ1bmN0aW9uICgpIHtcXG4gIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigyKTtcXG4gIG5ldyBEYXRhVmlldyhidWYpLnNldEludDE2KDAsIDI1NiwgdHJ1ZSk7IC8vIGxpdHRsZS1lbmRpYW4gd3JpdGVcXG4gIHJldHVybiBuZXcgSW50MTZBcnJheShidWYpWzBdID09PSAyNTY7IC8vIHBsYXRmb3JtLXNwZWMgcmVhZCwgaWYgZXF1YWwgdGhlbiBMRVxcbn0oKTtcXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBsZTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItdXRpbHMvc3JjL2Vudi9pc2xlLmpzPycpfSxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9lbnYvc25pZmZlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvc3JjL2Vudi9zbmlmZmVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbmNvbnN0IGxlID0gZnVuY3Rpb24gKCkge1xcbiAgY29uc3QgYnVmID0gbmV3IEFycmF5QnVmZmVyKDIpO1xcbiAgbmV3IERhdGFWaWV3KGJ1Zikuc2V0SW50MTYoMCwgMjU2LCB0cnVlKTsgLy8gbGl0dGxlLWVuZGlhbiB3cml0ZVxcbiAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGJ1ZilbMF0gPT09IDI1NjsgLy8gcGxhdGZvcm0tc3BlYyByZWFkLCBpZiBlcXVhbCB0aGVuIExFXFxufSgpO1xcblxcbmNvbnN0IHNuaWZmZXIgPSB7XFxuICBnZXQgZGV2aWNlKCkge1xcbiAgICBsZXQgciA9IHNuaWZmZXIub3M7XFxuICAgIHJldHVybiByLmlzUGMgPyAncGMnIDogci5pc1RhYmxldCA/ICd0YWJsZXQnIDogJ21vYmlsZSc7XFxuICB9LFxcbiAgZ2V0IGJyb3dzZXIoKSB7XFxuICAgIGxldCB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcXG4gICAgbGV0IHJlZyA9IHtcXG4gICAgICBpZTogL3J2OihbXFxcXGQuXSspXFxcXCkgbGlrZSBnZWNrby8sXFxuICAgICAgZmlyZm94OiAvZmlyZWZveFxcXFwvKFtcXFxcZC5dKykvLFxcbiAgICAgIGNocm9tZTogL2Nocm9tZVxcXFwvKFtcXFxcZC5dKykvLFxcbiAgICAgIG9wZXJhOiAvb3BlcmEuKFtcXFxcZC5dKykvLFxcbiAgICAgIHNhZmFyaTogL3ZlcnNpb25cXFxcLyhbXFxcXGQuXSspLipzYWZhcmkvXFxuICAgIH07XFxuICAgIHJldHVybiBbXS5jb25jYXQoT2JqZWN0LmtleXMocmVnKS5maWx0ZXIoa2V5ID0+IHJlZ1trZXldLnRlc3QodWEpKSlbMF07XFxuICB9LFxcbiAgZ2V0IG9zKCkge1xcbiAgICBsZXQgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xcbiAgICBsZXQgaXNXaW5kb3dzUGhvbmUgPSAvKD86V2luZG93cyBQaG9uZSkvLnRlc3QodWEpO1xcbiAgICBsZXQgaXNTeW1iaWFuID0gLyg/OlN5bWJpYW5PUykvLnRlc3QodWEpIHx8IGlzV2luZG93c1Bob25lO1xcbiAgICBsZXQgaXNBbmRyb2lkID0gLyg/OkFuZHJvaWQpLy50ZXN0KHVhKTtcXG4gICAgbGV0IGlzRmlyZUZveCA9IC8oPzpGaXJlZm94KS8udGVzdCh1YSk7XFxuICAgIGxldCBpc1RhYmxldCA9IC8oPzppUGFkfFBsYXlCb29rKS8udGVzdCh1YSkgfHwgaXNBbmRyb2lkICYmICEvKD86TW9iaWxlKS8udGVzdCh1YSkgfHwgaXNGaXJlRm94ICYmIC8oPzpUYWJsZXQpLy50ZXN0KHVhKTtcXG4gICAgbGV0IGlzUGhvbmUgPSAvKD86aVBob25lKS8udGVzdCh1YSkgJiYgIWlzVGFibGV0O1xcbiAgICBsZXQgaXNQYyA9ICFpc1Bob25lICYmICFpc0FuZHJvaWQgJiYgIWlzU3ltYmlhbjtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBpc1RhYmxldCxcXG4gICAgICBpc1Bob25lLFxcbiAgICAgIGlzQW5kcm9pZCxcXG4gICAgICBpc1BjLFxcbiAgICAgIGlzU3ltYmlhbixcXG4gICAgICBpc1dpbmRvd3NQaG9uZSxcXG4gICAgICBpc0ZpcmVGb3hcXG4gICAgfTtcXG4gIH0sXFxuXFxuICBnZXQgaXNMZSgpIHtcXG4gICAgcmV0dXJuIGxlO1xcbiAgfVxcbn07XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gc25pZmZlcjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItdXRpbHMvc3JjL2Vudi9zbmlmZmVyLmpzP1wiKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvZW52L3V0ZjguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXV0aWxzL3NyYy9lbnYvdXRmOC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5jbGFzcyBVVEY4IHtcXG4gIHN0YXRpYyBkZWNvZGUodWludDhhcnJheSkge1xcbiAgICBjb25zdCBvdXQgPSBbXTtcXG4gICAgY29uc3QgaW5wdXQgPSB1aW50OGFycmF5O1xcbiAgICBsZXQgaSA9IDA7XFxuICAgIGNvbnN0IGxlbmd0aCA9IHVpbnQ4YXJyYXkubGVuZ3RoO1xcblxcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xcbiAgICAgIGlmIChpbnB1dFtpXSA8IDB4ODApIHtcXG4gICAgICAgIG91dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaW5wdXRbaV0pKTtcXG4gICAgICAgICsraTtcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXRbaV0gPCAweEMwKSB7XFxuICAgICAgICAvLyBmYWxsdGhyb3VnaFxcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXRbaV0gPCAweEUwKSB7XFxuICAgICAgICBpZiAoVVRGOC5fY2hlY2tDb250aW51YXRpb24oaW5wdXQsIGksIDEpKSB7XFxuICAgICAgICAgIGNvbnN0IHVjczQgPSAoaW5wdXRbaV0gJiAweDFGKSA8PCA2IHwgaW5wdXRbaSArIDFdICYgMHgzRjtcXG4gICAgICAgICAgaWYgKHVjczQgPj0gMHg4MCkge1xcbiAgICAgICAgICAgIG91dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUodWNzNCAmIDB4RkZGRikpO1xcbiAgICAgICAgICAgIGkgKz0gMjtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXRbaV0gPCAweEYwKSB7XFxuICAgICAgICBpZiAoVVRGOC5fY2hlY2tDb250aW51YXRpb24oaW5wdXQsIGksIDIpKSB7XFxuICAgICAgICAgIGNvbnN0IHVjczQgPSAoaW5wdXRbaV0gJiAweEYpIDw8IDEyIHwgKGlucHV0W2kgKyAxXSAmIDB4M0YpIDw8IDYgfCBpbnB1dFtpICsgMl0gJiAweDNGO1xcbiAgICAgICAgICBpZiAodWNzNCA+PSAweDgwMCAmJiAodWNzNCAmIDB4RjgwMCkgIT09IDB4RDgwMCkge1xcbiAgICAgICAgICAgIG91dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUodWNzNCAmIDB4RkZGRikpO1xcbiAgICAgICAgICAgIGkgKz0gMztcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXRbaV0gPCAweEY4KSB7XFxuICAgICAgICBpZiAoVVRGOC5fY2hlY2tDb250aW51YXRpb24oaW5wdXQsIGksIDMpKSB7XFxuICAgICAgICAgIGxldCB1Y3M0ID0gKGlucHV0W2ldICYgMHg3KSA8PCAxOCB8IChpbnB1dFtpICsgMV0gJiAweDNGKSA8PCAxMiB8IChpbnB1dFtpICsgMl0gJiAweDNGKSA8PCA2IHwgaW5wdXRbaSArIDNdICYgMHgzRjtcXG4gICAgICAgICAgaWYgKHVjczQgPiAweDEwMDAwICYmIHVjczQgPCAweDExMDAwMCkge1xcbiAgICAgICAgICAgIHVjczQgLT0gMHgxMDAwMDtcXG4gICAgICAgICAgICBvdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHVjczQgPj4+IDEwIHwgMHhEODAwKSk7XFxuICAgICAgICAgICAgb3V0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSh1Y3M0ICYgMHgzRkYgfCAweERDMDApKTtcXG4gICAgICAgICAgICBpICs9IDQ7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgb3V0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpKTtcXG4gICAgICArK2k7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG91dC5qb2luKCcnKTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBfY2hlY2tDb250aW51YXRpb24odWludDhhcnJheSwgc3RhcnQsIGNoZWNrTGVuZ3RoKSB7XFxuICAgIGxldCBhcnJheSA9IHVpbnQ4YXJyYXk7XFxuICAgIGlmIChzdGFydCArIGNoZWNrTGVuZ3RoIDwgYXJyYXkubGVuZ3RoKSB7XFxuICAgICAgd2hpbGUgKGNoZWNrTGVuZ3RoLS0pIHtcXG4gICAgICAgIGlmICgoYXJyYXlbKytzdGFydF0gJiAweEMwKSAhPT0gMHg4MCkge1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBVVEY4O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9zcmMvZW52L3V0ZjguanM/XCIpfSxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvYXVkaW8tY29udGV4dC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vYmlsZS9hdWRpby1jb250ZXh0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoJ1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgX2V2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGV2ZW50cyAqLyBcIi4uLy4uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzXCIpO1xcblxcbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG5jbGFzcyBBdWRpb0N0eCBleHRlbmRzIF9ldmVudHMyLmRlZmF1bHQge1xcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XFxuICAgIHN1cGVyKCk7XFxuICAgIHRoaXMuY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcXG4gICAgbGV0IEF1ZGlvQ29udGV4dCA9IHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDtcXG4gICAgdGhpcy5jb250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xcbiAgICB0aGlzLmdhaW5Ob2RlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcXG4gICAgdGhpcy5nYWluTm9kZS5jb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbik7XFxuICAgIHRoaXMubWV0YSA9IHVuZGVmaW5lZDtcXG4gICAgdGhpcy5zYW1wbGVzID0gW107XFxuICAgIHRoaXMucHJlbG9hZFRpbWUgPSB0aGlzLmNvbmZpZy5wcmVsb2FkVGltZSB8fCAzO1xcbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcXG5cXG4gICAgdGhpcy5fY3VycmVudEJ1ZmZlciA9IHVuZGVmaW5lZDtcXG4gICAgdGhpcy5fbmV4dEJ1ZmZlciA9IHVuZGVmaW5lZDtcXG4gICAgdGhpcy5fbGFzdHB0cyA9IHVuZGVmaW5lZDtcXG4gICAgdGhpcy5fcHJlRGVjb2RlID0gW107XFxuICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gMDtcXG4gICAgdGhpcy5fZGVjb2RpbmcgPSBmYWxzZTtcXG4gICAgLy8g6K6w5b2V5aSW6YOo5Lyg6L6T55qE54q25oCBXFxuICAgIHRoaXMuX3BsYXllZCA9IGZhbHNlO1xcbiAgfVxcblxcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFRpbWU7XFxuICB9XFxuXFxuICBkZWNvZGVBdWRpbyhhdWRpb1RyYWNrKSB7XFxuICAgIGxldCB7IHNhbXBsZXMgfSA9IGF1ZGlvVHJhY2s7XFxuICAgIGxldCBkYXRhID0gc2FtcGxlcztcXG4gICAgYXVkaW9UcmFjay5zYW1wbGVzID0gW107XFxuICAgIHRoaXMuc2V0QXVkaW9EYXRhKGRhdGEpO1xcbiAgfVxcbiAgc2V0QXVkaW9EYXRhKGRhdGEpIHtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgZGF0YVtpXS5wdHMgPSBkYXRhW2ldLnB0cyA9PT0gdW5kZWZpbmVkID8gZGF0YVtpXS5kdHMgOiBkYXRhW2ldLnB0cztcXG4gICAgICB0aGlzLl9wcmVEZWNvZGUucHVzaChkYXRhW2ldKTtcXG4gICAgfVxcbiAgICBpZiAodGhpcy5fcHJlRGVjb2RlLmxlbmd0aCA+IDApIHtcXG4gICAgICBpZiAodGhpcy5fbGFzdHB0cyA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICB0aGlzLl9sYXN0cHRzID0gdGhpcy5fcHJlRGVjb2RlWzBdLnB0cztcXG4gICAgICB9XFxuICAgICAgaWYgKCh0aGlzLl9wcmVEZWNvZGVbdGhpcy5fcHJlRGVjb2RlLmxlbmd0aCAtIDFdLnB0cyAtIHRoaXMuX2xhc3RwdHMpIC8gMTAwMCA+IHRoaXMucHJlbG9hZFRpbWUpIHtcXG4gICAgICAgIHRoaXMuZGVjb2RlQUFDKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBkZWNvZGVBQUMoKSB7XFxuICAgIGlmICh0aGlzLl9kZWNvZGluZykge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICB0aGlzLl9kZWNvZGluZyA9IHRydWU7XFxuICAgIGxldCBkYXRhID0gdGhpcy5fcHJlRGVjb2RlO1xcbiAgICBsZXQgc2FtcGxlcyA9IFtdO1xcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xcbiAgICBsZXQgc2FtcGxlID0gZGF0YS5zaGlmdCgpO1xcbiAgICB3aGlsZSAoc2FtcGxlKSB7XFxuICAgICAgbGV0IHNhbXBsZURhdGEgPSBBdWRpb0N0eC5nZXRBQUNEYXRhKHRoaXMubWV0YSwgc2FtcGxlKTtcXG4gICAgICBzYW1wbGVzLnB1c2goc2FtcGxlRGF0YSk7XFxuICAgICAgdGhpcy5fbGFzdHB0cyA9IHNhbXBsZS5wdHM7XFxuICAgICAgc2FtcGxlID0gZGF0YS5zaGlmdCgpO1xcbiAgICB9XFxuICAgIGxldCBidWZmZXIgPSBBdWRpb0N0eC5jb21iaWxlRGF0YShzYW1wbGVzKTtcXG4gICAgdHJ5IHtcXG4gICAgICB0aGlzLmNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKGJ1ZmZlci5idWZmZXIsIGZ1bmN0aW9uIChidWZmZXIpIHtcXG4gICAgICAgIGxldCBhdWRpb1NvdXJjZSA9IF90aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XFxuICAgICAgICBhdWRpb1NvdXJjZS5idWZmZXIgPSBidWZmZXI7XFxuICAgICAgICBhdWRpb1NvdXJjZS5vbmVuZGVkID0gX3RoaXMub25Tb3VyY2VFbmRlZC5iaW5kKF90aGlzKTtcXG4gICAgICAgIF90aGlzLnNhbXBsZXMucHVzaCh7XFxuICAgICAgICAgIHRpbWU6IF90aGlzLmR1cmF0aW9uLFxcbiAgICAgICAgICBkdXJhdGlvbjogYnVmZmVyLmR1cmF0aW9uLFxcbiAgICAgICAgICBkYXRhOiBhdWRpb1NvdXJjZVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBfdGhpcy5kdXJhdGlvbiArPSBidWZmZXIuZHVyYXRpb247XFxuXFxuICAgICAgICBpZiAoIV90aGlzLl9jdXJyZW50QnVmZmVyKSB7XFxuICAgICAgICAgIF90aGlzLl9jdXJyZW50QnVmZmVyID0gX3RoaXMuZ2V0VGltZUJ1ZmZlcihfdGhpcy5jdXJyZW50VGltZSk7XFxuXFxuICAgICAgICAgIGlmIChfdGhpcy5fcGxheWVkKSB7XFxuICAgICAgICAgICAgX3RoaXMucGxheSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIV90aGlzLl9uZXh0QnVmZmVyICYmIF90aGlzLl9jdXJyZW50QnVmZmVyKSB7XFxuICAgICAgICAgIF90aGlzLl9uZXh0QnVmZmVyID0gX3RoaXMuZ2V0VGltZUJ1ZmZlcihfdGhpcy5jdXJyZW50VGltZSArIF90aGlzLl9jdXJyZW50QnVmZmVyLmR1cmF0aW9uKTtcXG4gICAgICAgIH1cXG4gICAgICAgIF90aGlzLl9kZWNvZGluZyA9IGZhbHNlO1xcblxcbiAgICAgICAgaWYgKChfdGhpcy5fcHJlRGVjb2RlLmxlbmd0aCA+IDAgJiYgX3RoaXMuX3ByZURlY29kZVtfdGhpcy5fcHJlRGVjb2RlLmxlbmd0aCAtIDFdLnB0cyAtIF90aGlzLl9sYXN0cHRzKSAvIDEwMDAgPj0gX3RoaXMucHJlbG9hZFRpbWUpIHtcXG4gICAgICAgICAgX3RoaXMuZGVjb2RlQUFDKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgb25Tb3VyY2VFbmRlZCgpIHtcXG4gICAgaWYgKCF0aGlzLl9uZXh0QnVmZmVyIHx8ICF0aGlzLl9wbGF5ZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgbGV0IGF1ZGlvU291cmNlID0gdGhpcy5fbmV4dEJ1ZmZlci5kYXRhO1xcbiAgICBhdWRpb1NvdXJjZS5zdGFydCgpO1xcbiAgICBhdWRpb1NvdXJjZS5jb25uZWN0KHRoaXMuZ2Fpbk5vZGUpO1xcbiAgICB0aGlzLl9jdXJyZW50QnVmZmVyID0gdGhpcy5fbmV4dEJ1ZmZlcjtcXG4gICAgdGhpcy5fY3VycmVudFRpbWUgPSB0aGlzLl9jdXJyZW50QnVmZmVyLnRpbWU7XFxuICAgIHRoaXMuX25leHRCdWZmZXIgPSB0aGlzLmdldFRpbWVCdWZmZXIodGhpcy5jdXJyZW50VGltZSk7XFxuICAgIGlmICh0aGlzLl9jdXJyZW50QnVmZmVyKSB7XFxuICAgICAgdGhpcy5fbmV4dEJ1ZmZlciA9IHRoaXMuZ2V0VGltZUJ1ZmZlcih0aGlzLmN1cnJlbnRUaW1lICsgdGhpcy5fY3VycmVudEJ1ZmZlci5kdXJhdGlvbik7XFxuICAgIH1cXG4gICAgdGhpcy5lbWl0KFxcJ0FVRElPX1NPVVJDRV9FTkRcXCcpO1xcbiAgfVxcblxcbiAgcGxheSgpIHtcXG4gICAgdGhpcy5fcGxheWVkID0gdHJ1ZTtcXG4gICAgaWYgKCF0aGlzLl9jdXJyZW50QnVmZmVyKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGxldCBhdWRpb1NvdXJjZSA9IHRoaXMuX2N1cnJlbnRCdWZmZXIuZGF0YTtcXG4gICAgYXVkaW9Tb3VyY2UuY29ubmVjdCh0aGlzLmdhaW5Ob2RlKTtcXG4gICAgYXVkaW9Tb3VyY2Uuc3RhcnQoKTtcXG4gIH1cXG5cXG4gIGdldFRpbWVCdWZmZXIodGltZSkge1xcbiAgICBsZXQgcmV0O1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2FtcGxlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGxldCBzYW1wbGUgPSB0aGlzLnNhbXBsZXNbaV07XFxuICAgICAgaWYgKHNhbXBsZS50aW1lIDw9IHRpbWUgJiYgc2FtcGxlLnRpbWUgKyBzYW1wbGUuZHVyYXRpb24gPiB0aW1lKSB7XFxuICAgICAgICByZXQgPSBzYW1wbGU7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHJldDtcXG4gIH1cXG5cXG4gIHNldEF1ZGlvTWV0YURhdGEobWV0YSkge1xcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xcbiAgfVxcblxcbiAgc3RhdGljIGdldEFBQ0RhdGEobWV0YSwgc2FtcGxlKSB7XFxuICAgIGxldCBidWZmZXIgPSBuZXcgVWludDhBcnJheShzYW1wbGUuZGF0YS5ieXRlTGVuZ3RoICsgNyk7XFxuICAgIGxldCBhZHRzID0gQXVkaW9DdHguZ2V0QWR0cyhtZXRhLCBzYW1wbGUuZGF0YSk7XFxuICAgIGJ1ZmZlci5zZXQoYWR0cyk7XFxuICAgIGJ1ZmZlci5zZXQoc2FtcGxlLmRhdGEsIDcpO1xcbiAgICByZXR1cm4gYnVmZmVyO1xcbiAgfVxcblxcbiAgc3RhdGljIGNvbWJpbGVEYXRhKHNhbXBsZXMpIHtcXG4gICAgLy8gZ2V0IGxlbmd0aFxcbiAgICBsZXQgbGVuZ3RoID0gMDtcXG4gICAgZm9yIChsZXQgaSA9IDAsIGsgPSBzYW1wbGVzLmxlbmd0aDsgaSA8IGs7IGkrKykge1xcbiAgICAgIGxlbmd0aCArPSBzYW1wbGVzW2ldLmJ5dGVMZW5ndGg7XFxuICAgIH1cXG5cXG4gICAgbGV0IHJldCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XFxuICAgIGxldCBvZmZzZXQgPSAwO1xcbiAgICAvLyBjb21iaWxlIGRhdGE7XFxuICAgIGZvciAobGV0IGkgPSAwLCBrID0gc2FtcGxlcy5sZW5ndGg7IGkgPCBrOyBpKyspIHtcXG4gICAgICByZXQuc2V0KHNhbXBsZXNbaV0sIG9mZnNldCk7XFxuICAgICAgb2Zmc2V0ICs9IHNhbXBsZXNbaV0uYnl0ZUxlbmd0aDtcXG4gICAgfVxcbiAgICByZXR1cm4gcmV0O1xcbiAgfVxcblxcbiAgc3RhdGljIGdldEFkdHMobWV0YSwgZGF0YSkge1xcbiAgICBsZXQgYWR0cyA9IG5ldyBVaW50OEFycmF5KDcpO1xcblxcbiAgICAvLyDorr7nva7lkIzmraXkvY0gMHhmZmYgMTJiaXRcXG4gICAgYWR0c1swXSA9IDB4ZmY7XFxuICAgIGFkdHNbMV0gPSAweGYwO1xcblxcbiAgICAvLyBPYmplY3QgZGF0YSAo5rKh5LuA5LmI5Lq655SoTVBFRy0y5LqG77yMSExT5ZKMRkxW5Lmf5YWo5pivTVBFRy0077yM6L+Z6YeM55u05o6lMCkgIDFiaXRcXG4gICAgLy8gTGV2ZWwgYWx3YXlzIDAwIDJiaXRcXG4gICAgLy8gQ1JDIGFsd2F5cyAxIDFiaXRcXG4gICAgYWR0c1sxXSA9IGFkdHNbMV0gfCAweDAxO1xcblxcbiAgICAvLyBwcm9maWxlIDJiaXRcXG4gICAgYWR0c1syXSA9IDB4YzAgJiBtZXRhLm9iamVjdFR5cGUgLSAxIDw8IDY7XFxuXFxuICAgIC8vc2FtcGxlRnJlcXVlbmN5SW5kZXhcXG4gICAgYWR0c1syXSA9IGFkdHNbMl0gfCAweDNjICYgbWV0YS5zYW1wbGVSYXRlSW5kZXggPDwgMjtcXG5cXG4gICAgLy9wcml2YXRlIGJpdCAwIDFiaXRcXG4gICAgLy8gY2hhbmVsIGNvbmZpZ3VyYXRpb24gM2JpdFxcbiAgICBhZHRzWzJdID0gYWR0c1syXSB8IDB4MDEgJiBtZXRhLmNoYW5uZWxDb3VudCA+PiAyO1xcbiAgICBhZHRzWzNdID0gMHhjMCAmIG1ldGEuY2hhbm5lbENvdW50IDw8IDY7XFxuXFxuICAgIC8vIG9yaWdpbmFsX2NvcHk6IDAgMWJpdFxcbiAgICAvLyBob21lOiAwIDFiaXRcXG5cXG4gICAgLy8gYWR0c192YXJpYWJsZV9oZWFkZXIoKVxcbiAgICAvLyBjb3B5cmlnaHRlZF9pZF9iaXQgMCAxYml0XFxuICAgIC8vIGNvcHlyaWdodGVkX2lkX3N0YXJ0IDAgMWJpdFxcblxcbiAgICAvLyBhYWNfZnJhbWVfbGVuZ3RoIDEzYml0O1xcbiAgICBsZXQgYWFjZnJhbWVsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGggKyA3O1xcblxcbiAgICBhZHRzWzNdID0gYWR0c1szXSB8IDB4MDMgJiBhYWNmcmFtZWxlbmd0aCA+PiAxMTtcXG4gICAgYWR0c1s0XSA9IDB4ZmYgJiBhYWNmcmFtZWxlbmd0aCA+PiAzO1xcbiAgICBhZHRzWzVdID0gMHhlMCAmIGFhY2ZyYW1lbGVuZ3RoIDw8IDU7XFxuXFxuICAgIC8vIGFkdHNfYnVmZmVyX2Z1bGxuZXNzIDB4N2ZmIDExYml0XFxuICAgIGFkdHNbNV0gPSBhZHRzWzVdIHwgMHgxZjtcXG4gICAgYWR0c1s2XSA9IDB4ZmM7XFxuXFxuICAgIC8vIG51bWJlcl9vZl9yYXdfZGF0YV9ibG9ja3NfaW5fZnJhbWUgMCAyYml0O1xcbiAgICByZXR1cm4gYWR0cztcXG4gIH1cXG59XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gQXVkaW9DdHg7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvYXVkaW8tY29udGV4dC5qcz8nKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvbW9iaWxlL21vYmlsZS12aWRlby5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci11dGlscy9zcmMvbW9iaWxlL21vYmlsZS12aWRlby5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG52YXIgX3ZpZGVvQ29udGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdmlkZW8tY29udGV4dCAqLyBcXFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vYmlsZS92aWRlby1jb250ZXh0LmpzXFxcIik7XFxuXFxudmFyIF92aWRlb0NvbnRleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlkZW9Db250ZXh0KTtcXG5cXG52YXIgX2F1ZGlvQ29udGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYXVkaW8tY29udGV4dCAqLyBcXFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vYmlsZS9hdWRpby1jb250ZXh0LmpzXFxcIik7XFxuXFxudmFyIF9hdWRpb0NvbnRleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXVkaW9Db250ZXh0KTtcXG5cXG52YXIgX3RpY2tlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGlja2VyICovIFxcXCIuLi94Z3BsYXllci11dGlscy9zcmMvbW9iaWxlL3RpY2tlci5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFxuLyoqXFxuICog6Z+z55S75ZCM5q2l6LCD5ZKM5ZmoXFxuICovXFxuY2xhc3MgQVZSZWNvbmNpbGVyIHtcXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XFxuICAgIHRoaXMuYUN0eCA9IHByb3BzLmFDdHg7XFxuICAgIHRoaXMudkN0eCA9IHByb3BzLnZDdHg7XFxuICAgIHRoaXMudmlkZW8gPSBwcm9wcy52aWRlbztcXG4gICAgdGhpcy50aW1lb3V0SWQgPSBudWxsO1xcbiAgICB0aGlzLnN0YXJ0ID0gbnVsbDtcXG4gIH1cXG5cXG4gIGRvUmVjb25jaWxlKCkge1xcbiAgICBjb25zdCB2Q3VyVGltZSA9ICh0aGlzLnZpZGVvLmN1cnJlbnRUaW1lIHx8IDApICogMTAwMDtcXG4gICAgY29uc3QgYUN1clRpbWUgPSAodGhpcy5hQ3R4LmN1cnJlbnRUaW1lIHx8IDApICogMTAwMDtcXG5cXG4gICAgY29uc3QgZ2FwID0gdkN1clRpbWUgLSBhQ3VyVGltZTtcXG4gICAgaWYgKHRoaXMudGltZW91dElkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGlmIChnYXAgPiAyMDApIHtcXG4gICAgICAvLyBhdWRpbyBkZWxheWVkIGZvciBtb3JlIHRoYW4gMTAwbXNcXG4gICAgICBjb25zb2xlLmxvZyhnYXApO1xcbiAgICAgIHRoaXMudmlkZW8uc3RhcnQgKz0gZ2FwO1xcbiAgICAgIHRoaXMudkN0eC5wYXVzZSgpO1xcbiAgICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XFxuICAgICAgICB0aGlzLnZDdHgucGxheSgpO1xcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBudWxsO1xcbiAgICAgIH0sIGdhcCk7XFxuICAgIH0gZWxzZSBpZiAoZ2FwIDwgLTEyMCkge1xcbiAgICAgIHRoaXMudkN0eC5jdXJyZW50VGltZSA9IHRoaXMudkN0eC5jdXJyZW50VGltZSArIE1hdGguYWJzKGdhcCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGRlc3Ryb3koKSB7XFxuICAgIHRoaXMuYUN0eCA9IG51bGw7XFxuICAgIHRoaXMudkN0eCA9IG51bGw7XFxuICB9XFxufVxcblxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxcbmNsYXNzIE1vYmlsZVZpZGVvIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XFxuICAgIHN1cGVyKCk7XFxuICAgIGxldCBfdGhpcyA9IHRoaXM7XFxuICAgIHRoaXMudkN0eCA9IG5ldyBfdmlkZW9Db250ZXh0Mi5kZWZhdWx0KCk7XFxuICAgIHRoaXMuYUN0eCA9IG5ldyBfYXVkaW9Db250ZXh0Mi5kZWZhdWx0KGNvbmZpZyk7XFxuICAgIHRoaXMudGlja2VyID0gbmV3ICgoMCwgX3RpY2tlci5nZXRUaWNrZXIpKCkpKCk7XFxuICAgIHRoaXMuaGlzdG9yeVRpbWUgPSAwO1xcbiAgICB0aGlzLnJlY29uY2lsZXIgPSBuZXcgQVZSZWNvbmNpbGVyKHtcXG4gICAgICB2Q3R4OiB0aGlzLnZDdHgsXFxuICAgICAgYUN0eDogdGhpcy5hQ3R4LFxcbiAgICAgIHZpZGVvOiB0aGlzXFxuICAgIH0pO1xcbiAgICB0aGlzLmhhbmRsZUF1ZGlvU291cmNlRW5kID0gdGhpcy5oYW5kbGVBdWRpb1NvdXJjZUVuZC5iaW5kKHRoaXMpO1xcbiAgICB0aGlzLmluaXQoKTtcXG4gIH1cXG5cXG4gIGluaXQoKSB7XFxuICAgIHRoaXMudkN0eC5vbmNhbnBsYXkgPSAoKSA9PiB7XFxuICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLnZDdHguY2FudmFzKTtcXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjYW5wbGF5JykpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnRpY2tlci5zdGFydCgoKSA9PiB7XFxuICAgICAgLy9cXG4gICAgICBpZiAoIXRoaXMuc3RhcnQpIHtcXG4gICAgICAgIHRoaXMuc3RhcnQgPSBEYXRlLm5vdygpO1xcbiAgICAgIH1cXG4gICAgICB0aGlzLl9jdXJyZW50VGltZSA9IERhdGUubm93KCkgLSB0aGlzLnN0YXJ0O1xcbiAgICAgIHRoaXMudkN0eC5fb25UaW1lcih0aGlzLl9jdXJyZW50VGltZSk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLmFDdHgub24oJ0FVRElPX1NPVVJDRV9FTkQnLCB0aGlzLmhhbmRsZUF1ZGlvU291cmNlRW5kKTtcXG4gIH1cXG5cXG4gIGhhbmRsZUF1ZGlvU291cmNlRW5kKCkge1xcbiAgICBjb25zb2xlLmxvZyh0aGlzLmFDdHguY3VycmVudFRpbWUpO1xcbiAgICB0aGlzLnJlY29uY2lsZXIuZG9SZWNvbmNpbGUoKTtcXG4gIH1cXG5cXG4gIF9jbGVhbkJ1ZmZlcigpIHtcXG4gICAgdGhpcy52Q3R4LmNsZWFuQnVmZmVyKCk7XFxuICB9XFxuXFxuICBkZXN0cm95KCkge1xcbiAgICB0aGlzLnJlY29uY2lsZXIuZGVzdHJveSgpO1xcbiAgfVxcblxcbiAgb25EZW11eENvbXBsZXRlKHZpZGVvVHJhY2ssIGF1ZGlvVHJhY2spIHtcXG4gICAgdGhpcy5hQ3R4LmRlY29kZUF1ZGlvKGF1ZGlvVHJhY2spO1xcbiAgICB0aGlzLnZDdHguZGVjb2RlVmlkZW8odmlkZW9UcmFjayk7XFxuICB9XFxuXFxuICBzZXRBdWRpb01ldGEobWV0YSkge1xcbiAgICB0aGlzLmFDdHguc2V0QXVkaW9NZXRhRGF0YShtZXRhKTtcXG4gIH1cXG5cXG4gIHNldFZpZGVvTWV0YShtZXRhKSB7XFxuICAgIHRoaXMudkN0eC5zZXRWaWRlb01ldGFEYXRhKG1ldGEpO1xcbiAgfVxcblxcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFRpbWUgLyAxMDAwO1xcbiAgfVxcblxcbiAgcGxheSgpIHtcXG4gICAgLy8gaWYgKCF0aGlzLnZDdHguKVxcbiAgICB0aGlzLnZDdHgucGxheSgpO1xcbiAgICB0aGlzLmFDdHgucGxheSgpO1xcbiAgfVxcbn1cXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ21vYmlsZS12aWRlbycsIE1vYmlsZVZpZGVvKTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vYmlsZS9tb2JpbGUtdmlkZW8uanM/XCIpfSxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvc291cmNlYnVmZmVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvc291cmNlYnVmZmVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuY2xhc3MgU291cmNlQnVmZmVyIHtcXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xcbiAgICB0aGlzLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyk7XFxuICAgIHRoaXMudHlwZSA9IHRoaXMuY29uZmlnLnR5cGU7XFxuICAgIHRoaXMuYnVmZmVyID0gW107XFxuICAgIHRoaXMuY3VycmVudEdvcCA9IHVuZGVmaW5lZDtcXG4gICAgdGhpcy5fbGFzdEdldCA9IHVuZGVmaW5lZDtcXG4gIH1cXG5cXG4gIHB1c2goZnJhbWUpIHtcXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ3ZpZGVvJykge1xcbiAgICAgIGlmIChmcmFtZS5pc0tleWZyYW1lKSB7XFxuICAgICAgICBsZXQgY3VycmVudEdvcCA9IHtcXG4gICAgICAgICAgc2FtcGxlczogW10sXFxuICAgICAgICAgIHN0YXJ0OiBmcmFtZS5kdHMsXFxuICAgICAgICAgIGVuZDogZnJhbWUuZHRzLFxcbiAgICAgICAgICBuZXh0R29wOiB1bmRlZmluZWRcXG4gICAgICAgIH07XFxuICAgICAgICBpZiAodGhpcy5jdXJyZW50R29wKSB7XFxuICAgICAgICAgIHRoaXMuY3VycmVudEdvcC5uZXh0R29wID0gY3VycmVudEdvcDtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMuY3VycmVudEdvcCA9IGN1cnJlbnRHb3A7XFxuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMuY3VycmVudEdvcCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRHb3ApIHtcXG4gICAgICAgIHRoaXMuY3VycmVudEdvcC5zYW1wbGVzLnB1c2goZnJhbWUpO1xcblxcbiAgICAgICAgaWYgKGZyYW1lLmR0cyA8IHRoaXMuY3VycmVudEdvcC5zdGFydCkge1xcbiAgICAgICAgICB0aGlzLmN1cnJlbnRHb3Auc3RhcnQgPSBmcmFtZS5kdHM7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZnJhbWUuZHRzID4gdGhpcy5jdXJyZW50R29wLmVuZCkge1xcbiAgICAgICAgICB0aGlzLmN1cnJlbnRHb3AuZW5kID0gZnJhbWUuZHRzO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZ2V0KHRpbWUpIHtcXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ3ZpZGVvJykge1xcbiAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPCAxKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aW1lID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIGxldCBzYW1wbGUgPSB0aGlzLl9nZXROZXh0KCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgX2dldE5leHQoKSB7XFxuICAgIGlmICghdGhpcy5fbGFzdEdldCkge1xcbiAgICAgIGxldCBnb3AgPSB0aGlzLmJ1ZmZlclswXTtcXG4gICAgICBpZiAoZ29wLnNhbXBsZXMubGVuZ3RoIDwgMSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9sYXN0R2V0ID0ge1xcbiAgICAgICAgZ29wLFxcbiAgICAgICAgaW5kZXg6IDBcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiBnb3Auc2FtcGxlc1swXTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBsZXQgZ29wID0gdGhpcy5fbGFzdEdldC5nb3A7XFxuICAgICAgbGV0IHNhbXBsZSA9IGdvcC5zYW1wbGVzW3RoaXMuX2xhc3RHZXQuaW5kZXggKyAxXTtcXG4gICAgICBpZiAoc2FtcGxlKSB7XFxuICAgICAgICB0aGlzLl9sYXN0R2V0LmluZGV4ID0gdGhpcy5fbGFzdEdldC5pbmRleCArIDE7XFxuICAgICAgICByZXR1cm4gc2FtcGxlO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBnb3AgPSBnb3AubmV4dEdvcDtcXG4gICAgICAgIGlmICghZ29wIHx8IGdvcC5zYW1wbGVzLmxlbmd0aCA8IDEpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2FtcGxlID0gZ29wLnNhbXBsZXNbMF07XFxuICAgICAgICB0aGlzLl9sYXN0R2V0ID0ge1xcbiAgICAgICAgICBnb3AsXFxuICAgICAgICAgIGluZGV4OiAwXFxuICAgICAgICB9O1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJlbW92ZShzdGFydCwgZW5kKSB7XFxuICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPCAwKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGxldCBpID0gMDtcXG4gICAgbGV0IGdvcCA9IHRoaXMuYnVmZmVyWzBdO1xcbiAgICB3aGlsZSAoZ29wKSB7XFxuICAgICAgaWYgKGdvcC5lbmQgPCBlbmQgJiYgZ29wLnN0YXJ0ID49IHN0YXJ0KSB7XFxuICAgICAgICBkZWxldGUgdGhpcy5idWZmZXJbaV07XFxuICAgICAgICBnb3AgPSB0aGlzLmJ1ZmZlcltpXTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaSArPSAxO1xcbiAgICAgICAgZ29wID0gdGhpcy5idWZmZXJbaV07XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbmV4cG9ydHMuZGVmYXVsdCA9IFNvdXJjZUJ1ZmZlcjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vYmlsZS9zb3VyY2VidWZmZXIuanM/XCIpfSxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvdGlja2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvdGlja2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbCgnXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbi8qKlxcbiAqIEBhdXRob3IgZnV5dWhhb0BieXRlZGFuY2UuY29tXFxuICovXFxuXFxuY2xhc3MgVGlja2VyIHtcXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyB8fCB7fSwge1xcbiAgICAgIGludGVydmFsOiAxNlxcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcXG4gIH1cXG5cXG4gIHN0YXJ0KC4uLmNhbGxiYWNrcykge1xcbiAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcXG4gIH1cXG5cXG4gIG9uVGljaygpIHtcXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrc1tpXTtcXG4gICAgICBjYWxsYmFjaygpO1xcbiAgICB9XFxuICB9XFxuXFxuICBzZXRJbnRlcnZhbChpbnRlcnZhbCkge1xcbiAgICB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwgPSBpbnRlcnZhbDtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIHRpY2tlciB1c2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXFxuICovXFxuY2xhc3MgUmFmVGlja2VyIGV4dGVuZHMgVGlja2VyIHtcXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XFxuICAgIHN1cGVyKHByb3BzKTtcXG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcXG4gICAgdGhpcy50aW1lcklkID0gbnVsbDtcXG4gICAgdGhpcy5fc3ViVGltZXJJZCA9IG51bGw7XFxuXFxuICAgIHRoaXMuX3RpY2tGdW5jID0gUmFmVGlja2VyLmdldFRpY2tGdW5jKCk7XFxuICAgIHRoaXMudGljayA9IHRoaXMudGljay5iaW5kKHRoaXMpO1xcbiAgfVxcblxcbiAgc3RhcnQoLi4uY2FsbGJhY2tzKSB7XFxuICAgIHN1cGVyLnN0YXJ0KC4uLmNhbGxiYWNrcyk7XFxuICAgIHRoaXMudGljaygpO1xcbiAgfVxcblxcbiAgdGljayh0aW1lc3RhbXApIHtcXG4gICAgdGhpcy5uZXh0VGljaygpO1xcbiAgICB0aGlzLm9uVGljaygpO1xcbiAgfVxcblxcbiAgbmV4dFRpY2soKSB7XFxuICAgIGNvbnN0IHsgX3RpY2tGdW5jIH0gPSB0aGlzO1xcbiAgICB0aGlzLnRpbWVySWQgPSBfdGlja0Z1bmModGhpcy50aWNrKTtcXG4gIH1cXG5cXG4gIHN0b3AoKSB7XFxuICAgIGlmICh0aGlzLnRpbWVySWQpIHtcXG4gICAgICBjb25zdCBjYW5jZWxGdW5jID0gUmFmVGlja2VyLmdldENhbmNlbEZ1bmMoKTtcXG5cXG4gICAgICBjYW5jZWxGdW5jKHRoaXMudGltZXJJZCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXRUaWNrRnVuYygpIHtcXG4gICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXRDYW5jZWxGdW5jKCkge1xcbiAgICByZXR1cm4gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBpc1N1cHBvcnRlZCgpIHtcXG4gICAgcmV0dXJuIFJhZlRpY2tlci5nZXRUaWNrRnVuYygpICE9PSB1bmRlZmluZWQ7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIHVzZSBzZXRUaW1lb3V0IGZvciBicm93c2VycyB3aXRob3V0IHJhZiBzdXBwb3J0XFxuICovXFxuY2xhc3MgVGltZW91dFRpY2tlciBleHRlbmRzIFRpY2tlciB7XFxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcXG4gICAgc3VwZXIoY29uZmlnKTtcXG4gICAgdGhpcy50aW1lb3V0SWQgPSBudWxsO1xcbiAgfVxcblxcbiAgc3RhcnQoLi4uY2FsbGJhY2tzKSB7XFxuICAgIHN1cGVyLm5leHRUaWNrKC4uLmNhbGxiYWNrcyk7XFxuICAgIHRoaXMudGltZW91dElkID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHtcXG4gICAgICB0aGlzLm9uVGljaygpO1xcbiAgICB9LCB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwgfHwgMTYpO1xcbiAgfVxcblxcbiAgc3RvcCgpIHtcXG4gICAgaWYgKHRoaXMudGltZW91dElkKSB7XFxuICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy50aW1lb3V0SWQpO1xcbiAgICB9XFxuICB9XFxuXFxufVxcblxcbi8qKlxcbiAqIOi/lOWbnlRpY2tlcuaehOmAoOWHveaVsFxcbiAqIEByZXR1cm5zIHtUaWNrZXJ9XFxuICovXFxuY29uc3QgZ2V0VGlja2VyID0gZXhwb3J0cy5nZXRUaWNrZXIgPSAoKSA9PiB7XFxuICBpZiAoUmFmVGlja2VyLmlzU3VwcG9ydGVkKCkpIHtcXG4gICAgcmV0dXJuIFJhZlRpY2tlcjtcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBUaW1lb3V0VGlja2VyO1xcbiAgfVxcbn07XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvdGlja2VyLmpzPycpfSxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvdmlkZW8tY29udGV4dC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vYmlsZS92aWRlby1jb250ZXh0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBfd2Vid29ya2lmeVdlYnBhY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB3ZWJ3b3JraWZ5LXdlYnBhY2sgKi8gXFxcIi4uL3hncGxheWVyLXV0aWxzL25vZGVfbW9kdWxlcy93ZWJ3b3JraWZ5LXdlYnBhY2svaW5kZXguanNcXFwiKTtcXG5cXG52YXIgX3dlYndvcmtpZnlXZWJwYWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dlYndvcmtpZnlXZWJwYWNrKTtcXG5cXG52YXIgX3N0cmVhbSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3dyaXRlL3N0cmVhbSAqLyBcXFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL3dyaXRlL3N0cmVhbS5qc1xcXCIpO1xcblxcbnZhciBfc3RyZWFtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmVhbSk7XFxuXFxudmFyIF9uYWx1bml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vLi4veGdwbGF5ZXItY29kZWMvc3JjL2gyNjQvbmFsdW5pdCAqLyBcXFwiLi4veGdwbGF5ZXItY29kZWMvc3JjL2gyNjQvbmFsdW5pdC9pbmRleC5qc1xcXCIpO1xcblxcbnZhciBfbmFsdW5pdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9uYWx1bml0KTtcXG5cXG52YXIgX3l1dkNhbnZhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4veXV2LWNhbnZhcyAqLyBcXFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vYmlsZS95dXYtY2FudmFzLmpzXFxcIik7XFxuXFxudmFyIF95dXZDYW52YXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfeXV2Q2FudmFzKTtcXG5cXG52YXIgX3NvdXJjZWJ1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc291cmNlYnVmZmVyICovIFxcXCIuLi94Z3BsYXllci11dGlscy9zcmMvbW9iaWxlL3NvdXJjZWJ1ZmZlci5qc1xcXCIpO1xcblxcbnZhciBfc291cmNlYnVmZmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NvdXJjZWJ1ZmZlcik7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG5jbGFzcyBWaWRlb0NhbnZhcyB7XFxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcXG4gICAgdGhpcy5jb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcpO1xcbiAgICB0aGlzLmNhbnZhcyA9IHRoaXMuY29uZmlnLmNhbnZhcyA/IHRoaXMuY29uZmlnLmNhbnZhcyA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xcbiAgICB0aGlzLnNvdXJjZSA9IG5ldyBfc291cmNlYnVmZmVyMi5kZWZhdWx0KHsgdHlwZTogJ3ZpZGVvJyB9KTtcXG4gICAgdGhpcy5wcmVsb2FkVGltZSA9IHRoaXMuY29uZmlnLnByZWxvYWRUaW1lIHx8IDM7XFxuICAgIHRoaXMub25jYW5wbGF5ID0gdW5kZWZpbmVkO1xcbiAgICB0aGlzLm9uRmlyc3RGcmFtZSA9IHVuZGVmaW5lZDtcXG4gICAgdGhpcy5tZXRhID0gdW5kZWZpbmVkO1xcbiAgICB0aGlzLnJlYWR5U3RhdHVzID0gMDtcXG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xcbiAgICB0aGlzLmNvdW50ID0gMDtcXG4gICAgdGhpcy5jdXJyZW50VGltZSA9IDA7XFxuICAgIHRoaXMubGFzdFBsYXllZCA9IDA7XFxuXFxuICAgIHRoaXMuX2RlY29kZXJJbml0ZWQgPSBmYWxzZTtcXG4gICAgdGhpcy5fYXZjY3B1c2hlZCA9IGZhbHNlO1xcbiAgICB0aGlzLl9kZWNvZGVkRnJhbWVzID0ge307XFxuICAgIHRoaXMuX2xhc3RTYW1wbGVEdHMgPSB1bmRlZmluZWQ7XFxuICAgIHRoaXMuX2Jhc2VEdHMgPSB1bmRlZmluZWQ7XFxuICAgIHRoaXMuX2xhc3RSZW5kZXJUaW1lID0gbnVsbDtcXG4gICAgdGhpcy5wbGF5RmluaXNoID0gbnVsbDtcXG4gIH1cXG5cXG4gIHBhdXNlKCkge1xcbiAgICB0aGlzLnBhdXNlZCA9IHRydWU7XFxuICB9XFxuXFxuICBpbml0V2FzbVdvcmtlcigpIHtcXG4gICAgbGV0IF90aGlzID0gdGhpcztcXG4gICAgdGhpcy53YXNtd29ya2VyID0gKDAsIF93ZWJ3b3JraWZ5V2VicGFjazIuZGVmYXVsdCkoLypyZXF1aXJlLnJlc29sdmUqLygvKiEgLi93b3JrZXIuanMgKi8gXFxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvd29ya2VyLmpzXFxcIikpO1xcbiAgICB0aGlzLndhc213b3JrZXIucG9zdE1lc3NhZ2Uoe1xcbiAgICAgIG1zZzogJ2luaXQnLFxcbiAgICAgIG1ldGE6IHRoaXMubWV0YVxcbiAgICB9KTtcXG4gICAgdGhpcy53YXNtd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBtc2cgPT4ge1xcbiAgICAgIHN3aXRjaCAobXNnLmRhdGEubXNnKSB7XFxuICAgICAgICBjYXNlICdERUNPREVSX1JFQURZJzpcXG4gICAgICAgICAgX3RoaXMuX2RlY29kZXJJbml0ZWQgPSB0cnVlO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgJ0RFQ09ERUQnOlxcbiAgICAgICAgICB0aGlzLl9vbkRlY29kZWQobXNnLmRhdGEpO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgc2V0VmlkZW9NZXRhRGF0YShtZXRhKSB7XFxuICAgIHRoaXMubWV0YSA9IG1ldGE7XFxuICAgIGlmICghdGhpcy5fZGVjb2RlckluaXRlZCkge1xcbiAgICAgIHRoaXMuaW5pdFdhc21Xb3JrZXIoKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgdGhpcy5fYXZjY3B1c2hlZCA9IHRydWU7XFxuICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobWV0YS5zcHMuYnl0ZUxlbmd0aCArIDQpO1xcbiAgICBkYXRhLnNldChbMCwgMCwgMCwgMV0pO1xcbiAgICBkYXRhLnNldChtZXRhLnNwcywgNCk7XFxuICAgIHRoaXMud2FzbXdvcmtlci5wb3N0TWVzc2FnZSh7XFxuICAgICAgbXNnOiAnZGVjb2RlJyxcXG4gICAgICBkYXRhOiBkYXRhXFxuICAgIH0pO1xcblxcbiAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobWV0YS5wcHMuYnl0ZUxlbmd0aCArIDQpO1xcbiAgICBkYXRhLnNldChbMCwgMCwgMCwgMV0pO1xcbiAgICBkYXRhLnNldChtZXRhLnBwcywgNCk7XFxuICAgIHRoaXMud2FzbXdvcmtlci5wb3N0TWVzc2FnZSh7XFxuICAgICAgbXNnOiAnZGVjb2RlJyxcXG4gICAgICBkYXRhOiBkYXRhXFxuICAgIH0pO1xcblxcbiAgICBpZiAoIXRoaXMueXV2Q2FudmFzKSB7XFxuICAgICAgbGV0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oeyBtZXRhLCBjYW52YXM6IHRoaXMuY2FudmFzIH0sIHRoaXMuY29uZmlnKTtcXG4gICAgICB0aGlzLnl1dkNhbnZhcyA9IG5ldyBfeXV2Q2FudmFzMi5kZWZhdWx0KGNvbmZpZyk7XFxuICAgIH1cXG4gICAgdGhpcy5yZWFkeVN0YXR1cyA9IDE7XFxuICB9XFxuXFxuICBkZWNvZGVWaWRlbyh2aWRlb1RyYWNrKSB7XFxuICAgIGlmICghdGhpcy5fZGVjb2RlckluaXRlZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAoIXRoaXMuX2F2Y2NwdXNoZWQpIHtcXG4gICAgICB0aGlzLnNldFZpZGVvTWV0YURhdGEodGhpcy5tZXRhKTtcXG4gICAgfVxcbiAgICBsZXQgeyBzYW1wbGVzIH0gPSB2aWRlb1RyYWNrO1xcbiAgICBsZXQgc2FtcGxlID0gc2FtcGxlcy5zaGlmdCgpO1xcblxcbiAgICB3aGlsZSAoc2FtcGxlKSB7XFxuICAgICAgaWYgKCF0aGlzLl9iYXNlRHRzKSB7XFxuICAgICAgICB0aGlzLl9iYXNlRHRzID0gc2FtcGxlLmR0cztcXG4gICAgICB9XFxuICAgICAgdGhpcy5zb3VyY2UucHVzaChzYW1wbGUpO1xcbiAgICAgIHNhbXBsZSA9IHNhbXBsZXMuc2hpZnQoKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9wcmVsb2FkKCk7XFxuICB9XFxuXFxuICBfcHJlbG9hZCgpIHtcXG4gICAgaWYgKCF0aGlzLl9sYXN0U2FtcGxlRHRzIHx8IHRoaXMuX2xhc3RTYW1wbGVEdHMgLSB0aGlzLl9iYXNlRHRzIDwgdGhpcy5jdXJyZW50VGltZSArIHRoaXMucHJlbG9hZFRpbWUgKiAxMDAwKSB7XFxuICAgICAgbGV0IHNhbXBsZSA9IHRoaXMuc291cmNlLmdldCgpO1xcbiAgICAgIGlmIChzYW1wbGUpIHtcXG4gICAgICAgIHRoaXMuX2xhc3RTYW1wbGVEdHMgPSBzYW1wbGUuZHRzO1xcbiAgICAgICAgdGhpcy5fYW5hbHlzZU5hbChzYW1wbGUpO1xcbiAgICAgIH1cXG5cXG4gICAgICB3aGlsZSAoc2FtcGxlICYmIHRoaXMuX2xhc3RTYW1wbGVEdHMgLSB0aGlzLl9iYXNlRHRzIDwgdGhpcy5jdXJyZW50VGltZSArIHRoaXMucHJlbG9hZFRpbWUgKiAxMDAwKSB7XFxuICAgICAgICBzYW1wbGUgPSB0aGlzLnNvdXJjZS5nZXQoKTtcXG4gICAgICAgIGlmIChzYW1wbGUpIHtcXG4gICAgICAgICAgdGhpcy5fYW5hbHlzZU5hbChzYW1wbGUpO1xcbiAgICAgICAgICB0aGlzLl9sYXN0U2FtcGxlRHRzID0gc2FtcGxlLmR0cztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIF9hbmFseXNlTmFsKHNhbXBsZSkge1xcbiAgICBsZXQgbmFscyA9IF9uYWx1bml0Mi5kZWZhdWx0LmdldEF2Y2NOYWxzKG5ldyBfc3RyZWFtMi5kZWZhdWx0KHNhbXBsZS5kYXRhLmJ1ZmZlcikpO1xcblxcbiAgICBsZXQgbGVuZ3RoID0gMDtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYWxzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgbGV0IG5hbCA9IG5hbHNbaV07XFxuICAgICAgbGVuZ3RoICs9IG5hbC5ib2R5LmJ5dGVMZW5ndGggKyA0O1xcbiAgICB9XFxuICAgIGxldCBvZmZzZXQgPSAwO1xcbiAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFscy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGxldCBuYWwgPSBuYWxzW2ldO1xcbiAgICAgIGRhdGEuc2V0KFswLCAwLCAwLCAxXSwgb2Zmc2V0KTtcXG4gICAgICBvZmZzZXQgKz0gNDtcXG4gICAgICBkYXRhLnNldChuZXcgVWludDhBcnJheShuYWwuYm9keSksIG9mZnNldCk7XFxuICAgICAgb2Zmc2V0ICs9IG5hbC5ib2R5LmJ5dGVMZW5ndGg7XFxuICAgIH1cXG4gICAgdGhpcy53YXNtd29ya2VyLnBvc3RNZXNzYWdlKHtcXG4gICAgICBtc2c6ICdkZWNvZGUnLFxcbiAgICAgIGRhdGE6IGRhdGEsXFxuICAgICAgaW5mbzoge1xcbiAgICAgICAgZHRzOiBzYW1wbGUuZHRzLFxcbiAgICAgICAgcHRzOiBzYW1wbGUucHRzID8gc2FtcGxlLnB0cyA6IHNhbXBsZS5kdHMgKyBzYW1wbGUuY3RzLFxcbiAgICAgICAga2V5OiBzYW1wbGUuaXNLZXlmcmFtZVxcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxuICBfb25EZWNvZGVkKGRhdGEpIHtcXG4gICAgbGV0IHsgZHRzIH0gPSBkYXRhLmluZm87XFxuICAgIHRoaXMuX2RlY29kZWRGcmFtZXNbZHRzXSA9IGRhdGE7XFxuICB9XFxuXFxuICBwbGF5KCkge1xcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XFxuICAgICAgdGhpcy5wbGF5RmluaXNoID0gcmVzb2x2ZTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBfb25UaW1lcihjdXJyZW50VGltZSkge1xcbiAgICBpZiAodGhpcy5wYXVzZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgaWYgKHRoaXMubWV0YSkge1xcbiAgICAgIGlmICh0aGlzLm1ldGEuZnJhbWVSYXRlICYmIHRoaXMubWV0YS5mcmFtZVJhdGUuZml4ZWQgJiYgdGhpcy5tZXRhLmZyYW1lUmF0ZS5mcHMpIHt9XFxuICAgICAgbGV0IGZyYW1lVGltZXMgPSBPYmplY3Qua2V5cyh0aGlzLl9kZWNvZGVkRnJhbWVzKTtcXG4gICAgICBpZiAoZnJhbWVUaW1lcy5sZW5ndGggPiAwKSB7XFxuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XFxuICAgICAgICBsZXQgZnJhbWVUaW1lID0gLTE7XFxuICAgICAgICBsZXQgY3VycmVudElkeCA9IDA7XFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lVGltZXMubGVuZ3RoICYmIE51bWJlci5wYXJzZUludChmcmFtZVRpbWVzW2ldKSAtIHRoaXMuX2Jhc2VEdHMgPD0gdGhpcy5jdXJyZW50VGltZTsgaSsrKSB7XFxuICAgICAgICAgIGZyYW1lVGltZSA9IE51bWJlci5wYXJzZUludChmcmFtZVRpbWVzW2kgLSAxXSk7XFxuICAgICAgICAgIGN1cnJlbnRJZHggPSBpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgbGV0IGZyYW1lID0gdGhpcy5fZGVjb2RlZEZyYW1lc1tmcmFtZVRpbWVdO1xcbiAgICAgICAgaWYgKGZyYW1lKSB7XFxuXFxuICAgICAgICAgIGlmICh0aGlzLm9uY2FucGxheSAmJiB0aGlzLnJlYWR5U3RhdHVzIDwgNCkge1xcbiAgICAgICAgICAgIHRoaXMub25jYW5wbGF5KCk7XFxuICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXR1cyA9IDQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgdGhpcy55dXZDYW52YXMucmVuZGVyKGZyYW1lLmJ1ZmZlciwgZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodCwgZnJhbWUueUxpbmVzaXplLCBmcmFtZS51dkxpbmVzaXplKTtcXG5cXG4gICAgICAgICAgaWYgKHRoaXMucGxheUZpbmlzaCkge1xcbiAgICAgICAgICAgIHRoaXMucGxheUZpbmlzaCgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudElkeDsgaSsrKSB7XFxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2RlY29kZWRGcmFtZXNbaV07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgdGhpcy5fbGFzdFJlbmRlclRpbWUgPSBEYXRlLm5vdygpO1xcbiAgfVxcblxcbiAgY2xlYW5CdWZmZXIoKSB7XFxuICAgIGlmICh0aGlzLmN1cnJlbnRUaW1lID4gMSkge1xcbiAgICAgIHRoaXMuc291cmNlLnJlbW92ZSgwLCB0aGlzLmN1cnJlbnRUaW1lIC0gMSk7XFxuICAgIH1cXG4gIH1cXG59XFxuZXhwb3J0cy5kZWZhdWx0ID0gVmlkZW9DYW52YXM7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvdmlkZW8tY29udGV4dC5qcz9cIil9LFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vYmlsZS93b3JrZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vYmlsZS93b3JrZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuY29uc3QgTUFYX1NUUkVBTV9CVUZGRVJfTEVOR1RIID0gMTAyNCAqIDEwMjQ7XFxudmFyIERlY29kZXIgPSBmdW5jdGlvbiAoc2VsZikge1xcbiAgdGhpcy5pbml0ZWQgPSBmYWxzZTtcXG4gIHRoaXMuc2VsZiA9IHNlbGY7XFxuICB0aGlzLm1ldGEgPSB0aGlzLnNlbGYubWV0YTtcXG4gIHRoaXMuaW5mb2xpc3QgPSB7fTtcXG4gIHNlbGYucGFyX2Jyb2Fkd2F5T25Ccm9hZHdheUluaXRlZCA9IHRoaXMuYnJvYWR3YXlPbkJyb2Fkd2F5SW5pdGVkLmJpbmQodGhpcyk7XFxuICBzZWxmLnBhcl9icm9hZHdheU9uUGljdHVyZURlY29kZWQgPSB0aGlzLmJyb2Fkd2F5T25QaWN0dXJlRGVjb2RlZC5iaW5kKHRoaXMpO1xcbn07XFxuXFxuRGVjb2Rlci5wcm90b3R5cGUudG9VOEFycmF5ID0gZnVuY3Rpb24gKHB0ciwgbGVuZ3RoKSB7XFxuICByZXR1cm4gdGhpcy5zZWxmLkhFQVBVOC5zdWJhcnJheShwdHIsIHB0ciArIGxlbmd0aCk7XFxufTtcXG5cXG5EZWNvZGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xcbiAgTW9kdWxlLl9icm9hZHdheUluaXQoKTtcXG4gIHRoaXMuc3RyZWFtQnVmZmVyID0gdGhpcy50b1U4QXJyYXkoTW9kdWxlLl9icm9hZHdheUNyZWF0ZVN0cmVhbShNQVhfU1RSRUFNX0JVRkZFUl9MRU5HVEgpLCBNQVhfU1RSRUFNX0JVRkZFUl9MRU5HVEgpO1xcbn07XFxuXFxuRGVjb2Rlci5wcm90b3R5cGUuYnJvYWR3YXlPblBpY3R1cmVEZWNvZGVkID0gZnVuY3Rpb24gKG9mZnNldCwgd2lkdGgsIGhlaWdodCwgeUxpbmVzaXplLCB1dkxpbmVzaXplLCBpbmZvaWQpIHtcXG4gIGxldCBpbmZvID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pbmZvbGlzdFtpbmZvaWRdKTtcXG4gIGxldCB5Um93Y291bnQgPSBoZWlnaHQ7XFxuICBsZXQgdXZSb3djb3VudCA9IGhlaWdodCAvIDI7XFxuICBpZiAodGhpcy5tZXRhLmNocm9tYUZvcm1hdCA9PT0gNDQ0IHx8IHRoaXMubWV0YS5jaHJvbWFGb3JtYXQgPT09IDQyMikge1xcbiAgICB1dlJvd2NvdW50ID0gaGVpZ2h0O1xcbiAgfVxcbiAgbGV0IGRhdGEgPSB0aGlzLnRvVThBcnJheShvZmZzZXQsIHlMaW5lc2l6ZSAqIHlSb3djb3VudCArIDIgKiAodXZMaW5lc2l6ZSAqIHV2Um93Y291bnQpKTtcXG4gIHRoaXMuaW5mb2xpc3RbaW5mb2lkXSA9IG51bGw7XFxuICBsZXQgZGF0ZXRlbXAgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XFxuICBkYXRldGVtcC5zZXQoZGF0YSk7XFxuICBsZXQgYnVmZmVyID0gZGF0ZXRlbXAuYnVmZmVyO1xcbiAgdGhpcy5zZWxmLnBvc3RNZXNzYWdlKHtcXG4gICAgbXNnOiAnREVDT0RFRCcsXFxuICAgIHdpZHRoLFxcbiAgICBoZWlnaHQsXFxuICAgIHlMaW5lc2l6ZSxcXG4gICAgdXZMaW5lc2l6ZSxcXG4gICAgaW5mbyxcXG4gICAgYnVmZmVyXFxuICB9LCBbYnVmZmVyXSk7XFxufTtcXG5cXG5EZWNvZGVyLnByb3RvdHlwZS5icm9hZHdheU9uQnJvYWR3YXlJbml0ZWQgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLmluaXRlZCA9IHRydWU7XFxuICB0aGlzLnNlbGYucG9zdE1lc3NhZ2UoeyBtc2c6ICdERUNPREVSX1JFQURZJyB9KTtcXG59O1xcblxcbkRlY29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChkYXRhLCBpbmZvKSB7XFxuICBsZXQgdGltZSA9IHBhcnNlSW50KG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcXG4gIGxldCBpbmZvaWQgPSB0aW1lIC0gTWF0aC5mbG9vcih0aW1lIC8gMTBlOCkgKiAxMGU4O1xcbiAgdGhpcy5pbmZvbGlzdFtpbmZvaWRdID0gaW5mbztcXG4gIHRoaXMuc3RyZWFtQnVmZmVyLnNldChkYXRhKTtcXG4gIE1vZHVsZS5fYnJvYWR3YXlQbGF5U3RyZWFtKGRhdGEubGVuZ3RoLCBpbmZvaWQpO1xcbn07XFxuXFxudmFyIGRlY29kZXI7XFxuXFxuZnVuY3Rpb24gb25Qb3N0UnVuKCkge1xcbiAgZGVjb2RlciA9IG5ldyBEZWNvZGVyKHRoaXMpO1xcbiAgZGVjb2Rlci5pbml0KCk7XFxufVxcblxcbmZ1bmN0aW9uIGluaXQobWV0YSkge1xcbiAgc2VsZi5pbXBvcnRTY3JpcHRzKCdodHRwczovL3NmMS12Y2xvdWRjZG4ucHN0YXRwLmNvbS9vYmovdHRmZS9tZWRpYS9kZWNvZGVyL2gyNjQvZGVjb2Rlci5qcycpO1xcbiAgYWRkT25Qb3N0UnVuKG9uUG9zdFJ1bi5iaW5kKHNlbGYpKTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VsZikge1xcbiAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgdmFyIGRhdGEgPSBlLmRhdGE7XFxuICAgIGlmICghZGF0YS5tc2cpIHtcXG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcXG4gICAgICAgIG1zZzogJ0VSUk9SOmludmFsaWQgbWVzc2FnZSdcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzd2l0Y2ggKGRhdGEubXNnKSB7XFxuICAgICAgICBjYXNlICdpbml0JzpcXG4gICAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XFxuICAgICAgICAgIHNlbGYubWV0YSA9IGRhdGEubWV0YTtcXG4gICAgICAgICAgaW5pdCgpO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgJ2RlY29kZSc6XFxuICAgICAgICAgIGRlY29kZXIuZGVjb2RlKGRhdGEuZGF0YSwgZGF0YS5pbmZvKTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sIGZhbHNlKTtcXG59O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9zcmMvbW9iaWxlL3dvcmtlci5qcz9cIil9LFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vYmlsZS95dXYtY2FudmFzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci11dGlscy9zcmMvbW9iaWxlL3l1di1jYW52YXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuY2xhc3MgWVVWQ2FudmFzIHtcXG4gIGNvbnN0cnVjdG9yKGNvbmZpZ3MpIHtcXG4gICAgdGhpcy5jb25maWdzID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlncyk7XFxuICAgIHRoaXMuY2FudmFzID0gdGhpcy5jb25maWdzLmNhbnZhcztcXG4gICAgdGhpcy5tZXRhID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25maWdzLm1ldGEpO1xcbiAgICB0aGlzLmNocm9tYSA9IHRoaXMubWV0YS5jaHJvbWFGb3JtYXQ7XFxuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tZXRhLnByZXNlbnRIZWlnaHQ7XFxuICAgIHRoaXMud2lkdGggPSB0aGlzLm1ldGEucHJlc2VudFdpZHRoO1xcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IDEyODA7XFxuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IDcyMDtcXG4gICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XFxuICAgIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcXG4gICAgdGhpcy5faW5pdENvbnRleHRHTCgpO1xcbiAgICBpZiAodGhpcy5jb250ZXh0R0wpIHtcXG4gICAgICB0aGlzLl9pbml0UHJvZ3JhbSgpO1xcbiAgICAgIHRoaXMuX2luaXRCdWZmZXJzKCk7XFxuICAgICAgdGhpcy5faW5pdFRleHR1cmVzKCk7XFxuICAgIH07XFxuICB9XFxuXFxuICBfaW5pdENvbnRleHRHTCgpIHtcXG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xcbiAgICB2YXIgZ2wgPSBudWxsO1xcblxcbiAgICB2YXIgdmFsaWRDb250ZXh0TmFtZXMgPSBbJ3dlYmdsJywgJ2V4cGVyaW1lbnRhbC13ZWJnbCcsICdtb3otd2ViZ2wnLCAnd2Via2l0LTNkJ107XFxuICAgIHZhciBuYW1lSW5kZXggPSAwO1xcblxcbiAgICB3aGlsZSAoIWdsICYmIG5hbWVJbmRleCA8IHZhbGlkQ29udGV4dE5hbWVzLmxlbmd0aCkge1xcbiAgICAgIHZhciBjb250ZXh0TmFtZSA9IHZhbGlkQ29udGV4dE5hbWVzW25hbWVJbmRleF07XFxuXFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRPcHRpb25zKSB7XFxuICAgICAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoY29udGV4dE5hbWUsIHRoaXMuY29udGV4dE9wdGlvbnMpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChjb250ZXh0TmFtZSk7XFxuICAgICAgICB9O1xcbiAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGdsID0gbnVsbDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFnbCB8fCB0eXBlb2YgZ2wuZ2V0UGFyYW1ldGVyICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICBnbCA9IG51bGw7XFxuICAgICAgfVxcblxcbiAgICAgICsrbmFtZUluZGV4O1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmNvbnRleHRHTCA9IGdsO1xcbiAgfVxcblxcbiAgX2luaXRQcm9ncmFtKCkge1xcbiAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHRHTDtcXG5cXG4gICAgLy8gdmVydGV4IHNoYWRlciBpcyB0aGUgc2FtZSBmb3IgYWxsIHR5cGVzXFxuICAgIHZhciB2ZXJ0ZXhTaGFkZXJTY3JpcHQ7XFxuICAgIHZhciBmcmFnbWVudFNoYWRlclNjcmlwdDtcXG4gICAgdmVydGV4U2hhZGVyU2NyaXB0ID0gWydhdHRyaWJ1dGUgdmVjNCB2ZXJ0ZXhQb3M7JywgJ2F0dHJpYnV0ZSB2ZWM0IHRleHR1cmVQb3M7JywgJ2F0dHJpYnV0ZSB2ZWM0IHVUZXh0dXJlUG9zOycsICdhdHRyaWJ1dGUgdmVjNCB2VGV4dHVyZVBvczsnLCAndmFyeWluZyB2ZWMyIHRleHR1cmVDb29yZDsnLCAndmFyeWluZyB2ZWMyIHVUZXh0dXJlQ29vcmQ7JywgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsICd2b2lkIG1haW4oKScsICd7JywgJyAgZ2xfUG9zaXRpb24gPSB2ZXJ0ZXhQb3M7JywgJyAgdGV4dHVyZUNvb3JkID0gdGV4dHVyZVBvcy54eTsnLCAnICB1VGV4dHVyZUNvb3JkID0gdVRleHR1cmVQb3MueHk7JywgJyAgdlRleHR1cmVDb29yZCA9IHZUZXh0dXJlUG9zLnh5OycsICd9J10uam9pbignXFxcXG4nKTtcXG5cXG4gICAgZnJhZ21lbnRTaGFkZXJTY3JpcHQgPSBbJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDsnLCAndmFyeWluZyBoaWdocCB2ZWMyIHRleHR1cmVDb29yZDsnLCAndmFyeWluZyBoaWdocCB2ZWMyIHVUZXh0dXJlQ29vcmQ7JywgJ3ZhcnlpbmcgaGlnaHAgdmVjMiB2VGV4dHVyZUNvb3JkOycsICd1bmlmb3JtIHNhbXBsZXIyRCB5U2FtcGxlcjsnLCAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JywgJ3VuaWZvcm0gc2FtcGxlcjJEIHZTYW1wbGVyOycsICd1bmlmb3JtIG1hdDQgWVVWMlJHQjsnLCAndm9pZCBtYWluKHZvaWQpIHsnLCAnICBoaWdocCBmbG9hdCB5ID0gdGV4dHVyZTJEKHlTYW1wbGVyLCAgdGV4dHVyZUNvb3JkKS5yOycsICcgIGhpZ2hwIGZsb2F0IHUgPSB0ZXh0dXJlMkQodVNhbXBsZXIsICB1VGV4dHVyZUNvb3JkKS5yOycsICcgIGhpZ2hwIGZsb2F0IHYgPSB0ZXh0dXJlMkQodlNhbXBsZXIsICB2VGV4dHVyZUNvb3JkKS5yOycsICcgIGdsX0ZyYWdDb2xvciA9IHZlYzQoeSwgdSwgdiwgMSkgKiBZVVYyUkdCOycsICd9J10uam9pbignXFxcXG4nKTtcXG5cXG4gICAgdmFyIFlVVjJSR0IgPSBbMS4xNjQzOCwgMC4wMDAwMCwgMS41OTYwMywgLTAuODcwNzksIDEuMTY0MzgsIC0wLjM5MTc2LCAtMC44MTI5NywgMC41Mjk1OSwgMS4xNjQzOCwgMi4wMTcyMywgMC4wMDAwMCwgLTEuMDgxMzksIDAsIDAsIDAsIDFdO1xcbiAgICB2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xcbiAgICBnbC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCB2ZXJ0ZXhTaGFkZXJTY3JpcHQpO1xcbiAgICBnbC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlcik7XFxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHZlcnRleFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XFxuICAgICAgY29uc29sZS5sb2coJ1ZlcnRleCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGU6ICcgKyBnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRleFNoYWRlcikpO1xcbiAgICB9XFxuXFxuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xcbiAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGZyYWdtZW50U2hhZGVyU2NyaXB0KTtcXG4gICAgZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XFxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGZyYWdtZW50U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcXG4gICAgICBjb25zb2xlLmxvZygnRnJhZ21lbnQgc2hhZGVyIGZhaWxlZCB0byBjb21waWxlOiAnICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyhmcmFnbWVudFNoYWRlcikpO1xcbiAgICB9XFxuXFxuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcXG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XFxuICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcXG4gICAgICBjb25zb2xlLmxvZygnUHJvZ3JhbSBmYWlsZWQgdG8gY29tcGlsZTogJyArIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcXG4gICAgfVxcblxcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xcblxcbiAgICB2YXIgWVVWMlJHQlJlZiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAnWVVWMlJHQicpO1xcbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KFlVVjJSR0JSZWYsIGZhbHNlLCBZVVYyUkdCKTtcXG5cXG4gICAgdGhpcy5zaGFkZXJQcm9ncmFtID0gcHJvZ3JhbTtcXG4gIH1cXG5cXG4gIF9pbml0QnVmZmVycygpIHtcXG4gICAgdmFyIGdsID0gdGhpcy5jb250ZXh0R0w7XFxuICAgIHZhciBwcm9ncmFtID0gdGhpcy5zaGFkZXJQcm9ncmFtO1xcblxcbiAgICB2YXIgdmVydGV4UG9zQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XFxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhQb3NCdWZmZXIpO1xcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgLTEsIDEsIDEsIC0xLCAtMSwgLTFdKSwgZ2wuU1RBVElDX0RSQVcpO1xcblxcbiAgICB2YXIgdmVydGV4UG9zUmVmID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ3ZlcnRleFBvcycpO1xcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhQb3NSZWYpO1xcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnRleFBvc1JlZiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcXG5cXG4gICAgdmFyIHRleHR1cmVQb3NCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRleHR1cmVQb3NCdWZmZXIpO1xcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMSwgMSwgMCwgMV0pLCBnbC5TVEFUSUNfRFJBVyk7XFxuXFxuICAgIHZhciB0ZXh0dXJlUG9zUmVmID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ3RleHR1cmVQb3MnKTtcXG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGV4dHVyZVBvc1JlZik7XFxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGV4dHVyZVBvc1JlZiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcXG5cXG4gICAgdGhpcy50ZXh0dXJlUG9zQnVmZmVyID0gdGV4dHVyZVBvc0J1ZmZlcjtcXG5cXG4gICAgdmFyIHVUZXh0dXJlUG9zQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XFxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB1VGV4dHVyZVBvc0J1ZmZlcik7XFxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAxLCAxLCAwLCAxXSksIGdsLlNUQVRJQ19EUkFXKTtcXG5cXG4gICAgdmFyIHVUZXh0dXJlUG9zUmVmID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ3VUZXh0dXJlUG9zJyk7XFxuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHVUZXh0dXJlUG9zUmVmKTtcXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih1VGV4dHVyZVBvc1JlZiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcXG5cXG4gICAgdGhpcy51VGV4dHVyZVBvc0J1ZmZlciA9IHVUZXh0dXJlUG9zQnVmZmVyO1xcblxcbiAgICB2YXIgdlRleHR1cmVQb3NCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHZUZXh0dXJlUG9zQnVmZmVyKTtcXG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDAsIDEsIDEsIDAsIDFdKSwgZ2wuU1RBVElDX0RSQVcpO1xcblxcbiAgICB2YXIgdlRleHR1cmVQb3NSZWYgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAndlRleHR1cmVQb3MnKTtcXG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodlRleHR1cmVQb3NSZWYpO1xcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZUZXh0dXJlUG9zUmVmLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xcblxcbiAgICB0aGlzLnZUZXh0dXJlUG9zQnVmZmVyID0gdlRleHR1cmVQb3NCdWZmZXI7XFxuICB9XFxuXFxuICBfaW5pdFRleHR1cmVzKCkge1xcbiAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHRHTDtcXG4gICAgdmFyIHByb2dyYW0gPSB0aGlzLnNoYWRlclByb2dyYW07XFxuICAgIHZhciB5VGV4dHVyZVJlZiA9IHRoaXMuX2luaXRUZXh0dXJlKCk7XFxuICAgIHZhciB5U2FtcGxlclJlZiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAneVNhbXBsZXInKTtcXG4gICAgZ2wudW5pZm9ybTFpKHlTYW1wbGVyUmVmLCAwKTtcXG4gICAgdGhpcy55VGV4dHVyZVJlZiA9IHlUZXh0dXJlUmVmO1xcblxcbiAgICB2YXIgdVRleHR1cmVSZWYgPSB0aGlzLl9pbml0VGV4dHVyZSgpO1xcbiAgICB2YXIgdVNhbXBsZXJSZWYgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTYW1wbGVyJyk7XFxuICAgIGdsLnVuaWZvcm0xaSh1U2FtcGxlclJlZiwgMSk7XFxuICAgIHRoaXMudVRleHR1cmVSZWYgPSB1VGV4dHVyZVJlZjtcXG5cXG4gICAgdmFyIHZUZXh0dXJlUmVmID0gdGhpcy5faW5pdFRleHR1cmUoKTtcXG4gICAgdmFyIHZTYW1wbGVyUmVmID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd2U2FtcGxlcicpO1xcbiAgICBnbC51bmlmb3JtMWkodlNhbXBsZXJSZWYsIDIpO1xcbiAgICB0aGlzLnZUZXh0dXJlUmVmID0gdlRleHR1cmVSZWY7XFxuICB9XFxuXFxuICBfaW5pdFRleHR1cmUoKSB7XFxuICAgIHZhciBnbCA9IHRoaXMuY29udGV4dEdMO1xcblxcbiAgICB2YXIgdGV4dHVyZVJlZiA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVJlZik7XFxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XFxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xcblxcbiAgICByZXR1cm4gdGV4dHVyZVJlZjtcXG4gIH1cXG5cXG4gIF9kcmF3UGljdHVyZUdMKGRhdGEsIHdpZHRoLCBoZWlnaHQsIHlMaW5lc2l6ZSwgdXZMaW5lc2l6ZSkge1xcbiAgICB2YXIgeWxlbiA9IHlMaW5lc2l6ZSAqIGhlaWdodDtcXG4gICAgdmFyIHV2bGVuID0gdXZMaW5lc2l6ZSAqIGhlaWdodCAvIDI7XFxuICAgIGlmICh0aGlzLmNocm9tYSA9PT0gNDQ0IHx8IHRoaXMuY2hyb21hID09PSA0MjIpIHtcXG4gICAgICB1dmxlbiAqPSAyO1xcbiAgICB9XFxuICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhKTtcXG4gICAgbGV0IHJlbmRlckRhdGEgPSB7XFxuICAgICAgeURhdGE6IGRhdGEuc3ViYXJyYXkoMCwgeWxlbiksXFxuICAgICAgdURhdGE6IGRhdGEuc3ViYXJyYXkoeWxlbiwgeWxlbiArIHV2bGVuKSxcXG4gICAgICB2RGF0YTogZGF0YS5zdWJhcnJheSh5bGVuICsgdXZsZW4sIHlsZW4gKyB1dmxlbiArIHV2bGVuKVxcbiAgICB9O1xcbiAgICB0aGlzLl9kcmF3UGljdHVyZUdMNDIwKHJlbmRlckRhdGEsIHdpZHRoLCBoZWlnaHQsIHlMaW5lc2l6ZSwgdXZMaW5lc2l6ZSk7XFxuICB9XFxuXFxuICBfZHJhd1BpY3R1cmVHTDQyMChkYXRhLCB3aWR0aCwgaGVpZ2h0LCB5TGluZXNpemUsIHV2TGluZXNpemUpIHtcXG4gICAgdmFyIGdsID0gdGhpcy5jb250ZXh0R0w7XFxuICAgIHZhciB0ZXh0dXJlUG9zQnVmZmVyID0gdGhpcy50ZXh0dXJlUG9zQnVmZmVyO1xcbiAgICB2YXIgdVRleHR1cmVQb3NCdWZmZXIgPSB0aGlzLnVUZXh0dXJlUG9zQnVmZmVyO1xcbiAgICB2YXIgdlRleHR1cmVQb3NCdWZmZXIgPSB0aGlzLnZUZXh0dXJlUG9zQnVmZmVyO1xcblxcbiAgICB2YXIgeVRleHR1cmVSZWYgPSB0aGlzLnlUZXh0dXJlUmVmO1xcbiAgICB2YXIgdVRleHR1cmVSZWYgPSB0aGlzLnVUZXh0dXJlUmVmO1xcbiAgICB2YXIgdlRleHR1cmVSZWYgPSB0aGlzLnZUZXh0dXJlUmVmO1xcblxcbiAgICB2YXIgeURhdGEgPSBkYXRhLnlEYXRhO1xcbiAgICB2YXIgdURhdGEgPSBkYXRhLnVEYXRhO1xcbiAgICB2YXIgdkRhdGEgPSBkYXRhLnZEYXRhO1xcblxcbiAgICB2YXIgeURhdGFQZXJSb3cgPSB5TGluZXNpemU7XFxuICAgIHZhciB5Um93Q250ID0gaGVpZ2h0O1xcblxcbiAgICB2YXIgdURhdGFQZXJSb3cgPSB3aWR0aCAvIDI7XFxuICAgIHZhciB1Um93Q250ID0gaGVpZ2h0IC8gMjtcXG5cXG4gICAgaWYgKHRoaXMuY2hyb21hID09PSA0MjIgfHwgdGhpcy5jaHJvbWEgPT09IDQ0NCkge1xcbiAgICAgIHVSb3dDbnQgPSBoZWlnaHQ7XFxuICAgIH1cXG5cXG4gICAgdmFyIHZEYXRhUGVyUm93ID0gdXZMaW5lc2l6ZTtcXG4gICAgdmFyIHZSb3dDbnQgPSB1Um93Q250O1xcblxcbiAgICBsZXQgcmF0aW93ID0gdGhpcy5jYW52YXMud2lkdGggLyB0aGlzLndpZHRoO1xcbiAgICBsZXQgcmF0aW9oID0gdGhpcy5jYW52YXMuaGVpZ2h0IC8gdGhpcy5oZWlnaHQ7XFxuICAgIGxldCBsZWZ0ID0gMDtcXG4gICAgbGV0IHRvcCA9IDA7XFxuICAgIGxldCB3ID0gdGhpcy5jYW52YXMud2lkdGg7XFxuICAgIGxldCBoID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xcbiAgICBpZiAocmF0aW93IDwgcmF0aW9oKSB7XFxuICAgICAgaCA9IHRoaXMuaGVpZ2h0ICogdGhpcy5jYW52YXMud2lkdGggLyB0aGlzLndpZHRoO1xcbiAgICAgIHRvcCA9IHBhcnNlSW50KCh0aGlzLmNhbnZhcy5oZWlnaHQgLSB0aGlzLmhlaWdodCAqIHRoaXMuY2FudmFzLndpZHRoIC8gdGhpcy53aWR0aCkgLyAyKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB3ID0gdGhpcy53aWR0aCAqIHRoaXMuY2FudmFzLmhlaWdodCAvIHRoaXMuaGVpZ2h0O1xcbiAgICAgIGxlZnQgPSBwYXJzZUludCgodGhpcy5jYW52YXMud2lkdGggLSB0aGlzLndpZHRoICogdGhpcy5jYW52YXMuaGVpZ2h0IC8gdGhpcy5oZWlnaHQpIC8gMik7XFxuICAgIH1cXG4gICAgZ2wudmlld3BvcnQobGVmdCwgdG9wLCB3LCBoKTtcXG5cXG4gICAgdmFyIHRleHR1cmVQb3NWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAxLCAxLCAwLCAxXSk7XFxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0ZXh0dXJlUG9zQnVmZmVyKTtcXG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRleHR1cmVQb3NWYWx1ZXMsIGdsLkRZTkFNSUNfRFJBVyk7XFxuXFxuICAgIHZhciB1VGV4dHVyZVBvc1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDAsIDEsIDEsIDAsIDFdKTtcXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHVUZXh0dXJlUG9zQnVmZmVyKTtcXG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHVUZXh0dXJlUG9zVmFsdWVzLCBnbC5EWU5BTUlDX0RSQVcpO1xcblxcbiAgICB2YXIgdlRleHR1cmVQb3NWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAxLCAxLCAwLCAxXSk7XFxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2VGV4dHVyZVBvc0J1ZmZlcik7XFxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2VGV4dHVyZVBvc1ZhbHVlcywgZ2wuRFlOQU1JQ19EUkFXKTtcXG5cXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XFxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHlUZXh0dXJlUmVmKTtcXG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5MVU1JTkFOQ0UsIHlEYXRhUGVyUm93LCB5Um93Q250LCAwLCBnbC5MVU1JTkFOQ0UsIGdsLlVOU0lHTkVEX0JZVEUsIHlEYXRhKTtcXG5cXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMSk7XFxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHVUZXh0dXJlUmVmKTtcXG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5MVU1JTkFOQ0UsIHVEYXRhUGVyUm93LCB1Um93Q250LCAwLCBnbC5MVU1JTkFOQ0UsIGdsLlVOU0lHTkVEX0JZVEUsIHVEYXRhKTtcXG5cXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMik7XFxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHZUZXh0dXJlUmVmKTtcXG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5MVU1JTkFOQ0UsIHZEYXRhUGVyUm93LCB2Um93Q250LCAwLCBnbC5MVU1JTkFOQ0UsIGdsLlVOU0lHTkVEX0JZVEUsIHZEYXRhKTtcXG5cXG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XFxuICB9XFxuXFxuICBfZHJhd1BpY3R1cmVSR0IoZGF0YSkge31cXG5cXG4gIHJlbmRlcihkYXRhLCB3aWR0aCwgaGVpZ2h0LCB5TGluZXNpemUsIHV2TGluZXNpemUpIHtcXG4gICAgdmFyIGdsID0gdGhpcy5jb250ZXh0R0w7XFxuICAgIGlmIChnbCkge1xcbiAgICAgIHRoaXMuX2RyYXdQaWN0dXJlR0woZGF0YSwgd2lkdGgsIGhlaWdodCwgeUxpbmVzaXplLCB1dkxpbmVzaXplKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLl9kcmF3UGljdHVyZVJHQihkYXRhKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBZVVZDYW52YXM7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUveXV2LWNhbnZhcy5qcz9cIil9LFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vZGVscy9tZWRpYS1pbmZvLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci11dGlscy9zcmMvbW9kZWxzL21lZGlhLWluZm8uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbCgnXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbmNvbnN0IGlzT2JqZWN0RmlsbGVkID0gb2JqID0+IHtcXG4gIGZvciAobGV0IGtleSBpbiBvYmopIHtcXG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxuICAgICAgaWYgKG9ialtrZXldID09PSBudWxsKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gdHJ1ZTtcXG59O1xcblxcbmNsYXNzIE1lZGlhSW5mbyB7XFxuICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgdGhpcy5taW1lVHlwZSA9IG51bGw7XFxuICAgIHRoaXMuZHVyYXRpb24gPSBudWxsO1xcblxcbiAgICB0aGlzLmhhc1ZpZGVvID0gbnVsbDtcXG4gICAgdGhpcy52aWRlbyA9IHtcXG4gICAgICBjb2RlYzogbnVsbCxcXG4gICAgICB3aWR0aDogbnVsbCxcXG4gICAgICBoZWlnaHQ6IG51bGwsXFxuICAgICAgcHJvZmlsZTogbnVsbCxcXG4gICAgICBsZXZlbDogbnVsbCxcXG4gICAgICBmcmFtZVJhdGU6IHtcXG4gICAgICAgIGZpeGVkOiB0cnVlLFxcbiAgICAgICAgZnBzOiAyNSxcXG4gICAgICAgIGZwc19udW06IDI1MDAwLFxcbiAgICAgICAgZnBzX2RlbjogMTAwMFxcbiAgICAgIH0sXFxuICAgICAgY2hyb21hRm9ybWF0OiBudWxsLFxcbiAgICAgIHBhclJhdGlvOiB7XFxuICAgICAgICB3aWR0aDogMSxcXG4gICAgICAgIGhlaWdodDogMVxcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgdGhpcy5oYXNBdWRpbyA9IG51bGw7XFxuXFxuICAgIHRoaXMuYXVkaW8gPSB7XFxuICAgICAgY29kZWM6IG51bGwsXFxuICAgICAgc2FtcGxlUmF0ZTogbnVsbCxcXG4gICAgICBzYW1wbGVSYXRlSW5kZXg6IG51bGwsXFxuICAgICAgY2hhbm5lbENvdW50OiBudWxsXFxuICAgIH07XFxuICB9XFxuXFxuICBpc0NvbXBsZXRlKCkge1xcbiAgICByZXR1cm4gTWVkaWFJbmZvLmlzQmFzZUluZm9SZWFkeSh0aGlzKSAmJiBNZWRpYUluZm8uaXNWaWRlb1JlYWR5KHRoaXMpICYmIE1lZGlhSW5mby5pc0F1ZGlvUmVhZHkodGhpcyk7XFxuICB9XFxuXFxuICBzdGF0aWMgaXNCYXNlSW5mb1JlYWR5KG1lZGlhSW5mbykge1xcbiAgICByZXR1cm4gaXNPYmplY3RGaWxsZWQobWVkaWFJbmZvKTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBpc1ZpZGVvUmVhZHkobWVkaWFJbmZvKSB7XFxuICAgIGlmICghbWVkaWFJbmZvLmhhc1ZpZGVvKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGlzT2JqZWN0RmlsbGVkKG1lZGlhSW5mby52aWRlbyk7XFxuICB9XFxuXFxuICBzdGF0aWMgaXNBdWRpb1JlYWR5KG1lZGlhSW5mbykge1xcbiAgICBpZiAoIW1lZGlhSW5mby5oYXNBdWRpbykge1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBpc09iamVjdEZpbGxlZChtZWRpYUluZm8udmlkZW8pO1xcbiAgfVxcbn1cXG5leHBvcnRzLmRlZmF1bHQgPSBNZWRpYUluZm87XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvbWVkaWEtaW5mby5qcz8nKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvbW9kZWxzL21lZGlhLXNhbXBsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci11dGlscy9zcmMvbW9kZWxzL21lZGlhLXNhbXBsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbmNsYXNzIE1lZGlhU2FtcGxlIHtcXG4gIGNvbnN0cnVjdG9yKGluZm8pIHtcXG4gICAgbGV0IF9kZWZhdWx0ID0gTWVkaWFTYW1wbGUuZ2V0RGVmYXVsdEluZigpO1xcblxcbiAgICBpZiAoIWluZm8gfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGluZm8pICE9PSAnW29iamVjdCBPYmplY3RdJykge1xcbiAgICAgIHJldHVybiBfZGVmYXVsdDtcXG4gICAgfVxcbiAgICBsZXQgc2FtcGxlID0gT2JqZWN0LmFzc2lnbih7fSwgX2RlZmF1bHQsIGluZm8pO1xcblxcbiAgICBPYmplY3QuZW50cmllcyhzYW1wbGUpLmZvckVhY2goKFtrLCB2XSkgPT4ge1xcbiAgICAgIHRoaXNba10gPSB2O1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXREZWZhdWx0SW5mKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGR0czogbnVsbCxcXG4gICAgICBwdHM6IG51bGwsXFxuICAgICAgZHVyYXRpb246IG51bGwsXFxuICAgICAgcG9zaXRpb246IG51bGwsXFxuICAgICAgaXNSQVA6IGZhbHNlLCAvLyBpcyBSYW5kb20gYWNjZXNzIHBvaW50XFxuICAgICAgb3JpZ2luRHRzOiBudWxsXFxuICAgIH07XFxuICB9XFxufVxcbmV4cG9ydHMuZGVmYXVsdCA9IE1lZGlhU2FtcGxlO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9zcmMvbW9kZWxzL21lZGlhLXNhbXBsZS5qcz9cIil9LFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vZGVscy9tZWRpYS1zZWdtZW50LWxpc3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vZGVscy9tZWRpYS1zZWdtZW50LWxpc3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKCdcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcXG4gICAgdmFsdWU6IHRydWVcXG59KTtcXG5jbGFzcyBNZWRpYVNlZ21lbnRMaXN0IHtcXG5cXG4gICAgY29uc3RydWN0b3IodHlwZSkge1xcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XFxuICAgICAgICB0aGlzLl9saXN0ID0gW107XFxuICAgICAgICB0aGlzLl9sYXN0QXBwZW5kTG9jYXRpb24gPSAtMTsgLy8gY2FjaGVkIGxhc3QgaW5zZXJ0IGxvY2F0aW9uXFxuICAgIH1cXG5cXG4gICAgZ2V0IHR5cGUoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcXG4gICAgfVxcblxcbiAgICBnZXQgbGVuZ3RoKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3QubGVuZ3RoO1xcbiAgICB9XFxuXFxuICAgIGlzRW1wdHkoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fbGlzdC5sZW5ndGggPT09IDA7XFxuICAgIH1cXG5cXG4gICAgY2xlYXIoKSB7XFxuICAgICAgICB0aGlzLl9saXN0ID0gW107XFxuICAgICAgICB0aGlzLl9sYXN0QXBwZW5kTG9jYXRpb24gPSAtMTtcXG4gICAgfVxcblxcbiAgICBfc2VhcmNoTmVhcmVzdFNlZ21lbnRCZWZvcmUoYmVnaW5EdHMpIHtcXG4gICAgICAgIGxldCBsaXN0ID0gdGhpcy5fbGlzdDtcXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiAtMjtcXG4gICAgICAgIH1cXG4gICAgICAgIGxldCBsYXN0ID0gbGlzdC5sZW5ndGggLSAxO1xcbiAgICAgICAgbGV0IG1pZCA9IDA7XFxuICAgICAgICBsZXQgbGJvdW5kID0gMDtcXG4gICAgICAgIGxldCB1Ym91bmQgPSBsYXN0O1xcblxcbiAgICAgICAgbGV0IGlkeCA9IDA7XFxuXFxuICAgICAgICBpZiAoYmVnaW5EdHMgPCBsaXN0WzBdLm9yaWdpbkR0cykge1xcbiAgICAgICAgICAgIGlkeCA9IC0xO1xcbiAgICAgICAgICAgIHJldHVybiBpZHg7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB3aGlsZSAobGJvdW5kIDw9IHVib3VuZCkge1xcbiAgICAgICAgICAgIG1pZCA9IGxib3VuZCArIE1hdGguZmxvb3IoKHVib3VuZCAtIGxib3VuZCkgLyAyKTtcXG4gICAgICAgICAgICBpZiAobWlkID09PSBsYXN0IHx8IGJlZ2luRHRzID4gbGlzdFttaWRdLmxhc3RTYW1wbGUub3JpZ2luRHRzICYmIGJlZ2luRHRzIDwgbGlzdFttaWQgKyAxXS5vcmlnaW5EdHMpIHtcXG4gICAgICAgICAgICAgICAgaWR4ID0gbWlkO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RbbWlkXS5vcmlnaW5EdHMgPCBiZWdpbkR0cykge1xcbiAgICAgICAgICAgICAgICBsYm91bmQgPSBtaWQgKyAxO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHVib3VuZCA9IG1pZCAtIDE7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGlkeDtcXG4gICAgfVxcblxcbiAgICBfc2VhcmNoTmVhcmVzdFNlZ21lbnRBZnRlcihiZWdpbkR0cykge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlYXJjaE5lYXJlc3RTZWdtZW50QmVmb3JlKGJlZ2luRHRzKSArIDE7XFxuICAgIH1cXG5cXG4gICAgYXBwZW5kKHNlZ21lbnQpIHtcXG4gICAgICAgIGxldCBsaXN0ID0gdGhpcy5fbGlzdDtcXG4gICAgICAgIGxldCBsYXN0QXBwZW5kSWR4ID0gdGhpcy5fbGFzdEFwcGVuZExvY2F0aW9uO1xcbiAgICAgICAgbGV0IGluc2VydElkeCA9IDA7XFxuXFxuICAgICAgICBpZiAobGFzdEFwcGVuZElkeCAhPT0gLTEgJiYgbGFzdEFwcGVuZElkeCA8IGxpc3QubGVuZ3RoICYmIHNlZ21lbnQub3JpZ2luU3RhcnREdHMgPj0gbGlzdFtsYXN0QXBwZW5kSWR4XS5sYXN0U2FtcGxlLm9yaWdpbkR0cyAmJiAobGFzdEFwcGVuZElkeCA9PT0gbGlzdC5sZW5ndGggLSAxIHx8IGxhc3RBcHBlbmRJZHggPCBsaXN0Lmxlbmd0aCAtIDEgJiYgc2VnbWVudC5vcmlnaW5TdGFydER0cyA8IGxpc3RbbGFzdEFwcGVuZElkeCArIDFdLm9yaWdpblN0YXJ0RHRzKSkge1xcbiAgICAgICAgICAgIGluc2VydElkeCA9IGxhc3RBcHBlbmRJZHggKyAxOyAvLyB1c2UgY2FjaGVkIGxvY2F0aW9uIGlkeFxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBpZiAobGlzdC5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgICAgIGluc2VydElkeCA9IHRoaXMuX3NlYXJjaE5lYXJlc3RTZWdtZW50QmVmb3JlKHNlZ21lbnQub3JpZ2luU3RhcnREdHMpICsgMTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl9sYXN0QXBwZW5kTG9jYXRpb24gPSBpbnNlcnRJZHg7XFxuICAgICAgICB0aGlzLl9saXN0LnNwbGljZShpbnNlcnRJZHgsIDAsIHNlZ21lbnQpO1xcbiAgICB9XFxuXFxuICAgIGdldExhc3RTZWdtZW50QmVmb3JlKGJlZ2luRHRzKSB7XFxuICAgICAgICBsZXQgaWR4ID0gdGhpcy5fc2VhcmNoTmVhcmVzdFNlZ21lbnRCZWZvcmUoYmVnaW5EdHMpO1xcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RbaWR4XTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgLy8gLTFcXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICBnZXRMYXN0U2FtcGxlQmVmb3JlKGJlZ2luRHRzKSB7XFxuICAgICAgICBsZXQgc2VnbWVudCA9IHRoaXMuZ2V0TGFzdFNlZ21lbnRCZWZvcmUoYmVnaW5EdHMpO1xcbiAgICAgICAgaWYgKHNlZ21lbnQgIT09IG51bGwpIHtcXG4gICAgICAgICAgICByZXR1cm4gc2VnbWVudC5sYXN0U2FtcGxlO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICBnZXRMYXN0UkFQQmVmb3JlKGJlZ2luRHRzKSB7XFxuICAgICAgICBsZXQgc2VnbWVudElkeCA9IHRoaXMuX3NlYXJjaE5lYXJlc3RTZWdtZW50QmVmb3JlKGJlZ2luRHRzKTtcXG4gICAgICAgIGxldCByYW5kb21BY2Nlc3NQb2ludHMgPSB0aGlzLl9saXN0W3NlZ21lbnRJZHhdLnJhbmRvbUFjY2Vzc1BvaW50cztcXG4gICAgICAgIHdoaWxlIChyYW5kb21BY2Nlc3NQb2ludHMubGVuZ3RoID09PSAwICYmIHNlZ21lbnRJZHggPiAwKSB7XFxuICAgICAgICAgICAgc2VnbWVudElkeC0tO1xcbiAgICAgICAgICAgIHJhbmRvbUFjY2Vzc1BvaW50cyA9IHRoaXMuX2xpc3Rbc2VnbWVudElkeF0ucmFuZG9tQWNjZXNzUG9pbnRzO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHJhbmRvbUFjY2Vzc1BvaW50cy5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHJhbmRvbUFjY2Vzc1BvaW50c1tyYW5kb21BY2Nlc3NQb2ludHMubGVuZ3RoIC0gMV07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxufVxcbmV4cG9ydHMuZGVmYXVsdCA9IE1lZGlhU2VnbWVudExpc3Q7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvbWVkaWEtc2VnbWVudC1saXN0LmpzPycpfSxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvbWVkaWEtc2VnbWVudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vZGVscy9tZWRpYS1zZWdtZW50LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoJ1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xcbiAgICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbmNsYXNzIE1lZGlhU2VnbWVudCB7XFxuICAgIGNvbnN0cnVjdG9yKCkge1xcbiAgICAgICAgdGhpcy5zdGFydER0cyA9IC0xO1xcbiAgICAgICAgdGhpcy5lbmREdHMgPSAtMTtcXG4gICAgICAgIHRoaXMuc3RhcnRQdHMgPSAtMTtcXG4gICAgICAgIHRoaXMuZW5kUHRzID0gLTE7XFxuICAgICAgICB0aGlzLm9yaWdpblN0YXJ0RHRzID0gLTE7XFxuICAgICAgICB0aGlzLm9yaWdpbkVuZER0cyA9IC0xO1xcbiAgICAgICAgdGhpcy5yYW5kb21BY2Nlc3NQb2ludHMgPSBbXTtcXG4gICAgICAgIHRoaXMuZmlyc3RTYW1wbGUgPSBudWxsO1xcbiAgICAgICAgdGhpcy5sYXN0U2FtcGxlID0gbnVsbDtcXG4gICAgfVxcblxcbiAgICBhZGRSQVAoc2FtcGxlKSB7XFxuICAgICAgICBzYW1wbGUuaXNSQVAgPSB0cnVlO1xcbiAgICAgICAgdGhpcy5yYW5kb21BY2Nlc3NQb2ludHMucHVzaChzYW1wbGUpO1xcbiAgICB9XFxufVxcbmV4cG9ydHMuZGVmYXVsdCA9IE1lZGlhU2VnbWVudDtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vZGVscy9tZWRpYS1zZWdtZW50LmpzPycpfSxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvdHJhY2stbWV0YS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vZGVscy90cmFjay1tZXRhLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbmNsYXNzIEF1ZGlvVHJhY2tNZXRhIHtcXG4gIGNvbnN0cnVjdG9yKG1ldGEpIHtcXG4gICAgY29uc3QgX2RlZmF1bHQgPSB7XFxuICAgICAgc2FtcGxlUmF0ZTogNDgwMDAsXFxuICAgICAgY2hhbm5lbENvdW50OiAyLFxcbiAgICAgIGNvZGVjOiAnbXA0YS40MC4yJyxcXG4gICAgICBjb25maWc6IFs0MSwgNDAxLCAxMzYsIDBdLFxcbiAgICAgIGR1cmF0aW9uOiAwLFxcbiAgICAgIGlkOiAyLFxcbiAgICAgIHJlZlNhbXBsZUR1cmF0aW9uOiAyMSxcXG4gICAgICBzYW1wbGVSYXRlSW5kZXg6IDMsXFxuICAgICAgdGltZXNjYWxlOiAxMDAwLFxcbiAgICAgIHR5cGU6ICdhdWRpbydcXG4gICAgfTtcXG4gICAgaWYgKG1ldGEpIHtcXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgX2RlZmF1bHQsIG1ldGEpO1xcbiAgICB9XFxuICAgIHJldHVybiBfZGVmYXVsdDtcXG4gIH1cXG5cXG4gIGRlc3Ryb3koKSB7XFxuICAgIHRoaXMuaW5pdCA9IG51bGw7XFxuICB9XFxufVxcblxcbmV4cG9ydHMuQXVkaW9UcmFja01ldGEgPSBBdWRpb1RyYWNrTWV0YTtcXG5jbGFzcyBWaWRlb1RyYWNrTWV0YSB7XFxuICBjb25zdHJ1Y3RvcihtZXRhKSB7XFxuICAgIGNvbnN0IF9kZWZhdWx0ID0ge1xcbiAgICAgIGF2Y2M6IG51bGwsXFxuICAgICAgc3BzOiBuZXcgVWludDhBcnJheSgwKSxcXG4gICAgICBwcHM6IG5ldyBVaW50OEFycmF5KDApLFxcbiAgICAgIGNocm9tYUZvcm1hdDogNDIwLFxcbiAgICAgIGNvZGVjOiAnYXZjMS42NDAwMjAnLFxcbiAgICAgIGNvZGVjSGVpZ2h0OiA3MjAsXFxuICAgICAgY29kZWNXaWR0aDogMTI4MCxcXG4gICAgICBkdXJhdGlvbjogMCxcXG4gICAgICBmcmFtZVJhdGU6IHtcXG4gICAgICAgIGZpeGVkOiB0cnVlLFxcbiAgICAgICAgZnBzOiAyNSxcXG4gICAgICAgIGZwc19udW06IDI1MDAwLFxcbiAgICAgICAgZnBzX2RlbjogMTAwMFxcbiAgICAgIH0sXFxuICAgICAgaWQ6IDEsXFxuICAgICAgbGV2ZWw6ICczLjInLFxcbiAgICAgIHByZXNlbnRIZWlnaHQ6IDcyMCxcXG4gICAgICBwcmVzZW50V2lkdGg6IDEyODAsXFxuICAgICAgcHJvZmlsZTogJ0hpZ2gnLFxcbiAgICAgIHJlZlNhbXBsZUR1cmF0aW9uOiA0MCxcXG4gICAgICBwYXJSYXRpbzoge1xcbiAgICAgICAgaGVpZ2h0OiAxLFxcbiAgICAgICAgd2lkdGg6IDFcXG4gICAgICB9LFxcbiAgICAgIHRpbWVzY2FsZTogMTAwMCxcXG4gICAgICB0eXBlOiAndmlkZW8nXFxuICAgIH07XFxuXFxuICAgIGlmIChtZXRhKSB7XFxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIF9kZWZhdWx0LCBtZXRhKTtcXG4gICAgfVxcbiAgICByZXR1cm4gX2RlZmF1bHQ7XFxuICB9XFxuXFxuICBkZXN0cm95KCkge1xcbiAgICB0aGlzLmluaXQgPSBudWxsO1xcbiAgICB0aGlzLnNwcyA9IG51bGw7XFxuICAgIHRoaXMucHBzID0gbnVsbDtcXG4gIH1cXG59XFxuZXhwb3J0cy5WaWRlb1RyYWNrTWV0YSA9IFZpZGVvVHJhY2tNZXRhO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9zcmMvbW9kZWxzL3RyYWNrLW1ldGEuanM/XCIpfSxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvdHJhY2stc2FtcGxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvdHJhY2stc2FtcGxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbCgnXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbmNsYXNzIEF1ZGlvVHJhY2tTYW1wbGUge1xcbiAgY29uc3RydWN0b3IoaW5mbykge1xcbiAgICBsZXQgX2RlZmF1bHQgPSBBdWRpb1RyYWNrU2FtcGxlLmdldERlZmF1bHQoKTtcXG4gICAgaWYgKCFpbmZvKSB7XFxuICAgICAgcmV0dXJuIF9kZWZhdWx0O1xcbiAgICB9XFxuICAgIGxldCBzYW1wbGUgPSBPYmplY3QuYXNzaWduKHt9LCBfZGVmYXVsdCwgaW5mbyk7XFxuXFxuICAgIHJldHVybiBzYW1wbGU7XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0RGVmYXVsdCgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBkdHM6IG51bGwsXFxuICAgICAgcHRzOiBudWxsLFxcbiAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KClcXG4gICAgfTtcXG4gIH1cXG59XFxuXFxuZXhwb3J0cy5BdWRpb1RyYWNrU2FtcGxlID0gQXVkaW9UcmFja1NhbXBsZTtcXG5jbGFzcyBWaWRlb1RyYWNrU2FtcGxlIHtcXG4gIGNvbnN0cnVjdG9yKGluZm8pIHtcXG4gICAgbGV0IF9kZWZhdWx0ID0gVmlkZW9UcmFja1NhbXBsZS5nZXREZWZhdWx0KCk7XFxuXFxuICAgIGlmICghaW5mbykge1xcbiAgICAgIHJldHVybiBfZGVmYXVsdDtcXG4gICAgfVxcbiAgICBsZXQgc2FtcGxlID0gT2JqZWN0LmFzc2lnbih7fSwgX2RlZmF1bHQsIGluZm8pO1xcblxcbiAgICByZXR1cm4gc2FtcGxlO1xcbiAgfVxcblxcbiAgc3RhdGljIGdldERlZmF1bHQoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgZHRzOiBudWxsLFxcbiAgICAgIHB0czogbnVsbCxcXG4gICAgICBpc0tleWZyYW1lOiBmYWxzZSwgLy8gaXMgUmFuZG9tIGFjY2VzcyBwb2ludFxcbiAgICAgIG9yaWdpbkR0czogbnVsbCxcXG4gICAgICBkYXRhOiBuZXcgVWludDhBcnJheSgpXFxuICAgIH07XFxuICB9XFxufVxcbmV4cG9ydHMuVmlkZW9UcmFja1NhbXBsZSA9IFZpZGVvVHJhY2tTYW1wbGU7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvdHJhY2stc2FtcGxlLmpzPycpfSxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tc2UvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci11dGlscy9zcmMvbXNlL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5jbGFzcyBNU0Uge1xcbiAgY29uc3RydWN0b3IoY29uZmlncykge1xcbiAgICB0aGlzLmNvbmZpZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWdzKTtcXG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLmNvbmZpZ3MuY29udGFpbmVyO1xcbiAgICB0aGlzLm1lZGlhU291cmNlID0gbnVsbDtcXG4gICAgdGhpcy5zb3VyY2VCdWZmZXJzID0ge307XFxuICAgIHRoaXMucHJlbG9hZFRpbWUgPSB0aGlzLmNvbmZpZ3MucHJlbG9hZFRpbWUgfHwgMTtcXG4gICAgdGhpcy5vblNvdXJjZU9wZW4gPSB0aGlzLm9uU291cmNlT3Blbi5iaW5kKHRoaXMpO1xcbiAgICB0aGlzLm9uVGltZVVwZGF0ZSA9IHRoaXMub25UaW1lVXBkYXRlLmJpbmQodGhpcyk7XFxuICAgIHRoaXMub25VcGRhdGVFbmQgPSB0aGlzLm9uVXBkYXRlRW5kLmJpbmQodGhpcyk7XFxuICAgIHRoaXMub25XYWl0aW5nID0gdGhpcy5vbldhaXRpbmcuYmluZCh0aGlzKTtcXG4gIH1cXG5cXG4gIGluaXQoKSB7XFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxcbiAgICB0aGlzLm1lZGlhU291cmNlID0gbmV3IHNlbGYuTWVkaWFTb3VyY2UoKTtcXG4gICAgdGhpcy5tZWRpYVNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5vblNvdXJjZU9wZW4pO1xcbiAgICB0aGlzLmNvbnRhaW5lci5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHRoaXMubWVkaWFTb3VyY2UpO1xcbiAgICB0aGlzLnVybCA9IHRoaXMuY29udGFpbmVyLnNyYztcXG4gICAgdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHRoaXMub25UaW1lVXBkYXRlKTtcXG4gICAgdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2FpdGluZycsIHRoaXMub25XYWl0aW5nKTtcXG4gIH1cXG5cXG4gIG9uVGltZVVwZGF0ZSgpIHtcXG4gICAgdGhpcy5lbWl0KCdUSU1FX1VQREFURScsIHRoaXMuY29udGFpbmVyKTtcXG4gIH1cXG5cXG4gIG9uV2FpdGluZygpIHtcXG4gICAgdGhpcy5lbWl0KCdXQUlUSU5HJywgdGhpcy5jb250YWluZXIpO1xcbiAgfVxcblxcbiAgb25Tb3VyY2VPcGVuKCkge1xcbiAgICB0aGlzLmFkZFNvdXJjZUJ1ZmZlcnMoKTtcXG4gIH1cXG5cXG4gIG9uVXBkYXRlRW5kKCkge1xcbiAgICB0aGlzLmVtaXQoJ1NPVVJDRV9VUERBVEVfRU5EJyk7XFxuICAgIHRoaXMuZG9BcHBlbmQoKTtcXG4gIH1cXG4gIGFkZFNvdXJjZUJ1ZmZlcnMoKSB7XFxuICAgIGlmICh0aGlzLm1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBsZXQgc291cmNlcyA9IHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoJ1BSRV9TT1VSQ0VfQlVGRkVSJyk7XFxuICAgIGxldCB0cmFja3MgPSB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKCdUUkFDS1MnKTtcXG4gICAgbGV0IHRyYWNrO1xcblxcbiAgICBzb3VyY2VzID0gc291cmNlcy5zb3VyY2VzO1xcbiAgICBsZXQgYWRkID0gZmFsc2U7XFxuICAgIGZvciAobGV0IGkgPSAwLCBrID0gT2JqZWN0LmtleXMoc291cmNlcykubGVuZ3RoOyBpIDwgazsgaSsrKSB7XFxuICAgICAgbGV0IHR5cGUgPSBPYmplY3Qua2V5cyhzb3VyY2VzKVtpXTtcXG4gICAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJykge1xcbiAgICAgICAgdHJhY2sgPSB0cmFja3MuYXVkaW9UcmFjaztcXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcXG4gICAgICAgIHRyYWNrID0gdHJhY2tzLnZpZGVvVHJhY2s7XFxuICAgICAgICAvLyByZXR1cm47XFxuICAgICAgfVxcbiAgICAgIGlmICh0cmFjaykge1xcbiAgICAgICAgbGV0IGR1ciA9IHR5cGUgPT09ICdhdWRpbycgPyAyMSA6IDQwO1xcbiAgICAgICAgaWYgKHRyYWNrLm1ldGEgJiYgdHJhY2subWV0YS5yZWZTYW1wbGVEdXJhdGlvbikgZHVyID0gdHJhY2subWV0YS5yZWZTYW1wbGVEdXJhdGlvbjtcXG4gICAgICAgIGlmIChzb3VyY2VzW3R5cGVdLmRhdGEubGVuZ3RoID49IHRoaXMucHJlbG9hZFRpbWUgLyBkdXIpIHtcXG4gICAgICAgICAgYWRkID0gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGFkZCkge1xcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcnMpLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgICAgZm9yIChsZXQgaSA9IDAsIGsgPSBPYmplY3Qua2V5cyhzb3VyY2VzKS5sZW5ndGg7IGkgPCBrOyBpKyspIHtcXG4gICAgICAgIGxldCB0eXBlID0gT2JqZWN0LmtleXMoc291cmNlcylbaV07XFxuICAgICAgICBsZXQgc291cmNlID0gc291cmNlc1t0eXBlXTtcXG4gICAgICAgIGxldCBtaW1lID0gdHlwZSA9PT0gJ3ZpZGVvJyA/ICd2aWRlby9tcDQ7Y29kZWNzPScgKyBzb3VyY2UubWltZXR5cGUgOiAnYXVkaW8vbXA0O2NvZGVjcz0nICsgc291cmNlLm1pbWV0eXBlO1xcbiAgICAgICAgbGV0IHNvdXJjZUJ1ZmZlciA9IHRoaXMubWVkaWFTb3VyY2UuYWRkU291cmNlQnVmZmVyKG1pbWUpO1xcbiAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJzW3R5cGVdID0gc291cmNlQnVmZmVyO1xcbiAgICAgICAgc291cmNlQnVmZmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIHRoaXMub25VcGRhdGVFbmQpO1xcbiAgICAgICAgdGhpcy5kb0FwcGVuZCgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZG9BcHBlbmQoKSB7XFxuICAgIGxldCBzb3VyY2VzID0gdGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZSgnUFJFX1NPVVJDRV9CVUZGRVInKTtcXG4gICAgaWYgKHNvdXJjZXMpIHtcXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVycykubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGxldCB0eXBlID0gT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXJzKVtpXTtcXG4gICAgICAgIGxldCBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcnNbdHlwZV07XFxuICAgICAgICBpZiAoIXNvdXJjZUJ1ZmZlci51cGRhdGluZykge1xcbiAgICAgICAgICBsZXQgc291cmNlID0gc291cmNlcy5zb3VyY2VzW3R5cGVdO1xcbiAgICAgICAgICBpZiAoc291cmNlICYmICFzb3VyY2UuaW5pdGVkKSB7XFxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2FwcGVuZCBpbml0aWFsIHNlZ21lbnQnKVxcbiAgICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hcHBlbmRCdWZmZXIoc291cmNlLmluaXQuYnVmZmVyLmJ1ZmZlcik7XFxuICAgICAgICAgICAgc291cmNlLmluaXRlZCA9IHRydWU7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlKSB7XFxuICAgICAgICAgICAgbGV0IGRhdGEgPSBzb3VyY2UuZGF0YS5zaGlmdCgpO1xcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XFxuICAgICAgICAgICAgICBzb3VyY2VCdWZmZXIuYXBwZW5kQnVmZmVyKGRhdGEuYnVmZmVyLmJ1ZmZlcik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBlbmRPZlN0cmVhbSgpIHtcXG4gICAgY29uc3QgeyByZWFkeVN0YXRlLCBhY3RpdmVTb3VyY2VCdWZmZXJzIH0gPSB0aGlzLm1lZGlhU291cmNlO1xcbiAgICBpZiAocmVhZHlTdGF0ZSA9PT0gJ29wZW4nICYmIGFjdGl2ZVNvdXJjZUJ1ZmZlcnMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHRoaXMubWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAvLyBsb2dcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJlbW92ZShlbmQsIHN0YXJ0ID0gMCkge1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVycykubGVuZ3RoOyBpKyspIHtcXG4gICAgICBsZXQgYnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXJzW09iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVycylbaV1dO1xcbiAgICAgIGlmICghYnVmZmVyLnVwZGF0aW5nKSB7XFxuICAgICAgICAvLyBjb25zb2xlLmxvZyhzdGFydCwgZW5kKVxcbiAgICAgICAgYnVmZmVyLnJlbW92ZShzdGFydCwgZW5kKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIHJlbW92ZUJ1ZmZlcnMoKSB7XFxuICAgIGNvbnN0IHRhc2tMaXN0ID0gW107XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXJzKS5sZW5ndGg7IGkrKykge1xcbiAgICAgIGxldCBidWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcnNbT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXJzKVtpXV07XFxuICAgICAgYnVmZmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIHRoaXMub25VcGRhdGVFbmQpO1xcblxcbiAgICAgIGxldCB0YXNrO1xcbiAgICAgIGlmIChidWZmZXIudXBkYXRpbmcpIHtcXG4gICAgICAgIHRhc2sgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcXG4gICAgICAgICAgY29uc3QgZG9DbGVhbkJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBsZXQgcmV0cnlUaW1lID0gMztcXG5cXG4gICAgICAgICAgICBjb25zdCBjbGVhbiA9ICgpID0+IHtcXG4gICAgICAgICAgICAgIGlmICghYnVmZmVyLnVwZGF0aW5nKSB7XFxuICAgICAgICAgICAgICAgIE1TRS5jbGVhckJ1ZmZlcihidWZmZXIpO1xcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XFxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJldHJ5VGltZSA+IDApIHtcXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChjbGVhbiwgMjAwKTtcXG4gICAgICAgICAgICAgICAgcmV0cnlUaW1lLS07XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfTtcXG5cXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNsZWFuLCAyMDApO1xcbiAgICAgICAgICAgIGJ1ZmZlci5yZW1vdmVFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCBkb0NsZWFuQnVmZmVyKTtcXG4gICAgICAgICAgfTtcXG4gICAgICAgICAgYnVmZmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIGRvQ2xlYW5CdWZmZXIpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIE1TRS5jbGVhckJ1ZmZlcihidWZmZXIpO1xcbiAgICAgICAgdGFzayA9IFByb21pc2UucmVzb2x2ZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0YXNrTGlzdC5wdXNoKHRhc2spO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBQcm9taXNlLmFsbCh0YXNrTGlzdCk7XFxuICB9XFxuXFxuICBkZXN0cm95KCkge1xcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVCdWZmZXJzKCkudGhlbigoKSA9PiB7XFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcnMpLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBsZXQgYnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXJzW09iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVycylbaV1dO1xcbiAgICAgICAgdGhpcy5tZWRpYVNvdXJjZS5yZW1vdmVTb3VyY2VCdWZmZXIoYnVmZmVyKTtcXG4gICAgICAgIGRlbGV0ZSB0aGlzLnNvdXJjZUJ1ZmZlcnNbT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXJzKVtpXV07XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLm9uVGltZVVwZGF0ZSk7XFxuICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2FpdGluZycsIHRoaXMub25XYWl0aW5nKTtcXG4gICAgICB0aGlzLm1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLm9uU291cmNlT3Blbik7XFxuXFxuICAgICAgdGhpcy5lbmRPZlN0cmVhbSgpO1xcbiAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMudXJsKTtcXG5cXG4gICAgICB0aGlzLnVybCA9IG51bGw7XFxuICAgICAgdGhpcy5jb25maWdzID0ge307XFxuICAgICAgdGhpcy5jb250YWluZXIgPSBudWxsO1xcbiAgICAgIHRoaXMubWVkaWFTb3VyY2UgPSBudWxsO1xcbiAgICAgIHRoaXMuc291cmNlQnVmZmVycyA9IHt9O1xcbiAgICAgIHRoaXMucHJlbG9hZFRpbWUgPSAxO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBjbGVhckJ1ZmZlcihidWZmZXIpIHtcXG4gICAgY29uc3QgYnVmZmVyZWQgPSBidWZmZXIuYnVmZmVyZWQ7XFxuICAgIGxldCBiRW5kID0gMC4xO1xcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYnVmZmVyZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICBiRW5kID0gYnVmZmVyZWQuZW5kKGkpO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgYnVmZmVyLnJlbW92ZSgwLCBiRW5kKTtcXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgIC8vIERPIE5PVEhJTkdcXG4gICAgfVxcbiAgfVxcbn1cXG5leHBvcnRzLmRlZmF1bHQgPSBNU0U7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL3NyYy9tc2UvaW5kZXguanM/XCIpfSxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy93cml0ZS9idWZmZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci11dGlscy9zcmMvd3JpdGUvYnVmZmVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgX2NvbmNhdFR5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb25jYXQtdHlwZWQtYXJyYXkgKi8gXFxcIi4uL3hncGxheWVyLXV0aWxzL25vZGVfbW9kdWxlcy9jb25jYXQtdHlwZWQtYXJyYXkvbGliL2luZGV4LmpzXFxcIik7XFxuXFxudmFyIF9jb25jYXRUeXBlZEFycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbmNhdFR5cGVkQXJyYXkpO1xcblxcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFxuY2xhc3MgQnVmZmVyIHtcXG4gIGNvbnN0cnVjdG9yKGJ1ZmZlcikge1xcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlciB8fCBuZXcgVWludDhBcnJheSgwKTtcXG4gIH1cXG5cXG4gIHdyaXRlKC4uLmJ1ZmZlcikge1xcbiAgICBidWZmZXIuZm9yRWFjaChpdGVtID0+IHtcXG4gICAgICB0aGlzLmJ1ZmZlciA9ICgwLCBfY29uY2F0VHlwZWRBcnJheTIuZGVmYXVsdCkoVWludDhBcnJheSwgdGhpcy5idWZmZXIsIGl0ZW0pO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHN0YXRpYyB3cml0ZVVpbnQzMih2YWx1ZSkge1xcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW3ZhbHVlID4+IDI0LCB2YWx1ZSA+PiAxNiAmIDB4ZmYsIHZhbHVlID4+IDggJiAweGZmLCB2YWx1ZSAmIDB4ZmZdKTtcXG4gIH1cXG5cXG4gIHN0YXRpYyByZWFkQXNJbnQoYXJyKSB7XFxuICAgIGxldCB0ZW1wID0gJyc7XFxuXFxuICAgIGZ1bmN0aW9uIHBhZFN0YXJ0NEhleChoZXhOdW0pIHtcXG4gICAgICBsZXQgaGV4U3RyID0gaGV4TnVtLnRvU3RyaW5nKDE2KTtcXG4gICAgICByZXR1cm4gaGV4U3RyLnBhZFN0YXJ0KDIsICcwJyk7XFxuICAgIH1cXG5cXG4gICAgYXJyLmZvckVhY2gobnVtID0+IHtcXG4gICAgICB0ZW1wICs9IHBhZFN0YXJ0NEhleChudW0pO1xcbiAgICB9KTtcXG4gICAgcmV0dXJuIHBhcnNlSW50KHRlbXAsIDE2KTtcXG4gIH1cXG59XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gQnVmZmVyO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9zcmMvd3JpdGUvYnVmZmVyLmpzP1wiKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvd3JpdGUvc3RyZWFtLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvc3JjL3dyaXRlL3N0cmVhbS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuY2xhc3MgU3RyZWFtIHtcXG4gIGNvbnN0cnVjdG9yKGJ1ZmZlcikge1xcbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcXG4gICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcXG4gICAgICB0aGlzLmRhdGF2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XFxuICAgICAgdGhpcy5kYXRhdmlldy5wb3NpdGlvbiA9IDA7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIGlzIGludmFsaWQnKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZ2V0IGxlbmd0aCgpIHtcXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XFxuICB9XFxuXFxuICBzZXQgcG9zaXRpb24odmFsdWUpIHtcXG4gICAgdGhpcy5kYXRhdmlldy5wb3NpdGlvbiA9IHZhbHVlO1xcbiAgfVxcblxcbiAgZ2V0IHBvc2l0aW9uKCkge1xcbiAgICByZXR1cm4gdGhpcy5kYXRhdmlldy5wb3NpdGlvbjtcXG4gIH1cXG5cXG4gIGJhY2soY291bnQpIHtcXG4gICAgdGhpcy5wb3NpdGlvbiAtPSBjb3VudDtcXG4gIH1cXG5cXG4gIHNraXAoY291bnQpIHtcXG4gICAgbGV0IGxvb3AgPSBNYXRoLmZsb29yKGNvdW50IC8gNCk7XFxuICAgIGxldCBsYXN0ID0gY291bnQgJSA0O1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvb3A7IGkrKykge1xcbiAgICAgIFN0cmVhbS5yZWFkQnl0ZSh0aGlzLmRhdGF2aWV3LCA0KTtcXG4gICAgfVxcbiAgICBpZiAobGFzdCA+IDApIHtcXG4gICAgICBTdHJlYW0ucmVhZEJ5dGUodGhpcy5kYXRhdmlldywgbGFzdCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogW3JlYWRCeXRlIOS7jkRhdGFWaWV35Lit6K+75Y+W5pWw5o2uXVxcbiAgICogQHBhcmFtICB7RGF0YVZpZXd9IGJ1ZmZlciBbRGF0YVZpZXflrp7kvotdXFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNpemUgICBb6K+75Y+W5a2X6IqC5pWwXVxcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgW+aVtOaVsF1cXG4gICAqL1xcbiAgc3RhdGljIHJlYWRCeXRlKGJ1ZmZlciwgc2l6ZSwgc2lnbikge1xcbiAgICBsZXQgcmVzO1xcbiAgICBzd2l0Y2ggKHNpemUpIHtcXG4gICAgICBjYXNlIDE6XFxuICAgICAgICBpZiAoc2lnbikge1xcbiAgICAgICAgICByZXMgPSBidWZmZXIuZ2V0SW50OChidWZmZXIucG9zaXRpb24pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmVzID0gYnVmZmVyLmdldFVpbnQ4KGJ1ZmZlci5wb3NpdGlvbik7XFxuICAgICAgICB9XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIDI6XFxuICAgICAgICBpZiAoc2lnbikge1xcbiAgICAgICAgICByZXMgPSBidWZmZXIuZ2V0SW50MTYoYnVmZmVyLnBvc2l0aW9uKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJlcyA9IGJ1ZmZlci5nZXRVaW50MTYoYnVmZmVyLnBvc2l0aW9uKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgMzpcXG4gICAgICAgIGlmIChzaWduKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IHN1cHBvcnRlZCBmb3IgcmVhZEJ5dGUgMycpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmVzID0gYnVmZmVyLmdldFVpbnQ4KGJ1ZmZlci5wb3NpdGlvbikgPDwgMTY7XFxuICAgICAgICAgIHJlcyB8PSBidWZmZXIuZ2V0VWludDgoYnVmZmVyLnBvc2l0aW9uICsgMSkgPDwgODtcXG4gICAgICAgICAgcmVzIHw9IGJ1ZmZlci5nZXRVaW50OChidWZmZXIucG9zaXRpb24gKyAyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgNDpcXG4gICAgICAgIGlmIChzaWduKSB7XFxuICAgICAgICAgIHJlcyA9IGJ1ZmZlci5nZXRJbnQzMihidWZmZXIucG9zaXRpb24pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmVzID0gYnVmZmVyLmdldFVpbnQzMihidWZmZXIucG9zaXRpb24pO1xcbiAgICAgICAgfVxcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSA4OlxcbiAgICAgICAgaWYgKHNpZ24pIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3Qgc3VwcG9ydGVkIGZvciByZWFkQm9keSA4Jyk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXMgPSBidWZmZXIuZ2V0VWludDMyKGJ1ZmZlci5wb3NpdGlvbikgPDwgMzI7XFxuICAgICAgICAgIHJlcyB8PSBidWZmZXIuZ2V0VWludDMyKGJ1ZmZlci5wb3NpdGlvbiArIDQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgYnJlYWs7XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHJlcyA9ICcnO1xcbiAgICB9XFxuICAgIGJ1ZmZlci5wb3NpdGlvbiArPSBzaXplO1xcbiAgICByZXR1cm4gcmVzO1xcbiAgfVxcblxcbiAgcmVhZFVpbnQ4KCkge1xcbiAgICByZXR1cm4gU3RyZWFtLnJlYWRCeXRlKHRoaXMuZGF0YXZpZXcsIDEpO1xcbiAgfVxcblxcbiAgcmVhZFVpbnQxNigpIHtcXG4gICAgcmV0dXJuIFN0cmVhbS5yZWFkQnl0ZSh0aGlzLmRhdGF2aWV3LCAyKTtcXG4gIH1cXG5cXG4gIHJlYWRVaW50MjQoKSB7XFxuICAgIHJldHVybiBTdHJlYW0ucmVhZEJ5dGUodGhpcy5kYXRhdmlldywgMyk7XFxuICB9XFxuXFxuICByZWFkVWludDMyKCkge1xcbiAgICByZXR1cm4gU3RyZWFtLnJlYWRCeXRlKHRoaXMuZGF0YXZpZXcsIDQpO1xcbiAgfVxcblxcbiAgcmVhZFVpbnQ2NCgpIHtcXG4gICAgcmV0dXJuIFN0cmVhbS5yZWFkQnl0ZSh0aGlzLmRhdGF2aWV3LCA4KTtcXG4gIH1cXG5cXG4gIHJlYWRJbnQ4KCkge1xcbiAgICByZXR1cm4gU3RyZWFtLnJlYWRCeXRlKHRoaXMuZGF0YXZpZXcsIDEsIHRydWUpO1xcbiAgfVxcbiAgcmVhZEludDE2KCkge1xcbiAgICByZXR1cm4gU3RyZWFtLnJlYWRCeXRlKHRoaXMuZGF0YXZpZXcsIDIsIHRydWUpO1xcbiAgfVxcblxcbiAgcmVhZEludDMyKCkge1xcbiAgICByZXR1cm4gU3RyZWFtLnJlYWRCeXRlKHRoaXMuZGF0YXZpZXcsIDQsIHRydWUpO1xcbiAgfVxcblxcbiAgd3JpdGVVaW50MzIodmFsdWUpIHtcXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFt2YWx1ZSA+Pj4gMjQgJiAweGZmLCB2YWx1ZSA+Pj4gMTYgJiAweGZmLCB2YWx1ZSA+Pj4gOCAmIDB4ZmYsIHZhbHVlICYgMHhmZl0pO1xcbiAgfVxcbn1cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBTdHJlYW07XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL3NyYy93cml0ZS9zdHJlYW0uanM/XCIpfSxcIi4vc3JjL2Zsdi1saXZlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2Zsdi1saXZlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIF94Z3BsYXllclJlbXV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgeGdwbGF5ZXItcmVtdXggKi8gXFxcIi4uL3hncGxheWVyLXJlbXV4L2luZGV4LmpzXFxcIik7XFxuXFxudmFyIF94Z3BsYXllclJlbXV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3hncGxheWVyUmVtdXgpO1xcblxcbnZhciBfeGdwbGF5ZXJMb2FkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB4Z3BsYXllci1sb2FkZXIgKi8gXFxcIi4uL3hncGxheWVyLWxvYWRlci9pbmRleC5qc1xcXCIpO1xcblxcbnZhciBfeGdwbGF5ZXJEZW11eCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHhncGxheWVyLWRlbXV4ICovIFxcXCIuLi94Z3BsYXllci1kZW11eC9pbmRleC5qc1xcXCIpO1xcblxcbnZhciBfeGdwbGF5ZXJCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB4Z3BsYXllci1idWZmZXIgKi8gXFxcIi4uL3hncGxheWVyLWJ1ZmZlci9pbmRleC5qc1xcXCIpO1xcblxcbnZhciBfeGdwbGF5ZXJVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHhncGxheWVyLXV0aWxzICovIFxcXCIuLi94Z3BsYXllci11dGlscy9pbmRleC5qc1xcXCIpO1xcblxcbnZhciBfeGdwbGF5ZXJDb2RlYyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHhncGxheWVyLWNvZGVjICovIFxcXCIuLi94Z3BsYXllci1jb2RlYy9pbmRleC5qc1xcXCIpO1xcblxcbnZhciBfeGdwbGF5ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB4Z3BsYXllciAqLyBcXFwieGdwbGF5ZXJcXFwiKTtcXG5cXG52YXIgX3hncGxheWVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3hncGxheWVyKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxcblxcbmNvbnN0IFJFTVVYX0VWRU5UUyA9IF94Z3BsYXllclV0aWxzLkVWRU5UUy5SRU1VWF9FVkVOVFM7XFxuY29uc3QgREVNVVhfRVZFTlRTID0gX3hncGxheWVyVXRpbHMuRVZFTlRTLkRFTVVYX0VWRU5UUztcXG5jb25zdCBMT0FERVJfRVZFTlRTID0gX3hncGxheWVyVXRpbHMuRVZFTlRTLkxPQURFUl9FVkVOVFM7XFxuY29uc3QgTVNFX0VWRU5UUyA9IF94Z3BsYXllclV0aWxzLkVWRU5UUy5NU0VfRVZFTlRTO1xcblxcbmNvbnN0IFRhZyA9ICdGTFZDb250cm9sbGVyJztcXG5cXG5jbGFzcyBMb2dnZXIge1xcbiAgd2FybigpIHt9XFxufVxcblxcbmNvbnN0IEZMVl9FUlJPUiA9ICdGTFZfRVJST1InO1xcblxcbmNsYXNzIEZsdkNvbnRyb2xsZXIge1xcbiAgY29uc3RydWN0b3IocGxheWVyKSB7XFxuICAgIHRoaXMuVEFHID0gVGFnO1xcbiAgICB0aGlzLl9wbGF5ZXIgPSBwbGF5ZXI7XFxuXFxuICAgIHRoaXMuc3RhdGUgPSB7XFxuICAgICAgaW5pdFNlZ21lbnRBcnJpdmVkOiBmYWxzZVxcbiAgICB9O1xcblxcbiAgICB0aGlzLmJ1ZmZlckNsZWFyVGltZXIgPSBudWxsO1xcbiAgfVxcblxcbiAgaW5pdCgpIHtcXG4gICAgdGhpcy5fY29udGV4dC5yZWdpc3RyeSgnRkVUQ0hfTE9BREVSJywgX3hncGxheWVyTG9hZGVyLkZldGNoTG9hZGVyKTtcXG4gICAgdGhpcy5fY29udGV4dC5yZWdpc3RyeSgnTE9BREVSX0JVRkZFUicsIF94Z3BsYXllckJ1ZmZlci5YZ0J1ZmZlcik7XFxuXFxuICAgIHRoaXMuX2NvbnRleHQucmVnaXN0cnkoJ0ZMVl9ERU1VWEVSJywgX3hncGxheWVyRGVtdXguRmx2RGVtdXhlcik7XFxuICAgIHRoaXMuX2NvbnRleHQucmVnaXN0cnkoJ1RSQUNLUycsIF94Z3BsYXllckJ1ZmZlci5UcmFja3MpO1xcblxcbiAgICB0aGlzLl9jb250ZXh0LnJlZ2lzdHJ5KCdNUDRfUkVNVVhFUicsIF94Z3BsYXllclJlbXV4Mi5kZWZhdWx0Lk1wNFJlbXV4ZXIpO1xcbiAgICB0aGlzLl9jb250ZXh0LnJlZ2lzdHJ5KCdQUkVfU09VUkNFX0JVRkZFUicsIF94Z3BsYXllckJ1ZmZlci5QcmVTb3VyY2UpO1xcblxcbiAgICBpZiAodGhpcy5fcGxheWVyLmNvbmZpZy5jb21wYXRpYmlsaXR5ICE9PSBmYWxzZSkge1xcbiAgICAgIHRoaXMuX2NvbnRleHQucmVnaXN0cnkoJ0NPTVBBVElCSUxJVFknLCBfeGdwbGF5ZXJDb2RlYy5Db21wYXRpYmlsaXR5KTtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9jb250ZXh0LnJlZ2lzdHJ5KCdMT0dHRVInLCBMb2dnZXIpO1xcbiAgICB0aGlzLm1zZSA9IHRoaXMuX2NvbnRleHQucmVnaXN0cnkoJ01TRScsIF94Z3BsYXllclV0aWxzLk1zZSkoeyBjb250YWluZXI6IHRoaXMuX3BsYXllci52aWRlbyB9KTtcXG5cXG4gICAgdGhpcy5faGFuZGxlVGltZVVwZGF0ZSA9IHRoaXMuX2hhbmRsZVRpbWVVcGRhdGUuYmluZCh0aGlzKTtcXG5cXG4gICAgdGhpcy5pbml0TGlzdGVuZXJzKCk7XFxuICB9XFxuXFxuICBpbml0TGlzdGVuZXJzKCkge1xcbiAgICB0aGlzLm9uKExPQURFUl9FVkVOVFMuTE9BREVSX0RBVEFMT0FERUQsIHRoaXMuX2hhbmRsZUxvYWRlckRhdGFMb2FkZWQuYmluZCh0aGlzKSk7XFxuICAgIHRoaXMub24oTE9BREVSX0VWRU5UUy5MT0FERVJfRVJST1IsIHRoaXMuX2hhbmRsZU5ldHdvcmtFcnJvci5iaW5kKHRoaXMpKTtcXG5cXG4gICAgdGhpcy5vbihERU1VWF9FVkVOVFMuTUVESUFfSU5GTywgdGhpcy5faGFuZGxlTWVkaWFJbmZvLmJpbmQodGhpcykpO1xcbiAgICB0aGlzLm9uKERFTVVYX0VWRU5UUy5NRVRBREFUQV9QQVJTRUQsIHRoaXMuX2hhbmRsZU1ldGFkYXRhUGFyc2VkLmJpbmQodGhpcykpO1xcbiAgICB0aGlzLm9uKERFTVVYX0VWRU5UUy5ERU1VWF9DT01QTEVURSwgdGhpcy5faGFuZGxlRGVtdXhDb21wbGV0ZS5iaW5kKHRoaXMpKTtcXG4gICAgdGhpcy5vbihERU1VWF9FVkVOVFMuREVNVVhfRVJST1IsIHRoaXMuX2hhbmRsZURlbXV4RXJyb3IuYmluZCh0aGlzKSk7XFxuXFxuICAgIHRoaXMub24oUkVNVVhfRVZFTlRTLklOSVRfU0VHTUVOVCwgdGhpcy5faGFuZGxlQXBwZW5kSW5pdFNlZ21lbnQuYmluZCh0aGlzKSk7XFxuICAgIHRoaXMub24oUkVNVVhfRVZFTlRTLk1FRElBX1NFR01FTlQsIHRoaXMuX2hhbmRsZU1lZGlhU2VnbWVudC5iaW5kKHRoaXMpKTtcXG5cXG4gICAgdGhpcy5vbihNU0VfRVZFTlRTLlNPVVJDRV9VUERBVEVfRU5ELCB0aGlzLl9oYW5kbGVTb3VyY2VVcGRhdGVFbmQuYmluZCh0aGlzKSk7XFxuXFxuICAgIHRoaXMuX3BsYXllci5vbigndGltZXVwZGF0ZScsIHRoaXMuX2hhbmRsZVRpbWVVcGRhdGUpO1xcbiAgfVxcblxcbiAgX2hhbmRsZU1lZGlhSW5mbygpIHtcXG4gICAgaWYgKCF0aGlzLl9jb250ZXh0Lm1lZGlhSW5mbykge1xcbiAgICAgIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuREVNVVhfRVJST1IsIG5ldyBFcnJvcignZmFpbGVkIHRvIGdldCBtZWRpYWluZm8nKSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIF9oYW5kbGVMb2FkZXJEYXRhTG9hZGVkKCkge1xcbiAgICB0aGlzLmVtaXRUbygnRkxWX0RFTVVYRVInLCBERU1VWF9FVkVOVFMuREVNVVhfU1RBUlQpO1xcbiAgfVxcblxcbiAgX2hhbmRsZU1ldGFkYXRhUGFyc2VkKHR5cGUpIHtcXG4gICAgdGhpcy5lbWl0KFJFTVVYX0VWRU5UUy5SRU1VWF9NRVRBREFUQSwgdHlwZSk7XFxuICB9XFxuICBfaGFuZGxlRGVtdXhDb21wbGV0ZSgpIHtcXG4gICAgdGhpcy5lbWl0KFJFTVVYX0VWRU5UUy5SRU1VWF9NRURJQSk7XFxuICB9XFxuXFxuICBfaGFuZGxlQXBwZW5kSW5pdFNlZ21lbnQoKSB7XFxuICAgIHRoaXMuc3RhdGUuaW5pdFNlZ21lbnRBcnJpdmVkID0gdHJ1ZTtcXG4gICAgdGhpcy5tc2UuYWRkU291cmNlQnVmZmVycygpO1xcbiAgfVxcblxcbiAgX2hhbmRsZU1lZGlhU2VnbWVudCgpIHtcXG4gICAgdGhpcy5tc2UuYWRkU291cmNlQnVmZmVycygpO1xcbiAgICB0aGlzLm1zZS5kb0FwcGVuZCgpO1xcbiAgfVxcblxcbiAgX2hhbmRsZVNvdXJjZVVwZGF0ZUVuZCgpIHtcXG4gICAgY29uc3QgdGltZSA9IHRoaXMuX3BsYXllci5jdXJyZW50VGltZTtcXG4gICAgY29uc3QgdmlkZW8gPSB0aGlzLl9wbGF5ZXIudmlkZW87XFxuICAgIGNvbnN0IHByZWxvYWRUaW1lID0gdGhpcy5fcGxheWVyLmNvbmZpZy5wcmVsb2FkVGltZSB8fCA1O1xcblxcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gdmlkZW8uYnVmZmVyZWQ7XFxuXFxuICAgIGlmIChsZW5ndGggPT09IDApIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgYnVmZmVyRW5kID0gdmlkZW8uYnVmZmVyZWQuZW5kKGxlbmd0aCAtIDEpO1xcbiAgICBpZiAoYnVmZmVyRW5kIC0gdGltZSA+IHByZWxvYWRUaW1lICogMikge1xcbiAgICAgIHRoaXMuX3BsYXllci5jdXJyZW50VGltZSA9IGJ1ZmZlckVuZCAtIHByZWxvYWRUaW1lO1xcbiAgICB9XFxuICAgIHRoaXMubXNlLmRvQXBwZW5kKCk7XFxuICB9XFxuXFxuICBfaGFuZGxlVGltZVVwZGF0ZSgpIHtcXG4gICAgY29uc3QgdGltZSA9IHRoaXMuX3BsYXllci5jdXJyZW50VGltZTtcXG5cXG4gICAgY29uc3QgdmlkZW8gPSB0aGlzLl9wbGF5ZXIudmlkZW87XFxuICAgIGxldCBidWZmZXJlZCA9IHZpZGVvLmJ1ZmZlcmVkO1xcblxcbiAgICBpZiAoIWJ1ZmZlcmVkIHx8ICFidWZmZXJlZC5sZW5ndGgpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgYnVmZmVyU3RhcnQgPSBidWZmZXJlZC5zdGFydChidWZmZXJlZC5sZW5ndGggLSAxKTtcXG4gICAgLy8gY29uc3QgYnVmZmVyU3RhcnQgPSB0aGlzLl9wbGF5ZXIuZ2V0QnVmZmVyZWRSYW5nZSgpWzBdXFxuICAgIGlmICh0aW1lIC0gYnVmZmVyU3RhcnQgPiAxMCkge1xcbiAgICAgIC8vIOWcqOebtOaSreaXtuWPiuaXtua4heepumJ1ZmZlcu+8jOmZjeS9juebtOaSreWGheWtmOWNoOeUqFxcbiAgICAgIGlmICh0aGlzLmJ1ZmZlckNsZWFyVGltZXIpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5tc2UucmVtb3ZlKHRpbWUgLSAxLCBidWZmZXJTdGFydCk7XFxuICAgICAgdGhpcy5idWZmZXJDbGVhclRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XFxuICAgICAgICB0aGlzLmJ1ZmZlckNsZWFyVGltZXIgPSBudWxsO1xcbiAgICAgIH0sIDUwMDApO1xcbiAgICB9XFxuICB9XFxuXFxuICBfaGFuZGxlTmV0d29ya0Vycm9yKHRhZywgZXJyKSB7XFxuICAgIHRoaXMuX3BsYXllci5lbWl0KCdlcnJvcicsIG5ldyBfeGdwbGF5ZXIyLmRlZmF1bHQuRXJyb3JzKCduZXR3b3JrJywgdGhpcy5fcGxheWVyLmNvbmZpZy51cmwpKTtcXG4gICAgdGhpcy5fb25FcnJvcihMT0FERVJfRVZFTlRTLkxPQURFUl9FUlJPUiwgdGFnLCBlcnIsIHRydWUpO1xcbiAgfVxcblxcbiAgX2hhbmRsZURlbXV4RXJyb3IodGFnLCBlcnIsIGZhdGFsKSB7XFxuICAgIGlmIChmYXRhbCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgZmF0YWwgPSBmYWxzZTtcXG4gICAgfVxcbiAgICB0aGlzLl9wbGF5ZXIuZW1pdCgnZXJyb3InLCBuZXcgX3hncGxheWVyMi5kZWZhdWx0LkVycm9ycygncGFyc2UnLCB0aGlzLl9wbGF5ZXIuY29uZmlnLnVybCkpO1xcbiAgICB0aGlzLl9vbkVycm9yKExPQURFUl9FVkVOVFMuTE9BREVSX0VSUk9SLCB0YWcsIGVyciwgZmF0YWwpO1xcbiAgfVxcblxcbiAgX29uRXJyb3IodHlwZSwgbW9kLCBlcnIsIGZhdGFsKSB7XFxuICAgIGxldCBlcnJvciA9IHtcXG4gICAgICBlcnJvclR5cGU6IHR5cGUsXFxuICAgICAgZXJyb3JEZXRhaWxzOiBgWyR7bW9kfV06ICR7ZXJyLm1lc3NhZ2V9YCxcXG4gICAgICBlcnJvckZhdGFsOiBmYXRhbCB8fCBmYWxzZVxcbiAgICB9O1xcbiAgICB0aGlzLl9wbGF5ZXIuZW1pdChGTFZfRVJST1IsIGVycm9yKTtcXG4gIH1cXG5cXG4gIHNlZWsoKSB7XFxuICAgIGlmICghdGhpcy5zdGF0ZS5pbml0U2VnbWVudEFycml2ZWQpIHtcXG4gICAgICB0aGlzLmxvYWREYXRhKCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGxvYWREYXRhKCkge1xcbiAgICB0aGlzLmVtaXQoTE9BREVSX0VWRU5UUy5MQURFUl9TVEFSVCwgdGhpcy5fcGxheWVyLmNvbmZpZy51cmwpO1xcbiAgfVxcblxcbiAgcGF1c2UoKSB7XFxuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoJ0ZFVENIX0xPQURFUicpO1xcblxcbiAgICBpZiAobG9hZGVyKSB7XFxuICAgICAgbG9hZGVyLmNhbmNlbCgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBkZXN0cm95KCkge1xcbiAgICB0aGlzLl9wbGF5ZXIub2ZmKCd0aW1ldXBkYXRlJywgdGhpcy5faGFuZGxlVGltZVVwZGF0ZSk7XFxuICAgIHRoaXMuX3BsYXllciA9IG51bGw7XFxuICAgIHRoaXMubXNlID0gbnVsbDtcXG4gIH1cXG59XFxuZXhwb3J0cy5kZWZhdWx0ID0gRmx2Q29udHJvbGxlcjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi9zcmMvZmx2LWxpdmUuanM/XCIpfSxcIi4vc3JjL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbnZhciBfeGdwbGF5ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB4Z3BsYXllciAqLyBcXFwieGdwbGF5ZXJcXFwiKTtcXG5cXG52YXIgX3hncGxheWVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3hncGxheWVyKTtcXG5cXG52YXIgX3hncGxheWVyVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB4Z3BsYXllci11dGlscyAqLyBcXFwiLi4veGdwbGF5ZXItdXRpbHMvaW5kZXguanNcXFwiKTtcXG5cXG52YXIgX2ZsdkxpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Zsdi1saXZlICovIFxcXCIuL3NyYy9mbHYtbGl2ZS5qc1xcXCIpO1xcblxcbnZhciBfZmx2TGl2ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mbHZMaXZlKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxcblxcbmNvbnN0IGZsdkFsbG93ZWRFdmVudHMgPSBfeGdwbGF5ZXJVdGlscy5FVkVOVFMuRmx2QWxsb3dlZEV2ZW50cztcXG5cXG5jbGFzcyBGbHZQbGF5ZXIgZXh0ZW5kcyBfeGdwbGF5ZXIyLmRlZmF1bHQge1xcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XFxuICAgIHN1cGVyKGNvbmZpZyk7XFxuICAgIHRoaXMuY29udGV4dCA9IG5ldyBfeGdwbGF5ZXJVdGlscy5Db250ZXh0KGZsdkFsbG93ZWRFdmVudHMpO1xcbiAgICB0aGlzLmluaXRFdmVudHMoKTtcXG4gICAgdGhpcy5sb2FkZXJDb21wbGV0ZVRpbWVyID0gbnVsbDtcXG4gICAgLy8gY29uc3QgcHJlbG9hZFRpbWUgPSBwbGF5ZXIuY29uZmlnLnByZWxvYWRUaW1lIHx8IDE1XFxuICB9XFxuXFxuICBzdGFydCgpIHtcXG4gICAgdGhpcy5pbml0Rmx2KCk7XFxuICAgIHRoaXMuY29udGV4dC5pbml0KCk7XFxuICAgIHN1cGVyLnN0YXJ0KHRoaXMuZmx2Lm1zZS51cmwpO1xcbiAgfVxcblxcbiAgaW5pdEZsdkV2ZW50cyhmbHYpIHtcXG4gICAgY29uc3QgcGxheWVyID0gdGhpcztcXG4gICAgZmx2Lm9uY2UoX3hncGxheWVyVXRpbHMuRVZFTlRTLlJFTVVYX0VWRU5UUy5JTklUX1NFR01FTlQsICgpID0+IHtcXG4gICAgICBfeGdwbGF5ZXIyLmRlZmF1bHQudXRpbC5hZGRDbGFzcyhwbGF5ZXIucm9vdCwgJ3hncGxheWVyLWlzLWxpdmUnKTtcXG4gICAgICBpZiAoIV94Z3BsYXllcjIuZGVmYXVsdC51dGlsLmZpbmREb20odGhpcy5yb290LCAneGctbGl2ZScpKSB7XFxuICAgICAgICBjb25zdCBsaXZlID0gX3hncGxheWVyMi5kZWZhdWx0LnV0aWwuY3JlYXRlRG9tKCd4Zy1saXZlJywgJ+ato+WcqOebtOaSrScsIHt9LCAneGdwbGF5ZXItbGl2ZScpO1xcbiAgICAgICAgcGxheWVyLmNvbnRyb2xzLmFwcGVuZENoaWxkKGxpdmUpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIGZsdi5vbmNlKF94Z3BsYXllclV0aWxzLkVWRU5UUy5MT0FERVJfRVZFTlRTLkxPQURFUl9DT01QTEVURSwgKCkgPT4ge1xcbiAgICAgIC8vIOebtOaSreWujOaIkO+8jOW+heaSreaUvuWZqOaSreWujOe8k+WtmOWQjuWPkemAgeWFs+mXreS6i+S7tlxcbiAgICAgIGlmICghcGxheWVyLnBhdXNlZCkge1xcbiAgICAgICAgdGhpcy5sb2FkZXJDb21wbGV0ZVRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xcbiAgICAgICAgICBjb25zdCBlbmQgPSBwbGF5ZXIuZ2V0QnVmZmVyZWRSYW5nZSgpWzFdO1xcbiAgICAgICAgICBpZiAoTWF0aC5hYnMocGxheWVyLmN1cnJlbnRUaW1lIC0gZW5kKSA8IDAuNSkge1xcbiAgICAgICAgICAgIHBsYXllci5lbWl0KCdlbmRlZCcpO1xcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMubG9hZGVyQ29tcGxldGVUaW1lcik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIDIwMCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGluaXRFdmVudHMoKSB7XFxuICAgIHRoaXMub24oJ3RpbWV1cGRhdGUnLCAoKSA9PiB7XFxuICAgICAgdGhpcy5sb2FkRGF0YSgpO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5vbignc2Vla2luZycsICgpID0+IHtcXG4gICAgICBjb25zdCB0aW1lID0gdGhpcy5jdXJyZW50VGltZTtcXG4gICAgICBjb25zdCByYW5nZSA9IHRoaXMuZ2V0QnVmZmVyZWRSYW5nZSgpO1xcbiAgICAgIGlmICh0aW1lID4gcmFuZ2VbMV0gfHwgdGltZSA8IHJhbmdlWzBdKSB7XFxuICAgICAgICB0aGlzLmZsdi5zZWVrKHRoaXMuY3VycmVudFRpbWUpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxuICBpbml0Rmx2KCkge1xcbiAgICBjb25zdCBmbHYgPSB0aGlzLmNvbnRleHQucmVnaXN0cnkoJ0ZMVl9DT05UUk9MTEVSJywgX2ZsdkxpdmUyLmRlZmF1bHQpKHRoaXMpO1xcbiAgICB0aGlzLmluaXRGbHZFdmVudHMoZmx2KTtcXG4gICAgdGhpcy5mbHYgPSBmbHY7XFxuICB9XFxuXFxuICBwbGF5KCkge1xcbiAgICBpZiAodGhpcy5faGFzU3RhcnQpIHtcXG4gICAgICB0aGlzLl9kZXN0cm95KCkudGhlbigoKSA9PiB7XFxuICAgICAgICB0aGlzLmNvbnRleHQgPSBuZXcgX3hncGxheWVyVXRpbHMuQ29udGV4dChmbHZBbGxvd2VkRXZlbnRzKTtcXG4gICAgICAgIGNvbnN0IGZsdiA9IHRoaXMuY29udGV4dC5yZWdpc3RyeSgnRkxWX0NPTlRST0xMRVInLCBfZmx2TGl2ZTIuZGVmYXVsdCkodGhpcyk7XFxuICAgICAgICB0aGlzLmluaXRGbHZFdmVudHMoZmx2KTtcXG4gICAgICAgIHRoaXMuZmx2ID0gZmx2O1xcbiAgICAgICAgdGhpcy5jb250ZXh0LmluaXQoKTtcXG4gICAgICAgIHN1cGVyLnN0YXJ0KGZsdi5tc2UudXJsKTtcXG4gICAgICAgIHN1cGVyLnBsYXkoKTtcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdXBlci5wbGF5KCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHBhdXNlKCkge1xcbiAgICBzdXBlci5wYXVzZSgpO1xcbiAgICBpZiAodGhpcy5mbHYpIHtcXG4gICAgICB0aGlzLmZsdi5wYXVzZSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBsb2FkRGF0YSh0aW1lID0gdGhpcy5jdXJyZW50VGltZSkge1xcbiAgICBpZiAodGhpcy5mbHYpIHtcXG4gICAgICB0aGlzLmZsdi5zZWVrKHRpbWUpO1xcbiAgICB9XFxuICB9XFxuXFxuICBkZXN0cm95KCkge1xcbiAgICB0aGlzLl9kZXN0cm95KCkudGhlbigoKSA9PiB7XFxuICAgICAgc3VwZXIuZGVzdHJveSgpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIF9kZXN0cm95KCkge1xcbiAgICByZXR1cm4gdGhpcy5mbHYubXNlLmRlc3Ryb3koKS50aGVuKCgpID0+IHtcXG4gICAgICB0aGlzLmNvbnRleHQuZGVzdHJveSgpO1xcbiAgICAgIHRoaXMuZmx2ID0gbnVsbDtcXG4gICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xcbiAgICAgIGlmICh0aGlzLmxvYWRlckNvbXBsZXRlVGltZXIpIHtcXG4gICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMubG9hZGVyQ29tcGxldGVUaW1lcik7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGdldCBzcmMoKSB7XFxuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTcmM7XFxuICB9XFxuXFxuICBzZXQgc3JjKHVybCkge1xcbiAgICB0aGlzLnBsYXllci5jb25maWcudXJsID0gdXJsO1xcbiAgICBpZiAoIXRoaXMucGF1c2VkKSB7XFxuICAgICAgdGhpcy5wYXVzZSgpO1xcbiAgICAgIHRoaXMub25jZSgncGF1c2UnLCAoKSA9PiB7XFxuICAgICAgICB0aGlzLnN0YXJ0KHVybCk7XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy5vbmNlKCdjYW5wbGF5JywgKCkgPT4ge1xcbiAgICAgICAgdGhpcy5wbGF5KCk7XFxuICAgICAgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhpcy5zdGFydCh1cmwpO1xcbiAgICB9XFxuICAgIHRoaXMub25jZSgnY2FucGxheScsICgpID0+IHtcXG4gICAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcXG4gICAgfSk7XFxuICB9XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gRmx2UGxheWVyO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uL3NyYy9pbmRleC5qcz9cIil9LDA6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIG11bHRpIC4vc3JjL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7ZXZhbCgnbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9pbmRleC5qcyAqL1wiLi9zcmMvaW5kZXguanNcIik7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2L211bHRpXy4vc3JjL2luZGV4LmpzPycpfSx4Z3BsYXllcjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiBleHRlcm5hbCBcInhncGxheWVyXCIgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzKXtldmFsKFwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX3hncGxheWVyX187XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2L2V4dGVybmFsXyUyMnhncGxheWVyJTIyP1wiKX19KX0pKTsiLCIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KHJlcXVpcmUoXCJ4Z3BsYXllclwiKSk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJ4Z3BsYXllclwiXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzW1wieGdwbGF5ZXItZmx2XCJdPXQocmVxdWlyZShcInhncGxheWVyXCIpKTplW1wieGdwbGF5ZXItZmx2XCJdPXQoZS54Z3BsYXllcil9KHdpbmRvdywoZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PXt9O2Z1bmN0aW9uIGkocyl7aWYodFtzXSlyZXR1cm4gdFtzXS5leHBvcnRzO3ZhciByPXRbc109e2k6cyxsOiExLGV4cG9ydHM6e319O3JldHVybiBlW3NdLmNhbGwoci5leHBvcnRzLHIsci5leHBvcnRzLGkpLHIubD0hMCxyLmV4cG9ydHN9cmV0dXJuIGkubT1lLGkuYz10LGkuZD1mdW5jdGlvbihlLHQscyl7aS5vKGUsdCl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse2VudW1lcmFibGU6ITAsZ2V0OnN9KX0saS5yPWZ1bmN0aW9uKGUpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LGkudD1mdW5jdGlvbihlLHQpe2lmKDEmdCYmKGU9aShlKSksOCZ0KXJldHVybiBlO2lmKDQmdCYmXCJvYmplY3RcIj09dHlwZW9mIGUmJmUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgcz1PYmplY3QuY3JlYXRlKG51bGwpO2lmKGkucihzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkocyxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTplfSksMiZ0JiZcInN0cmluZ1wiIT10eXBlb2YgZSlmb3IodmFyIHIgaW4gZSlpLmQocyxyLGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfS5iaW5kKG51bGwscikpO3JldHVybiBzfSxpLm49ZnVuY3Rpb24oZSl7dmFyIHQ9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIGkuZCh0LFwiYVwiLHQpLHR9LGkubz1mdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KX0saS5wPVwiXCIsaShpLnM9MTEpfShbZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz17Q29udGV4dDppKDEzKS5kZWZhdWx0LEVWRU5UUzppKDQpLmRlZmF1bHQsV09SS0VSX0NPTU1BTkRTOmkoMTUpLmRlZmF1bHQsc25pZmZlcjppKDE2KS5kZWZhdWx0LGlzTGU6aSgxNykuZGVmYXVsdCxVVEY4OmkoMTgpLmRlZmF1bHQsTWVkaWFJbmZvOmkoMykuZGVmYXVsdCxNZWRpYVNhbXBsZTppKDE5KS5kZWZhdWx0LE1lZGlhU2VnbWVudDppKDIwKS5kZWZhdWx0LE1lZGlhU2VnbWVudExpc3Q6aSgyMSkuZGVmYXVsdCxBdWRpb1RyYWNrTWV0YTppKDUpLkF1ZGlvVHJhY2tNZXRhLFZpZGVvVHJhY2tNZXRhOmkoNSkuVmlkZW9UcmFja01ldGEsQXVkaW9UcmFja1NhbXBsZTppKDYpLkF1ZGlvVHJhY2tTYW1wbGUsVmlkZW9UcmFja1NhbXBsZTppKDYpLlZpZGVvVHJhY2tTYW1wbGUsTXNlOmkoMjIpLmRlZmF1bHQsU3RyZWFtOmkoMjMpLmRlZmF1bHQsQnVmZmVyOmkoMjQpLmRlZmF1bHQsQ3J5cHRvOmkoMjcpLmRlZmF1bHR9fSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y2xhc3Mgc3tjb25zdHJ1Y3Rvcigpe3RoaXMuaWQ9LTEsdGhpcy5zZXF1ZW5jZU51bWJlcj0wLHRoaXMuc2FtcGxlcz1bXSx0aGlzLmRyb3BwZWRTYW1wbGVzPVtdLHRoaXMubGVuZ3RoPTB9cmVzZXQoKXt0aGlzLnNlcXVlbmNlTnVtYmVyPTAsdGhpcy5zYW1wbGVzPVtdLHRoaXMubGVuZ3RoPTB9ZGlzdHJveSgpe3RoaXMucmVzZXQoKSx0aGlzLmlkPS0xfX10LmRlZmF1bHQ9czt0LkF1ZGlvVHJhY2s9Y2xhc3MgZXh0ZW5kcyBze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLlRBRz1cIkF1ZGlvVHJhY2tcIix0aGlzLnR5cGU9XCJhdWRpb1wifX07dC5WaWRlb1RyYWNrPWNsYXNzIGV4dGVuZHMgc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5UQUc9XCJWaWRlb1RyYWNrXCIsdGhpcy50eXBlPVwidmlkZW9cIix0aGlzLmRyb3BwZWQ9MH1yZXNldCgpe3RoaXMuc2VxdWVuY2VOdW1iZXI9MCx0aGlzLnNhbXBsZXM9W10sdGhpcy5sZW5ndGg9MCx0aGlzLmRyb3BwZWQ9MH19O3QuVHJhY2tzPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5hdWRpb1RyYWNrPW51bGwsdGhpcy52aWRlb1RyYWNrPW51bGx9ZGVzdHJveSgpe3RoaXMuYXVkaW9UcmFjaz1udWxsLHRoaXMudmlkZW9UcmFjaz1udWxsfX19LGZ1bmN0aW9uKHQsaSl7dC5leHBvcnRzPWV9LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBzPWU9Pntmb3IobGV0IHQgaW4gZSlpZihlLmhhc093blByb3BlcnR5KHQpJiZudWxsPT09ZVt0XSlyZXR1cm4hMTtyZXR1cm4hMH07Y2xhc3Mgcntjb25zdHJ1Y3Rvcigpe3RoaXMubWltZVR5cGU9bnVsbCx0aGlzLmR1cmF0aW9uPW51bGwsdGhpcy5oYXNWaWRlbz1udWxsLHRoaXMudmlkZW89e2NvZGVjOm51bGwsd2lkdGg6bnVsbCxoZWlnaHQ6bnVsbCxwcm9maWxlOm51bGwsbGV2ZWw6bnVsbCxmcmFtZVJhdGU6e2ZpeGVkOiEwLGZwczoyNSxmcHNfbnVtOjI1ZTMsZnBzX2RlbjoxZTN9LGNocm9tYUZvcm1hdDpudWxsLHBhclJhdGlvOnt3aWR0aDoxLGhlaWdodDoxfX0sdGhpcy5oYXNBdWRpbz1udWxsLHRoaXMuYXVkaW89e2NvZGVjOm51bGwsc2FtcGxlUmF0ZTpudWxsLHNhbXBsZVJhdGVJbmRleDpudWxsLGNoYW5uZWxDb3VudDpudWxsfX1pc0NvbXBsZXRlKCl7cmV0dXJuIHIuaXNCYXNlSW5mb1JlYWR5KHRoaXMpJiZyLmlzVmlkZW9SZWFkeSh0aGlzKSYmci5pc0F1ZGlvUmVhZHkodGhpcyl9c3RhdGljIGlzQmFzZUluZm9SZWFkeShlKXtyZXR1cm4gcyhlKX1zdGF0aWMgaXNWaWRlb1JlYWR5KGUpe3JldHVybiFlLmhhc1ZpZGVvfHxzKGUudmlkZW8pfXN0YXRpYyBpc0F1ZGlvUmVhZHkoZSl7cmV0dXJuIWUuaGFzQXVkaW98fHMoZS52aWRlbyl9fXQuZGVmYXVsdD1yfSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3Qgcz17TEFERVJfU1RBUlQ6XCJMT0FERVJfU1RBUlRcIixMT0FERVJfREFUQUxPQURFRDpcIkxPQURFUl9EQVRBTE9BREVEXCIsTE9BREVSX0NPTVBMRVRFOlwiTE9BREVSX0NPTVBMRVRFXCIsTE9BREVSX0VSUk9SOlwiTE9BREVSX0VSUk9SXCJ9LHI9e0RFTVVYX1NUQVJUOlwiREVNVVhfU1RBUlRcIixERU1VWF9DT01QTEVURTpcIkRFTVVYX0NPTVBMRVRFXCIsREVNVVhfRVJST1I6XCJERU1VWF9FUlJPUlwiLE1FVEFEQVRBX1BBUlNFRDpcIk1FVEFEQVRBX1BBUlNFRFwiLFZJREVPX01FVEFEQVRBX0NIQU5HRTpcIlZJREVPX01FVEFEQVRBX0NIQU5HRVwiLEFVRElPX01FVEFEQVRBX0NIQU5HRTpcIkFVRElPX01FVEFEQVRBX0NIQU5HRVwiLE1FRElBX0lORk86XCJNRURJQV9JTkZPXCJ9LGE9e1JFTVVYX01FVEFEQVRBOlwiUkVNVVhfTUVUQURBVEFcIixSRU1VWF9NRURJQTpcIlJFTVVYX01FRElBXCIsTUVESUFfU0VHTUVOVDpcIk1FRElBX1NFR01FTlRcIixSRU1VWF9FUlJPUjpcIlJFTVVYX0VSUk9SXCIsSU5JVF9TRUdNRU5UOlwiSU5JVF9TRUdNRU5UXCIsREVURUNUX0NIQU5HRV9TVFJFQU06XCJERVRFQ1RfQ0hBTkdFX1NUUkVBTVwifSxuPXtTT1VSQ0VfVVBEQVRFX0VORDpcIlNPVVJDRV9VUERBVEVfRU5EXCJ9LG89e1JFVFJZX1RJTUVfRVhDRUVERUQ6XCJSRVRSWV9USU1FX0VYQ0VFREVEXCJ9LGQ9T2JqZWN0LmFzc2lnbih7fSxzLHIsYSxuLG8pLGw9W10saD1bXTtmb3IobGV0IGUgaW4gZClkLmhhc093blByb3BlcnR5KGUpJiZsLnB1c2goZFtlXSk7Zm9yKGxldCBlIGluIGQpZC5oYXNPd25Qcm9wZXJ0eShlKSYmaC5wdXNoKGRbZV0pO3QuZGVmYXVsdD17QUxMRVZFTlRTOmQsSExTX0VWRU5UUzpvLFJFTVVYX0VWRU5UUzphLERFTVVYX0VWRU5UUzpyLE1TRV9FVkVOVFM6bixMT0FERVJfRVZFTlRTOnMsRmx2QWxsb3dlZEV2ZW50czpsLEhsc0FsbG93ZWRFdmVudHM6aCxDUllUT19FVkVOVFM6e1NUQVJUX0RFQ1JZUFQ6XCJTVEFSVF9ERUNSWVBUXCIsREVDUllQVEVEOlwiREVDUllQVEVEXCJ9fX0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3QuQXVkaW9UcmFja01ldGE9Y2xhc3N7Y29uc3RydWN0b3IoZSl7Y29uc3QgdD17c2FtcGxlUmF0ZTo0OGUzLGNoYW5uZWxDb3VudDoyLGNvZGVjOlwibXA0YS40MC4yXCIsY29uZmlnOls0MSw0MDEsMTM2LDBdLGR1cmF0aW9uOjAsaWQ6MixyZWZTYW1wbGVEdXJhdGlvbjoyMSxzYW1wbGVSYXRlSW5kZXg6Myx0aW1lc2NhbGU6MWUzLHR5cGU6XCJhdWRpb1wifTtyZXR1cm4gZT9PYmplY3QuYXNzaWduKHt9LHQsZSk6dH1kZXN0cm95KCl7dGhpcy5pbml0PW51bGx9fTt0LlZpZGVvVHJhY2tNZXRhPWNsYXNze2NvbnN0cnVjdG9yKGUpe2NvbnN0IHQ9e2F2Y2M6bnVsbCxzcHM6bmV3IFVpbnQ4QXJyYXkoMCkscHBzOm5ldyBVaW50OEFycmF5KDApLGNocm9tYUZvcm1hdDo0MjAsY29kZWM6XCJhdmMxLjY0MDAyMFwiLGNvZGVjSGVpZ2h0OjcyMCxjb2RlY1dpZHRoOjEyODAsZHVyYXRpb246MCxmcmFtZVJhdGU6e2ZpeGVkOiEwLGZwczoyNSxmcHNfbnVtOjI1ZTMsZnBzX2RlbjoxZTN9LGlkOjEsbGV2ZWw6XCIzLjJcIixwcmVzZW50SGVpZ2h0OjcyMCxwcmVzZW50V2lkdGg6MTI4MCxwcm9maWxlOlwiSGlnaFwiLHJlZlNhbXBsZUR1cmF0aW9uOjQwLHBhclJhdGlvOntoZWlnaHQ6MSx3aWR0aDoxfSx0aW1lc2NhbGU6MWUzLHR5cGU6XCJ2aWRlb1wifTtyZXR1cm4gZT9PYmplY3QuYXNzaWduKHt9LHQsZSk6dH1kZXN0cm95KCl7dGhpcy5pbml0PW51bGwsdGhpcy5zcHM9bnVsbCx0aGlzLnBwcz1udWxsfX19LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjbGFzcyBze2NvbnN0cnVjdG9yKGUpe2xldCB0PXMuZ2V0RGVmYXVsdCgpO3JldHVybiBlP09iamVjdC5hc3NpZ24oe30sdCxlKTp0fXN0YXRpYyBnZXREZWZhdWx0KCl7cmV0dXJue2R0czpudWxsLHB0czpudWxsLGRhdGE6bmV3IFVpbnQ4QXJyYXl9fX10LkF1ZGlvVHJhY2tTYW1wbGU9cztjbGFzcyBye2NvbnN0cnVjdG9yKGUpe2xldCB0PXIuZ2V0RGVmYXVsdCgpO3JldHVybiBlP09iamVjdC5hc3NpZ24oe30sdCxlKTp0fXN0YXRpYyBnZXREZWZhdWx0KCl7cmV0dXJue2R0czpudWxsLHB0czpudWxsLGlzS2V5ZnJhbWU6ITEsb3JpZ2luRHRzOm51bGwsZGF0YTpuZXcgVWludDhBcnJheX19fXQuVmlkZW9UcmFja1NhbXBsZT1yfSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXtOYWx1bml0OmkoMzApLmRlZmF1bHQsU3BzUGFyc2VyOmkoOCkuZGVmYXVsdCxDb21wYXRpYmlsaXR5OmkoMzIpLmRlZmF1bHR9fSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHMscj1pKDMxKSxhPShzPXIpJiZzLl9fZXNNb2R1bGU/czp7ZGVmYXVsdDpzfTtjbGFzcyBue3N0YXRpYyBfZWJzcDJyYnNwKGUpe2xldCB0PWUsaT10LmJ5dGVMZW5ndGgscz1uZXcgVWludDhBcnJheShpKSxyPTA7Zm9yKGxldCBlPTA7ZTxpO2UrKyllPj0yJiYzPT09dFtlXSYmMD09PXRbZS0xXSYmMD09PXRbZS0yXXx8KHNbcl09dFtlXSxyKyspO3JldHVybiBuZXcgVWludDhBcnJheShzLmJ1ZmZlciwwLHIpfXN0YXRpYyBwYXJzZVNQUyhlKXtsZXQgdD1uLl9lYnNwMnJic3AoZSksaT1uZXcgYS5kZWZhdWx0KHQpO2kucmVhZEJ5dGUoKTtsZXQgcz1pLnJlYWRCeXRlKCk7aS5yZWFkQnl0ZSgpO2xldCByPWkucmVhZEJ5dGUoKTtpLnJlYWRVRUcoKTtsZXQgbz1uLmdldFByb2ZpbGVTdHJpbmcocyksZD1uLmdldExldmVsU3RyaW5nKHIpLGw9MSxoPTQyMCx1PVswLDQyMCw0MjIsNDQ0XSxjPTg7aWYoKDEwMD09PXN8fDExMD09PXN8fDEyMj09PXN8fDI0ND09PXN8fDQ0PT09c3x8ODM9PT1zfHw4Nj09PXN8fDExOD09PXN8fDEyOD09PXN8fDEzOD09PXN8fDE0ND09PXMpJiYoMz09PShsPWkucmVhZFVFRygpKSYmaS5yZWFkQml0cygxKSxsPD0zJiYoaD11W2xdKSxjPWkucmVhZFVFRygpKzgsaS5yZWFkVUVHKCksaS5yZWFkQml0cygxKSxpLnJlYWRCb29sKCkpKXtsZXQgZT0zIT09bD84OjEyO2ZvcihsZXQgdD0wO3Q8ZTt0KyspaS5yZWFkQm9vbCgpJiYodDw2P24uX3NraXBTY2FsaW5nTGlzdChpLDE2KTpuLl9za2lwU2NhbGluZ0xpc3QoaSw2NCkpfWkucmVhZFVFRygpO2xldCBmPWkucmVhZFVFRygpO2lmKDA9PT1mKWkucmVhZFVFRygpO2Vsc2UgaWYoMT09PWYpe2kucmVhZEJpdHMoMSksaS5yZWFkU0VHKCksaS5yZWFkU0VHKCk7bGV0IGU9aS5yZWFkVUVHKCk7Zm9yKGxldCB0PTA7dDxlO3QrKylpLnJlYWRTRUcoKX1pLnJlYWRVRUcoKSxpLnJlYWRCaXRzKDEpO2xldCBwPWkucmVhZFVFRygpLG09aS5yZWFkVUVHKCksZz1pLnJlYWRCaXRzKDEpOzA9PT1nJiZpLnJlYWRCaXRzKDEpLGkucmVhZEJpdHMoMSk7bGV0IF89MCx5PTAsRT0wLFM9MDtpLnJlYWRCb29sKCkmJihfPWkucmVhZFVFRygpLHk9aS5yZWFkVUVHKCksRT1pLnJlYWRVRUcoKSxTPWkucmVhZFVFRygpKTtsZXQgQT0xLHY9MSxUPTAsYj0hMCxSPTAsRD0wO2lmKGkucmVhZEJvb2woKSl7aWYoaS5yZWFkQm9vbCgpKXtsZXQgZT1pLnJlYWRCeXRlKCksdD1bMSwxMiwxMCwxNiw0MCwyNCwyMCwzMiw4MCwxOCwxNSw2NCwxNjAsNCwzLDJdLHM9WzEsMTEsMTEsMTEsMzMsMTEsMTEsMTEsMzMsMTEsMTEsMzMsOTksMywyLDFdO2U+MCYmZTwxNj8oQT10W2UtMV0sdj1zW2UtMV0pOjI1NT09PWUmJihBPWkucmVhZEJ5dGUoKTw8OHxpLnJlYWRCeXRlKCksdj1pLnJlYWRCeXRlKCk8PDh8aS5yZWFkQnl0ZSgpKX1pZihpLnJlYWRCb29sKCkmJmkucmVhZEJvb2woKSxpLnJlYWRCb29sKCkmJihpLnJlYWRCaXRzKDQpLGkucmVhZEJvb2woKSYmaS5yZWFkQml0cygyNCkpLGkucmVhZEJvb2woKSYmKGkucmVhZFVFRygpLGkucmVhZFVFRygpKSxpLnJlYWRCb29sKCkpe2xldCBlPWkucmVhZEJpdHMoMzIpLHQ9aS5yZWFkQml0cygzMik7Yj1pLnJlYWRCb29sKCksVD0oUj10KS8oRD0yKmUpfX1sZXQgdz0xOzE9PT1BJiYxPT09dnx8KHc9QS92KTtsZXQgeD0wLEw9MDtpZigwPT09bCl4PTEsTD0yLWc7ZWxzZXt4PTM9PT1sPzE6MixMPSgxPT09bD8yOjEpKigyLWcpfWxldCBPPTE2KihwKzEpLE09MTYqKG0rMSkqKDItZyk7Ty09KF8reSkqeCxNLT0oRStTKSpMO2xldCBCPU1hdGguY2VpbChPKncpO3JldHVybiBpLmRlc3Ryb3koKSxpPW51bGwse3Byb2ZpbGVfc3RyaW5nOm8sbGV2ZWxfc3RyaW5nOmQsYml0X2RlcHRoOmMsY2hyb21hX2Zvcm1hdDpoLGNocm9tYV9mb3JtYXRfc3RyaW5nOm4uZ2V0Q2hyb21hRm9ybWF0U3RyaW5nKGgpLGZyYW1lX3JhdGU6e2ZpeGVkOmIsZnBzOlQsZnBzX2RlbjpELGZwc19udW06Un0scGFyX3JhdGlvOnt3aWR0aDpBLGhlaWdodDp2fSxjb2RlY19zaXplOnt3aWR0aDpPLGhlaWdodDpNfSxwcmVzZW50X3NpemU6e3dpZHRoOkIsaGVpZ2h0Ok19fX1zdGF0aWMgX3NraXBTY2FsaW5nTGlzdChlLHQpe2xldCBpPTgscz04LHI9MDtmb3IobGV0IGE9MDthPHQ7YSsrKTAhPT1zJiYocz0oaSsocj1lLnJlYWRTRUcoKSkrMjU2KSUyNTYpLGk9MD09PXM/aTpzfXN0YXRpYyBnZXRQcm9maWxlU3RyaW5nKGUpe3N3aXRjaChlKXtjYXNlIDY2OnJldHVyblwiQmFzZWxpbmVcIjtjYXNlIDc3OnJldHVyblwiTWFpblwiO2Nhc2UgODg6cmV0dXJuXCJFeHRlbmRlZFwiO2Nhc2UgMTAwOnJldHVyblwiSGlnaFwiO2Nhc2UgMTEwOnJldHVyblwiSGlnaDEwXCI7Y2FzZSAxMjI6cmV0dXJuXCJIaWdoNDIyXCI7Y2FzZSAyNDQ6cmV0dXJuXCJIaWdoNDQ0XCI7ZGVmYXVsdDpyZXR1cm5cIlVua25vd25cIn19c3RhdGljIGdldExldmVsU3RyaW5nKGUpe3JldHVybihlLzEwKS50b0ZpeGVkKDEpfXN0YXRpYyBnZXRDaHJvbWFGb3JtYXRTdHJpbmcoZSl7c3dpdGNoKGUpe2Nhc2UgNDIwOnJldHVyblwiNDoyOjBcIjtjYXNlIDQyMjpyZXR1cm5cIjQ6MjoyXCI7Y2FzZSA0NDQ6cmV0dXJuXCI0OjQ6NFwiO2RlZmF1bHQ6cmV0dXJuXCJVbmtub3duXCJ9fXN0YXRpYyB0b1ZpZGVvTWV0YShlKXtsZXQgdD17fTtlJiZlLmNvZGVjX3NpemUmJih0LmNvZGVjV2lkdGg9ZS5jb2RlY19zaXplLndpZHRoLHQuY29kZWNIZWlnaHQ9ZS5jb2RlY19zaXplLmhlaWdodCx0LnByZXNlbnRXaWR0aD1lLnByZXNlbnRfc2l6ZS53aWR0aCx0LnByZXNlbnRIZWlnaHQ9ZS5wcmVzZW50X3NpemUuaGVpZ2h0KSx0LnByb2ZpbGU9ZS5wcm9maWxlX3N0cmluZyx0LmxldmVsPWUubGV2ZWxfc3RyaW5nLHQuYml0RGVwdGg9ZS5iaXRfZGVwdGgsdC5jaHJvbWFGb3JtYXQ9ZS5jaHJvbWFfZm9ybWF0LHQucGFyUmF0aW89e3dpZHRoOmUucGFyX3JhdGlvLndpZHRoLGhlaWdodDplLnBhcl9yYXRpby5oZWlnaHR9LHQuZnJhbWVSYXRlPWUuZnJhbWVfcmF0ZTtsZXQgaT10LmZyYW1lUmF0ZS5mcHNfZGVuLHM9dC5mcmFtZVJhdGUuZnBzX251bTt0LnJlZlNhbXBsZUR1cmF0aW9uPU1hdGguZmxvb3IodC50aW1lc2NhbGUqKGkvcykpfX10LmRlZmF1bHQ9bn0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz17VHJhY2s6aSgxKS5kZWZhdWx0LFRyYWNrczppKDEpLlRyYWNrcyxBdWRpb1RyYWNrOmkoMSkuQXVkaW9UcmFjayxWaWRlb1RyYWNrOmkoMSkuVmlkZW9UcmFjayxYZ0J1ZmZlcjppKDEwKS5YZ0J1ZmZlcixSZW11eEJ1ZmZlcjppKDEwKS5SZW11eEJ1ZmZlcixQcmVTb3VyY2U6aSgzNCkuZGVmYXVsdH19LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt0LlhnQnVmZmVyPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMubGVuZ3RoPWV8fDAsdGhpcy5oaXN0b3J5TGVuPWV8fDAsdGhpcy5hcnJheT1bXSx0aGlzLm9mZnNldD0wfXB1c2goZSl7dGhpcy5hcnJheS5wdXNoKGUpLHRoaXMubGVuZ3RoKz1lLmJ5dGVMZW5ndGgsdGhpcy5oaXN0b3J5TGVuKz1lLmJ5dGVMZW5ndGh9c2hpZnQoZSl7aWYodGhpcy5hcnJheS5sZW5ndGg8MSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7aWYodm9pZCAwPT09ZSlyZXR1cm4gdGhpcy5fc2hpZnRCdWZmZXIoKTtpZih0aGlzLm9mZnNldCtlPT09dGhpcy5hcnJheVswXS5sZW5ndGgpe2xldCB0PXRoaXMuYXJyYXlbMF0uc2xpY2UodGhpcy5vZmZzZXQsdGhpcy5vZmZzZXQrZSk7cmV0dXJuIHRoaXMub2Zmc2V0PTAsdGhpcy5hcnJheS5zaGlmdCgpLHRoaXMubGVuZ3RoLT1lLHR9aWYodGhpcy5vZmZzZXQrZTx0aGlzLmFycmF5WzBdLmxlbmd0aCl7bGV0IHQ9dGhpcy5hcnJheVswXS5zbGljZSh0aGlzLm9mZnNldCx0aGlzLm9mZnNldCtlKTtyZXR1cm4gdGhpcy5vZmZzZXQrPWUsdGhpcy5sZW5ndGgtPWUsdH1sZXQgdD1uZXcgVWludDhBcnJheShlKSxpPTA7Zm9yKDt0aGlzLmFycmF5Lmxlbmd0aD4wJiZlPjA7KXtpZih0aGlzLm9mZnNldCtlPHRoaXMuYXJyYXlbMF0ubGVuZ3RoKXtsZXQgcz10aGlzLmFycmF5WzBdLnNsaWNlKHRoaXMub2Zmc2V0LHRoaXMub2Zmc2V0K2UpO3Quc2V0KHMsaSksdGhpcy5vZmZzZXQrPWUsdGhpcy5sZW5ndGgtPWUsZT0wO2JyZWFrfXtsZXQgcz10aGlzLmFycmF5WzBdLmxlbmd0aC10aGlzLm9mZnNldDt0LnNldCh0aGlzLmFycmF5WzBdLnNsaWNlKHRoaXMub2Zmc2V0LHRoaXMuYXJyYXlbMF0ubGVuZ3RoKSxpKSx0aGlzLmFycmF5LnNoaWZ0KCksdGhpcy5vZmZzZXQ9MCxpKz1zLHRoaXMubGVuZ3RoLT1zLGUtPXN9fXJldHVybiB0fWNsZWFyKCl7dGhpcy5hcnJheT1bXSx0aGlzLmxlbmd0aD0wLHRoaXMub2Zmc2V0PTB9ZGVzdHJveSgpe3RoaXMuY2xlYXIoKSx0aGlzLmhpc3RvcnlMZW49MH1fc2hpZnRCdWZmZXIoKXtyZXR1cm4gdGhpcy5sZW5ndGgtPXRoaXMuYXJyYXlbMF0ubGVuZ3RoLHRoaXMub2Zmc2V0PTAsdGhpcy5hcnJheS5zaGlmdCgpfXRvSW50KGUsdCl7bGV0IGk9MCxzPXRoaXMub2Zmc2V0K2U7Zm9yKDtzPHRoaXMub2Zmc2V0K3QrZTspczx0aGlzLmFycmF5WzBdLmxlbmd0aD9pPTI1NippK3RoaXMuYXJyYXlbMF1bc106dGhpcy5hcnJheVsxXSYmKGk9MjU2KmkrdGhpcy5hcnJheVsxXVtzLXRoaXMuYXJyYXlbMF0ubGVuZ3RoXSkscysrO3JldHVybiBpfX07dC5SZW11eEJ1ZmZlcj1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMudmlkZW89W10sdGhpcy5hdWRpbz1bXX1kZXN0cm95KCl7dGhpcy52aWRlbz1bXSx0aGlzLmF1ZGlvPVtdfX19LGZ1bmN0aW9uKGUsdCxpKXtlLmV4cG9ydHM9aSgxMil9LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjt2YXIgcz1uKGkoMikpLHI9aSgwKSxhPW4oaSgyOCkpO2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWNvbnN0IG89ci5FVkVOVFMuRmx2QWxsb3dlZEV2ZW50cyxkPShlLHQpPT57aWYoIWUuY29uZmlnLmlzTGl2ZSYmZS5kdXJhdGlvbi1lLmN1cnJlbnRUaW1lPDIpe2NvbnN0IGk9ZS5nZXRCdWZmZXJlZFJhbmdlKCk7ZS5jdXJyZW50VGltZS1pWzFdPC4xJiYoZS5lbWl0KFwiZW5kZWRcIiksdC5tc2UuZW5kT2ZTdHJlYW0oKSl9fTtjbGFzcyBsIGV4dGVuZHMgcy5kZWZhdWx0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMuY29udGV4dD1uZXcgci5Db250ZXh0KG8pLHRoaXMuaW5pdEV2ZW50cygpfXN0YXJ0KCl7Y29uc3QgZT10aGlzLmNvbnRleHQucmVnaXN0cnkoXCJGTFZfQ09OVFJPTExFUlwiLGEuZGVmYXVsdCkodGhpcyk7dGhpcy5mbHY9ZSx0aGlzLmNvbnRleHQuaW5pdCgpLHN1cGVyLnN0YXJ0KGUubXNlLnVybCl9aW5pdEV2ZW50cygpe3RoaXMub24oXCJ0aW1ldXBkYXRlXCIsdGhpcy5oYW5kbGVUaW1lVXBkYXRlLmJpbmQodGhpcykpLHRoaXMub24oXCJzZWVraW5nXCIsdGhpcy5oYW5kbGVTZWVrLmJpbmQodGhpcykpLHRoaXMub25jZShcImRlc3Ryb3lcIix0aGlzLl9kZXN0cm95LmJpbmQodGhpcykpfWhhbmRsZVRpbWVVcGRhdGUoKXt0aGlzLmxvYWREYXRhKCksZCh0aGlzLHRoaXMuZmx2KX1oYW5kbGVTZWVrKCl7Y29uc3QgZT10aGlzLmN1cnJlbnRUaW1lLHQ9dGhpcy5nZXRCdWZmZXJlZFJhbmdlKCk7KGU+dFsxXXx8ZTx0WzBdKSYmdGhpcy5mbHYuc2Vlayh0aGlzLmN1cnJlbnRUaW1lKX1fZGVzdHJveSgpe3RoaXMuY29udGV4dC5kZXN0cm95KCksdGhpcy5jb250ZXh0PW51bGwsdGhpcy5mbHY9bnVsbH1sb2FkRGF0YShlPXRoaXMuY3VycmVudFRpbWUpe2NvbnN0IHQ9dGhpcy5nZXRCdWZmZXJlZFJhbmdlKCk7dFsxXS1lPCh0aGlzLmNvbmZpZy5wcmVsb2FkVGltZXx8MTUpLTUmJnRoaXMuZmx2LmxvYWROZXh0KHRbMV0rMSl9Z2V0IHNyYygpe3JldHVybiB0aGlzLmN1cnJlbnRTcmN9c2V0IHNyYyhlKXt0aGlzLnBsYXllci5jb25maWcudXJsPWUsdGhpcy5wYXVzZWQ/dGhpcy5zdGFydChlKToodGhpcy5wYXVzZSgpLHRoaXMub25jZShcInBhdXNlXCIsKCk9Pnt0aGlzLnN0YXJ0KGUpfSksdGhpcy5vbmNlKFwiY2FucGxheVwiLCgpPT57dGhpcy5wbGF5KCl9KSksdGhpcy5vbmNlKFwiY2FucGxheVwiLCgpPT57dGhpcy5jdXJyZW50VGltZT0wfSl9fWUuZXhwb3J0cz1sfSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHMscj1pKDMpLGE9KHM9cikmJnMuX19lc01vZHVsZT9zOntkZWZhdWx0OnN9LG49aSgxNCk7Y29uc3Qgbz1cIl9fVE9fX1wiO3QuZGVmYXVsdD1jbGFzc3tjb25zdHJ1Y3RvcihlPVtdKXt0aGlzLl9lbWl0dGVyPW5ldyBuLkV2ZW50RW1pdHRlcix0aGlzLl9pbnN0YW5jZU1hcD17fSx0aGlzLl9jbHNNYXA9e30sdGhpcy5faW5pdGVkPSExLHRoaXMubWVkaWFJbmZvPW5ldyBhLmRlZmF1bHQsdGhpcy5hbGxvd2VkRXZlbnRzPWUsdGhpcy5faG9va3M9e319Z2V0SW5zdGFuY2UoZSl7Y29uc3QgdD10aGlzLl9pbnN0YW5jZU1hcFtlXTtyZXR1cm4gdHx8bnVsbH1pbml0SW5zdGFuY2UoZSwuLi50KXtpZih0aGlzLl9jbHNNYXBbZV0pe2NvbnN0IGk9bmV3IHRoaXMuX2Nsc01hcFtlXSguLi50KTtyZXR1cm4gdGhpcy5faW5zdGFuY2VNYXBbZV09aSxpLmluaXQmJmkuaW5pdCgpLGl9dGhyb3cgbmV3IEVycm9yKGAke2V95pyq5ZyoY29udGV4dOS4reazqOWGjGApfWluaXQoZSl7aWYoIXRoaXMuX2luaXRlZCl7Zm9yKGxldCB0IGluIHRoaXMuX2Nsc01hcCl0aGlzLl9jbHNNYXAuaGFzT3duUHJvcGVydHkodCkmJiF0aGlzLl9pbnN0YW5jZU1hcFt0XSYmdGhpcy5pbml0SW5zdGFuY2UodCxlKTt0aGlzLl9pbml0ZWQ9ITB9fXJlZ2lzdHJ5KGUsdCl7Y29uc3QgaT10aGlzLl9lbWl0dGVyLHM9dGhpcy5faXNNZXNzYWdlTmFtZVZhbGlkLmJpbmQodGhpcykscj10aGlzO3JldHVybiB0aGlzLl9jbHNNYXBbZV09Y2xhc3MgZXh0ZW5kcyB0e2NvbnN0cnVjdG9yKC4uLnQpe3N1cGVyKC4uLnQpLHRoaXMubGlzdGVuZXJzPXt9LHRoaXMub25jZUxpc3RlbmVycz17fSx0aGlzLlRBRz1lLHRoaXMuX2NvbnRleHQ9cn1vbih0LHIpe3JldHVybiBzKHQpLHRoaXMubGlzdGVuZXJzW3RdP3RoaXMubGlzdGVuZXJzW3RdLnB1c2gocik6dGhpcy5saXN0ZW5lcnNbdF09W3JdLGkub24oYCR7dH0ke299JHtlfWAsciksaS5vbih0LHIpfWJlZm9yZShlLHQpe3MoZSksci5faG9va3NbZV0/ci5faG9va3NbZV0ucHVzaCh0KTpyLl9ob29rc1tlXT1bdF19b25jZSh0LHIpe3JldHVybiBzKHQpLHRoaXMub25jZUxpc3RlbmVyc1t0XT90aGlzLm9uY2VMaXN0ZW5lcnNbdF0ucHVzaChyKTp0aGlzLm9uY2VMaXN0ZW5lcnNbdF09W3JdLGkub25jZShgJHt0fSR7b30ke2V9YCxyKSxpLm9uY2UodCxyKX1lbWl0KGUsLi4udCl7cyhlKTtjb25zdCBhPXIuX2hvb2tzP3IuX2hvb2tzW2VdOm51bGw7aWYoYSlmb3IobGV0IGU9MCx0PWEubGVuZ3RoO2U8dDtlKyspeygwLGFbZV0pKCl9cmV0dXJuIGkuZW1pdChlLC4uLnQpfWVtaXRUbyhlLHQsLi4ucil7cmV0dXJuIHModCksaS5lbWl0KGAke3R9JHtvfSR7ZX1gLC4uLnIpfW9mZihlLHQpe3JldHVybiBzKGUpLGkub2ZmKGUsdCl9cmVtb3ZlTGlzdGVuZXJzKCl7Y29uc3QgdD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmJpbmQodGhpcy5saXN0ZW5lcnMpO2ZvcihsZXQgcyBpbiB0aGlzLmxpc3RlbmVycylpZih0KHMpKXtjb25zdCB0PXRoaXMubGlzdGVuZXJzW3NdfHxbXTtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyl7Y29uc3QgYT10W3JdO2kub2ZmKHMsYSksaS5vZmYoYCR7c30ke299JHtlfWAsYSl9fWZvcihsZXQgcyBpbiB0aGlzLm9uY2VMaXN0ZW5lcnMpaWYodChzKSl7Y29uc3QgdD10aGlzLm9uY2VMaXN0ZW5lcnNbc118fFtdO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7cisrKXtjb25zdCBhPXRbcl07aS5vZmYocyxhKSxpLm9mZihgJHtzfSR7b30ke2V9YCxhKX19fWRlc3Ryb3koKXtpZih0aGlzLnJlbW92ZUxpc3RlbmVycygpLHRoaXMubGlzdGVuZXJzPXt9LGRlbGV0ZSByLl9pbnN0YW5jZU1hcFtlXSxzdXBlci5kZXN0cm95KXJldHVybiBzdXBlci5kZXN0cm95KCl9fSwoLi4udCk9PnRoaXMuaW5pdEluc3RhbmNlKGUsLi4udCl9ZGVzdHJveUluc3RhbmNlcygpe09iamVjdC5rZXlzKHRoaXMuX2luc3RhbmNlTWFwKS5mb3JFYWNoKGU9Pnt0aGlzLl9pbnN0YW5jZU1hcFtlXS5kZXN0cm95JiZ0aGlzLl9pbnN0YW5jZU1hcFtlXS5kZXN0cm95KCl9KX1kZXN0cm95KCl7dGhpcy5fZW1pdHRlcj1udWxsLHRoaXMuYWxsb3dlZEV2ZW50cz1bXSx0aGlzLl9jbHNNYXA9bnVsbCx0aGlzLl9jb250ZXh0PW51bGwsdGhpcy5faG9va3M9bnVsbCx0aGlzLmRlc3Ryb3lJbnN0YW5jZXMoKX1faXNNZXNzYWdlTmFtZVZhbGlkKGUpe2lmKCF0aGlzLmFsbG93ZWRFdmVudHMuaW5kZXhPZihlKTwwKXRocm93IG5ldyBFcnJvcihgdW5yZWdpc3RlcmVkIG1lc3NhZ2UgbmFtZTogJHtlfWApfX19LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjt2YXIgcyxyPVwib2JqZWN0XCI9PXR5cGVvZiBSZWZsZWN0P1JlZmxlY3Q6bnVsbCxhPXImJlwiZnVuY3Rpb25cIj09dHlwZW9mIHIuYXBwbHk/ci5hcHBseTpmdW5jdGlvbihlLHQsaSl7cmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGUsdCxpKX07cz1yJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiByLm93bktleXM/ci5vd25LZXlzOk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM/ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGUpLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpKX06ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGUpfTt2YXIgbj1OdW1iZXIuaXNOYU58fGZ1bmN0aW9uKGUpe3JldHVybiBlIT1lfTtmdW5jdGlvbiBvKCl7by5pbml0LmNhbGwodGhpcyl9ZS5leHBvcnRzPW8sby5FdmVudEVtaXR0ZXI9byxvLnByb3RvdHlwZS5fZXZlbnRzPXZvaWQgMCxvLnByb3RvdHlwZS5fZXZlbnRzQ291bnQ9MCxvLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzPXZvaWQgMDt2YXIgZD0xMDtmdW5jdGlvbiBsKGUpe3JldHVybiB2b2lkIDA9PT1lLl9tYXhMaXN0ZW5lcnM/by5kZWZhdWx0TWF4TGlzdGVuZXJzOmUuX21heExpc3RlbmVyc31mdW5jdGlvbiBoKGUsdCxpLHMpe3ZhciByLGEsbixvO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGkpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgaSk7aWYodm9pZCAwPT09KGE9ZS5fZXZlbnRzKT8oYT1lLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSxlLl9ldmVudHNDb3VudD0wKToodm9pZCAwIT09YS5uZXdMaXN0ZW5lciYmKGUuZW1pdChcIm5ld0xpc3RlbmVyXCIsdCxpLmxpc3RlbmVyP2kubGlzdGVuZXI6aSksYT1lLl9ldmVudHMpLG49YVt0XSksdm9pZCAwPT09biluPWFbdF09aSwrK2UuX2V2ZW50c0NvdW50O2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uPWFbdF09cz9baSxuXTpbbixpXTpzP24udW5zaGlmdChpKTpuLnB1c2goaSksKHI9bChlKSk+MCYmbi5sZW5ndGg+ciYmIW4ud2FybmVkKXtuLndhcm5lZD0hMDt2YXIgZD1uZXcgRXJyb3IoXCJQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuIFwiK24ubGVuZ3RoK1wiIFwiK1N0cmluZyh0KStcIiBsaXN0ZW5lcnMgYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0XCIpO2QubmFtZT1cIk1heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZ1wiLGQuZW1pdHRlcj1lLGQudHlwZT10LGQuY291bnQ9bi5sZW5ndGgsbz1kLGNvbnNvbGUmJmNvbnNvbGUud2FybiYmY29uc29sZS53YXJuKG8pfXJldHVybiBlfWZ1bmN0aW9uIHUoKXtmb3IodmFyIGU9W10sdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspZS5wdXNoKGFyZ3VtZW50c1t0XSk7dGhpcy5maXJlZHx8KHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSx0aGlzLndyYXBGbiksdGhpcy5maXJlZD0hMCxhKHRoaXMubGlzdGVuZXIsdGhpcy50YXJnZXQsZSkpfWZ1bmN0aW9uIGMoZSx0LGkpe3ZhciBzPXtmaXJlZDohMSx3cmFwRm46dm9pZCAwLHRhcmdldDplLHR5cGU6dCxsaXN0ZW5lcjppfSxyPXUuYmluZChzKTtyZXR1cm4gci5saXN0ZW5lcj1pLHMud3JhcEZuPXIscn1mdW5jdGlvbiBmKGUsdCxpKXt2YXIgcz1lLl9ldmVudHM7aWYodm9pZCAwPT09cylyZXR1cm5bXTt2YXIgcj1zW3RdO3JldHVybiB2b2lkIDA9PT1yP1tdOlwiZnVuY3Rpb25cIj09dHlwZW9mIHI/aT9bci5saXN0ZW5lcnx8cl06W3JdOmk/ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PW5ldyBBcnJheShlLmxlbmd0aCksaT0wO2k8dC5sZW5ndGg7KytpKXRbaV09ZVtpXS5saXN0ZW5lcnx8ZVtpXTtyZXR1cm4gdH0ocik6bShyLHIubGVuZ3RoKX1mdW5jdGlvbiBwKGUpe3ZhciB0PXRoaXMuX2V2ZW50cztpZih2b2lkIDAhPT10KXt2YXIgaT10W2VdO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGkpcmV0dXJuIDE7aWYodm9pZCAwIT09aSlyZXR1cm4gaS5sZW5ndGh9cmV0dXJuIDB9ZnVuY3Rpb24gbShlLHQpe2Zvcih2YXIgaT1uZXcgQXJyYXkodCkscz0wO3M8dDsrK3MpaVtzXT1lW3NdO3JldHVybiBpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLFwiZGVmYXVsdE1heExpc3RlbmVyc1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBkfSxzZXQ6ZnVuY3Rpb24oZSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGV8fGU8MHx8bihlKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcrZStcIi5cIik7ZD1lfX0pLG8uaW5pdD1mdW5jdGlvbigpe3ZvaWQgMCE9PXRoaXMuX2V2ZW50cyYmdGhpcy5fZXZlbnRzIT09T2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHN8fCh0aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9ldmVudHNDb3VudD0wKSx0aGlzLl9tYXhMaXN0ZW5lcnM9dGhpcy5fbWF4TGlzdGVuZXJzfHx2b2lkIDB9LG8ucHJvdG90eXBlLnNldE1heExpc3RlbmVycz1mdW5jdGlvbihlKXtpZihcIm51bWJlclwiIT10eXBlb2YgZXx8ZTwwfHxuKGUpKXRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJytlK1wiLlwiKTtyZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzPWUsdGhpc30sby5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIGwodGhpcyl9LG8ucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdLGk9MTtpPGFyZ3VtZW50cy5sZW5ndGg7aSsrKXQucHVzaChhcmd1bWVudHNbaV0pO3ZhciBzPVwiZXJyb3JcIj09PWUscj10aGlzLl9ldmVudHM7aWYodm9pZCAwIT09cilzPXMmJnZvaWQgMD09PXIuZXJyb3I7ZWxzZSBpZighcylyZXR1cm4hMTtpZihzKXt2YXIgbjtpZih0Lmxlbmd0aD4wJiYobj10WzBdKSxuIGluc3RhbmNlb2YgRXJyb3IpdGhyb3cgbjt2YXIgbz1uZXcgRXJyb3IoXCJVbmhhbmRsZWQgZXJyb3IuXCIrKG4/XCIgKFwiK24ubWVzc2FnZStcIilcIjpcIlwiKSk7dGhyb3cgby5jb250ZXh0PW4sb312YXIgZD1yW2VdO2lmKHZvaWQgMD09PWQpcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZClhKGQsdGhpcyx0KTtlbHNle3ZhciBsPWQubGVuZ3RoLGg9bShkLGwpO2ZvcihpPTA7aTxsOysraSlhKGhbaV0sdGhpcyx0KX1yZXR1cm4hMH0sby5wcm90b3R5cGUuYWRkTGlzdGVuZXI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gaCh0aGlzLGUsdCwhMSl9LG8ucHJvdG90eXBlLm9uPW8ucHJvdG90eXBlLmFkZExpc3RlbmVyLG8ucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lcj1mdW5jdGlvbihlLHQpe3JldHVybiBoKHRoaXMsZSx0LCEwKX0sby5wcm90b3R5cGUub25jZT1mdW5jdGlvbihlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgdCk7cmV0dXJuIHRoaXMub24oZSxjKHRoaXMsZSx0KSksdGhpc30sby5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lcj1mdW5jdGlvbihlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgdCk7cmV0dXJuIHRoaXMucHJlcGVuZExpc3RlbmVyKGUsYyh0aGlzLGUsdCkpLHRoaXN9LG8ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyPWZ1bmN0aW9uKGUsdCl7dmFyIGkscyxyLGEsbjtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcrdHlwZW9mIHQpO2lmKHZvaWQgMD09PShzPXRoaXMuX2V2ZW50cykpcmV0dXJuIHRoaXM7aWYodm9pZCAwPT09KGk9c1tlXSkpcmV0dXJuIHRoaXM7aWYoaT09PXR8fGkubGlzdGVuZXI9PT10KTA9PS0tdGhpcy5fZXZlbnRzQ291bnQ/dGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCk6KGRlbGV0ZSBzW2VdLHMucmVtb3ZlTGlzdGVuZXImJnRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsZSxpLmxpc3RlbmVyfHx0KSk7ZWxzZSBpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBpKXtmb3Iocj0tMSxhPWkubGVuZ3RoLTE7YT49MDthLS0paWYoaVthXT09PXR8fGlbYV0ubGlzdGVuZXI9PT10KXtuPWlbYV0ubGlzdGVuZXIscj1hO2JyZWFrfWlmKHI8MClyZXR1cm4gdGhpczswPT09cj9pLnNoaWZ0KCk6ZnVuY3Rpb24oZSx0KXtmb3IoO3QrMTxlLmxlbmd0aDt0KyspZVt0XT1lW3QrMV07ZS5wb3AoKX0oaSxyKSwxPT09aS5sZW5ndGgmJihzW2VdPWlbMF0pLHZvaWQgMCE9PXMucmVtb3ZlTGlzdGVuZXImJnRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsZSxufHx0KX1yZXR1cm4gdGhpc30sby5wcm90b3R5cGUub2ZmPW8ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLG8ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycz1mdW5jdGlvbihlKXt2YXIgdCxpLHM7aWYodm9pZCAwPT09KGk9dGhpcy5fZXZlbnRzKSlyZXR1cm4gdGhpcztpZih2b2lkIDA9PT1pLnJlbW92ZUxpc3RlbmVyKXJldHVybiAwPT09YXJndW1lbnRzLmxlbmd0aD8odGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5fZXZlbnRzQ291bnQ9MCk6dm9pZCAwIT09aVtlXSYmKDA9PS0tdGhpcy5fZXZlbnRzQ291bnQ/dGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCk6ZGVsZXRlIGlbZV0pLHRoaXM7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByLGE9T2JqZWN0LmtleXMoaSk7Zm9yKHM9MDtzPGEubGVuZ3RoOysrcylcInJlbW92ZUxpc3RlbmVyXCIhPT0ocj1hW3NdKSYmdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMocik7cmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwicmVtb3ZlTGlzdGVuZXJcIiksdGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5fZXZlbnRzQ291bnQ9MCx0aGlzfWlmKFwiZnVuY3Rpb25cIj09dHlwZW9mKHQ9aVtlXSkpdGhpcy5yZW1vdmVMaXN0ZW5lcihlLHQpO2Vsc2UgaWYodm9pZCAwIT09dClmb3Iocz10Lmxlbmd0aC0xO3M+PTA7cy0tKXRoaXMucmVtb3ZlTGlzdGVuZXIoZSx0W3NdKTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybiBmKHRoaXMsZSwhMCl9LG8ucHJvdG90eXBlLnJhd0xpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm4gZih0aGlzLGUsITEpfSxvLmxpc3RlbmVyQ291bnQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmxpc3RlbmVyQ291bnQ/ZS5saXN0ZW5lckNvdW50KHQpOnAuY2FsbChlLHQpfSxvLnByb3RvdHlwZS5saXN0ZW5lckNvdW50PXAsby5wcm90b3R5cGUuZXZlbnROYW1lcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9ldmVudHNDb3VudD4wP3ModGhpcy5fZXZlbnRzKTpbXX19LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt0LkNPTlRFWFRfQ09NT01BTkRTPXtPTjpcIm9uXCIsT05DRTpcIm9uY2VcIixPRkY6XCJvZmZcIixFTUlUOlwiZW1pdFwiLERFU1RST1k6XCJkZXN0cm95XCJ9fSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3Qgcz1mdW5jdGlvbigpe2NvbnN0IGU9bmV3IEFycmF5QnVmZmVyKDIpO3JldHVybiBuZXcgRGF0YVZpZXcoZSkuc2V0SW50MTYoMCwyNTYsITApLDI1Nj09PW5ldyBJbnQxNkFycmF5KGUpWzBdfSgpLHI9e2dldCBkZXZpY2UoKXtsZXQgZT1yLm9zO3JldHVybiBlLmlzUGM/XCJwY1wiOmUuaXNUYWJsZXQ/XCJ0YWJsZXRcIjpcIm1vYmlsZVwifSxnZXQgYnJvd3Nlcigpe2xldCBlPW5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSx0PXtpZTovcnY6KFtcXGQuXSspXFwpIGxpa2UgZ2Vja28vLGZpcmZveDovZmlyZWZveFxcLyhbXFxkLl0rKS8sY2hyb21lOi9jaHJvbWVcXC8oW1xcZC5dKykvLG9wZXJhOi9vcGVyYS4oW1xcZC5dKykvLHNhZmFyaTovdmVyc2lvblxcLyhbXFxkLl0rKS4qc2FmYXJpL307cmV0dXJuW10uY29uY2F0KE9iamVjdC5rZXlzKHQpLmZpbHRlcihpPT50W2ldLnRlc3QoZSkpKVswXX0sZ2V0IG9zKCl7bGV0IGU9bmF2aWdhdG9yLnVzZXJBZ2VudCx0PS8oPzpXaW5kb3dzIFBob25lKS8udGVzdChlKSxpPS8oPzpTeW1iaWFuT1MpLy50ZXN0KGUpfHx0LHM9Lyg/OkFuZHJvaWQpLy50ZXN0KGUpLHI9Lyg/OkZpcmVmb3gpLy50ZXN0KGUpLGE9Lyg/OmlQYWR8UGxheUJvb2spLy50ZXN0KGUpfHxzJiYhLyg/Ok1vYmlsZSkvLnRlc3QoZSl8fHImJi8oPzpUYWJsZXQpLy50ZXN0KGUpLG49Lyg/OmlQaG9uZSkvLnRlc3QoZSkmJiFhO3JldHVybntpc1RhYmxldDphLGlzUGhvbmU6bixpc0FuZHJvaWQ6cyxpc1BjOiFuJiYhcyYmIWksaXNTeW1iaWFuOmksaXNXaW5kb3dzUGhvbmU6dCxpc0ZpcmVGb3g6cn19LGdldCBpc0xlKCl7cmV0dXJuIHN9fTt0LmRlZmF1bHQ9cn0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IHM9ZnVuY3Rpb24oKXtjb25zdCBlPW5ldyBBcnJheUJ1ZmZlcigyKTtyZXR1cm4gbmV3IERhdGFWaWV3KGUpLnNldEludDE2KDAsMjU2LCEwKSwyNTY9PT1uZXcgSW50MTZBcnJheShlKVswXX0oKTt0LmRlZmF1bHQ9c30sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NsYXNzIHN7c3RhdGljIGRlY29kZShlKXtjb25zdCB0PVtdLGk9ZTtsZXQgcj0wO2NvbnN0IGE9ZS5sZW5ndGg7Zm9yKDtyPGE7KWlmKGlbcl08MTI4KXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGlbcl0pKSwrK3I7ZWxzZXtpZihpW3JdPDE5Mik7ZWxzZSBpZihpW3JdPDIyNCl7aWYocy5fY2hlY2tDb250aW51YXRpb24oaSxyLDEpKXtjb25zdCBlPSgzMSZpW3JdKTw8Nnw2MyZpW3IrMV07aWYoZT49MTI4KXt0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSg2NTUzNSZlKSkscis9Mjtjb250aW51ZX19fWVsc2UgaWYoaVtyXTwyNDApe2lmKHMuX2NoZWNrQ29udGludWF0aW9uKGksciwyKSl7Y29uc3QgZT0oMTUmaVtyXSk8PDEyfCg2MyZpW3IrMV0pPDw2fDYzJmlbcisyXTtpZihlPj0yMDQ4JiY1NTI5NiE9KDYzNDg4JmUpKXt0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSg2NTUzNSZlKSkscis9Mztjb250aW51ZX19fWVsc2UgaWYoaVtyXTwyNDgmJnMuX2NoZWNrQ29udGludWF0aW9uKGksciwzKSl7bGV0IGU9KDcmaVtyXSk8PDE4fCg2MyZpW3IrMV0pPDwxMnwoNjMmaVtyKzJdKTw8Nnw2MyZpW3IrM107aWYoZT42NTUzNiYmZTwxMTE0MTEyKXtlLT02NTUzNix0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShlPj4+MTB8NTUyOTYpKSx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgxMDIzJmV8NTYzMjApKSxyKz00O2NvbnRpbnVlfX10LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSg2NTUzMykpLCsrcn1yZXR1cm4gdC5qb2luKFwiXCIpfXN0YXRpYyBfY2hlY2tDb250aW51YXRpb24oZSx0LGkpe2xldCBzPWU7aWYodCtpPHMubGVuZ3RoKXtmb3IoO2ktLTspaWYoMTI4IT0oMTkyJnNbKyt0XSkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuITF9fXQuZGVmYXVsdD1zfSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y2xhc3Mgc3tjb25zdHJ1Y3RvcihlKXtsZXQgdD1zLmdldERlZmF1bHRJbmYoKTtpZighZXx8XCJbb2JqZWN0IE9iamVjdF1cIiE9PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSlyZXR1cm4gdDtsZXQgaT1PYmplY3QuYXNzaWduKHt9LHQsZSk7T2JqZWN0LmVudHJpZXMoaSkuZm9yRWFjaCgoW2UsdF0pPT57dGhpc1tlXT10fSl9c3RhdGljIGdldERlZmF1bHRJbmYoKXtyZXR1cm57ZHRzOm51bGwscHRzOm51bGwsZHVyYXRpb246bnVsbCxwb3NpdGlvbjpudWxsLGlzUkFQOiExLG9yaWdpbkR0czpudWxsfX19dC5kZWZhdWx0PXN9LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt0LmRlZmF1bHQ9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLnN0YXJ0RHRzPS0xLHRoaXMuZW5kRHRzPS0xLHRoaXMuc3RhcnRQdHM9LTEsdGhpcy5lbmRQdHM9LTEsdGhpcy5vcmlnaW5TdGFydER0cz0tMSx0aGlzLm9yaWdpbkVuZER0cz0tMSx0aGlzLnJhbmRvbUFjY2Vzc1BvaW50cz1bXSx0aGlzLmZpcnN0U2FtcGxlPW51bGwsdGhpcy5sYXN0U2FtcGxlPW51bGx9YWRkUkFQKGUpe2UuaXNSQVA9ITAsdGhpcy5yYW5kb21BY2Nlc3NQb2ludHMucHVzaChlKX19fSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dC5kZWZhdWx0PWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX3R5cGU9ZSx0aGlzLl9saXN0PVtdLHRoaXMuX2xhc3RBcHBlbmRMb2NhdGlvbj0tMX1nZXQgdHlwZSgpe3JldHVybiB0aGlzLl90eXBlfWdldCBsZW5ndGgoKXtyZXR1cm4gdGhpcy5fbGlzdC5sZW5ndGh9aXNFbXB0eSgpe3JldHVybiAwPT09dGhpcy5fbGlzdC5sZW5ndGh9Y2xlYXIoKXt0aGlzLl9saXN0PVtdLHRoaXMuX2xhc3RBcHBlbmRMb2NhdGlvbj0tMX1fc2VhcmNoTmVhcmVzdFNlZ21lbnRCZWZvcmUoZSl7bGV0IHQ9dGhpcy5fbGlzdDtpZigwPT09dC5sZW5ndGgpcmV0dXJuLTI7bGV0IGk9dC5sZW5ndGgtMSxzPTAscj0wLGE9aSxuPTA7aWYoZTx0WzBdLm9yaWdpbkR0cylyZXR1cm4gbj0tMTtmb3IoO3I8PWE7KXtpZigocz1yK01hdGguZmxvb3IoKGEtcikvMikpPT09aXx8ZT50W3NdLmxhc3RTYW1wbGUub3JpZ2luRHRzJiZlPHRbcysxXS5vcmlnaW5EdHMpe249czticmVha310W3NdLm9yaWdpbkR0czxlP3I9cysxOmE9cy0xfXJldHVybiBufV9zZWFyY2hOZWFyZXN0U2VnbWVudEFmdGVyKGUpe3JldHVybiB0aGlzLl9zZWFyY2hOZWFyZXN0U2VnbWVudEJlZm9yZShlKSsxfWFwcGVuZChlKXtsZXQgdD10aGlzLl9saXN0LGk9dGhpcy5fbGFzdEFwcGVuZExvY2F0aW9uLHM9MDstMSE9PWkmJmk8dC5sZW5ndGgmJmUub3JpZ2luU3RhcnREdHM+PXRbaV0ubGFzdFNhbXBsZS5vcmlnaW5EdHMmJihpPT09dC5sZW5ndGgtMXx8aTx0Lmxlbmd0aC0xJiZlLm9yaWdpblN0YXJ0RHRzPHRbaSsxXS5vcmlnaW5TdGFydER0cyk/cz1pKzE6dC5sZW5ndGg+MCYmKHM9dGhpcy5fc2VhcmNoTmVhcmVzdFNlZ21lbnRCZWZvcmUoZS5vcmlnaW5TdGFydER0cykrMSksdGhpcy5fbGFzdEFwcGVuZExvY2F0aW9uPXMsdGhpcy5fbGlzdC5zcGxpY2UocywwLGUpfWdldExhc3RTZWdtZW50QmVmb3JlKGUpe2xldCB0PXRoaXMuX3NlYXJjaE5lYXJlc3RTZWdtZW50QmVmb3JlKGUpO3JldHVybiB0Pj0wP3RoaXMuX2xpc3RbdF06bnVsbH1nZXRMYXN0U2FtcGxlQmVmb3JlKGUpe2xldCB0PXRoaXMuZ2V0TGFzdFNlZ21lbnRCZWZvcmUoZSk7cmV0dXJuIG51bGwhPT10P3QubGFzdFNhbXBsZTpudWxsfWdldExhc3RSQVBCZWZvcmUoZSl7bGV0IHQ9dGhpcy5fc2VhcmNoTmVhcmVzdFNlZ21lbnRCZWZvcmUoZSksaT10aGlzLl9saXN0W3RdLnJhbmRvbUFjY2Vzc1BvaW50cztmb3IoOzA9PT1pLmxlbmd0aCYmdD4wOyl0LS0saT10aGlzLl9saXN0W3RdLnJhbmRvbUFjY2Vzc1BvaW50cztyZXR1cm4gaS5sZW5ndGg+MD9pW2kubGVuZ3RoLTFdOm51bGx9fX0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NsYXNzIHN7Y29uc3RydWN0b3IoZSl7dGhpcy5jb25maWdzPU9iamVjdC5hc3NpZ24oe30sZSksdGhpcy5jb250YWluZXI9dGhpcy5jb25maWdzLmNvbnRhaW5lcix0aGlzLm1lZGlhU291cmNlPW51bGwsdGhpcy5zb3VyY2VCdWZmZXJzPXt9LHRoaXMucHJlbG9hZFRpbWU9dGhpcy5jb25maWdzLnByZWxvYWRUaW1lfHwxLHRoaXMub25Tb3VyY2VPcGVuPXRoaXMub25Tb3VyY2VPcGVuLmJpbmQodGhpcyksdGhpcy5vblRpbWVVcGRhdGU9dGhpcy5vblRpbWVVcGRhdGUuYmluZCh0aGlzKSx0aGlzLm9uVXBkYXRlRW5kPXRoaXMub25VcGRhdGVFbmQuYmluZCh0aGlzKSx0aGlzLm9uV2FpdGluZz10aGlzLm9uV2FpdGluZy5iaW5kKHRoaXMpfWluaXQoKXt0aGlzLm1lZGlhU291cmNlPW5ldyBzZWxmLk1lZGlhU291cmNlLHRoaXMubWVkaWFTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcInNvdXJjZW9wZW5cIix0aGlzLm9uU291cmNlT3BlbiksdGhpcy5jb250YWluZXIuc3JjPVVSTC5jcmVhdGVPYmplY3RVUkwodGhpcy5tZWRpYVNvdXJjZSksdGhpcy51cmw9dGhpcy5jb250YWluZXIuc3JjLHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aW1ldXBkYXRlXCIsdGhpcy5vblRpbWVVcGRhdGUpLHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ3YWl0aW5nXCIsdGhpcy5vbldhaXRpbmcpfW9uVGltZVVwZGF0ZSgpe3RoaXMuZW1pdChcIlRJTUVfVVBEQVRFXCIsdGhpcy5jb250YWluZXIpfW9uV2FpdGluZygpe3RoaXMuZW1pdChcIldBSVRJTkdcIix0aGlzLmNvbnRhaW5lcil9b25Tb3VyY2VPcGVuKCl7dGhpcy5hZGRTb3VyY2VCdWZmZXJzKCl9b25VcGRhdGVFbmQoKXt0aGlzLmVtaXQoXCJTT1VSQ0VfVVBEQVRFX0VORFwiKSx0aGlzLmRvQXBwZW5kKCl9YWRkU291cmNlQnVmZmVycygpe2lmKFwib3BlblwiIT09dGhpcy5tZWRpYVNvdXJjZS5yZWFkeVN0YXRlKXJldHVybjtsZXQgZSx0PXRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoXCJQUkVfU09VUkNFX0JVRkZFUlwiKSxpPXRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoXCJUUkFDS1NcIik7dD10LnNvdXJjZXM7bGV0IHM9ITE7Zm9yKGxldCByPTAsYT1PYmplY3Qua2V5cyh0KS5sZW5ndGg7cjxhO3IrKyl7bGV0IGE9T2JqZWN0LmtleXModClbcl07aWYoXCJhdWRpb1wiPT09YT9lPWkuYXVkaW9UcmFjazpcInZpZGVvXCI9PT1hJiYoZT1pLnZpZGVvVHJhY2spLGUpe2xldCBpPVwiYXVkaW9cIj09PWE/MjE6NDA7ZS5tZXRhJiZlLm1ldGEucmVmU2FtcGxlRHVyYXRpb24mJihpPWUubWV0YS5yZWZTYW1wbGVEdXJhdGlvbiksdFthXS5kYXRhLmxlbmd0aD49dGhpcy5wcmVsb2FkVGltZS9pJiYocz0hMCl9fWlmKHMpe2lmKE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVycykubGVuZ3RoPjApcmV0dXJuO2ZvcihsZXQgZT0wLGk9T2JqZWN0LmtleXModCkubGVuZ3RoO2U8aTtlKyspe2xldCBpPU9iamVjdC5rZXlzKHQpW2VdLHM9dFtpXSxyPVwidmlkZW9cIj09PWk/XCJ2aWRlby9tcDQ7Y29kZWNzPVwiK3MubWltZXR5cGU6XCJhdWRpby9tcDQ7Y29kZWNzPVwiK3MubWltZXR5cGUsYT10aGlzLm1lZGlhU291cmNlLmFkZFNvdXJjZUJ1ZmZlcihyKTt0aGlzLnNvdXJjZUJ1ZmZlcnNbaV09YSxhLmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVlbmRcIix0aGlzLm9uVXBkYXRlRW5kKSx0aGlzLmRvQXBwZW5kKCl9fX1kb0FwcGVuZCgpe2xldCBlPXRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoXCJQUkVfU09VUkNFX0JVRkZFUlwiKTtpZihlKWZvcihsZXQgdD0wO3Q8T2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXJzKS5sZW5ndGg7dCsrKXtsZXQgaT1PYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcnMpW3RdLHM9dGhpcy5zb3VyY2VCdWZmZXJzW2ldO2lmKCFzLnVwZGF0aW5nKXtsZXQgdD1lLnNvdXJjZXNbaV07aWYodCYmIXQuaW5pdGVkKXMuYXBwZW5kQnVmZmVyKHQuaW5pdC5idWZmZXIuYnVmZmVyKSx0LmluaXRlZD0hMDtlbHNlIGlmKHQpe2xldCBlPXQuZGF0YS5zaGlmdCgpO2UmJnMuYXBwZW5kQnVmZmVyKGUuYnVmZmVyLmJ1ZmZlcil9fX19ZW5kT2ZTdHJlYW0oKXtjb25zdHtyZWFkeVN0YXRlOmUsYWN0aXZlU291cmNlQnVmZmVyczp0fT10aGlzLm1lZGlhU291cmNlO2lmKFwib3BlblwiPT09ZSYmMD09PXQubGVuZ3RoKXRyeXt0aGlzLm1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCl9Y2F0Y2goZSl7fX1yZW1vdmUoZSx0PTApe2ZvcihsZXQgaT0wO2k8T2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXJzKS5sZW5ndGg7aSsrKXtsZXQgcz10aGlzLnNvdXJjZUJ1ZmZlcnNbT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXJzKVtpXV07cy51cGRhdGluZ3x8cy5yZW1vdmUodCxlKX19cmVtb3ZlQnVmZmVycygpe2NvbnN0IGU9W107Zm9yKGxldCB0PTA7dDxPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcnMpLmxlbmd0aDt0Kyspe2xldCBpLHI9dGhpcy5zb3VyY2VCdWZmZXJzW09iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVycylbdF1dO3IucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWVuZFwiLHRoaXMub25VcGRhdGVFbmQpLHIudXBkYXRpbmc/aT1uZXcgUHJvbWlzZShlPT57Y29uc3QgdD1mdW5jdGlvbigpe2xldCBpPTM7Y29uc3QgYT0oKT0+e3IudXBkYXRpbmc/aT4wPyhzZXRUaW1lb3V0KGEsMjAwKSxpLS0pOmUoKToocy5jbGVhckJ1ZmZlcihyKSxlKCkpfTtzZXRUaW1lb3V0KGEsMjAwKSxyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVlbmRcIix0KX07ci5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZW5kXCIsdCl9KToocy5jbGVhckJ1ZmZlcihyKSxpPVByb21pc2UucmVzb2x2ZSgpKSxlLnB1c2goaSl9cmV0dXJuIFByb21pc2UuYWxsKGUpfWRlc3Ryb3koKXtyZXR1cm4gdGhpcy5yZW1vdmVCdWZmZXJzKCkudGhlbigoKT0+e2ZvcihsZXQgZT0wO2U8T2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXJzKS5sZW5ndGg7ZSsrKXtsZXQgdD10aGlzLnNvdXJjZUJ1ZmZlcnNbT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXJzKVtlXV07dGhpcy5tZWRpYVNvdXJjZS5yZW1vdmVTb3VyY2VCdWZmZXIodCksZGVsZXRlIHRoaXMuc291cmNlQnVmZmVyc1tPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcnMpW2VdXX10aGlzLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwidGltZXVwZGF0ZVwiLHRoaXMub25UaW1lVXBkYXRlKSx0aGlzLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwid2FpdGluZ1wiLHRoaXMub25XYWl0aW5nKSx0aGlzLm1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzb3VyY2VvcGVuXCIsdGhpcy5vblNvdXJjZU9wZW4pLHRoaXMuZW5kT2ZTdHJlYW0oKSx3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLnVybCksdGhpcy51cmw9bnVsbCx0aGlzLmNvbmZpZ3M9e30sdGhpcy5jb250YWluZXI9bnVsbCx0aGlzLm1lZGlhU291cmNlPW51bGwsdGhpcy5zb3VyY2VCdWZmZXJzPXt9LHRoaXMucHJlbG9hZFRpbWU9MX0pfXN0YXRpYyBjbGVhckJ1ZmZlcihlKXtjb25zdCB0PWUuYnVmZmVyZWQ7bGV0IGk9LjE7Zm9yKGxldCBlPTAscz10Lmxlbmd0aDtlPHM7ZSsrKWk9dC5lbmQoZSk7dHJ5e2UucmVtb3ZlKDAsaSl9Y2F0Y2goZSl7fX19dC5kZWZhdWx0PXN9LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjbGFzcyBze2NvbnN0cnVjdG9yKGUpe2lmKCEoZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSl0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIGlzIGludmFsaWRcIik7dGhpcy5idWZmZXI9ZSx0aGlzLmRhdGF2aWV3PW5ldyBEYXRhVmlldyhlKSx0aGlzLmRhdGF2aWV3LnBvc2l0aW9uPTB9Z2V0IGxlbmd0aCgpe3JldHVybiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RofXNldCBwb3NpdGlvbihlKXt0aGlzLmRhdGF2aWV3LnBvc2l0aW9uPWV9Z2V0IHBvc2l0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YXZpZXcucG9zaXRpb259YmFjayhlKXt0aGlzLnBvc2l0aW9uLT1lfXNraXAoZSl7bGV0IHQ9TWF0aC5mbG9vcihlLzQpLGk9ZSU0O2ZvcihsZXQgZT0wO2U8dDtlKyspcy5yZWFkQnl0ZSh0aGlzLmRhdGF2aWV3LDQpO2k+MCYmcy5yZWFkQnl0ZSh0aGlzLmRhdGF2aWV3LGkpfXN0YXRpYyByZWFkQnl0ZShlLHQsaSl7bGV0IHM7c3dpdGNoKHQpe2Nhc2UgMTpzPWk/ZS5nZXRJbnQ4KGUucG9zaXRpb24pOmUuZ2V0VWludDgoZS5wb3NpdGlvbik7YnJlYWs7Y2FzZSAyOnM9aT9lLmdldEludDE2KGUucG9zaXRpb24pOmUuZ2V0VWludDE2KGUucG9zaXRpb24pO2JyZWFrO2Nhc2UgMzppZihpKXRocm93IG5ldyBFcnJvcihcIm5vdCBzdXBwb3J0ZWQgZm9yIHJlYWRCeXRlIDNcIik7cz1lLmdldFVpbnQ4KGUucG9zaXRpb24pPDwxNixzfD1lLmdldFVpbnQ4KGUucG9zaXRpb24rMSk8PDgsc3w9ZS5nZXRVaW50OChlLnBvc2l0aW9uKzIpO2JyZWFrO2Nhc2UgNDpzPWk/ZS5nZXRJbnQzMihlLnBvc2l0aW9uKTplLmdldFVpbnQzMihlLnBvc2l0aW9uKTticmVhaztjYXNlIDg6aWYoaSl0aHJvdyBuZXcgRXJyb3IoXCJub3Qgc3VwcG9ydGVkIGZvciByZWFkQm9keSA4XCIpO3M9ZS5nZXRVaW50MzIoZS5wb3NpdGlvbik8PDMyLHN8PWUuZ2V0VWludDMyKGUucG9zaXRpb24rNCk7YnJlYWs7ZGVmYXVsdDpzPVwiXCJ9cmV0dXJuIGUucG9zaXRpb24rPXQsc31yZWFkVWludDgoKXtyZXR1cm4gcy5yZWFkQnl0ZSh0aGlzLmRhdGF2aWV3LDEpfXJlYWRVaW50MTYoKXtyZXR1cm4gcy5yZWFkQnl0ZSh0aGlzLmRhdGF2aWV3LDIpfXJlYWRVaW50MjQoKXtyZXR1cm4gcy5yZWFkQnl0ZSh0aGlzLmRhdGF2aWV3LDMpfXJlYWRVaW50MzIoKXtyZXR1cm4gcy5yZWFkQnl0ZSh0aGlzLmRhdGF2aWV3LDQpfXJlYWRVaW50NjQoKXtyZXR1cm4gcy5yZWFkQnl0ZSh0aGlzLmRhdGF2aWV3LDgpfXJlYWRJbnQ4KCl7cmV0dXJuIHMucmVhZEJ5dGUodGhpcy5kYXRhdmlldywxLCEwKX1yZWFkSW50MTYoKXtyZXR1cm4gcy5yZWFkQnl0ZSh0aGlzLmRhdGF2aWV3LDIsITApfXJlYWRJbnQzMigpe3JldHVybiBzLnJlYWRCeXRlKHRoaXMuZGF0YXZpZXcsNCwhMCl9d3JpdGVVaW50MzIoZSl7cmV0dXJuIG5ldyBVaW50OEFycmF5KFtlPj4+MjQmMjU1LGU+Pj4xNiYyNTUsZT4+PjgmMjU1LDI1NSZlXSl9fXQuZGVmYXVsdD1zfSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHMscj1pKDI1KSxhPShzPXIpJiZzLl9fZXNNb2R1bGU/czp7ZGVmYXVsdDpzfTt0LmRlZmF1bHQ9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5idWZmZXI9ZXx8bmV3IFVpbnQ4QXJyYXkoMCl9d3JpdGUoLi4uZSl7ZS5mb3JFYWNoKGU9Pnt0aGlzLmJ1ZmZlcj0oMCxhLmRlZmF1bHQpKFVpbnQ4QXJyYXksdGhpcy5idWZmZXIsZSl9KX1zdGF0aWMgd3JpdGVVaW50MzIoZSl7cmV0dXJuIG5ldyBVaW50OEFycmF5KFtlPj4yNCxlPj4xNiYyNTUsZT4+OCYyNTUsMjU1JmVdKX1zdGF0aWMgcmVhZEFzSW50KGUpe2xldCB0PVwiXCI7cmV0dXJuIGUuZm9yRWFjaChlPT57dCs9ZnVuY3Rpb24oZSl7cmV0dXJuIGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsXCIwXCIpfShlKX0pLHBhcnNlSW50KHQsMTYpfX19LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjt2YXIgcyxyPWkoMjYpLGE9KHM9cikmJnMuX19lc01vZHVsZT9zOntkZWZhdWx0OnN9O2UuZXhwb3J0cz1hLmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAsaT1hcmd1bWVudHMubGVuZ3RoLHM9QXJyYXkoaT4xP2ktMTowKSxyPTE7cjxpO3IrKylzW3ItMV09YXJndW1lbnRzW3JdO3ZhciBhPSEwLG49ITEsbz12b2lkIDA7dHJ5e2Zvcih2YXIgZCxsPXNbU3ltYm9sLml0ZXJhdG9yXSgpOyEoYT0oZD1sLm5leHQoKSkuZG9uZSk7YT0hMCl7dmFyIGg9ZC52YWx1ZTt0Kz1oLmxlbmd0aH19Y2F0Y2goZSl7bj0hMCxvPWV9ZmluYWxseXt0cnl7IWEmJmwucmV0dXJuJiZsLnJldHVybigpfWZpbmFsbHl7aWYobil0aHJvdyBvfX12YXIgdT1uZXcgZSh0KSxjPTAsZj0hMCxwPSExLG09dm9pZCAwO3RyeXtmb3IodmFyIGcsXz1zW1N5bWJvbC5pdGVyYXRvcl0oKTshKGY9KGc9Xy5uZXh0KCkpLmRvbmUpO2Y9ITApe3ZhciB5PWcudmFsdWU7dS5zZXQoeSxjKSxjKz15Lmxlbmd0aH19Y2F0Y2goZSl7cD0hMCxtPWV9ZmluYWxseXt0cnl7IWYmJl8ucmV0dXJuJiZfLnJldHVybigpfWZpbmFsbHl7aWYocCl0aHJvdyBtfX1yZXR1cm4gdX19LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcyxyPWkoNCk7Y29uc3QgYT0oKHM9cikmJnMuX19lc01vZHVsZT9zOntkZWZhdWx0OnN9KS5kZWZhdWx0LkNSWVRPX0VWRU5UUzt0LmRlZmF1bHQ9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5pbnB1dEJ1ZmZlcj1lLmlucHV0YnVmZmVyLHRoaXMub3V0cHV0QnVmZmVyPWUub3V0cHV0YnVmZmVyLHRoaXMua2V5PWUua2V5LHRoaXMuaXY9ZS5pdix0aGlzLm1ldGhvZD1lLm1ldGhvZCx0aGlzLmNyeXB0bz13aW5kb3cuY3J5cHRvfHx3aW5kb3cubXNDcnlwdG99aW5pdCgpe3RoaXMub24oYS5TVEFSVF9ERUNSWVBULHRoaXMuZGVjcmlwdC5iaW5kKHRoaXMpKX1kZWNyaXB0KCl7aWYodGhpcy5hZXNrZXkpdGhpcy5kZWNyaXB0RGF0YSgpO2Vsc2V7dGhpcy5jcnlwdG8uc3VidGxlLmltcG9ydEtleShcInJhd1wiLHRoaXMua2V5LmJ1ZmZlcix7bmFtZTpcIkFFUy1DQkNcIn0sITEsW1wiZW5jcnlwdFwiLFwiZGVjcnlwdFwiXSkudGhlbihlPT57dGhpcy5hZXNrZXk9ZSx0aGlzLmRlY3JpcHREYXRhKCl9KX19ZGVjcmlwdERhdGEoKXtsZXQgZT10aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKHRoaXMuaW5wdXRCdWZmZXIpLHQ9dGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZSh0aGlzLm91dHB1dEJ1ZmZlciksaT1lLnNoaWZ0KCk7aSYmdGhpcy5jcnlwdG8uc3VidGxlLmRlY3J5cHQoe25hbWU6XCJBRVMtQ0JDXCIsaXY6dGhpcy5pdi5idWZmZXJ9LHRoaXMuYWVza2V5LGkpLnRoZW4oZT0+e3QucHVzaChuZXcgVWludDhBcnJheShlKSksdGhpcy5lbWl0KGEuREVDUllQVEVEKSx0aGlzLmRlY3JpcHREYXRhKGkpfSl9fX0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPWgoaSgyOSkpLHI9aChpKDM2KSksYT1pKDM5KSxuPWkoOSksbz1pKDApLGQ9aSg3KSxsPWgoaSgyKSk7ZnVuY3Rpb24gaChlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19Y29uc3QgdT1vLkVWRU5UUy5SRU1VWF9FVkVOVFMsYz1vLkVWRU5UUy5ERU1VWF9FVkVOVFMsZj1vLkVWRU5UUy5MT0FERVJfRVZFTlRTLHA9XCJGTFZDb250cm9sbGVyXCI7Y2xhc3MgbXt3YXJuKCl7fX1jb25zdCBnPVwiRkxWX0VSUk9SXCI7Y2xhc3MgX3tjb25zdHJ1Y3RvcihlKXt0aGlzLlRBRz1wLHRoaXMuX3BsYXllcj1lLHRoaXMuc3RhdGU9e2luaXRTZWdtZW50QXJyaXZlZDohMSxyYW5nZTp7c3RhcnQ6MCxlbmQ6XCJcIn0scmFuZ2VTdXBwb3J0OiEwfX1zdGF0aWMgZmluZEZpbGVQb3NpdGlvbihlLHQpe2ZvcihsZXQgaT0wLHM9dC50aW1lcy5sZW5ndGg7aTxzO2krKyl7Y29uc3Qgcj10LnRpbWVzW2ldLGE9aSsxPHM/dC50aW1lc1tpKzFdOk51bWJlci5NQVhfU0FGRV9JTlRFR0VSO2lmKHI8PWUmJmU8PWEpcmV0dXJuIHQuZmlsZXBvc2l0aW9uc1tpXX1yZXR1cm5cIlwifWluaXQoKXt0aGlzLl9jb250ZXh0LnJlZ2lzdHJ5KFwiRkVUQ0hfTE9BREVSXCIsYS5GZXRjaExvYWRlciksdGhpcy5fY29udGV4dC5yZWdpc3RyeShcIkxPQURFUl9CVUZGRVJcIixuLlhnQnVmZmVyKSx0aGlzLl9jb250ZXh0LnJlZ2lzdHJ5KFwiRkxWX0RFTVVYRVJcIixzLmRlZmF1bHQpLHRoaXMuX2NvbnRleHQucmVnaXN0cnkoXCJUUkFDS1NcIixuLlRyYWNrcyksdGhpcy5fY29udGV4dC5yZWdpc3RyeShcIk1QNF9SRU1VWEVSXCIsci5kZWZhdWx0Lk1wNFJlbXV4ZXIpLHRoaXMuX2NvbnRleHQucmVnaXN0cnkoXCJQUkVfU09VUkNFX0JVRkZFUlwiLG4uUHJlU291cmNlKSx0aGlzLl9jb250ZXh0LnJlZ2lzdHJ5KFwiQ09NUEFUSUJJTElUWVwiLGQuQ29tcGF0aWJpbGl0eSksdGhpcy5fY29udGV4dC5yZWdpc3RyeShcIkxPR0dFUlwiLG0pLHRoaXMubXNlPXRoaXMuX2NvbnRleHQucmVnaXN0cnkoXCJNU0VcIixvLk1zZSkoe2NvbnRhaW5lcjp0aGlzLl9wbGF5ZXIudmlkZW99KSx0aGlzLmluaXRMaXN0ZW5lcnMoKSxzZXRUaW1lb3V0KCgpPT57dGhpcy5sb2FkTWV0YSgpfSwwKX1pbml0TGlzdGVuZXJzKCl7dGhpcy5vbihmLkxPQURFUl9EQVRBTE9BREVELHRoaXMuX2hhbmRsZUxvYWRlckRhdGFMb2FkZWQuYmluZCh0aGlzKSksdGhpcy5vbihmLkxPQURFUl9FUlJPUix0aGlzLl9oYW5kbGVOZXR3b3JrRXJyb3IuYmluZCh0aGlzKSksdGhpcy5vbihjLk1FRElBX0lORk8sdGhpcy5faGFuZGxlTWVkaWFJbmZvLmJpbmQodGhpcykpLHRoaXMub24oYy5NRVRBREFUQV9QQVJTRUQsdGhpcy5faGFuZGxlTWV0YWRhdGFQYXJzZWQuYmluZCh0aGlzKSksdGhpcy5vbihjLkRFTVVYX0NPTVBMRVRFLHRoaXMuX2hhbmRsZURlbXV4Q29tcGxldGUuYmluZCh0aGlzKSksdGhpcy5vbihjLkRFTVVYX0VSUk9SLHRoaXMuX2hhbmRsZURlbXV4RXJyb3IuYmluZCh0aGlzKSksdGhpcy5vbih1LklOSVRfU0VHTUVOVCx0aGlzLl9oYW5kbGVBcHBlbmRJbml0U2VnbWVudC5iaW5kKHRoaXMpKSx0aGlzLm9uKHUuTUVESUFfU0VHTUVOVCx0aGlzLl9oYW5kbGVNZWRpYVNlZ21lbnQuYmluZCh0aGlzKSl9X2hhbmRsZU1lZGlhSW5mbygpe3RoaXMuX2NvbnRleHQub25NZXRhRGF0YXx8dGhpcy5lbWl0KGMuREVNVVhfRVJST1IsbmV3IEVycm9yKFwiZmFpbGVkIHRvIGdldCBtZWRpYWluZm9cIikpO2NvbnN0IGU9dGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZShcIkxPQURFUl9CVUZGRVJcIiksdD10aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKFwiRkVUQ0hfTE9BREVSXCIpO3RoaXMuaXNTZWVrYWJsZSYmKHQuY2FuY2VsKCksdGhpcy5zdGF0ZS5yYW5nZT17c3RhcnQ6MCxlbmQ6ZS5oaXN0b3J5TGVuLTF9LHNldFRpbWVvdXQoKCk9Pnt0aGlzLmxvYWROZXh0KDApfSkpfV9oYW5kbGVMb2FkZXJEYXRhTG9hZGVkKCl7dGhpcy5lbWl0VG8oXCJGTFZfREVNVVhFUlwiLGMuREVNVVhfU1RBUlQpfV9oYW5kbGVNZXRhZGF0YVBhcnNlZChlKXt0aGlzLmVtaXQodS5SRU1VWF9NRVRBREFUQSxlKX1faGFuZGxlRGVtdXhDb21wbGV0ZSgpe3RoaXMuZW1pdCh1LlJFTVVYX01FRElBKX1faGFuZGxlQXBwZW5kSW5pdFNlZ21lbnQoKXt0aGlzLnN0YXRlLmluaXRTZWdtZW50QXJyaXZlZD0hMCx0aGlzLm1zZS5hZGRTb3VyY2VCdWZmZXJzKCl9X2hhbmRsZU1lZGlhU2VnbWVudCgpe3RoaXMubXNlLmFkZFNvdXJjZUJ1ZmZlcnMoKSx0aGlzLm1zZS5kb0FwcGVuZCgpfV9oYW5kbGVOZXR3b3JrRXJyb3IoZSx0KXt0aGlzLl9wbGF5ZXIuZW1pdChcImVycm9yXCIsbmV3IGwuZGVmYXVsdC5FcnJvcnMoXCJuZXR3b3JrXCIsdGhpcy5fcGxheWVyLmNvbmZpZy51cmwpKSx0aGlzLl9vbkVycm9yKGYuTE9BREVSX0VSUk9SLGUsdCwhMCl9X2hhbmRsZURlbXV4RXJyb3IoZSx0LGkpe3ZvaWQgMD09PWkmJihpPSExKSx0aGlzLl9wbGF5ZXIuZW1pdChcImVycm9yXCIsbmV3IGwuZGVmYXVsdC5FcnJvcnMoXCJwYXJzZVwiLHRoaXMuX3BsYXllci5jb25maWcudXJsKSksdGhpcy5fb25FcnJvcihmLkxPQURFUl9FUlJPUixlLHQsaSl9X29uRXJyb3IoZSx0LGkscyl7bGV0IHI9e2Vycm9yVHlwZTplLGVycm9yRGV0YWlsczpgWyR7dH1dOiAke2kubWVzc2FnZX1gLGVycm9yRmF0YWw6c3x8ITF9O3RoaXMuX3BsYXllci5lbWl0KGcscil9c2VlayhlKXtpZighdGhpcy5fY29udGV4dC5vbk1ldGFEYXRhKXJldHVybiB2b2lkIHRoaXMubG9hZE1ldGEoKTtpZighdGhpcy5pc1NlZWthYmxlKXJldHVybjt0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKFwiTE9BREVSX0JVRkZFUlwiKS5jbGVhcigpO2NvbnN0e3ByZWxvYWRUaW1lOnQ9MTV9PXRoaXMuX3BsYXllci5jb25maWcsaT10aGlzLmdldFNlZWtSYW5nZShlLHQpO3RoaXMuc3RhdGUucmFuZ2U9aSx0aGlzLmNvbXBhdCYmdGhpcy5jb21wYXQucmVzZXQoKSx0aGlzLmxvYWREYXRhKCl9bG9hZE5leHQoZSl7dGhpcy5fY29udGV4dC5vbk1ldGFEYXRhJiYodGhpcy5sb2FkZXIubG9hZGluZ3x8dGhpcy5nZXROZXh0UmFuZ2UoZSkmJnRoaXMubG9hZERhdGEoKSl9bG9hZERhdGEoKXtjb25zdHtzdGFydDplLGVuZDp0fT10aGlzLnN0YXRlLnJhbmdlO3RoaXMuZW1pdChmLkxBREVSX1NUQVJULHRoaXMuX3BsYXllci5jb25maWcudXJsLHtoZWFkZXJzOnttZXRob2Q6XCJnZXRcIixSYW5nZTpgYnl0ZXM9JHtlfS0ke3R9YH19KX1sb2FkTWV0YSgpe3RoaXMubG9hZGVyLmxvYWQodGhpcy5fcGxheWVyLmNvbmZpZy51cmwse2hlYWRlcnM6e1JhbmdlOlwiYnl0ZXM9MC1cIn19KS5jYXRjaCgoKT0+e3RoaXMuc3RhdGUucmFuZ2VTdXBwb3J0PSExLHRoaXMubG9hZEZhbGxiYWNrKCl9KX1sb2FkRmFsbGJhY2soKXt0aGlzLmxvYWRlci5sb2FkKHRoaXMuX3BsYXllci5jb25maWcudXJsKS5jYXRjaCgoKT0+e3RoaXMuX3BsYXllci5lbWl0KFwiZXJyb3JcIixuZXcgbC5kZWZhdWx0LkVycm9ycyhcIm5ldHdvcmtcIix0aGlzLl9wbGF5ZXIuY29uZmlnLnVybCkpfSl9Z2V0U2Vla1JhbmdlKGUsdCl7Y29uc3R7a2V5ZnJhbWVzOml9PXRoaXMuX2NvbnRleHQub25NZXRhRGF0YSxzPXRoaXMuX2NvbnRleHQubWVkaWFJbmZvLmR1cmF0aW9uLHI9ZSxhPWUrdCxuPV8uZmluZEZpbGVQb3NpdGlvbihyLGkpO3JldHVybiBhPj1zfHxyPj1zP3tzdGFydDpuLGVuZDpcIlwifTp7c3RhcnQ6bixlbmQ6Xy5maW5kRmlsZVBvc2l0aW9uKGEsaSl9fWdldE5leHRSYW5nZShlKXtpZihcIlwiPT09dGhpcy5zdGF0ZS5yYW5nZS5lbmQpcmV0dXJuO2NvbnN0e2VuZDp0fT10aGlzLmdldFNlZWtSYW5nZShlLHRoaXMuY29uZmlnLnByZWxvYWRUaW1lfHwxNSk7cmV0dXJuIHQ8PXRoaXMuc3RhdGUucmFuZ2UuZW5kJiZcIlwiIT09dD92b2lkIDA6KHRoaXMuc3RhdGUucmFuZ2U9e3N0YXJ0OnRoaXMuc3RhdGUucmFuZ2UuZW5kKzEsZW5kOnR9LCEwKX1kZXN0cm95KCl7dGhpcy5fcGxheWVyPW51bGwsdGhpcy5tc2U9bnVsbCx0aGlzLnN0YXRlPXtpbml0U2VnbWVudEFycml2ZWQ6ITEscmFuZ2U6e3N0YXJ0OjAsZW5kOlwiXCJ9LHJhbmdlU3VwcG9ydDohMH19Z2V0IGlzU2Vla2FibGUoKXtyZXR1cm4hIXRoaXMuc3RhdGUucmFuZ2VTdXBwb3J0JiYoIXRoaXMuX2NvbnRleHR8fCF0aGlzLl9jb250ZXh0Lm1lZGlhSW5mby5pc0NvbXBsZXRlKCl8fG51bGwhPT10aGlzLl9jb250ZXh0Lm1lZGlhSW5mby5rZXlmcmFtZXMmJnZvaWQgMCE9PXRoaXMuX2NvbnRleHQubWVkaWFJbmZvLmtleWZyYW1lcyl9Z2V0IGNvbmZpZygpe3JldHVybiB0aGlzLl9wbGF5ZXIuY29uZmlnfWdldCBsb2FkZXIoKXtyZXR1cm4gdGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZShcIkZFVENIX0xPQURFUlwiKX1nZXQgY29tcGF0KCl7cmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoXCJDT01QQVRJQklMSVRZXCIpfX10LmRlZmF1bHQ9X30sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzLHI9aSgwKSxhPWkoNyksbj1pKDkpLG89aSgzNSksZD0ocz1vKSYmcy5fX2VzTW9kdWxlP3M6e2RlZmF1bHQ6c307Y29uc3QgbD1yLkVWRU5UUy5ERU1VWF9FVkVOVFM7Y2xhc3MgaHtjb25zdHJ1Y3Rvcigpe3RoaXMuX2ZpcnN0RnJhZ21lbnRMb2FkZWQ9ITEsdGhpcy5fdHJhY2tOdW09MCx0aGlzLl9oYXNTY3JpcHQ9ITF9aW5pdCgpe3RoaXMub24obC5ERU1VWF9TVEFSVCx0aGlzLmRvUGFyc2VGbHYuYmluZCh0aGlzKSl9c3RhdGljIGlzRmx2RmlsZShlKXtyZXR1cm4hKDcwIT09ZVswXXx8NzYhPT1lWzFdfHw4NiE9PWVbMl18fDEhPT1lWzNdKX1zdGF0aWMgZ2V0UGxheVR5cGUoZSl7Y29uc3QgdD17aGFzVmlkZW86ITEsaGFzQXVkaW86ITF9O3JldHVybiEwJmUmJih0Lmhhc1ZpZGVvPSEwKSwhMCZlJiYodC5oYXNBdWRpbz0hMCksdH1kb1BhcnNlRmx2KCl7aWYodGhpcy5fZmlyc3RGcmFnbWVudExvYWRlZCl7aWYodGhpcy5sb2FkZXJCdWZmZXIubGVuZ3RoPDExKXJldHVybjtsZXQgZSx0PTFlNTtkb3tlPXRoaXMuX3BhcnNlRmx2VGFnKCl9d2hpbGUoZSYmdC0tID4wKTt0aGlzLmVtaXQobC5ERU1VWF9DT01QTEVURSl9ZWxzZXtpZih0aGlzLmxvYWRlckJ1ZmZlci5sZW5ndGg8MTMpcmV0dXJuO2NvbnN0IGU9dGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoMTMpO3RoaXMucGFyc2VGbHZIZWFkZXIoZSksdGhpcy5kb1BhcnNlRmx2KCl9fXBhcnNlRmx2SGVhZGVyKGUpe2lmKGguaXNGbHZGaWxlKGUpKXt0aGlzLl9maXJzdEZyYWdtZW50TG9hZGVkPSEwO2NvbnN0IHQ9aC5nZXRQbGF5VHlwZShlWzRdKTt0Lmhhc1ZpZGVvJiZ0aGlzLmluaXRWaWRlb1RyYWNrKCksdC5oYXNBdWRpbyYmdGhpcy5pbml0QXVkaW9UcmFjaygpfWVsc2UgdGhpcy5lbWl0KGwuREVNVVhfRVJST1IsbmV3IEVycm9yKFwiaW52YWxpZCBmbHYgZmlsZVwiKSksdGhpcy5kb1BhcnNlRmx2KCk7dGhpcy5kb1BhcnNlRmx2KCl9aW5pdFZpZGVvVHJhY2soKXt0aGlzLl90cmFja051bSsrO2xldCBlPW5ldyBuLlZpZGVvVHJhY2s7ZS5tZXRhPW5ldyByLlZpZGVvVHJhY2tNZXRhLGUuaWQ9ZS5tZXRhLmlkPXRoaXMuX3RyYWNrTnVtLHRoaXMudHJhY2tzLnZpZGVvVHJhY2s9ZX1pbml0QXVkaW9UcmFjaygpe3RoaXMuX3RyYWNrTnVtKys7bGV0IGU9bmV3IG4uQXVkaW9UcmFjaztlLm1ldGE9bmV3IHIuQXVkaW9UcmFja01ldGEsZS5pZD1lLm1ldGEuaWQ9dGhpcy5fdHJhY2tOdW0sdGhpcy50cmFja3MuYXVkaW9UcmFjaz1lfV9wYXJzZUZsdlRhZygpe2lmKHRoaXMubG9hZGVyQnVmZmVyLmxlbmd0aDwxMSlyZXR1cm4gbnVsbDtsZXQgZT10aGlzLl9wYXJzZUZsdlRhZ0hlYWRlcigpO3JldHVybiBlJiZ0aGlzLl9wcm9jZXNzQ2h1bmsoZSksZX1fcGFyc2VGbHZUYWdIZWFkZXIoKXtsZXQgZT0wLHQ9e30saT10aGlzLmxvYWRlckJ1ZmZlci50b0ludChlLDEpO2lmKGUrPTEsdC5maWx0ZXJlZD0oMzImaSk+Pj41LHQudGFnVHlwZT0zMSZpLHQuZGF0YXNpemU9dGhpcy5sb2FkZXJCdWZmZXIudG9JbnQoZSwzKSxlKz0zLDghPT10LnRhZ1R5cGUmJjkhPT10LnRhZ1R5cGUmJjExIT09dC50YWdUeXBlJiYxOCE9PXQudGFnVHlwZXx8MCE9PXRoaXMubG9hZGVyQnVmZmVyLnRvSW50KDgsMykpcmV0dXJuIHRoaXMubG9hZGVyQnVmZmVyJiZ0aGlzLmxvYWRlckJ1ZmZlci5sZW5ndGg+MCYmdGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoMSksdGhpcy5lbWl0KGwuREVNVVhfRVJST1IsdGhpcy5UQUcsbmV3IEVycm9yKFwidGFnVHlwZSBcIit0LnRhZ1R5cGUpLCExKSxudWxsO2lmKHRoaXMubG9hZGVyQnVmZmVyLmxlbmd0aDx0LmRhdGFzaXplKzE1KXJldHVybiBudWxsO3RoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDQpO2xldCBzPXRoaXMubG9hZGVyQnVmZmVyLnRvSW50KDAsMyk7dGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoMyk7bGV0IHI9dGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoMSlbMF07cmV0dXJuIHI+MCYmKHMrPTE2Nzc3MjE2KnIpLHQuZHRzPXMsdGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoMyksdH1fcHJvY2Vzc0NodW5rKGUpe3N3aXRjaChlLnRhZ1R5cGUpe2Nhc2UgMTg6dGhpcy5fcGFyc2VTY3JpcHREYXRhKGUpO2JyZWFrO2Nhc2UgODp0aGlzLl9wYXJzZUFBQ0RhdGEoZSk7YnJlYWs7Y2FzZSA5OnRoaXMuX3BhcnNlSGV2Y0RhdGEoZSk7YnJlYWs7Y2FzZSAxMTp0aGlzLmxvYWRlckJ1ZmZlci5zaGlmdCgzKTticmVhaztkZWZhdWx0OnRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDEpfX1fcGFyc2VTY3JpcHREYXRhKGUpe2xldCB0PXRoaXMudHJhY2tzLmF1ZGlvVHJhY2ssaT10aGlzLnRyYWNrcy52aWRlb1RyYWNrLHM9dGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoZS5kYXRhc2l6ZSk7Y29uc3Qgcj0obmV3IGQuZGVmYXVsdCkucmVzb2x2ZShzLHMubGVuZ3RoKSxhPXRoaXMuX2NvbnRleHQub25NZXRhRGF0YT1yP3Iub25NZXRhRGF0YTp2b2lkIDA7aWYodGhpcy5fY29udGV4dC5tZWRpYUluZm8uZHVyYXRpb249YS5kdXJhdGlvbix0aGlzLl9jb250ZXh0Lm1lZGlhSW5mby5oYXNWaWRlbz1hLmhhc1ZpZGVvLHRoaXMuX2NvbnRleHQubWVkaWFJbmZvLmhzYUF1ZGlvPWEuaGFzQXVkaW8sdGhpcy5fZGF0YXNpemVWYWxpZGF0b3IoZS5kYXRhc2l6ZSkmJih0aGlzLmVtaXQobC5NRURJQV9JTkZPKSx0aGlzLl9oYXNTY3JpcHQ9ITApLHQmJiF0Lmhhc1NwZWNpZmljQ29uZmlnKXtsZXQgZT10Lm1ldGE7c3dpdGNoKGEuYXVkaW9zYW1wbGVyYXRlJiYoZS5zYW1wbGVSYXRlPWEuYXVkaW9zYW1wbGVyYXRlKSxhLmF1ZGlvY2hhbm5lbHMmJihlLmNoYW5uZWxDb3VudD1hLmF1ZGlvY2hhbm5lbHMpLGEuYXVkaW9zYW1wbGVyYXRlKXtjYXNlIDQ0MTAwOmUuc2FtcGxlUmF0ZUluZGV4PTQ7YnJlYWs7Y2FzZSAyMjA1MDplLnNhbXBsZVJhdGVJbmRleD03O2JyZWFrO2Nhc2UgMTEwMjU6ZS5zYW1wbGVSYXRlSW5kZXg9MTB9fWlmKGkmJiFpLmhhc1NwZWNpZmljQ29uZmlnKXtsZXQgZT1pLm1ldGE7aWYoXCJudW1iZXJcIj09dHlwZW9mIGEuZnJhbWVyYXRlKXtsZXQgdD1NYXRoLmZsb29yKDFlMyphLmZyYW1lcmF0ZSk7aWYodD4wKXtsZXQgaT10LzFlMztlLmZyYW1lUmF0ZXx8KGUuZnJhbWVSYXRlPXt9KSxlLmZyYW1lUmF0ZS5maXhlZD0hMCxlLmZyYW1lUmF0ZS5mcHM9aSxlLmZyYW1lUmF0ZS5mcHNfbnVtPXQsZS5mcmFtZVJhdGUuZnBzX2Rlbj0xZTN9fX19X2FhY1NlcXVlbmNlSGVhZGVyUGFyc2VyKGUpe2xldCB0PXtoYXNTcGVjaWZpY0NvbmZpZzohMH07dC5vYmplY3RUeXBlPWVbMV0+Pj4zLHQuc2FtcGxlUmF0ZUluZGV4PSg3JmVbMV0pPDwxfGVbMl0+Pj43LHQuYXVkaW9zYW1wbGVyYXRlPXRoaXMuX3N3aXRjaEF1ZGlvU2FtcGxlUmF0ZSh0LnNhbXBsZVJhdGVJbmRleCksdC5jaGFubmVsQ291bnQ9KDEyMCZlWzJdKT4+PjMsdC5mcmFtZUxlbmd0aD0oNCZlWzJdKT4+PjIsdC5kZXBlbmRzT25Db3JlQ29kZXI9KDImZVsyXSk+Pj4xLHQuZXh0ZW5zaW9uRmxhZ0luZGV4PTEmZVsyXSx0LmNvZGVjPWBtcDRhLjQwLiR7dC5vYmplY3RUeXBlfWA7bGV0IGkscyxyPXdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksYT10LnNhbXBsZVJhdGVJbmRleDtyZXR1cm4tMSE9PXIuaW5kZXhPZihcImZpcmVmb3hcIik/dC5zYW1wbGVSYXRlSW5kZXg+PTY/KHQub2JqZWN0VHlwZT01LHM9bmV3IEFycmF5KDQpLGk9YS0zKToodC5vYmplY3RUeXBlPTIscz1uZXcgQXJyYXkoMiksaT1hKTotMSE9PXIuaW5kZXhPZihcImFuZHJvaWRcIik/KHQub2JqZWN0VHlwZT0yLHM9bmV3IEFycmF5KDIpLGk9YSk6KHQub2JqZWN0VHlwZT01LGk9dC5zYW1wbGVSYXRlSW5kZXgscz1uZXcgQXJyYXkoNCksdC5zYW1wbGVSYXRlSW5kZXg+PTY/aT10LnNhbXBsZVJhdGVJbmRleC0zOjE9PT10LmNoYW5uZWxDb3VudCYmKHQub2JqZWN0VHlwZT0yLHM9bmV3IEFycmF5KDIpLGk9dC5zYW1wbGVSYXRlSW5kZXgpKSxzWzBdPXQub2JqZWN0VHlwZTw8MyxzWzBdfD0oMTUmdC5zYW1wbGVSYXRlSW5kZXgpPj4+MSxzWzFdPSgxNSZ0LnNhbXBsZVJhdGVJbmRleCk8PDcsc1sxXXw9KDE1JnQuY2hhbm5lbENvdW50KTw8Myw1PT09dC5vYmplY3RUeXBlJiYoc1sxXXw9KDE1JmkpPj4+MSxzWzJdPSgxJmkpPDw3LHNbMl18PTgsc1szXT0wKSx0LmNvbmZpZz1zLHR9X3BhcnNlQUFDRGF0YShlKXtsZXQgdD10aGlzLnRyYWNrcy5hdWRpb1RyYWNrO2lmKCF0KXJldHVybjtsZXQgaT10Lm1ldGE7aXx8KHQubWV0YT1uZXcgci5BdWRpb1RyYWNrTWV0YSxpPXQubWV0YSk7bGV0IHM9dGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoMSlbMF07ZS5kYXRhPXRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KGUuZGF0YXNpemUtMSk7bGV0IGE9KDI0MCZzKT4+PjQ7dC5mb3JtYXQ9YSwxMCE9PWEmJnRoaXMuZW1pdChsLkRFTVVYX0VSUk9SLG5ldyBFcnJvcihgaW52YWxpZCBhdWRpbyBmb3JtYXQ6ICR7YX1gKSksMTAhPT1hfHx0aGlzLl9oYXNBdWRpb1NlcXVlbmNlfHwoaS5zYW1wbGVSYXRlPXRoaXMuX3N3aXRjaEF1ZGlvU2FtcGxpbmdGcmVxdWVuY3kocyksaS5zYW1wbGVSYXRlSW5kZXg9KDEyJnMpPj4+MixpLmZyYW1lTGVudGg9KDImcyk+Pj4xLGkuY2hhbm5lbENvdW50PTEmcyxpLnJlZlNhbXBsZUR1cmF0aW9uPU1hdGguZmxvb3IoMTAyNC9pLmF1ZGlvU2FtcGxlUmF0ZSppLnRpbWVzY2FsZSkpO2xldCBuPWkuYXVkaW9TYW1wbGVSYXRlLG89aS5zYW1wbGVSYXRlSW5kZXgsZD1pLnJlZlNhbXBsZUR1cmF0aW9uO2RlbGV0ZSBlLnRhZ1R5cGU7bGV0IGg9dGhpcy5fZGF0YXNpemVWYWxpZGF0b3IoZS5kYXRhc2l6ZSk7aWYoMD09PWUuZGF0YVswXSl7bGV0IHQ9dGhpcy5fYWFjU2VxdWVuY2VIZWFkZXJQYXJzZXIoZS5kYXRhKTtuPXQuYXVkaW9zYW1wbGVyYXRlfHxpLmF1ZGlvU2FtcGxlUmF0ZSxvPXQuc2FtcGxlUmF0ZUluZGV4fHxpLnNhbXBsZVJhdGVJbmRleCxkPU1hdGguZmxvb3IoMTAyNC9uKmkudGltZXNjYWxlKSxpLmNoYW5uZWxDb3VudD10LmNoYW5uZWxDb3VudCxpLnNhbXBsZVJhdGU9bixpLnNhbXBsZVJhdGVJbmRleD1vLGkucmVmU2FtcGxlRHVyYXRpb249ZCxpLmR1cmF0aW9uPXRoaXMuX2NvbnRleHQubWVkaWFJbmZvLmR1cmF0aW9uKmkudGltZXNjYWxlLGkuY29uZmlnPXQuY29uZmlnO2NvbnN0IHM9dGhpcy5fY29udGV4dC5tZWRpYUluZm8uYXVkaW87cy5jb2RlYz10LmNvZGVjLHMuY2hhbm5lbENvdW50PXQuY2hhbm5lbENvdW50LHMuc2FtcGxlUmF0ZT1uLHMuc2FtcGxlUmF0ZUluZGV4PXQuYXVkaW9TYW1wbGVSYXRlSW5kZXgsdGhpcy5faGFzU2NyaXB0JiYhdGhpcy5faGFzQXVkaW9TZXF1ZW5jZT90aGlzLmVtaXQobC5NRVRBREFUQV9QQVJTRUQsXCJhdWRpb1wiKTp0aGlzLl9oYXNTY3JpcHQmJnRoaXMuX2hhc0F1ZGlvU2VxdWVuY2UmJnRoaXMuZW1pdChsLkFVRElPX01FVEFEQVRBX0NIQU5HRSksdGhpcy5faGFzQXVkaW9TZXF1ZW5jZT0hMCx0aGlzLl9tZXRhQ2hhbmdlPSEwfWVsc2UgdGhpcy5fbWV0YUNoYW5nZSYmKGUub3B0aW9ucz17bWV0YTp0Lm1ldGF9LHRoaXMuX21ldGFDaGFuZ2U9ITEpLGUuZGF0YT1lLmRhdGEuc2xpY2UoMSxlLmRhdGEubGVuZ3RoKSx0LnNhbXBsZXMucHVzaChlKTtofHx0aGlzLmVtaXQobC5ERU1VWF9FUlJPUix0aGlzLlRBRyxuZXcgRXJyb3IoXCJUQUcgbGVuZ3RoIGVycm9yIGF0IFwiK2UuZGF0YXNpemUpLCExKX1fcGFyc2VIZXZjRGF0YShlKXtsZXQgdD10aGlzLmxvYWRlckJ1ZmZlci5zaGlmdCgxKVswXTtlLmZyYW1lVHlwZT0oMjQwJnQpPj4+NCxlLmlzS2V5ZnJhbWU9MT09PWUuZnJhbWVUeXBlO2xldCBpPTE1JnQ7aWYodGhpcy50cmFja3MudmlkZW9UcmFjay5jb2RlY0lEPWksZS5hdmNQYWNrZXRUeXBlPXRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDEpWzBdLGUuY3RzPXRoaXMubG9hZGVyQnVmZmVyLnRvSW50KDAsMyksdGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoMyksMTI9PT1pKXtjb25zdCB0PXRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KGUuZGF0YXNpemUtNSk7aWYoZS5kYXRhPXQsMCE9PU51bWJlci5wYXJzZUludChlLmF2Y1BhY2tldFR5cGUpKXt0aGlzLl9kYXRhc2l6ZVZhbGlkYXRvcihlLmRhdGFzaXplKXx8dGhpcy5lbWl0KGwuREVNVVhfRVJST1IsdGhpcy5UQUcsbmV3IEVycm9yKGBpbnZhbGlkIHZpZGVvIHRhZyBkYXRhc2l6ZTogJHtlLmRhdGFzaXplfWApLCExKTtsZXQgdD17fSxpPTA7Zm9yKHQuY3RzPWUuY3RzLHQuZHRzPWUuZHRzO2UuZGF0YS5sZW5ndGg+aTspe2xldCBzPWUuZGF0YS5zbGljZShOdW1iZXIucGFyc2VJbnQoaSksNCtpKTt0LnNpemU9c1szXSx0LnNpemUrPTI1NipzWzJdLHQuc2l6ZSs9MjU2KnNbMV0qMjU2LHQuc2l6ZSs9MjU2KnNbMF0qMjU2KjI1NixpKz00LHQuZGF0YT1lLmRhdGEuc2xpY2UoTnVtYmVyLnBhcnNlSW50KGkpLHQuc2l6ZStpKSxpKz10LnNpemUsdGhpcy50cmFja3MudmlkZW9UcmFjay5zYW1wbGVzLnB1c2godCksdGhpcy5lbWl0KGwuTUVUQURBVEFfUEFSU0VELFwidmlkZW9cIil9fWVsc2UgMD09PU51bWJlci5wYXJzZUludChlLmF2Y1BhY2tldFR5cGUpJiYodGhpcy5fZGF0YXNpemVWYWxpZGF0b3IoZS5kYXRhc2l6ZSk/dGhpcy5lbWl0KGwuTUVUQURBVEFfUEFSU0VELFwidmlkZW9cIik6dGhpcy5lbWl0KGwuREVNVVhfRVJST1IsdGhpcy5UQUcsbmV3IEVycm9yKGBpbnZhbGlkIHZpZGVvIHRhZyBkYXRhc2l6ZTogJHtlLmRhdGFzaXplfWApLCExKSl9ZWxzZSBpZig3PT09aSl7bGV0IHQ9dGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoZS5kYXRhc2l6ZS01KTtpZigwPT09dFs0XSYmMD09PXRbNV0mJjA9PT10WzZdJiYxPT09dFs3XSl7bGV0IGU9MDtmb3IobGV0IGk9MDtpPDQ7aSsrKWU9MjU2KmUrdFtpXTtlLT00LCh0PXQuc2xpY2UoNCx0Lmxlbmd0aCkpWzNdPWUlMjU2LGU9KGUtdFszXSkvMjU2LHRbMl09ZSUyNTYsZT0oZS10WzJdKS8yNTYsdFsxXT1lJTI1Nix0WzBdPShlLXRbMV0pLzI1Nn1pZihlLmRhdGE9dCwwPT09ZS5hdmNQYWNrZXRUeXBlKXt0aGlzLl9hdmNTZXF1ZW5jZUhlYWRlclBhcnNlcihlLmRhdGEpLHRoaXMuX2RhdGFzaXplVmFsaWRhdG9yKGUuZGF0YXNpemUpJiYodGhpcy5faGFzU2NyaXB0JiYhdGhpcy5faGFzVmlkZW9TZXF1ZW5jZT90aGlzLmVtaXQobC5NRVRBREFUQV9QQVJTRUQsXCJ2aWRlb1wiKTp0aGlzLl9oYXNTY3JpcHQmJnRoaXMuX2hhc1ZpZGVvU2VxdWVuY2UmJnRoaXMuZW1pdChsLlZJREVPX01FVEFEQVRBX0NIQU5HRSksdGhpcy5faGFzVmlkZW9TZXF1ZW5jZT0hMCksdGhpcy5fbWV0YUNoYW5nZT0hMH1lbHNle2lmKCF0aGlzLl9kYXRhc2l6ZVZhbGlkYXRvcihlLmRhdGFzaXplKSlyZXR1cm4gdm9pZCB0aGlzLmVtaXQobC5ERU1VWF9FUlJPUix0aGlzLlRBRyxuZXcgRXJyb3IoYGludmFsaWQgdmlkZW8gdGFnIGRhdGFzaXplOiAke2UuZGF0YXNpemV9YCksITEpO3RoaXMuX21ldGFDaGFuZ2UmJihlLm9wdGlvbnM9e21ldGE6T2JqZWN0LmFzc2lnbih7fSx0aGlzLnRyYWNrcy52aWRlb1RyYWNrLm1ldGEpfSx0aGlzLl9tZXRhQ2hhbmdlPSExKSx0aGlzLnRyYWNrcy52aWRlb1RyYWNrLnNhbXBsZXMucHVzaChlKX19ZWxzZSB0aGlzLmVtaXQobC5ERU1VWF9FUlJPUix0aGlzLlRBRyxuZXcgRXJyb3IoYHZpZGVvIGNvZGVpZCBpcyAke2l9YCksITEpLGUuZGF0YT10aGlzLmxvYWRlckJ1ZmZlci5zaGlmdChlLmRhdGFzaXplLTEpLHRoaXMuX2RhdGFzaXplVmFsaWRhdG9yKGUuZGF0YXNpemUpfHx0aGlzLmVtaXQobC5ERU1VWF9FUlJPUix0aGlzLlRBRyxuZXcgRXJyb3IoYGludmFsaWQgdmlkZW8gdGFnIGRhdGFzaXplOiAke2UuZGF0YXNpemV9YCksITEpLHRoaXMudHJhY2tzLnZpZGVvVHJhY2suc2FtcGxlcy5wdXNoKGUpLHRoaXMuZW1pdChsLkRFTVVYX0NPTVBMRVRFKTtkZWxldGUgZS50YWdUeXBlfV9hdmNTZXF1ZW5jZUhlYWRlclBhcnNlcihlKXtsZXQgdD10aGlzLnRyYWNrcy52aWRlb1RyYWNrO2lmKCF0KXJldHVybjtsZXQgaT0wO3QubWV0YXx8KHQubWV0YT1uZXcgci5WaWRlb1RyYWNrTWV0YSk7bGV0IHM9dC5tZXRhO3MuY29uZmlndXJhdGlvblZlcnNpb249ZVswXSxzLmF2Y1Byb2ZpbGVJbmRpY2F0aW9uPWVbMV0scy5wcm9maWxlQ29tcGF0aWJpbGl0eT1lWzJdLHMuYXZjTGV2ZWxJbmRpY2F0aW9uPWVbM10vMTAscy5uYWxVbml0TGVuZ3RoPTErKDMmZVs0XSk7bGV0IG49MzEmZVs1XTtpPTY7bGV0IG89e307Zm9yKGxldCB0PTA7dDxuO3QrKyl7bGV0IHQ9MjU1KmVbaV0rZVtpKzFdO2krPTI7bGV0IHI9bmV3IFVpbnQ4QXJyYXkodCk7Zm9yKGxldCBzPTA7czx0O3MrKylyW3NdPWVbaStzXTtsZXQgbj1cImF2YzEuXCI7Zm9yKGxldCBlPTE7ZTw0O2UrKyl7bGV0IHQ9cltlXS50b1N0cmluZygxNik7dC5sZW5ndGg8MiYmKHQ9XCIwXCIrdCksbis9dH1zLmNvZGVjPW4saSs9dCx0aGlzLnRyYWNrcy52aWRlb1RyYWNrLm1ldGEuc3BzPXIsbz1hLlNwc1BhcnNlci5wYXJzZVNQUyhyKX1sZXQgZD1lW2ldO2krKztmb3IobGV0IHQ9MDt0PGQ7dCsrKXtsZXQgdD0yNTUqZVtpXStlW2krMV07aSs9MjtsZXQgcz1uZXcgVWludDhBcnJheSh0KTtmb3IobGV0IHI9MDtyPHQ7cisrKXNbcl09ZVtpK3JdO2krPXQsdGhpcy50cmFja3MudmlkZW9UcmFjay5tZXRhLnBwcz1zfU9iamVjdC5hc3NpZ24ocyxhLlNwc1BhcnNlci50b1ZpZGVvTWV0YShvKSk7Y29uc3QgbD10aGlzLl9jb250ZXh0Lm1lZGlhSW5mby52aWRlbztsLmNvZGVjPXMuY29kZWMsbC5wcm9maWxlPXMucHJvZmlsZSxsLmxldmVsPXMubGV2ZWwsbC5jaHJvbWFGb3JtYXQ9cy5jaHJvbWFGb3JtYXQsbC5mcmFtZVJhdGU9cy5mcmFtZVJhdGUsbC5wYXJSYXRpbz1zLnBhclJhdGlvLGwud2lkdGg9bC53aWR0aD09PXMucHJlc2VudFdpZHRoP2wud2lkdGg6cy5wcmVzZW50V2lkdGgsbC5oZWlnaHQ9bC5oZWlnaHQ9PT1zLnByZXNlbnRIZWlnaHQ/bC53aWR0aDpzLnByZXNlbnRIZWlnaHQscy5kdXJhdGlvbj10aGlzLl9jb250ZXh0Lm1lZGlhSW5mby5kdXJhdGlvbipzLnRpbWVzY2FsZSxzLmF2Y2M9bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgpLHMuYXZjYy5zZXQoZSksdC5tZXRhPXN9X3N3aXRjaEF1ZGlvU2FtcGxlUmF0ZShlKXtyZXR1cm5bOTZlMyw4ODIwMCw2NGUzLDQ4ZTMsNDQxMDAsMzJlMywyNGUzLDIyMDUwLDE2ZTMsMTJlMywxMTAyNSw4ZTMsNzM1MF1bZV19X3N3aXRjaEF1ZGlvU2FtcGxpbmdGcmVxdWVuY3koZSl7cmV0dXJuWzU1MDAsMTEwMjUsMjIwNTAsNDQxMDAsNDhlM11bKDEyJmUpPj4+Ml19X3N3aXRjaEF1ZGlvQ2hhbm5lbChlKXtyZXR1cm5bMSwyXVsxJmVdfV9kYXRhc2l6ZVZhbGlkYXRvcihlKXtsZXQgdD10aGlzLmxvYWRlckJ1ZmZlci50b0ludCgwLDQpO3JldHVybiB0aGlzLmxvYWRlckJ1ZmZlci5zaGlmdCg0KSx0PT09ZSsxMX1nZXQgbG9hZGVyQnVmZmVyKCl7Y29uc3QgZT10aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKFwiTE9BREVSX0JVRkZFUlwiKTtpZihlKXJldHVybiBlO3RoaXMuZW1pdChsLkRFTVVYX0VSUk9SLG5ldyBFcnJvcihcIuaJvuS4jeWIsCBsb2FkZXJCdWZmZXIg5a6e5L6LXCIpKX1nZXQgdHJhY2tzKCl7cmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoXCJUUkFDS1NcIil9Z2V0IGxvZ2dlcigpe3JldHVybiB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKFwiTE9HR0VSXCIpfX10LmRlZmF1bHQ9aH0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzLHI9aSg4KSxhPShzPXIpJiZzLl9fZXNNb2R1bGU/czp7ZGVmYXVsdDpzfTtjbGFzcyBue3N0YXRpYyBnZXROYWx1bml0cyhlKXtpZihlLmxlbmd0aC1lLnBvc2l0aW9uPDQpcmV0dXJuW107bGV0IHQ9ZS5kYXRhdmlldyxpPWUucG9zaXRpb247cmV0dXJuIDE9PT10LmdldEludDMyKGkpfHwwPT09dC5nZXRJbnQxNihpKSYmMT09PXQuZ2V0SW50OChpKzIpP24uZ2V0QW5uZXhiTmFscyhlKTpuLmdldEF2Y2NOYWxzKGUpfXN0YXRpYyBnZXRBbm5leGJOYWxzKGUpe2xldCB0PVtdLGk9bi5nZXRIZWFkZXJQb3NpdGlvbkFubmV4QihlKSxzPWkucG9zLHI9cztmb3IoO3M8ZS5sZW5ndGgtNDspe2xldCBhPWUuYnVmZmVyLnNsaWNlKHMscytpLmhlYWRlckxlbmd0aCk7aS5wb3M9PT1lLnBvc2l0aW9uJiZlLnNraXAoaS5oZWFkZXJMZW5ndGgpLHI9KGk9bi5nZXRIZWFkZXJQb3NpdGlvbkFubmV4QihlKSkucG9zO2xldCBvPXtoZWFkZXI6YSxib2R5Om5ldyBVaW50OEFycmF5KGUuYnVmZmVyLnNsaWNlKHMrYS5ieXRlTGVuZ3RoLHIpKX07bi5hbmFseXNlTmFsKG8pLHQucHVzaChvKSxlLnNraXAoci1lLnBvc2l0aW9uKSxzPXJ9cmV0dXJuIHR9c3RhdGljIGdldEF2Y2NOYWxzKGUpe2xldCB0PVtdO2Zvcig7ZS5wb3NpdGlvbjxlLmxlbmd0aC00Oyl7bGV0IGk9ZS5kYXRhdmlldy5nZXRJbnQzMigpO2lmKCEoZS5sZW5ndGgtZS5wb3NpdGlvbj49aSkpYnJlYWs7e2xldCBzPWUuYnVmZmVyLnNsaWNlKGUucG9zaXRpb24sZS5wb3NpdGlvbis0KTtlLnNraXAoNCk7bGV0IHI9ZS5idWZmZXIuc2xpY2UoZS5wb3NpdGlvbixlLnBvc2l0aW9uK2kpO2Uuc2tpcChpKTtsZXQgYT17aGVhZGVyOnMsYm9keTpyfTtuLmFuYWx5c2VOYWwoYSksdC5wdXNoKGEpfX1yZXR1cm4gdH1zdGF0aWMgYW5hbHlzZU5hbChlKXtzd2l0Y2goMzEmZS5ib2R5WzBdKXtjYXNlIDE6ZS5uZHI9ITA7YnJlYWs7Y2FzZSA1OmUuaWRyPSEwO2JyZWFrO2Nhc2UgNjpicmVhaztjYXNlIDc6ZS5zcHM9YS5kZWZhdWx0LnBhcnNlU1BTKGUuYm9keSk7YnJlYWs7Y2FzZSA4OmUucHBzPSEwfX1zdGF0aWMgZ2V0SGVhZGVyUG9zaXRpb25Bbm5leEIoZSl7bGV0IHQ9ZS5wb3NpdGlvbixpPTA7Zm9yKDszIT09aSYmNCE9PWkmJnQ8ZS5sZW5ndGgtNDspMD09PWUuZGF0YXZpZXcuZ2V0SW50MTYodCk/MT09PWUuZGF0YXZpZXcuZ2V0SW50MTYodCsyKT9pPTQ6MT09PWUuZGF0YXZpZXcuZ2V0SW50OCh0KzIpP2k9Mzp0Kys6dCsrO3JldHVybiB0PT09ZS5sZW5ndGgtNCYmKDA9PT1lLmRhdGF2aWV3LmdldEludDE2KHQpPzE9PT1lLmRhdGF2aWV3LmdldEludDE2KHQrMikmJihpPTQpOih0KyssMD09PWUuZGF0YXZpZXcuZ2V0SW50MTYodCkmJjE9PT1lLmRhdGF2aWV3LmdldEludDgodCk/aT0zOnQ9ZS5sZW5ndGgpKSx7cG9zOnQsaGVhZGVyTGVuZ3RoOml9fXN0YXRpYyBnZXRBdmNjKGUsdCl7bGV0IGk9bmV3IFVpbnQ4QXJyYXkoZS5ieXRlTGVuZ3RoK3QuYnl0ZUxlbmd0aCsxMSk7aVswXT0xLGlbMV09ZVsxXSxpWzJdPWVbMl0saVszXT1lWzNdLGlbNF09MjU1LGlbNV09MjI1O2xldCBzPTY7cmV0dXJuIGkuc2V0KG5ldyBVaW50OEFycmF5KFtlLmJ5dGVMZW5ndGg+Pj44JjI1NSwyNTUmZS5ieXRlTGVuZ3RoXSkscykscys9MixpLnNldChlLHMpLGlbcys9ZS5ieXRlTGVuZ3RoXT0xLHMrKyxpLnNldChuZXcgVWludDhBcnJheShbdC5ieXRlTGVuZ3RoPj4+OCYyNTUsMjU1JnQuYnl0ZUxlbmd0aF0pLHMpLHMrPTIsaS5zZXQodCxzKSxpfX10LmRlZmF1bHQ9bn0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3QuZGVmYXVsdD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLlRBRz1cIkdvbG9tYlwiLHRoaXMuX2J1ZmZlcj1lLHRoaXMuX2J1ZmZlckluZGV4PTAsdGhpcy5fdG90YWxCeXRlcz1lLmJ5dGVMZW5ndGgsdGhpcy5fdG90YWxCaXRzPTgqZS5ieXRlTGVuZ3RoLHRoaXMuX2N1cnJlbnRXb3JkPTAsdGhpcy5fY3VycmVudFdvcmRCaXRzTGVmdD0wfWRlc3Ryb3koKXt0aGlzLl9idWZmZXI9bnVsbH1fZmlsbEN1cnJlbnRXb3JkKCl7bGV0IGU9dGhpcy5fdG90YWxCeXRlcy10aGlzLl9idWZmZXJJbmRleCx0PU1hdGgubWluKDQsZSksaT1uZXcgVWludDhBcnJheSg0KTtpLnNldCh0aGlzLl9idWZmZXIuc3ViYXJyYXkodGhpcy5fYnVmZmVySW5kZXgsdGhpcy5fYnVmZmVySW5kZXgrdCkpLHRoaXMuX2N1cnJlbnRXb3JkPW5ldyBEYXRhVmlldyhpLmJ1ZmZlcikuZ2V0VWludDMyKDApLHRoaXMuX2J1ZmZlckluZGV4Kz10LHRoaXMuX2N1cnJlbnRXb3JkQml0c0xlZnQ9OCp0fXJlYWRCaXRzKGUpe2xldCB0PU1hdGgubWluKHRoaXMuX2N1cnJlbnRXb3JkQml0c0xlZnQsZSksaT10aGlzLl9jdXJyZW50V29yZD4+PjMyLXQ7aWYoZT4zMil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVhZCBtb3JlIHRoYW4gMzIgYml0cyBhdCBhIHRpbWVcIik7cmV0dXJuIHRoaXMuX2N1cnJlbnRXb3JkQml0c0xlZnQtPXQsdGhpcy5fY3VycmVudFdvcmRCaXRzTGVmdD4wP3RoaXMuX2N1cnJlbnRXb3JkPDw9dDp0aGlzLl90b3RhbEJ5dGVzLXRoaXMuX2J1ZmZlckluZGV4PjAmJnRoaXMuX2ZpbGxDdXJyZW50V29yZCgpLCh0PWUtdCk+MCYmdGhpcy5fY3VycmVudFdvcmRCaXRzTGVmdD9pPDx0fHRoaXMucmVhZEJpdHModCk6aX1yZWFkQm9vbCgpe3JldHVybiAxPT09dGhpcy5yZWFkQml0cygxKX1yZWFkQnl0ZSgpe3JldHVybiB0aGlzLnJlYWRCaXRzKDgpfV9za2lwTGVhZGluZ1plcm8oKXtsZXQgZTtmb3IoZT0wO2U8dGhpcy5fY3VycmVudFdvcmRCaXRzTGVmdDtlKyspaWYoMCE9KHRoaXMuX2N1cnJlbnRXb3JkJjIxNDc0ODM2NDg+Pj5lKSlyZXR1cm4gdGhpcy5fY3VycmVudFdvcmQ8PD1lLHRoaXMuX2N1cnJlbnRXb3JkQml0c0xlZnQtPWUsZTtyZXR1cm4gdGhpcy5fZmlsbEN1cnJlbnRXb3JkKCksZSt0aGlzLl9za2lwTGVhZGluZ1plcm8oKX1yZWFkVUVHKCl7bGV0IGU9dGhpcy5fc2tpcExlYWRpbmdaZXJvKCk7cmV0dXJuIHRoaXMucmVhZEJpdHMoZSsxKS0xfXJlYWRTRUcoKXtsZXQgZT10aGlzLnJlYWRVRUcoKTtyZXR1cm4gMSZlP2UrMT4+PjE6LTEqKGU+Pj4xKX19fSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHMscj1pKDApLGE9aSgzMyksbj0ocz1hKSYmcy5fX2VzTW9kdWxlP3M6e2RlZmF1bHQ6c307Y29uc3R7UkVNVVhfRVZFTlRTOm8sREVNVVhfRVZFTlRTOmR9PXIuRVZFTlRTO2NsYXNzIGx7Y29uc3RydWN0b3IoKXt0aGlzLm5leHRBdWRpb0R0cz0wLHRoaXMubmV4dFZpZGVvRHRzPTAsdGhpcy5sYXN0QXVkaW9TYW1wbGVzTGVuPTAsdGhpcy5sYXN0VmlkZW9TYW1wbGVzTGVuPTAsdGhpcy5sYXN0VmlkZW9EdHM9dm9pZCAwLHRoaXMubGFzdEF1ZGlvRHRzPXZvaWQgMCx0aGlzLmFsbEF1ZGlvU2FtcGxlc0NvdW50PTAsdGhpcy5hbGxWaWRlb1NhbXBsZXNDb3VudD0wLHRoaXMuX2ZpcnN0QXVkaW9TYW1wbGU9bnVsbCx0aGlzLl9maXJzdFZpZGVvU2FtcGxlPW51bGwsdGhpcy5maWxsZWRBdWRpb1NhbXBsZXM9W10sdGhpcy5maWxsZWRWaWRlb1NhbXBsZXM9W10sdGhpcy5fdmlkZW9MYXJnZUdhcD0wLHRoaXMuX2F1ZGlvTGFyZ2VHYXA9MH1pbml0KCl7dGhpcy5iZWZvcmUoby5SRU1VWF9NRURJQSx0aGlzLmRvRml4LmJpbmQodGhpcykpfXJlc2V0KCl7dGhpcy5uZXh0QXVkaW9EdHM9bnVsbCx0aGlzLm5leHRWaWRlb0R0cz1udWxsLHRoaXMubGFzdEF1ZGlvU2FtcGxlc0xlbj0wLHRoaXMubGFzdFZpZGVvU2FtcGxlc0xlbj0wLHRoaXMubGFzdFZpZGVvRHRzPXZvaWQgMCx0aGlzLmxhc3RBdWRpb0R0cz12b2lkIDAsdGhpcy5maWxsZWRBdWRpb1NhbXBsZXM9W10sdGhpcy5maWxsZWRWaWRlb1NhbXBsZXM9W119ZG9GaXgoKXtjb25zdHtpc0ZpcnN0QXVkaW9TYW1wbGVzOmUsaXNGaXJzdFZpZGVvU2FtcGxlczp0fT10aGlzLmdldEZpcnN0U2FtcGxlKCk7dGhpcy5yZWNvcmRTYW1wbGVzQ291bnQoKSx0aGlzLl9maXJzdFZpZGVvU2FtcGxlJiZ0aGlzLmZpeFJlZlNhbXBsZUR1cmF0aW9uKHRoaXMudmlkZW9UcmFjay5tZXRhLHRoaXMudmlkZW9UcmFjay5zYW1wbGVzKSx0aGlzLl9maXJzdEF1ZGlvU2FtcGxlJiZ0aGlzLmZpeFJlZlNhbXBsZUR1cmF0aW9uKHRoaXMuYXVkaW9UcmFjay5tZXRhLHRoaXMuYXVkaW9UcmFjay5zYW1wbGVzKTtjb25zdHtjaGFuZ2VkOmksY2hhbmdlZElkeDpzfT1sLmRldGFjdENoYW5nZVN0cmVhbSh0aGlzLnZpZGVvVHJhY2suc2FtcGxlcyk7aSYmIWU/dGhpcy5maXhDaGFuZ2VTdHJlYW1WaWRlbyhzKTp0aGlzLmRvRml4VmlkZW8odCk7Y29uc3R7Y2hhbmdlZDpyLGNoYW5nZWRJZHg6YX09bC5kZXRhY3RDaGFuZ2VTdHJlYW0odGhpcy5hdWRpb1RyYWNrLnNhbXBsZXMpO3I/dGhpcy5maXhDaGFuZ2VTdHJlYW1BdWRpbyhhKTp0aGlzLmRvRml4QXVkaW8oZSl9ZG9GaXhWaWRlbyhlLHQpe2xldHtzYW1wbGVzOmksbWV0YTpzfT10aGlzLnZpZGVvVHJhY2s7aWYocy5mcmFtZVJhdGUmJiExPT09cy5mcmFtZVJhdGUuZml4ZWQpcmV0dXJuO2lmKCFpfHwhaS5sZW5ndGh8fCF0aGlzLl9maXJzdFZpZGVvU2FtcGxlKXJldHVybjtjb25zdCByPWlbMF0sYT1pLmxlbmd0aDt0aGlzLl92aWRlb0xhcmdlR2FwPjAmJmwuZG9GaXhMYXJnZUdhcChpLHRoaXMuX3ZpZGVvTGFyZ2VHYXApLHIuZHRzIT09dGhpcy5fZmlyc3RWaWRlb1NhbXBsZS5kdHMmJih0fHxsLmRldGVjdExhcmdlR2FwKHRoaXMubmV4dFZpZGVvRHRzLHIpKSYmKHQmJih0aGlzLm5leHRWaWRlb0R0cz10KSx0aGlzLl92aWRlb0xhcmdlR2FwPXRoaXMubmV4dFZpZGVvRHRzLXIuZHRzLGwuZG9GaXhMYXJnZUdhcChpLHRoaXMuX3ZpZGVvTGFyZ2VHYXApKTtjb25zdCBuPXIuZHRzO2lmKGUmJnRoaXMuX2ZpcnN0QXVkaW9TYW1wbGUpe2NvbnN0IGU9dGhpcy5fZmlyc3RWaWRlb1NhbXBsZS5kdHMsdD1lLXRoaXMuX2ZpcnN0QXVkaW9TYW1wbGUuZHRzO2lmKHQ+MipzLnJlZlNhbXBsZUR1cmF0aW9uKXtjb25zdCBhPU1hdGguZmxvb3IodC9zLnJlZlNhbXBsZUR1cmF0aW9uKTtmb3IobGV0IHQ9MDt0PGE7dCsrKXtjb25zdCBhPU9iamVjdC5hc3NpZ24oe30scik7YS5kdHM9ZS0odCsxKSpzLnJlZlNhbXBsZUR1cmF0aW9uLGEucHRzPWEuZHRzK2EuY3RzLGkudW5zaGlmdChhKSx0aGlzLmZpbGxlZFZpZGVvU2FtcGxlcy5wdXNoKHtkdHM6YS5kdHMsc2l6ZTphLmRhdGEuYnl0ZUxlbmd0aH0pfX19bGV0IG87aWYodGhpcy5uZXh0VmlkZW9EdHMpe289bi10aGlzLm5leHRWaWRlb0R0cztjb25zdCBlPU1hdGguYWJzKG8pO2lmKG8+MipzLnJlZlNhbXBsZUR1cmF0aW9uKXtjb25zdCBlPU1hdGguZmxvb3Ioby9zLnJlZlNhbXBsZUR1cmF0aW9uKTtmb3IobGV0IHQ9MDt0PGU7dCsrKXtjb25zdCBlPU9iamVjdC5hc3NpZ24oe30saVswXSkscj1uLSh0KzEpKnMucmVmU2FtcGxlRHVyYXRpb247ZS5kdHM9cj50aGlzLm5leHRWaWRlb0R0cz9yOnRoaXMubmV4dFZpZGVvRHRzLGUucHRzPWUuZHRzK2UuY3RzLHRoaXMudmlkZW9UcmFjay5zYW1wbGVzLnVuc2hpZnQoZSksdGhpcy5maWxsZWRWaWRlb1NhbXBsZXMucHVzaCh7ZHRzOmUuZHRzLHNpemU6ZS5kYXRhLmJ5dGVMZW5ndGh9KX19ZWxzZSBlPD1zLnJlZlNhbXBsZUR1cmF0aW9uJiZlPjA/KGlbMF0uZHRzPXRoaXMubmV4dFZpZGVvRHRzLGlbMF0ub3JpZ2luRHRzPWlbMF0uZHRzLGlbMF0uY3RzPXZvaWQgMCE9PWlbMF0uY3RzP2lbMF0uY3RzOmlbMF0ucHRzLWlbMF0uZHRzLGlbMF0ucHRzPWlbMF0uZHRzK2lbMF0uY3RzKTpvPDAmJmwuZG9GaXhMYXJnZUdhcChpLC0xKm8pfWNvbnN0IGQ9aVtpLmxlbmd0aC0xXS5kdHMsaD1pLmxlbmd0aD49Mj9kLWlbaS5sZW5ndGgtMl0uZHRzOnMucmVmU2FtcGxlRHVyYXRpb247dGhpcy5sYXN0VmlkZW9TYW1wbGVzTGVuPWEsdGhpcy5uZXh0VmlkZW9EdHM9ZCtoLHRoaXMubGFzdFZpZGVvRHRzPWQ7Zm9yKGxldCBlPTAsdD1pLmxlbmd0aDtlPHQ7ZSsrKXtjb25zdCB0PWlbZV0scj1pW2UrMV07aWYoIXIpYnJlYWs7Y29uc3QgYT1yLmR0cy10LmR0cztpZihhPjIqcy5yZWZTYW1wbGVEdXJhdGlvbil7bGV0IG49TWF0aC5mbG9vcihhL3MucmVmU2FtcGxlRHVyYXRpb24pLG89MDtmb3IoO288bjspe2NvbnN0IGE9T2JqZWN0LmFzc2lnbih7fSxyKTthLmR0cz10LmR0cysobysxKSpzLnJlZlNhbXBsZUR1cmF0aW9uLGEucHRzPWEuZHRzK2EuY3RzLGE8ci5kdHMmJihpLnNwbGljZShlLDAsYSksdGhpcy5maWxsZWRWaWRlb1NhbXBsZXMucHVzaCh7ZHRzOmEuZHRzLHNpemU6YS5kYXRhLmJ5dGVMZW5ndGh9KSksbysrLGUrK319fXRoaXMudmlkZW9UcmFjay5zYW1wbGVzPWl9ZG9GaXhBdWRpbyhlLHQpe2xldHtzYW1wbGVzOmksbWV0YTpzfT10aGlzLmF1ZGlvVHJhY2s7aWYoIWl8fCFpLmxlbmd0aClyZXR1cm47Y29uc3Qgcj1pLmxlbmd0aCxhPW4uZGVmYXVsdC5nZXRTaWxlbnRGcmFtZShzLmNvZGVjLHMuY2hhbm5lbENvdW50KSxvPXRoaXMuX2ZpcnN0QXVkaW9TYW1wbGUsZD1pWzBdO2lmKHRoaXMuX2F1ZGlvTGFyZ2VHYXA+MCYmbC5kb0ZpeExhcmdlR2FwKGksdGhpcy5fYXVkaW9MYXJnZUdhcCksZC5kdHMhPT10aGlzLl9maXJzdEF1ZGlvU2FtcGxlLmR0cyYmKHR8fGwuZGV0ZWN0TGFyZ2VHYXAodGhpcy5uZXh0QXVkaW9EdHMsZCkpJiYodCYmKHRoaXMubmV4dEF1ZGlvRHRzPXQpLHRoaXMuX2F1ZGlvTGFyZ2VHYXA9dGhpcy5uZXh0QXVkaW9EdHMtZC5kdHMsbC5kb0ZpeExhcmdlR2FwKGksdGhpcy5fYXVkaW9MYXJnZUdhcCkpLHRoaXMuX2ZpcnN0VmlkZW9TYW1wbGUmJmUpe2NvbnN0IGU9dGhpcy5fZmlyc3RWaWRlb1NhbXBsZS5wdHM/dGhpcy5fZmlyc3RWaWRlb1NhbXBsZS5wdHM6dGhpcy5fZmlyc3RWaWRlb1NhbXBsZS5kdHMrdGhpcy5fZmlyc3RWaWRlb1NhbXBsZS5jdHM7aWYoby5kdHMtZT5zLnJlZlNhbXBsZUR1cmF0aW9uKXtjb25zdCB0PU1hdGguZmxvb3IoKG8uZHRzLWUpL3MucmVmU2FtcGxlRHVyYXRpb24pO2ZvcihsZXQgZT0wO2U8dDtlKyspe2NvbnN0IHQ9e2RhdGE6YSxkYXRhc2l6ZTphLmJ5dGVMZW5ndGgsZHRzOm8uZHRzLShlKzEpKnMucmVmU2FtcGxlRHVyYXRpb24sZmlsdGVyZWQ6MH07aS51bnNoaWZ0KHQpLHRoaXMuZmlsbGVkQXVkaW9TYW1wbGVzLnB1c2goe2R0czp0LmR0cyxzaXplOnQuZGF0YS5ieXRlTGVuZ3RofSl9fX1sZXQgaDtjb25zdCB1PWlbMF0uZHRzO2lmKHRoaXMubmV4dEF1ZGlvRHRzKXtoPXUtdGhpcy5uZXh0QXVkaW9EdHM7Y29uc3QgZT1NYXRoLmFicyhoKTtpZihlPnMucmVmU2FtcGxlRHVyYXRpb24mJjE9PT1yJiYxPT09dGhpcy5sYXN0QXVkaW9TYW1wbGVzTGVuJiYocy5yZWZTYW1wbGVEdXJhdGlvbkZpeGVkPXZvaWQgMCksaD4yKnMucmVmU2FtcGxlRHVyYXRpb24paWYoMT09PXImJjE9PT10aGlzLmxhc3RBdWRpb1NhbXBsZXNMZW4pcy5yZWZTYW1wbGVEdXJhdGlvbkZpeGVkPXZvaWQgMCE9PXMucmVmU2FtcGxlRHVyYXRpb25GaXhlZD9zLnJlZlNhbXBsZUR1cmF0aW9uRml4ZWQraDpzLnJlZlNhbXBsZUR1cmF0aW9uK2g7ZWxzZXtjb25zdCBlPU1hdGguZmxvb3IoaC9zLnJlZlNhbXBsZUR1cmF0aW9uKTtmb3IobGV0IHQ9MDt0PGU7dCsrKXtjb25zdCBlPXUtKHQrMSkqcy5yZWZTYW1wbGVEdXJhdGlvbixyPU9iamVjdC5hc3NpZ24oe30saVswXSx7ZHRzOmU+dGhpcy5uZXh0QXVkaW9EdHM/ZTp0aGlzLm5leHRBdWRpb0R0c30pO3RoaXMuZmlsbGVkQXVkaW9TYW1wbGVzLnB1c2goe2R0czpyLmR0cyxzaXplOnIuZGF0YS5ieXRlTGVuZ3RofSksdGhpcy5hdWRpb1RyYWNrLnNhbXBsZXMudW5zaGlmdChyKX19ZWxzZSBlPD1zLnJlZlNhbXBsZUR1cmF0aW9uJiZlPjA/KGlbMF0uZHRzPXRoaXMubmV4dEF1ZGlvRHRzLGlbMF0ucHRzPXRoaXMubmV4dEF1ZGlvRHRzKTpoPDAmJmwuZG9GaXhMYXJnZUdhcChpLC0xKmgpfWNvbnN0IGM9aVtpLmxlbmd0aC0xXS5kdHMsZj1pLmxlbmd0aD49Mj9jLWlbaS5sZW5ndGgtMl0uZHRzOnMucmVmU2FtcGxlRHVyYXRpb247dGhpcy5sYXN0QXVkaW9TYW1wbGVzTGVuPXIsdGhpcy5uZXh0QXVkaW9EdHM9cy5yZWZTYW1wbGVEdXJhdGlvbkZpeGVkP2Mrcy5yZWZTYW1wbGVEdXJhdGlvbkZpeGVkOmMrZix0aGlzLmxhc3RBdWRpb0R0cz1jO2ZvcihsZXQgZT0wLHQ9aS5sZW5ndGg7ZTx0O2UrKyl7Y29uc3QgdD1pW2VdLHM9aVtlKzFdO2lmKCFzKWJyZWFrO2NvbnN0IHI9cy5kdHMtdC5kdHM7aVtlXS5kdXJhdGlvbj1yfXRoaXMuYXVkaW9UcmFjay5zYW1wbGVzPWwuc29ydEF1ZGlvU2FtcGxlcyhpKX1maXhDaGFuZ2VTdHJlYW1WaWRlbyhlKXtjb25zdHtzYW1wbGVzOnQsbWV0YTppfT10aGlzLnZpZGVvVHJhY2sscz0wPT09ZT90aGlzLmdldFN0cmVhbUNoYW5nZVN0YXJ0KHRbMF0pOnRbZS0xXS5kdHMscj10W2VdLmR0cztpZihNYXRoLmFicyhzLXIpPD0yKmkucmVmU2FtcGxlRHVyYXRpb24pcmV0dXJuIHRbZV0ub3B0aW9ucz90W2VdLm9wdGlvbnMuaXNDb250aW51ZT0hMDp0W2VdLm9wdGlvbnM9e2lzQ29udGludWU6ITB9LHRoaXMuZG9GaXhWaWRlbyghMSk7Y29uc3QgYT10LnNsaWNlKDAsZSksbj10LnNsaWNlKGUpLG89dFswXSxkPW5bMF0uZHRzLW8uZHRzLGw9by5vcHRpb25zJiZvLm9wdGlvbnMuc3RhcnQrZD9vLm9wdGlvbnMuc3RhcnQ6bnVsbDt0aGlzLnZpZGVvVHJhY2suc2FtcGxlcz10LnNsaWNlKDAsZSksdGhpcy5kb0ZpeFZpZGVvKCExKSx0aGlzLnZpZGVvVHJhY2suc2FtcGxlcz10LnNsaWNlKGUpLHRoaXMuZG9GaXhWaWRlbyghMSxsKSx0aGlzLnZpZGVvVHJhY2suc2FtcGxlcz1hLmNvbmNhdChuKX1maXhDaGFuZ2VTdHJlYW1BdWRpbyhlKXtjb25zdHtzYW1wbGVzOnQsbWV0YTppfT10aGlzLmF1ZGlvVHJhY2sscz0wPT09ZT90aGlzLmdldFN0cmVhbUNoYW5nZVN0YXJ0KHRbMF0pOnRbZS0xXS5kdHMscj10W2VdLmR0cztpZihNYXRoLmFicyhzLXIpPD0yKmkucmVmU2FtcGxlRHVyYXRpb24pcmV0dXJuIHRbZV0ub3B0aW9ucz90W2VdLm9wdGlvbnMuaXNDb250aW51ZT0hMDp0W2VdLm9wdGlvbnM9e2lzQ29udGludWU6ITB9LHRoaXMuZG9GaXhBdWRpbyghMSk7Y29uc3QgYT10LnNsaWNlKDAsZSksbj10LnNsaWNlKGUpLG89dFswXSxkPW5bMF0uZHRzLW8uZHRzLGw9by5vcHRpb25zJiZvLm9wdGlvbnMuc3RhcnQrZD9vLm9wdGlvbnMuc3RhcnQ6bnVsbDt0aGlzLmF1ZGlvVHJhY2suc2FtcGxlcz1hLHRoaXMuZG9GaXhBdWRpbyghMSksdGhpcy5hdWRpb1RyYWNrLnNhbXBsZXM9bix0aGlzLmRvRml4QXVkaW8oITEsbCksdGhpcy5hdWRpb1RyYWNrLnNhbXBsZXM9YS5jb25jYXQobil9Z2V0Rmlyc3RTYW1wbGUoKXtsZXR7c2FtcGxlczplfT10aGlzLnZpZGVvVHJhY2sse3NhbXBsZXM6dH09dGhpcy5hdWRpb1RyYWNrLGk9ITEscz0hMTtyZXR1cm4hdGhpcy5fZmlyc3RWaWRlb1NhbXBsZSYmZS5sZW5ndGgmJih0aGlzLl9maXJzdFZpZGVvU2FtcGxlPWwuZmluZEZpcnN0VmlkZW9TYW1wbGUoZSksaT0hMCksIXRoaXMuX2ZpcnN0QXVkaW9TYW1wbGUmJnQubGVuZ3RoJiYodGhpcy5fZmlyc3RBdWRpb1NhbXBsZT1sLmZpbmRGaXJzdEF1ZGlvU2FtcGxlKHQpLHM9ITApLHtpc0ZpcnN0VmlkZW9TYW1wbGVzOmksaXNGaXJzdEF1ZGlvU2FtcGxlczpzfX1maXhSZWZTYW1wbGVEdXJhdGlvbihlLHQpe2NvbnN0IGk9XCJ2aWRlb1wiPT09ZS50eXBlLHM9aT90aGlzLmFsbFZpZGVvU2FtcGxlc0NvdW50OnRoaXMuYWxsQXVkaW9TYW1wbGVzQ291bnQscj1pP3RoaXMuX2ZpcnN0VmlkZW9TYW1wbGUuZHRzOnRoaXMuX2ZpcnN0QXVkaW9TYW1wbGUuZHRzLGE9aT90aGlzLmZpbGxlZFZpZGVvU2FtcGxlcy5sZW5ndGg6dGhpcy5maWxsZWRBdWRpb1NhbXBsZXMubGVuZ3RoO2lmKCFlLnJlZlNhbXBsZUR1cmF0aW9ufHxlLnJlZlNhbXBsZUR1cmF0aW9uPD0wfHxOdW1iZXIuaXNOYU4oZS5yZWZTYW1wbGVEdXJhdGlvbikpe2lmKHQubGVuZ3RoPj0xKXtjb25zdCBpPXRbdC5sZW5ndGgtMV0uZHRzO2UucmVmU2FtcGxlRHVyYXRpb249TWF0aC5mbG9vcigoaS1yKS8ocythLTEpKX19ZWxzZSBpZihlLnJlZlNhbXBsZUR1cmF0aW9uJiZ0Lmxlbmd0aD49NSl7Y29uc3QgaT0odFt0Lmxlbmd0aC0xXS5kdHMtdFswXS5kdHMpLyh0Lmxlbmd0aC0xKTtlLnJlZlNhbXBsZUR1cmF0aW9uPU1hdGguZmxvb3IoTWF0aC5hYnMoZS5yZWZTYW1wbGVEdXJhdGlvbi1pKTw9NT9lLnJlZlNhbXBsZUR1cmF0aW9uOmkpfX1yZWNvcmRTYW1wbGVzQ291bnQoKXtjb25zdHthdWRpb1RyYWNrOmUsdmlkZW9UcmFjazp0fT10aGlzO3RoaXMuYWxsQXVkaW9TYW1wbGVzQ291bnQrPWUuc2FtcGxlcy5sZW5ndGgsdGhpcy5hbGxWaWRlb1NhbXBsZXNDb3VudCs9dC5zYW1wbGVzLmxlbmd0aH1yZW1vdmVJbnZhbGlkU2FtcGxlcygpe2NvbnN0e19maXJzdFZpZGVvU2FtcGxlOmUsX2ZpcnN0QXVkaW9TYW1wbGU6dH09dGhpczt0aGlzLmF1ZGlvVHJhY2suc2FtcGxlcz10aGlzLmF1ZGlvVHJhY2suc2FtcGxlcy5maWx0ZXIoZT0+ZS5kdHM+PXQuZHRzJiYodm9pZCAwPT09dGhpcy5sYXN0QXVkaW9EdHN8fGUuZHRzPnRoaXMubGFzdEF1ZGlvRHRzKSksdGhpcy52aWRlb1RyYWNrLnNhbXBsZXM9dGhpcy52aWRlb1RyYWNrLnNhbXBsZXMuZmlsdGVyKHQ9PnQuZHRzPj1lLmR0cyYmKHZvaWQgMD09PXRoaXMubGFzdFZpZGVvRHRzfHx0LmR0cz50aGlzLmxhc3RWaWRlb0R0cykpfWdldFN0cmVhbUNoYW5nZVN0YXJ0KGUpe3JldHVybiBlLm9wdGlvbnMmJmUub3B0aW9ucy5zdGFydD9lLm9wdGlvbnMuc3RhcnQtdGhpcy5kdHNCYXNlOjEvMH1zdGF0aWMgc29ydEF1ZGlvU2FtcGxlcyhlKXtyZXR1cm4gMT09PWUubGVuZ3RoP2U6ZS5zb3J0KChlLHQpPT5lLmR0cy10LmR0cyl9c3RhdGljIGZpbmRGaXJzdEF1ZGlvU2FtcGxlKGUpe3JldHVybiBlJiYwIT09ZS5sZW5ndGg/bC5zb3J0QXVkaW9TYW1wbGVzKGUpWzBdOm51bGx9c3RhdGljIGZpbmRGaXJzdFZpZGVvU2FtcGxlKGUpe2lmKCFlLmxlbmd0aClyZXR1cm4gbnVsbDtjb25zdCB0PWUuc29ydCgoZSx0KT0+ZS5kdHMtdC5kdHMpO2ZvcihsZXQgZT0wLGk9dC5sZW5ndGg7ZTxpO2UrKylpZih0W2VdLmlzS2V5ZnJhbWUpcmV0dXJuIHRbZV19c3RhdGljIGRldGVjdExhcmdlR2FwKGUsdCl7aWYobnVsbD09PWUpcmV0dXJuO2NvbnN0IGk9dC5kdHN8fDAscz1lLWk+PTFlM3x8aS1lPj0xZTMscj10Lm9wdGlvbnMmJnQub3B0aW9ucy5kaXNjb250aW51ZTtyZXR1cm4gc3x8cn1zdGF0aWMgZG9GaXhMYXJnZUdhcChlLHQpe2NvbnNvbGUubG9nKFwiZml4IGxhcmdlIGdhcFwiKTtmb3IobGV0IGk9MCxzPWUubGVuZ3RoO2k8cztpKyspe2NvbnN0IHM9ZVtpXTtzLmR0cys9dCxzLnB0cyYmKHMucHRzKz10KX19c3RhdGljIGRldGFjdENoYW5nZVN0cmVhbShlKXtsZXQgdD0hMSxpPS0xO2ZvcihsZXQgcz0wLHI9ZS5sZW5ndGg7czxyO3MrKylpZihlW3NdLm9wdGlvbnMmJmVbc10ub3B0aW9ucy5tZXRhKXt0PSEwLGk9czticmVha31yZXR1cm57Y2hhbmdlZDp0LGNoYW5nZWRJZHg6aX19Z2V0IHRyYWNrcygpe3JldHVybiB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKFwiVFJBQ0tTXCIpfWdldCBhdWRpb1RyYWNrKCl7cmV0dXJuIHRoaXMudHJhY2tzP3RoaXMudHJhY2tzLmF1ZGlvVHJhY2s6bnVsbH1nZXQgdmlkZW9UcmFjaygpe3JldHVybiB0aGlzLnRyYWNrcz90aGlzLnRyYWNrcy52aWRlb1RyYWNrOm51bGx9Z2V0IGR0c0Jhc2UoKXtjb25zdCBlPXRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoXCJNUDRfUkVNVVhFUlwiKTtyZXR1cm4gZT9lLl9kdHNCYXNlOjB9fXQuZGVmYXVsdD1sfSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dC5kZWZhdWx0PWNsYXNze3N0YXRpYyBnZXRTaWxlbnRGcmFtZShlLHQpe2lmKFwibXA0YS40MC4yXCI9PT1lKXtpZigxPT09dClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzAsMjAwLDAsMTI4LDM1LDEyOF0pO2lmKDI9PT10KXJldHVybiBuZXcgVWludDhBcnJheShbMzMsMCw3MywxNDQsMiwyNSwwLDM1LDEyOF0pO2lmKDM9PT10KXJldHVybiBuZXcgVWludDhBcnJheShbMCwyMDAsMCwxMjgsMzIsMTMyLDEsMzgsNjQsOCwxMDAsMCwxNDJdKTtpZig0PT09dClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzAsMjAwLDAsMTI4LDMyLDEzMiwxLDM4LDY0LDgsMTAwLDAsMTI4LDQ0LDEyOCw4LDIsNTZdKTtpZig1PT09dClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzAsMjAwLDAsMTI4LDMyLDEzMiwxLDM4LDY0LDgsMTAwLDAsMTMwLDQ4LDQsMTUzLDAsMzMsMTQ0LDIsNTZdKTtpZig2PT09dClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzAsMjAwLDAsMTI4LDMyLDEzMiwxLDM4LDY0LDgsMTAwLDAsMTMwLDQ4LDQsMTUzLDAsMzMsMTQ0LDIsMCwxNzgsMCwzMiw4LDIyNF0pfWVsc2V7aWYoMT09PXQpcmV0dXJuIG5ldyBVaW50OEFycmF5KFsxLDY0LDM0LDEyOCwxNjMsNzgsMjMwLDEyOCwxODYsOCwwLDAsMCwyOCw2LDI0MSwxOTMsMTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTRdKTtpZigyPT09dClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzEsNjQsMzQsMTI4LDE2Myw5NCwyMzAsMTI4LDE4Niw4LDAsMCwwLDAsMTQ5LDAsNiwyNDEsMTYxLDEwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDk0XSk7aWYoMz09PXQpcmV0dXJuIG5ldyBVaW50OEFycmF5KFsxLDY0LDM0LDEyOCwxNjMsOTQsMjMwLDEyOCwxODYsOCwwLDAsMCwwLDE0OSwwLDYsMjQxLDE2MSwxMCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5NF0pfXJldHVybiBudWxsfX19LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjbGFzcyBze2NvbnN0cnVjdG9yKCl7dGhpcy5taW1ldHlwZT1cIlwiLHRoaXMuaW5pdD1udWxsLHRoaXMuZGF0YT1bXX19dC5kZWZhdWx0PWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5zb3VyY2VzPXt9fWdldFNvdXJjZShlKXtyZXR1cm4gdGhpcy5zb3VyY2VzW2VdfWNyZWF0ZVNvdXJjZShlKXtyZXR1cm4gdGhpcy5zb3VyY2VzW2VdPW5ldyBzLHRoaXMuc291cmNlc1tlXX1jbGVhcigpe3RoaXMuc291cmNlcz17fX1kZXN0cm95KCl7dGhpcy5zb3VyY2VzPXt9fX19LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1pKDApO2NvbnN0IHI9e05VTUJFUjowLEJPT0xFQU46MSxTVFJJTkc6MixPQkpFQ1Q6MyxNSVhfQVJSQVk6OCxPQkpFQ1RfRU5EOjksU1RSSUNUX0FSUkFZOjEwLERBVEU6MTEsTE9ORV9TVFJJTkc6MTJ9O3QuZGVmYXVsdD1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMub2Zmc2V0PTAsdGhpcy5yZWFkT2Zmc2V0PXRoaXMub2Zmc2V0fXJlc29sdmUoZSx0KXtpZih0PDMpdGhyb3cgbmV3IEVycm9yKFwibm90IGVub3VnaCBkYXRhIGZvciBtZXRhaW5mb1wiKTtjb25zdCBpPXt9LHM9dGhpcy5wYXJzZVZhbHVlKGUpLHI9dGhpcy5wYXJzZVZhbHVlKGUsdC1zLmJvZHlTaXplKTtyZXR1cm4gaVtzLmRhdGFdPXIuZGF0YSx0aGlzLnJlc2V0U3RhdHVzKCksaX1yZXNldFN0YXR1cygpe3RoaXMub2Zmc2V0PTAsdGhpcy5yZWFkT2Zmc2V0PXRoaXMub2Zmc2V0fXBhcnNlU3RyaW5nKGUpe2NvbnN0IHQ9bmV3IERhdGFWaWV3KGUsdGhpcy5yZWFkT2Zmc2V0KS5nZXRVaW50MTYoMCwhcy5pc0xlKTtsZXQgaT1cIlwiO2k9dD4wP3MuVVRGOC5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoZSx0aGlzLnJlYWRPZmZzZXQrMix0KSk6XCJcIjtsZXQgcj10KzI7cmV0dXJuIHRoaXMucmVhZE9mZnNldCs9cix7ZGF0YTppLGJvZHlTaXplOnQrMn19cGFyc2VEYXRlKGUsdCl7Y29uc3QgaT1uZXcgRGF0YVZpZXcoZSx0aGlzLnJlYWRPZmZzZXQsdCk7bGV0IHI9aS5nZXRGbG9hdDY0KDAsIXMuaXNMZSk7cmV0dXJuIHIrPTYwKmkuZ2V0SW50MTYoOCwhcy5pc0xlKSoxZTMsdGhpcy5yZWFkT2Zmc2V0Kz0xMCx7ZGF0YTpuZXcgRGF0ZShyKSxib2R5U2l6ZToxMH19cGFyc2VPYmplY3QoZSx0KXtjb25zdCBpPXRoaXMucGFyc2VTdHJpbmcoZSx0KSxzPXRoaXMucGFyc2VWYWx1ZShlLHQtaS5ib2R5U2l6ZSk7cmV0dXJue2RhdGE6e25hbWU6aS5kYXRhLHZhbHVlOnMuZGF0YX0sYm9keVNpemU6aS5ib2R5U2l6ZStzLmJvZHlTaXplLGlzT2JqRW5kOnMuaXNPYmpFbmR9fXBhcnNlTG9uZ1N0cmluZyhlKXtjb25zdCB0PW5ldyBEYXRhVmlldyhlLHRoaXMucmVhZE9mZnNldCkuZ2V0VWludDMyKDAsIXMuaXNMZSk7bGV0IGk9XCJcIjtyZXR1cm4gaT10PjA/cy5VVEY4LmRlY29kZShuZXcgVWludDhBcnJheShlLHRoaXMucmVhZE9mZnNldCsyLHQpKTpcIlwiLHRoaXMucmVhZE9mZnNldCs9dCs0LHtkYXRhOmksYm9keVNpemU6dCs0fX1wYXJzZVZhbHVlKGUsdCl7bGV0IGk9bmV3IEFycmF5QnVmZmVyO2k9ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyP2U6ZS5idWZmZXI7Y29uc3R7TlVNQkVSOmEsQk9PTEVBTjpuLFNUUklORzpvLE9CSkVDVDpkLE1JWF9BUlJBWTpsLE9CSkVDVF9FTkQ6aCxTVFJJQ1RfQVJSQVk6dSxEQVRFOmMsTE9ORV9TVFJJTkc6Zn09cixwPW5ldyBEYXRhVmlldyhpLHRoaXMucmVhZE9mZnNldCx0KTtsZXQgbT0hMTtjb25zdCBnPXAuZ2V0VWludDgoMCk7bGV0IF89MTt0aGlzLnJlYWRPZmZzZXQrPTE7bGV0IHk9bnVsbDtzd2l0Y2goZyl7Y2FzZSBhOnk9cC5nZXRGbG9hdDY0KDEsIXMuaXNMZSksdGhpcy5yZWFkT2Zmc2V0Kz04LF8rPTg7YnJlYWs7Y2FzZSBuOnk9ISFwLmdldFVpbnQ4KDEpLHRoaXMucmVhZE9mZnNldCs9MSxfKz0xO2JyZWFrO2Nhc2Ugbzp7Y29uc3QgZT10aGlzLnBhcnNlU3RyaW5nKGkpO3k9ZS5kYXRhLF8rPWUuYm9keVNpemU7YnJlYWt9Y2FzZSBkOnt5PXt9O2xldCBlPTA7Zm9yKDE2Nzc3MjE1JnAuZ2V0VWludDMyKHQtNCwhcy5pc0xlKSYmKGU9Myk7Xzx0LTQ7KXtjb25zdCBzPXRoaXMucGFyc2VPYmplY3QoaSx0LV8tZSk7aWYocy5pc09iamVjdEVuZClicmVhazt5W3MuZGF0YS5uYW1lXT1zLmRhdGEudmFsdWUsXys9cy5ib2R5U2l6ZX1pZihfPD10LTMpezk9PT0oMTY3NzcyMTUmcC5nZXRVaW50MzIoXy0xLCFzLmlzTGUpKSYmKHRoaXMucmVhZE9mZnNldCs9MyxfKz0zKX1icmVha31jYXNlIGw6e3k9e30sXys9NCx0aGlzLnJlYWRPZmZzZXQrPTQ7bGV0IGU9MDtmb3IoOT09KDE2Nzc3MjE1JnAuZ2V0VWludDMyKHQtNCwhcy5pc0xlKSkmJihlPTMpO188dC04Oyl7Y29uc3Qgcz10aGlzLnBhcnNlT2JqZWN0KGksdC1fLWUpO2lmKHMuaXNPYmplY3RFbmQpYnJlYWs7eVtzLmRhdGEubmFtZV09cy5kYXRhLnZhbHVlLF8rPXMuYm9keVNpemV9aWYoXzw9dC0zKXs5PT09KDE2Nzc3MjE1JnAuZ2V0VWludDMyKF8tMSwhcy5pc0xlKSkmJihfKz0zLHRoaXMucmVhZE9mZnNldCs9Myl9YnJlYWt9Y2FzZSBoOnk9bnVsbCxtPSEwO2JyZWFrO2Nhc2UgdTp7eT1bXTtjb25zdCBlPXAuZ2V0VWludDMyKDEsIXMuaXNMZSk7Xys9NCx0aGlzLnJlYWRPZmZzZXQrPTQ7Zm9yKGxldCBzPTA7czxlO3MrKyl7Y29uc3QgZT10aGlzLnBhcnNlVmFsdWUoaSx0LV8pO3kucHVzaChlLmRhdGEpLF8rPWUuYm9keVNpemV9YnJlYWt9Y2FzZSBjOntjb25zdCBlPXRoaXMucGFyc2VEYXRlKGksdC0xKTt5PWUuZGF0YSxfKz1lLmJvZHlTaXplO2JyZWFrfWNhc2UgZjp7Y29uc3QgZT10aGlzLnBhcnNlTG9uZ1N0cmluZyhpLHQtMSk7eT1lLmRhdGEsXys9ZS5ib2R5U2l6ZTticmVha31kZWZhdWx0Ol89dH1yZXR1cm57ZGF0YTp5LGJvZHlTaXplOl8saXNPYmpFbmQ6bX19fX0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz17TXA0UmVtdXhlcjppKDM3KS5kZWZhdWx0fX0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzLHI9aSgwKSxhPWkoMzgpLG49KHM9YSkmJnMuX19lc01vZHVsZT9zOntkZWZhdWx0OnN9O2NvbnN0IG89ci5FVkVOVFMuUkVNVVhfRVZFTlRTO2NsYXNzIGR7Y29uc3RydWN0b3IoKXt0aGlzLl9kdHNCYXNlPTAsdGhpcy5faXNEdHNCYXNlSW5pdGVkPSExLHRoaXMuX2F1ZGlvTmV4dER0cz1udWxsLHRoaXMuX3ZpZGVvTmV4dER0cz1udWxsLHRoaXMuX3ZpZGVvU2VnbWVudExpc3Q9bmV3IHIuTWVkaWFTZWdtZW50TGlzdChcInZpZGVvXCIpLHRoaXMuX2F1ZGlvU2VnbWVudExpc3Q9bmV3IHIuTWVkaWFTZWdtZW50TGlzdChcImF1ZGlvXCIpO2NvbnN0e2Jyb3dzZXI6ZX09ci5zbmlmZmVyO3RoaXMuX2ZpbGxTaWxlbmNlRnJhbWU9XCJpZVwiPT09ZSx0aGlzLmlzRmlyc3RWaWRlbz0hMCx0aGlzLmlzRmlyc3RBdWRpbz0hMCx0aGlzLnZpZGVvQWxsRHVyYXRpb249MCx0aGlzLmF1ZGlvQWxsRHVyYXRpb249MH1pbml0KCl7dGhpcy5vbihvLlJFTVVYX01FRElBLHRoaXMucmVtdXguYmluZCh0aGlzKSksdGhpcy5vbihvLlJFTVVYX01FVEFEQVRBLHRoaXMub25NZXRhRGF0YVJlYWR5LmJpbmQodGhpcykpLHRoaXMub24oby5ERVRFQ1RfQ0hBTkdFX1NUUkVBTSx0aGlzLnJlc2V0RHRzQmFzZS5iaW5kKHRoaXMpKX1kZXN0cm95KCl7dGhpcy5fZHRzQmFzZT0tMSx0aGlzLl9kdHNCYXNlSW5pdGVkPSExLHRoaXMuX3ZpZGVvTmV4dER0cz1udWxsLHRoaXMuX2F1ZGlvTmV4dER0cz1udWxsLHRoaXMuX3ZpZGVvU2VnbWVudExpc3QuY2xlYXIoKSx0aGlzLl9hdWRpb1NlZ21lbnRMaXN0LmNsZWFyKCksdGhpcy5fdmlkZW9TZWdtZW50TGlzdD1udWxsLHRoaXMuX2F1ZGlvU2VnbWVudExpc3Q9bnVsbH1yZW11eCgpe2NvbnN0e2F1ZGlvVHJhY2s6ZSx2aWRlb1RyYWNrOnR9PXRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoXCJUUkFDS1NcIik7IXRoaXMuX2lzRHRzQmFzZUluaXRlZCYmdGhpcy5jYWxjRHRzQmFzZShlLHQpLHRoaXMuX3JlbXV4VmlkZW8odCksdGhpcy5fcmVtdXhBdWRpbyhlKX1yZXNldER0c0Jhc2UoKXt0aGlzLl9kdHNCYXNlPTAsdGhpcy5fZHRzQmFzZUluaXRlZD0hMX1zZWVrKCl7dGhpcy5fdmlkZW9OZXh0RHRzPW51bGwsdGhpcy5fYXVkaW9OZXh0RHRzPW51bGwsdGhpcy5fdmlkZW9TZWdtZW50TGlzdC5jbGVhcigpLHRoaXMuX2F1ZGlvU2VnbWVudExpc3QuY2xlYXIoKX1vbk1ldGFEYXRhUmVhZHkoZSl7bGV0IHQ7aWYoXCJhdWRpb1wiPT09ZSl7Y29uc3R7YXVkaW9UcmFjazplfT10aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKFwiVFJBQ0tTXCIpO3Q9ZX1lbHNle2NvbnN0e3ZpZGVvVHJhY2s6ZX09dGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZShcIlRSQUNLU1wiKTt0PWV9bGV0IGk9dGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZShcIlBSRV9TT1VSQ0VfQlVGRkVSXCIpLHM9aS5nZXRTb3VyY2UoZSk7c3x8KHM9aS5jcmVhdGVTb3VyY2UoZSkpLHMubWltZXR5cGU9dC5tZXRhLmNvZGVjLHMuaW5pdD10aGlzLnJlbXV4SW5pdFNlZ21lbnQoZSx0Lm1ldGEpLHRoaXMuZW1pdChvLklOSVRfU0VHTUVOVCxlKX1yZW11eEluaXRTZWdtZW50KGUsdCl7bGV0IGk9bmV3IHIuQnVmZmVyLHM9bi5kZWZhdWx0LmZ0eXAoKSxhPW4uZGVmYXVsdC5tb292KHt0eXBlOmUsbWV0YTp0fSk7cmV0dXJuIGkud3JpdGUocyxhKSxpfWNhbGNEdHNCYXNlKGUsdCl7aWYoIWUuc2FtcGxlcy5sZW5ndGgmJiF0LnNhbXBsZXMubGVuZ3RoKXJldHVybjtsZXQgaT0xLzAscz0xLzA7ZS5zYW1wbGVzJiZlLnNhbXBsZXMubGVuZ3RoJiYoaT1lLnNhbXBsZXNbMF0uZHRzKSx0LnNhbXBsZXMmJnQuc2FtcGxlcy5sZW5ndGgmJihzPXQuc2FtcGxlc1swXS5kdHMpLHRoaXMuX2R0c0Jhc2U9TWF0aC5taW4oaSxzKSx0aGlzLl9pc0R0c0Jhc2VJbml0ZWQ9ITB9X3JlbXV4VmlkZW8oZSl7Y29uc3QgdD1lO2lmKCFlLnNhbXBsZXN8fCFlLnNhbXBsZXMubGVuZ3RoKXJldHVybjtsZXR7c2FtcGxlczppfT10LHM9LTEsYT1udWxsO2NvbnN0IGQ9W10sbD17c2FtcGxlczpbXX07Zm9yKDtpLmxlbmd0aDspe2NvbnN0IGU9aS5zaGlmdCgpLHtpc0tleWZyYW1lOnQsb3B0aW9uczpyfT1lO2lmKCF0aGlzLmlzRmlyc3RBdWRpbyYmciYmci5tZXRhKXthPXRoaXMucmVtdXhJbml0U2VnbWVudChcInZpZGVvXCIsci5tZXRhKSxyLm1ldGE9bnVsbCxpLnVuc2hpZnQoZSksci5pc0NvbnRpbnVlfHx0aGlzLnJlc2V0RHRzQmFzZSgpO2JyZWFrfWxldCBuLG8saD1lLmR0cy10aGlzLl9kdHNCYXNlOy0xPT09cyYmKHM9aCksdm9pZCAwIT09ZS5wdHMmJihuPShvPWUucHRzLXRoaXMuX2R0c0Jhc2UpLWgpLHZvaWQgMCE9PWUuY3RzJiYobz1lLmN0cytoLG49ZS5jdHMpO2xldCB1PXtidWZmZXI6W10sc2l6ZTowfTtsLnNhbXBsZXMucHVzaCh1KSx1LmJ1ZmZlci5wdXNoKGUuZGF0YSksdS5zaXplKz1lLmRhdGEuYnl0ZUxlbmd0aDtsZXQgYz0wO2lmKGkubGVuZ3RoPj0xKXtjPWlbMF0uZHRzLXRoaXMuX2R0c0Jhc2UtaH1lbHNlIGM9ZC5sZW5ndGg+PTE/ZFtkLmxlbmd0aC0xXS5kdXJhdGlvbjp0aGlzLnZpZGVvTWV0YS5yZWZTYW1wbGVEdXJhdGlvbjt0aGlzLnZpZGVvQWxsRHVyYXRpb24rPWMsZC5wdXNoKHtkdHM6aCxjdHM6bixwdHM6byxkYXRhOmUuZGF0YSxzaXplOmUuZGF0YS5ieXRlTGVuZ3RoLGlzS2V5ZnJhbWU6dCxkdXJhdGlvbjpjLGZsYWdzOntpc0xlYWRpbmc6MCxkZXBlbmRzT246dD8yOjEsaXNEZXBlbmRlZE9uOnQ/MTowLGhhc1JlZHVuZGFuY3k6MCxpc05vblN5bmM6dD8wOjF9LG9yaWdpbkR0czpoLHR5cGU6XCJ2aWRlb1wifSl9bGV0IGg9bmV3IHIuQnVmZmVyO2lmKGQubGVuZ3RoKXtjb25zdCBlPW4uZGVmYXVsdC5tb29mKHtpZDp0Lm1ldGEuaWQsdGltZTpzLHNhbXBsZXM6ZH0pLGk9bi5kZWZhdWx0Lm1kYXQobCk7aC53cml0ZShlLGkpLHRoaXMud3JpdGVUb1NvdXJjZShcInZpZGVvXCIsaCl9aWYoYSYmKHRoaXMud3JpdGVUb1NvdXJjZShcInZpZGVvXCIsYSksaS5sZW5ndGgpKXJldHVybiB0LnNhbXBsZXM9aSx0aGlzLl9yZW11eFZpZGVvKHQpO3RoaXMuaXNGaXJzdFZpZGVvPSExLHRoaXMuZW1pdChvLk1FRElBX1NFR01FTlQsXCJ2aWRlb1wiKTtjb25zdCB1PWRbZC5sZW5ndGgtMV07dGhpcy5fdmlkZW9OZXh0RHRzPXUuZHRzK3UuZHVyYXRpb24sdC5zYW1wbGVzPVtdLHQubGVuZ3RoPTB9X3JlbXV4QXVkaW8oZSl7Y29uc3R7c2FtcGxlczp0fT1lO2xldCBpPS0xLHM9W10sYT1udWxsO2NvbnN0IGQ9e3NhbXBsZXM6W119O2lmKCF0fHwhdC5sZW5ndGgpcmV0dXJuO2xldCBsPSExO2Zvcig7dC5sZW5ndGg7KXtsZXQgZT10LnNoaWZ0KCk7Y29uc3R7ZGF0YTpyLG9wdGlvbnM6bn09ZTtpZighdGhpcy5pc0ZpcnN0QXVkaW8mJm4mJm4ubWV0YSl7YT10aGlzLnJlbXV4SW5pdFNlZ21lbnQoXCJhdWRpb1wiLG4ubWV0YSksbi5tZXRhPW51bGwsdC51bnNoaWZ0KGUpLG4uaXNDb250aW51ZXx8dGhpcy5yZXNldER0c0Jhc2UoKTticmVha31sZXQgbz1lLmR0cy10aGlzLl9kdHNCYXNlO2NvbnN0IGg9bztsfHwoaT1vLGw9ITApO2xldCB1PTA7aWYodGhpcy5hdWRpb01ldGEucmVmU2FtcGxlRHVyYXRpb25GaXhlZCl1PXRoaXMuYXVkaW9NZXRhLnJlZlNhbXBsZUR1cmF0aW9uRml4ZWQ7ZWxzZSBpZih0Lmxlbmd0aD49MSl7dT10WzBdLmR0cy10aGlzLl9kdHNCYXNlLW99ZWxzZSB1PXMubGVuZ3RoPj0xP3Nbcy5sZW5ndGgtMV0uZHVyYXRpb246dGhpcy5hdWRpb01ldGEucmVmU2FtcGxlRHVyYXRpb247dGhpcy5hdWRpb0FsbER1cmF0aW9uKz11O2NvbnN0IGM9e2R0czpvLHB0czpvLGN0czowLHNpemU6ci5ieXRlTGVuZ3RoLGR1cmF0aW9uOmUuZHVyYXRpb24/ZS5kdXJhdGlvbjp1LGZsYWdzOntpc0xlYWRpbmc6MCxkZXBlbmRzT246Mixpc0RlcGVuZGVkT246MSxoYXNSZWR1bmRhbmN5OjAsaXNOb25TeW5jOjB9LGlzS2V5ZnJhbWU6ITAsb3JpZ2luRHRzOmgsdHlwZTpcImF1ZGlvXCJ9O2xldCBmPXtidWZmZXI6W10sc2l6ZTowfTtmLmJ1ZmZlci5wdXNoKHIpLGYuc2l6ZSs9ci5ieXRlTGVuZ3RoLGQuc2FtcGxlcy5wdXNoKGYpLHMucHVzaChjKX1jb25zdCBoPW5ldyByLkJ1ZmZlcjtpZihzLmxlbmd0aCl7Y29uc3QgdD1uLmRlZmF1bHQubW9vZih7aWQ6ZS5tZXRhLmlkLHRpbWU6aSxzYW1wbGVzOnN9KSxyPW4uZGVmYXVsdC5tZGF0KGQpO2gud3JpdGUodCxyKSx0aGlzLndyaXRlVG9Tb3VyY2UoXCJhdWRpb1wiLGgpfWlmKGEmJih0aGlzLndyaXRlVG9Tb3VyY2UoXCJhdWRpb1wiLGEpLHQubGVuZ3RoKSlyZXR1cm4gZS5zYW1wbGVzPXQsdGhpcy5fcmVtdXhBdWRpbyhlKTt0aGlzLmlzRmlyc3RBdWRpbz0hMSx0aGlzLmVtaXQoby5NRURJQV9TRUdNRU5ULFwiYXVkaW9cIixoKTtjb25zdCB1PXNbcy5sZW5ndGgtMV07dGhpcy5fdmlkZW9OZXh0RHRzPXUuZHRzK3UuZHVyYXRpb24sZS5zYW1wbGVzPVtdLGUubGVuZ3RoPTB9d3JpdGVUb1NvdXJjZShlLHQpe2xldCBpPXRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoXCJQUkVfU09VUkNFX0JVRkZFUlwiKSxzPWkuZ2V0U291cmNlKGUpO3N8fChzPWkuY3JlYXRlU291cmNlKGUpKSxzLmRhdGEucHVzaCh0KX1pbml0U2lsZW50QXVkaW8oZSx0KXtjb25zdCBpPWQuZ2V0U2lsZW50RnJhbWUodGhpcy5fYXVkaW9NZXRhLmNoYW5uZWxDb3VudCk7cmV0dXJue2R0czplLHB0czplLGN0czowLGR1cmF0aW9uOnQsdW5pdDppLHNpemU6aS5ieXRlTGVuZ3RoLG9yaWdpbkR0czplLHR5cGU6XCJ2aWRlb1wifX1nZXQgdmlkZW9NZXRhKCl7cmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoXCJUUkFDS1NcIikudmlkZW9UcmFjay5tZXRhfWdldCBhdWRpb01ldGEoKXtyZXR1cm4gdGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZShcIlRSQUNLU1wiKS5hdWRpb1RyYWNrLm1ldGF9c3RhdGljIGdldFNpbGVudEZyYW1lKGUpe3JldHVybiAxPT09ZT9uZXcgVWludDhBcnJheShbMCwyMDAsMCwxMjgsMzUsMTI4XSk6Mj09PWU/bmV3IFVpbnQ4QXJyYXkoWzMzLDAsNzMsMTQ0LDIsMjUsMCwzNSwxMjhdKTozPT09ZT9uZXcgVWludDhBcnJheShbMCwyMDAsMCwxMjgsMzIsMTMyLDEsMzgsNjQsOCwxMDAsMCwxNDJdKTo0PT09ZT9uZXcgVWludDhBcnJheShbMCwyMDAsMCwxMjgsMzIsMTMyLDEsMzgsNjQsOCwxMDAsMCwxMjgsNDQsMTI4LDgsMiw1Nl0pOjU9PT1lP25ldyBVaW50OEFycmF5KFswLDIwMCwwLDEyOCwzMiwxMzIsMSwzOCw2NCw4LDEwMCwwLDEzMCw0OCw0LDE1MywwLDMzLDE0NCwyLDU2XSk6Nj09PWU/bmV3IFVpbnQ4QXJyYXkoWzAsMjAwLDAsMTI4LDMyLDEzMiwxLDM4LDY0LDgsMTAwLDAsMTMwLDQ4LDQsMTUzLDAsMzMsMTQ0LDIsMCwxNzgsMCwzMiw4LDIyNF0pOm51bGx9fXQuZGVmYXVsdD1kfSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9aSgwKTtjbGFzcyBye3N0YXRpYyBzaXplKGUpe3JldHVybiBzLkJ1ZmZlci53cml0ZVVpbnQzMihlKX1zdGF0aWMgaW5pdEJveChlLHQsLi4uaSl7Y29uc3QgYT1uZXcgcy5CdWZmZXI7cmV0dXJuIGEud3JpdGUoci5zaXplKGUpLHIudHlwZSh0KSwuLi5pKSxhLmJ1ZmZlcn1zdGF0aWMgZXh0ZW5zaW9uKGUsdCl7cmV0dXJuIG5ldyBVaW50OEFycmF5KFtlLHQ+PjE2JjI1NSx0Pj44JjI1NSwyNTUmdF0pfXN0YXRpYyBmdHlwKCl7cmV0dXJuIHIuaW5pdEJveCgyNCxcImZ0eXBcIixuZXcgVWludDhBcnJheShbMTA1LDExNSwxMTEsMTA5LDAsMCwwLDEsMTA1LDExNSwxMTEsMTA5LDk3LDExOCw5OSw0OV0pKX1zdGF0aWMgbW9vdih7dHlwZTplLG1ldGE6dH0pe2xldCBpLHM9OCxhPXIubXZoZCh0LmR1cmF0aW9uLHQudGltZXNjYWxlKTtpPVwidmlkZW9cIj09PWU/ci52aWRlb1RyYWsodCk6ci5hdWRpb1RyYWsodCk7bGV0IG49ci5tdmV4KHQuZHVyYXRpb24sdC50aW1lc2NhbGV8fDFlMyx0LmlkKTtyZXR1cm5bYSxpLG5dLmZvckVhY2goZT0+e3MrPWUuYnl0ZUxlbmd0aH0pLHIuaW5pdEJveChzLFwibW9vdlwiLGEsaSxuKX1zdGF0aWMgbXZoZChlLHQ9MWUzKXtsZXQgaT1uZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsdD4+PjI0JjI1NSx0Pj4+MTYmMjU1LHQ+Pj44JjI1NSwyNTUmdCxlPj4+MjQmMjU1LGU+Pj4xNiYyNTUsZT4+PjgmMjU1LDI1NSZlLDAsMSwwLDAsMSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDY0LDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1NSwyNTUsMjU1LDI1NV0pO3JldHVybiByLmluaXRCb3goOCtpLmxlbmd0aCxcIm12aGRcIixuZXcgVWludDhBcnJheShpKSl9c3RhdGljIHZpZGVvVHJhayhlKXtsZXQgdD04LGk9ci50a2hkKHtpZDoxLGR1cmF0aW9uOmUuZHVyYXRpb24sdGltZXNjYWxlOmUudGltZXNjYWxlfHwxZTMsd2lkdGg6ZS5wcmVzZW50V2lkdGgsaGVpZ2h0OmUucHJlc2VudEhlaWdodCx0eXBlOlwidmlkZW9cIn0pLHM9ci5tZGlhKHt0eXBlOlwidmlkZW9cIix0aW1lc2NhbGU6ZS50aW1lc2NhbGV8fDFlMyxkdXJhdGlvbjplLmR1cmF0aW9uLGF2Y2M6ZS5hdmNjLHBhclJhdGlvOmUucGFyUmF0aW8sd2lkdGg6ZS5wcmVzZW50V2lkdGgsaGVpZ2h0OmUucHJlc2VudEhlaWdodH0pO3JldHVybltpLHNdLmZvckVhY2goZT0+e3QrPWUuYnl0ZUxlbmd0aH0pLHIuaW5pdEJveCh0LFwidHJha1wiLGkscyl9c3RhdGljIGF1ZGlvVHJhayhlKXtsZXQgdD04LGk9ci50a2hkKHtpZDoyLGR1cmF0aW9uOmUuZHVyYXRpb24sdGltZXNjYWxlOmUudGltZXNjYWxlfHwxZTMsd2lkdGg6MCxoZWlnaHQ6MCx0eXBlOlwiYXVkaW9cIn0pLHM9ci5tZGlhKHt0eXBlOlwiYXVkaW9cIix0aW1lc2NhbGU6ZS50aW1lc2NhbGV8fDFlMyxkdXJhdGlvbjplLmR1cmF0aW9uLGNoYW5uZWxDb3VudDplLmNoYW5uZWxDb3VudCxzYW1wbGVyYXRlOmUuc2FtcGxlUmF0ZSxjb25maWc6ZS5jb25maWd9KTtyZXR1cm5baSxzXS5mb3JFYWNoKGU9Pnt0Kz1lLmJ5dGVMZW5ndGh9KSxyLmluaXRCb3godCxcInRyYWtcIixpLHMpfXN0YXRpYyB0a2hkKGUpe2xldCB0PWUuaWQsaT1lLmR1cmF0aW9uLHM9ZS53aWR0aCxhPWUuaGVpZ2h0LG49bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDcsMCwwLDAsMCwwLDAsMCwwLHQ+Pj4yNCYyNTUsdD4+PjE2JjI1NSx0Pj4+OCYyNTUsMjU1JnQsMCwwLDAsMCxpPj4+MjQmMjU1LGk+Pj4xNiYyNTUsaT4+PjgmMjU1LDI1NSZpLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDY0LDAsMCwwLHM+Pj44JjI1NSwyNTUmcywwLDAsYT4+PjgmMjU1LDI1NSZhLDAsMF0pO3JldHVybiByLmluaXRCb3goOCtuLmJ5dGVMZW5ndGgsXCJ0a2hkXCIsbil9c3RhdGljIGVkdHMoZSl7bGV0IHQ9bmV3IHMuQnVmZmVyLGk9ZS5kdXJhdGlvbixhPWUubWVkaWFUaW1lO3JldHVybiB0LndyaXRlKHIuc2l6ZSgzNiksci50eXBlKFwiZWR0c1wiKSksdC53cml0ZShyLnNpemUoMjgpLHIudHlwZShcImVsc3RcIikpLHQud3JpdGUobmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDEsaT4+MjQmMjU1LGk+PjE2JjI1NSxpPj44JjI1NSwyNTUmaSxhPj4yNCYyNTUsYT4+MTYmMjU1LGE+PjgmMjU1LDI1NSZhLDAsMCwwLDFdKSksdC5idWZmZXJ9c3RhdGljIG1kaWEoZSl7bGV0IHQ9OCxpPXIubWRoZChlLnRpbWVzY2FsZSxlLmR1cmF0aW9uKSxzPXIuaGRscihlLnR5cGUpLGE9ci5taW5mKGUpO3JldHVybltpLHMsYV0uZm9yRWFjaChlPT57dCs9ZS5ieXRlTGVuZ3RofSksci5pbml0Qm94KHQsXCJtZGlhXCIsaSxzLGEpfXN0YXRpYyBtZGhkKGU9MWUzLHQpe2xldCBpPW5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDAsZT4+PjI0JjI1NSxlPj4+MTYmMjU1LGU+Pj44JjI1NSwyNTUmZSx0Pj4+MjQmMjU1LHQ+Pj4xNiYyNTUsdD4+PjgmMjU1LDI1NSZ0LDg1LDE5NiwwLDBdKTtyZXR1cm4gci5pbml0Qm94KDEyK2kuYnl0ZUxlbmd0aCxcIm1kaGRcIixyLmV4dGVuc2lvbigwLDApLGkpfXN0YXRpYyBoZGxyKGUpe2xldCB0PVswLDAsMCwwLDAsMCwwLDAsMTE4LDEwNSwxMDAsMTAxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDg2LDEwNSwxMDAsMTAxLDExMSw3Miw5NywxMTAsMTAwLDEwOCwxMDEsMTE0LDBdO3JldHVyblwiYXVkaW9cIj09PWUmJih0LnNwbGljZSg4LDQsMTE1LDExMSwxMTcsMTEwKSx0LnNwbGljZSgyNCwxMyw4MywxMTEsMTE3LDExMCwxMDAsNzIsOTcsMTEwLDEwMCwxMDgsMTAxLDExNCwwKSksci5pbml0Qm94KDgrdC5sZW5ndGgsXCJoZGxyXCIsbmV3IFVpbnQ4QXJyYXkodCkpfXN0YXRpYyBtaW5mKGUpe2xldCB0PTgsaT1cInZpZGVvXCI9PT1lLnR5cGU/ci52bWhkKCk6ci5zbWhkKCkscz1yLmRpbmYoKSxhPXIuc3RibChlKTtyZXR1cm5baSxzLGFdLmZvckVhY2goZT0+e3QrPWUuYnl0ZUxlbmd0aH0pLHIuaW5pdEJveCh0LFwibWluZlwiLGkscyxhKX1zdGF0aWMgdm1oZCgpe3JldHVybiByLmluaXRCb3goMjAsXCJ2bWhkXCIsbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwXSkpfXN0YXRpYyBzbWhkKCl7cmV0dXJuIHIuaW5pdEJveCgxNixcInNtaGRcIixuZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwXSkpfXN0YXRpYyBkaW5mKCl7bGV0IGU9bmV3IHMuQnVmZmVyO3JldHVybiBlLndyaXRlKHIuc2l6ZSgzNiksci50eXBlKFwiZGluZlwiKSxyLnNpemUoMjgpLHIudHlwZShcImRyZWZcIiksbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMSwwLDAsMCwxMiwxMTcsMTE0LDEwOCwzMiwwLDAsMCwxXSkpLGUuYnVmZmVyfXN0YXRpYyBzdGJsKGUpe2xldCB0PTgsaT1yLnN0c2QoZSkscz1yLnN0dHMoKSxhPXIuc3RzYygpLG49ci5zdHN6KCksbz1yLnN0Y28oKTtyZXR1cm5baSxzLGEsbixvXS5mb3JFYWNoKGU9Pnt0Kz1lLmJ5dGVMZW5ndGh9KSxyLmluaXRCb3godCxcInN0YmxcIixpLHMsYSxuLG8pfXN0YXRpYyBzdHNkKGUpe2xldCB0O3JldHVybiB0PVwiYXVkaW9cIj09PWUudHlwZT9yLm1wNGEoZSk6ci5hdmMxKGUpLHIuaW5pdEJveCgxNit0LmJ5dGVMZW5ndGgsXCJzdHNkXCIsci5leHRlbnNpb24oMCwwKSxuZXcgVWludDhBcnJheShbMCwwLDAsMV0pLHQpfXN0YXRpYyBtcDRhKGUpe2xldCB0PW5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwLDAsZS5jaGFubmVsQ291bnQsMCwxNiwwLDAsMCwwLGUuc2FtcGxlcmF0ZT4+OCYyNTUsMjU1JmUuc2FtcGxlcmF0ZSwwLDBdKSxpPXIuZXNkcyhlLmNvbmZpZyk7cmV0dXJuIHIuaW5pdEJveCg4K3QuYnl0ZUxlbmd0aCtpLmJ5dGVMZW5ndGgsXCJtcDRhXCIsdCxpKX1zdGF0aWMgZXNkcyhlPVs0MywxNDYsOCwwXSl7Y29uc3QgdD1lLmxlbmd0aDtsZXQgaT1uZXcgcy5CdWZmZXIsYT1uZXcgVWludDhBcnJheShbMCwwLDAsMCwzLDIzK3QsMCwxLDAsNCwxNSt0LDY0LDIxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCw1XS5jb25jYXQoW3RdKS5jb25jYXQoZSkuY29uY2F0KFs2LDEsMl0pKTtyZXR1cm4gaS53cml0ZShyLnNpemUoOCthLmJ5dGVMZW5ndGgpLHIudHlwZShcImVzZHNcIiksYSksaS5idWZmZXJ9c3RhdGljIGF2YzEoZSl7bGV0IHQ9bmV3IHMuQnVmZmVyLGk9ZS53aWR0aCxhPWUuaGVpZ2h0LG49ZS5wYXJSYXRpby5oZWlnaHQsbz1lLnBhclJhdGlvLndpZHRoLGQ9ZS5hdmNjLGw9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLGk+PjgmMjU1LDI1NSZpLGE+PjgmMjU1LDI1NSZhLDAsNzIsMCwwLDAsNzIsMCwwLDAsMCwwLDAsMCwxLDE4LDEwMCw5NywxMDUsMTA4LDEyMSwxMDksMTExLDExNiwxMDUsMTExLDExMCw0NywxMDQsMTA4LDExNSw0NiwxMDYsMTE1LDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyNCwxNywxN10pLGg9bmV3IFVpbnQ4QXJyYXkoWzAsMjgsMTU2LDEyOCwwLDQ1LDE5OCwxOTIsMCw0NSwxOTgsMTkyXSksdT1uZXcgVWludDhBcnJheShbbj4+MjQsbj4+MTYmMjU1LG4+PjgmMjU1LDI1NSZuLG8+PjI0LG8+PjE2JjI1NSxvPj44JjI1NSwyNTUmb10pO3JldHVybiB0LndyaXRlKHIuc2l6ZSg0MCtsLmJ5dGVMZW5ndGgrZC5ieXRlTGVuZ3RoK2guYnl0ZUxlbmd0aCksci50eXBlKFwiYXZjMVwiKSxsLHIuc2l6ZSg4K2QuYnl0ZUxlbmd0aCksci50eXBlKFwiYXZjQ1wiKSxkLHIuc2l6ZSgyMCksci50eXBlKFwiYnRydFwiKSxoLHIuc2l6ZSgxNiksci50eXBlKFwicGFzcFwiKSx1KSx0LmJ1ZmZlcn1zdGF0aWMgc3R0cygpe2xldCBlPW5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDBdKTtyZXR1cm4gci5pbml0Qm94KDE2LFwic3R0c1wiLGUpfXN0YXRpYyBzdHNjKCl7bGV0IGU9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMF0pO3JldHVybiByLmluaXRCb3goMTYsXCJzdHNjXCIsZSl9c3RhdGljIHN0Y28oKXtsZXQgZT1uZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwXSk7cmV0dXJuIHIuaW5pdEJveCgxNixcInN0Y29cIixlKX1zdGF0aWMgc3Rzeigpe2xldCBlPW5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF0pO3JldHVybiByLmluaXRCb3goMjAsXCJzdHN6XCIsZSl9c3RhdGljIG12ZXgoZSx0PTFlMyxpKXtsZXQgYT1uZXcgcy5CdWZmZXIsbj1zLkJ1ZmZlci53cml0ZVVpbnQzMihlKTtyZXR1cm4gYS53cml0ZShyLnNpemUoNTYpLHIudHlwZShcIm12ZXhcIiksci5zaXplKDE2KSxyLnR5cGUoXCJtZWhkXCIpLHIuZXh0ZW5zaW9uKDAsMCksbixyLnRyZXgoaSkpLGEuYnVmZmVyfXN0YXRpYyB0cmV4KGUpe2xldCB0PW5ldyBVaW50OEFycmF5KFswLDAsMCwwLGU+PjI0LGU+PjE2JjI1NSxlPj44JjI1NSwyNTUmZSwwLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLDEsMCwxXSk7cmV0dXJuIHIuaW5pdEJveCg4K3QuYnl0ZUxlbmd0aCxcInRyZXhcIix0KX1zdGF0aWMgbW9vZihlKXtsZXQgdD04LGk9ci5tZmhkKCkscz1yLnRyYWYoZSk7cmV0dXJuW2ksc10uZm9yRWFjaChlPT57dCs9ZS5ieXRlTGVuZ3RofSksci5pbml0Qm94KHQsXCJtb29mXCIsaSxzKX1zdGF0aWMgbWZoZCgpe2xldCBlPXMuQnVmZmVyLndyaXRlVWludDMyKHIuc2VxdWVuY2UpO3JldHVybiByLnNlcXVlbmNlKz0xLHIuaW5pdEJveCgxNixcIm1maGRcIixyLmV4dGVuc2lvbigwLDApLGUpfXN0YXRpYyB0cmFmKGUpe2xldCB0PTgsaT1yLnRmaGQoZS5pZCkscz1yLnRmZHQoZS50aW1lKSxhPXIuc2R0cChlKSxuPXIudHJ1bihlLGEuYnl0ZUxlbmd0aCk7cmV0dXJuW2kscyxuLGFdLmZvckVhY2goZT0+e3QrPWUuYnl0ZUxlbmd0aH0pLHIuaW5pdEJveCh0LFwidHJhZlwiLGkscyxuLGEpfXN0YXRpYyB0ZmhkKGUpe2xldCB0PXMuQnVmZmVyLndyaXRlVWludDMyKGUpO3JldHVybiByLmluaXRCb3goMTYsXCJ0ZmhkXCIsci5leHRlbnNpb24oMCwwKSx0KX1zdGF0aWMgdGZkdChlKXtyZXR1cm4gci5pbml0Qm94KDE2LFwidGZkdFwiLHIuZXh0ZW5zaW9uKDAsMCkscy5CdWZmZXIud3JpdGVVaW50MzIoZSkpfXN0YXRpYyB0cnVuKGUsdCl7bGV0IGk9bmV3IHMuQnVmZmVyLGE9cy5CdWZmZXIud3JpdGVVaW50MzIoZS5zYW1wbGVzLmxlbmd0aCksbj1zLkJ1ZmZlci53cml0ZVVpbnQzMig5MisxNiplLnNhbXBsZXMubGVuZ3RoK3QpO3JldHVybiBpLndyaXRlKHIuc2l6ZSgyMCsxNiplLnNhbXBsZXMubGVuZ3RoKSxyLnR5cGUoXCJ0cnVuXCIpLG5ldyBVaW50OEFycmF5KFswLDAsMTUsMV0pLGEsbiksZS5zYW1wbGVzLmZvckVhY2goZT0+e2NvbnN0IHQ9ZS5mbGFncztpLndyaXRlKG5ldyBVaW50OEFycmF5KFtlLmR1cmF0aW9uPj4+MjQmMjU1LGUuZHVyYXRpb24+Pj4xNiYyNTUsZS5kdXJhdGlvbj4+PjgmMjU1LDI1NSZlLmR1cmF0aW9uLGUuc2l6ZT4+PjI0JjI1NSxlLnNpemU+Pj4xNiYyNTUsZS5zaXplPj4+OCYyNTUsMjU1JmUuc2l6ZSx0LmlzTGVhZGluZzw8Mnx0LmRlcGVuZHNPbix0LmlzRGVwZW5kZWRPbjw8Nnx0Lmhhc1JlZHVuZGFuY3k8PDR8dC5pc05vblN5bmMsMCwwLGUuY3RzPj4+MjQmMjU1LGUuY3RzPj4+MTYmMjU1LGUuY3RzPj4+OCYyNTUsMjU1JmUuY3RzXSkpfSksaS5idWZmZXJ9c3RhdGljIHNkdHAoZSl7bGV0IHQ9bmV3IHMuQnVmZmVyO3JldHVybiB0LndyaXRlKHIuc2l6ZSgxMitlLnNhbXBsZXMubGVuZ3RoKSxyLnR5cGUoXCJzZHRwXCIpLHIuZXh0ZW5zaW9uKDAsMCkpLGUuc2FtcGxlcy5mb3JFYWNoKGU9Pntjb25zdCBpPWUuZmxhZ3Mscz1pLmlzTGVhZGluZzw8NnxpLmRlcGVuZHNPbjw8NHxpLmlzRGVwZW5kZWRPbjw8MnxpLmhhc1JlZHVuZGFuY3k7dC53cml0ZShuZXcgVWludDhBcnJheShbc10pKX0pLHQuYnVmZmVyfXN0YXRpYyBtZGF0KGUpe2xldCB0PW5ldyBzLkJ1ZmZlcixpPTg7ZS5zYW1wbGVzLmZvckVhY2goZT0+e2krPWUuc2l6ZX0pLHQud3JpdGUoci5zaXplKGkpLHIudHlwZShcIm1kYXRcIikpO2xldCBhPW5ldyBVaW50OEFycmF5KGkpLG49MDtyZXR1cm4gYS5zZXQodC5idWZmZXIsbiksbis9OCxlLnNhbXBsZXMuZm9yRWFjaChlPT57ZS5idWZmZXIuZm9yRWFjaChlPT57YS5zZXQoZSxuKSxuKz1lLmJ5dGVMZW5ndGh9KX0pLGF9fXIudHlwZT1lPT5uZXcgVWludDhBcnJheShbZS5jaGFyQ29kZUF0KDApLGUuY2hhckNvZGVBdCgxKSxlLmNoYXJDb2RlQXQoMiksZS5jaGFyQ29kZUF0KDMpXSksci5zZXF1ZW5jZT0xLHQuZGVmYXVsdD1yfSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXtGZXRjaExvYWRlcjppKDQwKS5kZWZhdWx0fX0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IHM9aSgwKS5FVkVOVFMuTE9BREVSX0VWRU5UUyxyPTAsYT0xLG49MixvPTM7dC5kZWZhdWx0PWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuY29uZmlncz1PYmplY3QuYXNzaWduKHt9LGUpLHRoaXMudXJsPW51bGwsdGhpcy5zdGF0dXM9MCx0aGlzLmVycm9yPW51bGwsdGhpcy5fcmVhZGVyPW51bGwsdGhpcy5fY2FuY2VsZWQ9ITEsdGhpcy5fZGVzdHJveWVkPSExLHRoaXMucmVhZHR5cGU9dGhpcy5jb25maWdzLnJlYWR0eXBlLHRoaXMuYnVmZmVyPXRoaXMuY29uZmlncy5idWZmZXJ8fFwiTE9BREVSX0JVRkZFUlwiLHRoaXMuX2xvYWRlclRhc2tObz0wfWluaXQoKXt0aGlzLm9uKHMuTEFERVJfU1RBUlQsdGhpcy5sb2FkLmJpbmQodGhpcykpfXN0YXRpYyBnZXQgdHlwZSgpe3JldHVyblwibG9hZGVyXCJ9bG9hZChlLHQpe2xldCBpPXRoaXM7dGhpcy51cmw9ZSx0aGlzLl9jYW5jZWxlZD0hMTtsZXQgcj10aGlzLmdldFBhcmFtcyh0KTtyZXR1cm4gaS5sb2FkaW5nPSEwLGZldGNoKHRoaXMudXJsLHIpLnRoZW4oKGZ1bmN0aW9uKGUpe2lmKGUub2spcmV0dXJuIGkuc3RhdHVzPWUuc3RhdHVzLGkuX29uRmV0Y2hSZXNwb25zZShlKTtpLmxvYWRpbmc9ITEsaS5lbWl0KHMuTE9BREVSX0VSUk9SLGkuVEFHLG5ldyBFcnJvcihcImludmFsaWQgcmVzcG9uc2UuXCIpKX0pKS5jYXRjaCgoZnVuY3Rpb24oZSl7dGhyb3cgaS5sb2FkaW5nPSExLGkuZW1pdChzLkxPQURFUl9FUlJPUixpLlRBRyxlKSxuZXcgRXJyb3IoZS5tZXNzYWdlKX0pKX1fb25GZXRjaFJlc3BvbnNlKGUpe2xldCB0PXRoaXMsaT10aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKHRoaXMuYnVmZmVyKTt0aGlzLl9sb2FkZXJUYXNrTm8rKztsZXQgZD10aGlzLl9sb2FkZXJUYXNrTm87aWYoITA9PT1lLm9rKXN3aXRjaCh0aGlzLnJlYWR0eXBlKXtjYXNlIG46ZS5qc29uKCkudGhlbihlPT57dC5sb2FkaW5nPSExLHQuX2NhbmNlbGVkfHx0Ll9kZXN0cm95ZWR8fChpPyhpLnB1c2goZSksdC5lbWl0KHMuTE9BREVSX0NPTVBMRVRFLGkpKTp0LmVtaXQocy5MT0FERVJfQ09NUExFVEUsZSkpfSk7YnJlYWs7Y2FzZSBhOmUudGV4dCgpLnRoZW4oZT0+e3QubG9hZGluZz0hMSx0Ll9jYW5jZWxlZHx8dC5fZGVzdHJveWVkfHwoaT8oaS5wdXNoKGUpLHQuZW1pdChzLkxPQURFUl9DT01QTEVURSxpKSk6dC5lbWl0KHMuTE9BREVSX0NPTVBMRVRFLGUpKX0pO2JyZWFrO2Nhc2UgbzplLmFycmF5QnVmZmVyKCkudGhlbihlPT57dC5sb2FkaW5nPSExLHQuX2NhbmNlbGVkfHx0Ll9kZXN0cm95ZWR8fChpPyhpLnB1c2gobmV3IFVpbnQ4QXJyYXkoZSkpLHQuZW1pdChzLkxPQURFUl9DT01QTEVURSxpKSk6dC5lbWl0KHMuTE9BREVSX0NPTVBMRVRFLGUpKX0pO2JyZWFrO2Nhc2UgcjpkZWZhdWx0OnJldHVybiB0aGlzLl9vblJlYWRlcihlLmJvZHkuZ2V0UmVhZGVyKCksZCl9fV9vblJlYWRlcihlLHQpe2xldCBpPXRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UodGhpcy5idWZmZXIpO2lmKCFpJiZ0aGlzLl9yZWFkZXJ8fHRoaXMuX2Rlc3Ryb3llZCl0cnl7dGhpcy5fcmVhZGVyLmNhbmNlbCgpfWNhdGNoKGUpe31pZih0aGlzLl9yZWFkZXI9ZSwhMT09PXRoaXMubG9hZGluZylyZXR1cm47bGV0IHI9dGhpczt0aGlzLl9yZWFkZXImJnRoaXMuX3JlYWRlci5yZWFkKCkudGhlbigoZnVuY3Rpb24oYSl7aWYoYS5kb25lKXJldHVybiByLmxvYWRpbmc9ITEsci5zdGF0dXM9MCx2b2lkIHIuZW1pdChzLkxPQURFUl9DT01QTEVURSxpKTtpZighci5fY2FuY2VsZWQmJiFyLl9kZXN0cm95ZWQpcmV0dXJuIGkucHVzaChhLnZhbHVlKSxyLmVtaXQocy5MT0FERVJfREFUQUxPQURFRCxpKSxyLl9vblJlYWRlcihlLHQpO2lmKHIuX3JlYWRlcil0cnl7ci5fcmVhZGVyLmNhbmNlbCgpfWNhdGNoKGUpe319KSkuY2F0Y2goZT0+e3IubG9hZGluZz0hMSxyLmVtaXQocy5MT0FERVJfRVJST1Isci5UQUcsZSl9KX1nZXRQYXJhbXMoZSl7bGV0IHQ9T2JqZWN0LmFzc2lnbih7fSxlKSxpPW5ldyBIZWFkZXJzLHM9e21ldGhvZDpcIkdFVFwiLGhlYWRlcnM6aSxtb2RlOlwiY29yc1wiLGNhY2hlOlwiZGVmYXVsdFwifTtpZihcIm9iamVjdFwiPT10eXBlb2YgdGhpcy5jb25maWdzLmhlYWRlcnMpe2xldCBlPXRoaXMuY29uZmlncy5oZWFkZXJzO2ZvcihsZXQgdCBpbiBlKWUuaGFzT3duUHJvcGVydHkodCkmJmkuYXBwZW5kKHQsZVt0XSl9aWYoXCJvYmplY3RcIj09dHlwZW9mIHQuaGVhZGVycyl7bGV0IGU9dC5oZWFkZXJzO2ZvcihsZXQgdCBpbiBlKWUuaGFzT3duUHJvcGVydHkodCkmJmkuYXBwZW5kKHQsZVt0XSl9cmV0dXJuITE9PT10LmNvcnMmJihzLm1vZGU9XCJzYW1lLW9yaWdpblwiKSx0LndpdGhDcmVkZW50aWFscyYmKHMuY3JlZGVudGlhbHM9XCJpbmNsdWRlXCIpLHN9Y2FuY2VsKCl7aWYodGhpcy5fcmVhZGVyKXt0cnl7dGhpcy5fcmVhZGVyLmNhbmNlbCgpfWNhdGNoKGUpe310aGlzLl9yZWFkZXI9bnVsbCx0aGlzLmxvYWRpbmc9ITEsdGhpcy5fY2FuY2VsZWQ9ITB9fWRlc3Ryb3koKXt0aGlzLl9kZXN0cm95ZWQ9ITAsdGhpcy5jYW5jZWwoKX19fV0pfSkpO1xuIiwiaW1wb3J0IEZsdkxpdmVQbGF5ZXIgZnJvbSAneGdwbGF5ZXItZmx2LWxpdmUnXG5pbXBvcnQgRmx2Vm9kUGxheWVyIGZyb20gJ3hncGxheWVyLWZsdi12b2QnXG5cbmNsYXNzIEZsdlBsYXllcntcbiAgY29uc3RydWN0b3IgKGNvbmZpZykge1xuICAgIGlmIChjb25maWcuaXNMaXZlKSB7XG4gICAgICByZXR1cm4gbmV3IEZsdkxpdmVQbGF5ZXIoY29uZmlnKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEZsdlZvZFBsYXllcihjb25maWcpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRmx2UGxheWVyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfeGdwbGF5ZXJfXzsiXSwic291cmNlUm9vdCI6IiJ9