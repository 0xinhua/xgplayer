window.FlvPlayer=function(e){var t={};function n(s){if(t[s])return t[s].exports;var i=t[s]={i:s,l:!1,exports:{}};return e[s].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,s){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(n.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(s,i,function(t){return e[t]}.bind(null,i));return s},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=0)}({"../xgplayer-flv-live/dist/index.js":
/*!****************************!*\
  !*** .-live/dist/index.js ***!
  \****************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";var n;window,n=function(__WEBPACK_EXTERNAL_MODULE_xgplayer__){return function(e){var t={};function n(s){if(t[s])return t[s].exports;var i=t[s]={i:s,l:!1,exports:{}};return e[s].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,s){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(n.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(s,i,function(t){return e[t]}.bind(null,i));return s},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=0)}({"../../node_modules/events/events.js":
/*!*****************************************************************************************!*\
      !*** /Users/leonardo/Documents/front-end/player/xgplayer/node_modules/events/events.js ***!
      \*****************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\n\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function () {\n    return defaultMaxListeners;\n  },\n  set: function (arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function () {\n\n  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = type === 'error';\n\n  var events = this._events;\n  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0) er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined) return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n};\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = this._events;\n  if (events === undefined) return this;\n\n  list = events[type];\n  if (list === undefined) return this;\n\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = Object.create(null);else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0) return this;\n\n    if (position === 0) list.shift();else {\n      spliceOne(list, position);\n    }\n\n    if (list.length === 1) events[type] = list[0];\n\n    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events, i;\n\n  events = this._events;\n  if (events === undefined) return this;\n\n  // not listening for removeListener, no need to emit\n  if (events.removeListener === undefined) {\n    if (arguments.length === 0) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    } else if (events[type] !== undefined) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n    }\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    var key;\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n\n  listeners = events[type];\n\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners !== undefined) {\n    // LIFO order\n    for (i = listeners.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners[i]);\n    }\n  }\n\n  return this;\n};\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined) return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined) return [];\n\n  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i) copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++) list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n//# sourceURL=webpack://xgplayer-flv//Users/leonardo/Documents/front-end/player/xgplayer/node_modules/events/events.js?")},"../xgplayer-buffer/index.js":
/*!***********************************!*\
      !*** ../xgplayer-buffer/index.js ***!
      \***********************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nmodule.exports = {\n  Track: __webpack_require__(/*! ./src/track */ "../xgplayer-buffer/src/track.js").default,\n  Tracks: __webpack_require__(/*! ./src/track */ "../xgplayer-buffer/src/track.js").Tracks,\n  AudioTrack: __webpack_require__(/*! ./src/track */ "../xgplayer-buffer/src/track.js").AudioTrack,\n  VideoTrack: __webpack_require__(/*! ./src/track */ "../xgplayer-buffer/src/track.js").VideoTrack,\n\n  XgBuffer: __webpack_require__(/*! ./src/buffer */ "../xgplayer-buffer/src/buffer.js").XgBuffer,\n  RemuxBuffer: __webpack_require__(/*! ./src/buffer */ "../xgplayer-buffer/src/buffer.js").RemuxBuffer,\n\n  PreSource: __webpack_require__(/*! ./src/presouce */ "../xgplayer-buffer/src/presouce.js").default\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-buffer/index.js?')},"../xgplayer-buffer/src/buffer.js":
/*!****************************************!*\
      !*** ../xgplayer-buffer/src/buffer.js ***!
      \****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nclass XgBuffer {\n  /**\n   * A buffer to store loaded data.\n   *\n   * @class LoaderBuffer\n   * @param {number} length - Optional the buffer size\n   */\n  constructor(length) {\n    this.length = length || 0;\n    this.historyLen = length || 0;\n    this.array = [];\n    this.offset = 0;\n  }\n\n  /**\n   * The function to push data.\n   *\n   * @param {number} data - The data to push into the buffer\n   */\n  push(data) {\n    this.array.push(data);\n    this.length += data.byteLength;\n    this.historyLen += data.byteLength;\n  }\n\n  /**\n   * The function to shift data.\n   *\n   * @param {number} length - The size of shift.\n   */\n  shift(length) {\n    if (this.array.length < 1) {\n      return new Uint8Array(0);\n    }\n\n    if (length === undefined) {\n      return this._shiftBuffer();\n    }\n    if (this.offset + length === this.array[0].length) {\n      let ret = this.array[0].slice(this.offset, this.offset + length);\n      this.offset = 0;\n      this.array.shift();\n      this.length -= length;\n      return ret;\n    }\n\n    if (this.offset + length < this.array[0].length) {\n      let ret = this.array[0].slice(this.offset, this.offset + length);\n      this.offset += length;\n      this.length -= length;\n      return ret;\n    }\n\n    let ret = new Uint8Array(length);\n    let tmpoff = 0;\n    while (this.array.length > 0 && length > 0) {\n      if (this.offset + length < this.array[0].length) {\n        let tmp = this.array[0].slice(this.offset, this.offset + length);\n        ret.set(tmp, tmpoff);\n        this.offset += length;\n        this.length -= length;\n        length = 0;\n        break;\n      } else {\n        let templength = this.array[0].length - this.offset;\n        ret.set(this.array[0].slice(this.offset, this.array[0].length), tmpoff);\n        this.array.shift();\n        this.offset = 0;\n        tmpoff += templength;\n        this.length -= templength;\n        length -= templength;\n      }\n    }\n    return ret;\n  }\n\n  /**\n   * Function to clear the buffer.\n   */\n  clear() {\n    this.array = [];\n    this.length = 0;\n    this.offset = 0;\n  }\n\n  destroy() {\n    this.clear();\n    this.historyLen = 0;\n  }\n\n  /**\n   * Function to shift one unit8Array.\n   */\n  _shiftBuffer() {\n    this.length -= this.array[0].length;\n    this.offset = 0;\n    return this.array.shift();\n  }\n\n  /**\n   * Convert uint8 data to number.\n   *\n   * @param {number} start - the start postion.\n   * @param {number} length - the length of data.\n   */\n  toInt(start, length) {\n    let retInt = 0;\n    let i = this.offset + start;\n    while (i < this.offset + length + start) {\n      if (i < this.array[0].length) {\n        retInt = retInt * 256 + this.array[0][i];\n      } else if (this.array[1]) {\n        retInt = retInt * 256 + this.array[1][i - this.array[0].length];\n      }\n\n      i++;\n    }\n    return retInt;\n  }\n}\n\nexports.XgBuffer = XgBuffer;\nclass RemuxBuffer {\n  constructor() {\n    this.video = [];\n    this.audio = [];\n  }\n\n  destroy() {\n    this.video = [];\n    this.audio = [];\n  }\n}\nexports.RemuxBuffer = RemuxBuffer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-buffer/src/buffer.js?')},"../xgplayer-buffer/src/presouce.js":
/*!******************************************!*\
      !*** ../xgplayer-buffer/src/presouce.js ***!
      \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass Source {\n  constructor() {\n    this.mimetype = '';\n    this.init = null;\n    this.data = [];\n  }\n}\n\nclass PreSource {\n  constructor() {\n    this.sources = {};\n  }\n\n  getSource(source) {\n    return this.sources[source];\n  }\n\n  createSource(name) {\n    this.sources[name] = new Source();\n    return this.sources[name];\n  }\n\n  clear() {\n    this.sources = {};\n  }\n\n  destroy() {\n    this.sources = {};\n  }\n}\n\nexports.default = PreSource;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-buffer/src/presouce.js?")},"../xgplayer-buffer/src/track.js":
/*!***************************************!*\
      !*** ../xgplayer-buffer/src/track.js ***!
      \***************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass Track {\n  /**\n   * The constructor.\n   */\n  constructor() {\n    this.id = -1;\n    this.sequenceNumber = 0;\n    this.samples = [];\n    this.droppedSamples = [];\n    this.length = 0;\n  }\n\n  /**\n   * Reset the track.\n   */\n  reset() {\n    this.sequenceNumber = 0;\n    this.samples = [];\n    this.length = 0;\n  }\n  /**\n   * destroy the track.\n   */\n  distroy() {\n    this.reset();\n    this.id = -1;\n  }\n}\n\nexports.default = Track;\nclass AudioTrack extends Track {\n  /**\n   * The constructor for audio track.\n   */\n  constructor() {\n    super();\n    this.TAG = 'AudioTrack';\n    this.type = 'audio';\n  }\n}\n\nexports.AudioTrack = AudioTrack;\nclass VideoTrack extends Track {\n  /**\n   * The constructor for video track.\n   */\n  constructor() {\n    super();\n    this.TAG = 'VideoTrack';\n    this.type = 'video';\n    this.dropped = 0;\n  }\n  /**\n   * reset the video track.\n   */\n  reset() {\n    this.sequenceNumber = 0;\n    this.samples = [];\n    this.length = 0;\n    this.dropped = 0;\n  }\n}\n\nexports.VideoTrack = VideoTrack;\nclass Tracks {\n  constructor() {\n    this.audioTrack = null;\n    this.videoTrack = null;\n  }\n\n  destroy() {\n    this.audioTrack = null;\n    this.videoTrack = null;\n  }\n}\nexports.Tracks = Tracks;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-buffer/src/track.js?")},"../xgplayer-codec/index.js":
/*!**********************************!*\
      !*** ../xgplayer-codec/index.js ***!
      \**********************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nmodule.exports = {\n  Nalunit: __webpack_require__(/*! ./src/h264/nalunit */ "../xgplayer-codec/src/h264/nalunit/index.js").default,\n  SpsParser: __webpack_require__(/*! ./src/h264/nalunit/sps */ "../xgplayer-codec/src/h264/nalunit/sps.js").default,\n\n  Compatibility: __webpack_require__(/*! ./src/compatibility */ "../xgplayer-codec/src/compatibility.js").default\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-codec/index.js?')},"../xgplayer-codec/src/aac/aac-helper.js":
/*!***********************************************!*\
      !*** ../xgplayer-codec/src/aac/aac-helper.js ***!
      \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nclass AAC {\n\n  static getSilentFrame(codec, channelCount) {\n    if (codec === \'mp4a.40.2\') {\n      // handle LC-AAC\n      if (channelCount === 1) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n      } else if (channelCount === 2) {\n        return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n      } else if (channelCount === 3) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n      } else if (channelCount === 4) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n      } else if (channelCount === 5) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n      } else if (channelCount === 6) {\n        return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n      }\n    } else {\n      // handle HE-AAC (mp4a.40.5 / mp4a.40.29)\n      if (channelCount === 1) {\n        // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e \'16/1 "0x%x," "\\n"\' -v output.aac\n        return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n      } else if (channelCount === 2) {\n        // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e \'16/1 "0x%x," "\\n"\' -v output.aac\n        return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n      } else if (channelCount === 3) {\n        // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e \'16/1 "0x%x," "\\n"\' -v output.aac\n        return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n      }\n    }\n    return null;\n  }\n\n}\n\nexports.default = AAC;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-codec/src/aac/aac-helper.js?')},"../xgplayer-codec/src/compatibility.js":
/*!**********************************************!*\
      !*** ../xgplayer-codec/src/compatibility.js ***!
      \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nvar _aacHelper = __webpack_require__(/*! ./aac/aac-helper */ \"../xgplayer-codec/src/aac/aac-helper.js\");\n\nvar _aacHelper2 = _interopRequireDefault(_aacHelper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst { REMUX_EVENTS, DEMUX_EVENTS } = _xgplayerUtils.EVENTS;\n\nclass Compatibility {\n  constructor() {\n    this.nextAudioDts = 0; // 模拟下一段音频数据的dts\n    this.nextVideoDts = 0; // 模拟下一段视频数据的dts\n\n    this.lastAudioSamplesLen = 0; // 上一段音频数据的长度\n    this.lastVideoSamplesLen = 0; // 上一段视频数据的长度\n\n    this.lastVideoDts = undefined; // 上一段音频数据的长度\n    this.lastAudioDts = undefined; // 上一段视频数据的长度\n\n    this.allAudioSamplesCount = 0; // 音频总数据量(原始帧)\n    this.allVideoSamplesCount = 0; // 视频总数据量(原始帧)\n\n    this._firstAudioSample = null;\n    this._firstVideoSample = null;\n\n    this.filledAudioSamples = []; // 补充音频帧（）\n    this.filledVideoSamples = []; // 补充视频帧（）\n\n    this._videoLargeGap = 0;\n    this._audioLargeGap = 0;\n  }\n\n  init() {\n    this.before(REMUX_EVENTS.REMUX_MEDIA, this.doFix.bind(this));\n  }\n\n  reset() {\n    this.nextAudioDts = null; // 估算下一段音频数据的dts\n    this.nextVideoDts = null; // 估算下一段视频数据的dts\n\n    this.lastAudioSamplesLen = 0; // 上一段音频数据的长度\n    this.lastVideoSamplesLen = 0; // 上一段视频数据的长度\n\n    this.lastVideoDts = undefined; // 上一段音频数据的长度\n    this.lastAudioDts = undefined; // 上一段视频数据的长度\n\n    // this.allAudioSamplesCount = 0 // 音频总数据量(原始帧)\n    // this.allVideoSamplesCount = 0 // 视频总数据量(原始帧)\n\n    // this._firstAudioSample = null\n    // this._firstVideoSample = null\n\n    this.filledAudioSamples = []; // 补充音频帧（）\n    this.filledVideoSamples = []; // 补充视频帧（）\n  }\n\n  doFix() {\n    const { isFirstAudioSamples, isFirstVideoSamples } = this.getFirstSample();\n\n    // this.removeInvalidSamples()\n\n    this.recordSamplesCount();\n\n    if (this._firstVideoSample) {\n      this.fixRefSampleDuration(this.videoTrack.meta, this.videoTrack.samples);\n    }\n    if (this._firstAudioSample) {\n      this.fixRefSampleDuration(this.audioTrack.meta, this.audioTrack.samples);\n    }\n\n    const { changed: videoChanged, changedIdx: videoChangedIdx } = Compatibility.detactChangeStream(this.videoTrack.samples);\n    if (videoChanged && !isFirstAudioSamples) {\n      this.fixChangeStreamVideo(videoChangedIdx);\n    } else {\n      this.doFixVideo(isFirstVideoSamples);\n    }\n\n    const { changed: audioChanged, changedIdx: audioChangedIdx } = Compatibility.detactChangeStream(this.audioTrack.samples);\n    if (audioChanged) {\n      this.fixChangeStreamAudio(audioChangedIdx);\n    } else {\n      this.doFixAudio(isFirstAudioSamples);\n    }\n\n    // this.removeInvalidSamples()\n  }\n\n  doFixVideo(first, streamChangeStart) {\n    let { samples: videoSamples, meta } = this.videoTrack;\n\n    if (meta.frameRate && meta.frameRate.fixed === false) {\n      return;\n    }\n\n    if (!videoSamples || !videoSamples.length || !this._firstVideoSample) {\n      return;\n    }\n\n    // console.log(`video lastSample, ${videoSamples[videoSamples.length - 1].dts}`)\n\n    const firstSample = videoSamples[0];\n\n    const samplesLen = videoSamples.length;\n\n    // step0.修复hls流出现巨大gap，需要强制重定位的问题\n    if (this._videoLargeGap > 0) {\n      Compatibility.doFixLargeGap(videoSamples, this._videoLargeGap);\n    }\n\n    if (firstSample.dts !== this._firstVideoSample.dts && (streamChangeStart || Compatibility.detectLargeGap(this.nextVideoDts, firstSample))) {\n      if (streamChangeStart) {\n        this.nextVideoDts = streamChangeStart; // FIX: Hls中途切codec，在如果直接seek到后面的点会导致largeGap计算失败\n      }\n\n      this._videoLargeGap = this.nextVideoDts - firstSample.dts;\n      Compatibility.doFixLargeGap(videoSamples, this._videoLargeGap);\n    }\n\n    const firstDts = firstSample.dts;\n\n    // step1. 修复与audio首帧差距太大的问题\n    if (first && this._firstAudioSample) {\n      const videoFirstDts = this._firstVideoSample.dts;\n      const audioFirstDts = this._firstAudioSample.dts;\n      const gap = videoFirstDts - audioFirstDts;\n      if (gap > 2 * meta.refSampleDuration) {\n        const fillCount = Math.floor(gap / meta.refSampleDuration);\n\n        for (let i = 0; i < fillCount; i++) {\n          const clonedFirstSample = Object.assign({}, firstSample); // 视频头部帧缺失需要复制第一帧\n          // 重新计算sample的dts和pts\n          clonedFirstSample.dts = videoFirstDts - (i + 1) * meta.refSampleDuration;\n          clonedFirstSample.pts = clonedFirstSample.dts + clonedFirstSample.cts;\n\n          videoSamples.unshift(clonedFirstSample);\n\n          this.filledVideoSamples.push({\n            dts: clonedFirstSample.dts,\n            size: clonedFirstSample.data.byteLength\n          });\n        }\n      }\n    }\n\n    let gap;\n    // step2. 修复samples段之间的间距问题、\n    if (this.nextVideoDts) {\n      // step1. 处理samples段之间的丢帧情况\n      // 当发现duration差距大于2帧时进行补帧\n      gap = firstDts - this.nextVideoDts;\n      const absGap = Math.abs(gap);\n      if (gap > 2 * meta.refSampleDuration) {\n        const fillFrameCount = Math.floor(gap / meta.refSampleDuration);\n\n        for (let i = 0; i < fillFrameCount; i++) {\n          const clonedSample = Object.assign({}, videoSamples[0]);\n          const computed = firstDts - (i + 1) * meta.refSampleDuration;\n\n          clonedSample.dts = computed > this.nextVideoDts ? computed : this.nextVideoDts; // 补的第一帧一定要是nextVideoDts\n          clonedSample.pts = clonedSample.dts + clonedSample.cts;\n\n          this.videoTrack.samples.unshift(clonedSample);\n\n          this.filledVideoSamples.push({\n            dts: clonedSample.dts,\n            size: clonedSample.data.byteLength\n          });\n        }\n      } else if (absGap <= meta.refSampleDuration && absGap > 0) {\n        // 当差距在+-一帧之间时将第一帧的dts强行定位到期望位置\n        // console.log('重定位视频帧dts', videoSamples[0].dts, this.nextVideoDts)\n        videoSamples[0].dts = this.nextVideoDts;\n        videoSamples[0].originDts = videoSamples[0].dts;\n        videoSamples[0].cts = videoSamples[0].cts !== undefined ? videoSamples[0].cts : videoSamples[0].pts - videoSamples[0].dts;\n        videoSamples[0].pts = videoSamples[0].dts + videoSamples[0].cts;\n      } else if (gap < 0) {\n        // 出现大的gap\n        Compatibility.doFixLargeGap(videoSamples, -1 * gap);\n      }\n    }\n    const lastDts = videoSamples[videoSamples.length - 1].dts;\n\n    const lastSampleDuration = videoSamples.length >= 2 ? lastDts - videoSamples[videoSamples.length - 2].dts : meta.refSampleDuration;\n\n    this.lastVideoSamplesLen = samplesLen;\n    this.nextVideoDts = lastDts + lastSampleDuration;\n    this.lastVideoDts = lastDts;\n\n    // step2. 修复sample段之内的间距问题\n    // step3. 修复samples段内部的dts异常问题\n    for (let i = 0, len = videoSamples.length; i < len; i++) {\n      const current = videoSamples[i];\n      const next = videoSamples[i + 1];\n\n      if (!next) {\n        break;\n      }\n\n      const duration = next.dts - current.dts;\n\n      if (duration > 2 * meta.refSampleDuration) {\n        // 两帧之间间隔太大，需要补空白帧\n        let fillFrameCount = Math.floor(duration / meta.refSampleDuration);\n\n        let fillFrameIdx = 0;\n        while (fillFrameIdx < fillFrameCount) {\n          const fillFrame = Object.assign({}, next);\n          fillFrame.dts = current.dts + (fillFrameIdx + 1) * meta.refSampleDuration;\n          fillFrame.pts = fillFrame.dts + fillFrame.cts;\n          if (fillFrame < next.dts) {\n            videoSamples.splice(i, 0, fillFrame);\n\n            this.filledVideoSamples.push({\n              dts: fillFrame.dts,\n              size: fillFrame.data.byteLength\n            });\n          }\n\n          fillFrameIdx++;\n          i++;\n        }\n      }\n    }\n\n    this.videoTrack.samples = videoSamples;\n  }\n\n  doFixAudio(first, streamChangeStart) {\n    let { samples: audioSamples, meta } = this.audioTrack;\n\n    if (!audioSamples || !audioSamples.length) {\n      return;\n    }\n    // console.log(`audio lastSample, ${audioSamples[audioSamples.length - 1].dts}`)\n\n    const samplesLen = audioSamples.length;\n    const silentFrame = _aacHelper2.default.getSilentFrame(meta.codec, meta.channelCount);\n\n    const firstSample = this._firstAudioSample;\n\n    const _firstSample = audioSamples[0];\n    // 对audioSamples按照dts做排序\n    // audioSamples = Compatibility.sortAudioSamples(audioSamples)\n    if (this._audioLargeGap > 0) {\n      Compatibility.doFixLargeGap(audioSamples, this._audioLargeGap);\n    }\n\n    if (_firstSample.dts !== this._firstAudioSample.dts && (streamChangeStart || Compatibility.detectLargeGap(this.nextAudioDts, _firstSample))) {\n      if (streamChangeStart) {\n        this.nextAudioDts = streamChangeStart; // FIX: Hls中途切codec，在如果直接seek到后面的点会导致largeGap计算失败\n      }\n      this._audioLargeGap = this.nextAudioDts - _firstSample.dts;\n      Compatibility.doFixLargeGap(audioSamples, this._audioLargeGap);\n    }\n    // step0. 首帧与video首帧间距大的问题\n    if (this._firstVideoSample && first) {\n      const videoFirstPts = this._firstVideoSample.pts ? this._firstVideoSample.pts : this._firstVideoSample.dts + this._firstVideoSample.cts;\n\n      if (firstSample.dts - videoFirstPts > meta.refSampleDuration) {\n        const silentSampleCount = Math.floor((firstSample.dts - videoFirstPts) / meta.refSampleDuration);\n\n        for (let i = 0; i < silentSampleCount; i++) {\n          const silentSample = {\n            data: silentFrame,\n            datasize: silentFrame.byteLength,\n            dts: firstSample.dts - (i + 1) * meta.refSampleDuration,\n            filtered: 0\n          };\n\n          audioSamples.unshift(silentSample);\n\n          this.filledAudioSamples.push({\n            dts: silentSample.dts,\n            size: silentSample.data.byteLength\n          });\n        }\n      }\n    }\n\n    let gap;\n    const firstDts = audioSamples[0].dts;\n\n    if (this.nextAudioDts) {\n      // step1. 处理samples段之间的丢帧情况\n      // 当发现duration差距大于1帧时进行补帧\n      gap = firstDts - this.nextAudioDts;\n      const absGap = Math.abs(gap);\n\n      if (absGap > meta.refSampleDuration && samplesLen === 1 && this.lastAudioSamplesLen === 1) {\n        meta.refSampleDurationFixed = undefined;\n      }\n\n      if (gap > 2 * meta.refSampleDuration) {\n        if (samplesLen === 1 && this.lastAudioSamplesLen === 1) {\n          // 如果sample的length一直是1，而且一直不符合refSampleDuration，需要动态修改refSampleDuration\n          meta.refSampleDurationFixed = meta.refSampleDurationFixed !== undefined ? meta.refSampleDurationFixed + gap : meta.refSampleDuration + gap;\n        } else {\n          const silentFrameCount = Math.floor(gap / meta.refSampleDuration);\n\n          for (let i = 0; i < silentFrameCount; i++) {\n            const computed = firstDts - (i + 1) * meta.refSampleDuration;\n            const silentSample = Object.assign({}, audioSamples[0], {\n              dts: computed > this.nextAudioDts ? computed : this.nextAudioDts\n            });\n\n            this.filledAudioSamples.push({\n              dts: silentSample.dts,\n              size: silentSample.data.byteLength\n            });\n            this.audioTrack.samples.unshift(silentSample);\n          }\n        }\n      } else if (absGap <= meta.refSampleDuration && absGap > 0) {\n        // 当差距比较小的时候将音频帧重定位\n        // console.log('重定位音频帧dts', audioSamples[0].dts, this.nextAudioDts)\n        audioSamples[0].dts = this.nextAudioDts;\n        audioSamples[0].pts = this.nextAudioDts;\n      } else if (gap < 0) {\n        Compatibility.doFixLargeGap(audioSamples, -1 * gap);\n      }\n    }\n    const lastDts = audioSamples[audioSamples.length - 1].dts;\n    const lastSampleDuration = audioSamples.length >= 2 ? lastDts - audioSamples[audioSamples.length - 2].dts : meta.refSampleDuration;\n\n    this.lastAudioSamplesLen = samplesLen;\n    this.nextAudioDts = meta.refSampleDurationFixed ? lastDts + meta.refSampleDurationFixed : lastDts + lastSampleDuration;\n    this.lastAudioDts = lastDts;\n\n    // step3. 修复samples段内部的dts异常问题\n    for (let i = 0, len = audioSamples.length; i < len; i++) {\n      const current = audioSamples[i];\n      const next = audioSamples[i + 1];\n\n      if (!next) {\n        break;\n      }\n\n      const duration = next.dts - current.dts;\n      audioSamples[i].duration = duration;\n      /*\n      if (duration > (2 * meta.refSampleDuration)) {\n        // 两帧之间间隔太大，需要补空白帧\n        /**\n        let silentFrameCount = Math.floor(duration / meta.refSampleDuration)\n        let frameIdx = 0\n         while (frameIdx < silentFrameCount) {\n          const silentSample = {\n            data: silentFrame,\n            datasize: silentFrame.byteLength,\n            dts: current.dts + (frameIdx + 1) * meta.refSampleDuration,\n            filtered: 0,\n            isSilent: true\n          }\n           audioSamples.splice(i, 0, silentSample)\n           this.filledAudioSamples.push({\n            dts: silentSample.dts,\n            size: silentSample.data.byteLength\n          })\n           frameIdx++\n          i++ // 不对静音帧做比较\n        }\n      } */\n    }\n\n    this.audioTrack.samples = Compatibility.sortAudioSamples(audioSamples);\n  }\n\n  fixChangeStreamVideo(changeIdx) {\n    const { samples, meta } = this.videoTrack;\n    const prevDts = changeIdx === 0 ? this.getStreamChangeStart(samples[0]) : samples[changeIdx - 1].dts;\n    const curDts = samples[changeIdx].dts;\n    const isContinue = Math.abs(prevDts - curDts) <= 2 * meta.refSampleDuration;\n\n    if (isContinue) {\n      if (!samples[changeIdx].options) {\n        samples[changeIdx].options = {\n          isContinue: true\n        };\n      } else {\n        samples[changeIdx].options.isContinue = true;\n      }\n      return this.doFixVideo(false);\n    }\n\n    const firstPartSamples = samples.slice(0, changeIdx);\n    const secondPartSamples = samples.slice(changeIdx);\n    const firstSample = samples[0];\n\n    const changeSample = secondPartSamples[0];\n    const firstPartDuration = changeSample.dts - firstSample.dts;\n    const streamChangeStart = firstSample.options && firstSample.options.start + firstPartDuration ? firstSample.options.start : null;\n\n    this.videoTrack.samples = samples.slice(0, changeIdx);\n\n    this.doFixVideo(false);\n\n    this.videoTrack.samples = samples.slice(changeIdx);\n\n    this.doFixVideo(false, streamChangeStart);\n\n    this.videoTrack.samples = firstPartSamples.concat(secondPartSamples);\n  }\n\n  fixChangeStreamAudio(changeIdx) {\n    const { samples, meta } = this.audioTrack;\n\n    const prevDts = changeIdx === 0 ? this.getStreamChangeStart(samples[0]) : samples[changeIdx - 1].dts;\n    const curDts = samples[changeIdx].dts;\n    const isContinue = Math.abs(prevDts - curDts) <= 2 * meta.refSampleDuration;\n\n    if (isContinue) {\n      if (!samples[changeIdx].options) {\n        samples[changeIdx].options = {\n          isContinue: true\n        };\n      } else {\n        samples[changeIdx].options.isContinue = true;\n      }\n      return this.doFixAudio(false);\n    }\n\n    const firstPartSamples = samples.slice(0, changeIdx);\n    const secondPartSamples = samples.slice(changeIdx);\n    const firstSample = samples[0];\n\n    const changeSample = secondPartSamples[0];\n    const firstPartDuration = changeSample.dts - firstSample.dts;\n    const streamChangeStart = firstSample.options && firstSample.options.start + firstPartDuration ? firstSample.options.start : null;\n\n    this.audioTrack.samples = firstPartSamples;\n\n    this.doFixAudio(false);\n\n    this.audioTrack.samples = secondPartSamples;\n\n    this.doFixAudio(false, streamChangeStart);\n\n    this.audioTrack.samples = firstPartSamples.concat(secondPartSamples);\n  }\n\n  getFirstSample() {\n    // 获取video和audio的首帧数据\n    let { samples: videoSamples } = this.videoTrack;\n    let { samples: audioSamples } = this.audioTrack;\n\n    let isFirstVideoSamples = false;\n    let isFirstAudioSamples = false;\n\n    if (!this._firstVideoSample && videoSamples.length) {\n      this._firstVideoSample = Compatibility.findFirstVideoSample(videoSamples);\n      isFirstVideoSamples = true;\n    }\n\n    if (!this._firstAudioSample && audioSamples.length) {\n      this._firstAudioSample = Compatibility.findFirstAudioSample(audioSamples); // 寻找dts最小的帧作为首个音频帧\n      isFirstAudioSamples = true;\n    }\n\n    return {\n      isFirstVideoSamples,\n      isFirstAudioSamples\n    };\n  }\n\n  /**\n   * 在没有refSampleDuration的问题流中，\n   */\n  fixRefSampleDuration(meta, samples) {\n    const isVideo = meta.type === 'video';\n    const allSamplesCount = isVideo ? this.allVideoSamplesCount : this.allAudioSamplesCount;\n    const firstDts = isVideo ? this._firstVideoSample.dts : this._firstAudioSample.dts;\n    const filledSamplesCount = isVideo ? this.filledVideoSamples.length : this.filledAudioSamples.length;\n\n    if (!meta.refSampleDuration || meta.refSampleDuration <= 0 || Number.isNaN(meta.refSampleDuration)) {\n      if (samples.length >= 1) {\n        const lastDts = samples[samples.length - 1].dts;\n\n        meta.refSampleDuration = Math.floor((lastDts - firstDts) / (allSamplesCount + filledSamplesCount - 1)); // 将refSampleDuration重置为计算后的平均值\n      }\n    } else if (meta.refSampleDuration) {\n      if (samples.length >= 5) {\n        const lastDts = samples[samples.length - 1].dts;\n        const firstDts = samples[0].dts;\n        const durationAvg = (lastDts - firstDts) / (samples.length - 1);\n\n        meta.refSampleDuration = Math.floor(Math.abs(meta.refSampleDuration - durationAvg) <= 5 ? meta.refSampleDuration : durationAvg); // 将refSampleDuration重置为计算后的平均值\n      }\n    }\n  }\n\n  /**\n   * 记录截止目前一共播放了多少帧\n   */\n  recordSamplesCount() {\n    const { audioTrack, videoTrack } = this;\n\n    this.allAudioSamplesCount += audioTrack.samples.length;\n    this.allVideoSamplesCount += videoTrack.samples.length;\n  }\n\n  /**\n   * 去除不合法的帧（倒退、重复帧）\n   */\n  removeInvalidSamples() {\n    const { _firstVideoSample, _firstAudioSample } = this;\n\n    this.audioTrack.samples = this.audioTrack.samples.filter(sample => {\n      return sample.dts >= _firstAudioSample.dts && (this.lastAudioDts === undefined || sample.dts > this.lastAudioDts);\n    });\n\n    this.videoTrack.samples = this.videoTrack.samples.filter(sample => {\n      return sample.dts >= _firstVideoSample.dts && (this.lastVideoDts === undefined || sample.dts > this.lastVideoDts);\n    });\n  }\n\n  getStreamChangeStart(sample) {\n    if (sample.options && sample.options.start) {\n      return sample.options.start - this.dtsBase;\n    }\n    return Infinity;\n  }\n\n  static sortAudioSamples(samples) {\n    if (samples.length === 1) {\n      return samples;\n    }\n\n    return samples.sort((a, b) => {\n      return a.dts - b.dts;\n    });\n  }\n\n  /**\n   * 寻找dts最小的sample\n   * @param samples\n   */\n  static findFirstAudioSample(samples) {\n    if (!samples || samples.length === 0) {\n      return null;\n    }\n\n    return Compatibility.sortAudioSamples(samples)[0];\n  }\n\n  static findFirstVideoSample(samples) {\n    if (!samples.length) {\n      return null;\n    }\n\n    const sorted = samples.sort((a, b) => {\n      return a.dts - b.dts;\n    });\n\n    for (let i = 0, len = sorted.length; i < len; i++) {\n      if (sorted[i].isKeyframe) {\n        return sorted[i];\n      }\n    }\n  }\n\n  static detectLargeGap(nextDts, firstSample) {\n    if (nextDts === null) {\n      return;\n    }\n    const curDts = firstSample.dts || 0;\n    const cond1 = nextDts - curDts >= 1000 || curDts - nextDts >= 1000; // fix hls流出现大量流dts间距问题\n    const cond2 = firstSample.options && firstSample.options.discontinue;\n\n    return cond1 || cond2;\n  }\n\n  static doFixLargeGap(samples, gap) {\n    for (let i = 0, len = samples.length; i < len; i++) {\n      const sample = samples[i];\n      sample.dts += gap;\n      if (sample.pts) {\n        sample.pts += gap;\n      }\n    }\n  }\n\n  /**\n   * 中途换流\n   */\n  static detactChangeStream(samples) {\n    let changed = false;\n    let changedIdx = -1;\n    for (let i = 0, len = samples.length; i < len; i++) {\n      if (samples[i].options && samples[i].options.meta) {\n        changed = true;\n        changedIdx = i;\n        break;\n      }\n    }\n\n    return {\n      changed,\n      changedIdx\n    };\n  }\n\n  get tracks() {\n    return this._context.getInstance('TRACKS');\n  }\n\n  get audioTrack() {\n    if (this.tracks) {\n      return this.tracks.audioTrack;\n    }\n    return null;\n  }\n\n  get videoTrack() {\n    if (this.tracks) {\n      return this.tracks.videoTrack;\n    }\n    return null;\n  }\n\n  get dtsBase() {\n    const remuxer = this._context.getInstance('MP4_REMUXER');\n    if (remuxer) {\n      return remuxer._dtsBase;\n    }\n    return 0;\n  }\n}\nexports.default = Compatibility;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-codec/src/compatibility.js?")},"../xgplayer-codec/src/h264/nalunit/golomb.js":
/*!****************************************************!*\
      !*** ../xgplayer-codec/src/h264/nalunit/golomb.js ***!
      \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass Golomb {\n  constructor(uint8array) {\n    this.TAG = 'Golomb';\n    this._buffer = uint8array;\n    this._bufferIndex = 0;\n    this._totalBytes = uint8array.byteLength;\n    this._totalBits = uint8array.byteLength * 8;\n    this._currentWord = 0;\n    this._currentWordBitsLeft = 0;\n  }\n\n  destroy() {\n    this._buffer = null;\n  }\n\n  _fillCurrentWord() {\n    let bufferBytesLeft = this._totalBytes - this._bufferIndex;\n    if (bufferBytesLeft <= 0) {\n      // TODO 异常处理\n    }\n\n    let bytesRead = Math.min(4, bufferBytesLeft);\n    let word = new Uint8Array(4);\n    word.set(this._buffer.subarray(this._bufferIndex, this._bufferIndex + bytesRead));\n    this._currentWord = new DataView(word.buffer).getUint32(0);\n\n    this._bufferIndex += bytesRead;\n    this._currentWordBitsLeft = bytesRead * 8;\n  }\n\n  readBits(size) {\n    let bits = Math.min(this._currentWordBitsLeft, size); // :uint\n    let valu = this._currentWord >>> 32 - bits;\n    if (size > 32) {\n      throw new Error('Cannot read more than 32 bits at a time');\n    }\n    this._currentWordBitsLeft -= bits;\n    if (this._currentWordBitsLeft > 0) {\n      this._currentWord <<= bits;\n    } else if (this._totalBytes - this._bufferIndex > 0) {\n      this._fillCurrentWord();\n    }\n\n    bits = size - bits;\n    if (bits > 0 && this._currentWordBitsLeft) {\n      return valu << bits | this.readBits(bits);\n    } else {\n      return valu;\n    }\n  }\n\n  readBool() {\n    return this.readBits(1) === 1;\n  }\n\n  readByte() {\n    return this.readBits(8);\n  }\n\n  _skipLeadingZero() {\n    let zeroCount;\n    for (zeroCount = 0; zeroCount < this._currentWordBitsLeft; zeroCount++) {\n      if ((this._currentWord & 0x80000000 >>> zeroCount) !== 0) {\n        this._currentWord <<= zeroCount;\n        this._currentWordBitsLeft -= zeroCount;\n        return zeroCount;\n      }\n    }\n    this._fillCurrentWord();\n    return zeroCount + this._skipLeadingZero();\n  }\n\n  readUEG() {\n    // unsigned exponential golomb\n    let leadingZeros = this._skipLeadingZero();\n    return this.readBits(leadingZeros + 1) - 1;\n  }\n\n  readSEG() {\n    // signed exponential golomb\n    let value = this.readUEG();\n    if (value & 0x01) {\n      return value + 1 >>> 1;\n    } else {\n      return -1 * (value >>> 1);\n    }\n  }\n}\n\nexports.default = Golomb;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-codec/src/h264/nalunit/golomb.js?")},"../xgplayer-codec/src/h264/nalunit/index.js":
/*!***************************************************!*\
      !*** ../xgplayer-codec/src/h264/nalunit/index.js ***!
      \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _sps = __webpack_require__(/*! ./sps */ "../xgplayer-codec/src/h264/nalunit/sps.js");\n\nvar _sps2 = _interopRequireDefault(_sps);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Nalunit {\n  static getNalunits(buffer) {\n    if (buffer.length - buffer.position < 4) {\n      return [];\n    }\n\n    let buf = buffer.dataview;\n    let position = buffer.position;\n    if (buf.getInt32(position) === 1 || buf.getInt16(position) === 0 && buf.getInt8(position + 2) === 1) {\n      return Nalunit.getAnnexbNals(buffer);\n    } else {\n      return Nalunit.getAvccNals(buffer);\n    }\n  }\n\n  static getAnnexbNals(buffer) {\n    let nals = [];\n    let position = Nalunit.getHeaderPositionAnnexB(buffer);\n    let start = position.pos;\n    let end = start;\n    while (start < buffer.length - 4) {\n      let header = buffer.buffer.slice(start, start + position.headerLength);\n      if (position.pos === buffer.position) {\n        buffer.skip(position.headerLength);\n      }\n      position = Nalunit.getHeaderPositionAnnexB(buffer);\n      end = position.pos;\n      let body = new Uint8Array(buffer.buffer.slice(start + header.byteLength, end));\n      let unit = { header, body };\n      Nalunit.analyseNal(unit);\n      nals.push(unit);\n      buffer.skip(end - buffer.position);\n      start = end;\n    }\n    return nals;\n  }\n\n  static getAvccNals(buffer) {\n    let nals = [];\n    while (buffer.position < buffer.length - 4) {\n      let length = buffer.dataview.getInt32(buffer.position);\n      if (buffer.length - buffer.position >= length) {\n        let header = buffer.buffer.slice(buffer.position, buffer.position + 4);\n        buffer.skip(4);\n        let body = buffer.buffer.slice(buffer.position, buffer.position + length);\n        buffer.skip(length);\n        let unit = { header, body };\n        Nalunit.analyseNal(unit);\n        nals.push(unit);\n      } else {\n        break;\n      }\n    }\n    return nals;\n  }\n\n  static analyseNal(unit) {\n    let type = unit.body[0] & 0x1f;\n    switch (type) {\n      case 1:\n        // NDR\n        unit.ndr = true;\n        break;\n      case 5:\n        // IDR\n        unit.idr = true;\n        break;\n      case 6:\n        // SEI\n        break;\n      case 7:\n        // SPS\n        unit.sps = _sps2.default.parseSPS(unit.body);\n        break;\n      case 8:\n        // PPS\n        unit.pps = true;\n        break;\n      case 9:\n        // AUD\n        break;\n      default:\n        break;\n    }\n  }\n\n  static getHeaderPositionAnnexB(buffer) {\n    // seperate\n    let pos = buffer.position;\n    let headerLength = 0;\n    while (headerLength !== 3 && headerLength !== 4 && pos < buffer.length - 4) {\n      if (buffer.dataview.getInt16(pos) === 0) {\n        if (buffer.dataview.getInt16(pos + 2) === 1) {\n          // 0x000001\n          headerLength = 4;\n        } else if (buffer.dataview.getInt8(pos + 2) === 1) {\n          headerLength = 3;\n        } else {\n          pos++;\n        }\n      } else {\n        pos++;\n      }\n    }\n\n    if (pos === buffer.length - 4) {\n      if (buffer.dataview.getInt16(pos) === 0) {\n        if (buffer.dataview.getInt16(pos + 2) === 1) {\n          // 0x000001\n          headerLength = 4;\n        }\n      } else {\n        pos++;\n        if (buffer.dataview.getInt16(pos) === 0 && buffer.dataview.getInt8(pos) === 1) {\n          // 0x0000001\n          headerLength = 3;\n        } else {\n          pos = buffer.length;\n        }\n      }\n    }\n    return { pos, headerLength };\n  }\n\n  static getAvcc(sps, pps) {\n    let ret = new Uint8Array(sps.byteLength + pps.byteLength + 11);\n    ret[0] = 0x01;\n    ret[1] = sps[1];\n    ret[2] = sps[2];\n    ret[3] = sps[3];\n    ret[4] = 255;\n    ret[5] = 225;\n\n    let offset = 6;\n\n    ret.set(new Uint8Array([sps.byteLength >>> 8 & 0xff, sps.byteLength & 0xff]), offset);\n    offset += 2;\n    ret.set(sps, offset);\n    offset += sps.byteLength;\n\n    ret[offset] = 1;\n    offset++;\n\n    ret.set(new Uint8Array([pps.byteLength >>> 8 & 0xff, pps.byteLength & 0xff]), offset);\n    offset += 2;\n    ret.set(pps, offset);\n    return ret;\n  }\n}\n\nexports.default = Nalunit;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-codec/src/h264/nalunit/index.js?')},"../xgplayer-codec/src/h264/nalunit/sps.js":
/*!*************************************************!*\
      !*** ../xgplayer-codec/src/h264/nalunit/sps.js ***!
      \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _golomb = __webpack_require__(/*! ./golomb */ \"../xgplayer-codec/src/h264/nalunit/golomb.js\");\n\nvar _golomb2 = _interopRequireDefault(_golomb);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass SPSParser {\n  static _ebsp2rbsp(uint8array) {\n    let src = uint8array;\n    let srcLength = src.byteLength;\n    let dst = new Uint8Array(srcLength);\n    let dstIdx = 0;\n\n    for (let i = 0; i < srcLength; i++) {\n      if (i >= 2) {\n        if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {\n          continue;\n        }\n      }\n      dst[dstIdx] = src[i];\n      dstIdx++;\n    }\n\n    return new Uint8Array(dst.buffer, 0, dstIdx);\n  }\n\n  static parseSPS(uint8array) {\n    let rbsp = SPSParser._ebsp2rbsp(uint8array);\n    let gb = new _golomb2.default(rbsp);\n\n    gb.readByte();\n    let profileIdc = gb.readByte();\n    gb.readByte();\n    let levelIdc = gb.readByte();\n    gb.readUEG();\n\n    let profile_string = SPSParser.getProfileString(profileIdc);\n    let level_string = SPSParser.getLevelString(levelIdc);\n    let chroma_format_idc = 1;\n    let chroma_format = 420;\n    let chroma_format_table = [0, 420, 422, 444];\n    let bit_depth = 8;\n\n    if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128 || profileIdc === 138 || profileIdc === 144) {\n      chroma_format_idc = gb.readUEG();\n      if (chroma_format_idc === 3) {\n        gb.readBits(1);\n      }\n      if (chroma_format_idc <= 3) {\n        chroma_format = chroma_format_table[chroma_format_idc];\n      }\n\n      bit_depth = gb.readUEG() + 8;\n      gb.readUEG();\n      gb.readBits(1);\n      if (gb.readBool()) {\n        let scaling_list_count = chroma_format_idc !== 3 ? 8 : 12;\n        for (let i = 0; i < scaling_list_count; i++) {\n          if (gb.readBool()) {\n            if (i < 6) {\n              SPSParser._skipScalingList(gb, 16);\n            } else {\n              SPSParser._skipScalingList(gb, 64);\n            }\n          }\n        }\n      }\n    }\n    gb.readUEG();\n    let pic_order_cnt_type = gb.readUEG();\n    if (pic_order_cnt_type === 0) {\n      gb.readUEG();\n    } else if (pic_order_cnt_type === 1) {\n      gb.readBits(1);\n      gb.readSEG();\n      gb.readSEG();\n      let num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG();\n      for (let i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {\n        gb.readSEG();\n      }\n    }\n    gb.readUEG();\n    gb.readBits(1);\n\n    let pic_width_in_mbs_minus1 = gb.readUEG();\n    let pic_height_in_map_units_minus1 = gb.readUEG();\n\n    let frame_mbs_only_flag = gb.readBits(1);\n    if (frame_mbs_only_flag === 0) {\n      gb.readBits(1);\n    }\n    gb.readBits(1);\n\n    let frame_crop_left_offset = 0;\n    let frame_crop_right_offset = 0;\n    let frame_crop_top_offset = 0;\n    let frame_crop_bottom_offset = 0;\n\n    let frame_cropping_flag = gb.readBool();\n    if (frame_cropping_flag) {\n      frame_crop_left_offset = gb.readUEG();\n      frame_crop_right_offset = gb.readUEG();\n      frame_crop_top_offset = gb.readUEG();\n      frame_crop_bottom_offset = gb.readUEG();\n    }\n\n    let par_width = 1,\n        par_height = 1;\n    let fps = 0,\n        fps_fixed = true,\n        fps_num = 0,\n        fps_den = 0;\n\n    let vui_parameters_present_flag = gb.readBool();\n    if (vui_parameters_present_flag) {\n      if (gb.readBool()) {\n        // aspect_ratio_info_present_flag\n        let aspect_ratio_idc = gb.readByte();\n        let par_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];\n        let par_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];\n\n        if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {\n          par_width = par_w_table[aspect_ratio_idc - 1];\n          par_height = par_h_table[aspect_ratio_idc - 1];\n        } else if (aspect_ratio_idc === 255) {\n          par_width = gb.readByte() << 8 | gb.readByte();\n          par_height = gb.readByte() << 8 | gb.readByte();\n        }\n      }\n\n      if (gb.readBool()) {\n        gb.readBool();\n      }\n      if (gb.readBool()) {\n        gb.readBits(4);\n        if (gb.readBool()) {\n          gb.readBits(24);\n        }\n      }\n      if (gb.readBool()) {\n        gb.readUEG();\n        gb.readUEG();\n      }\n      if (gb.readBool()) {\n        let num_units_in_tick = gb.readBits(32);\n        let time_scale = gb.readBits(32);\n        fps_fixed = gb.readBool();\n\n        fps_num = time_scale;\n        fps_den = num_units_in_tick * 2;\n        fps = fps_num / fps_den;\n      }\n    }\n\n    let parScale = 1;\n    if (par_width !== 1 || par_height !== 1) {\n      parScale = par_width / par_height;\n    }\n\n    let crop_unit_x = 0,\n        crop_unit_y = 0;\n    if (chroma_format_idc === 0) {\n      crop_unit_x = 1;\n      crop_unit_y = 2 - frame_mbs_only_flag;\n    } else {\n      let sub_wc = chroma_format_idc === 3 ? 1 : 2;\n      let sub_hc = chroma_format_idc === 1 ? 2 : 1;\n      crop_unit_x = sub_wc;\n      crop_unit_y = sub_hc * (2 - frame_mbs_only_flag);\n    }\n\n    let codec_width = (pic_width_in_mbs_minus1 + 1) * 16;\n    let codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16);\n\n    codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x;\n    codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y;\n\n    let present_width = Math.ceil(codec_width * parScale);\n\n    gb.destroy();\n    gb = null;\n\n    return {\n      profile_string: profile_string,\n      level_string: level_string,\n      bit_depth: bit_depth,\n      chroma_format: chroma_format,\n      chroma_format_string: SPSParser.getChromaFormatString(chroma_format),\n\n      frame_rate: {\n        fixed: fps_fixed,\n        fps: fps,\n        fps_den: fps_den,\n        fps_num: fps_num\n      },\n\n      par_ratio: {\n        width: par_width,\n        height: par_height\n      },\n\n      codec_size: {\n        width: codec_width,\n        height: codec_height\n      },\n\n      present_size: {\n        width: present_width,\n        height: codec_height\n      }\n    };\n  }\n\n  static _skipScalingList(gb, count) {\n    let last_scale = 8,\n        next_scale = 8;\n    let delta_scale = 0;\n    for (let i = 0; i < count; i++) {\n      if (next_scale !== 0) {\n        delta_scale = gb.readSEG();\n        next_scale = (last_scale + delta_scale + 256) % 256;\n      }\n      last_scale = next_scale === 0 ? last_scale : next_scale;\n    }\n  }\n\n  static getProfileString(profileIdc) {\n    switch (profileIdc) {\n      case 66:\n        return 'Baseline';\n      case 77:\n        return 'Main';\n      case 88:\n        return 'Extended';\n      case 100:\n        return 'High';\n      case 110:\n        return 'High10';\n      case 122:\n        return 'High422';\n      case 244:\n        return 'High444';\n      default:\n        return 'Unknown';\n    }\n  }\n\n  static getLevelString(levelIdc) {\n    return (levelIdc / 10).toFixed(1);\n  }\n\n  static getChromaFormatString(chroma) {\n    switch (chroma) {\n      case 420:\n        return '4:2:0';\n      case 422:\n        return '4:2:2';\n      case 444:\n        return '4:4:4';\n      default:\n        return 'Unknown';\n    }\n  }\n\n  static toVideoMeta(spsConfig) {\n    let meta = {};\n    if (spsConfig && spsConfig.codec_size) {\n      meta.codecWidth = spsConfig.codec_size.width;\n      meta.codecHeight = spsConfig.codec_size.height;\n      meta.presentWidth = spsConfig.present_size.width;\n      meta.presentHeight = spsConfig.present_size.height;\n    }\n\n    meta.profile = spsConfig.profile_string;\n    meta.level = spsConfig.level_string;\n    meta.bitDepth = spsConfig.bit_depth;\n    meta.chromaFormat = spsConfig.chroma_format;\n\n    meta.parRatio = {\n      width: spsConfig.par_ratio.width,\n      height: spsConfig.par_ratio.height\n    };\n\n    meta.frameRate = spsConfig.frame_rate;\n\n    let fpsDen = meta.frameRate.fps_den;\n    let fpsNum = meta.frameRate.fps_num;\n    meta.refSampleDuration = Math.floor(meta.timescale * (fpsDen / fpsNum));\n    return meta;\n  }\n} /* eslint-disable camelcase  */\n/* eslint-disable one-var  */\nexports.default = SPSParser;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-codec/src/h264/nalunit/sps.js?")},"../xgplayer-demux/index.js":
/*!**********************************!*\
      !*** ../xgplayer-demux/index.js ***!
      \**********************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nmodule.exports = {\n  // HLS\n  M3U8Parser: __webpack_require__(/*! ./src/hls/demuxer/m3u8parser */ "../xgplayer-demux/src/hls/demuxer/m3u8parser.js").default,\n  TsDemuxer: __webpack_require__(/*! ./src/hls/demuxer/ts */ "../xgplayer-demux/src/hls/demuxer/ts.js").default,\n  Playlist: __webpack_require__(/*! ./src/hls/playlist */ "../xgplayer-demux/src/hls/playlist.js").default,\n  FlvDemuxer: __webpack_require__(/*! ./src/flv/index */ "../xgplayer-demux/src/flv/index.js").default\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-demux/index.js?')},"../xgplayer-demux/src/flv/amf-parser.js":
/*!***********************************************!*\
      !*** ../xgplayer-demux/src/flv/amf-parser.js ***!
      \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nconst DATA_TYPES = {\n  NUMBER: 0,\n  BOOLEAN: 1,\n  STRING: 2,\n  OBJECT: 3,\n  MIX_ARRAY: 8,\n  OBJECT_END: 9,\n  STRICT_ARRAY: 10,\n  DATE: 11,\n  LONE_STRING: 12\n\n  /**\n   * meta信息解析\n   */\n};class AMFParser {\n  constructor() {\n    this.offset = 0;\n    this.readOffset = this.offset;\n  }\n\n  resolve(meta, size) {\n    if (size < 3) {\n      throw new Error('not enough data for metainfo');\n    }\n    const metaData = {};\n    const name = this.parseValue(meta);\n    const value = this.parseValue(meta, size - name.bodySize);\n    metaData[name.data] = value.data;\n\n    this.resetStatus();\n    return metaData;\n  }\n\n  resetStatus() {\n    this.offset = 0;\n    this.readOffset = this.offset;\n  }\n\n  parseString(buffer) {\n    const dv = new DataView(buffer, this.readOffset);\n    const strLen = dv.getUint16(0, !_xgplayerUtils.isLe);\n    let str = '';\n    if (strLen > 0) {\n      str = _xgplayerUtils.UTF8.decode(new Uint8Array(buffer, this.readOffset + 2, strLen));\n    } else {\n      str = '';\n    }\n    let size = strLen + 2;\n    this.readOffset += size;\n    return {\n      data: str,\n      bodySize: strLen + 2\n    };\n  }\n\n  parseDate(buffer, size) {\n    const dv = new DataView(buffer, this.readOffset, size);\n    let ts = dv.getFloat64(0, !_xgplayerUtils.isLe);\n    const timeOffset = dv.getInt16(8, !_xgplayerUtils.isLe);\n    ts += timeOffset * 60 * 1000;\n\n    this.readOffset += 10;\n    return {\n      data: new Date(ts),\n      bodySize: 10\n    };\n  }\n\n  parseObject(buffer, size) {\n    const name = this.parseString(buffer, size);\n    const value = this.parseValue(buffer, size - name.bodySize);\n    return {\n      data: {\n        name: name.data,\n        value: value.data\n      },\n      bodySize: name.bodySize + value.bodySize,\n      isObjEnd: value.isObjEnd\n    };\n  }\n\n  parseLongString(buffer) {\n    const dv = new DataView(buffer, this.readOffset);\n    const strLen = dv.getUint32(0, !_xgplayerUtils.isLe);\n    let str = '';\n    if (strLen > 0) {\n      str = _xgplayerUtils.UTF8.decode(new Uint8Array(buffer, this.readOffset + 2, strLen));\n    } else {\n      str = '';\n    }\n    // const size = strLen + 4;\n    this.readOffset += strLen + 4;\n    return {\n      data: str,\n      bodySize: strLen + 4\n    };\n  }\n\n  /**\n   * 解析meta中的变量\n   */\n  parseValue(data, size) {\n    let buffer = new ArrayBuffer();\n    if (data instanceof ArrayBuffer) {\n      buffer = data;\n    } else {\n      buffer = data.buffer;\n    }\n    const {\n      NUMBER,\n      BOOLEAN,\n      STRING,\n      OBJECT,\n      MIX_ARRAY,\n      OBJECT_END,\n      STRICT_ARRAY,\n      DATE,\n      LONE_STRING\n    } = DATA_TYPES;\n    const dataView = new DataView(buffer, this.readOffset, size);\n    let isObjEnd = false;\n    const type = dataView.getUint8(0);\n    let offset = 1;\n    this.readOffset += 1;\n    let value = null;\n\n    switch (type) {\n      case NUMBER:\n        {\n          value = dataView.getFloat64(1, !_xgplayerUtils.isLe);\n          this.readOffset += 8;\n          offset += 8;\n          break;\n        }\n      case BOOLEAN:\n        {\n          const boolNum = dataView.getUint8(1);\n          value = !!boolNum;\n          this.readOffset += 1;\n          offset += 1;\n          break;\n        }\n      case STRING:\n        {\n          const str = this.parseString(buffer);\n          value = str.data;\n          offset += str.bodySize;\n          break;\n        }\n      case OBJECT:\n        {\n          value = {};\n          let objEndSize = 0;\n          if (dataView.getUint32(size - 4, !_xgplayerUtils.isLe) & 0x00FFFFFF) {\n            objEndSize = 3;\n          }\n          // this.readOffset += offset - 1;\n          while (offset < size - 4) {\n            const amfObj = this.parseObject(buffer, size - offset - objEndSize);\n            if (amfObj.isObjectEnd) {\n              break;\n            }\n            value[amfObj.data.name] = amfObj.data.value;\n            offset += amfObj.bodySize;\n          }\n          if (offset <= size - 3) {\n            const mark = dataView.getUint32(offset - 1, !_xgplayerUtils.isLe) & 0x00FFFFFF;\n            if (mark === 9) {\n              this.readOffset += 3;\n              offset += 3;\n            }\n          }\n          break;\n        }\n      case MIX_ARRAY:\n        {\n          value = {};\n          offset += 4;\n          this.readOffset += 4;\n          let objEndSize = 0;\n          if ((dataView.getUint32(size - 4, !_xgplayerUtils.isLe) & 0x00FFFFFF) === 9) {\n            objEndSize = 3;\n          }\n\n          while (offset < size - 8) {\n            const amfVar = this.parseObject(buffer, size - offset - objEndSize);\n            if (amfVar.isObjectEnd) {\n              break;\n            }\n            value[amfVar.data.name] = amfVar.data.value;\n            offset += amfVar.bodySize;\n          }\n          if (offset <= size - 3) {\n            const marker = dataView.getUint32(offset - 1, !_xgplayerUtils.isLe) & 0x00FFFFFF;\n            if (marker === 9) {\n              offset += 3;\n              this.readOffset += 3;\n            }\n          }\n          break;\n        }\n\n      case OBJECT_END:\n        {\n          value = null;\n          isObjEnd = true;\n          break;\n        }\n\n      case STRICT_ARRAY:\n        {\n          value = [];\n          const arrLength = dataView.getUint32(1, !_xgplayerUtils.isLe);\n          offset += 4;\n          this.readOffset += 4;\n          for (let i = 0; i < arrLength; i++) {\n            const script = this.parseValue(buffer, size - offset);\n            value.push(script.data);\n            offset += script.bodySize;\n          }\n          break;\n        }\n\n      case DATE:\n        {\n          const date = this.parseDate(buffer, size - 1);\n          value = date.data;\n          offset += date.bodySize;\n          break;\n        }\n\n      case LONE_STRING:\n        {\n          const longStr = this.parseLongString(buffer, size - 1);\n          value = longStr.data;\n          offset += longStr.bodySize;\n          break;\n        }\n\n      default:\n        {\n          offset = size;\n        }\n    }\n\n    return {\n      data: value,\n      bodySize: offset,\n      isObjEnd: isObjEnd\n    };\n  }\n}\nexports.default = AMFParser;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-demux/src/flv/amf-parser.js?")},"../xgplayer-demux/src/flv/index.js":
/*!******************************************!*\
      !*** ../xgplayer-demux/src/flv/index.js ***!
      \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nvar _xgplayerCodec = __webpack_require__(/*! xgplayer-codec */ \"../xgplayer-codec/index.js\");\n\nvar _xgplayerBuffer = __webpack_require__(/*! xgplayer-buffer */ \"../xgplayer-buffer/index.js\");\n\nvar _amfParser = __webpack_require__(/*! ./amf-parser */ \"../xgplayer-demux/src/flv/amf-parser.js\");\n\nvar _amfParser2 = _interopRequireDefault(_amfParser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst DEMUX_EVENTS = _xgplayerUtils.EVENTS.DEMUX_EVENTS;\n\nclass FlvDemuxer {\n  constructor() {\n    this._firstFragmentLoaded = false;\n    this._trackNum = 0;\n    this._hasScript = false;\n  }\n\n  init() {\n    this.on(DEMUX_EVENTS.DEMUX_START, this.doParseFlv.bind(this));\n  }\n\n  /**\n   * if the flv head is valid\n   * @param data\n   * @returns {boolean}\n   */\n  static isFlvFile(data) {\n    return !(data[0] !== 0x46 || data[1] !== 0x4C || data[2] !== 0x56 || data[3] !== 0x01);\n  }\n\n  /**\n   * If the stream has audio or video.\n   * @param {number} streamFlag - Data from the stream which is define whether the audio / video track is exist.\n   */\n  static getPlayType(streamFlag) {\n    const result = {\n      hasVideo: false,\n      hasAudio: false\n    };\n\n    if (streamFlag & 0x01 > 0) {\n      result.hasVideo = true;\n    }\n\n    if (streamFlag & 0x04 > 0) {\n      result.hasAudio = true;\n    }\n\n    return result;\n  }\n\n  doParseFlv() {\n    if (!this._firstFragmentLoaded) {\n      if (this.loaderBuffer.length < 13) {\n        return;\n      }\n      const header = this.loaderBuffer.shift(13);\n      this.parseFlvHeader(header);\n      this.doParseFlv(); // 递归调用，继续解析flv流\n    } else {\n      if (this.loaderBuffer.length < 11) {\n        return;\n      }\n      let chunk;\n\n      let loopMax = 100000; // 防止死循环产生\n      do {\n        chunk = this._parseFlvTag();\n      } while (chunk && loopMax-- > 0);\n\n      this.emit(DEMUX_EVENTS.DEMUX_COMPLETE);\n    }\n  }\n\n  parseFlvHeader(header) {\n    if (!FlvDemuxer.isFlvFile(header)) {\n      this.emit(DEMUX_EVENTS.DEMUX_ERROR, new Error('invalid flv file'));\n      this.doParseFlv();\n    } else {\n      this._firstFragmentLoaded = true;\n      const playType = FlvDemuxer.getPlayType(header[4]);\n\n      if (playType.hasVideo) {\n        this.initVideoTrack();\n      }\n\n      if (playType.hasAudio) {\n        this.initAudioTrack();\n      }\n    }\n    this.doParseFlv();\n  }\n\n  /**\n   * init default video track configs\n   */\n  initVideoTrack() {\n    this._trackNum++;\n    let videoTrack = new _xgplayerBuffer.VideoTrack();\n    videoTrack.meta = new _xgplayerUtils.VideoTrackMeta();\n    videoTrack.id = videoTrack.meta.id = this._trackNum;\n\n    this.tracks.videoTrack = videoTrack;\n  }\n\n  /**\n   * init default audio track configs\n   */\n  initAudioTrack() {\n    this._trackNum++;\n    let audioTrack = new _xgplayerBuffer.AudioTrack();\n    audioTrack.meta = new _xgplayerUtils.AudioTrackMeta();\n    audioTrack.id = audioTrack.meta.id = this._trackNum;\n\n    this.tracks.audioTrack = audioTrack;\n  }\n\n  /**\n   * Package the data as the following data structure\n   * {\n   *    data: Uint8Array. the Stream data.\n   *    info: The first byte info of the Tag.\n   *    tagType: 8、9、18\n   *    timeStamp: the timestemp\n   * }\n   */\n  _parseFlvTag() {\n    if (this.loaderBuffer.length < 11) {\n      return null;\n    }\n    let chunk = this._parseFlvTagHeader();\n    if (chunk) {\n      this._processChunk(chunk);\n    }\n    return chunk;\n  }\n\n  /**\n   * Parse the 11 byte tag Header\n   */\n  _parseFlvTagHeader() {\n    let offset = 0;\n    let chunk = {};\n\n    let tagType = this.loaderBuffer.toInt(offset, 1);\n    offset += 1;\n\n    // 2 bit FMS reserved, 1 bit filtered, 5 bit tag type\n    chunk.filtered = (tagType & 32) >>> 5;\n    chunk.tagType = tagType & 31;\n\n    // 3 Byte datasize\n    chunk.datasize = this.loaderBuffer.toInt(offset, 3);\n    offset += 3;\n\n    if (chunk.tagType !== 8 && chunk.tagType !== 9 && chunk.tagType !== 11 && chunk.tagType !== 18 || this.loaderBuffer.toInt(8, 3) !== 0) {\n      if (this.loaderBuffer && this.loaderBuffer.length > 0) {\n        this.loaderBuffer.shift(1);\n      }\n      this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error('tagType ' + chunk.tagType), false);\n      return null;\n    }\n\n    if (this.loaderBuffer.length < chunk.datasize + 15) {\n      return null;\n    }\n\n    // read the data.\n    this.loaderBuffer.shift(4);\n\n    // 3 Byte timestamp\n    let timestamp = this.loaderBuffer.toInt(0, 3);\n    this.loaderBuffer.shift(3);\n\n    // 1 Byte timestampExt\n    let timestampExt = this.loaderBuffer.shift(1)[0];\n    if (timestampExt > 0) {\n      timestamp += timestampExt * 0x1000000;\n    }\n\n    chunk.dts = timestamp;\n\n    // streamId\n    this.loaderBuffer.shift(3);\n    return chunk;\n  }\n\n  _processChunk(chunk) {\n    switch (chunk.tagType) {\n      case 18:\n        this._parseScriptData(chunk);\n        break;\n      case 8:\n        this._parseAACData(chunk);\n        break;\n      case 9:\n        this._parseHevcData(chunk);\n        break;\n      case 11:\n        // for some CDN that did not process the currect RTMP messages\n        this.loaderBuffer.shift(3);\n        break;\n      default:\n        this.loaderBuffer.shift(1);\n    }\n  }\n\n  /**\n   * parse flv script data\n   * @param chunk\n   * @private\n   */\n  _parseScriptData(chunk) {\n    let audioTrack = this.tracks.audioTrack;\n    let videoTrack = this.tracks.videoTrack;\n\n    let data = this.loaderBuffer.shift(chunk.datasize);\n\n    const info = new _amfParser2.default().resolve(data, data.length);\n\n    const onMetaData = this._context.onMetaData = info ? info.onMetaData : undefined;\n\n    // fill mediaInfo\n    this._context.mediaInfo.duration = onMetaData.duration;\n    this._context.mediaInfo.hasVideo = onMetaData.hasVideo;\n    this._context.mediaInfo.hsaAudio = onMetaData.hasAudio;\n\n    let validate = this._datasizeValidator(chunk.datasize);\n    if (validate) {\n      this.emit(DEMUX_EVENTS.MEDIA_INFO);\n      this._hasScript = true;\n    }\n\n    // Edit default meta.\n    if (audioTrack && !audioTrack.hasSpecificConfig) {\n      let meta = audioTrack.meta;\n      if (onMetaData.audiosamplerate) {\n        meta.sampleRate = onMetaData.audiosamplerate;\n      }\n\n      if (onMetaData.audiochannels) {\n        meta.channelCount = onMetaData.audiochannels;\n      }\n\n      switch (onMetaData.audiosamplerate) {\n        case 44100:\n          meta.sampleRateIndex = 4;\n          break;\n        case 22050:\n          meta.sampleRateIndex = 7;\n          break;\n        case 11025:\n          meta.sampleRateIndex = 10;\n          break;\n      }\n    }\n    if (videoTrack && !videoTrack.hasSpecificConfig) {\n      let meta = videoTrack.meta;\n      if (typeof onMetaData.framerate === 'number') {\n        let fpsNum = Math.floor(onMetaData.framerate * 1000);\n        if (fpsNum > 0) {\n          let fps = fpsNum / 1000;\n          if (!meta.frameRate) {\n            meta.frameRate = {};\n          }\n          meta.frameRate.fixed = true;\n          meta.frameRate.fps = fps;\n          meta.frameRate.fps_num = fpsNum;\n          meta.frameRate.fps_den = 1000;\n        }\n      }\n    }\n  }\n\n  _aacSequenceHeaderParser(data) {\n    let ret = {};\n    ret.hasSpecificConfig = true;\n    ret.objectType = data[1] >>> 3;\n    ret.sampleRateIndex = (data[1] & 7) << 1 | data[2] >>> 7;\n    ret.audiosamplerate = this._switchAudioSampleRate(ret.sampleRateIndex);\n    ret.channelCount = (data[2] & 120) >>> 3;\n    ret.frameLength = (data[2] & 4) >>> 2;\n    ret.dependsOnCoreCoder = (data[2] & 2) >>> 1;\n    ret.extensionFlagIndex = data[2] & 1;\n\n    ret.codec = `mp4a.40.${ret.objectType}`;\n    let userAgent = window.navigator.userAgent.toLowerCase();\n    let extensionSamplingIndex;\n\n    let config;\n    let samplingIndex = ret.sampleRateIndex;\n\n    if (userAgent.indexOf('firefox') !== -1) {\n      // firefox: use SBR (HE-AAC) if freq less than 24kHz\n      if (ret.sampleRateIndex >= 6) {\n        ret.objectType = 5;\n        config = new Array(4);\n        extensionSamplingIndex = samplingIndex - 3;\n      } else {\n        // use LC-AAC\n        ret.objectType = 2;\n        config = new Array(2);\n        extensionSamplingIndex = samplingIndex;\n      }\n    } else if (userAgent.indexOf('android') !== -1) {\n      // android: always use LC-AAC\n      ret.objectType = 2;\n      config = new Array(2);\n      extensionSamplingIndex = samplingIndex;\n    } else {\n      // for other browsers, e.g. chrome...\n      // Always use HE-AAC to make it easier to switch aac codec profile\n      ret.objectType = 5;\n      extensionSamplingIndex = ret.sampleRateIndex;\n      config = new Array(4);\n\n      if (ret.sampleRateIndex >= 6) {\n        extensionSamplingIndex = ret.sampleRateIndex - 3;\n      } else if (ret.channelCount === 1) {\n        // Mono channel\n        ret.objectType = 2;\n        config = new Array(2);\n        extensionSamplingIndex = ret.sampleRateIndex;\n      }\n    }\n\n    config[0] = ret.objectType << 3;\n    config[0] |= (ret.sampleRateIndex & 0x0F) >>> 1;\n    config[1] = (ret.sampleRateIndex & 0x0F) << 7;\n    config[1] |= (ret.channelCount & 0x0F) << 3;\n    if (ret.objectType === 5) {\n      config[1] |= (extensionSamplingIndex & 0x0F) >>> 1;\n      config[2] = (extensionSamplingIndex & 0x01) << 7;\n      // extended audio object type: force to 2 (LC-AAC)\n      config[2] |= 2 << 2;\n      config[3] = 0;\n    }\n    ret.config = config;\n    return ret;\n  }\n\n  _parseAACData(chunk) {\n    let track = this.tracks.audioTrack;\n    if (!track) {\n      return;\n    }\n\n    let meta = track.meta;\n\n    if (!meta) {\n      track.meta = new _xgplayerUtils.AudioTrackMeta();\n      meta = track.meta;\n    }\n\n    let info = this.loaderBuffer.shift(1)[0];\n\n    chunk.data = this.loaderBuffer.shift(chunk.datasize - 1);\n\n    let format = (info & 240) >>> 4;\n\n    track.format = format;\n\n    if (format !== 10) {\n      this.emit(DEMUX_EVENTS.DEMUX_ERROR, new Error(`invalid audio format: ${format}`));\n    }\n\n    if (format === 10 && !this._hasAudioSequence) {\n      meta.sampleRate = this._switchAudioSamplingFrequency(info);\n      meta.sampleRateIndex = (info & 12) >>> 2;\n      meta.frameLenth = (info & 2) >>> 1;\n      meta.channelCount = info & 1;\n      meta.refSampleDuration = Math.floor(1024 / meta.audioSampleRate * meta.timescale);\n    }\n\n    let audioSampleRate = meta.audioSampleRate;\n    let audioSampleRateIndex = meta.sampleRateIndex;\n    let refSampleDuration = meta.refSampleDuration;\n\n    delete chunk.tagType;\n    let validate = this._datasizeValidator(chunk.datasize);\n\n    if (chunk.data[0] === 0) {\n      // AAC Sequence Header\n      let aacHeader = this._aacSequenceHeaderParser(chunk.data);\n      audioSampleRate = aacHeader.audiosamplerate || meta.audioSampleRate;\n      audioSampleRateIndex = aacHeader.sampleRateIndex || meta.sampleRateIndex;\n      refSampleDuration = Math.floor(1024 / audioSampleRate * meta.timescale);\n\n      meta.channelCount = aacHeader.channelCount;\n      meta.sampleRate = audioSampleRate;\n      meta.sampleRateIndex = audioSampleRateIndex;\n      meta.refSampleDuration = refSampleDuration;\n      meta.duration = this._context.mediaInfo.duration * meta.timescale;\n      meta.config = aacHeader.config;\n      meta.objectType = aacHeader.objectType;\n\n      const audioMedia = this._context.mediaInfo.audio;\n\n      // fill audio media info\n      audioMedia.codec = aacHeader.codec;\n      audioMedia.channelCount = aacHeader.channelCount;\n      audioMedia.sampleRate = audioSampleRate;\n      audioMedia.sampleRateIndex = aacHeader.audioSampleRateIndex;\n\n      if (this._hasScript && !this._hasAudioSequence) {\n        this.emit(DEMUX_EVENTS.METADATA_PARSED, 'audio');\n      } else if (this._hasScript && this._hasAudioSequence) {\n        this.emit(DEMUX_EVENTS.METADATA_PARSED, 'audio');\n        this.emit(DEMUX_EVENTS.AUDIO_METADATA_CHANGE);\n        // this.emit(DEMUX_EVENTS.METADATA_PARSED, 'audio')\n      }\n      this._hasAudioSequence = true;\n\n      this._metaChange = true;\n    } else {\n      if (this._metaChange) {\n        chunk.options = {\n          meta: track.meta\n        };\n        this._metaChange = false;\n      }\n\n      chunk.data = chunk.data.slice(1, chunk.data.length);\n      track.samples.push(chunk);\n    }\n    if (!validate) {\n      this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error('TAG length error at ' + chunk.datasize), false);\n      // this.logger.warn(this.TAG, error.message)\n    }\n  }\n\n  /**\n   * parse hevc/avc video data\n   * @param chunk\n   * @private\n   */\n  _parseHevcData(chunk) {\n    // header\n    let info = this.loaderBuffer.shift(1)[0];\n    chunk.frameType = (info & 0xf0) >>> 4;\n    chunk.isKeyframe = chunk.frameType === 1;\n    // let tempCodecID = this.tracks.videoTrack.codecID\n    let codecID = info & 0x0f;\n    this.tracks.videoTrack.codecID = codecID;\n\n    // hevc和avc的header解析方式一样\n    chunk.avcPacketType = this.loaderBuffer.shift(1)[0];\n    chunk.cts = this.loaderBuffer.toInt(0, 3);\n    this.loaderBuffer.shift(3);\n\n    // 12 for hevc, 7 for avc\n    if (codecID === 12) {\n      const data = this.loaderBuffer.shift(chunk.datasize - 5);\n      chunk.data = data;\n\n      if (Number.parseInt(chunk.avcPacketType) !== 0) {\n        if (!this._datasizeValidator(chunk.datasize)) {\n          this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error(`invalid video tag datasize: ${chunk.datasize}`), false);\n        }\n        let nalu = {};\n        let r = 0;\n        nalu.cts = chunk.cts;\n        nalu.dts = chunk.dts;\n        while (chunk.data.length > r) {\n          let sizes = chunk.data.slice(Number.parseInt(r), 4 + r);\n          nalu.size = sizes[3];\n          nalu.size += sizes[2] * 256;\n          nalu.size += sizes[1] * 256 * 256;\n          nalu.size += sizes[0] * 256 * 256 * 256;\n          r += 4;\n          nalu.data = chunk.data.slice(Number.parseInt(r), nalu.size + r);\n          r += nalu.size;\n          this.tracks.videoTrack.samples.push(nalu);\n          this.emit(DEMUX_EVENTS.METADATA_PARSED, 'video');\n        }\n      } else if (Number.parseInt(chunk.avcPacketType) === 0) {\n        if (!this._datasizeValidator(chunk.datasize)) {\n          this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error(`invalid video tag datasize: ${chunk.datasize}`), false);\n        } else {\n          this.emit(DEMUX_EVENTS.METADATA_PARSED, 'video');\n        }\n      }\n    } else if (codecID === 7) {\n      let data = this.loaderBuffer.shift(chunk.datasize - 5);\n      if (data[4] === 0 && data[5] === 0 && data[6] === 0 && data[7] === 1) {\n        let avcclength = 0;\n        for (let i = 0; i < 4; i++) {\n          avcclength = avcclength * 256 + data[i];\n        }\n        avcclength -= 4;\n        data = data.slice(4, data.length);\n        data[3] = avcclength % 256;\n        avcclength = (avcclength - data[3]) / 256;\n        data[2] = avcclength % 256;\n        avcclength = (avcclength - data[2]) / 256;\n        data[1] = avcclength % 256;\n        data[0] = (avcclength - data[1]) / 256;\n      }\n\n      chunk.data = data;\n      // If it is AVC sequece Header.\n      if (chunk.avcPacketType === 0) {\n        this._avcSequenceHeaderParser(chunk.data);\n        let validate = this._datasizeValidator(chunk.datasize);\n        if (validate) {\n          if (this._hasScript && !this._hasVideoSequence) {\n            this.emit(DEMUX_EVENTS.METADATA_PARSED, 'video');\n          } else if (this._hasScript && this._hasVideoSequence) {\n            this.emit(DEMUX_EVENTS.METADATA_PARSED, 'audio');\n            this.emit(DEMUX_EVENTS.VIDEO_METADATA_CHANGE);\n            // this.emit(DEMUX_EVENTS.METADATA_PARSED, 'video')\n          }\n          this._hasVideoSequence = true;\n        }\n        this._metaChange = true;\n      } else {\n        if (!this._datasizeValidator(chunk.datasize)) {\n          this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error(`invalid video tag datasize: ${chunk.datasize}`), false);\n          return;\n        }\n        if (this._metaChange) {\n          chunk.options = {\n            meta: Object.assign({}, this.tracks.videoTrack.meta)\n          };\n          this._metaChange = false;\n        }\n        this.tracks.videoTrack.samples.push(chunk);\n        // this.emit(DEMUX_EVENTS.DEMUX_COMPLETE)\n      }\n    } else {\n      this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error(`video codeid is ${codecID}`), false);\n      chunk.data = this.loaderBuffer.shift(chunk.datasize - 1);\n      if (!this._datasizeValidator(chunk.datasize)) {\n        this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error(`invalid video tag datasize: ${chunk.datasize}`), false);\n      }\n      this.tracks.videoTrack.samples.push(chunk);\n      this.emit(DEMUX_EVENTS.DEMUX_COMPLETE);\n    }\n    delete chunk.tagType;\n  }\n\n  /**\n   * parse avc metadata\n   * @param data\n   * @private\n   */\n  _avcSequenceHeaderParser(data) {\n    let track = this.tracks.videoTrack;\n\n    if (!track) {\n      return;\n    }\n\n    let offset = 0;\n\n    if (!track.meta) {\n      track.meta = new _xgplayerUtils.VideoTrackMeta();\n    }\n    let meta = track.meta;\n\n    meta.configurationVersion = data[0];\n    meta.avcProfileIndication = data[1];\n    meta.profileCompatibility = data[2];\n    meta.avcLevelIndication = data[3] / 10;\n    meta.nalUnitLength = (data[4] & 0x03) + 1;\n\n    let numOfSps = data[5] & 0x1f;\n    offset = 6;\n    let config = {};\n\n    // parse SPS\n    for (let i = 0; i < numOfSps; i++) {\n      let size = data[offset] * 255 + data[offset + 1];\n      offset += 2;\n\n      let sps = new Uint8Array(size);\n      for (let j = 0; j < size; j++) {\n        sps[j] = data[offset + j];\n      }\n\n      // codec string\n      let codecString = 'avc1.';\n      for (let j = 1; j < 4; j++) {\n        let h = sps[j].toString(16);\n        if (h.length < 2) {\n          h = '0' + h;\n        }\n        codecString += h;\n      }\n\n      meta.codec = codecString;\n\n      offset += size;\n      this.tracks.videoTrack.meta.sps = sps;\n      config = _xgplayerCodec.SpsParser.parseSPS(sps);\n    }\n\n    let numOfPps = data[offset];\n\n    offset++;\n\n    for (let i = 0; i < numOfPps; i++) {\n      let size = data[offset] * 255 + data[offset + 1];\n      offset += 2;\n      let pps = new Uint8Array(size);\n      for (let j = 0; j < size; j++) {\n        pps[j] = data[offset + j];\n      }\n      offset += size;\n      this.tracks.videoTrack.meta.pps = pps;\n    }\n\n    Object.assign(meta, _xgplayerCodec.SpsParser.toVideoMeta(config));\n\n    // fill video media info\n    const videoMedia = this._context.mediaInfo.video;\n\n    videoMedia.codec = meta.codec;\n    videoMedia.profile = meta.profile;\n    videoMedia.level = meta.level;\n    videoMedia.chromaFormat = meta.chromaFormat;\n    videoMedia.frameRate = meta.frameRate;\n    videoMedia.parRatio = meta.parRatio;\n    videoMedia.width = videoMedia.width === meta.presentWidth ? videoMedia.width : meta.presentWidth;\n    videoMedia.height = videoMedia.height === meta.presentHeight ? videoMedia.width : meta.presentHeight;\n\n    meta.duration = this._context.mediaInfo.duration * meta.timescale;\n    meta.avcc = new Uint8Array(data.length);\n    meta.avcc.set(data);\n    track.meta = meta;\n  }\n\n  /**\n   * choose audio sample rate\n   * @param samplingFrequencyIndex\n   * @returns {number}\n   * @private\n   */\n  _switchAudioSampleRate(samplingFrequencyIndex) {\n    let samplingFrequencyList = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n    return samplingFrequencyList[samplingFrequencyIndex];\n  }\n\n  /**\n   * choose audio sampling frequence\n   * @param info\n   * @returns {number}\n   * @private\n   */\n  _switchAudioSamplingFrequency(info) {\n    let samplingFrequencyIndex = (info & 12) >>> 2;\n    let samplingFrequencyList = [5500, 11025, 22050, 44100, 48000];\n    return samplingFrequencyList[samplingFrequencyIndex];\n  }\n\n  /**\n   * choose audio channel count\n   * @param info\n   * @returns {number}\n   * @private\n   */\n  _switchAudioChannel(info) {\n    let sampleTrackNumIndex = info & 1;\n    let sampleTrackNumList = [1, 2];\n    return sampleTrackNumList[sampleTrackNumIndex];\n  }\n\n  /**\n   * check datasize is valid use 4 Byte after current tag\n   * @param datasize\n   * @returns {boolean}\n   * @private\n   */\n  _datasizeValidator(datasize) {\n    let datasizeConfirm = this.loaderBuffer.toInt(0, 4);\n    this.loaderBuffer.shift(4);\n    return datasizeConfirm === datasize + 11;\n  }\n\n  get loaderBuffer() {\n    const buffer = this._context.getInstance('LOADER_BUFFER');\n    if (buffer) {\n      return buffer;\n    } else {\n      this.emit(DEMUX_EVENTS.DEMUX_ERROR, new Error('找不到 loaderBuffer 实例'));\n    }\n  }\n\n  get tracks() {\n    return this._context.getInstance('TRACKS');\n  }\n\n  get logger() {\n    return this._context.getInstance('LOGGER');\n  }\n}\n\nexports.default = FlvDemuxer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-demux/src/flv/index.js?")},"../xgplayer-demux/src/hls/demuxer/m3u8parser.js":
/*!*******************************************************!*\
      !*** ../xgplayer-demux/src/hls/demuxer/m3u8parser.js ***!
      \*******************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Reference: https://tools.ietf.org/html/rfc8216#section-4.3\n */\nclass M3U8Parser {\n  static parse(text, baseurl = '') {\n    let ret = {\n      duration: 0\n    };\n    if (!text || !text.split) {\n      return;\n    }\n    let refs = text.split(/\\r|\\n/);\n    refs = refs.filter(ref => {\n      return ref;\n    });\n    let ref = refs.shift();\n    if (!ref.match('#EXTM3U')) {\n      throw new Error(`Invalid m3u8 file: not \"#EXTM3U\"`);\n      return null;\n    }\n    ref = refs.shift();\n    while (ref) {\n      let refm = ref.match(/#(.[A-Z|-]*):(.*)/);\n      let refd = ref.match(/#(.[A-Z|-]*)/);\n      if (refd && refm && refm.length > 2) {\n        switch (refm[1]) {\n          case 'EXT-X-VERSION':\n            ret.version = parseInt(refm[2]);\n            break;\n          case 'EXT-X-MEDIA-SEQUENCE':\n            ret.sequence = parseInt(refm[2]);\n            break;\n          case 'EXT-X-TARGETDURATION':\n            ret.targetduration = parseFloat(refm[2]);\n            break;\n          case 'EXTINF':\n            M3U8Parser.parseFrag(refm, refs, ret, baseurl);\n            break;\n          case 'EXT-X-KEY':\n            M3U8Parser.parseDecrypt(refm[2], ret);\n            break;\n          default:\n            break;\n        }\n      }if (refd && refd.length > 1) {\n        switch (refd[1]) {\n          case 'EXT-X-DISCONTINUITY':\n            ref = refs.shift();\n            let refm = ref.match(/#(.[A-Z|-]*):(.*)/);\n            if (refm.length > 2 && refm[1] === 'EXTINF') {\n              M3U8Parser.parseFrag(refm, refs, ret, baseurl, true);\n            }\n            break;\n          default:\n            break;\n        }\n      }\n      ref = refs.shift();\n    }\n    return ret;\n  }\n\n  static parseFrag(refm, refs, ret, baseurl, discontinue) {\n    if (!ret.frags) {\n      ret.frags = [];\n    }\n\n    let freg = {\n      start: ret.duration,\n      duration: parseFloat(refm[2]) * 1000\n    };\n\n    ret.duration += freg.duration;\n    let nextline = refs.shift();\n    if (nextline.match(/#(.*):(.*)/)) {\n      nextline = refs.shift();\n    }\n    if (nextline.length > 0 && nextline.charAt(0) === '/' && baseurl.match(/.*\\/\\/.*\\.\\w+/g)) {\n      baseurl = baseurl.match(/.*\\/\\/.*\\.\\w+/g)[0];\n    }\n    if (nextline.match(/.*:\\/\\/.*/)) {\n      freg.url = nextline;\n    } else {\n      freg.url = baseurl + nextline;\n    }\n    freg.discontinue = discontinue;\n    ret.frags.push(freg);\n  }\n\n  static parseURL(url) {\n    let baseurl = '';\n    let urls = url.match(/(.*\\/).*\\.m3u8/);\n    if (urls && urls.length > 0) {\n      for (let i = 0; i < urls.length; i++) {\n        if (urls[i].match(/.*\\/$/g) && urls[i].length > baseurl.length) {\n          baseurl = urls[i];\n        }\n      }\n    }\n    return baseurl;\n  }\n\n  static parseDecrypt(refm, ret) {\n    ret.encrypt = {};\n    let refs = refm.split(',');\n    for (let i in refs) {\n      let cmd = refs[i];\n      if (cmd.match(/METHOD=(.*)/)) {\n        ret.encrypt.method = cmd.match(/METHOD=(.*)/)[1];\n      }\n      if (cmd.match(/URI=\"(.*)\"/)) {\n        ret.encrypt.uri = cmd.match(/URI=\"(.*)\"/)[1];\n      }\n\n      if (cmd.match(/IV=0x(.*)/)) {\n        let iv = cmd.match(/IV=0x(.*)/)[1];\n        let length = Math.ceil(iv.length / 2);\n        ret.encrypt.ivb = new Uint8Array(length);\n        for (let i = length - 1; i >= 0; i--) {\n          let im = parseInt(iv.substr(i * 2, 2), 16);\n          ret.encrypt.ivb[i] = im;\n        }\n        ret.encrypt.iv = iv;\n      }\n    };\n  }\n}\n\nexports.default = M3U8Parser;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-demux/src/hls/demuxer/m3u8parser.js?")},"../xgplayer-demux/src/hls/demuxer/ts.js":
/*!***********************************************!*\
      !*** ../xgplayer-demux/src/hls/demuxer/ts.js ***!
      \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _xgplayerCodec = __webpack_require__(/*! xgplayer-codec */ \"../xgplayer-codec/index.js\");\n\nvar _xgplayerBuffer = __webpack_require__(/*! xgplayer-buffer */ \"../xgplayer-buffer/index.js\");\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nconst DEMUX_EVENTS = _xgplayerUtils.EVENTS.DEMUX_EVENTS;\nconst StreamType = {\n  0x01: ['video', 'MPEG-1'],\n  0x02: ['video', 'MPEG-2'],\n  0x1b: ['video', 'AVC.H264'],\n  0xea: ['video', 'VC-1'],\n  0x03: ['audio', 'MPEG-1'],\n  0x04: ['audio', 'MPEG-2'],\n  0x0f: ['audio', 'MPEG-2.AAC'],\n  0x11: ['audio', 'MPEG-4.AAC'],\n  0x80: ['audio', 'LPCM'],\n  0x81: ['audio', 'AC3'],\n  0x06: ['audio', 'AC3'],\n  0x82: ['audio', 'DTS'],\n  0x83: ['audio', 'Dolby TrueHD'],\n  0x84: ['audio', 'AC3-Plus'],\n  0x85: ['audio', 'DTS-HD'],\n  0x86: ['audio', 'DTS-MA'],\n  0xa1: ['audio', 'AC3-Plus-SEC'],\n  0xa2: ['audio', 'DTS-HD-SEC']\n};\n\nclass TsDemuxer {\n  constructor(configs) {\n    this.configs = Object.assign({}, configs);\n    this.demuxing = false;\n    this.pat = [];\n    this.pmt = [];\n    this._hasVideoMeta = false;\n    this._hasAudioMeta = false;\n  }\n\n  init() {\n    this.on(DEMUX_EVENTS.DEMUX_START, this.demux.bind(this));\n  }\n\n  demux(frag) {\n    if (this.demuxing) {\n      return;\n    }\n\n    let buffer = this.inputBuffer;\n    let frags = { pat: [], pmt: [] };\n    let peses = {};\n\n    // Read TS segment\n    while (buffer.length >= 188) {\n      if (buffer.length >= 1 && buffer.array[0][buffer.offset] !== 71) {\n        this.emit(DEMUX_EVENTS.DEMUX_ERROR, this.TAG, new Error(`Untrust sync code: ${buffer.array[0][buffer.offset]}, try to recover;`), false);\n      }\n      while (buffer.length >= 1 && buffer.array[0][buffer.offset] !== 71) {\n        buffer.shift(1);\n      }\n      let buf = buffer.shift(188);\n      // console.log(buf);\n      let tsStream = new _xgplayerUtils.Stream(buf.buffer);\n      let ts = {};\n      TsDemuxer.read(tsStream, ts, frags);\n      if (ts.pes) {\n        if (!peses[ts.header.pid]) {\n          peses[ts.header.pid] = [];\n        }\n        peses[ts.header.pid].push(ts.pes);\n        ts.pes.ES.buffer = [ts.pes.ES.buffer];\n      } else if (peses[ts.header.pid]) {\n        peses[ts.header.pid][peses[ts.header.pid].length - 1].ES.buffer.push(ts.payload.stream);\n      }\n    }\n\n    let AudioOptions = frag;\n    let VideoOptions = frag;\n\n    // Get Frames data\n    for (let i = 0; i < Object.keys(peses).length; i++) {\n      let epeses = peses[Object.keys(peses)[i]];\n      for (let j = 0; j < epeses.length; j++) {\n        epeses[j].id = Object.keys(peses)[i];\n        epeses[j].ES.buffer = TsDemuxer.Merge(epeses[j].ES.buffer);\n        if (epeses[j].type === 'audio') {\n          this.pushAudioSample(epeses[j], AudioOptions);\n          AudioOptions = {};\n        } else if (epeses[j].type === 'video') {\n          this.pushVideoSample(epeses[j], VideoOptions);\n          VideoOptions = {};\n        }\n      }\n    }\n\n    if (this._hasAudioMeta) {\n      this.emit(DEMUX_EVENTS.DEMUX_COMPLETE, 'audio');\n    }\n    if (this._hasVideoMeta) {\n      this.emit(DEMUX_EVENTS.DEMUX_COMPLETE, 'video');\n    }\n  }\n\n  pushAudioSample(pes, options) {\n    let track;\n    if (!this._tracks.audioTrack) {\n      this._tracks.audioTrack = new _xgplayerBuffer.AudioTrack();\n      track = this._tracks.audioTrack;\n    } else {\n      track = this._tracks.audioTrack;\n    }\n    let meta = new _xgplayerUtils.AudioTrackMeta({\n      audioSampleRate: pes.ES.frequence,\n      sampleRate: pes.ES.frequence,\n      channelCount: pes.ES.channel,\n      codec: 'mp4a.40.' + pes.ES.audioObjectType,\n      config: pes.ES.audioConfig,\n      id: 2,\n      sampleRateIndex: pes.ES.frequencyIndex\n    });\n    meta.refSampleDuration = Math.floor(1024 / meta.audioSampleRate * meta.timescale);\n\n    let metaEqual = TsDemuxer.compaireMeta(track.meta, meta, true);\n\n    if (!this._hasAudioMeta || !metaEqual) {\n      track.meta = meta;\n      this._hasAudioMeta = true;\n      this.emit(DEMUX_EVENTS.METADATA_PARSED, 'audio');\n    }\n\n    let data = new Uint8Array(pes.ES.buffer.buffer.slice(pes.ES.buffer.position, pes.ES.buffer.length));\n    let dts = parseInt(pes.pts / 90);\n    let pts = parseInt(pes.pts / 90);\n    let sample = new _xgplayerUtils.AudioTrackSample({ dts, pts, data, options });\n    track.samples.push(sample);\n  }\n\n  pushVideoSample(pes, options) {\n    let nals = _xgplayerCodec.Nalunit.getNalunits(pes.ES.buffer);\n    let track;\n    let meta = new _xgplayerUtils.VideoTrackMeta();\n    if (!this._tracks.videoTrack) {\n      this._tracks.videoTrack = new _xgplayerBuffer.VideoTrack();\n      track = this._tracks.videoTrack;\n    } else {\n      track = this._tracks.videoTrack;\n    }\n    let sampleLength = 0;\n    let sps = false;\n    let pps = false;\n    for (let i = 0; i < nals.length; i++) {\n      let nal = nals[i];\n      if (nal.sps) {\n        sps = nal;\n        track.sps = nal.body;\n        meta.chromaFormat = sps.sps.chroma_format;\n        meta.codec = 'avc1.';\n        for (var j = 1; j < 4; j++) {\n          var h = sps.body[j].toString(16);\n          if (h.length < 2) {\n            h = '0' + h;\n          }\n          meta.codec += h;\n        }\n        meta.codecHeight = sps.sps.codec_size.height;\n        meta.codecWidth = sps.sps.codec_size.width;\n        meta.frameRate = sps.sps.frame_rate;\n        meta.id = 1;\n        meta.level = sps.sps.level_string;\n        meta.presentHeight = sps.sps.present_size.height;\n        meta.presentWidth = sps.sps.present_size.width;\n        meta.profile = sps.sps.profile_string;\n        meta.refSampleDuration = Math.floor(meta.timescale * (sps.sps.frame_rate.fps_den / sps.sps.frame_rate.fps_num));\n        meta.sarRatio = sps.sps.sar_ratio ? sps.sps.sar_ratio : sps.sps.par_ratio;\n      } else if (nal.pps) {\n        track.pps = nal.body;\n        pps = nal;\n      } else {\n        sampleLength += 4 + nal.body.byteLength;\n      }\n    }\n\n    if (sps && pps) {\n      meta.avcc = _xgplayerCodec.Nalunit.getAvcc(sps.body, pps.body);\n      let metaEqual = TsDemuxer.compaireMeta(track.meta, meta, true);\n      if (!this._hasVideoMeta || !metaEqual) {\n        if (options) {\n          options.meta = Object.assign({}, meta);\n        } else {\n          options = {\n            meta: Object.assign({}, meta)\n          };\n        }\n        track.meta = meta;\n        this._hasVideoMeta = true;\n        this.emit(DEMUX_EVENTS.METADATA_PARSED, 'video');\n      }\n    }\n\n    let data = new Uint8Array(sampleLength);\n    let offset = 0;\n    let isKeyframe = false;\n    for (let i = 0; i < nals.length; i++) {\n      let nal = nals[i];\n      let length = nal.body.byteLength;\n      if (nal.idr) {\n        isKeyframe = true;\n      }\n      if (!nal.pps && !nal.sps) {\n        data.set(new Uint8Array([length >>> 24 & 0xff, length >>> 16 & 0xff, length >>> 8 & 0xff, length & 0xff]), offset);\n        offset += 4;\n        data.set(nal.body, offset);\n        offset += length;\n      }\n    }\n    let sample = new _xgplayerUtils.VideoTrackSample({\n      dts: parseInt(pes.dts / 90),\n      pts: parseInt(pes.pts / 90),\n      cts: (pes.pts - pes.dts) / 90,\n      originDts: pes.dts,\n      isKeyframe,\n      data,\n      options\n    });\n    track.samples.push(sample);\n  }\n\n  destory() {\n    this.off(DEMUX_EVENTS.DEMUX_START, this.demux);\n    this.configs = {};\n    this.demuxing = false;\n    this.pat = [];\n    this.pmt = [];\n    this._hasVideoMeta = false;\n    this._hasAudioMeta = false;\n  }\n\n  static compaireArray(a, b, type) {\n    let al = 0;\n    let bl = 0;\n    if (type === 'Uint8Array') {\n      al = a.byteLength;\n      bl = b.byteLength;\n    } else if (type === 'Array') {\n      al = a.length;\n      bl = b.length;\n    }\n    if (al !== bl) {\n      return false;\n    }\n\n    for (let i = 0; i < al; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  static compaireMeta(a, b, ignoreDuration) {\n    if (!a || !b) {\n      return false;\n    }\n\n    for (let i = 0, k = Object.keys(a).length; i < k; i++) {\n      let itema = a[Object.keys(a)[i]];\n      let itemb = b[Object.keys(a)[i]];\n      if (typeof itema !== 'object') {\n        if (ignoreDuration && Object.keys(a)[i] !== 'duration' && Object.keys(a)[i] !== 'refSampleDuration' && Object.keys(a)[i] !== 'refSampleDurationFixed' && itema !== itemb) {\n          return false;\n        }\n      } else if (itema.byteLength !== undefined) {\n        if (itemb.byteLength === undefined) {\n          return false;\n        }\n        if (!TsDemuxer.compaireArray(itema, itemb, 'Uint8Array')) {\n          return false;\n        }\n      } else if (itema.length !== undefined) {\n        if (itemb.length === undefined) {\n          return false;\n        }\n        if (!TsDemuxer.compaireArray(itema, itemb, 'Array')) {\n          return false;\n        }\n      } else {\n        if (!TsDemuxer.compaireMeta(itema, itemb)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  static Merge(buffers) {\n    let data;\n    let length = 0;\n    let offset = 0;\n    for (let i = 0; i < buffers.length; i++) {\n      length += buffers[i].length - buffers[i].position;\n    }\n\n    data = new Uint8Array(length);\n    for (let i = 0; i < buffers.length; i++) {\n      let buffer = buffers[i];\n      data.set(new Uint8Array(buffer.buffer, buffer.position), offset);\n      offset += buffer.length - buffer.position;\n    }\n    return new _xgplayerUtils.Stream(data.buffer);\n  }\n\n  static read(stream, ts, frags) {\n    TsDemuxer.readHeader(stream, ts);\n    TsDemuxer.readPayload(stream, ts, frags);\n    if (ts.header.packet === 'MEDIA' && ts.header.payload === 1 && !ts.unknownPIDs) {\n      ts.pes = TsDemuxer.PES(ts);\n    }\n  }\n\n  static readPayload(stream, ts, frags) {\n    let header = ts.header;\n    let pid = header.pid;\n    switch (pid) {\n      case 0:\n        TsDemuxer.PAT(stream, ts, frags);\n        break;\n      case 1:\n        TsDemuxer.CAT(stream, ts, frags);\n        break;\n      case 2:\n        TsDemuxer.TSDT(stream, ts, frags);\n        break;\n      case 0x1fff:\n        break;\n      default:\n        // TODO: some的写法不太好，得改\n        if (frags.pat.some(item => {\n          return item.pid === pid;\n        })) {\n          TsDemuxer.PMT(stream, ts, frags);\n        } else {\n          let sts = frags.pmt ? frags.pmt.filter(item => item.pid === pid) : [];\n          if (sts.length > 0) {\n            TsDemuxer.Media(stream, ts, StreamType[sts[0].streamType][0]);\n          } else {\n            ts.unknownPIDs = true;\n          };\n        }\n    }\n  }\n\n  static readHeader(stream, ts) {\n    let header = {};\n    header.sync = stream.readUint8();\n    let next = stream.readUint16();\n    header.error = next >>> 15;\n    header.payload = next >>> 14 & 1;\n    header.priority = next >>> 13 & 1;\n    header.pid = next & 0x1fff;\n\n    next = stream.readUint8();\n\n    header.scrambling = next >> 6 & 0x3; // 是否加密，00表示不加密\n\n    /**\n     * 00 ISO/IEC未来使用保留\n     * 01 没有调整字段，仅含有184B有效净荷\n     * 02 没有有效净荷，仅含有183B调整字段\n     * 03 0~182B调整字段后为有效净荷\n     */\n    header.adaptation = next >> 4 & 0x3;\n    header.continuity = next & 15;\n    header.packet = header.pid === 0 ? 'PAT' : 'MEDIA';\n    ts.header = header;\n  }\n\n  static PAT(stream, ts, frags) {\n    let ret = {};\n    let next = stream.readUint8();\n    stream.skip(next);\n    next = stream.readUint8();\n    ret.tabelID = next;\n    next = stream.readUint16();\n    ret.error = next >>> 7;\n    ret.zero = next >>> 6 & 1;\n    ret.sectionLength = next & 0xfff;\n    ret.streamID = stream.readUint16();\n    ret.current = stream.readUint8() & 1;\n    ret.sectionNumber = stream.readUint8();\n    ret.lastSectionNumber = stream.readUint8();\n    let N = (ret.sectionLength - 9) / 4;\n    let list = [];\n    for (let i = 0; i < N; i++) {\n      let programNumber = stream.readUint16();\n      let pid = stream.readUint16() & 0x1fff;\n      list.push({\n        program: programNumber,\n        pid,\n        type: programNumber === 0 ? 'network' : 'mapPID'\n      });\n    }\n    if (list.length > 0) {\n      frags.pat = frags.pat.concat(list);\n    }\n    ret.list = list;\n    ret.program = stream.readUint16();\n    ret.pid = stream.readUint16() & 0x1fff;\n    ts.payload = ret;\n    // TODO CRC\n  }\n\n  static PMT(stream, ts, frags) {\n    let ret = {};\n    let header = ts.header;\n    header.packet = 'PMT';\n    let next = stream.readUint8();\n    stream.skip(next);\n    next = stream.readUint8();\n    ret.tableID = next;\n    next = stream.readUint16();\n    ret.sectionLength = next & 0xfff;\n    ret.program = stream.readUint16();\n    ret.current = stream.readUint8() & 1;\n    ret.order = stream.readUint8();\n    ret.lastOrder = stream.readUint8();\n    ret.PCR_PID = stream.readUint16() & 0x1fff;\n    ret.programLength = stream.readUint16() & 0xfff;\n    let N = (ret.sectionLength - 13) / 5;\n    let list = [];\n    for (let i = 0; i < N; i++) {\n      list.push({\n        streamType: stream.readUint8(),\n        pid: stream.readUint16() & 0x1fff, // 0x07e5 视频，0x07e6\n        es: stream.readUint16() & 0xfff\n      });\n    }\n    ret.list = list;\n    if (!this.pmt) {\n      this.pmt = [];\n    }\n    frags.pmt = this.pmt.concat(list.map(item => {\n      return {\n        pid: item.pid,\n        es: item.es,\n        streamType: item.streamType,\n        program: ret.program\n      };\n    }));\n    ts.payload = ret;\n  }\n\n  static Media(stream, ts, type) {\n    let header = ts.header;\n    let payload = {};\n    header.type = type;\n    if (header.adaptation === 0x03) {\n      payload.adaptationLength = stream.readUint8();\n      if (payload.adaptationLength > 0) {\n        let next = stream.readUint8();\n        payload.discontinue = next >>> 7;\n        payload.access = next >>> 6 & 0x01;\n        payload.priority = next >>> 5 & 0x01;\n        payload.PCR = next >>> 4 & 0x01;\n        payload.OPCR = next >>> 3 & 0x01;\n        payload.splicePoint = next >>> 2 & 0x01;\n        payload.transportPrivate = next >>> 1 & 0x01;\n        payload.adaptationField = next & 0x01;\n        let _start = stream.position;\n        if (payload.PCR === 1) {\n          payload.programClockBase = stream.readUint32() << 1;\n          next = stream.readUint16();\n          payload.programClockBase |= next >>> 15;\n          payload.programClockExtension = next & 0x1ff;\n        }\n        if (payload.OPCR === 1) {\n          payload.originProgramClockBase = stream.readUint32() << 1;\n          next = stream.readUint16();\n          payload.originProgramClockBase += next >>> 15;\n          payload.originProgramClockExtension = next & 0x1ff;\n        }\n        if (payload.splicePoint === 1) {\n          payload.spliceCountdown = stream.readUint8();\n        }\n        if (payload.transportPrivate === 1) {\n          let length = stream.readUint8();\n          let transportPrivateData = [];\n          for (let i = 0; i < length; i++) {\n            transportPrivateData.push(stream.readUint8());\n          }\n        }\n        if (payload.adaptationField === 1) {\n          let length = stream.readUint8();\n          let next = stream.readUint8();\n          let start = stream.position;\n          let ltw = next >>> 7;\n          let piecewise = next >>> 6 & 0x1;\n          let seamless = next >>> 5 & 0x1;\n          if (ltw === 1) {\n            next = stream.readUint16();\n            payload.ltwValid = next >>> 15;\n            payload.ltwOffset = next & 0xefff;\n          }\n          if (piecewise === 1) {\n            next = stream.readUint24();\n            payload.piecewiseRate = next & 0x3fffff;\n          }\n          if (seamless === 1) {\n            next = stream.readInt8();\n            payload.spliceType = next >>> 4;\n            payload.dtsNextAU1 = next >>> 1 & 0x7;\n            payload.marker1 = next & 0x1;\n            next = stream.readUint16();\n            payload.dtsNextAU2 = next >>> 1;\n            payload.marker2 = next & 0x1;\n            next = stream.readUint16();\n            payload.dtsNextAU3 = next;\n          }\n          stream.skip(length - 1 - (stream.position - start));\n        }\n        let lastStuffing = payload.adaptationLength - 1 - (stream.position - _start);\n        stream.skip(lastStuffing);\n      }\n    }\n    payload.stream = new _xgplayerUtils.Stream(stream.buffer.slice(stream.position));\n    ts.payload = payload;\n  }\n\n  static PES(ts) {\n    let ret = {};\n    let buffer = ts.payload.stream;\n\n    let next = buffer.readUint24();\n    if (next !== 1) {\n      ret.ES = {};\n      ret.ES.buffer = buffer;\n    } else {\n      let streamID = buffer.readUint8();\n      if (streamID >= 0xe0 && streamID <= 0xef) {\n        ret.type = 'video';\n      }\n      if (streamID >= 0xc0 && streamID <= 0xdf) {\n        ret.type = 'audio';\n      }\n      let packetLength = buffer.readUint16();\n      ret.packetLength = packetLength;\n      if (ret.type === 'video' || ret.type === 'audio') {\n        let next = buffer.readUint8();\n        let first = next >>> 6;\n        if (first !== 0x02) {\n          throw new Error('error when parse pes header');\n        }\n        next = buffer.readUint8();\n        ret.ptsDTSFlag = next >>> 6;\n        ret.escrFlag = next >>> 5 & 0x01;\n        ret.esRateFlag = next >>> 4 & 0x01;\n        ret.dsmFlag = next >>> 3 & 0x01;\n        ret.additionalFlag = next >>> 2 & 0x01;\n        ret.crcFlag = next >>> 1 & 0x01;\n        ret.extensionFlag = next & 0x01;\n        ret.pesHeaderLength = buffer.readUint8();\n        let N1 = ret.pesHeaderLength;\n\n        if (ret.ptsDTSFlag === 2) {\n          let pts = [];\n          next = buffer.readUint8();\n          pts.push(next >>> 1 & 0x07);\n          next = buffer.readUint16();\n          pts.push(next >>> 1);\n          next = buffer.readUint16();\n          pts.push(next >>> 1);\n          ret.pts = pts[0] << 30 | pts[1] << 15 | pts[2];\n          N1 -= 5;\n          // 视频如果没有dts用pts\n          if (ret.type === 'video') {\n            ret.dts = ret.pts;\n          }\n        }\n        if (ret.ptsDTSFlag === 3) {\n          let pts = [];\n          next = buffer.readUint8();\n          pts.push(next >>> 1 & 0x07);\n          next = buffer.readUint16();\n          pts.push(next >>> 1);\n          next = buffer.readUint16();\n          pts.push(next >>> 1);\n          ret.pts = pts[0] << 30 | pts[1] << 15 | pts[2];\n          let dts = [];\n          next = buffer.readUint8();\n          dts.push(next >>> 1 & 0x07);\n          next = buffer.readUint16();\n          dts.push(next >>> 1);\n          next = buffer.readUint16();\n          dts.push(next >>> 1);\n          ret.dts = dts[0] << 30 | dts[1] << 15 | dts[2];\n          N1 -= 10;\n        }\n        if (ret.escrFlag === 1) {\n          let escr = [];\n          let ex = [];\n          next = buffer.readUint8();\n          escr.push(next >>> 3 & 0x07);\n          escr.push(next & 0x03);\n          next = buffer.readUint16();\n          escr.push(next >>> 13);\n          escr.push(next & 0x03);\n          next = buffer.readUint16();\n          escr.push(next >>> 13);\n          ex.push(next & 0x03);\n          next = buffer.readUint8();\n          ex.push(next >>> 1);\n          ret.escr = (escr[0] << 30 | escr[1] << 28 | escr[2] << 15 | escr[3] << 13 | escr[4]) * 300 + (ex[0] << 7 | ex[1]);\n          N1 -= 6;\n        }\n        if (ret.esRateFlag === 1) {\n          next = buffer.readUint24();\n          ret.esRate = next >>> 1 & 0x3fffff;\n          N1 -= 3;\n        }\n        if (ret.dsmFlag === 1) {\n          throw new Error('not support DSM_trick_mode');\n        }\n        if (ret.additionalFlag === 1) {\n          next = buffer.readUint8();\n          ret.additionalCopyInfo = next & 0x7f;\n          N1 -= 1;\n        }\n        if (ret.crcFlag === 1) {\n          ret.pesCRC = buffer.readUint16();\n          N1 -= 2;\n        }\n        if (ret.extensionFlag === 1) {\n          throw new Error('not support extension');\n        }\n        if (N1 > 0) {\n          buffer.skip(N1);\n        }\n        ret.ES = TsDemuxer.ES(buffer, ret.type);\n      } else {\n        throw new Error('format is not supported');\n      }\n    }\n    return ret;\n  }\n\n  static ES(buffer, type) {\n    let next;\n    let ret = {};\n    if (type === 'video') {\n      next = buffer.readUint32();\n      if (next !== 1) {\n        buffer.back(4);\n        next = buffer.readUint24();\n        if (next !== 1) {\n          throw new Error('h264 nal header parse failed');\n        }\n      }\n      buffer.skip(2); // 09 F0\n      // TODO readnalu\n      ret.buffer = buffer;\n    } else if (type === 'audio') {\n      next = buffer.readUint16();\n      // adts的同步字节，12位\n      if (next >>> 4 !== 0xfff) {\n        throw new Error('aac ES parse Error');\n      }\n      const fq = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n      ret.id = (next >>> 3 & 0x01) === 0 ? 'MPEG-4' : 'MPEG-2';\n      ret.layer = next >>> 1 & 0x03;\n      ret.absent = next & 0x01;\n      next = buffer.readUint16();\n      ret.audioObjectType = (next >>> 14 & 0x03) + 1;\n      ret.profile = ret.audioObjectType - 1;\n      ret.frequencyIndex = next >>> 10 & 0x0f;\n      ret.frequence = fq[ret.frequencyIndex];\n      ret.channel = next >>> 6 & 0x07;\n      ret.frameLength = (next & 0x03) << 11 | buffer.readUint16() >>> 5;\n      TsDemuxer.getAudioConfig(ret);\n      buffer.skip(1);\n      ret.buffer = buffer;\n    } else {\n      throw new Error(`ES ${type} is not supported`);\n    }\n\n    return ret;\n  }\n\n  static TSDT(stream, ts, frags) {\n    // TODO\n    ts.payload = {};\n  }\n\n  static CAT(stream, ts, frags) {\n    let ret = {};\n    ret.tableID = stream.readUint8();\n    let next = stream.readUint16();\n    ret.sectionIndicator = next >>> 7;\n    ret.sectionLength = next & 0x0fff;\n    stream.skip(2);\n    next = stream.readUint8();\n    ret.version = next >>> 3;\n    ret.currentNextIndicator = next & 0x01;\n    ret.sectionNumber = stream.readUint8();\n    ret.lastSectionNumber = stream.readUint8();\n    let N = (this.sectionLength - 9) / 4;\n    let list = [];\n    for (let i = 0; i < N; i++) {\n      list.push({});\n    }\n    ret.crc32 = stream.readUint32();\n    ts.payload = ret;\n  }\n\n  static getAudioConfig(ret) {\n    let userAgent = navigator.userAgent.toLowerCase();\n    let config;\n    let extensionSampleIndex;\n    if (/firefox/i.test(userAgent)) {\n      if (ret.frequencyIndex >= 6) {\n        ret.audioObjectType = 5;\n        config = new Array(4);\n        extensionSampleIndex = ret.frequencyIndex - 3;\n      } else {\n        ret.audioObjectType = 2;\n        config = new Array(2);\n        extensionSampleIndex = ret.frequencyIndex;\n      }\n    } else if (userAgent.indexOf('android') !== -1) {\n      ret.audioObjectType = 2;\n      config = new Array(2);\n      extensionSampleIndex = ret.frequencyIndex;\n    } else {\n      ret.audioObjectType = 5;\n      config = new Array(4);\n      if (ret.frequencyIndex >= 6) {\n        extensionSampleIndex = ret.frequencyIndex - 3;\n      } else {\n        if (ret.channel === 1) {\n          ret.audioObjectType = 2;\n          config = new Array(2);\n        }\n        extensionSampleIndex = ret.frequencyIndex;\n      }\n    }\n\n    config[0] = ret.audioObjectType << 3;\n    config[0] |= (ret.frequencyIndex & 0x0e) >> 1;\n    config[1] = (ret.frequencyIndex & 0x01) << 7;\n    config[1] |= ret.channel << 3;\n    if (ret.audioObjectType === 5) {\n      config[1] |= (extensionSampleIndex & 0x0e) >> 1;\n      config[2] = (extensionSampleIndex & 0x01) << 7;\n      config[2] |= 2 << 2;\n      config[3] = 0;\n    }\n    ret.audioConfig = config;\n  }\n\n  get inputBuffer() {\n    return this._context.getInstance(this.configs.inputbuffer);\n  }\n\n  get _tracks() {\n    return this._context.getInstance('TRACKS');\n  }\n}\n\nexports.default = TsDemuxer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-demux/src/hls/demuxer/ts.js?")},"../xgplayer-demux/src/hls/playlist.js":
/*!*********************************************!*\
      !*** ../xgplayer-demux/src/hls/playlist.js ***!
      \*********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass Playlist {\n  constructor(configs) {\n    this._baseURL = '';\n    this._list = {};\n    this._ts = {};\n    this.version = 0;\n    this.sequence = -1;\n    this.targetduration = 0;\n    this.duration = 0;\n    this.fragLength = 0;\n    this._lastget = undefined;\n    this._audoclear = configs.autoclear || false;\n  }\n\n  get list() {\n    return this._list;\n  }\n\n  set baseURL(baseURL) {\n    if (this.baseURL !== baseURL) {\n      this.clear();\n      this._baseURL = baseURL;\n    }\n  }\n\n  get baseURL() {\n    return this._baseURL;\n  }\n\n  push(ts, duration, discontinue) {\n    if (!this._ts[ts]) {\n      this._ts[ts] = { duration: duration,\n        downloaded: false,\n        downloading: false,\n        start: this.duration,\n        discontinue: discontinue ? true : false\n      };\n      this._list[this.duration] = ts;\n      this.duration += duration;\n      this.fragLength += 1;\n    }\n  }\n\n  deleteFrag(url) {\n    if (this._ts[url]) {\n      if (this._ts[url].start > this._lastget.time) {\n        this._lastget = {\n          duration: this._ts[url].duration,\n          time: this._ts[url].start,\n          downloaded: false,\n          downloading: false,\n          url: url\n        };\n      }\n      delete this._list[this._ts[url].start];\n      delete this._ts[url];\n      this.fragLength -= 1;\n    }\n  }\n\n  pushM3U8(data, deletepre) {\n    // 常规信息替换\n    if (!data) {\n      throw new Error(`No m3u8 data received.`);\n      return;\n    }\n    this.version = data.version;\n    this.targetduration = data.targetduration;\n    if (data.encrypt && !this.encrypt) {\n      this.encrypt = data.encrypt;\n    }\n    // 新分片信息\n    if (data.sequence > this.sequence) {\n      this.sequence = data.sequence;\n      let newfraglist = [];\n      for (let i = 0; i < data.frags.length; i++) {\n        let frag = data.frags[i];\n        if (!this._ts[frag.url]) {\n          newfraglist.push(frag.url);\n          this.push(frag.url, frag.duration, frag.discontinue);\n        }\n      }\n\n      if (newfraglist.length < 1) {\n        throw new Error(`Can not read ts file list.`);\n      }\n\n      if (deletepre) {\n        let tslist = this.getTsList();\n        for (let i = 0; i < tslist.length; i++) {\n          if (newfraglist.indexOf(tslist[i]) < 0) {\n            this.deleteFrag(tslist[i]);\n          }\n        }\n      }\n    } else {\n      throw new Error(`Old m3u8 file received, ${data.sequence}`);\n    }\n  }\n\n  getTsList() {\n    return Object.keys(this._ts);\n  }\n\n  downloaded(tsname, isloaded) {\n    let ts = this._ts[tsname];\n    if (ts) {\n      ts.downloaded = isloaded;\n    }\n  }\n\n  downloading(tsname, loading) {\n    let ts = this._ts[tsname];\n    if (ts) {\n      ts.downloading = loading;\n    }\n  }\n\n  getTsByName(name) {\n    return this._ts[name];\n  }\n\n  getTs(time) {\n    let timelist = Object.keys(this._list);\n    let ts;\n\n    if (time === undefined) {\n      if (this._lastget) {\n        time = this._lastget.time + this._lastget.duration;\n      } else {\n        time = 0;\n      }\n    }\n\n    if (timelist.length < 1 || time >= this.duration) {\n      return undefined;\n    }\n    timelist.sort((a, b) => {\n      return parseFloat(a) - parseFloat(b);\n    });\n    for (let i = 0; i < timelist.length; i++) {\n      if (time >= parseInt(timelist[i])) {\n        let url = this._list[timelist[i]];\n        let downloaded = this._ts[url].downloaded;\n        let downloading = this._ts[url].downloading;\n        ts = { url, downloaded, downloading, time: parseInt(timelist[i]), duration: parseInt(this._ts[url].duration) };\n        if (this.autoclear) {\n          delete this._ts[this._lastget.url];\n          delete this._list[this._lastget.time];\n        }\n        this._lastget = ts;\n      } else {\n        break;\n      }\n    }\n    return ts;\n  }\n\n  clear() {\n    this._baseURL = '';\n    this._list = {};\n    this._ts = {};\n    this.version = 0;\n    this.sequence = -1;\n    this.targetduration = 0;\n    this.duration = 0;\n  }\n\n  clearDownloaded() {\n    for (let i = 0, l = Object.keys(this._ts).length; i < l; i++) {\n      let ts = this._ts[Object.keys(this._ts)[i]];\n      ts.downloaded = false;\n      ts.downloading = false;\n    }\n  }\n\n  destroy() {\n    this._baseURL = '';\n    this._list = {};\n    this._ts = {};\n    this.version = 0;\n    this.sequence = -1;\n    this.targetduration = 0;\n    this.duration = 0;\n    this.fragLength = 0;\n    this._lastget = undefined;\n    this._audoclear = false;\n  }\n}\n\nexports.default = Playlist;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-demux/src/hls/playlist.js?")},"../xgplayer-loader/index.js":
/*!***********************************!*\
      !*** ../xgplayer-loader/index.js ***!
      \***********************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nmodule.exports = {\n  FetchLoader: __webpack_require__(/*! ./src/fetch-loader */ "../xgplayer-loader/src/fetch-loader.js").default\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-loader/index.js?')},"../xgplayer-loader/src/fetch-loader.js":
/*!**********************************************!*\
      !*** ../xgplayer-loader/src/fetch-loader.js ***!
      \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nconst LOADER_EVENTS = _xgplayerUtils.EVENTS.LOADER_EVENTS;\nconst READ_STREAM = 0;\nconst READ_TEXT = 1;\nconst READ_JSON = 2;\nconst READ_BUFFER = 3;\nclass FetchLoader {\n  constructor(configs) {\n    this.configs = Object.assign({}, configs);\n    this.url = null;\n    this.status = 0;\n    this.error = null;\n    this._reader = null;\n    this._canceled = false;\n    this._destroyed = false;\n    this.readtype = this.configs.readtype;\n    this.buffer = this.configs.buffer || 'LOADER_BUFFER';\n    this._loaderTaskNo = 0;\n  }\n\n  init() {\n    this.on(LOADER_EVENTS.LADER_START, this.load.bind(this));\n  }\n\n  static get type() {\n    return 'loader';\n  }\n\n  load(url, opts) {\n    let _this = this;\n    this.url = url;\n    this._canceled = false;\n\n    // TODO: Add Ranges\n    let params = this.getParams(opts);\n    _this.loading = true;\n    return fetch(this.url, params).then(function (response) {\n      if (response.ok) {\n        _this.status = response.status;\n        return _this._onFetchResponse(response);\n      }\n      _this.loading = false;\n      _this.emit(LOADER_EVENTS.LOADER_ERROR, _this.TAG, new Error(`invalid response.`));\n    }).catch(function (error) {\n      _this.loading = false;\n      _this.emit(LOADER_EVENTS.LOADER_ERROR, _this.TAG, error);\n      throw new Error(error.message);\n    });\n  }\n\n  _onFetchResponse(response) {\n    let _this = this;\n    let buffer = this._context.getInstance(this.buffer);\n    this._loaderTaskNo++;\n    let taskno = this._loaderTaskNo;\n    if (response.ok === true) {\n      switch (this.readtype) {\n        case READ_JSON:\n          response.json().then(data => {\n            _this.loading = false;\n            if (!_this._canceled && !_this._destroyed) {\n              if (buffer) {\n                buffer.push(data);\n                _this.emit(LOADER_EVENTS.LOADER_COMPLETE, buffer);\n              } else {\n                _this.emit(LOADER_EVENTS.LOADER_COMPLETE, data);\n              }\n            }\n          });\n          break;\n        case READ_TEXT:\n          response.text().then(data => {\n            _this.loading = false;\n            if (!_this._canceled && !_this._destroyed) {\n              if (buffer) {\n                buffer.push(data);\n                _this.emit(LOADER_EVENTS.LOADER_COMPLETE, buffer);\n              } else {\n                _this.emit(LOADER_EVENTS.LOADER_COMPLETE, data);\n              }\n            }\n          });\n          break;\n        case READ_BUFFER:\n          response.arrayBuffer().then(data => {\n            _this.loading = false;\n            if (!_this._canceled && !_this._destroyed) {\n              if (buffer) {\n                buffer.push(new Uint8Array(data));\n                _this.emit(LOADER_EVENTS.LOADER_COMPLETE, buffer);\n              } else {\n                _this.emit(LOADER_EVENTS.LOADER_COMPLETE, data);\n              }\n            }\n          });\n          break;\n        case READ_STREAM:\n        default:\n          return this._onReader(response.body.getReader(), taskno);\n      }\n    }\n  }\n\n  _onReader(reader, taskno) {\n    let buffer = this._context.getInstance(this.buffer);\n    if (!buffer && this._reader || this._destroyed) {\n      try {\n        this._reader.cancel();\n      } catch (e) {\n        // DO NOTHING\n      }\n    }\n\n    this._reader = reader;\n    if (this.loading === false) {\n      return;\n    }\n\n    let _this = this;\n    // reader read function returns a Promise. get data when callback and has value.done when disconnected.\n    // read方法返回一个Promise. 回调中可以获取到数据。当value.done存在时，说明链接断开。\n    this._reader && this._reader.read().then(function (val) {\n      if (val.done) {\n        // TODO: 完成处理\n        _this.loading = false;\n        _this.status = 0;\n        _this.emit(LOADER_EVENTS.LOADER_COMPLETE, buffer);\n        return;\n      }\n\n      if (_this._canceled || _this._destroyed) {\n        if (_this._reader) {\n          try {\n            _this._reader.cancel();\n          } catch (e) {\n            // DO NOTHING\n          }\n        }\n\n        return;\n      }\n      buffer.push(val.value);\n      _this.emit(LOADER_EVENTS.LOADER_DATALOADED, buffer);\n      return _this._onReader(reader, taskno);\n    }).catch(error => {\n      _this.loading = false;\n      _this.emit(LOADER_EVENTS.LOADER_ERROR, _this.TAG, error);\n    });\n  }\n\n  getParams(opts) {\n    let options = Object.assign({}, opts);\n    let headers = new Headers();\n\n    let params = {\n      method: 'GET',\n      headers: headers,\n      mode: 'cors',\n      cache: 'default'\n\n      // add custmor headers\n      // 添加自定义头\n    };if (typeof this.configs.headers === 'object') {\n      let configHeaders = this.configs.headers;\n      for (let key in configHeaders) {\n        if (configHeaders.hasOwnProperty(key)) {\n          headers.append(key, configHeaders[key]);\n        }\n      }\n    }\n\n    if (typeof options.headers === 'object') {\n      let optHeaders = options.headers;\n      for (let key in optHeaders) {\n        if (optHeaders.hasOwnProperty(key)) {\n          headers.append(key, optHeaders[key]);\n        }\n      }\n    }\n\n    if (options.cors === false) {\n      params.mode = 'same-origin';\n    }\n\n    // withCredentials is disabled by default\n    // withCredentials 在默认情况下不被使用。\n    if (options.withCredentials) {\n      params.credentials = 'include';\n    }\n\n    // TODO: Add ranges;\n    return params;\n  }\n\n  cancel() {\n    if (this._reader) {\n      try {\n        this._reader.cancel();\n      } catch (e) {\n        // 防止failed: 200错误被打印到控制台上\n      }\n      this._reader = null;\n      this.loading = false;\n      this._canceled = true;\n    }\n  }\n\n  destroy() {\n    this._destroyed = true;\n    this.cancel();\n  }\n}\n\nexports.default = FetchLoader;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-loader/src/fetch-loader.js?")},"../xgplayer-remux/index.js":
/*!**********************************!*\
      !*** ../xgplayer-remux/index.js ***!
      \**********************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nmodule.exports = {\n  Mp4Remuxer: __webpack_require__(/*! ./src/mp4 */ "../xgplayer-remux/src/mp4/index.js").default\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-remux/index.js?')},"../xgplayer-remux/src/mp4/fmp4.js":
/*!*****************************************!*\
      !*** ../xgplayer-remux/src/mp4/fmp4.js ***!
      \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\n// const UINT32_MAX = Math.pow(2, 32) - 1;\nclass Fmp4 {\n  static size(value) {\n    return _xgplayerUtils.Buffer.writeUint32(value);\n  }\n  static initBox(size, name, ...content) {\n    const buffer = new _xgplayerUtils.Buffer();\n    buffer.write(Fmp4.size(size), Fmp4.type(name), ...content);\n    return buffer.buffer;\n  }\n  static extension(version, flag) {\n    return new Uint8Array([version, flag >> 16 & 0xff, flag >> 8 & 0xff, flag & 0xff]);\n  }\n  static ftyp() {\n    return Fmp4.initBox(24, 'ftyp', new Uint8Array([0x69, 0x73, 0x6F, 0x6D, // isom,\n    0x0, 0x0, 0x00, 0x01, // minor_version: 0x01\n    0x69, 0x73, 0x6F, 0x6D, // isom\n    0x61, 0x76, 0x63, 0x31 // avc1\n    ]));\n  }\n  static moov({ type, meta }) {\n    let size = 8;\n    let mvhd = Fmp4.mvhd(meta.duration, meta.timescale);\n    let trak;\n\n    if (type === 'video') {\n      trak = Fmp4.videoTrak(meta);\n    } else {\n      trak = Fmp4.audioTrak(meta);\n    }\n\n    let mvex = Fmp4.mvex(meta.duration, meta.timescale || 1000, meta.id);\n    [mvhd, trak, mvex].forEach(item => {\n      size += item.byteLength;\n    });\n    return Fmp4.initBox(size, 'moov', mvhd, trak, mvex);\n  }\n  static mvhd(duration, timescale = 1000) {\n    // duration *= timescale;\n    let bytes = new Uint8Array([0x00, 0x00, 0x00, 0x00, // version(0) + flags     1位的box版本+3位flags   box版本，0或1，一般为0。（以下字节数均按version=0）\n    0x00, 0x00, 0x00, 0x00, // creation_time    创建时间  （相对于UTC时间1904-01-01零点的秒数）\n    0x00, 0x00, 0x00, 0x00, // modification_time   修改时间\n\n    /**\n           * timescale: 4 bytes文件媒体在1秒时间内的刻度值，可以理解为1秒长度\n           */\n    timescale >>> 24 & 0xFF, timescale >>> 16 & 0xFF, timescale >>> 8 & 0xFF, timescale & 0xFF,\n\n    /**\n           * duration: 4 bytes该track的时间长度，用duration和time scale值可以计算track时长，比如audio track的time scale = 8000,\n           * duration = 560128，时长为70.016，video track的time scale = 600, duration = 42000，时长为70\n           */\n    duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, 0x00, 0x01, 0x00, 0x00, // Preferred rate: 1.0   推荐播放速率，高16位和低16位分别为小数点整数部分和小数部分，即[16.16] 格式，该值为1.0（0x00010000）表示正常前向播放\n    /**\n           * PreferredVolume(1.0, 2bytes) + reserved(2bytes)\n           * 与rate类似，[8.8] 格式，1.0（0x0100）表示最大音量\n           */\n    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //  reserved: 4 + 4 bytes保留位\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, // ----begin composition matrix----\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 视频变换矩阵   线性代数\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // ----end composition matrix----\n    0x00, 0x00, 0x00, 0x00, // ----begin pre_defined 6 * 4 bytes----\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre-defined 保留位\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ----end pre_defined 6 * 4 bytes----\n    0xFF, 0xFF, 0xFF, 0xFF // next_track_ID 下一个track使用的id号\n    ]);\n    return Fmp4.initBox(8 + bytes.length, 'mvhd', new Uint8Array(bytes));\n  }\n  static videoTrak(data) {\n    let size = 8;\n\n    let tkhd = Fmp4.tkhd({\n      id: 1,\n      duration: data.duration,\n      timescale: data.timescale || 1000,\n      width: data.presentWidth,\n      height: data.presentHeight,\n      type: 'video'\n    });\n    let mdia = Fmp4.mdia({\n      type: 'video',\n      timescale: data.timescale || 1000,\n      duration: data.duration,\n      avcc: data.avcc,\n      parRatio: data.parRatio,\n      width: data.presentWidth,\n      height: data.presentHeight\n    });\n    [tkhd, mdia].forEach(item => {\n      size += item.byteLength;\n    });\n    return Fmp4.initBox(size, 'trak', tkhd, mdia);\n  }\n  static audioTrak(data) {\n    let size = 8;\n    let tkhd = Fmp4.tkhd({\n      id: 2,\n      duration: data.duration,\n      timescale: data.timescale || 1000,\n      width: 0,\n      height: 0,\n      type: 'audio'\n    });\n    let mdia = Fmp4.mdia({\n      type: 'audio',\n      timescale: data.timescale || 1000,\n      duration: data.duration,\n      channelCount: data.channelCount,\n      samplerate: data.sampleRate,\n      config: data.config\n    });\n    [tkhd, mdia].forEach(item => {\n      size += item.byteLength;\n    });\n    return Fmp4.initBox(size, 'trak', tkhd, mdia);\n  }\n  static tkhd(data) {\n    let id = data.id;\n    let duration = data.duration;\n    let width = data.width;\n    let height = data.height;\n    let content = new Uint8Array([0x00, 0x00, 0x00, 0x07, // version(0) + flags 1位版本 box版本，0或1，一般为0。（以下字节数均按version=0）按位或操作结果值，预定义如下：\n    // 0x000001 track_enabled，否则该track不被播放；\n    // 0x000002 track_in_movie，表示该track在播放中被引用；\n    // 0x000004 track_in_preview，表示该track在预览时被引用。\n    // 一般该值为7，1+2+4 如果一个媒体所有track均未设置track_in_movie和track_in_preview，将被理解为所有track均设置了这两项；对于hint track，该值为0\n    // hint track 这个特殊的track并不包含媒体数据，而是包含了一些将其他数据track打包成流媒体的指示信息。\n    0x00, 0x00, 0x00, 0x00, // creation_time创建时间（相对于UTC时间1904-01-01零点的秒数）\n    0x00, 0x00, 0x00, 0x00, // modification time 修改时间\n    id >>> 24 & 0xFF, // track_ID: 4 bytes id号，不能重复且不能为0\n    id >>> 16 & 0xFF, id >>> 8 & 0xFF, id & 0xFF, 0x00, 0x00, 0x00, 0x00, // reserved: 4 bytes    保留位\n    duration >>> 24 & 0xFF, // duration: 4 bytes track的时间长度\n    duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, 0x00, 0x00, 0x00, 0x00, // reserved: 2 * 4 bytes    保留位\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // layer(2bytes) + alternate_group(2bytes)  视频层，默认为0，值小的在上层.track分组信息，默认为0表示该track未与其他track有群组关系\n    0x00, 0x00, 0x00, 0x00, // volume(2bytes) + reserved(2bytes)    [8.8] 格式，如果为音频track，1.0（0x0100）表示最大音量；否则为0   +保留位\n    0x00, 0x01, 0x00, 0x00, // ----begin composition matrix----\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, // 视频变换矩阵\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // ----end composition matrix----\n    width >>> 8 & 0xFF, // //宽度\n    width & 0xFF, 0x00, 0x00, height >>> 8 & 0xFF, // 高度\n    height & 0xFF, 0x00, 0x00]);\n    return Fmp4.initBox(8 + content.byteLength, 'tkhd', content);\n  }\n  static edts(data) {\n    let buffer = new _xgplayerUtils.Buffer();\n    let duration = data.duration;\n    let mediaTime = data.mediaTime;\n    buffer.write(Fmp4.size(36), Fmp4.type('edts'));\n    // elst\n    buffer.write(Fmp4.size(28), Fmp4.type('elst'));\n    buffer.write(new Uint8Array([0x00, 0x00, 0x00, 0x01, // entry count\n    duration >> 24 & 0xff, duration >> 16 & 0xff, duration >> 8 & 0xff, duration & 0xff, mediaTime >> 24 & 0xff, mediaTime >> 16 & 0xff, mediaTime >> 8 & 0xff, mediaTime & 0xff, 0x00, 0x00, 0x00, 0x01 // media rate\n    ]));\n    return buffer.buffer;\n  }\n  static mdia(data) {\n    let size = 8;\n    let mdhd = Fmp4.mdhd(data.timescale, data.duration);\n    let hdlr = Fmp4.hdlr(data.type);\n    let minf = Fmp4.minf(data);\n    [mdhd, hdlr, minf].forEach(item => {\n      size += item.byteLength;\n    });\n    return Fmp4.initBox(size, 'mdia', mdhd, hdlr, minf);\n  }\n  static mdhd(timescale = 1000, duration) {\n    let content = new Uint8Array([0x00, 0x00, 0x00, 0x00, // creation_time    创建时间\n    0x00, 0x00, 0x00, 0x00, // modification_time修改时间\n    timescale >>> 24 & 0xFF, // timescale: 4 bytes    文件媒体在1秒时间内的刻度值，可以理解为1秒长度\n    timescale >>> 16 & 0xFF, timescale >>> 8 & 0xFF, timescale & 0xFF, duration >>> 24 & 0xFF, // duration: 4 bytes  track的时间长度\n    duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, 0x55, 0xC4, // language: und (undetermined) 媒体语言码。最高位为0，后面15位为3个字符（见ISO 639-2/T标准中定义）\n    0x00, 0x00 // pre_defined = 0\n    ]);\n    return Fmp4.initBox(12 + content.byteLength, 'mdhd', Fmp4.extension(0, 0), content);\n  }\n  static hdlr(type) {\n    let value = [0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ];\n    if (type === 'audio') {\n      value.splice(8, 4, ...[0x73, 0x6f, 0x75, 0x6e]);\n      value.splice(24, 13, ...[0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00]);\n    }\n    return Fmp4.initBox(8 + value.length, 'hdlr', new Uint8Array(value));\n  }\n  static minf(data) {\n    let size = 8;\n    let vmhd = data.type === 'video' ? Fmp4.vmhd() : Fmp4.smhd();\n    let dinf = Fmp4.dinf();\n    let stbl = Fmp4.stbl(data);\n    [vmhd, dinf, stbl].forEach(item => {\n      size += item.byteLength;\n    });\n    return Fmp4.initBox(size, 'minf', vmhd, dinf, stbl);\n  }\n  static vmhd() {\n    return Fmp4.initBox(20, 'vmhd', new Uint8Array([0x00, // version\n    0x00, 0x00, 0x01, // flags\n    0x00, 0x00, // graphicsmode\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n    ]));\n  }\n  static smhd() {\n    return Fmp4.initBox(16, 'smhd', new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, // balance\n    0x00, 0x00 // reserved\n    ]));\n  }\n  static dinf() {\n    let buffer = new _xgplayerUtils.Buffer();\n    let dref = [0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // entry_count\n    0x00, 0x00, 0x00, 0x0c, // entry_size\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\n    0x00, // version 0\n    0x00, 0x00, 0x01 // entry_flags\n    ];\n    buffer.write(Fmp4.size(36), Fmp4.type('dinf'), Fmp4.size(28), Fmp4.type('dref'), new Uint8Array(dref));\n    return buffer.buffer;\n  }\n  static stbl(data) {\n    let size = 8;\n    let stsd = Fmp4.stsd(data);\n    let stts = Fmp4.stts();\n    let stsc = Fmp4.stsc();\n    let stsz = Fmp4.stsz();\n    let stco = Fmp4.stco();\n    [stsd, stts, stsc, stsz, stco].forEach(item => {\n      size += item.byteLength;\n    });\n    return Fmp4.initBox(size, 'stbl', stsd, stts, stsc, stsz, stco);\n  }\n  static stsd(data) {\n    let content;\n    if (data.type === 'audio') {\n      // if (!data.isAAC && data.codec === 'mp4') {\n      //     content = FMP4.mp3(data);\n      // } else {\n      //\n      // }\n      // 支持mp4a\n      content = Fmp4.mp4a(data);\n    } else {\n      content = Fmp4.avc1(data);\n    }\n    return Fmp4.initBox(16 + content.byteLength, 'stsd', Fmp4.extension(0, 0), new Uint8Array([0x00, 0x00, 0x00, 0x01]), content);\n  }\n  static mp4a(data) {\n    let content = new Uint8Array([0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, // data_reference_index\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, data.channelCount, // channelcount\n    0x00, 0x10, // sampleSize:16bits\n    0x00, 0x00, 0x00, 0x00, // reserved2\n    data.samplerate >> 8 & 0xff, data.samplerate & 0xff, //\n    0x00, 0x00]);\n    let esds = Fmp4.esds(data.config);\n    return Fmp4.initBox(8 + content.byteLength + esds.byteLength, 'mp4a', content, esds);\n  }\n  static esds(config = [43, 146, 8, 0]) {\n    const configlen = config.length;\n    let buffer = new _xgplayerUtils.Buffer();\n    let content = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n\n    0x03, // descriptor_type\n    0x17 + configlen, // length\n    0x00, 0x01, // es_id\n    0x00, // stream_priority\n\n    0x04, // descriptor_type\n    0x0f + configlen, // length\n    0x40, // codec : mpeg4_audio\n    0x15, // stream_type\n    0x00, 0x00, 0x00, // buffer_size\n    0x00, 0x00, 0x00, 0x00, // maxBitrate\n    0x00, 0x00, 0x00, 0x00, // avgBitrate\n\n    0x05 // descriptor_type\n    ].concat([configlen]).concat(config).concat([0x06, 0x01, 0x02]));\n    buffer.write(Fmp4.size(8 + content.byteLength), Fmp4.type('esds'), content);\n    return buffer.buffer;\n  }\n  static avc1(data) {\n    let buffer = new _xgplayerUtils.Buffer();\n    let size = 40; // 8(avc1)+8(avcc)+8(btrt)+16(pasp)\n    // let sps = data.sps\n    // let pps = data.pps\n    let width = data.width;\n    let height = data.height;\n    let hSpacing = data.parRatio.height;\n    let vSpacing = data.parRatio.width;\n    // let avccBuffer = new Buffer()\n    // avccBuffer.write(new Uint8Array([\n    //   0x01, // version\n    //   sps[1], // profile\n    //   sps[2], // profile compatible\n    //   sps[3], // level\n    //   0xfc | 3,\n    //   0xE0 | 1 // 目前只处理一个sps\n    // ].concat([sps.length >>> 8 & 0xff, sps.length & 0xff])))\n    // avccBuffer.write(sps, new Uint8Array([1, pps.length >>> 8 & 0xff, pps.length & 0xff]), pps)\n\n    let avcc = data.avcc;\n    let avc1 = new Uint8Array([0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, // data_reference_index\n    0x00, 0x00, // pre_defined\n    0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n    width >> 8 & 0xff, width & 0xff, // width\n    height >> 8 & 0xff, height & 0xff, // height\n    0x00, 0x48, 0x00, 0x00, // horizresolution\n    0x00, 0x48, 0x00, 0x00, // vertresolution\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, // frame_count\n    0x12, 0x64, 0x61, 0x69, 0x6C, // dailymotion/hls.js\n    0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname\n    0x00, 0x18, // depth = 24\n    0x11, 0x11]); // pre_defined = -1\n    let btrt = new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n    0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n    0x00, 0x2d, 0xc6, 0xc0 // avgBitrate\n    ]);\n    let pasp = new Uint8Array([hSpacing >> 24, // hSpacing\n    hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24, // vSpacing\n    vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff]);\n\n    buffer.write(Fmp4.size(size + avc1.byteLength + avcc.byteLength + btrt.byteLength), Fmp4.type('avc1'), avc1, Fmp4.size(8 + avcc.byteLength), Fmp4.type('avcC'), avcc, Fmp4.size(20), Fmp4.type('btrt'), btrt, Fmp4.size(16), Fmp4.type('pasp'), pasp);\n    return buffer.buffer;\n  }\n  static stts() {\n    let content = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n    return Fmp4.initBox(16, 'stts', content);\n  }\n  static stsc() {\n    let content = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n    return Fmp4.initBox(16, 'stsc', content);\n  }\n  static stco() {\n    let content = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n    return Fmp4.initBox(16, 'stco', content);\n  }\n  static stsz() {\n    let content = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n    ]);\n    return Fmp4.initBox(20, 'stsz', content);\n  }\n  static mvex(duration, timescale = 1000, trackID) {\n    let buffer = new _xgplayerUtils.Buffer();\n    let mehd = _xgplayerUtils.Buffer.writeUint32(duration);\n    buffer.write(Fmp4.size(56), Fmp4.type('mvex'), Fmp4.size(16), Fmp4.type('mehd'), Fmp4.extension(0, 0), mehd, Fmp4.trex(trackID));\n    return buffer.buffer;\n  }\n  static trex(id) {\n    let content = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff, // track_ID\n    0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]);\n    return Fmp4.initBox(8 + content.byteLength, 'trex', content);\n  }\n  static moof(data) {\n    let size = 8;\n    let mfhd = Fmp4.mfhd();\n    let traf = Fmp4.traf(data);\n    [mfhd, traf].forEach(item => {\n      size += item.byteLength;\n    });\n    return Fmp4.initBox(size, 'moof', mfhd, traf);\n  }\n  static mfhd() {\n    let content = _xgplayerUtils.Buffer.writeUint32(Fmp4.sequence);\n    Fmp4.sequence += 1;\n    return Fmp4.initBox(16, 'mfhd', Fmp4.extension(0, 0), content);\n  }\n  static traf(data) {\n    let size = 8;\n    let tfhd = Fmp4.tfhd(data.id);\n    let tfdt = Fmp4.tfdt(data.time);\n    let sdtp = Fmp4.sdtp(data);\n    let trun = Fmp4.trun(data, sdtp.byteLength);\n\n    [tfhd, tfdt, trun, sdtp].forEach(item => {\n      size += item.byteLength;\n    });\n    return Fmp4.initBox(size, 'traf', tfhd, tfdt, trun, sdtp);\n  }\n  static tfhd(id) {\n    let content = _xgplayerUtils.Buffer.writeUint32(id);\n    return Fmp4.initBox(16, 'tfhd', Fmp4.extension(0, 0), content);\n  }\n  static tfdt(time) {\n    // let upper = Math.floor(time / (UINT32_MAX + 1)),\n    //     lower = Math.floor(time % (UINT32_MAX + 1));\n    return Fmp4.initBox(16, 'tfdt', Fmp4.extension(0, 0), _xgplayerUtils.Buffer.writeUint32(time));\n  }\n  static trun(data, sdtpLength) {\n    // let id = data.id;\n    // let ceil = id === 1 ? 16 : 12;\n    let buffer = new _xgplayerUtils.Buffer();\n    let sampleCount = _xgplayerUtils.Buffer.writeUint32(data.samples.length);\n    // mdat-header 8\n    // moof-header 8\n    // mfhd 16\n    // traf-header 8\n    // thhd 16\n    // tfdt 20\n    // trun-header 12\n    // sampleCount 4\n    // data-offset 4\n    // samples.length\n    let offset = _xgplayerUtils.Buffer.writeUint32(8 + 8 + 16 + 8 + 16 + 16 + 12 + 4 + 4 + 16 * data.samples.length + sdtpLength);\n    buffer.write(Fmp4.size(20 + 16 * data.samples.length), Fmp4.type('trun'), new Uint8Array([0x00, 0x00, 0x0F, 0x01]), sampleCount, offset);\n\n    // let size = buffer.buffer.byteLength\n    // let writeOffset = 0\n    // data.samples.forEach(() => {\n    //   size += 16\n    // })\n    //\n    // let trunBox = new Uint8Array(size)\n\n    // trunBox.set(buffer.buffer, 0)\n\n    data.samples.forEach(item => {\n      const flags = item.flags;\n      // console.log(item.type, item.dts, item.duration)\n\n      buffer.write(new Uint8Array([item.duration >>> 24 & 0xFF, // sample_duration\n      item.duration >>> 16 & 0xFF, item.duration >>> 8 & 0xFF, item.duration & 0xFF, item.size >>> 24 & 0xFF, // sample_size\n      item.size >>> 16 & 0xFF, item.size >>> 8 & 0xFF, item.size & 0xFF, flags.isLeading << 2 | flags.dependsOn, // sample_flags\n      flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.isNonSync, 0x00, 0x00, // sample_degradation_priority\n      item.cts >>> 24 & 0xFF, // sample_composition_time_offset\n      item.cts >>> 16 & 0xFF, item.cts >>> 8 & 0xFF, item.cts & 0xFF]));\n      // writeOffset += 16\n      // buffer.write(Buffer.writeUint32(0));\n    });\n    return buffer.buffer;\n  }\n  static sdtp(data) {\n    let buffer = new _xgplayerUtils.Buffer();\n    buffer.write(Fmp4.size(12 + data.samples.length), Fmp4.type('sdtp'), Fmp4.extension(0, 0));\n    data.samples.forEach(item => {\n      const flags = item.flags;\n      const num = flags.isLeading << 6 | // is_leading: 2 (bit)\n      flags.dependsOn << 4 | // sample_depends_on\n      flags.isDependedOn << 2 | // sample_is_depended_on\n      flags.hasRedundancy; // sample_has_redundancy\n\n      buffer.write(new Uint8Array([num]));\n    });\n    return buffer.buffer;\n  }\n  static mdat(data) {\n    let buffer = new _xgplayerUtils.Buffer();\n    let size = 8;\n    data.samples.forEach(item => {\n      size += item.size;\n    });\n    buffer.write(Fmp4.size(size), Fmp4.type('mdat'));\n    let mdatBox = new Uint8Array(size);\n    let offset = 0;\n    mdatBox.set(buffer.buffer, offset);\n    offset += 8;\n    data.samples.forEach(item => {\n      item.buffer.forEach(unit => {\n        mdatBox.set(unit, offset);\n        offset += unit.byteLength;\n        // buffer.write(unit.data);\n      });\n    });\n    return mdatBox;\n  }\n}\nFmp4.type = name => {\n  return new Uint8Array([name.charCodeAt(0), name.charCodeAt(1), name.charCodeAt(2), name.charCodeAt(3)]);\n};\nFmp4.sequence = 1;\n\nexports.default = Fmp4;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-remux/src/mp4/fmp4.js?")},"../xgplayer-remux/src/mp4/index.js":
/*!******************************************!*\
      !*** ../xgplayer-remux/src/mp4/index.js ***!
      \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nvar _fmp = __webpack_require__(/*! ./fmp4 */ \"../xgplayer-remux/src/mp4/fmp4.js\");\n\nvar _fmp2 = _interopRequireDefault(_fmp);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst REMUX_EVENTS = _xgplayerUtils.EVENTS.REMUX_EVENTS;\n\nclass Mp4Remuxer {\n  constructor() {\n    this._dtsBase = 0;\n    this._isDtsBaseInited = false;\n\n    this.isFirstVideo = true;\n    this.isFirstAudio = true;\n\n    this.videoAllDuration = 0;\n    this.audioAllDuration = 0;\n  }\n\n  init() {\n    this.on(REMUX_EVENTS.REMUX_MEDIA, this.remux.bind(this));\n    this.on(REMUX_EVENTS.REMUX_METADATA, this.onMetaDataReady.bind(this));\n    this.on(REMUX_EVENTS.DETECT_CHANGE_STREAM, this.resetDtsBase.bind(this));\n  }\n\n  destroy() {\n    this._dtsBase = -1;\n    this._dtsBaseInited = false;\n  }\n\n  reset() {\n    this._dtsBase = 0;\n    this._isDtsBaseInited = false;\n  }\n\n  remux() {\n    const { audioTrack, videoTrack } = this._context.getInstance('TRACKS');\n    !this._isDtsBaseInited && this.calcDtsBase(audioTrack, videoTrack);\n\n    this._remuxVideo(videoTrack);\n    this._remuxAudio(audioTrack);\n  }\n\n  resetDtsBase() {\n    // for hls 中途切换 meta后seek\n    this._dtsBase = 0;\n    this._dtsBaseInited = false;\n  }\n\n  seek() {}\n\n  onMetaDataReady(type) {\n    let track;\n\n    if (type === 'audio') {\n      const { audioTrack } = this._context.getInstance('TRACKS');\n      track = audioTrack;\n    } else {\n      const { videoTrack } = this._context.getInstance('TRACKS');\n      track = videoTrack;\n    }\n\n    let presourcebuffer = this._context.getInstance('PRE_SOURCE_BUFFER');\n    let source = presourcebuffer.getSource(type);\n    if (!source) {\n      source = presourcebuffer.createSource(type);\n    }\n\n    source.mimetype = track.meta.codec;\n    source.init = this.remuxInitSegment(type, track.meta);\n    // source.inited = false;\n\n    // this.resetDtsBase()\n    this.emit(REMUX_EVENTS.INIT_SEGMENT, type);\n  }\n\n  remuxInitSegment(type, meta) {\n    let initSegment = new _xgplayerUtils.Buffer();\n    let ftyp = _fmp2.default.ftyp();\n    let moov = _fmp2.default.moov({ type, meta: meta });\n\n    initSegment.write(ftyp, moov);\n    return initSegment;\n  }\n\n  calcDtsBase(audioTrack, videoTrack) {\n    if (!audioTrack.samples.length && !videoTrack.samples.length) {\n      return;\n    }\n\n    let audioBase = Infinity;\n    let videoBase = Infinity;\n\n    if (audioTrack.samples && audioTrack.samples.length) {\n      audioBase = audioTrack.samples[0].dts;\n    }\n    if (videoTrack.samples && videoTrack.samples.length) {\n      videoBase = videoTrack.samples[0].dts;\n    }\n\n    this._dtsBase = Math.min(audioBase, videoBase);\n    this._isDtsBaseInited = true;\n  }\n\n  _remuxVideo(videoTrack) {\n    const track = videoTrack;\n\n    if (!videoTrack.samples || !videoTrack.samples.length) {\n      return;\n    }\n\n    let { samples } = track;\n    let firstDts = -1;\n\n    let initSegment = null;\n    const mp4Samples = [];\n    const mdatBox = {\n      samples: []\n    };\n\n    while (samples.length) {\n      const avcSample = samples.shift();\n\n      const { isKeyframe, options } = avcSample;\n      if (!this.isFirstAudio && options && options.meta) {\n        initSegment = this.remuxInitSegment('video', options.meta);\n        options.meta = null;\n        samples.unshift(avcSample);\n        if (!options.isContinue) {\n          this.resetDtsBase();\n        }\n        break;\n      }\n\n      let dts = avcSample.dts - this._dtsBase;\n\n      if (firstDts === -1) {\n        firstDts = dts;\n      }\n\n      let cts;\n      let pts;\n      if (avcSample.pts !== undefined) {\n        pts = avcSample.pts - this._dtsBase;\n        cts = pts - dts;\n      }\n      if (avcSample.cts !== undefined) {\n        pts = avcSample.cts + dts;\n        cts = avcSample.cts;\n      }\n\n      let mdatSample = {\n        buffer: [],\n        size: 0\n      };\n      mdatBox.samples.push(mdatSample);\n      mdatSample.buffer.push(avcSample.data);\n      mdatSample.size += avcSample.data.byteLength;\n\n      let sampleDuration = 0;\n      if (samples.length >= 1) {\n        const nextDts = samples[0].dts - this._dtsBase;\n        sampleDuration = nextDts - dts;\n      } else {\n        if (mp4Samples.length >= 1) {\n          // lastest sample, use second last duration\n          sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n        } else {\n          // the only one sample, use reference duration\n          sampleDuration = this.videoMeta.refSampleDuration;\n        }\n      }\n      this.videoAllDuration += sampleDuration;\n      // console.log(`dts ${dts}`, `pts ${pts}`, `cts: ${cts}`, `duration: ${sampleDuration}`, avcSample)\n      mp4Samples.push({\n        dts,\n        cts,\n        pts,\n        data: avcSample.data,\n        size: avcSample.data.byteLength,\n        isKeyframe,\n        duration: sampleDuration,\n        flags: {\n          isLeading: 0,\n          dependsOn: isKeyframe ? 2 : 1,\n          isDependedOn: isKeyframe ? 1 : 0,\n          hasRedundancy: 0,\n          isNonSync: isKeyframe ? 0 : 1\n        },\n        originDts: dts,\n        type: 'video'\n      });\n    }\n\n    let moofMdat = new _xgplayerUtils.Buffer();\n    if (mp4Samples.length) {\n      const moof = _fmp2.default.moof({\n        id: track.meta.id,\n        time: firstDts,\n        samples: mp4Samples\n      });\n      const mdat = _fmp2.default.mdat(mdatBox);\n      moofMdat.write(moof, mdat);\n\n      this.writeToSource('video', moofMdat);\n    }\n\n    if (initSegment) {\n      this.writeToSource('video', initSegment);\n\n      if (samples.length) {\n        // second part of stream change\n        track.samples = samples;\n        return this._remuxVideo(track);\n      }\n    }\n\n    this.isFirstVideo = false;\n    this.emit(REMUX_EVENTS.MEDIA_SEGMENT, 'video');\n\n    const lastSample = mp4Samples[mp4Samples.length - 1];\n    this._videoNextDts = lastSample.dts + lastSample.duration;\n    track.samples = [];\n    track.length = 0;\n  }\n\n  _remuxAudio(track) {\n    const { samples } = track;\n    let firstDts = -1;\n    let mp4Samples = [];\n\n    let initSegment = null;\n    const mdatBox = {\n      samples: []\n    };\n    if (!samples || !samples.length) {\n      return;\n    }\n    let isFirstDtsInited = false;\n    while (samples.length) {\n      let sample = samples.shift();\n      const { data, options } = sample;\n      if (!this.isFirstAudio && options && options.meta) {\n        initSegment = this.remuxInitSegment('audio', options.meta);\n        options.meta = null;\n        samples.unshift(sample);\n        if (!options.isContinue) {\n          this.resetDtsBase();\n        }\n        break;\n      }\n\n      let dts = sample.dts - this._dtsBase;\n      const originDts = dts;\n      if (!isFirstDtsInited) {\n        firstDts = dts;\n        isFirstDtsInited = true;\n      }\n\n      let sampleDuration = 0;\n\n      if (this.audioMeta.refSampleDurationFixed) {\n        sampleDuration = this.audioMeta.refSampleDurationFixed;\n      } else if (samples.length >= 1) {\n        const nextDts = samples[0].dts - this._dtsBase;\n        sampleDuration = nextDts - dts;\n      } else {\n        if (mp4Samples.length >= 1) {\n          // use second last sample duration\n          sampleDuration = mp4Samples[mp4Samples.length - 1].duration;\n        } else {\n          // the only one sample, use reference sample duration\n          sampleDuration = this.audioMeta.refSampleDuration;\n        }\n      }\n\n      // console.log('remux audio ', dts)\n      this.audioAllDuration += sampleDuration;\n      const mp4Sample = {\n        dts,\n        pts: dts,\n        cts: 0,\n        size: data.byteLength,\n        duration: sample.duration ? sample.duration : sampleDuration,\n        flags: {\n          isLeading: 0,\n          dependsOn: 2,\n          isDependedOn: 1,\n          hasRedundancy: 0,\n          isNonSync: 0\n        },\n        isKeyframe: true,\n        originDts,\n        type: 'audio'\n      };\n\n      let mdatSample = {\n        buffer: [],\n        size: 0\n      };\n      mdatSample.buffer.push(data);\n      mdatSample.size += data.byteLength;\n\n      mdatBox.samples.push(mdatSample);\n\n      mp4Samples.push(mp4Sample);\n    }\n\n    const moofMdat = new _xgplayerUtils.Buffer();\n\n    if (mp4Samples.length) {\n      const moof = _fmp2.default.moof({\n        id: track.meta.id,\n        time: firstDts,\n        samples: mp4Samples\n      });\n      const mdat = _fmp2.default.mdat(mdatBox);\n      moofMdat.write(moof, mdat);\n\n      this.writeToSource('audio', moofMdat);\n    }\n\n    if (initSegment) {\n      this.writeToSource('audio', initSegment);\n      if (samples.length) {\n        // second part of stream change\n        track.samples = samples;\n        return this._remuxAudio(track);\n      }\n    }\n\n    this.isFirstAudio = false;\n    this.emit(REMUX_EVENTS.MEDIA_SEGMENT, 'audio', moofMdat);\n\n    const lastSample = mp4Samples[mp4Samples.length - 1];\n    this._videoNextDts = lastSample.dts + lastSample.duration;\n    track.samples = [];\n    track.length = 0;\n  }\n\n  writeToSource(type, buffer) {\n    let presourcebuffer = this._context.getInstance('PRE_SOURCE_BUFFER');\n    let source = presourcebuffer.getSource(type);\n    if (!source) {\n      source = presourcebuffer.createSource(type);\n    }\n\n    source.data.push(buffer);\n  }\n\n  initSilentAudio(dts, duration) {\n    const unit = Mp4Remuxer.getSilentFrame(this.audioMeta.channelCount);\n    return {\n      dts,\n      pts: dts,\n      cts: 0,\n      duration,\n      unit,\n      size: unit.byteLength,\n      originDts: dts,\n      type: 'video'\n    };\n  }\n\n  get videoMeta() {\n    return this._context.getInstance('TRACKS').videoTrack.meta;\n  }\n  get audioMeta() {\n    return this._context.getInstance('TRACKS').audioTrack.meta;\n  }\n\n  static getSilentFrame(channelCount) {\n    if (channelCount === 1) {\n      return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n    } else if (channelCount === 2) {\n      return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n    } else if (channelCount === 3) {\n      return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n    } else if (channelCount === 4) {\n      return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n    } else if (channelCount === 5) {\n      return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n    } else if (channelCount === 6) {\n      return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n    }\n    return null;\n  }\n}\nexports.default = Mp4Remuxer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-remux/src/mp4/index.js?")},"../xgplayer-utils/index.js":
/*!**********************************!*\
      !*** ../xgplayer-utils/index.js ***!
      \**********************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nmodule.exports = {\n  Context: __webpack_require__(/*! ./src/context */ "../xgplayer-utils/src/context.js").default,\n\n  // Modules from constants\n  EVENTS: __webpack_require__(/*! ./src/constants/events */ "../xgplayer-utils/src/constants/events.js").default,\n  WORKER_COMMANDS: __webpack_require__(/*! ./src/constants/worker-commands */ "../xgplayer-utils/src/constants/worker-commands.js").default,\n\n  // Modules from env\n  sniffer: __webpack_require__(/*! ./src/env/sniffer */ "../xgplayer-utils/src/env/sniffer.js").default,\n  isLe: __webpack_require__(/*! ./src/env/isle */ "../xgplayer-utils/src/env/isle.js").default,\n  UTF8: __webpack_require__(/*! ./src/env/utf8 */ "../xgplayer-utils/src/env/utf8.js").default,\n\n  // Models\n  MediaInfo: __webpack_require__(/*! ./src/models/media-info */ "../xgplayer-utils/src/models/media-info.js").default,\n  MediaSample: __webpack_require__(/*! ./src/models/media-sample */ "../xgplayer-utils/src/models/media-sample.js").default,\n  MediaSegment: __webpack_require__(/*! ./src/models/media-segment */ "../xgplayer-utils/src/models/media-segment.js").default,\n  MediaSegmentList: __webpack_require__(/*! ./src/models/media-segment-list */ "../xgplayer-utils/src/models/media-segment-list.js").default,\n  AudioTrackMeta: __webpack_require__(/*! ./src/models/track-meta */ "../xgplayer-utils/src/models/track-meta.js").AudioTrackMeta,\n  VideoTrackMeta: __webpack_require__(/*! ./src/models/track-meta */ "../xgplayer-utils/src/models/track-meta.js").VideoTrackMeta,\n  AudioTrackSample: __webpack_require__(/*! ./src/models/track-sample */ "../xgplayer-utils/src/models/track-sample.js").AudioTrackSample,\n  VideoTrackSample: __webpack_require__(/*! ./src/models/track-sample */ "../xgplayer-utils/src/models/track-sample.js").VideoTrackSample,\n\n  // Modules from mse\n  Mse: __webpack_require__(/*! ./src/mse/index */ "../xgplayer-utils/src/mse/index.js").default,\n\n  // Modules from write\n  Stream: __webpack_require__(/*! ./src/write/stream */ "../xgplayer-utils/src/write/stream.js").default,\n  Buffer: __webpack_require__(/*! ./src/write/buffer */ "../xgplayer-utils/src/write/buffer.js").default,\n\n  MobileVideo: __webpack_require__(/*! ./src/mobile/mobile-video */ "../xgplayer-utils/src/mobile/mobile-video.js"),\n  // Crypto\n  Crypto: __webpack_require__(/*! ./src/crypto */ "../xgplayer-utils/src/crypto/index.js").default\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/index.js?')},"../xgplayer-utils/node_modules/concat-typed-array/lib/concat.js":
/*!***********************************************************************!*\
      !*** ../xgplayer-utils/node_modules/concat-typed-array/lib/concat.js ***!
      \***********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nexports.default = function (ResultConstructor) {\n  var totalLength = 0;\n\n  for (var _len = arguments.length, arrays = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    arrays[_key - 1] = arguments[_key];\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = arrays[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var arr = _step.value;\n\n      totalLength += arr.length;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var result = new ResultConstructor(totalLength);\n  var offset = 0;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = arrays[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _arr = _step2.value;\n\n      result.set(_arr, offset);\n      offset += _arr.length;\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return result;\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/node_modules/concat-typed-array/lib/concat.js?')},"../xgplayer-utils/node_modules/concat-typed-array/lib/index.js":
/*!**********************************************************************!*\
      !*** ../xgplayer-utils/node_modules/concat-typed-array/lib/index.js ***!
      \**********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nvar _concat = __webpack_require__(/*! ./concat */ "../xgplayer-utils/node_modules/concat-typed-array/lib/concat.js");\n\nvar _concat2 = _interopRequireDefault(_concat);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nmodule.exports = _concat2.default;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/node_modules/concat-typed-array/lib/index.js?')},"../xgplayer-utils/node_modules/webworkify-webpack/index.js":
/*!******************************************************************!*\
      !*** ../xgplayer-utils/node_modules/webworkify-webpack/index.js ***!
      \******************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nfunction webpackBootstrapFunc(modules) {\n  /******/ // The module cache\n  /******/var installedModules = {};\n\n  /******/ // The require function\n  /******/function __webpack_require__(moduleId) {\n\n    /******/ // Check if module is in cache\n    /******/if (installedModules[moduleId])\n      /******/return installedModules[moduleId].exports;\n\n    /******/ // Create a new module (and put it into the cache)\n    /******/var module = installedModules[moduleId] = {\n      /******/i: moduleId,\n      /******/l: false,\n      /******/exports: {}\n      /******/ };\n\n    /******/ // Execute the module function\n    /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n    /******/ // Flag the module as loaded\n    /******/module.l = true;\n\n    /******/ // Return the exports of the module\n    /******/return module.exports;\n    /******/\n  }\n\n  /******/ // expose the modules object (__webpack_modules__)\n  /******/__webpack_require__.m = modules;\n\n  /******/ // expose the module cache\n  /******/__webpack_require__.c = installedModules;\n\n  /******/ // identity function for calling harmony imports with the correct context\n  /******/__webpack_require__.i = function (value) {\n    return value;\n  };\n\n  /******/ // define getter function for harmony exports\n  /******/__webpack_require__.d = function (exports, name, getter) {\n    /******/if (!__webpack_require__.o(exports, name)) {\n      /******/Object.defineProperty(exports, name, {\n        /******/configurable: false,\n        /******/enumerable: true,\n        /******/get: getter\n        /******/ });\n      /******/\n    }\n    /******/\n  };\n\n  /******/ // define __esModule on exports\n  /******/__webpack_require__.r = function (exports) {\n    /******/Object.defineProperty(exports, '__esModule', { value: true });\n    /******/\n  };\n\n  /******/ // getDefaultExport function for compatibility with non-harmony modules\n  /******/__webpack_require__.n = function (module) {\n    /******/var getter = module && module.__esModule ?\n    /******/function getDefault() {\n      return module['default'];\n    } :\n    /******/function getModuleExports() {\n      return module;\n    };\n    /******/__webpack_require__.d(getter, 'a', getter);\n    /******/return getter;\n    /******/\n  };\n\n  /******/ // Object.prototype.hasOwnProperty.call\n  /******/__webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n\n  /******/ // __webpack_public_path__\n  /******/__webpack_require__.p = \"/\";\n\n  /******/ // on error function for async loading\n  /******/__webpack_require__.oe = function (err) {\n    console.error(err);throw err;\n  };\n\n  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE);\n  return f.default || f; // try to call default if defined to also support babel esmodule exports\n}\n\nvar moduleNameReqExp = '[\\\\.|\\\\-|\\\\+|\\\\w|\\/|@]+';\nvar dependencyRegExp = '\\\\(\\\\s*(\\/\\\\*.*?\\\\*\\/)?\\\\s*.*?(' + moduleNameReqExp + ').*?\\\\)'; // additional chars when output.pathinfo is true\n\n// http://stackoverflow.com/a/2593661/130442\nfunction quoteRegExp(str) {\n  return (str + '').replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&');\n}\n\nfunction isNumeric(n) {\n  return !isNaN(1 * n); // 1 * n converts integers, integers as string (\"123\"), 1e3 and \"1e3\" to integers and strings to NaN\n}\n\nfunction getModuleDependencies(sources, module, queueName) {\n  var retval = {};\n  retval[queueName] = [];\n\n  var fnString = module.toString();\n  var wrapperSignature = fnString.match(/^function\\s?\\w*\\(\\w+,\\s*\\w+,\\s*(\\w+)\\)/);\n  if (!wrapperSignature) return retval;\n  var webpackRequireName = wrapperSignature[1];\n\n  // main bundle deps\n  var re = new RegExp('(\\\\\\\\n|\\\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g');\n  var match;\n  while (match = re.exec(fnString)) {\n    if (match[3] === 'dll-reference') continue;\n    retval[queueName].push(match[3]);\n  }\n\n  // dll deps\n  re = new RegExp('\\\\(' + quoteRegExp(webpackRequireName) + '\\\\(\"(dll-reference\\\\s(' + moduleNameReqExp + '))\"\\\\)\\\\)' + dependencyRegExp, 'g');\n  while (match = re.exec(fnString)) {\n    if (!sources[match[2]]) {\n      retval[queueName].push(match[1]);\n      sources[match[2]] = __webpack_require__(match[1]).m;\n    }\n    retval[match[2]] = retval[match[2]] || [];\n    retval[match[2]].push(match[4]);\n  }\n\n  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3\n  var keys = Object.keys(retval);\n  for (var i = 0; i < keys.length; i++) {\n    for (var j = 0; j < retval[keys[i]].length; j++) {\n      if (isNumeric(retval[keys[i]][j])) {\n        retval[keys[i]][j] = 1 * retval[keys[i]][j];\n      }\n    }\n  }\n\n  return retval;\n}\n\nfunction hasValuesInQueues(queues) {\n  var keys = Object.keys(queues);\n  return keys.reduce(function (hasValues, key) {\n    return hasValues || queues[key].length > 0;\n  }, false);\n}\n\nfunction getRequiredModules(sources, moduleId) {\n  var modulesQueue = {\n    main: [moduleId]\n  };\n  var requiredModules = {\n    main: []\n  };\n  var seenModules = {\n    main: {}\n  };\n\n  while (hasValuesInQueues(modulesQueue)) {\n    var queues = Object.keys(modulesQueue);\n    for (var i = 0; i < queues.length; i++) {\n      var queueName = queues[i];\n      var queue = modulesQueue[queueName];\n      var moduleToCheck = queue.pop();\n      seenModules[queueName] = seenModules[queueName] || {};\n      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue;\n      seenModules[queueName][moduleToCheck] = true;\n      requiredModules[queueName] = requiredModules[queueName] || [];\n      requiredModules[queueName].push(moduleToCheck);\n      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName);\n      var newModulesKeys = Object.keys(newModules);\n      for (var j = 0; j < newModulesKeys.length; j++) {\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || [];\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]]);\n      }\n    }\n  }\n\n  return requiredModules;\n}\n\nmodule.exports = function (moduleId, options) {\n  options = options || {};\n  var sources = {\n    main: __webpack_require__.m\n  };\n\n  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId);\n\n  var src = '';\n\n  Object.keys(requiredModules).filter(function (m) {\n    return m !== 'main';\n  }).forEach(function (module) {\n    var entryModule = 0;\n    while (requiredModules[module][entryModule]) {\n      entryModule++;\n    }\n    requiredModules[module].push(entryModule);\n    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })';\n    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) {\n      return '' + JSON.stringify(id) + ': ' + sources[module][id].toString();\n    }).join(',') + '});\\n';\n  });\n\n  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) {\n    return '' + JSON.stringify(id) + ': ' + sources.main[id].toString();\n  }).join(',') + '}))(self);';\n\n  var blob = new window.Blob([src], { type: 'text/javascript' });\n  if (options.bare) {\n    return blob;\n  }\n\n  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\n  var workerUrl = URL.createObjectURL(blob);\n  var worker = new window.Worker(workerUrl);\n  worker.objectURL = workerUrl;\n\n  return worker;\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/node_modules/webworkify-webpack/index.js?")},"../xgplayer-utils/src/constants/events.js":
/*!*************************************************!*\
      !*** ../xgplayer-utils/src/constants/events.js ***!
      \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst LOADER_EVENTS = {\n  LADER_START: 'LOADER_START',\n  LOADER_DATALOADED: 'LOADER_DATALOADED',\n  LOADER_COMPLETE: 'LOADER_COMPLETE',\n  LOADER_ERROR: 'LOADER_ERROR'\n};\n\nconst DEMUX_EVENTS = {\n  DEMUX_START: 'DEMUX_START',\n  DEMUX_COMPLETE: 'DEMUX_COMPLETE',\n  DEMUX_ERROR: 'DEMUX_ERROR',\n  METADATA_PARSED: 'METADATA_PARSED',\n  VIDEO_METADATA_CHANGE: 'VIDEO_METADATA_CHANGE',\n  AUDIO_METADATA_CHANGE: 'AUDIO_METADATA_CHANGE',\n  MEDIA_INFO: 'MEDIA_INFO'\n};\n\nconst REMUX_EVENTS = {\n  REMUX_METADATA: 'REMUX_METADATA',\n  REMUX_MEDIA: 'REMUX_MEDIA',\n  MEDIA_SEGMENT: 'MEDIA_SEGMENT',\n  REMUX_ERROR: 'REMUX_ERROR',\n  INIT_SEGMENT: 'INIT_SEGMENT',\n  DETECT_CHANGE_STREAM: 'DETECT_CHANGE_STREAM'\n};\n\nconst MSE_EVENTS = {\n  SOURCE_UPDATE_END: 'SOURCE_UPDATE_END'\n\n  // hls专有events\n};const HLS_EVENTS = {\n  RETRY_TIME_EXCEEDED: 'RETRY_TIME_EXCEEDED'\n};\n\nconst CRYTO_EVENTS = {\n  START_DECRYPT: 'START_DECRYPT',\n  DECRYPTED: 'DECRYPTED'\n};\nconst ALLEVENTS = Object.assign({}, LOADER_EVENTS, DEMUX_EVENTS, REMUX_EVENTS, MSE_EVENTS, HLS_EVENTS);\n\nconst FlvAllowedEvents = [];\nconst HlsAllowedEvents = [];\n\nfor (let key in ALLEVENTS) {\n  if (ALLEVENTS.hasOwnProperty(key)) {\n    FlvAllowedEvents.push(ALLEVENTS[key]);\n  }\n}\n\nfor (let key in ALLEVENTS) {\n  if (ALLEVENTS.hasOwnProperty(key)) {\n    HlsAllowedEvents.push(ALLEVENTS[key]);\n  }\n}\n\nexports.default = {\n  ALLEVENTS,\n  HLS_EVENTS,\n  REMUX_EVENTS,\n  DEMUX_EVENTS,\n  MSE_EVENTS,\n  LOADER_EVENTS,\n  FlvAllowedEvents,\n  HlsAllowedEvents,\n  CRYTO_EVENTS\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/constants/events.js?")},"../xgplayer-utils/src/constants/worker-commands.js":
/*!**********************************************************!*\
      !*** ../xgplayer-utils/src/constants/worker-commands.js ***!
      \**********************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst CONTEXT_COMOMANDS = exports.CONTEXT_COMOMANDS = {\n  ON: 'on',\n  ONCE: 'once',\n  OFF: 'off',\n  EMIT: 'emit',\n  DESTROY: 'destroy'\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/constants/worker-commands.js?")},"../xgplayer-utils/src/context.js":
/*!****************************************!*\
      !*** ../xgplayer-utils/src/context.js ***!
      \****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _mediaInfo = __webpack_require__(/*! ./models/media-info */ "../xgplayer-utils/src/models/media-info.js");\n\nvar _mediaInfo2 = _interopRequireDefault(_mediaInfo);\n\nvar _events = __webpack_require__(/*! events */ "../../node_modules/events/events.js");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst DIRECT_EMIT_FLAG = \'__TO__\';\n\nclass Context {\n  constructor(allowedEvents = []) {\n    this._emitter = new _events.EventEmitter();\n    this._instanceMap = {}; // 所有的解码流程实例\n    this._clsMap = {}; // 构造函数的map\n    this._inited = false;\n    this.mediaInfo = new _mediaInfo2.default();\n    this.allowedEvents = allowedEvents;\n    this._hooks = {}; // 注册在事件前/后的钩子，例如 before(\'DEMUX_COMPLETE\')\n  }\n\n  /**\n   * 从上下文中获取解码流程实例，如果没有实例，构造一个\n   * @param tag\n   * @param args\n   * @returns {*}\n   */\n  getInstance(tag) {\n    const instance = this._instanceMap[tag];\n    if (instance) {\n      return instance;\n    } else {\n      // throw new Error(`${tag}实例尚未初始化`)\n      return null;\n    }\n  }\n\n  /**\n   * 初始化具体实例\n   * @param tag\n   * @param args\n   */\n  initInstance(tag, ...args) {\n    if (this._clsMap[tag]) {\n      const newInstance = new this._clsMap[tag](...args);\n      this._instanceMap[tag] = newInstance;\n      if (newInstance.init) {\n        newInstance.init(); // TODO: lifecircle\n      }\n      return newInstance;\n    } else {\n      throw new Error(`${tag}未在context中注册`);\n    }\n  }\n\n  /**\n   * 避免大量的initInstance调用，初始化所有的组件\n   * @param config\n   */\n  init(config) {\n    if (this._inited) {\n      return;\n    }\n    for (let tag in this._clsMap) {\n      // if not inited, init an instance\n      if (this._clsMap.hasOwnProperty(tag) && !this._instanceMap[tag]) {\n        this.initInstance(tag, config);\n      }\n    }\n    this._inited = true;\n  }\n\n  /**\n   * 注册一个上下文流程，提供安全的事件发送机制\n   * @param tag\n   * @param cls\n   */\n  registry(tag, cls) {\n    const emitter = this._emitter;\n    const checkMessageName = this._isMessageNameValid.bind(this);\n    const self = this;\n    const enhanced = class extends cls {\n      constructor(...args) {\n        super(...args);\n        this.listeners = {};\n        this.onceListeners = {};\n        this.TAG = tag;\n        this._context = self;\n      }\n\n      on(messageName, callback) {\n        checkMessageName(messageName);\n\n        if (this.listeners[messageName]) {\n          this.listeners[messageName].push(callback);\n        } else {\n          this.listeners[messageName] = [callback];\n        }\n\n        emitter.on(`${messageName}${DIRECT_EMIT_FLAG}${tag}`, callback); // 建立定向通信监听\n        return emitter.on(messageName, callback);\n      }\n\n      /**\n       * 在某个事件触发前执行\n       * @param messageName\n       * @param callback\n       */\n      before(messageName, callback) {\n        checkMessageName(messageName);\n        if (self._hooks[messageName]) {\n          self._hooks[messageName].push(callback);\n        } else {\n          self._hooks[messageName] = [callback];\n        }\n      }\n\n      once(messageName, callback) {\n        checkMessageName(messageName);\n\n        if (this.onceListeners[messageName]) {\n          this.onceListeners[messageName].push(callback);\n        } else {\n          this.onceListeners[messageName] = [callback];\n        }\n\n        emitter.once(`${messageName}${DIRECT_EMIT_FLAG}${tag}`, callback);\n        return emitter.once(messageName, callback);\n      }\n\n      emit(messageName, ...args) {\n        checkMessageName(messageName);\n\n        const beforeList = self._hooks ? self._hooks[messageName] : null;\n\n        if (beforeList) {\n          for (let i = 0, len = beforeList.length; i < len; i++) {\n            const callback = beforeList[i];\n            callback();\n          }\n        }\n        return emitter.emit(messageName, ...args);\n      }\n\n      /**\n       * 定向发送给某个组件单例的消息\n       * @param messageName\n       * @param args\n       */\n      emitTo(tag, messageName, ...args) {\n        checkMessageName(messageName);\n\n        return emitter.emit(`${messageName}${DIRECT_EMIT_FLAG}${tag}`, ...args);\n      }\n\n      off(messageName, callback) {\n        checkMessageName(messageName);\n        return emitter.off(messageName, callback);\n      }\n\n      removeListeners() {\n        const hasOwn = Object.prototype.hasOwnProperty.bind(this.listeners);\n\n        for (let messageName in this.listeners) {\n          if (hasOwn(messageName)) {\n            const callbacks = this.listeners[messageName] || [];\n            for (let i = 0; i < callbacks.length; i++) {\n              const callback = callbacks[i];\n              emitter.off(messageName, callback);\n              emitter.off(`${messageName}${DIRECT_EMIT_FLAG}${tag}`, callback);\n            }\n          }\n        }\n\n        for (let messageName in this.onceListeners) {\n          if (hasOwn(messageName)) {\n            const callbacks = this.onceListeners[messageName] || [];\n            for (let i = 0; i < callbacks.length; i++) {\n              const callback = callbacks[i];\n              emitter.off(messageName, callback);\n              emitter.off(`${messageName}${DIRECT_EMIT_FLAG}${tag}`, callback);\n            }\n          }\n        }\n      }\n\n      /**\n       * 在组件销毁时，默认将它注册的事件全部卸载，确保不会造成内存泄漏\n       */\n      destroy() {\n        // step1 unlisten events\n        this.removeListeners();\n        this.listeners = {};\n\n        // step2 release from context\n        delete self._instanceMap[tag];\n        if (super.destroy) {\n          return super.destroy();\n        }\n      }\n    };\n    this._clsMap[tag] = enhanced;\n\n    /**\n     * get instance immediately\n     * e.g const instance = context.registry(tag, Cls)(config)\n     * */\n    return (...args) => {\n      return this.initInstance(tag, ...args);\n    };\n  }\n\n  /**\n   * 对存在的实例进行\n   */\n  destroyInstances() {\n    Object.keys(this._instanceMap).forEach(tag => {\n      if (this._instanceMap[tag].destroy) {\n        this._instanceMap[tag].destroy();\n      }\n    });\n  }\n\n  /**\n   * 编解码流程无需关注事件的解绑\n   */\n  destroy() {\n    this._emitter = null;\n    this.allowedEvents = [];\n    this._clsMap = null;\n    this._context = null;\n    this._hooks = null;\n    this.destroyInstances();\n  }\n\n  /**\n   * 对信道进行收拢\n   * @param messageName\n   * @private\n   */\n  _isMessageNameValid(messageName) {\n    if (!this.allowedEvents.indexOf(messageName) < 0) {\n      throw new Error(`unregistered message name: ${messageName}`);\n    }\n  }\n}\n\nexports.default = Context;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/context.js?')},"../xgplayer-utils/src/crypto/index.js":
/*!*********************************************!*\
      !*** ../xgplayer-utils/src/crypto/index.js ***!
      \*********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _events = __webpack_require__(/*! ../constants/events */ \"../xgplayer-utils/src/constants/events.js\");\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst CRYTO_EVENTS = _events2.default.CRYTO_EVENTS;\nclass Crypto {\n    constructor(config) {\n        this.inputBuffer = config.inputbuffer;\n        this.outputBuffer = config.outputbuffer;\n        this.key = config.key;\n        this.iv = config.iv;\n        this.method = config.method;\n\n        this.crypto = window.crypto || window.msCrypto;\n    }\n\n    init() {\n        this.on(CRYTO_EVENTS.START_DECRYPT, this.decript.bind(this));\n    }\n\n    decript() {\n        if (!this.aeskey) {\n            let sbkey = this.crypto.subtle.importKey('raw', this.key.buffer, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);\n            sbkey.then(key => {\n                this.aeskey = key;\n                this.decriptData();\n            });\n        } else {\n            this.decriptData();\n        }\n    }\n\n    decriptData() {\n        let inputbuffer = this._context.getInstance(this.inputBuffer);\n        let outputbuffer = this._context.getInstance(this.outputBuffer);\n        let data = inputbuffer.shift();\n        if (data) {\n            this.crypto.subtle.decrypt({ name: 'AES-CBC', iv: this.iv.buffer }, this.aeskey, data).then(res => {\n                outputbuffer.push(new Uint8Array(res));\n                this.emit(CRYTO_EVENTS.DECRYPTED);\n                this.decriptData(data);\n            });\n        }\n    }\n}\nexports.default = Crypto;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/crypto/index.js?")},"../xgplayer-utils/src/env/isle.js":
/*!*****************************************!*\
      !*** ../xgplayer-utils/src/env/isle.js ***!
      \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nconst le = function () {\n  const buf = new ArrayBuffer(2);\n  new DataView(buf).setInt16(0, 256, true); // little-endian write\n  return new Int16Array(buf)[0] === 256; // platform-spec read, if equal then LE\n}();\n\nexports.default = le;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/env/isle.js?')},"../xgplayer-utils/src/env/sniffer.js":
/*!********************************************!*\
      !*** ../xgplayer-utils/src/env/sniffer.js ***!
      \********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst le = function () {\n  const buf = new ArrayBuffer(2);\n  new DataView(buf).setInt16(0, 256, true); // little-endian write\n  return new Int16Array(buf)[0] === 256; // platform-spec read, if equal then LE\n}();\n\nconst sniffer = {\n  get device() {\n    let r = sniffer.os;\n    return r.isPc ? 'pc' : r.isTablet ? 'tablet' : 'mobile';\n  },\n  get browser() {\n    let ua = navigator.userAgent.toLowerCase();\n    let reg = {\n      ie: /rv:([\\d.]+)\\) like gecko/,\n      firfox: /firefox\\/([\\d.]+)/,\n      chrome: /chrome\\/([\\d.]+)/,\n      opera: /opera.([\\d.]+)/,\n      safari: /version\\/([\\d.]+).*safari/\n    };\n    return [].concat(Object.keys(reg).filter(key => reg[key].test(ua)))[0];\n  },\n  get os() {\n    let ua = navigator.userAgent;\n    let isWindowsPhone = /(?:Windows Phone)/.test(ua);\n    let isSymbian = /(?:SymbianOS)/.test(ua) || isWindowsPhone;\n    let isAndroid = /(?:Android)/.test(ua);\n    let isFireFox = /(?:Firefox)/.test(ua);\n    let isTablet = /(?:iPad|PlayBook)/.test(ua) || isAndroid && !/(?:Mobile)/.test(ua) || isFireFox && /(?:Tablet)/.test(ua);\n    let isPhone = /(?:iPhone)/.test(ua) && !isTablet;\n    let isPc = !isPhone && !isAndroid && !isSymbian;\n    return {\n      isTablet,\n      isPhone,\n      isAndroid,\n      isPc,\n      isSymbian,\n      isWindowsPhone,\n      isFireFox\n    };\n  },\n\n  get isLe() {\n    return le;\n  }\n};\n\nexports.default = sniffer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/env/sniffer.js?")},"../xgplayer-utils/src/env/utf8.js":
/*!*****************************************!*\
      !*** ../xgplayer-utils/src/env/utf8.js ***!
      \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass UTF8 {\n  static decode(uint8array) {\n    const out = [];\n    const input = uint8array;\n    let i = 0;\n    const length = uint8array.length;\n\n    while (i < length) {\n      if (input[i] < 0x80) {\n        out.push(String.fromCharCode(input[i]));\n        ++i;\n        continue;\n      } else if (input[i] < 0xC0) {\n        // fallthrough\n      } else if (input[i] < 0xE0) {\n        if (UTF8._checkContinuation(input, i, 1)) {\n          const ucs4 = (input[i] & 0x1F) << 6 | input[i + 1] & 0x3F;\n          if (ucs4 >= 0x80) {\n            out.push(String.fromCharCode(ucs4 & 0xFFFF));\n            i += 2;\n            continue;\n          }\n        }\n      } else if (input[i] < 0xF0) {\n        if (UTF8._checkContinuation(input, i, 2)) {\n          const ucs4 = (input[i] & 0xF) << 12 | (input[i + 1] & 0x3F) << 6 | input[i + 2] & 0x3F;\n          if (ucs4 >= 0x800 && (ucs4 & 0xF800) !== 0xD800) {\n            out.push(String.fromCharCode(ucs4 & 0xFFFF));\n            i += 3;\n            continue;\n          }\n        }\n      } else if (input[i] < 0xF8) {\n        if (UTF8._checkContinuation(input, i, 3)) {\n          let ucs4 = (input[i] & 0x7) << 18 | (input[i + 1] & 0x3F) << 12 | (input[i + 2] & 0x3F) << 6 | input[i + 3] & 0x3F;\n          if (ucs4 > 0x10000 && ucs4 < 0x110000) {\n            ucs4 -= 0x10000;\n            out.push(String.fromCharCode(ucs4 >>> 10 | 0xD800));\n            out.push(String.fromCharCode(ucs4 & 0x3FF | 0xDC00));\n            i += 4;\n            continue;\n          }\n        }\n      }\n      out.push(String.fromCharCode(0xFFFD));\n      ++i;\n    }\n\n    return out.join('');\n  }\n\n  static _checkContinuation(uint8array, start, checkLength) {\n    let array = uint8array;\n    if (start + checkLength < array.length) {\n      while (checkLength--) {\n        if ((array[++start] & 0xC0) !== 0x80) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n\nexports.default = UTF8;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/env/utf8.js?")},"../xgplayer-utils/src/mobile/audio-context.js":
/*!*****************************************************!*\
      !*** ../xgplayer-utils/src/mobile/audio-context.js ***!
      \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _events = __webpack_require__(/*! events */ "../../node_modules/events/events.js");\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass AudioCtx extends _events2.default {\n  constructor(config) {\n    super();\n    this.config = Object.assign({}, config);\n    let AudioContext = window.AudioContext || window.webkitAudioContext;\n    this.context = new AudioContext();\n    this.gainNode = this.context.createGain();\n    this.gainNode.connect(this.context.destination);\n    this.meta = undefined;\n    this.samples = [];\n    this.preloadTime = this.config.preloadTime || 3;\n    this.duration = 0;\n\n    this._currentBuffer = undefined;\n    this._nextBuffer = undefined;\n    this._lastpts = undefined;\n    this._preDecode = [];\n    this._currentTime = 0;\n    this._decoding = false;\n    // 记录外部传输的状态\n    this._played = false;\n  }\n\n  get currentTime() {\n    return this._currentTime;\n  }\n\n  decodeAudio(audioTrack) {\n    let { samples } = audioTrack;\n    let data = samples;\n    audioTrack.samples = [];\n    this.setAudioData(data);\n  }\n  setAudioData(data) {\n    for (let i = 0; i < data.length; i++) {\n      data[i].pts = data[i].pts === undefined ? data[i].dts : data[i].pts;\n      this._preDecode.push(data[i]);\n    }\n    if (this._preDecode.length > 0) {\n      if (this._lastpts === undefined) {\n        this._lastpts = this._preDecode[0].pts;\n      }\n      if ((this._preDecode[this._preDecode.length - 1].pts - this._lastpts) / 1000 > this.preloadTime) {\n        this.decodeAAC();\n      }\n    }\n  }\n\n  decodeAAC() {\n    if (this._decoding) {\n      return;\n    }\n    this._decoding = true;\n    let data = this._preDecode;\n    let samples = [];\n    let _this = this;\n    let sample = data.shift();\n    while (sample) {\n      let sampleData = AudioCtx.getAACData(this.meta, sample);\n      samples.push(sampleData);\n      this._lastpts = sample.pts;\n      sample = data.shift();\n    }\n    let buffer = AudioCtx.combileData(samples);\n    try {\n      this.context.decodeAudioData(buffer.buffer, function (buffer) {\n        let audioSource = _this.context.createBufferSource();\n        audioSource.buffer = buffer;\n        audioSource.onended = _this.onSourceEnded.bind(_this);\n        _this.samples.push({\n          time: _this.duration,\n          duration: buffer.duration,\n          data: audioSource\n        });\n\n        _this.duration += buffer.duration;\n\n        if (!_this._currentBuffer) {\n          _this._currentBuffer = _this.getTimeBuffer(_this.currentTime);\n\n          if (_this._played) {\n            _this.play();\n          }\n        }\n\n        if (!_this._nextBuffer && _this._currentBuffer) {\n          _this._nextBuffer = _this.getTimeBuffer(_this.currentTime + _this._currentBuffer.duration);\n        }\n        _this._decoding = false;\n\n        if ((_this._preDecode.length > 0 && _this._preDecode[_this._preDecode.length - 1].pts - _this._lastpts) / 1000 >= _this.preloadTime) {\n          _this.decodeAAC();\n        }\n      });\n    } catch (err) {\n      console.error(err);\n    }\n  }\n\n  onSourceEnded() {\n    if (!this._nextBuffer || !this._played) {\n      return;\n    }\n    let audioSource = this._nextBuffer.data;\n    audioSource.start();\n    audioSource.connect(this.gainNode);\n    this._currentBuffer = this._nextBuffer;\n    this._currentTime = this._currentBuffer.time;\n    this._nextBuffer = this.getTimeBuffer(this.currentTime);\n    if (this._currentBuffer) {\n      this._nextBuffer = this.getTimeBuffer(this.currentTime + this._currentBuffer.duration);\n    }\n    this.emit(\'AUDIO_SOURCE_END\');\n  }\n\n  play() {\n    this._played = true;\n    if (!this._currentBuffer) {\n      return;\n    }\n    let audioSource = this._currentBuffer.data;\n    audioSource.connect(this.gainNode);\n    audioSource.start();\n  }\n\n  getTimeBuffer(time) {\n    let ret;\n    for (let i = 0; i < this.samples.length; i++) {\n      let sample = this.samples[i];\n      if (sample.time <= time && sample.time + sample.duration > time) {\n        ret = sample;\n        break;\n      }\n    }\n    return ret;\n  }\n\n  setAudioMetaData(meta) {\n    this.meta = meta;\n  }\n\n  static getAACData(meta, sample) {\n    let buffer = new Uint8Array(sample.data.byteLength + 7);\n    let adts = AudioCtx.getAdts(meta, sample.data);\n    buffer.set(adts);\n    buffer.set(sample.data, 7);\n    return buffer;\n  }\n\n  static combileData(samples) {\n    // get length\n    let length = 0;\n    for (let i = 0, k = samples.length; i < k; i++) {\n      length += samples[i].byteLength;\n    }\n\n    let ret = new Uint8Array(length);\n    let offset = 0;\n    // combile data;\n    for (let i = 0, k = samples.length; i < k; i++) {\n      ret.set(samples[i], offset);\n      offset += samples[i].byteLength;\n    }\n    return ret;\n  }\n\n  static getAdts(meta, data) {\n    let adts = new Uint8Array(7);\n\n    // 设置同步位 0xfff 12bit\n    adts[0] = 0xff;\n    adts[1] = 0xf0;\n\n    // Object data (没什么人用MPEG-2了，HLS和FLV也全是MPEG-4，这里直接0)  1bit\n    // Level always 00 2bit\n    // CRC always 1 1bit\n    adts[1] = adts[1] | 0x01;\n\n    // profile 2bit\n    adts[2] = 0xc0 & meta.objectType - 1 << 6;\n\n    //sampleFrequencyIndex\n    adts[2] = adts[2] | 0x3c & meta.sampleRateIndex << 2;\n\n    //private bit 0 1bit\n    // chanel configuration 3bit\n    adts[2] = adts[2] | 0x01 & meta.channelCount >> 2;\n    adts[3] = 0xc0 & meta.channelCount << 6;\n\n    // original_copy: 0 1bit\n    // home: 0 1bit\n\n    // adts_variable_header()\n    // copyrighted_id_bit 0 1bit\n    // copyrighted_id_start 0 1bit\n\n    // aac_frame_length 13bit;\n    let aacframelength = data.byteLength + 7;\n\n    adts[3] = adts[3] | 0x03 & aacframelength >> 11;\n    adts[4] = 0xff & aacframelength >> 3;\n    adts[5] = 0xe0 & aacframelength << 5;\n\n    // adts_buffer_fullness 0x7ff 11bit\n    adts[5] = adts[5] | 0x1f;\n    adts[6] = 0xfc;\n\n    // number_of_raw_data_blocks_in_frame 0 2bit;\n    return adts;\n  }\n}\n\nexports.default = AudioCtx;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/audio-context.js?')},"../xgplayer-utils/src/mobile/mobile-video.js":
/*!****************************************************!*\
      !*** ../xgplayer-utils/src/mobile/mobile-video.js ***!
      \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nvar _videoContext = __webpack_require__(/*! ./video-context */ \"../xgplayer-utils/src/mobile/video-context.js\");\n\nvar _videoContext2 = _interopRequireDefault(_videoContext);\n\nvar _audioContext = __webpack_require__(/*! ./audio-context */ \"../xgplayer-utils/src/mobile/audio-context.js\");\n\nvar _audioContext2 = _interopRequireDefault(_audioContext);\n\nvar _ticker = __webpack_require__(/*! ./ticker */ \"../xgplayer-utils/src/mobile/ticker.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * 音画同步调和器\n */\nclass AVReconciler {\n  constructor(props) {\n    this.aCtx = props.aCtx;\n    this.vCtx = props.vCtx;\n    this.video = props.video;\n    this.timeoutId = null;\n    this.start = null;\n  }\n\n  doReconcile() {\n    const vCurTime = (this.video.currentTime || 0) * 1000;\n    const aCurTime = (this.aCtx.currentTime || 0) * 1000;\n\n    const gap = vCurTime - aCurTime;\n    if (this.timeoutId) {\n      return;\n    }\n    if (gap > 200) {\n      // audio delayed for more than 100ms\n      console.log(gap);\n      this.video.start += gap;\n      this.vCtx.pause();\n      this.timeoutId = setTimeout(() => {\n        this.vCtx.play();\n        this.timeoutId = null;\n      }, gap);\n    } else if (gap < -120) {\n      this.vCtx.currentTime = this.vCtx.currentTime + Math.abs(gap);\n    }\n  }\n\n  destroy() {\n    this.aCtx = null;\n    this.vCtx = null;\n  }\n}\n\n// eslint-disable-next-line no-undef\nclass MobileVideo extends HTMLElement {\n  constructor(config) {\n    super();\n    let _this = this;\n    this.vCtx = new _videoContext2.default();\n    this.aCtx = new _audioContext2.default(config);\n    this.ticker = new ((0, _ticker.getTicker)())();\n    this.historyTime = 0;\n    this.reconciler = new AVReconciler({\n      vCtx: this.vCtx,\n      aCtx: this.aCtx,\n      video: this\n    });\n    this.handleAudioSourceEnd = this.handleAudioSourceEnd.bind(this);\n    this.init();\n  }\n\n  init() {\n    this.vCtx.oncanplay = () => {\n      this.appendChild(this.vCtx.canvas);\n      // eslint-disable-next-line no-undef\n      this.dispatchEvent(new Event('canplay'));\n    };\n\n    this.ticker.start(() => {\n      //\n      if (!this.start) {\n        this.start = Date.now();\n      }\n      this._currentTime = Date.now() - this.start;\n      this.vCtx._onTimer(this._currentTime);\n    });\n\n    this.aCtx.on('AUDIO_SOURCE_END', this.handleAudioSourceEnd);\n  }\n\n  handleAudioSourceEnd() {\n    console.log(this.aCtx.currentTime);\n    this.reconciler.doReconcile();\n  }\n\n  _cleanBuffer() {\n    this.vCtx.cleanBuffer();\n  }\n\n  destroy() {\n    this.reconciler.destroy();\n  }\n\n  onDemuxComplete(videoTrack, audioTrack) {\n    this.aCtx.decodeAudio(audioTrack);\n    this.vCtx.decodeVideo(videoTrack);\n  }\n\n  setAudioMeta(meta) {\n    this.aCtx.setAudioMetaData(meta);\n  }\n\n  setVideoMeta(meta) {\n    this.vCtx.setVideoMetaData(meta);\n  }\n\n  get currentTime() {\n    return this._currentTime / 1000;\n  }\n\n  play() {\n    // if (!this.vCtx.)\n    this.vCtx.play();\n    this.aCtx.play();\n  }\n}\n// eslint-disable-next-line no-undef\ncustomElements.define('mobile-video', MobileVideo);\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/mobile-video.js?")},"../xgplayer-utils/src/mobile/sourcebuffer.js":
/*!****************************************************!*\
      !*** ../xgplayer-utils/src/mobile/sourcebuffer.js ***!
      \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass SourceBuffer {\n  constructor(config) {\n    this.config = Object.assign({}, config);\n    this.type = this.config.type;\n    this.buffer = [];\n    this.currentGop = undefined;\n    this._lastGet = undefined;\n  }\n\n  push(frame) {\n    if (this.type === 'video') {\n      if (frame.isKeyframe) {\n        let currentGop = {\n          samples: [],\n          start: frame.dts,\n          end: frame.dts,\n          nextGop: undefined\n        };\n        if (this.currentGop) {\n          this.currentGop.nextGop = currentGop;\n        }\n        this.currentGop = currentGop;\n        this.buffer.push(this.currentGop);\n      }\n\n      if (this.currentGop) {\n        this.currentGop.samples.push(frame);\n\n        if (frame.dts < this.currentGop.start) {\n          this.currentGop.start = frame.dts;\n        }\n\n        if (frame.dts > this.currentGop.end) {\n          this.currentGop.end = frame.dts;\n        }\n      }\n    }\n  }\n\n  get(time) {\n    if (this.type === 'video') {\n      if (this.buffer.length < 1) {\n        return;\n      }\n\n      if (time === undefined) {\n        let sample = this._getNext();\n        return sample;\n      }\n    }\n  }\n\n  _getNext() {\n    if (!this._lastGet) {\n      let gop = this.buffer[0];\n      if (gop.samples.length < 1) {\n        return;\n      }\n\n      this._lastGet = {\n        gop,\n        index: 0\n      };\n      return gop.samples[0];\n    } else {\n      let gop = this._lastGet.gop;\n      let sample = gop.samples[this._lastGet.index + 1];\n      if (sample) {\n        this._lastGet.index = this._lastGet.index + 1;\n        return sample;\n      } else {\n        gop = gop.nextGop;\n        if (!gop || gop.samples.length < 1) {\n          return;\n        }\n        sample = gop.samples[0];\n        this._lastGet = {\n          gop,\n          index: 0\n        };\n        return sample;\n      }\n    }\n  }\n\n  remove(start, end) {\n    if (this.buffer.length < 0) {\n      return;\n    }\n\n    let i = 0;\n    let gop = this.buffer[0];\n    while (gop) {\n      if (gop.end < end && gop.start >= start) {\n        delete this.buffer[i];\n        gop = this.buffer[i];\n      } else {\n        i += 1;\n        gop = this.buffer[i];\n      }\n    }\n  }\n}\n\nexports.default = SourceBuffer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/sourcebuffer.js?")},"../xgplayer-utils/src/mobile/ticker.js":
/*!**********************************************!*\
      !*** ../xgplayer-utils/src/mobile/ticker.js ***!
      \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n/**\n * @author fuyuhao@bytedance.com\n */\n\nclass Ticker {\n  constructor(options) {\n    this.options = Object.assign({}, options || {}, {\n      interval: 16\n    });\n\n    this.callbacks = [];\n  }\n\n  start(...callbacks) {\n    this.callbacks = callbacks;\n  }\n\n  onTick() {\n    for (let i = 0, len = this.callbacks.length; i < len; i++) {\n      const callback = this.callbacks[i];\n      callback();\n    }\n  }\n\n  setInterval(interval) {\n    this.options.interval = interval;\n    return this;\n  }\n}\n\n/**\n * ticker use requestAnimationFrame\n */\nclass RafTicker extends Ticker {\n  constructor(props) {\n    super(props);\n    this.prev = null;\n    this.timerId = null;\n    this._subTimerId = null;\n\n    this._tickFunc = RafTicker.getTickFunc();\n    this.tick = this.tick.bind(this);\n  }\n\n  start(...callbacks) {\n    super.start(...callbacks);\n    this.tick();\n  }\n\n  tick(timestamp) {\n    this.nextTick();\n    this.onTick();\n  }\n\n  nextTick() {\n    const { _tickFunc } = this;\n    this.timerId = _tickFunc(this.tick);\n  }\n\n  stop() {\n    if (this.timerId) {\n      const cancelFunc = RafTicker.getCancelFunc();\n\n      cancelFunc(this.timerId);\n    }\n  }\n\n  static getTickFunc() {\n    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;\n  }\n\n  static getCancelFunc() {\n    return window.cancelAnimationFrame || window.webkitCancelAnimationFrame;\n  }\n\n  static isSupported() {\n    return RafTicker.getTickFunc() !== undefined;\n  }\n}\n\n/**\n * use setTimeout for browsers without raf support\n */\nclass TimeoutTicker extends Ticker {\n  constructor(config) {\n    super(config);\n    this.timeoutId = null;\n  }\n\n  start(...callbacks) {\n    super.nextTick(...callbacks);\n    this.timeoutId = window.setInterval(() => {\n      this.onTick();\n    }, this.options.interval || 16);\n  }\n\n  stop() {\n    if (this.timeoutId) {\n      window.clearInterval(this.timeoutId);\n    }\n  }\n\n}\n\n/**\n * 返回Ticker构造函数\n * @returns {Ticker}\n */\nconst getTicker = exports.getTicker = () => {\n  if (RafTicker.isSupported()) {\n    return RafTicker;\n  } else {\n    return TimeoutTicker;\n  }\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/ticker.js?')},"../xgplayer-utils/src/mobile/video-context.js":
/*!*****************************************************!*\
      !*** ../xgplayer-utils/src/mobile/video-context.js ***!
      \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _webworkifyWebpack = __webpack_require__(/*! webworkify-webpack */ \"../xgplayer-utils/node_modules/webworkify-webpack/index.js\");\n\nvar _webworkifyWebpack2 = _interopRequireDefault(_webworkifyWebpack);\n\nvar _stream = __webpack_require__(/*! ../write/stream */ \"../xgplayer-utils/src/write/stream.js\");\n\nvar _stream2 = _interopRequireDefault(_stream);\n\nvar _nalunit = __webpack_require__(/*! ../../../xgplayer-codec/src/h264/nalunit */ \"../xgplayer-codec/src/h264/nalunit/index.js\");\n\nvar _nalunit2 = _interopRequireDefault(_nalunit);\n\nvar _yuvCanvas = __webpack_require__(/*! ./yuv-canvas */ \"../xgplayer-utils/src/mobile/yuv-canvas.js\");\n\nvar _yuvCanvas2 = _interopRequireDefault(_yuvCanvas);\n\nvar _sourcebuffer = __webpack_require__(/*! ./sourcebuffer */ \"../xgplayer-utils/src/mobile/sourcebuffer.js\");\n\nvar _sourcebuffer2 = _interopRequireDefault(_sourcebuffer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass VideoCanvas {\n  constructor(config) {\n    this.config = Object.assign({}, config);\n    this.canvas = this.config.canvas ? this.config.canvas : document.createElement('canvas');\n    this.source = new _sourcebuffer2.default({ type: 'video' });\n    this.preloadTime = this.config.preloadTime || 3;\n    this.oncanplay = undefined;\n    this.onFirstFrame = undefined;\n    this.meta = undefined;\n    this.readyStatus = 0;\n    this.paused = true;\n    this.count = 0;\n    this.currentTime = 0;\n    this.lastPlayed = 0;\n\n    this._decoderInited = false;\n    this._avccpushed = false;\n    this._decodedFrames = {};\n    this._lastSampleDts = undefined;\n    this._baseDts = undefined;\n    this._lastRenderTime = null;\n    this.playFinish = null;\n  }\n\n  pause() {\n    this.paused = true;\n  }\n\n  initWasmWorker() {\n    let _this = this;\n    this.wasmworker = (0, _webworkifyWebpack2.default)(/*require.resolve*/(/*! ./worker.js */ \"../xgplayer-utils/src/mobile/worker.js\"));\n    this.wasmworker.postMessage({\n      msg: 'init',\n      meta: this.meta\n    });\n    this.wasmworker.addEventListener('message', msg => {\n      switch (msg.data.msg) {\n        case 'DECODER_READY':\n          _this._decoderInited = true;\n          break;\n        case 'DECODED':\n          this._onDecoded(msg.data);\n          break;\n      }\n    });\n  }\n\n  setVideoMetaData(meta) {\n    this.meta = meta;\n    if (!this._decoderInited) {\n      this.initWasmWorker();\n      return;\n    }\n    this._avccpushed = true;\n    let data = new Uint8Array(meta.sps.byteLength + 4);\n    data.set([0, 0, 0, 1]);\n    data.set(meta.sps, 4);\n    this.wasmworker.postMessage({\n      msg: 'decode',\n      data: data\n    });\n\n    data = new Uint8Array(meta.pps.byteLength + 4);\n    data.set([0, 0, 0, 1]);\n    data.set(meta.pps, 4);\n    this.wasmworker.postMessage({\n      msg: 'decode',\n      data: data\n    });\n\n    if (!this.yuvCanvas) {\n      let config = Object.assign({ meta, canvas: this.canvas }, this.config);\n      this.yuvCanvas = new _yuvCanvas2.default(config);\n    }\n    this.readyStatus = 1;\n  }\n\n  decodeVideo(videoTrack) {\n    if (!this._decoderInited) {\n      return;\n    }\n\n    if (!this._avccpushed) {\n      this.setVideoMetaData(this.meta);\n    }\n    let { samples } = videoTrack;\n    let sample = samples.shift();\n\n    while (sample) {\n      if (!this._baseDts) {\n        this._baseDts = sample.dts;\n      }\n      this.source.push(sample);\n      sample = samples.shift();\n    }\n\n    this._preload();\n  }\n\n  _preload() {\n    if (!this._lastSampleDts || this._lastSampleDts - this._baseDts < this.currentTime + this.preloadTime * 1000) {\n      let sample = this.source.get();\n      if (sample) {\n        this._lastSampleDts = sample.dts;\n        this._analyseNal(sample);\n      }\n\n      while (sample && this._lastSampleDts - this._baseDts < this.currentTime + this.preloadTime * 1000) {\n        sample = this.source.get();\n        if (sample) {\n          this._analyseNal(sample);\n          this._lastSampleDts = sample.dts;\n        }\n      }\n    }\n  }\n\n  _analyseNal(sample) {\n    let nals = _nalunit2.default.getAvccNals(new _stream2.default(sample.data.buffer));\n\n    let length = 0;\n    for (let i = 0; i < nals.length; i++) {\n      let nal = nals[i];\n      length += nal.body.byteLength + 4;\n    }\n    let offset = 0;\n    let data = new Uint8Array(length);\n    for (let i = 0; i < nals.length; i++) {\n      let nal = nals[i];\n      data.set([0, 0, 0, 1], offset);\n      offset += 4;\n      data.set(new Uint8Array(nal.body), offset);\n      offset += nal.body.byteLength;\n    }\n    this.wasmworker.postMessage({\n      msg: 'decode',\n      data: data,\n      info: {\n        dts: sample.dts,\n        pts: sample.pts ? sample.pts : sample.dts + sample.cts,\n        key: sample.isKeyframe\n      }\n    });\n  }\n\n  _onDecoded(data) {\n    let { dts } = data.info;\n    this._decodedFrames[dts] = data;\n  }\n\n  play() {\n    this.paused = false;\n    return new Promise(resolve => {\n      this.playFinish = resolve;\n    });\n  }\n\n  _onTimer(currentTime) {\n    if (this.paused) {\n      return;\n    }\n    if (this.meta) {\n      if (this.meta.frameRate && this.meta.frameRate.fixed && this.meta.frameRate.fps) {}\n      let frameTimes = Object.keys(this._decodedFrames);\n      if (frameTimes.length > 0) {\n        this.currentTime = currentTime;\n        let frameTime = -1;\n        let currentIdx = 0;\n        for (let i = 0; i < frameTimes.length && Number.parseInt(frameTimes[i]) - this._baseDts <= this.currentTime; i++) {\n          frameTime = Number.parseInt(frameTimes[i - 1]);\n          currentIdx = i;\n        }\n\n        let frame = this._decodedFrames[frameTime];\n        if (frame) {\n\n          if (this.oncanplay && this.readyStatus < 4) {\n            this.oncanplay();\n            this.readyStatus = 4;\n          }\n          this.yuvCanvas.render(frame.buffer, frame.width, frame.height, frame.yLinesize, frame.uvLinesize);\n\n          if (this.playFinish) {\n            this.playFinish();\n          }\n          for (let i = 0; i < currentIdx; i++) {\n            delete this._decodedFrames[i];\n          }\n        }\n      }\n    }\n    this._lastRenderTime = Date.now();\n  }\n\n  cleanBuffer() {\n    if (this.currentTime > 1) {\n      this.source.remove(0, this.currentTime - 1);\n    }\n  }\n}\nexports.default = VideoCanvas;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/video-context.js?")},"../xgplayer-utils/src/mobile/worker.js":
/*!**********************************************!*\
      !*** ../xgplayer-utils/src/mobile/worker.js ***!
      \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nconst MAX_STREAM_BUFFER_LENGTH = 1024 * 1024;\nvar Decoder = function (self) {\n  this.inited = false;\n  this.self = self;\n  this.meta = this.self.meta;\n  this.infolist = {};\n  self.par_broadwayOnBroadwayInited = this.broadwayOnBroadwayInited.bind(this);\n  self.par_broadwayOnPictureDecoded = this.broadwayOnPictureDecoded.bind(this);\n};\n\nDecoder.prototype.toU8Array = function (ptr, length) {\n  return this.self.HEAPU8.subarray(ptr, ptr + length);\n};\n\nDecoder.prototype.init = function () {\n  Module._broadwayInit();\n  this.streamBuffer = this.toU8Array(Module._broadwayCreateStream(MAX_STREAM_BUFFER_LENGTH), MAX_STREAM_BUFFER_LENGTH);\n};\n\nDecoder.prototype.broadwayOnPictureDecoded = function (offset, width, height, yLinesize, uvLinesize, infoid) {\n  let info = Object.assign({}, this.infolist[infoid]);\n  let yRowcount = height;\n  let uvRowcount = height / 2;\n  if (this.meta.chromaFormat === 444 || this.meta.chromaFormat === 422) {\n    uvRowcount = height;\n  }\n  let data = this.toU8Array(offset, yLinesize * yRowcount + 2 * (uvLinesize * uvRowcount));\n  this.infolist[infoid] = null;\n  let datetemp = new Uint8Array(data.length);\n  datetemp.set(data);\n  let buffer = datetemp.buffer;\n  this.self.postMessage({\n    msg: 'DECODED',\n    width,\n    height,\n    yLinesize,\n    uvLinesize,\n    info,\n    buffer\n  }, [buffer]);\n};\n\nDecoder.prototype.broadwayOnBroadwayInited = function () {\n  this.inited = true;\n  this.self.postMessage({ msg: 'DECODER_READY' });\n};\n\nDecoder.prototype.decode = function (data, info) {\n  let time = parseInt(new Date().getTime());\n  let infoid = time - Math.floor(time / 10e8) * 10e8;\n  this.infolist[infoid] = info;\n  this.streamBuffer.set(data);\n  Module._broadwayPlayStream(data.length, infoid);\n};\n\nvar decoder;\n\nfunction onPostRun() {\n  decoder = new Decoder(this);\n  decoder.init();\n}\n\nfunction init(meta) {\n  self.importScripts('https://sf1-vcloudcdn.pstatp.com/obj/ttfe/media/decoder/h264/decoder.js');\n  addOnPostRun(onPostRun.bind(self));\n}\n\nmodule.exports = function (self) {\n  self.addEventListener('message', function (e) {\n    var data = e.data;\n    if (!data.msg) {\n      self.postMessage({\n        msg: 'ERROR:invalid message'\n      });\n    } else {\n      switch (data.msg) {\n        case 'init':\n          console.log(data);\n          self.meta = data.meta;\n          init();\n          break;\n        case 'decode':\n          decoder.decode(data.data, data.info);\n          break;\n        default:\n          break;\n      }\n    }\n  }, false);\n};\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/worker.js?")},"../xgplayer-utils/src/mobile/yuv-canvas.js":
/*!**************************************************!*\
      !*** ../xgplayer-utils/src/mobile/yuv-canvas.js ***!
      \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass YUVCanvas {\n  constructor(configs) {\n    this.configs = Object.assign({}, configs);\n    this.canvas = this.configs.canvas;\n    this.meta = Object.assign({}, this.configs.meta);\n    this.chroma = this.meta.chromaFormat;\n    this.height = this.meta.presentHeight;\n    this.width = this.meta.presentWidth;\n    this.canvas.width = 1280;\n    this.canvas.height = 720;\n    this.canvas.style.width = '100%';\n    this.canvas.style.height = '100%';\n    this._initContextGL();\n    if (this.contextGL) {\n      this._initProgram();\n      this._initBuffers();\n      this._initTextures();\n    };\n  }\n\n  _initContextGL() {\n    var canvas = this.canvas;\n    var gl = null;\n\n    var validContextNames = ['webgl', 'experimental-webgl', 'moz-webgl', 'webkit-3d'];\n    var nameIndex = 0;\n\n    while (!gl && nameIndex < validContextNames.length) {\n      var contextName = validContextNames[nameIndex];\n\n      try {\n        if (this.contextOptions) {\n          gl = canvas.getContext(contextName, this.contextOptions);\n        } else {\n          gl = canvas.getContext(contextName);\n        };\n      } catch (e) {\n        gl = null;\n      }\n\n      if (!gl || typeof gl.getParameter !== 'function') {\n        gl = null;\n      }\n\n      ++nameIndex;\n    };\n\n    this.contextGL = gl;\n  }\n\n  _initProgram() {\n    var gl = this.contextGL;\n\n    // vertex shader is the same for all types\n    var vertexShaderScript;\n    var fragmentShaderScript;\n    vertexShaderScript = ['attribute vec4 vertexPos;', 'attribute vec4 texturePos;', 'attribute vec4 uTexturePos;', 'attribute vec4 vTexturePos;', 'varying vec2 textureCoord;', 'varying vec2 uTextureCoord;', 'varying vec2 vTextureCoord;', 'void main()', '{', '  gl_Position = vertexPos;', '  textureCoord = texturePos.xy;', '  uTextureCoord = uTexturePos.xy;', '  vTextureCoord = vTexturePos.xy;', '}'].join('\\n');\n\n    fragmentShaderScript = ['precision highp float;', 'varying highp vec2 textureCoord;', 'varying highp vec2 uTextureCoord;', 'varying highp vec2 vTextureCoord;', 'uniform sampler2D ySampler;', 'uniform sampler2D uSampler;', 'uniform sampler2D vSampler;', 'uniform mat4 YUV2RGB;', 'void main(void) {', '  highp float y = texture2D(ySampler,  textureCoord).r;', '  highp float u = texture2D(uSampler,  uTextureCoord).r;', '  highp float v = texture2D(vSampler,  vTextureCoord).r;', '  gl_FragColor = vec4(y, u, v, 1) * YUV2RGB;', '}'].join('\\n');\n\n    var YUV2RGB = [1.16438, 0.00000, 1.59603, -0.87079, 1.16438, -0.39176, -0.81297, 0.52959, 1.16438, 2.01723, 0.00000, -1.08139, 0, 0, 0, 1];\n    var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(vertexShader, vertexShaderScript);\n    gl.compileShader(vertexShader);\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      console.log('Vertex shader failed to compile: ' + gl.getShaderInfoLog(vertexShader));\n    }\n\n    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(fragmentShader, fragmentShaderScript);\n    gl.compileShader(fragmentShader);\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      console.log('Fragment shader failed to compile: ' + gl.getShaderInfoLog(fragmentShader));\n    }\n\n    var program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      console.log('Program failed to compile: ' + gl.getProgramInfoLog(program));\n    }\n\n    gl.useProgram(program);\n\n    var YUV2RGBRef = gl.getUniformLocation(program, 'YUV2RGB');\n    gl.uniformMatrix4fv(YUV2RGBRef, false, YUV2RGB);\n\n    this.shaderProgram = program;\n  }\n\n  _initBuffers() {\n    var gl = this.contextGL;\n    var program = this.shaderProgram;\n\n    var vertexPosBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]), gl.STATIC_DRAW);\n\n    var vertexPosRef = gl.getAttribLocation(program, 'vertexPos');\n    gl.enableVertexAttribArray(vertexPosRef);\n    gl.vertexAttribPointer(vertexPosRef, 2, gl.FLOAT, false, 0, 0);\n\n    var texturePosBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, texturePosBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]), gl.STATIC_DRAW);\n\n    var texturePosRef = gl.getAttribLocation(program, 'texturePos');\n    gl.enableVertexAttribArray(texturePosRef);\n    gl.vertexAttribPointer(texturePosRef, 2, gl.FLOAT, false, 0, 0);\n\n    this.texturePosBuffer = texturePosBuffer;\n\n    var uTexturePosBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, uTexturePosBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]), gl.STATIC_DRAW);\n\n    var uTexturePosRef = gl.getAttribLocation(program, 'uTexturePos');\n    gl.enableVertexAttribArray(uTexturePosRef);\n    gl.vertexAttribPointer(uTexturePosRef, 2, gl.FLOAT, false, 0, 0);\n\n    this.uTexturePosBuffer = uTexturePosBuffer;\n\n    var vTexturePosBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, vTexturePosBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]), gl.STATIC_DRAW);\n\n    var vTexturePosRef = gl.getAttribLocation(program, 'vTexturePos');\n    gl.enableVertexAttribArray(vTexturePosRef);\n    gl.vertexAttribPointer(vTexturePosRef, 2, gl.FLOAT, false, 0, 0);\n\n    this.vTexturePosBuffer = vTexturePosBuffer;\n  }\n\n  _initTextures() {\n    var gl = this.contextGL;\n    var program = this.shaderProgram;\n    var yTextureRef = this._initTexture();\n    var ySamplerRef = gl.getUniformLocation(program, 'ySampler');\n    gl.uniform1i(ySamplerRef, 0);\n    this.yTextureRef = yTextureRef;\n\n    var uTextureRef = this._initTexture();\n    var uSamplerRef = gl.getUniformLocation(program, 'uSampler');\n    gl.uniform1i(uSamplerRef, 1);\n    this.uTextureRef = uTextureRef;\n\n    var vTextureRef = this._initTexture();\n    var vSamplerRef = gl.getUniformLocation(program, 'vSampler');\n    gl.uniform1i(vSamplerRef, 2);\n    this.vTextureRef = vTextureRef;\n  }\n\n  _initTexture() {\n    var gl = this.contextGL;\n\n    var textureRef = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, textureRef);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    return textureRef;\n  }\n\n  _drawPictureGL(data, width, height, yLinesize, uvLinesize) {\n    var ylen = yLinesize * height;\n    var uvlen = uvLinesize * height / 2;\n    if (this.chroma === 444 || this.chroma === 422) {\n      uvlen *= 2;\n    }\n    data = new Uint8Array(data);\n    let renderData = {\n      yData: data.subarray(0, ylen),\n      uData: data.subarray(ylen, ylen + uvlen),\n      vData: data.subarray(ylen + uvlen, ylen + uvlen + uvlen)\n    };\n    this._drawPictureGL420(renderData, width, height, yLinesize, uvLinesize);\n  }\n\n  _drawPictureGL420(data, width, height, yLinesize, uvLinesize) {\n    var gl = this.contextGL;\n    var texturePosBuffer = this.texturePosBuffer;\n    var uTexturePosBuffer = this.uTexturePosBuffer;\n    var vTexturePosBuffer = this.vTexturePosBuffer;\n\n    var yTextureRef = this.yTextureRef;\n    var uTextureRef = this.uTextureRef;\n    var vTextureRef = this.vTextureRef;\n\n    var yData = data.yData;\n    var uData = data.uData;\n    var vData = data.vData;\n\n    var yDataPerRow = yLinesize;\n    var yRowCnt = height;\n\n    var uDataPerRow = width / 2;\n    var uRowCnt = height / 2;\n\n    if (this.chroma === 422 || this.chroma === 444) {\n      uRowCnt = height;\n    }\n\n    var vDataPerRow = uvLinesize;\n    var vRowCnt = uRowCnt;\n\n    let ratiow = this.canvas.width / this.width;\n    let ratioh = this.canvas.height / this.height;\n    let left = 0;\n    let top = 0;\n    let w = this.canvas.width;\n    let h = this.canvas.height;\n    if (ratiow < ratioh) {\n      h = this.height * this.canvas.width / this.width;\n      top = parseInt((this.canvas.height - this.height * this.canvas.width / this.width) / 2);\n    } else {\n      w = this.width * this.canvas.height / this.height;\n      left = parseInt((this.canvas.width - this.width * this.canvas.height / this.height) / 2);\n    }\n    gl.viewport(left, top, w, h);\n\n    var texturePosValues = new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]);\n    gl.bindBuffer(gl.ARRAY_BUFFER, texturePosBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, texturePosValues, gl.DYNAMIC_DRAW);\n\n    var uTexturePosValues = new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]);\n    gl.bindBuffer(gl.ARRAY_BUFFER, uTexturePosBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, uTexturePosValues, gl.DYNAMIC_DRAW);\n\n    var vTexturePosValues = new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]);\n    gl.bindBuffer(gl.ARRAY_BUFFER, vTexturePosBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vTexturePosValues, gl.DYNAMIC_DRAW);\n\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, yTextureRef);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, yDataPerRow, yRowCnt, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, yData);\n\n    gl.activeTexture(gl.TEXTURE1);\n    gl.bindTexture(gl.TEXTURE_2D, uTextureRef);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, uDataPerRow, uRowCnt, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, uData);\n\n    gl.activeTexture(gl.TEXTURE2);\n    gl.bindTexture(gl.TEXTURE_2D, vTextureRef);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, vDataPerRow, vRowCnt, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, vData);\n\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n  }\n\n  _drawPictureRGB(data) {}\n\n  render(data, width, height, yLinesize, uvLinesize) {\n    var gl = this.contextGL;\n    if (gl) {\n      this._drawPictureGL(data, width, height, yLinesize, uvLinesize);\n    } else {\n      this._drawPictureRGB(data);\n    }\n  }\n}\n\nexports.default = YUVCanvas;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mobile/yuv-canvas.js?")},"../xgplayer-utils/src/models/media-info.js":
/*!**************************************************!*\
      !*** ../xgplayer-utils/src/models/media-info.js ***!
      \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nconst isObjectFilled = obj => {\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      if (obj[key] === null) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\nclass MediaInfo {\n  constructor() {\n    this.mimeType = null;\n    this.duration = null;\n\n    this.hasVideo = null;\n    this.video = {\n      codec: null,\n      width: null,\n      height: null,\n      profile: null,\n      level: null,\n      frameRate: {\n        fixed: true,\n        fps: 25,\n        fps_num: 25000,\n        fps_den: 1000\n      },\n      chromaFormat: null,\n      parRatio: {\n        width: 1,\n        height: 1\n      }\n    };\n\n    this.hasAudio = null;\n\n    this.audio = {\n      codec: null,\n      sampleRate: null,\n      sampleRateIndex: null,\n      channelCount: null\n    };\n  }\n\n  isComplete() {\n    return MediaInfo.isBaseInfoReady(this) && MediaInfo.isVideoReady(this) && MediaInfo.isAudioReady(this);\n  }\n\n  static isBaseInfoReady(mediaInfo) {\n    return isObjectFilled(mediaInfo);\n  }\n\n  static isVideoReady(mediaInfo) {\n    if (!mediaInfo.hasVideo) {\n      return true;\n    }\n\n    return isObjectFilled(mediaInfo.video);\n  }\n\n  static isAudioReady(mediaInfo) {\n    if (!mediaInfo.hasAudio) {\n      return true;\n    }\n\n    return isObjectFilled(mediaInfo.video);\n  }\n}\nexports.default = MediaInfo;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/media-info.js?')},"../xgplayer-utils/src/models/media-sample.js":
/*!****************************************************!*\
      !*** ../xgplayer-utils/src/models/media-sample.js ***!
      \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass MediaSample {\n  constructor(info) {\n    let _default = MediaSample.getDefaultInf();\n\n    if (!info || Object.prototype.toString.call(info) !== '[object Object]') {\n      return _default;\n    }\n    let sample = Object.assign({}, _default, info);\n\n    Object.entries(sample).forEach(([k, v]) => {\n      this[k] = v;\n    });\n  }\n\n  static getDefaultInf() {\n    return {\n      dts: null,\n      pts: null,\n      duration: null,\n      position: null,\n      isRAP: false, // is Random access point\n      originDts: null\n    };\n  }\n}\nexports.default = MediaSample;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/media-sample.js?")},"../xgplayer-utils/src/models/media-segment-list.js":
/*!**********************************************************!*\
      !*** ../xgplayer-utils/src/models/media-segment-list.js ***!
      \**********************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nclass MediaSegmentList {\n\n    constructor(type) {\n        this._type = type;\n        this._list = [];\n        this._lastAppendLocation = -1; // cached last insert location\n    }\n\n    get type() {\n        return this._type;\n    }\n\n    get length() {\n        return this._list.length;\n    }\n\n    isEmpty() {\n        return this._list.length === 0;\n    }\n\n    clear() {\n        this._list = [];\n        this._lastAppendLocation = -1;\n    }\n\n    _searchNearestSegmentBefore(beginDts) {\n        let list = this._list;\n        if (list.length === 0) {\n            return -2;\n        }\n        let last = list.length - 1;\n        let mid = 0;\n        let lbound = 0;\n        let ubound = last;\n\n        let idx = 0;\n\n        if (beginDts < list[0].originDts) {\n            idx = -1;\n            return idx;\n        }\n\n        while (lbound <= ubound) {\n            mid = lbound + Math.floor((ubound - lbound) / 2);\n            if (mid === last || beginDts > list[mid].lastSample.originDts && beginDts < list[mid + 1].originDts) {\n                idx = mid;\n                break;\n            } else if (list[mid].originDts < beginDts) {\n                lbound = mid + 1;\n            } else {\n                ubound = mid - 1;\n            }\n        }\n        return idx;\n    }\n\n    _searchNearestSegmentAfter(beginDts) {\n        return this._searchNearestSegmentBefore(beginDts) + 1;\n    }\n\n    append(segment) {\n        let list = this._list;\n        let lastAppendIdx = this._lastAppendLocation;\n        let insertIdx = 0;\n\n        if (lastAppendIdx !== -1 && lastAppendIdx < list.length && segment.originStartDts >= list[lastAppendIdx].lastSample.originDts && (lastAppendIdx === list.length - 1 || lastAppendIdx < list.length - 1 && segment.originStartDts < list[lastAppendIdx + 1].originStartDts)) {\n            insertIdx = lastAppendIdx + 1; // use cached location idx\n        } else {\n            if (list.length > 0) {\n                insertIdx = this._searchNearestSegmentBefore(segment.originStartDts) + 1;\n            }\n        }\n\n        this._lastAppendLocation = insertIdx;\n        this._list.splice(insertIdx, 0, segment);\n    }\n\n    getLastSegmentBefore(beginDts) {\n        let idx = this._searchNearestSegmentBefore(beginDts);\n        if (idx >= 0) {\n            return this._list[idx];\n        } else {\n            // -1\n            return null;\n        }\n    }\n\n    getLastSampleBefore(beginDts) {\n        let segment = this.getLastSegmentBefore(beginDts);\n        if (segment !== null) {\n            return segment.lastSample;\n        } else {\n            return null;\n        }\n    }\n\n    getLastRAPBefore(beginDts) {\n        let segmentIdx = this._searchNearestSegmentBefore(beginDts);\n        let randomAccessPoints = this._list[segmentIdx].randomAccessPoints;\n        while (randomAccessPoints.length === 0 && segmentIdx > 0) {\n            segmentIdx--;\n            randomAccessPoints = this._list[segmentIdx].randomAccessPoints;\n        }\n        if (randomAccessPoints.length > 0) {\n            return randomAccessPoints[randomAccessPoints.length - 1];\n        } else {\n            return null;\n        }\n    }\n\n}\nexports.default = MediaSegmentList;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/media-segment-list.js?')},"../xgplayer-utils/src/models/media-segment.js":
/*!*****************************************************!*\
      !*** ../xgplayer-utils/src/models/media-segment.js ***!
      \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nclass MediaSegment {\n    constructor() {\n        this.startDts = -1;\n        this.endDts = -1;\n        this.startPts = -1;\n        this.endPts = -1;\n        this.originStartDts = -1;\n        this.originEndDts = -1;\n        this.randomAccessPoints = [];\n        this.firstSample = null;\n        this.lastSample = null;\n    }\n\n    addRAP(sample) {\n        sample.isRAP = true;\n        this.randomAccessPoints.push(sample);\n    }\n}\nexports.default = MediaSegment;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/media-segment.js?')},"../xgplayer-utils/src/models/track-meta.js":
/*!**************************************************!*\
      !*** ../xgplayer-utils/src/models/track-meta.js ***!
      \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass AudioTrackMeta {\n  constructor(meta) {\n    const _default = {\n      sampleRate: 48000,\n      channelCount: 2,\n      codec: 'mp4a.40.2',\n      config: [41, 401, 136, 0],\n      duration: 0,\n      id: 2,\n      refSampleDuration: 21,\n      sampleRateIndex: 3,\n      timescale: 1000,\n      type: 'audio'\n    };\n    if (meta) {\n      return Object.assign({}, _default, meta);\n    }\n    return _default;\n  }\n\n  destroy() {\n    this.init = null;\n  }\n}\n\nexports.AudioTrackMeta = AudioTrackMeta;\nclass VideoTrackMeta {\n  constructor(meta) {\n    const _default = {\n      avcc: null,\n      sps: new Uint8Array(0),\n      pps: new Uint8Array(0),\n      chromaFormat: 420,\n      codec: 'avc1.640020',\n      codecHeight: 720,\n      codecWidth: 1280,\n      duration: 0,\n      frameRate: {\n        fixed: true,\n        fps: 25,\n        fps_num: 25000,\n        fps_den: 1000\n      },\n      id: 1,\n      level: '3.2',\n      presentHeight: 720,\n      presentWidth: 1280,\n      profile: 'High',\n      refSampleDuration: 40,\n      parRatio: {\n        height: 1,\n        width: 1\n      },\n      timescale: 1000,\n      type: 'video'\n    };\n\n    if (meta) {\n      return Object.assign({}, _default, meta);\n    }\n    return _default;\n  }\n\n  destroy() {\n    this.init = null;\n    this.sps = null;\n    this.pps = null;\n  }\n}\nexports.VideoTrackMeta = VideoTrackMeta;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/track-meta.js?")},"../xgplayer-utils/src/models/track-sample.js":
/*!****************************************************!*\
      !*** ../xgplayer-utils/src/models/track-sample.js ***!
      \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nclass AudioTrackSample {\n  constructor(info) {\n    let _default = AudioTrackSample.getDefault();\n    if (!info) {\n      return _default;\n    }\n    let sample = Object.assign({}, _default, info);\n\n    return sample;\n  }\n\n  static getDefault() {\n    return {\n      dts: null,\n      pts: null,\n      data: new Uint8Array()\n    };\n  }\n}\n\nexports.AudioTrackSample = AudioTrackSample;\nclass VideoTrackSample {\n  constructor(info) {\n    let _default = VideoTrackSample.getDefault();\n\n    if (!info) {\n      return _default;\n    }\n    let sample = Object.assign({}, _default, info);\n\n    return sample;\n  }\n\n  static getDefault() {\n    return {\n      dts: null,\n      pts: null,\n      isKeyframe: false, // is Random access point\n      originDts: null,\n      data: new Uint8Array()\n    };\n  }\n}\nexports.VideoTrackSample = VideoTrackSample;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/models/track-sample.js?')},"../xgplayer-utils/src/mse/index.js":
/*!******************************************!*\
      !*** ../xgplayer-utils/src/mse/index.js ***!
      \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass MSE {\n  constructor(configs) {\n    this.configs = Object.assign({}, configs);\n    this.container = this.configs.container;\n    this.mediaSource = null;\n    this.sourceBuffers = {};\n    this.preloadTime = this.configs.preloadTime || 1;\n    this.onSourceOpen = this.onSourceOpen.bind(this);\n    this.onTimeUpdate = this.onTimeUpdate.bind(this);\n    this.onUpdateEnd = this.onUpdateEnd.bind(this);\n    this.onWaiting = this.onWaiting.bind(this);\n  }\n\n  init() {\n    // eslint-disable-next-line no-undef\n    this.mediaSource = new self.MediaSource();\n    this.mediaSource.addEventListener('sourceopen', this.onSourceOpen);\n    this.container.src = URL.createObjectURL(this.mediaSource);\n    this.url = this.container.src;\n    this.container.addEventListener('timeupdate', this.onTimeUpdate);\n    this.container.addEventListener('waiting', this.onWaiting);\n  }\n\n  onTimeUpdate() {\n    this.emit('TIME_UPDATE', this.container);\n  }\n\n  onWaiting() {\n    this.emit('WAITING', this.container);\n  }\n\n  onSourceOpen() {\n    this.addSourceBuffers();\n  }\n\n  onUpdateEnd() {\n    this.emit('SOURCE_UPDATE_END');\n    this.doAppend();\n  }\n  addSourceBuffers() {\n    if (this.mediaSource.readyState !== 'open') {\n      return;\n    }\n    let sources = this._context.getInstance('PRE_SOURCE_BUFFER');\n    let tracks = this._context.getInstance('TRACKS');\n    let track;\n\n    sources = sources.sources;\n    let add = false;\n    for (let i = 0, k = Object.keys(sources).length; i < k; i++) {\n      let type = Object.keys(sources)[i];\n      if (type === 'audio') {\n        track = tracks.audioTrack;\n      } else if (type === 'video') {\n        track = tracks.videoTrack;\n        // return;\n      }\n      if (track) {\n        let dur = type === 'audio' ? 21 : 40;\n        if (track.meta && track.meta.refSampleDuration) dur = track.meta.refSampleDuration;\n        if (sources[type].data.length >= this.preloadTime / dur) {\n          add = true;\n        }\n      }\n    }\n\n    if (add) {\n      if (Object.keys(this.sourceBuffers).length > 0) {\n        return;\n      }\n      for (let i = 0, k = Object.keys(sources).length; i < k; i++) {\n        let type = Object.keys(sources)[i];\n        let source = sources[type];\n        let mime = type === 'video' ? 'video/mp4;codecs=' + source.mimetype : 'audio/mp4;codecs=' + source.mimetype;\n        let sourceBuffer = this.mediaSource.addSourceBuffer(mime);\n        this.sourceBuffers[type] = sourceBuffer;\n        sourceBuffer.addEventListener('updateend', this.onUpdateEnd);\n        this.doAppend();\n      }\n    }\n  }\n\n  doAppend() {\n    let sources = this._context.getInstance('PRE_SOURCE_BUFFER');\n    if (sources) {\n      for (let i = 0; i < Object.keys(this.sourceBuffers).length; i++) {\n        let type = Object.keys(this.sourceBuffers)[i];\n        let sourceBuffer = this.sourceBuffers[type];\n        if (!sourceBuffer.updating) {\n          let source = sources.sources[type];\n          if (source && !source.inited) {\n            // console.log('append initial segment')\n            sourceBuffer.appendBuffer(source.init.buffer.buffer);\n            source.inited = true;\n          } else if (source) {\n            let data = source.data.shift();\n            if (data) {\n              sourceBuffer.appendBuffer(data.buffer.buffer);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  endOfStream() {\n    const { readyState, activeSourceBuffers } = this.mediaSource;\n    if (readyState === 'open' && activeSourceBuffers.length === 0) {\n      try {\n        this.mediaSource.endOfStream();\n      } catch (e) {\n        // log\n      }\n    }\n  }\n\n  remove(end, start = 0) {\n    for (let i = 0; i < Object.keys(this.sourceBuffers).length; i++) {\n      let buffer = this.sourceBuffers[Object.keys(this.sourceBuffers)[i]];\n      if (!buffer.updating) {\n        // console.log(start, end)\n        buffer.remove(start, end);\n      }\n    }\n  }\n  removeBuffers() {\n    const taskList = [];\n    for (let i = 0; i < Object.keys(this.sourceBuffers).length; i++) {\n      let buffer = this.sourceBuffers[Object.keys(this.sourceBuffers)[i]];\n      buffer.removeEventListener('updateend', this.onUpdateEnd);\n\n      let task;\n      if (buffer.updating) {\n        task = new Promise(resolve => {\n          const doCleanBuffer = function () {\n            let retryTime = 3;\n\n            const clean = () => {\n              if (!buffer.updating) {\n                MSE.clearBuffer(buffer);\n                resolve();\n              } else if (retryTime > 0) {\n                setTimeout(clean, 200);\n                retryTime--;\n              } else {\n                resolve();\n              }\n            };\n\n            setTimeout(clean, 200);\n            buffer.removeEventListener('updateend', doCleanBuffer);\n          };\n          buffer.addEventListener('updateend', doCleanBuffer);\n        });\n      } else {\n        MSE.clearBuffer(buffer);\n        task = Promise.resolve();\n      }\n\n      taskList.push(task);\n    }\n\n    return Promise.all(taskList);\n  }\n\n  destroy() {\n    return this.removeBuffers().then(() => {\n      for (let i = 0; i < Object.keys(this.sourceBuffers).length; i++) {\n        let buffer = this.sourceBuffers[Object.keys(this.sourceBuffers)[i]];\n        this.mediaSource.removeSourceBuffer(buffer);\n        delete this.sourceBuffers[Object.keys(this.sourceBuffers)[i]];\n      }\n\n      this.container.removeEventListener('timeupdate', this.onTimeUpdate);\n      this.container.removeEventListener('waiting', this.onWaiting);\n      this.mediaSource.removeEventListener('sourceopen', this.onSourceOpen);\n\n      this.endOfStream();\n      window.URL.revokeObjectURL(this.url);\n\n      this.url = null;\n      this.configs = {};\n      this.container = null;\n      this.mediaSource = null;\n      this.sourceBuffers = {};\n      this.preloadTime = 1;\n    });\n  }\n\n  static clearBuffer(buffer) {\n    const buffered = buffer.buffered;\n    let bEnd = 0.1;\n    for (let i = 0, len = buffered.length; i < len; i++) {\n      bEnd = buffered.end(i);\n    }\n    try {\n      buffer.remove(0, bEnd);\n    } catch (e) {\n      // DO NOTHING\n    }\n  }\n}\nexports.default = MSE;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/mse/index.js?")},"../xgplayer-utils/src/write/buffer.js":
/*!*********************************************!*\
      !*** ../xgplayer-utils/src/write/buffer.js ***!
      \*********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _concatTypedArray = __webpack_require__(/*! concat-typed-array */ \"../xgplayer-utils/node_modules/concat-typed-array/lib/index.js\");\n\nvar _concatTypedArray2 = _interopRequireDefault(_concatTypedArray);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass Buffer {\n  constructor(buffer) {\n    this.buffer = buffer || new Uint8Array(0);\n  }\n\n  write(...buffer) {\n    buffer.forEach(item => {\n      this.buffer = (0, _concatTypedArray2.default)(Uint8Array, this.buffer, item);\n    });\n  }\n\n  static writeUint32(value) {\n    return new Uint8Array([value >> 24, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff]);\n  }\n\n  static readAsInt(arr) {\n    let temp = '';\n\n    function padStart4Hex(hexNum) {\n      let hexStr = hexNum.toString(16);\n      return hexStr.padStart(2, '0');\n    }\n\n    arr.forEach(num => {\n      temp += padStart4Hex(num);\n    });\n    return parseInt(temp, 16);\n  }\n}\n\nexports.default = Buffer;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/write/buffer.js?")},"../xgplayer-utils/src/write/stream.js":
/*!*********************************************!*\
      !*** ../xgplayer-utils/src/write/stream.js ***!
      \*********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass Stream {\n  constructor(buffer) {\n    if (buffer instanceof ArrayBuffer) {\n      this.buffer = buffer;\n      this.dataview = new DataView(buffer);\n      this.dataview.position = 0;\n    } else {\n      throw new Error('data is invalid');\n    }\n  }\n\n  get length() {\n    return this.buffer.byteLength;\n  }\n\n  set position(value) {\n    this.dataview.position = value;\n  }\n\n  get position() {\n    return this.dataview.position;\n  }\n\n  back(count) {\n    this.position -= count;\n  }\n\n  skip(count) {\n    let loop = Math.floor(count / 4);\n    let last = count % 4;\n    for (let i = 0; i < loop; i++) {\n      Stream.readByte(this.dataview, 4);\n    }\n    if (last > 0) {\n      Stream.readByte(this.dataview, last);\n    }\n  }\n\n  /**\n   * [readByte 从DataView中读取数据]\n   * @param  {DataView} buffer [DataView实例]\n   * @param  {Number} size   [读取字节数]\n   * @return {Number}        [整数]\n   */\n  static readByte(buffer, size, sign) {\n    let res;\n    switch (size) {\n      case 1:\n        if (sign) {\n          res = buffer.getInt8(buffer.position);\n        } else {\n          res = buffer.getUint8(buffer.position);\n        }\n        break;\n      case 2:\n        if (sign) {\n          res = buffer.getInt16(buffer.position);\n        } else {\n          res = buffer.getUint16(buffer.position);\n        }\n        break;\n      case 3:\n        if (sign) {\n          throw new Error('not supported for readByte 3');\n        } else {\n          res = buffer.getUint8(buffer.position) << 16;\n          res |= buffer.getUint8(buffer.position + 1) << 8;\n          res |= buffer.getUint8(buffer.position + 2);\n        }\n        break;\n      case 4:\n        if (sign) {\n          res = buffer.getInt32(buffer.position);\n        } else {\n          res = buffer.getUint32(buffer.position);\n        }\n        break;\n      case 8:\n        if (sign) {\n          throw new Error('not supported for readBody 8');\n        } else {\n          res = buffer.getUint32(buffer.position) << 32;\n          res |= buffer.getUint32(buffer.position + 4);\n        }\n        break;\n      default:\n        res = '';\n    }\n    buffer.position += size;\n    return res;\n  }\n\n  readUint8() {\n    return Stream.readByte(this.dataview, 1);\n  }\n\n  readUint16() {\n    return Stream.readByte(this.dataview, 2);\n  }\n\n  readUint24() {\n    return Stream.readByte(this.dataview, 3);\n  }\n\n  readUint32() {\n    return Stream.readByte(this.dataview, 4);\n  }\n\n  readUint64() {\n    return Stream.readByte(this.dataview, 8);\n  }\n\n  readInt8() {\n    return Stream.readByte(this.dataview, 1, true);\n  }\n  readInt16() {\n    return Stream.readByte(this.dataview, 2, true);\n  }\n\n  readInt32() {\n    return Stream.readByte(this.dataview, 4, true);\n  }\n\n  writeUint32(value) {\n    return new Uint8Array([value >>> 24 & 0xff, value >>> 16 & 0xff, value >>> 8 & 0xff, value & 0xff]);\n  }\n}\n\nexports.default = Stream;\n\n//# sourceURL=webpack://xgplayer-flv/../xgplayer-utils/src/write/stream.js?")},"./src/flv-live.js":
/*!*************************!*\
      !*** ./src/flv-live.js ***!
      \*************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _xgplayerRemux = __webpack_require__(/*! xgplayer-remux */ \"../xgplayer-remux/index.js\");\n\nvar _xgplayerRemux2 = _interopRequireDefault(_xgplayerRemux);\n\nvar _xgplayerLoader = __webpack_require__(/*! xgplayer-loader */ \"../xgplayer-loader/index.js\");\n\nvar _xgplayerDemux = __webpack_require__(/*! xgplayer-demux */ \"../xgplayer-demux/index.js\");\n\nvar _xgplayerBuffer = __webpack_require__(/*! xgplayer-buffer */ \"../xgplayer-buffer/index.js\");\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nvar _xgplayerCodec = __webpack_require__(/*! xgplayer-codec */ \"../xgplayer-codec/index.js\");\n\nvar _xgplayer = __webpack_require__(/*! xgplayer */ \"xgplayer\");\n\nvar _xgplayer2 = _interopRequireDefault(_xgplayer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst REMUX_EVENTS = _xgplayerUtils.EVENTS.REMUX_EVENTS;\nconst DEMUX_EVENTS = _xgplayerUtils.EVENTS.DEMUX_EVENTS;\nconst LOADER_EVENTS = _xgplayerUtils.EVENTS.LOADER_EVENTS;\nconst MSE_EVENTS = _xgplayerUtils.EVENTS.MSE_EVENTS;\n\nconst Tag = 'FLVController';\n\nclass Logger {\n  warn() {}\n}\n\nconst FLV_ERROR = 'FLV_ERROR';\n\nclass FlvController {\n  constructor(player) {\n    this.TAG = Tag;\n    this._player = player;\n\n    this.state = {\n      initSegmentArrived: false\n    };\n\n    this.bufferClearTimer = null;\n  }\n\n  init() {\n    this._context.registry('FETCH_LOADER', _xgplayerLoader.FetchLoader);\n    this._context.registry('LOADER_BUFFER', _xgplayerBuffer.XgBuffer);\n\n    this._context.registry('FLV_DEMUXER', _xgplayerDemux.FlvDemuxer);\n    this._context.registry('TRACKS', _xgplayerBuffer.Tracks);\n\n    this._context.registry('MP4_REMUXER', _xgplayerRemux2.default.Mp4Remuxer);\n    this._context.registry('PRE_SOURCE_BUFFER', _xgplayerBuffer.PreSource);\n\n    if (this._player.config.compatibility !== false) {\n      this._context.registry('COMPATIBILITY', _xgplayerCodec.Compatibility);\n    }\n\n    this._context.registry('LOGGER', Logger);\n    this.mse = this._context.registry('MSE', _xgplayerUtils.Mse)({ container: this._player.video });\n\n    this._handleTimeUpdate = this._handleTimeUpdate.bind(this);\n\n    this.initListeners();\n  }\n\n  initListeners() {\n    this.on(LOADER_EVENTS.LOADER_DATALOADED, this._handleLoaderDataLoaded.bind(this));\n    this.on(LOADER_EVENTS.LOADER_ERROR, this._handleNetworkError.bind(this));\n\n    this.on(DEMUX_EVENTS.MEDIA_INFO, this._handleMediaInfo.bind(this));\n    this.on(DEMUX_EVENTS.METADATA_PARSED, this._handleMetadataParsed.bind(this));\n    this.on(DEMUX_EVENTS.DEMUX_COMPLETE, this._handleDemuxComplete.bind(this));\n    this.on(DEMUX_EVENTS.DEMUX_ERROR, this._handleDemuxError.bind(this));\n\n    this.on(REMUX_EVENTS.INIT_SEGMENT, this._handleAppendInitSegment.bind(this));\n    this.on(REMUX_EVENTS.MEDIA_SEGMENT, this._handleMediaSegment.bind(this));\n\n    this.on(MSE_EVENTS.SOURCE_UPDATE_END, this._handleSourceUpdateEnd.bind(this));\n\n    this._player.on('timeupdate', this._handleTimeUpdate);\n  }\n\n  _handleMediaInfo() {\n    if (!this._context.mediaInfo) {\n      this.emit(DEMUX_EVENTS.DEMUX_ERROR, new Error('failed to get mediainfo'));\n    }\n  }\n\n  _handleLoaderDataLoaded() {\n    this.emitTo('FLV_DEMUXER', DEMUX_EVENTS.DEMUX_START);\n  }\n\n  _handleMetadataParsed(type) {\n    this.emit(REMUX_EVENTS.REMUX_METADATA, type);\n  }\n  _handleDemuxComplete() {\n    this.emit(REMUX_EVENTS.REMUX_MEDIA);\n  }\n\n  _handleAppendInitSegment() {\n    this.state.initSegmentArrived = true;\n    this.mse.addSourceBuffers();\n  }\n\n  _handleMediaSegment() {\n    this.mse.addSourceBuffers();\n    this.mse.doAppend();\n  }\n\n  _handleSourceUpdateEnd() {\n    const time = this._player.currentTime;\n    const video = this._player.video;\n    const preloadTime = this._player.config.preloadTime || 5;\n\n    const { length } = video.buffered;\n\n    if (length === 0) {\n      return;\n    }\n\n    const bufferEnd = video.buffered.end(length - 1);\n    if (bufferEnd - time > preloadTime * 2) {\n      this._player.currentTime = bufferEnd - preloadTime;\n    }\n    this.mse.doAppend();\n  }\n\n  _handleTimeUpdate() {\n    const time = this._player.currentTime;\n\n    const video = this._player.video;\n    let buffered = video.buffered;\n\n    if (!buffered || !buffered.length) {\n      return;\n    }\n\n    const bufferStart = buffered.start(buffered.length - 1);\n    // const bufferStart = this._player.getBufferedRange()[0]\n    if (time - bufferStart > 10) {\n      // 在直播时及时清空buffer，降低直播内存占用\n      if (this.bufferClearTimer) {\n        return;\n      }\n\n      this.mse.remove(time - 1, bufferStart);\n      this.bufferClearTimer = setTimeout(() => {\n        this.bufferClearTimer = null;\n      }, 5000);\n    }\n  }\n\n  _handleNetworkError(tag, err) {\n    this._player.emit('error', new _xgplayer2.default.Errors('network', this._player.config.url));\n    this._onError(LOADER_EVENTS.LOADER_ERROR, tag, err, true);\n  }\n\n  _handleDemuxError(tag, err, fatal) {\n    if (fatal === undefined) {\n      fatal = false;\n    }\n    this._player.emit('error', new _xgplayer2.default.Errors('parse', this._player.config.url));\n    this._onError(LOADER_EVENTS.LOADER_ERROR, tag, err, fatal);\n  }\n\n  _onError(type, mod, err, fatal) {\n    let error = {\n      errorType: type,\n      errorDetails: `[${mod}]: ${err.message}`,\n      errorFatal: fatal || false\n    };\n    this._player.emit(FLV_ERROR, error);\n  }\n\n  seek() {\n    if (!this.state.initSegmentArrived) {\n      this.loadData();\n    }\n  }\n\n  loadData() {\n    this.emit(LOADER_EVENTS.LADER_START, this._player.config.url);\n  }\n\n  pause() {\n    const loader = this._context.getInstance('FETCH_LOADER');\n\n    if (loader) {\n      loader.cancel();\n    }\n  }\n\n  destroy() {\n    this._player.off('timeupdate', this._handleTimeUpdate);\n    this._player = null;\n    this.mse = null;\n  }\n}\nexports.default = FlvController;\n\n//# sourceURL=webpack://xgplayer-flv/./src/flv-live.js?")},"./src/index.js":
/*!**********************!*\
      !*** ./src/index.js ***!
      \**********************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n\nvar _xgplayer = __webpack_require__(/*! xgplayer */ \"xgplayer\");\n\nvar _xgplayer2 = _interopRequireDefault(_xgplayer);\n\nvar _xgplayerUtils = __webpack_require__(/*! xgplayer-utils */ \"../xgplayer-utils/index.js\");\n\nvar _flvLive = __webpack_require__(/*! ./flv-live */ \"./src/flv-live.js\");\n\nvar _flvLive2 = _interopRequireDefault(_flvLive);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst flvAllowedEvents = _xgplayerUtils.EVENTS.FlvAllowedEvents;\n\nclass FlvPlayer extends _xgplayer2.default {\n  constructor(config) {\n    super(config);\n    this.context = new _xgplayerUtils.Context(flvAllowedEvents);\n    this.initEvents();\n    this.loaderCompleteTimer = null;\n    // const preloadTime = player.config.preloadTime || 15\n  }\n\n  start() {\n    this.initFlv();\n    this.context.init();\n    super.start(this.flv.mse.url);\n  }\n\n  initFlvEvents(flv) {\n    const player = this;\n    flv.once(_xgplayerUtils.EVENTS.REMUX_EVENTS.INIT_SEGMENT, () => {\n      _xgplayer2.default.util.addClass(player.root, 'xgplayer-is-live');\n      if (!_xgplayer2.default.util.findDom(this.root, 'xg-live')) {\n        const live = _xgplayer2.default.util.createDom('xg-live', '正在直播', {}, 'xgplayer-live');\n        player.controls.appendChild(live);\n      }\n    });\n\n    flv.once(_xgplayerUtils.EVENTS.LOADER_EVENTS.LOADER_COMPLETE, () => {\n      // 直播完成，待播放器播完缓存后发送关闭事件\n      if (!player.paused) {\n        this.loaderCompleteTimer = setInterval(() => {\n          const end = player.getBufferedRange()[1];\n          if (Math.abs(player.currentTime - end) < 0.5) {\n            player.emit('ended');\n            window.clearInterval(this.loaderCompleteTimer);\n          }\n        }, 200);\n      }\n    });\n  }\n\n  initEvents() {\n    this.on('timeupdate', () => {\n      this.loadData();\n    });\n\n    this.on('seeking', () => {\n      const time = this.currentTime;\n      const range = this.getBufferedRange();\n      if (time > range[1] || time < range[0]) {\n        this.flv.seek(this.currentTime);\n      }\n    });\n  }\n\n  initFlv() {\n    const flv = this.context.registry('FLV_CONTROLLER', _flvLive2.default)(this);\n    this.initFlvEvents(flv);\n    this.flv = flv;\n  }\n\n  play() {\n    if (this._hasStart) {\n      this._destroy().then(() => {\n        this.context = new _xgplayerUtils.Context(flvAllowedEvents);\n        const flv = this.context.registry('FLV_CONTROLLER', _flvLive2.default)(this);\n        this.initFlvEvents(flv);\n        this.flv = flv;\n        this.context.init();\n        super.start(flv.mse.url);\n        super.play();\n      });\n    } else {\n      super.play();\n    }\n  }\n\n  pause() {\n    super.pause();\n    if (this.flv) {\n      this.flv.pause();\n    }\n  }\n\n  loadData(time = this.currentTime) {\n    if (this.flv) {\n      this.flv.seek(time);\n    }\n  }\n\n  destroy() {\n    this._destroy().then(() => {\n      super.destroy();\n    });\n  }\n\n  _destroy() {\n    return this.flv.mse.destroy().then(() => {\n      this.context.destroy();\n      this.flv = null;\n      this.context = null;\n      if (this.loaderCompleteTimer) {\n        window.clearInterval(this.loaderCompleteTimer);\n      }\n    });\n  }\n\n  get src() {\n    return this.currentSrc;\n  }\n\n  set src(url) {\n    this.player.config.url = url;\n    if (!this.paused) {\n      this.pause();\n      this.once('pause', () => {\n        this.start(url);\n      });\n      this.once('canplay', () => {\n        this.play();\n      });\n    } else {\n      this.start(url);\n    }\n    this.once('canplay', () => {\n      this.currentTime = 0;\n    });\n  }\n}\n\nmodule.exports = FlvPlayer;\n\n//# sourceURL=webpack://xgplayer-flv/./src/index.js?")},0:
/*!****************************!*\
      !*** multi ./src/index.js ***!
      \****************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__(/*! ./src/index.js */"./src/index.js");\n\n\n//# sourceURL=webpack://xgplayer-flv/multi_./src/index.js?')},xgplayer:
/*!***************************!*\
      !*** external "xgplayer" ***!
      \***************************/
/*! no static exports found */function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE_xgplayer__;\n\n//# sourceURL=webpack://xgplayer-flv/external_%22xgplayer%22?")}})},module.exports=n(__webpack_require__(/*! xgplayer */"xgplayer"))},"../xgplayer-flv-vod/dist/index.js":
/*!***************************!*\
  !*** .-vod/dist/index.js ***!
  \***************************/
/*! no static exports found */function(e,t,n){"use strict";var s;window,e.exports=(s=n(/*! xgplayer */"xgplayer"),function(e){var t={};function n(s){if(t[s])return t[s].exports;var i=t[s]={i:s,l:!1,exports:{}};return e[s].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,s){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(n.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(s,i,function(t){return e[t]}.bind(null,i));return s},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=11)}([function(e,t,n){e.exports={Context:n(13).default,EVENTS:n(4).default,WORKER_COMMANDS:n(15).default,sniffer:n(16).default,isLe:n(17).default,UTF8:n(18).default,MediaInfo:n(3).default,MediaSample:n(19).default,MediaSegment:n(20).default,MediaSegmentList:n(21).default,AudioTrackMeta:n(5).AudioTrackMeta,VideoTrackMeta:n(5).VideoTrackMeta,AudioTrackSample:n(6).AudioTrackSample,VideoTrackSample:n(6).VideoTrackSample,Mse:n(22).default,Stream:n(23).default,Buffer:n(24).default,Crypto:n(27).default}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});class s{constructor(){this.id=-1,this.sequenceNumber=0,this.samples=[],this.droppedSamples=[],this.length=0}reset(){this.sequenceNumber=0,this.samples=[],this.length=0}distroy(){this.reset(),this.id=-1}}t.default=s,t.AudioTrack=class extends s{constructor(){super(),this.TAG="AudioTrack",this.type="audio"}},t.VideoTrack=class extends s{constructor(){super(),this.TAG="VideoTrack",this.type="video",this.dropped=0}reset(){this.sequenceNumber=0,this.samples=[],this.length=0,this.dropped=0}},t.Tracks=class{constructor(){this.audioTrack=null,this.videoTrack=null}destroy(){this.audioTrack=null,this.videoTrack=null}}},function(e,t){e.exports=s},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});const s=e=>{for(let t in e)if(e.hasOwnProperty(t)&&null===e[t])return!1;return!0};class i{constructor(){this.mimeType=null,this.duration=null,this.hasVideo=null,this.video={codec:null,width:null,height:null,profile:null,level:null,frameRate:{fixed:!0,fps:25,fps_num:25e3,fps_den:1e3},chromaFormat:null,parRatio:{width:1,height:1}},this.hasAudio=null,this.audio={codec:null,sampleRate:null,sampleRateIndex:null,channelCount:null}}isComplete(){return i.isBaseInfoReady(this)&&i.isVideoReady(this)&&i.isAudioReady(this)}static isBaseInfoReady(e){return s(e)}static isVideoReady(e){return!e.hasVideo||s(e.video)}static isAudioReady(e){return!e.hasAudio||s(e.video)}}t.default=i},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});const s={LADER_START:"LOADER_START",LOADER_DATALOADED:"LOADER_DATALOADED",LOADER_COMPLETE:"LOADER_COMPLETE",LOADER_ERROR:"LOADER_ERROR"},i={DEMUX_START:"DEMUX_START",DEMUX_COMPLETE:"DEMUX_COMPLETE",DEMUX_ERROR:"DEMUX_ERROR",METADATA_PARSED:"METADATA_PARSED",VIDEO_METADATA_CHANGE:"VIDEO_METADATA_CHANGE",AUDIO_METADATA_CHANGE:"AUDIO_METADATA_CHANGE",MEDIA_INFO:"MEDIA_INFO"},r={REMUX_METADATA:"REMUX_METADATA",REMUX_MEDIA:"REMUX_MEDIA",MEDIA_SEGMENT:"MEDIA_SEGMENT",REMUX_ERROR:"REMUX_ERROR",INIT_SEGMENT:"INIT_SEGMENT",DETECT_CHANGE_STREAM:"DETECT_CHANGE_STREAM"},a={SOURCE_UPDATE_END:"SOURCE_UPDATE_END"},o={RETRY_TIME_EXCEEDED:"RETRY_TIME_EXCEEDED"},l=Object.assign({},s,i,r,a,o),d=[],u=[];for(let e in l)l.hasOwnProperty(e)&&d.push(l[e]);for(let e in l)l.hasOwnProperty(e)&&u.push(l[e]);t.default={ALLEVENTS:l,HLS_EVENTS:o,REMUX_EVENTS:r,DEMUX_EVENTS:i,MSE_EVENTS:a,LOADER_EVENTS:s,FlvAllowedEvents:d,HlsAllowedEvents:u,CRYTO_EVENTS:{START_DECRYPT:"START_DECRYPT",DECRYPTED:"DECRYPTED"}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.AudioTrackMeta=class{constructor(e){const t={sampleRate:48e3,channelCount:2,codec:"mp4a.40.2",config:[41,401,136,0],duration:0,id:2,refSampleDuration:21,sampleRateIndex:3,timescale:1e3,type:"audio"};return e?Object.assign({},t,e):t}destroy(){this.init=null}},t.VideoTrackMeta=class{constructor(e){const t={avcc:null,sps:new Uint8Array(0),pps:new Uint8Array(0),chromaFormat:420,codec:"avc1.640020",codecHeight:720,codecWidth:1280,duration:0,frameRate:{fixed:!0,fps:25,fps_num:25e3,fps_den:1e3},id:1,level:"3.2",presentHeight:720,presentWidth:1280,profile:"High",refSampleDuration:40,parRatio:{height:1,width:1},timescale:1e3,type:"video"};return e?Object.assign({},t,e):t}destroy(){this.init=null,this.sps=null,this.pps=null}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});class s{constructor(e){let t=s.getDefault();return e?Object.assign({},t,e):t}static getDefault(){return{dts:null,pts:null,data:new Uint8Array}}}t.AudioTrackSample=s;class i{constructor(e){let t=i.getDefault();return e?Object.assign({},t,e):t}static getDefault(){return{dts:null,pts:null,isKeyframe:!1,originDts:null,data:new Uint8Array}}}t.VideoTrackSample=i},function(e,t,n){e.exports={Nalunit:n(30).default,SpsParser:n(8).default,Compatibility:n(32).default}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s,i=(s=n(31))&&s.__esModule?s:{default:s};class r{static _ebsp2rbsp(e){let t=e,n=t.byteLength,s=new Uint8Array(n),i=0;for(let e=0;e<n;e++)e>=2&&3===t[e]&&0===t[e-1]&&0===t[e-2]||(s[i]=t[e],i++);return new Uint8Array(s.buffer,0,i)}static parseSPS(e){let t=r._ebsp2rbsp(e),n=new i.default(t);n.readByte();let s=n.readByte();n.readByte();let a=n.readByte();n.readUEG();let o=r.getProfileString(s),l=r.getLevelString(a),d=1,u=420,f=8;if((100===s||110===s||122===s||244===s||44===s||83===s||86===s||118===s||128===s||138===s||144===s)&&(3===(d=n.readUEG())&&n.readBits(1),d<=3&&(u=[0,420,422,444][d]),f=n.readUEG()+8,n.readUEG(),n.readBits(1),n.readBool())){let e=3!==d?8:12;for(let t=0;t<e;t++)n.readBool()&&(t<6?r._skipScalingList(n,16):r._skipScalingList(n,64))}n.readUEG();let c=n.readUEG();if(0===c)n.readUEG();else if(1===c){n.readBits(1),n.readSEG(),n.readSEG();let e=n.readUEG();for(let t=0;t<e;t++)n.readSEG()}n.readUEG(),n.readBits(1);let h=n.readUEG(),p=n.readUEG(),m=n.readBits(1);0===m&&n.readBits(1),n.readBits(1);let _=0,g=0,x=0,y=0;n.readBool()&&(_=n.readUEG(),g=n.readUEG(),x=n.readUEG(),y=n.readUEG());let b=1,v=1,E=0,S=!0,T=0,w=0;if(n.readBool()){if(n.readBool()){let e=n.readByte(),t=[1,12,10,16,40,24,20,32,80,18,15,64,160,4,3,2],s=[1,11,11,11,33,11,11,11,33,11,11,33,99,3,2,1];e>0&&e<16?(b=t[e-1],v=s[e-1]):255===e&&(b=n.readByte()<<8|n.readByte(),v=n.readByte()<<8|n.readByte())}if(n.readBool()&&n.readBool(),n.readBool()&&(n.readBits(4),n.readBool()&&n.readBits(24)),n.readBool()&&(n.readUEG(),n.readUEG()),n.readBool()){let e=n.readBits(32),t=n.readBits(32);S=n.readBool(),E=(T=t)/(w=2*e)}}let k=1;1===b&&1===v||(k=b/v);let A=0,D=0;0===d?(A=1,D=2-m):(A=3===d?1:2,D=(1===d?2:1)*(2-m));let R=16*(h+1),L=16*(p+1)*(2-m);R-=(_+g)*A,L-=(x+y)*D;let M=Math.ceil(R*k);return n.destroy(),n=null,{profile_string:o,level_string:l,bit_depth:f,chroma_format:u,chroma_format_string:r.getChromaFormatString(u),frame_rate:{fixed:S,fps:E,fps_den:w,fps_num:T},par_ratio:{width:b,height:v},codec_size:{width:R,height:L},present_size:{width:M,height:L}}}static _skipScalingList(e,t){let n=8,s=8,i=0;for(let r=0;r<t;r++)0!==s&&(s=(n+(i=e.readSEG())+256)%256),n=0===s?n:s}static getProfileString(e){switch(e){case 66:return"Baseline";case 77:return"Main";case 88:return"Extended";case 100:return"High";case 110:return"High10";case 122:return"High422";case 244:return"High444";default:return"Unknown"}}static getLevelString(e){return(e/10).toFixed(1)}static getChromaFormatString(e){switch(e){case 420:return"4:2:0";case 422:return"4:2:2";case 444:return"4:4:4";default:return"Unknown"}}static toVideoMeta(e){let t={};e&&e.codec_size&&(t.codecWidth=e.codec_size.width,t.codecHeight=e.codec_size.height,t.presentWidth=e.present_size.width,t.presentHeight=e.present_size.height),t.profile=e.profile_string,t.level=e.level_string,t.bitDepth=e.bit_depth,t.chromaFormat=e.chroma_format,t.parRatio={width:e.par_ratio.width,height:e.par_ratio.height},t.frameRate=e.frame_rate;let n=t.frameRate.fps_den,s=t.frameRate.fps_num;t.refSampleDuration=Math.floor(t.timescale*(n/s))}}t.default=r},function(e,t,n){e.exports={Track:n(1).default,Tracks:n(1).Tracks,AudioTrack:n(1).AudioTrack,VideoTrack:n(1).VideoTrack,XgBuffer:n(10).XgBuffer,RemuxBuffer:n(10).RemuxBuffer,PreSource:n(34).default}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.XgBuffer=class{constructor(e){this.length=e||0,this.historyLen=e||0,this.array=[],this.offset=0}push(e){this.array.push(e),this.length+=e.byteLength,this.historyLen+=e.byteLength}shift(e){if(this.array.length<1)return new Uint8Array(0);if(void 0===e)return this._shiftBuffer();if(this.offset+e===this.array[0].length){let t=this.array[0].slice(this.offset,this.offset+e);return this.offset=0,this.array.shift(),this.length-=e,t}if(this.offset+e<this.array[0].length){let t=this.array[0].slice(this.offset,this.offset+e);return this.offset+=e,this.length-=e,t}let t=new Uint8Array(e),n=0;for(;this.array.length>0&&e>0;){if(this.offset+e<this.array[0].length){let s=this.array[0].slice(this.offset,this.offset+e);t.set(s,n),this.offset+=e,this.length-=e,e=0;break}{let s=this.array[0].length-this.offset;t.set(this.array[0].slice(this.offset,this.array[0].length),n),this.array.shift(),this.offset=0,n+=s,this.length-=s,e-=s}}return t}clear(){this.array=[],this.length=0,this.offset=0}destroy(){this.clear(),this.historyLen=0}_shiftBuffer(){return this.length-=this.array[0].length,this.offset=0,this.array.shift()}toInt(e,t){let n=0,s=this.offset+e;for(;s<this.offset+t+e;)s<this.array[0].length?n=256*n+this.array[0][s]:this.array[1]&&(n=256*n+this.array[1][s-this.array[0].length]),s++;return n}},t.RemuxBuffer=class{constructor(){this.video=[],this.audio=[]}destroy(){this.video=[],this.audio=[]}}},function(e,t,n){e.exports=n(12)},function(e,t,n){var s=a(n(2)),i=n(0),r=a(n(28));function a(e){return e&&e.__esModule?e:{default:e}}const o=i.EVENTS.FlvAllowedEvents,l=(e,t)=>{if(!e.config.isLive&&e.duration-e.currentTime<2){const n=e.getBufferedRange();e.currentTime-n[1]<.1&&(e.emit("ended"),t.mse.endOfStream())}};class d extends s.default{constructor(e){super(e),this.context=new i.Context(o),this.initEvents()}start(){const e=this.context.registry("FLV_CONTROLLER",r.default)(this);this.flv=e,this.context.init(),super.start(e.mse.url)}initEvents(){this.on("timeupdate",this.handleTimeUpdate.bind(this)),this.on("seeking",this.handleSeek.bind(this)),this.once("destroy",this._destroy.bind(this))}handleTimeUpdate(){this.loadData(),l(this,this.flv)}handleSeek(){const e=this.currentTime,t=this.getBufferedRange();(e>t[1]||e<t[0])&&this.flv.seek(this.currentTime)}_destroy(){this.context.destroy(),this.context=null,this.flv=null}loadData(e=this.currentTime){const t=this.getBufferedRange();t[1]-e<(this.config.preloadTime||15)-5&&this.flv.loadNext(t[1]+1)}get src(){return this.currentSrc}set src(e){this.player.config.url=e,this.paused?this.start(e):(this.pause(),this.once("pause",()=>{this.start(e)}),this.once("canplay",()=>{this.play()})),this.once("canplay",()=>{this.currentTime=0})}}e.exports=d},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s,i=(s=n(3))&&s.__esModule?s:{default:s},r=n(14);const a="__TO__";t.default=class{constructor(e=[]){this._emitter=new r.EventEmitter,this._instanceMap={},this._clsMap={},this._inited=!1,this.mediaInfo=new i.default,this.allowedEvents=e,this._hooks={}}getInstance(e){return this._instanceMap[e]||null}initInstance(e,...t){if(this._clsMap[e]){const n=new this._clsMap[e](...t);return this._instanceMap[e]=n,n.init&&n.init(),n}throw new Error(`${e}未在context中注册`)}init(e){if(!this._inited){for(let t in this._clsMap)this._clsMap.hasOwnProperty(t)&&!this._instanceMap[t]&&this.initInstance(t,e);this._inited=!0}}registry(e,t){const n=this._emitter,s=this._isMessageNameValid.bind(this),i=this;return this._clsMap[e]=class extends t{constructor(...t){super(...t),this.listeners={},this.onceListeners={},this.TAG=e,this._context=i}on(t,i){return s(t),this.listeners[t]?this.listeners[t].push(i):this.listeners[t]=[i],n.on(`${t}${a}${e}`,i),n.on(t,i)}before(e,t){s(e),i._hooks[e]?i._hooks[e].push(t):i._hooks[e]=[t]}once(t,i){return s(t),this.onceListeners[t]?this.onceListeners[t].push(i):this.onceListeners[t]=[i],n.once(`${t}${a}${e}`,i),n.once(t,i)}emit(e,...t){s(e);const r=i._hooks?i._hooks[e]:null;if(r)for(let e=0,t=r.length;e<t;e++)(0,r[e])();return n.emit(e,...t)}emitTo(e,t,...i){return s(t),n.emit(`${t}${a}${e}`,...i)}off(e,t){return s(e),n.off(e,t)}removeListeners(){const t=Object.prototype.hasOwnProperty.bind(this.listeners);for(let s in this.listeners)if(t(s)){const t=this.listeners[s]||[];for(let i=0;i<t.length;i++){const r=t[i];n.off(s,r),n.off(`${s}${a}${e}`,r)}}for(let s in this.onceListeners)if(t(s)){const t=this.onceListeners[s]||[];for(let i=0;i<t.length;i++){const r=t[i];n.off(s,r),n.off(`${s}${a}${e}`,r)}}}destroy(){if(this.removeListeners(),this.listeners={},delete i._instanceMap[e],super.destroy)return super.destroy()}},(...t)=>this.initInstance(e,...t)}destroyInstances(){Object.keys(this._instanceMap).forEach(e=>{this._instanceMap[e].destroy&&this._instanceMap[e].destroy()})}destroy(){this._emitter=null,this.allowedEvents=[],this._clsMap=null,this._context=null,this._hooks=null,this.destroyInstances()}_isMessageNameValid(e){if(!this.allowedEvents.indexOf(e)<0)throw new Error(`unregistered message name: ${e}`)}}},function(e,t,n){var s,i="object"==typeof Reflect?Reflect:null,r=i&&"function"==typeof i.apply?i.apply:function(e,t,n){return Function.prototype.apply.call(e,t,n)};s=i&&"function"==typeof i.ownKeys?i.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var a=Number.isNaN||function(e){return e!=e};function o(){o.init.call(this)}e.exports=o,o.EventEmitter=o,o.prototype._events=void 0,o.prototype._eventsCount=0,o.prototype._maxListeners=void 0;var l=10;function d(e){return void 0===e._maxListeners?o.defaultMaxListeners:e._maxListeners}function u(e,t,n,s){var i,r,a,o;if("function"!=typeof n)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof n);if(void 0===(r=e._events)?(r=e._events=Object.create(null),e._eventsCount=0):(void 0!==r.newListener&&(e.emit("newListener",t,n.listener?n.listener:n),r=e._events),a=r[t]),void 0===a)a=r[t]=n,++e._eventsCount;else if("function"==typeof a?a=r[t]=s?[n,a]:[a,n]:s?a.unshift(n):a.push(n),(i=d(e))>0&&a.length>i&&!a.warned){a.warned=!0;var l=new Error("Possible EventEmitter memory leak detected. "+a.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");l.name="MaxListenersExceededWarning",l.emitter=e,l.type=t,l.count=a.length,o=l,console&&console.warn&&console.warn(o)}return e}function f(){for(var e=[],t=0;t<arguments.length;t++)e.push(arguments[t]);this.fired||(this.target.removeListener(this.type,this.wrapFn),this.fired=!0,r(this.listener,this.target,e))}function c(e,t,n){var s={fired:!1,wrapFn:void 0,target:e,type:t,listener:n},i=f.bind(s);return i.listener=n,s.wrapFn=i,i}function h(e,t,n){var s=e._events;if(void 0===s)return[];var i=s[t];return void 0===i?[]:"function"==typeof i?n?[i.listener||i]:[i]:n?function(e){for(var t=new Array(e.length),n=0;n<t.length;++n)t[n]=e[n].listener||e[n];return t}(i):m(i,i.length)}function p(e){var t=this._events;if(void 0!==t){var n=t[e];if("function"==typeof n)return 1;if(void 0!==n)return n.length}return 0}function m(e,t){for(var n=new Array(t),s=0;s<t;++s)n[s]=e[s];return n}Object.defineProperty(o,"defaultMaxListeners",{enumerable:!0,get:function(){return l},set:function(e){if("number"!=typeof e||e<0||a(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");l=e}}),o.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},o.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||a(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},o.prototype.getMaxListeners=function(){return d(this)},o.prototype.emit=function(e){for(var t=[],n=1;n<arguments.length;n++)t.push(arguments[n]);var s="error"===e,i=this._events;if(void 0!==i)s=s&&void 0===i.error;else if(!s)return!1;if(s){var a;if(t.length>0&&(a=t[0]),a instanceof Error)throw a;var o=new Error("Unhandled error."+(a?" ("+a.message+")":""));throw o.context=a,o}var l=i[e];if(void 0===l)return!1;if("function"==typeof l)r(l,this,t);else{var d=l.length,u=m(l,d);for(n=0;n<d;++n)r(u[n],this,t)}return!0},o.prototype.addListener=function(e,t){return u(this,e,t,!1)},o.prototype.on=o.prototype.addListener,o.prototype.prependListener=function(e,t){return u(this,e,t,!0)},o.prototype.once=function(e,t){if("function"!=typeof t)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof t);return this.on(e,c(this,e,t)),this},o.prototype.prependOnceListener=function(e,t){if("function"!=typeof t)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof t);return this.prependListener(e,c(this,e,t)),this},o.prototype.removeListener=function(e,t){var n,s,i,r,a;if("function"!=typeof t)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof t);if(void 0===(s=this._events))return this;if(void 0===(n=s[e]))return this;if(n===t||n.listener===t)0==--this._eventsCount?this._events=Object.create(null):(delete s[e],s.removeListener&&this.emit("removeListener",e,n.listener||t));else if("function"!=typeof n){for(i=-1,r=n.length-1;r>=0;r--)if(n[r]===t||n[r].listener===t){a=n[r].listener,i=r;break}if(i<0)return this;0===i?n.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(n,i),1===n.length&&(s[e]=n[0]),void 0!==s.removeListener&&this.emit("removeListener",e,a||t)}return this},o.prototype.off=o.prototype.removeListener,o.prototype.removeAllListeners=function(e){var t,n,s;if(void 0===(n=this._events))return this;if(void 0===n.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==n[e]&&(0==--this._eventsCount?this._events=Object.create(null):delete n[e]),this;if(0===arguments.length){var i,r=Object.keys(n);for(s=0;s<r.length;++s)"removeListener"!==(i=r[s])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(t=n[e]))this.removeListener(e,t);else if(void 0!==t)for(s=t.length-1;s>=0;s--)this.removeListener(e,t[s]);return this},o.prototype.listeners=function(e){return h(this,e,!0)},o.prototype.rawListeners=function(e){return h(this,e,!1)},o.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):p.call(e,t)},o.prototype.listenerCount=p,o.prototype.eventNames=function(){return this._eventsCount>0?s(this._events):[]}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.CONTEXT_COMOMANDS={ON:"on",ONCE:"once",OFF:"off",EMIT:"emit",DESTROY:"destroy"}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});const s=function(){const e=new ArrayBuffer(2);return new DataView(e).setInt16(0,256,!0),256===new Int16Array(e)[0]}(),i={get device(){let e=i.os;return e.isPc?"pc":e.isTablet?"tablet":"mobile"},get browser(){let e=navigator.userAgent.toLowerCase(),t={ie:/rv:([\d.]+)\) like gecko/,firfox:/firefox\/([\d.]+)/,chrome:/chrome\/([\d.]+)/,opera:/opera.([\d.]+)/,safari:/version\/([\d.]+).*safari/};return[].concat(Object.keys(t).filter(n=>t[n].test(e)))[0]},get os(){let e=navigator.userAgent,t=/(?:Windows Phone)/.test(e),n=/(?:SymbianOS)/.test(e)||t,s=/(?:Android)/.test(e),i=/(?:Firefox)/.test(e),r=/(?:iPad|PlayBook)/.test(e)||s&&!/(?:Mobile)/.test(e)||i&&/(?:Tablet)/.test(e),a=/(?:iPhone)/.test(e)&&!r;return{isTablet:r,isPhone:a,isAndroid:s,isPc:!a&&!s&&!n,isSymbian:n,isWindowsPhone:t,isFireFox:i}},get isLe(){return s}};t.default=i},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});const s=function(){const e=new ArrayBuffer(2);return new DataView(e).setInt16(0,256,!0),256===new Int16Array(e)[0]}();t.default=s},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});class s{static decode(e){const t=[],n=e;let i=0;const r=e.length;for(;i<r;)if(n[i]<128)t.push(String.fromCharCode(n[i])),++i;else{if(n[i]<192);else if(n[i]<224){if(s._checkContinuation(n,i,1)){const e=(31&n[i])<<6|63&n[i+1];if(e>=128){t.push(String.fromCharCode(65535&e)),i+=2;continue}}}else if(n[i]<240){if(s._checkContinuation(n,i,2)){const e=(15&n[i])<<12|(63&n[i+1])<<6|63&n[i+2];if(e>=2048&&55296!=(63488&e)){t.push(String.fromCharCode(65535&e)),i+=3;continue}}}else if(n[i]<248&&s._checkContinuation(n,i,3)){let e=(7&n[i])<<18|(63&n[i+1])<<12|(63&n[i+2])<<6|63&n[i+3];if(e>65536&&e<1114112){e-=65536,t.push(String.fromCharCode(e>>>10|55296)),t.push(String.fromCharCode(1023&e|56320)),i+=4;continue}}t.push(String.fromCharCode(65533)),++i}return t.join("")}static _checkContinuation(e,t,n){let s=e;if(t+n<s.length){for(;n--;)if(128!=(192&s[++t]))return!1;return!0}return!1}}t.default=s},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});class s{constructor(e){let t=s.getDefaultInf();if(!e||"[object Object]"!==Object.prototype.toString.call(e))return t;let n=Object.assign({},t,e);Object.entries(n).forEach(([e,t])=>{this[e]=t})}static getDefaultInf(){return{dts:null,pts:null,duration:null,position:null,isRAP:!1,originDts:null}}}t.default=s},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=class{constructor(){this.startDts=-1,this.endDts=-1,this.startPts=-1,this.endPts=-1,this.originStartDts=-1,this.originEndDts=-1,this.randomAccessPoints=[],this.firstSample=null,this.lastSample=null}addRAP(e){e.isRAP=!0,this.randomAccessPoints.push(e)}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=class{constructor(e){this._type=e,this._list=[],this._lastAppendLocation=-1}get type(){return this._type}get length(){return this._list.length}isEmpty(){return 0===this._list.length}clear(){this._list=[],this._lastAppendLocation=-1}_searchNearestSegmentBefore(e){let t=this._list;if(0===t.length)return-2;let n=t.length-1,s=0,i=0,r=n,a=0;if(e<t[0].originDts)return-1;for(;i<=r;){if((s=i+Math.floor((r-i)/2))===n||e>t[s].lastSample.originDts&&e<t[s+1].originDts){a=s;break}t[s].originDts<e?i=s+1:r=s-1}return a}_searchNearestSegmentAfter(e){return this._searchNearestSegmentBefore(e)+1}append(e){let t=this._list,n=this._lastAppendLocation,s=0;-1!==n&&n<t.length&&e.originStartDts>=t[n].lastSample.originDts&&(n===t.length-1||n<t.length-1&&e.originStartDts<t[n+1].originStartDts)?s=n+1:t.length>0&&(s=this._searchNearestSegmentBefore(e.originStartDts)+1),this._lastAppendLocation=s,this._list.splice(s,0,e)}getLastSegmentBefore(e){let t=this._searchNearestSegmentBefore(e);return t>=0?this._list[t]:null}getLastSampleBefore(e){let t=this.getLastSegmentBefore(e);return null!==t?t.lastSample:null}getLastRAPBefore(e){let t=this._searchNearestSegmentBefore(e),n=this._list[t].randomAccessPoints;for(;0===n.length&&t>0;)t--,n=this._list[t].randomAccessPoints;return n.length>0?n[n.length-1]:null}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});class s{constructor(e){this.configs=Object.assign({},e),this.container=this.configs.container,this.mediaSource=null,this.sourceBuffers={},this.preloadTime=this.configs.preloadTime||1,this.onSourceOpen=this.onSourceOpen.bind(this),this.onTimeUpdate=this.onTimeUpdate.bind(this),this.onUpdateEnd=this.onUpdateEnd.bind(this),this.onWaiting=this.onWaiting.bind(this)}init(){this.mediaSource=new self.MediaSource,this.mediaSource.addEventListener("sourceopen",this.onSourceOpen),this.container.src=URL.createObjectURL(this.mediaSource),this.url=this.container.src,this.container.addEventListener("timeupdate",this.onTimeUpdate),this.container.addEventListener("waiting",this.onWaiting)}onTimeUpdate(){this.emit("TIME_UPDATE",this.container)}onWaiting(){this.emit("WAITING",this.container)}onSourceOpen(){this.addSourceBuffers()}onUpdateEnd(){this.emit("SOURCE_UPDATE_END"),this.doAppend()}addSourceBuffers(){if("open"!==this.mediaSource.readyState)return;let e,t=this._context.getInstance("PRE_SOURCE_BUFFER"),n=this._context.getInstance("TRACKS");t=t.sources;let s=!1;for(let i=0,r=Object.keys(t).length;i<r;i++){let r=Object.keys(t)[i];if("audio"===r?e=n.audioTrack:"video"===r&&(e=n.videoTrack),e){let n="audio"===r?21:40;e.meta&&e.meta.refSampleDuration&&(n=e.meta.refSampleDuration),t[r].data.length>=this.preloadTime/n&&(s=!0)}}if(s){if(Object.keys(this.sourceBuffers).length>0)return;for(let e=0,n=Object.keys(t).length;e<n;e++){let n=Object.keys(t)[e],s=t[n],i="video"===n?"video/mp4;codecs="+s.mimetype:"audio/mp4;codecs="+s.mimetype,r=this.mediaSource.addSourceBuffer(i);this.sourceBuffers[n]=r,r.addEventListener("updateend",this.onUpdateEnd),this.doAppend()}}}doAppend(){let e=this._context.getInstance("PRE_SOURCE_BUFFER");if(e)for(let t=0;t<Object.keys(this.sourceBuffers).length;t++){let n=Object.keys(this.sourceBuffers)[t],s=this.sourceBuffers[n];if(!s.updating){let t=e.sources[n];if(t&&!t.inited)s.appendBuffer(t.init.buffer.buffer),t.inited=!0;else if(t){let e=t.data.shift();e&&s.appendBuffer(e.buffer.buffer)}}}}endOfStream(){const{readyState:e,activeSourceBuffers:t}=this.mediaSource;if("open"===e&&0===t.length)try{this.mediaSource.endOfStream()}catch(e){}}remove(e,t=0){for(let n=0;n<Object.keys(this.sourceBuffers).length;n++){let s=this.sourceBuffers[Object.keys(this.sourceBuffers)[n]];s.updating||s.remove(t,e)}}removeBuffers(){const e=[];for(let t=0;t<Object.keys(this.sourceBuffers).length;t++){let n,i=this.sourceBuffers[Object.keys(this.sourceBuffers)[t]];i.removeEventListener("updateend",this.onUpdateEnd),i.updating?n=new Promise(e=>{const t=function(){let n=3;const r=()=>{i.updating?n>0?(setTimeout(r,200),n--):e():(s.clearBuffer(i),e())};setTimeout(r,200),i.removeEventListener("updateend",t)};i.addEventListener("updateend",t)}):(s.clearBuffer(i),n=Promise.resolve()),e.push(n)}return Promise.all(e)}destroy(){return this.removeBuffers().then(()=>{for(let e=0;e<Object.keys(this.sourceBuffers).length;e++){let t=this.sourceBuffers[Object.keys(this.sourceBuffers)[e]];this.mediaSource.removeSourceBuffer(t),delete this.sourceBuffers[Object.keys(this.sourceBuffers)[e]]}this.container.removeEventListener("timeupdate",this.onTimeUpdate),this.container.removeEventListener("waiting",this.onWaiting),this.mediaSource.removeEventListener("sourceopen",this.onSourceOpen),this.endOfStream(),window.URL.revokeObjectURL(this.url),this.url=null,this.configs={},this.container=null,this.mediaSource=null,this.sourceBuffers={},this.preloadTime=1})}static clearBuffer(e){const t=e.buffered;let n=.1;for(let e=0,s=t.length;e<s;e++)n=t.end(e);try{e.remove(0,n)}catch(e){}}}t.default=s},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});class s{constructor(e){if(!(e instanceof ArrayBuffer))throw new Error("data is invalid");this.buffer=e,this.dataview=new DataView(e),this.dataview.position=0}get length(){return this.buffer.byteLength}set position(e){this.dataview.position=e}get position(){return this.dataview.position}back(e){this.position-=e}skip(e){let t=Math.floor(e/4),n=e%4;for(let e=0;e<t;e++)s.readByte(this.dataview,4);n>0&&s.readByte(this.dataview,n)}static readByte(e,t,n){let s;switch(t){case 1:s=n?e.getInt8(e.position):e.getUint8(e.position);break;case 2:s=n?e.getInt16(e.position):e.getUint16(e.position);break;case 3:if(n)throw new Error("not supported for readByte 3");s=e.getUint8(e.position)<<16,s|=e.getUint8(e.position+1)<<8,s|=e.getUint8(e.position+2);break;case 4:s=n?e.getInt32(e.position):e.getUint32(e.position);break;case 8:if(n)throw new Error("not supported for readBody 8");s=e.getUint32(e.position)<<32,s|=e.getUint32(e.position+4);break;default:s=""}return e.position+=t,s}readUint8(){return s.readByte(this.dataview,1)}readUint16(){return s.readByte(this.dataview,2)}readUint24(){return s.readByte(this.dataview,3)}readUint32(){return s.readByte(this.dataview,4)}readUint64(){return s.readByte(this.dataview,8)}readInt8(){return s.readByte(this.dataview,1,!0)}readInt16(){return s.readByte(this.dataview,2,!0)}readInt32(){return s.readByte(this.dataview,4,!0)}writeUint32(e){return new Uint8Array([e>>>24&255,e>>>16&255,e>>>8&255,255&e])}}t.default=s},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s,i=(s=n(25))&&s.__esModule?s:{default:s};t.default=class{constructor(e){this.buffer=e||new Uint8Array(0)}write(...e){e.forEach(e=>{this.buffer=(0,i.default)(Uint8Array,this.buffer,e)})}static writeUint32(e){return new Uint8Array([e>>24,e>>16&255,e>>8&255,255&e])}static readAsInt(e){let t="";return e.forEach(e=>{t+=function(e){return e.toString(16).padStart(2,"0")}(e)}),parseInt(t,16)}}},function(e,t,n){var s,i=(s=n(26))&&s.__esModule?s:{default:s};e.exports=i.default},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){for(var t=0,n=arguments.length,s=Array(n>1?n-1:0),i=1;i<n;i++)s[i-1]=arguments[i];var r=!0,a=!1,o=void 0;try{for(var l,d=s[Symbol.iterator]();!(r=(l=d.next()).done);r=!0){var u=l.value;t+=u.length}}catch(e){a=!0,o=e}finally{try{!r&&d.return&&d.return()}finally{if(a)throw o}}var f=new e(t),c=0,h=!0,p=!1,m=void 0;try{for(var _,g=s[Symbol.iterator]();!(h=(_=g.next()).done);h=!0){var x=_.value;f.set(x,c),c+=x.length}}catch(e){p=!0,m=e}finally{try{!h&&g.return&&g.return()}finally{if(p)throw m}}return f}},function(e,t,n){var s;Object.defineProperty(t,"__esModule",{value:!0});const i=((s=n(4))&&s.__esModule?s:{default:s}).default.CRYTO_EVENTS;t.default=class{constructor(e){this.inputBuffer=e.inputbuffer,this.outputBuffer=e.outputbuffer,this.key=e.key,this.iv=e.iv,this.method=e.method,this.crypto=window.crypto||window.msCrypto}init(){this.on(i.START_DECRYPT,this.decript.bind(this))}decript(){this.aeskey?this.decriptData():this.crypto.subtle.importKey("raw",this.key.buffer,{name:"AES-CBC"},!1,["encrypt","decrypt"]).then(e=>{this.aeskey=e,this.decriptData()})}decriptData(){let e=this._context.getInstance(this.inputBuffer),t=this._context.getInstance(this.outputBuffer),n=e.shift();n&&this.crypto.subtle.decrypt({name:"AES-CBC",iv:this.iv.buffer},this.aeskey,n).then(e=>{t.push(new Uint8Array(e)),this.emit(i.DECRYPTED),this.decriptData(n)})}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s=u(n(29)),i=u(n(36)),r=n(39),a=n(9),o=n(0),l=n(7),d=u(n(2));function u(e){return e&&e.__esModule?e:{default:e}}const f=o.EVENTS.REMUX_EVENTS,c=o.EVENTS.DEMUX_EVENTS,h=o.EVENTS.LOADER_EVENTS,p="FLVController";class m{warn(){}}const _="FLV_ERROR";class g{constructor(e){this.TAG=p,this._player=e,this.state={initSegmentArrived:!1,range:{start:0,end:""},rangeSupport:!0}}static findFilePosition(e,t){for(let n=0,s=t.times.length;n<s;n++){const i=t.times[n],r=n+1<s?t.times[n+1]:Number.MAX_SAFE_INTEGER;if(i<=e&&e<=r)return t.filepositions[n]}return""}init(){this._context.registry("FETCH_LOADER",r.FetchLoader),this._context.registry("LOADER_BUFFER",a.XgBuffer),this._context.registry("FLV_DEMUXER",s.default),this._context.registry("TRACKS",a.Tracks),this._context.registry("MP4_REMUXER",i.default.Mp4Remuxer),this._context.registry("PRE_SOURCE_BUFFER",a.PreSource),this._context.registry("COMPATIBILITY",l.Compatibility),this._context.registry("LOGGER",m),this.mse=this._context.registry("MSE",o.Mse)({container:this._player.video}),this.initListeners(),setTimeout(()=>{this.loadMeta()},0)}initListeners(){this.on(h.LOADER_DATALOADED,this._handleLoaderDataLoaded.bind(this)),this.on(h.LOADER_ERROR,this._handleNetworkError.bind(this)),this.on(c.MEDIA_INFO,this._handleMediaInfo.bind(this)),this.on(c.METADATA_PARSED,this._handleMetadataParsed.bind(this)),this.on(c.DEMUX_COMPLETE,this._handleDemuxComplete.bind(this)),this.on(c.DEMUX_ERROR,this._handleDemuxError.bind(this)),this.on(f.INIT_SEGMENT,this._handleAppendInitSegment.bind(this)),this.on(f.MEDIA_SEGMENT,this._handleMediaSegment.bind(this))}_handleMediaInfo(){this._context.onMetaData||this.emit(c.DEMUX_ERROR,new Error("failed to get mediainfo"));const e=this._context.getInstance("LOADER_BUFFER"),t=this._context.getInstance("FETCH_LOADER");this.isSeekable&&(t.cancel(),this.state.range={start:0,end:e.historyLen-1},setTimeout(()=>{this.loadNext(0)}))}_handleLoaderDataLoaded(){this.emitTo("FLV_DEMUXER",c.DEMUX_START)}_handleMetadataParsed(e){this.emit(f.REMUX_METADATA,e)}_handleDemuxComplete(){this.emit(f.REMUX_MEDIA)}_handleAppendInitSegment(){this.state.initSegmentArrived=!0,this.mse.addSourceBuffers()}_handleMediaSegment(){this.mse.addSourceBuffers(),this.mse.doAppend()}_handleNetworkError(e,t){this._player.emit("error",new d.default.Errors("network",this._player.config.url)),this._onError(h.LOADER_ERROR,e,t,!0)}_handleDemuxError(e,t,n){void 0===n&&(n=!1),this._player.emit("error",new d.default.Errors("parse",this._player.config.url)),this._onError(h.LOADER_ERROR,e,t,n)}_onError(e,t,n,s){let i={errorType:e,errorDetails:`[${t}]: ${n.message}`,errorFatal:s||!1};this._player.emit(_,i)}seek(e){if(!this._context.onMetaData)return void this.loadMeta();if(!this.isSeekable)return;this._context.getInstance("LOADER_BUFFER").clear();const{preloadTime:t=15}=this._player.config,n=this.getSeekRange(e,t);this.state.range=n,this.compat&&this.compat.reset(),this.loadData()}loadNext(e){this._context.onMetaData&&(this.loader.loading||this.getNextRange(e)&&this.loadData())}loadData(){const{start:e,end:t}=this.state.range;this.emit(h.LADER_START,this._player.config.url,{headers:{method:"get",Range:`bytes=${e}-${t}`}})}loadMeta(){this.loader.load(this._player.config.url,{headers:{Range:"bytes=0-"}}).catch(()=>{this.state.rangeSupport=!1,this.loadFallback()})}loadFallback(){this.loader.load(this._player.config.url).catch(()=>{this._player.emit("error",new d.default.Errors("network",this._player.config.url))})}getSeekRange(e,t){const{keyframes:n}=this._context.onMetaData,s=this._context.mediaInfo.duration,i=e,r=e+t,a=g.findFilePosition(i,n);return r>=s||i>=s?{start:a,end:""}:{start:a,end:g.findFilePosition(r,n)}}getNextRange(e){if(""===this.state.range.end)return;const{end:t}=this.getSeekRange(e,this.config.preloadTime||15);return t<=this.state.range.end&&""!==t?void 0:(this.state.range={start:this.state.range.end+1,end:t},!0)}destroy(){this._player=null,this.mse=null,this.state={initSegmentArrived:!1,range:{start:0,end:""},rangeSupport:!0}}get isSeekable(){return!!this.state.rangeSupport&&(!this._context||!this._context.mediaInfo.isComplete()||null!==this._context.mediaInfo.keyframes&&void 0!==this._context.mediaInfo.keyframes)}get config(){return this._player.config}get loader(){return this._context.getInstance("FETCH_LOADER")}get compat(){return this._context.getInstance("COMPATIBILITY")}}t.default=g},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s,i=n(0),r=n(7),a=n(9),o=(s=n(35))&&s.__esModule?s:{default:s};const l=i.EVENTS.DEMUX_EVENTS;class d{constructor(){this._firstFragmentLoaded=!1,this._trackNum=0,this._hasScript=!1}init(){this.on(l.DEMUX_START,this.doParseFlv.bind(this))}static isFlvFile(e){return!(70!==e[0]||76!==e[1]||86!==e[2]||1!==e[3])}static getPlayType(e){const t={hasVideo:!1,hasAudio:!1};return!0&e&&(t.hasVideo=!0),!0&e&&(t.hasAudio=!0),t}doParseFlv(){if(this._firstFragmentLoaded){if(this.loaderBuffer.length<11)return;let e,t=1e5;do{e=this._parseFlvTag()}while(e&&t-- >0);this.emit(l.DEMUX_COMPLETE)}else{if(this.loaderBuffer.length<13)return;const e=this.loaderBuffer.shift(13);this.parseFlvHeader(e),this.doParseFlv()}}parseFlvHeader(e){if(d.isFlvFile(e)){this._firstFragmentLoaded=!0;const t=d.getPlayType(e[4]);t.hasVideo&&this.initVideoTrack(),t.hasAudio&&this.initAudioTrack()}else this.emit(l.DEMUX_ERROR,new Error("invalid flv file")),this.doParseFlv();this.doParseFlv()}initVideoTrack(){this._trackNum++;let e=new a.VideoTrack;e.meta=new i.VideoTrackMeta,e.id=e.meta.id=this._trackNum,this.tracks.videoTrack=e}initAudioTrack(){this._trackNum++;let e=new a.AudioTrack;e.meta=new i.AudioTrackMeta,e.id=e.meta.id=this._trackNum,this.tracks.audioTrack=e}_parseFlvTag(){if(this.loaderBuffer.length<11)return null;let e=this._parseFlvTagHeader();return e&&this._processChunk(e),e}_parseFlvTagHeader(){let e=0,t={},n=this.loaderBuffer.toInt(e,1);if(e+=1,t.filtered=(32&n)>>>5,t.tagType=31&n,t.datasize=this.loaderBuffer.toInt(e,3),e+=3,8!==t.tagType&&9!==t.tagType&&11!==t.tagType&&18!==t.tagType||0!==this.loaderBuffer.toInt(8,3))return this.loaderBuffer&&this.loaderBuffer.length>0&&this.loaderBuffer.shift(1),this.emit(l.DEMUX_ERROR,this.TAG,new Error("tagType "+t.tagType),!1),null;if(this.loaderBuffer.length<t.datasize+15)return null;this.loaderBuffer.shift(4);let s=this.loaderBuffer.toInt(0,3);this.loaderBuffer.shift(3);let i=this.loaderBuffer.shift(1)[0];return i>0&&(s+=16777216*i),t.dts=s,this.loaderBuffer.shift(3),t}_processChunk(e){switch(e.tagType){case 18:this._parseScriptData(e);break;case 8:this._parseAACData(e);break;case 9:this._parseHevcData(e);break;case 11:this.loaderBuffer.shift(3);break;default:this.loaderBuffer.shift(1)}}_parseScriptData(e){let t=this.tracks.audioTrack,n=this.tracks.videoTrack,s=this.loaderBuffer.shift(e.datasize);const i=(new o.default).resolve(s,s.length),r=this._context.onMetaData=i?i.onMetaData:void 0;if(this._context.mediaInfo.duration=r.duration,this._context.mediaInfo.hasVideo=r.hasVideo,this._context.mediaInfo.hsaAudio=r.hasAudio,this._datasizeValidator(e.datasize)&&(this.emit(l.MEDIA_INFO),this._hasScript=!0),t&&!t.hasSpecificConfig){let e=t.meta;switch(r.audiosamplerate&&(e.sampleRate=r.audiosamplerate),r.audiochannels&&(e.channelCount=r.audiochannels),r.audiosamplerate){case 44100:e.sampleRateIndex=4;break;case 22050:e.sampleRateIndex=7;break;case 11025:e.sampleRateIndex=10}}if(n&&!n.hasSpecificConfig){let e=n.meta;if("number"==typeof r.framerate){let t=Math.floor(1e3*r.framerate);if(t>0){let n=t/1e3;e.frameRate||(e.frameRate={}),e.frameRate.fixed=!0,e.frameRate.fps=n,e.frameRate.fps_num=t,e.frameRate.fps_den=1e3}}}}_aacSequenceHeaderParser(e){let t={hasSpecificConfig:!0};t.objectType=e[1]>>>3,t.sampleRateIndex=(7&e[1])<<1|e[2]>>>7,t.audiosamplerate=this._switchAudioSampleRate(t.sampleRateIndex),t.channelCount=(120&e[2])>>>3,t.frameLength=(4&e[2])>>>2,t.dependsOnCoreCoder=(2&e[2])>>>1,t.extensionFlagIndex=1&e[2],t.codec=`mp4a.40.${t.objectType}`;let n,s,i=window.navigator.userAgent.toLowerCase(),r=t.sampleRateIndex;return-1!==i.indexOf("firefox")?t.sampleRateIndex>=6?(t.objectType=5,s=new Array(4),n=r-3):(t.objectType=2,s=new Array(2),n=r):-1!==i.indexOf("android")?(t.objectType=2,s=new Array(2),n=r):(t.objectType=5,n=t.sampleRateIndex,s=new Array(4),t.sampleRateIndex>=6?n=t.sampleRateIndex-3:1===t.channelCount&&(t.objectType=2,s=new Array(2),n=t.sampleRateIndex)),s[0]=t.objectType<<3,s[0]|=(15&t.sampleRateIndex)>>>1,s[1]=(15&t.sampleRateIndex)<<7,s[1]|=(15&t.channelCount)<<3,5===t.objectType&&(s[1]|=(15&n)>>>1,s[2]=(1&n)<<7,s[2]|=8,s[3]=0),t.config=s,t}_parseAACData(e){let t=this.tracks.audioTrack;if(!t)return;let n=t.meta;n||(t.meta=new i.AudioTrackMeta,n=t.meta);let s=this.loaderBuffer.shift(1)[0];e.data=this.loaderBuffer.shift(e.datasize-1);let r=(240&s)>>>4;t.format=r,10!==r&&this.emit(l.DEMUX_ERROR,new Error(`invalid audio format: ${r}`)),10!==r||this._hasAudioSequence||(n.sampleRate=this._switchAudioSamplingFrequency(s),n.sampleRateIndex=(12&s)>>>2,n.frameLenth=(2&s)>>>1,n.channelCount=1&s,n.refSampleDuration=Math.floor(1024/n.audioSampleRate*n.timescale));let a=n.audioSampleRate,o=n.sampleRateIndex,d=n.refSampleDuration;delete e.tagType;let u=this._datasizeValidator(e.datasize);if(0===e.data[0]){let t=this._aacSequenceHeaderParser(e.data);a=t.audiosamplerate||n.audioSampleRate,o=t.sampleRateIndex||n.sampleRateIndex,d=Math.floor(1024/a*n.timescale),n.channelCount=t.channelCount,n.sampleRate=a,n.sampleRateIndex=o,n.refSampleDuration=d,n.duration=this._context.mediaInfo.duration*n.timescale,n.config=t.config;const s=this._context.mediaInfo.audio;s.codec=t.codec,s.channelCount=t.channelCount,s.sampleRate=a,s.sampleRateIndex=t.audioSampleRateIndex,this._hasScript&&!this._hasAudioSequence?this.emit(l.METADATA_PARSED,"audio"):this._hasScript&&this._hasAudioSequence&&this.emit(l.AUDIO_METADATA_CHANGE),this._hasAudioSequence=!0,this._metaChange=!0}else this._metaChange&&(e.options={meta:t.meta},this._metaChange=!1),e.data=e.data.slice(1,e.data.length),t.samples.push(e);u||this.emit(l.DEMUX_ERROR,this.TAG,new Error("TAG length error at "+e.datasize),!1)}_parseHevcData(e){let t=this.loaderBuffer.shift(1)[0];e.frameType=(240&t)>>>4,e.isKeyframe=1===e.frameType;let n=15&t;if(this.tracks.videoTrack.codecID=n,e.avcPacketType=this.loaderBuffer.shift(1)[0],e.cts=this.loaderBuffer.toInt(0,3),this.loaderBuffer.shift(3),12===n){const t=this.loaderBuffer.shift(e.datasize-5);if(e.data=t,0!==Number.parseInt(e.avcPacketType)){this._datasizeValidator(e.datasize)||this.emit(l.DEMUX_ERROR,this.TAG,new Error(`invalid video tag datasize: ${e.datasize}`),!1);let t={},n=0;for(t.cts=e.cts,t.dts=e.dts;e.data.length>n;){let s=e.data.slice(Number.parseInt(n),4+n);t.size=s[3],t.size+=256*s[2],t.size+=256*s[1]*256,t.size+=256*s[0]*256*256,n+=4,t.data=e.data.slice(Number.parseInt(n),t.size+n),n+=t.size,this.tracks.videoTrack.samples.push(t),this.emit(l.METADATA_PARSED,"video")}}else 0===Number.parseInt(e.avcPacketType)&&(this._datasizeValidator(e.datasize)?this.emit(l.METADATA_PARSED,"video"):this.emit(l.DEMUX_ERROR,this.TAG,new Error(`invalid video tag datasize: ${e.datasize}`),!1))}else if(7===n){let t=this.loaderBuffer.shift(e.datasize-5);if(0===t[4]&&0===t[5]&&0===t[6]&&1===t[7]){let e=0;for(let n=0;n<4;n++)e=256*e+t[n];e-=4,(t=t.slice(4,t.length))[3]=e%256,e=(e-t[3])/256,t[2]=e%256,e=(e-t[2])/256,t[1]=e%256,t[0]=(e-t[1])/256}if(e.data=t,0===e.avcPacketType)this._avcSequenceHeaderParser(e.data),this._datasizeValidator(e.datasize)&&(this._hasScript&&!this._hasVideoSequence?this.emit(l.METADATA_PARSED,"video"):this._hasScript&&this._hasVideoSequence&&this.emit(l.VIDEO_METADATA_CHANGE),this._hasVideoSequence=!0),this._metaChange=!0;else{if(!this._datasizeValidator(e.datasize))return void this.emit(l.DEMUX_ERROR,this.TAG,new Error(`invalid video tag datasize: ${e.datasize}`),!1);this._metaChange&&(e.options={meta:Object.assign({},this.tracks.videoTrack.meta)},this._metaChange=!1),this.tracks.videoTrack.samples.push(e)}}else this.emit(l.DEMUX_ERROR,this.TAG,new Error(`video codeid is ${n}`),!1),e.data=this.loaderBuffer.shift(e.datasize-1),this._datasizeValidator(e.datasize)||this.emit(l.DEMUX_ERROR,this.TAG,new Error(`invalid video tag datasize: ${e.datasize}`),!1),this.tracks.videoTrack.samples.push(e),this.emit(l.DEMUX_COMPLETE);delete e.tagType}_avcSequenceHeaderParser(e){let t=this.tracks.videoTrack;if(!t)return;let n=0;t.meta||(t.meta=new i.VideoTrackMeta);let s=t.meta;s.configurationVersion=e[0],s.avcProfileIndication=e[1],s.profileCompatibility=e[2],s.avcLevelIndication=e[3]/10,s.nalUnitLength=1+(3&e[4]);let a=31&e[5];n=6;let o={};for(let t=0;t<a;t++){let t=255*e[n]+e[n+1];n+=2;let i=new Uint8Array(t);for(let s=0;s<t;s++)i[s]=e[n+s];let a="avc1.";for(let e=1;e<4;e++){let t=i[e].toString(16);t.length<2&&(t="0"+t),a+=t}s.codec=a,n+=t,this.tracks.videoTrack.meta.sps=i,o=r.SpsParser.parseSPS(i)}let l=e[n];n++;for(let t=0;t<l;t++){let t=255*e[n]+e[n+1];n+=2;let s=new Uint8Array(t);for(let i=0;i<t;i++)s[i]=e[n+i];n+=t,this.tracks.videoTrack.meta.pps=s}Object.assign(s,r.SpsParser.toVideoMeta(o));const d=this._context.mediaInfo.video;d.codec=s.codec,d.profile=s.profile,d.level=s.level,d.chromaFormat=s.chromaFormat,d.frameRate=s.frameRate,d.parRatio=s.parRatio,d.width=d.width===s.presentWidth?d.width:s.presentWidth,d.height=d.height===s.presentHeight?d.width:s.presentHeight,s.duration=this._context.mediaInfo.duration*s.timescale,s.avcc=new Uint8Array(e.length),s.avcc.set(e),t.meta=s}_switchAudioSampleRate(e){return[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350][e]}_switchAudioSamplingFrequency(e){return[5500,11025,22050,44100,48e3][(12&e)>>>2]}_switchAudioChannel(e){return[1,2][1&e]}_datasizeValidator(e){let t=this.loaderBuffer.toInt(0,4);return this.loaderBuffer.shift(4),t===e+11}get loaderBuffer(){const e=this._context.getInstance("LOADER_BUFFER");if(e)return e;this.emit(l.DEMUX_ERROR,new Error("找不到 loaderBuffer 实例"))}get tracks(){return this._context.getInstance("TRACKS")}get logger(){return this._context.getInstance("LOGGER")}}t.default=d},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s,i=(s=n(8))&&s.__esModule?s:{default:s};class r{static getNalunits(e){if(e.length-e.position<4)return[];let t=e.dataview,n=e.position;return 1===t.getInt32(n)||0===t.getInt16(n)&&1===t.getInt8(n+2)?r.getAnnexbNals(e):r.getAvccNals(e)}static getAnnexbNals(e){let t=[],n=r.getHeaderPositionAnnexB(e),s=n.pos,i=s;for(;s<e.length-4;){let a=e.buffer.slice(s,s+n.headerLength);n.pos===e.position&&e.skip(n.headerLength),i=(n=r.getHeaderPositionAnnexB(e)).pos;let o={header:a,body:new Uint8Array(e.buffer.slice(s+a.byteLength,i))};r.analyseNal(o),t.push(o),e.skip(i-e.position),s=i}return t}static getAvccNals(e){let t=[];for(;e.position<e.length-4;){let n=e.dataview.getInt32();if(!(e.length-e.position>=n))break;{let s=e.buffer.slice(e.position,e.position+4);e.skip(4);let i=e.buffer.slice(e.position,e.position+n);e.skip(n);let a={header:s,body:i};r.analyseNal(a),t.push(a)}}return t}static analyseNal(e){switch(31&e.body[0]){case 1:e.ndr=!0;break;case 5:e.idr=!0;break;case 6:break;case 7:e.sps=i.default.parseSPS(e.body);break;case 8:e.pps=!0}}static getHeaderPositionAnnexB(e){let t=e.position,n=0;for(;3!==n&&4!==n&&t<e.length-4;)0===e.dataview.getInt16(t)?1===e.dataview.getInt16(t+2)?n=4:1===e.dataview.getInt8(t+2)?n=3:t++:t++;return t===e.length-4&&(0===e.dataview.getInt16(t)?1===e.dataview.getInt16(t+2)&&(n=4):(t++,0===e.dataview.getInt16(t)&&1===e.dataview.getInt8(t)?n=3:t=e.length)),{pos:t,headerLength:n}}static getAvcc(e,t){let n=new Uint8Array(e.byteLength+t.byteLength+11);n[0]=1,n[1]=e[1],n[2]=e[2],n[3]=e[3],n[4]=255,n[5]=225;let s=6;return n.set(new Uint8Array([e.byteLength>>>8&255,255&e.byteLength]),s),s+=2,n.set(e,s),n[s+=e.byteLength]=1,s++,n.set(new Uint8Array([t.byteLength>>>8&255,255&t.byteLength]),s),s+=2,n.set(t,s),n}}t.default=r},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=class{constructor(e){this.TAG="Golomb",this._buffer=e,this._bufferIndex=0,this._totalBytes=e.byteLength,this._totalBits=8*e.byteLength,this._currentWord=0,this._currentWordBitsLeft=0}destroy(){this._buffer=null}_fillCurrentWord(){let e=this._totalBytes-this._bufferIndex,t=Math.min(4,e),n=new Uint8Array(4);n.set(this._buffer.subarray(this._bufferIndex,this._bufferIndex+t)),this._currentWord=new DataView(n.buffer).getUint32(0),this._bufferIndex+=t,this._currentWordBitsLeft=8*t}readBits(e){let t=Math.min(this._currentWordBitsLeft,e),n=this._currentWord>>>32-t;if(e>32)throw new Error("Cannot read more than 32 bits at a time");return this._currentWordBitsLeft-=t,this._currentWordBitsLeft>0?this._currentWord<<=t:this._totalBytes-this._bufferIndex>0&&this._fillCurrentWord(),(t=e-t)>0&&this._currentWordBitsLeft?n<<t|this.readBits(t):n}readBool(){return 1===this.readBits(1)}readByte(){return this.readBits(8)}_skipLeadingZero(){let e;for(e=0;e<this._currentWordBitsLeft;e++)if(0!=(this._currentWord&2147483648>>>e))return this._currentWord<<=e,this._currentWordBitsLeft-=e,e;return this._fillCurrentWord(),e+this._skipLeadingZero()}readUEG(){let e=this._skipLeadingZero();return this.readBits(e+1)-1}readSEG(){let e=this.readUEG();return 1&e?e+1>>>1:-1*(e>>>1)}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s,i=n(0),r=(s=n(33))&&s.__esModule?s:{default:s};const{REMUX_EVENTS:a,DEMUX_EVENTS:o}=i.EVENTS;class l{constructor(){this.nextAudioDts=0,this.nextVideoDts=0,this.lastAudioSamplesLen=0,this.lastVideoSamplesLen=0,this.lastVideoDts=void 0,this.lastAudioDts=void 0,this.allAudioSamplesCount=0,this.allVideoSamplesCount=0,this._firstAudioSample=null,this._firstVideoSample=null,this.filledAudioSamples=[],this.filledVideoSamples=[],this._videoLargeGap=0,this._audioLargeGap=0}init(){this.before(a.REMUX_MEDIA,this.doFix.bind(this))}reset(){this.nextAudioDts=null,this.nextVideoDts=null,this.lastAudioSamplesLen=0,this.lastVideoSamplesLen=0,this.lastVideoDts=void 0,this.lastAudioDts=void 0,this.filledAudioSamples=[],this.filledVideoSamples=[]}doFix(){const{isFirstAudioSamples:e,isFirstVideoSamples:t}=this.getFirstSample();this.recordSamplesCount(),this._firstVideoSample&&this.fixRefSampleDuration(this.videoTrack.meta,this.videoTrack.samples),this._firstAudioSample&&this.fixRefSampleDuration(this.audioTrack.meta,this.audioTrack.samples);const{changed:n,changedIdx:s}=l.detactChangeStream(this.videoTrack.samples);n&&!e?this.fixChangeStreamVideo(s):this.doFixVideo(t);const{changed:i,changedIdx:r}=l.detactChangeStream(this.audioTrack.samples);i?this.fixChangeStreamAudio(r):this.doFixAudio(e)}doFixVideo(e,t){let{samples:n,meta:s}=this.videoTrack;if(s.frameRate&&!1===s.frameRate.fixed)return;if(!n||!n.length||!this._firstVideoSample)return;const i=n[0],r=n.length;this._videoLargeGap>0&&l.doFixLargeGap(n,this._videoLargeGap),i.dts!==this._firstVideoSample.dts&&(t||l.detectLargeGap(this.nextVideoDts,i))&&(t&&(this.nextVideoDts=t),this._videoLargeGap=this.nextVideoDts-i.dts,l.doFixLargeGap(n,this._videoLargeGap));const a=i.dts;if(e&&this._firstAudioSample){const e=this._firstVideoSample.dts,t=e-this._firstAudioSample.dts;if(t>2*s.refSampleDuration){const r=Math.floor(t/s.refSampleDuration);for(let t=0;t<r;t++){const r=Object.assign({},i);r.dts=e-(t+1)*s.refSampleDuration,r.pts=r.dts+r.cts,n.unshift(r),this.filledVideoSamples.push({dts:r.dts,size:r.data.byteLength})}}}let o;if(this.nextVideoDts){o=a-this.nextVideoDts;const e=Math.abs(o);if(o>2*s.refSampleDuration){const e=Math.floor(o/s.refSampleDuration);for(let t=0;t<e;t++){const e=Object.assign({},n[0]),i=a-(t+1)*s.refSampleDuration;e.dts=i>this.nextVideoDts?i:this.nextVideoDts,e.pts=e.dts+e.cts,this.videoTrack.samples.unshift(e),this.filledVideoSamples.push({dts:e.dts,size:e.data.byteLength})}}else e<=s.refSampleDuration&&e>0?(n[0].dts=this.nextVideoDts,n[0].originDts=n[0].dts,n[0].cts=void 0!==n[0].cts?n[0].cts:n[0].pts-n[0].dts,n[0].pts=n[0].dts+n[0].cts):o<0&&l.doFixLargeGap(n,-1*o)}const d=n[n.length-1].dts,u=n.length>=2?d-n[n.length-2].dts:s.refSampleDuration;this.lastVideoSamplesLen=r,this.nextVideoDts=d+u,this.lastVideoDts=d;for(let e=0,t=n.length;e<t;e++){const t=n[e],i=n[e+1];if(!i)break;const r=i.dts-t.dts;if(r>2*s.refSampleDuration){let a=Math.floor(r/s.refSampleDuration),o=0;for(;o<a;){const r=Object.assign({},i);r.dts=t.dts+(o+1)*s.refSampleDuration,r.pts=r.dts+r.cts,r<i.dts&&(n.splice(e,0,r),this.filledVideoSamples.push({dts:r.dts,size:r.data.byteLength})),o++,e++}}}this.videoTrack.samples=n}doFixAudio(e,t){let{samples:n,meta:s}=this.audioTrack;if(!n||!n.length)return;const i=n.length,a=r.default.getSilentFrame(s.codec,s.channelCount),o=this._firstAudioSample,d=n[0];if(this._audioLargeGap>0&&l.doFixLargeGap(n,this._audioLargeGap),d.dts!==this._firstAudioSample.dts&&(t||l.detectLargeGap(this.nextAudioDts,d))&&(t&&(this.nextAudioDts=t),this._audioLargeGap=this.nextAudioDts-d.dts,l.doFixLargeGap(n,this._audioLargeGap)),this._firstVideoSample&&e){const e=this._firstVideoSample.pts?this._firstVideoSample.pts:this._firstVideoSample.dts+this._firstVideoSample.cts;if(o.dts-e>s.refSampleDuration){const t=Math.floor((o.dts-e)/s.refSampleDuration);for(let e=0;e<t;e++){const t={data:a,datasize:a.byteLength,dts:o.dts-(e+1)*s.refSampleDuration,filtered:0};n.unshift(t),this.filledAudioSamples.push({dts:t.dts,size:t.data.byteLength})}}}let u;const f=n[0].dts;if(this.nextAudioDts){u=f-this.nextAudioDts;const e=Math.abs(u);if(e>s.refSampleDuration&&1===i&&1===this.lastAudioSamplesLen&&(s.refSampleDurationFixed=void 0),u>2*s.refSampleDuration)if(1===i&&1===this.lastAudioSamplesLen)s.refSampleDurationFixed=void 0!==s.refSampleDurationFixed?s.refSampleDurationFixed+u:s.refSampleDuration+u;else{const e=Math.floor(u/s.refSampleDuration);for(let t=0;t<e;t++){const e=f-(t+1)*s.refSampleDuration,i=Object.assign({},n[0],{dts:e>this.nextAudioDts?e:this.nextAudioDts});this.filledAudioSamples.push({dts:i.dts,size:i.data.byteLength}),this.audioTrack.samples.unshift(i)}}else e<=s.refSampleDuration&&e>0?(n[0].dts=this.nextAudioDts,n[0].pts=this.nextAudioDts):u<0&&l.doFixLargeGap(n,-1*u)}const c=n[n.length-1].dts,h=n.length>=2?c-n[n.length-2].dts:s.refSampleDuration;this.lastAudioSamplesLen=i,this.nextAudioDts=s.refSampleDurationFixed?c+s.refSampleDurationFixed:c+h,this.lastAudioDts=c;for(let e=0,t=n.length;e<t;e++){const t=n[e],s=n[e+1];if(!s)break;const i=s.dts-t.dts;n[e].duration=i}this.audioTrack.samples=l.sortAudioSamples(n)}fixChangeStreamVideo(e){const{samples:t,meta:n}=this.videoTrack,s=0===e?this.getStreamChangeStart(t[0]):t[e-1].dts,i=t[e].dts;if(Math.abs(s-i)<=2*n.refSampleDuration)return t[e].options?t[e].options.isContinue=!0:t[e].options={isContinue:!0},this.doFixVideo(!1);const r=t.slice(0,e),a=t.slice(e),o=t[0],l=a[0].dts-o.dts,d=o.options&&o.options.start+l?o.options.start:null;this.videoTrack.samples=t.slice(0,e),this.doFixVideo(!1),this.videoTrack.samples=t.slice(e),this.doFixVideo(!1,d),this.videoTrack.samples=r.concat(a)}fixChangeStreamAudio(e){const{samples:t,meta:n}=this.audioTrack,s=0===e?this.getStreamChangeStart(t[0]):t[e-1].dts,i=t[e].dts;if(Math.abs(s-i)<=2*n.refSampleDuration)return t[e].options?t[e].options.isContinue=!0:t[e].options={isContinue:!0},this.doFixAudio(!1);const r=t.slice(0,e),a=t.slice(e),o=t[0],l=a[0].dts-o.dts,d=o.options&&o.options.start+l?o.options.start:null;this.audioTrack.samples=r,this.doFixAudio(!1),this.audioTrack.samples=a,this.doFixAudio(!1,d),this.audioTrack.samples=r.concat(a)}getFirstSample(){let{samples:e}=this.videoTrack,{samples:t}=this.audioTrack,n=!1,s=!1;return!this._firstVideoSample&&e.length&&(this._firstVideoSample=l.findFirstVideoSample(e),n=!0),!this._firstAudioSample&&t.length&&(this._firstAudioSample=l.findFirstAudioSample(t),s=!0),{isFirstVideoSamples:n,isFirstAudioSamples:s}}fixRefSampleDuration(e,t){const n="video"===e.type,s=n?this.allVideoSamplesCount:this.allAudioSamplesCount,i=n?this._firstVideoSample.dts:this._firstAudioSample.dts,r=n?this.filledVideoSamples.length:this.filledAudioSamples.length;if(!e.refSampleDuration||e.refSampleDuration<=0||Number.isNaN(e.refSampleDuration)){if(t.length>=1){const n=t[t.length-1].dts;e.refSampleDuration=Math.floor((n-i)/(s+r-1))}}else if(e.refSampleDuration&&t.length>=5){const n=(t[t.length-1].dts-t[0].dts)/(t.length-1);e.refSampleDuration=Math.floor(Math.abs(e.refSampleDuration-n)<=5?e.refSampleDuration:n)}}recordSamplesCount(){const{audioTrack:e,videoTrack:t}=this;this.allAudioSamplesCount+=e.samples.length,this.allVideoSamplesCount+=t.samples.length}removeInvalidSamples(){const{_firstVideoSample:e,_firstAudioSample:t}=this;this.audioTrack.samples=this.audioTrack.samples.filter(e=>e.dts>=t.dts&&(void 0===this.lastAudioDts||e.dts>this.lastAudioDts)),this.videoTrack.samples=this.videoTrack.samples.filter(t=>t.dts>=e.dts&&(void 0===this.lastVideoDts||t.dts>this.lastVideoDts))}getStreamChangeStart(e){return e.options&&e.options.start?e.options.start-this.dtsBase:1/0}static sortAudioSamples(e){return 1===e.length?e:e.sort((e,t)=>e.dts-t.dts)}static findFirstAudioSample(e){return e&&0!==e.length?l.sortAudioSamples(e)[0]:null}static findFirstVideoSample(e){if(!e.length)return null;const t=e.sort((e,t)=>e.dts-t.dts);for(let e=0,n=t.length;e<n;e++)if(t[e].isKeyframe)return t[e]}static detectLargeGap(e,t){if(null===e)return;const n=t.dts||0,s=e-n>=1e3||n-e>=1e3,i=t.options&&t.options.discontinue;return s||i}static doFixLargeGap(e,t){console.log("fix large gap");for(let n=0,s=e.length;n<s;n++){const s=e[n];s.dts+=t,s.pts&&(s.pts+=t)}}static detactChangeStream(e){let t=!1,n=-1;for(let s=0,i=e.length;s<i;s++)if(e[s].options&&e[s].options.meta){t=!0,n=s;break}return{changed:t,changedIdx:n}}get tracks(){return this._context.getInstance("TRACKS")}get audioTrack(){return this.tracks?this.tracks.audioTrack:null}get videoTrack(){return this.tracks?this.tracks.videoTrack:null}get dtsBase(){const e=this._context.getInstance("MP4_REMUXER");return e?e._dtsBase:0}}t.default=l},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.default=class{static getSilentFrame(e,t){if("mp4a.40.2"===e){if(1===t)return new Uint8Array([0,200,0,128,35,128]);if(2===t)return new Uint8Array([33,0,73,144,2,25,0,35,128]);if(3===t)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,142]);if(4===t)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,128,44,128,8,2,56]);if(5===t)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,130,48,4,153,0,33,144,2,56]);if(6===t)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,130,48,4,153,0,33,144,2,0,178,0,32,8,224])}else{if(1===t)return new Uint8Array([1,64,34,128,163,78,230,128,186,8,0,0,0,28,6,241,193,10,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,94]);if(2===t)return new Uint8Array([1,64,34,128,163,94,230,128,186,8,0,0,0,0,149,0,6,241,161,10,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,94]);if(3===t)return new Uint8Array([1,64,34,128,163,94,230,128,186,8,0,0,0,0,149,0,6,241,161,10,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,94])}return null}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});class s{constructor(){this.mimetype="",this.init=null,this.data=[]}}t.default=class{constructor(){this.sources={}}getSource(e){return this.sources[e]}createSource(e){return this.sources[e]=new s,this.sources[e]}clear(){this.sources={}}destroy(){this.sources={}}}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s=n(0);const i={NUMBER:0,BOOLEAN:1,STRING:2,OBJECT:3,MIX_ARRAY:8,OBJECT_END:9,STRICT_ARRAY:10,DATE:11,LONE_STRING:12};t.default=class{constructor(){this.offset=0,this.readOffset=this.offset}resolve(e,t){if(t<3)throw new Error("not enough data for metainfo");const n={},s=this.parseValue(e),i=this.parseValue(e,t-s.bodySize);return n[s.data]=i.data,this.resetStatus(),n}resetStatus(){this.offset=0,this.readOffset=this.offset}parseString(e){const t=new DataView(e,this.readOffset).getUint16(0,!s.isLe);let n="";n=t>0?s.UTF8.decode(new Uint8Array(e,this.readOffset+2,t)):"";let i=t+2;return this.readOffset+=i,{data:n,bodySize:t+2}}parseDate(e,t){const n=new DataView(e,this.readOffset,t);let i=n.getFloat64(0,!s.isLe);return i+=60*n.getInt16(8,!s.isLe)*1e3,this.readOffset+=10,{data:new Date(i),bodySize:10}}parseObject(e,t){const n=this.parseString(e,t),s=this.parseValue(e,t-n.bodySize);return{data:{name:n.data,value:s.data},bodySize:n.bodySize+s.bodySize,isObjEnd:s.isObjEnd}}parseLongString(e){const t=new DataView(e,this.readOffset).getUint32(0,!s.isLe);let n="";return n=t>0?s.UTF8.decode(new Uint8Array(e,this.readOffset+2,t)):"",this.readOffset+=t+4,{data:n,bodySize:t+4}}parseValue(e,t){let n=new ArrayBuffer;n=e instanceof ArrayBuffer?e:e.buffer;const{NUMBER:r,BOOLEAN:a,STRING:o,OBJECT:l,MIX_ARRAY:d,OBJECT_END:u,STRICT_ARRAY:f,DATE:c,LONE_STRING:h}=i,p=new DataView(n,this.readOffset,t);let m=!1;const _=p.getUint8(0);let g=1;this.readOffset+=1;let x=null;switch(_){case r:x=p.getFloat64(1,!s.isLe),this.readOffset+=8,g+=8;break;case a:x=!!p.getUint8(1),this.readOffset+=1,g+=1;break;case o:{const e=this.parseString(n);x=e.data,g+=e.bodySize;break}case l:{x={};let e=0;for(16777215&p.getUint32(t-4,!s.isLe)&&(e=3);g<t-4;){const s=this.parseObject(n,t-g-e);if(s.isObjectEnd)break;x[s.data.name]=s.data.value,g+=s.bodySize}g<=t-3&&9==(16777215&p.getUint32(g-1,!s.isLe))&&(this.readOffset+=3,g+=3);break}case d:{x={},g+=4,this.readOffset+=4;let e=0;for(9==(16777215&p.getUint32(t-4,!s.isLe))&&(e=3);g<t-8;){const s=this.parseObject(n,t-g-e);if(s.isObjectEnd)break;x[s.data.name]=s.data.value,g+=s.bodySize}g<=t-3&&9==(16777215&p.getUint32(g-1,!s.isLe))&&(g+=3,this.readOffset+=3);break}case u:x=null,m=!0;break;case f:{x=[];const e=p.getUint32(1,!s.isLe);g+=4,this.readOffset+=4;for(let s=0;s<e;s++){const e=this.parseValue(n,t-g);x.push(e.data),g+=e.bodySize}break}case c:{const e=this.parseDate(n,t-1);x=e.data,g+=e.bodySize;break}case h:{const e=this.parseLongString(n,t-1);x=e.data,g+=e.bodySize;break}default:g=t}return{data:x,bodySize:g,isObjEnd:m}}}},function(e,t,n){e.exports={Mp4Remuxer:n(37).default}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s,i=n(0),r=(s=n(38))&&s.__esModule?s:{default:s};const a=i.EVENTS.REMUX_EVENTS;class o{constructor(){this._dtsBase=0,this._isDtsBaseInited=!1,this._audioNextDts=null,this._videoNextDts=null,this._videoSegmentList=new i.MediaSegmentList("video"),this._audioSegmentList=new i.MediaSegmentList("audio");const{browser:e}=i.sniffer;this._fillSilenceFrame="ie"===e,this.isFirstVideo=!0,this.isFirstAudio=!0,this.videoAllDuration=0,this.audioAllDuration=0}init(){this.on(a.REMUX_MEDIA,this.remux.bind(this)),this.on(a.REMUX_METADATA,this.onMetaDataReady.bind(this)),this.on(a.DETECT_CHANGE_STREAM,this.resetDtsBase.bind(this))}destroy(){this._dtsBase=-1,this._dtsBaseInited=!1,this._videoNextDts=null,this._audioNextDts=null,this._videoSegmentList.clear(),this._audioSegmentList.clear(),this._videoSegmentList=null,this._audioSegmentList=null}remux(){const{audioTrack:e,videoTrack:t}=this._context.getInstance("TRACKS");!this._isDtsBaseInited&&this.calcDtsBase(e,t),this._remuxVideo(t),this._remuxAudio(e)}resetDtsBase(){this._dtsBase=0,this._dtsBaseInited=!1}seek(){this._videoNextDts=null,this._audioNextDts=null,this._videoSegmentList.clear(),this._audioSegmentList.clear()}onMetaDataReady(e){let t;if("audio"===e){const{audioTrack:e}=this._context.getInstance("TRACKS");t=e}else{const{videoTrack:e}=this._context.getInstance("TRACKS");t=e}let n=this._context.getInstance("PRE_SOURCE_BUFFER"),s=n.getSource(e);s||(s=n.createSource(e)),s.mimetype=t.meta.codec,s.init=this.remuxInitSegment(e,t.meta),this.emit(a.INIT_SEGMENT,e)}remuxInitSegment(e,t){let n=new i.Buffer,s=r.default.ftyp(),a=r.default.moov({type:e,meta:t});return n.write(s,a),n}calcDtsBase(e,t){if(!e.samples.length&&!t.samples.length)return;let n=1/0,s=1/0;e.samples&&e.samples.length&&(n=e.samples[0].dts),t.samples&&t.samples.length&&(s=t.samples[0].dts),this._dtsBase=Math.min(n,s),this._isDtsBaseInited=!0}_remuxVideo(e){const t=e;if(!e.samples||!e.samples.length)return;let{samples:n}=t,s=-1,o=null;const l=[],d={samples:[]};for(;n.length;){const e=n.shift(),{isKeyframe:t,options:i}=e;if(!this.isFirstAudio&&i&&i.meta){o=this.remuxInitSegment("video",i.meta),i.meta=null,n.unshift(e),i.isContinue||this.resetDtsBase();break}let r,a,u=e.dts-this._dtsBase;-1===s&&(s=u),void 0!==e.pts&&(r=(a=e.pts-this._dtsBase)-u),void 0!==e.cts&&(a=e.cts+u,r=e.cts);let f={buffer:[],size:0};d.samples.push(f),f.buffer.push(e.data),f.size+=e.data.byteLength;let c=0;c=n.length>=1?n[0].dts-this._dtsBase-u:l.length>=1?l[l.length-1].duration:this.videoMeta.refSampleDuration,this.videoAllDuration+=c,l.push({dts:u,cts:r,pts:a,data:e.data,size:e.data.byteLength,isKeyframe:t,duration:c,flags:{isLeading:0,dependsOn:t?2:1,isDependedOn:t?1:0,hasRedundancy:0,isNonSync:t?0:1},originDts:u,type:"video"})}let u=new i.Buffer;if(l.length){const e=r.default.moof({id:t.meta.id,time:s,samples:l}),n=r.default.mdat(d);u.write(e,n),this.writeToSource("video",u)}if(o&&(this.writeToSource("video",o),n.length))return t.samples=n,this._remuxVideo(t);this.isFirstVideo=!1,this.emit(a.MEDIA_SEGMENT,"video");const f=l[l.length-1];this._videoNextDts=f.dts+f.duration,t.samples=[],t.length=0}_remuxAudio(e){const{samples:t}=e;let n=-1,s=[],o=null;const l={samples:[]};if(!t||!t.length)return;let d=!1;for(;t.length;){let e=t.shift();const{data:i,options:r}=e;if(!this.isFirstAudio&&r&&r.meta){o=this.remuxInitSegment("audio",r.meta),r.meta=null,t.unshift(e),r.isContinue||this.resetDtsBase();break}let a=e.dts-this._dtsBase;const u=a;d||(n=a,d=!0);let f=0;f=this.audioMeta.refSampleDurationFixed?this.audioMeta.refSampleDurationFixed:t.length>=1?t[0].dts-this._dtsBase-a:s.length>=1?s[s.length-1].duration:this.audioMeta.refSampleDuration,this.audioAllDuration+=f;const c={dts:a,pts:a,cts:0,size:i.byteLength,duration:e.duration?e.duration:f,flags:{isLeading:0,dependsOn:2,isDependedOn:1,hasRedundancy:0,isNonSync:0},isKeyframe:!0,originDts:u,type:"audio"};let h={buffer:[],size:0};h.buffer.push(i),h.size+=i.byteLength,l.samples.push(h),s.push(c)}const u=new i.Buffer;if(s.length){const t=r.default.moof({id:e.meta.id,time:n,samples:s}),i=r.default.mdat(l);u.write(t,i),this.writeToSource("audio",u)}if(o&&(this.writeToSource("audio",o),t.length))return e.samples=t,this._remuxAudio(e);this.isFirstAudio=!1,this.emit(a.MEDIA_SEGMENT,"audio",u);const f=s[s.length-1];this._videoNextDts=f.dts+f.duration,e.samples=[],e.length=0}writeToSource(e,t){let n=this._context.getInstance("PRE_SOURCE_BUFFER"),s=n.getSource(e);s||(s=n.createSource(e)),s.data.push(t)}initSilentAudio(e,t){const n=o.getSilentFrame(this._audioMeta.channelCount);return{dts:e,pts:e,cts:0,duration:t,unit:n,size:n.byteLength,originDts:e,type:"video"}}get videoMeta(){return this._context.getInstance("TRACKS").videoTrack.meta}get audioMeta(){return this._context.getInstance("TRACKS").audioTrack.meta}static getSilentFrame(e){return 1===e?new Uint8Array([0,200,0,128,35,128]):2===e?new Uint8Array([33,0,73,144,2,25,0,35,128]):3===e?new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,142]):4===e?new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,128,44,128,8,2,56]):5===e?new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,130,48,4,153,0,33,144,2,56]):6===e?new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,130,48,4,153,0,33,144,2,0,178,0,32,8,224]):null}}t.default=o},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var s=n(0);class i{static size(e){return s.Buffer.writeUint32(e)}static initBox(e,t,...n){const r=new s.Buffer;return r.write(i.size(e),i.type(t),...n),r.buffer}static extension(e,t){return new Uint8Array([e,t>>16&255,t>>8&255,255&t])}static ftyp(){return i.initBox(24,"ftyp",new Uint8Array([105,115,111,109,0,0,0,1,105,115,111,109,97,118,99,49]))}static moov({type:e,meta:t}){let n,s=8,r=i.mvhd(t.duration,t.timescale);n="video"===e?i.videoTrak(t):i.audioTrak(t);let a=i.mvex(t.duration,t.timescale||1e3,t.id);return[r,n,a].forEach(e=>{s+=e.byteLength}),i.initBox(s,"moov",r,n,a)}static mvhd(e,t=1e3){let n=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,t>>>24&255,t>>>16&255,t>>>8&255,255&t,e>>>24&255,e>>>16&255,e>>>8&255,255&e,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255]);return i.initBox(8+n.length,"mvhd",new Uint8Array(n))}static videoTrak(e){let t=8,n=i.tkhd({id:1,duration:e.duration,timescale:e.timescale||1e3,width:e.presentWidth,height:e.presentHeight,type:"video"}),s=i.mdia({type:"video",timescale:e.timescale||1e3,duration:e.duration,avcc:e.avcc,parRatio:e.parRatio,width:e.presentWidth,height:e.presentHeight});return[n,s].forEach(e=>{t+=e.byteLength}),i.initBox(t,"trak",n,s)}static audioTrak(e){let t=8,n=i.tkhd({id:2,duration:e.duration,timescale:e.timescale||1e3,width:0,height:0,type:"audio"}),s=i.mdia({type:"audio",timescale:e.timescale||1e3,duration:e.duration,channelCount:e.channelCount,samplerate:e.sampleRate,config:e.config});return[n,s].forEach(e=>{t+=e.byteLength}),i.initBox(t,"trak",n,s)}static tkhd(e){let t=e.id,n=e.duration,s=e.width,r=e.height,a=new Uint8Array([0,0,0,7,0,0,0,0,0,0,0,0,t>>>24&255,t>>>16&255,t>>>8&255,255&t,0,0,0,0,n>>>24&255,n>>>16&255,n>>>8&255,255&n,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,s>>>8&255,255&s,0,0,r>>>8&255,255&r,0,0]);return i.initBox(8+a.byteLength,"tkhd",a)}static edts(e){let t=new s.Buffer,n=e.duration,r=e.mediaTime;return t.write(i.size(36),i.type("edts")),t.write(i.size(28),i.type("elst")),t.write(new Uint8Array([0,0,0,1,n>>24&255,n>>16&255,n>>8&255,255&n,r>>24&255,r>>16&255,r>>8&255,255&r,0,0,0,1])),t.buffer}static mdia(e){let t=8,n=i.mdhd(e.timescale,e.duration),s=i.hdlr(e.type),r=i.minf(e);return[n,s,r].forEach(e=>{t+=e.byteLength}),i.initBox(t,"mdia",n,s,r)}static mdhd(e=1e3,t){let n=new Uint8Array([0,0,0,0,0,0,0,0,e>>>24&255,e>>>16&255,e>>>8&255,255&e,t>>>24&255,t>>>16&255,t>>>8&255,255&t,85,196,0,0]);return i.initBox(12+n.byteLength,"mdhd",i.extension(0,0),n)}static hdlr(e){let t=[0,0,0,0,0,0,0,0,118,105,100,101,0,0,0,0,0,0,0,0,0,0,0,0,86,105,100,101,111,72,97,110,100,108,101,114,0];return"audio"===e&&(t.splice(8,4,115,111,117,110),t.splice(24,13,83,111,117,110,100,72,97,110,100,108,101,114,0)),i.initBox(8+t.length,"hdlr",new Uint8Array(t))}static minf(e){let t=8,n="video"===e.type?i.vmhd():i.smhd(),s=i.dinf(),r=i.stbl(e);return[n,s,r].forEach(e=>{t+=e.byteLength}),i.initBox(t,"minf",n,s,r)}static vmhd(){return i.initBox(20,"vmhd",new Uint8Array([0,0,0,1,0,0,0,0,0,0,0,0]))}static smhd(){return i.initBox(16,"smhd",new Uint8Array([0,0,0,0,0,0,0,0]))}static dinf(){let e=new s.Buffer;return e.write(i.size(36),i.type("dinf"),i.size(28),i.type("dref"),new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,12,117,114,108,32,0,0,0,1])),e.buffer}static stbl(e){let t=8,n=i.stsd(e),s=i.stts(),r=i.stsc(),a=i.stsz(),o=i.stco();return[n,s,r,a,o].forEach(e=>{t+=e.byteLength}),i.initBox(t,"stbl",n,s,r,a,o)}static stsd(e){let t;return t="audio"===e.type?i.mp4a(e):i.avc1(e),i.initBox(16+t.byteLength,"stsd",i.extension(0,0),new Uint8Array([0,0,0,1]),t)}static mp4a(e){let t=new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,e.channelCount,0,16,0,0,0,0,e.samplerate>>8&255,255&e.samplerate,0,0]),n=i.esds(e.config);return i.initBox(8+t.byteLength+n.byteLength,"mp4a",t,n)}static esds(e=[43,146,8,0]){const t=e.length;let n=new s.Buffer,r=new Uint8Array([0,0,0,0,3,23+t,0,1,0,4,15+t,64,21,0,0,0,0,0,0,0,0,0,0,0,5].concat([t]).concat(e).concat([6,1,2]));return n.write(i.size(8+r.byteLength),i.type("esds"),r),n.buffer}static avc1(e){let t=new s.Buffer,n=e.width,r=e.height,a=e.parRatio.height,o=e.parRatio.width,l=e.avcc,d=new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,n>>8&255,255&n,r>>8&255,255&r,0,72,0,0,0,72,0,0,0,0,0,0,0,1,18,100,97,105,108,121,109,111,116,105,111,110,47,104,108,115,46,106,115,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,17,17]),u=new Uint8Array([0,28,156,128,0,45,198,192,0,45,198,192]),f=new Uint8Array([a>>24,a>>16&255,a>>8&255,255&a,o>>24,o>>16&255,o>>8&255,255&o]);return t.write(i.size(40+d.byteLength+l.byteLength+u.byteLength),i.type("avc1"),d,i.size(8+l.byteLength),i.type("avcC"),l,i.size(20),i.type("btrt"),u,i.size(16),i.type("pasp"),f),t.buffer}static stts(){let e=new Uint8Array([0,0,0,0,0,0,0,0]);return i.initBox(16,"stts",e)}static stsc(){let e=new Uint8Array([0,0,0,0,0,0,0,0]);return i.initBox(16,"stsc",e)}static stco(){let e=new Uint8Array([0,0,0,0,0,0,0,0]);return i.initBox(16,"stco",e)}static stsz(){let e=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0]);return i.initBox(20,"stsz",e)}static mvex(e,t=1e3,n){let r=new s.Buffer,a=s.Buffer.writeUint32(e);return r.write(i.size(56),i.type("mvex"),i.size(16),i.type("mehd"),i.extension(0,0),a,i.trex(n)),r.buffer}static trex(e){let t=new Uint8Array([0,0,0,0,e>>24,e>>16&255,e>>8&255,255&e,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1]);return i.initBox(8+t.byteLength,"trex",t)}static moof(e){let t=8,n=i.mfhd(),s=i.traf(e);return[n,s].forEach(e=>{t+=e.byteLength}),i.initBox(t,"moof",n,s)}static mfhd(){let e=s.Buffer.writeUint32(i.sequence);return i.sequence+=1,i.initBox(16,"mfhd",i.extension(0,0),e)}static traf(e){let t=8,n=i.tfhd(e.id),s=i.tfdt(e.time),r=i.sdtp(e),a=i.trun(e,r.byteLength);return[n,s,a,r].forEach(e=>{t+=e.byteLength}),i.initBox(t,"traf",n,s,a,r)}static tfhd(e){let t=s.Buffer.writeUint32(e);return i.initBox(16,"tfhd",i.extension(0,0),t)}static tfdt(e){return i.initBox(16,"tfdt",i.extension(0,0),s.Buffer.writeUint32(e))}static trun(e,t){let n=new s.Buffer,r=s.Buffer.writeUint32(e.samples.length),a=s.Buffer.writeUint32(92+16*e.samples.length+t);return n.write(i.size(20+16*e.samples.length),i.type("trun"),new Uint8Array([0,0,15,1]),r,a),e.samples.forEach(e=>{const t=e.flags;n.write(new Uint8Array([e.duration>>>24&255,e.duration>>>16&255,e.duration>>>8&255,255&e.duration,e.size>>>24&255,e.size>>>16&255,e.size>>>8&255,255&e.size,t.isLeading<<2|t.dependsOn,t.isDependedOn<<6|t.hasRedundancy<<4|t.isNonSync,0,0,e.cts>>>24&255,e.cts>>>16&255,e.cts>>>8&255,255&e.cts]))}),n.buffer}static sdtp(e){let t=new s.Buffer;return t.write(i.size(12+e.samples.length),i.type("sdtp"),i.extension(0,0)),e.samples.forEach(e=>{const n=e.flags,s=n.isLeading<<6|n.dependsOn<<4|n.isDependedOn<<2|n.hasRedundancy;t.write(new Uint8Array([s]))}),t.buffer}static mdat(e){let t=new s.Buffer,n=8;e.samples.forEach(e=>{n+=e.size}),t.write(i.size(n),i.type("mdat"));let r=new Uint8Array(n),a=0;return r.set(t.buffer,a),a+=8,e.samples.forEach(e=>{e.buffer.forEach(e=>{r.set(e,a),a+=e.byteLength})}),r}}i.type=e=>new Uint8Array([e.charCodeAt(0),e.charCodeAt(1),e.charCodeAt(2),e.charCodeAt(3)]),i.sequence=1,t.default=i},function(e,t,n){e.exports={FetchLoader:n(40).default}},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});const s=n(0).EVENTS.LOADER_EVENTS;t.default=class{constructor(e){this.configs=Object.assign({},e),this.url=null,this.status=0,this.error=null,this._reader=null,this._canceled=!1,this._destroyed=!1,this.readtype=this.configs.readtype,this.buffer=this.configs.buffer||"LOADER_BUFFER",this._loaderTaskNo=0}init(){this.on(s.LADER_START,this.load.bind(this))}static get type(){return"loader"}load(e,t){let n=this;this.url=e,this._canceled=!1;let i=this.getParams(t);return n.loading=!0,fetch(this.url,i).then((function(e){if(e.ok)return n.status=e.status,n._onFetchResponse(e);n.loading=!1,n.emit(s.LOADER_ERROR,n.TAG,new Error("invalid response."))})).catch((function(e){throw n.loading=!1,n.emit(s.LOADER_ERROR,n.TAG,e),new Error(e.message)}))}_onFetchResponse(e){let t=this,n=this._context.getInstance(this.buffer);this._loaderTaskNo++;let i=this._loaderTaskNo;if(!0===e.ok)switch(this.readtype){case 2:e.json().then(e=>{t.loading=!1,t._canceled||t._destroyed||(n?(n.push(e),t.emit(s.LOADER_COMPLETE,n)):t.emit(s.LOADER_COMPLETE,e))});break;case 1:e.text().then(e=>{t.loading=!1,t._canceled||t._destroyed||(n?(n.push(e),t.emit(s.LOADER_COMPLETE,n)):t.emit(s.LOADER_COMPLETE,e))});break;case 3:e.arrayBuffer().then(e=>{t.loading=!1,t._canceled||t._destroyed||(n?(n.push(new Uint8Array(e)),t.emit(s.LOADER_COMPLETE,n)):t.emit(s.LOADER_COMPLETE,e))});break;case 0:default:return this._onReader(e.body.getReader(),i)}}_onReader(e,t){let n=this._context.getInstance(this.buffer);if(!n&&this._reader||this._destroyed)try{this._reader.cancel()}catch(e){}if(this._reader=e,!1===this.loading)return;let i=this;this._reader&&this._reader.read().then((function(r){if(r.done)return i.loading=!1,i.status=0,void i.emit(s.LOADER_COMPLETE,n);if(!i._canceled&&!i._destroyed)return n.push(r.value),i.emit(s.LOADER_DATALOADED,n),i._onReader(e,t);if(i._reader)try{i._reader.cancel()}catch(e){}})).catch(e=>{i.loading=!1,i.emit(s.LOADER_ERROR,i.TAG,e)})}getParams(e){let t=Object.assign({},e),n=new Headers,s={method:"GET",headers:n,mode:"cors",cache:"default"};if("object"==typeof this.configs.headers){let e=this.configs.headers;for(let t in e)e.hasOwnProperty(t)&&n.append(t,e[t])}if("object"==typeof t.headers){let e=t.headers;for(let t in e)e.hasOwnProperty(t)&&n.append(t,e[t])}return!1===t.cors&&(s.mode="same-origin"),t.withCredentials&&(s.credentials="include"),s}cancel(){if(this._reader){try{this._reader.cancel()}catch(e){}this._reader=null,this.loading=!1,this._canceled=!0}}destroy(){this._destroyed=!0,this.cancel()}}}]))},"./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */function(e,t,n){"use strict";var s=r(n(/*! xgplayer-flv-live */"../xgplayer-flv-live/dist/index.js")),i=r(n(/*! xgplayer-flv-vod */"../xgplayer-flv-vod/dist/index.js"));function r(e){return e&&e.__esModule?e:{default:e}}e.exports=function e(t){return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),t.isLive?new s.default(t):new i.default(t)}},0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */function(e,t,n){e.exports=n(/*! ./src/index.js */"./src/index.js")},xgplayer:
/*!*************************!*\
  !*** external "Player" ***!
  \*************************/
/*! no static exports found */function(e,t){e.exports=window.Player}});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9GbHZQbGF5ZXIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vRmx2UGxheWVyLy4tbGl2ZS9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL0ZsdlBsYXllci8uLXZvZC9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL0ZsdlBsYXllci8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9GbHZQbGF5ZXIvZXh0ZXJuYWwgXCJQbGF5ZXJcIiJdLCJuYW1lcyI6WyJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiZXhwb3J0cyIsIm1vZHVsZSIsImkiLCJsIiwibW9kdWxlcyIsImNhbGwiLCJtIiwiYyIsImQiLCJuYW1lIiwiZ2V0dGVyIiwibyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsInIiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwidCIsIm1vZGUiLCJfX2VzTW9kdWxlIiwibnMiLCJjcmVhdGUiLCJrZXkiLCJiaW5kIiwibiIsIm9iamVjdCIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsIndpbmRvdyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfeGdwbGF5ZXJfXyIsImUiLCJhIiwiZGVmYXVsdCIsImV2YWwiLCIwIiwieGdwbGF5ZXIiLCJyZXF1aXJlIiwiQ29udGV4dCIsIkVWRU5UUyIsIldPUktFUl9DT01NQU5EUyIsInNuaWZmZXIiLCJpc0xlIiwiVVRGOCIsIk1lZGlhSW5mbyIsIk1lZGlhU2FtcGxlIiwiTWVkaWFTZWdtZW50IiwiTWVkaWFTZWdtZW50TGlzdCIsIkF1ZGlvVHJhY2tNZXRhIiwiVmlkZW9UcmFja01ldGEiLCJBdWRpb1RyYWNrU2FtcGxlIiwiVmlkZW9UcmFja1NhbXBsZSIsIk1zZSIsIlN0cmVhbSIsIkJ1ZmZlciIsIkNyeXB0byIsImNvbnN0cnVjdG9yIiwidGhpcyIsImlkIiwic2VxdWVuY2VOdW1iZXIiLCJzYW1wbGVzIiwiZHJvcHBlZFNhbXBsZXMiLCJsZW5ndGgiLCJyZXNldCIsIkF1ZGlvVHJhY2siLCJzdXBlciIsIlRBRyIsInR5cGUiLCJWaWRlb1RyYWNrIiwiZHJvcHBlZCIsIlRyYWNrcyIsImF1ZGlvVHJhY2siLCJ2aWRlb1RyYWNrIiwibWltZVR5cGUiLCJkdXJhdGlvbiIsImhhc1ZpZGVvIiwidmlkZW8iLCJjb2RlYyIsIndpZHRoIiwiaGVpZ2h0IiwicHJvZmlsZSIsImxldmVsIiwiZnJhbWVSYXRlIiwiZml4ZWQiLCJmcHMiLCJmcHNfbnVtIiwiZnBzX2RlbiIsImNocm9tYUZvcm1hdCIsInBhclJhdGlvIiwiaGFzQXVkaW8iLCJhdWRpbyIsInNhbXBsZVJhdGUiLCJzYW1wbGVSYXRlSW5kZXgiLCJjaGFubmVsQ291bnQiLCJpc0Jhc2VJbmZvUmVhZHkiLCJpc1ZpZGVvUmVhZHkiLCJpc0F1ZGlvUmVhZHkiLCJMQURFUl9TVEFSVCIsIkxPQURFUl9EQVRBTE9BREVEIiwiTE9BREVSX0NPTVBMRVRFIiwiTE9BREVSX0VSUk9SIiwiREVNVVhfU1RBUlQiLCJERU1VWF9DT01QTEVURSIsIkRFTVVYX0VSUk9SIiwiTUVUQURBVEFfUEFSU0VEIiwiVklERU9fTUVUQURBVEFfQ0hBTkdFIiwiQVVESU9fTUVUQURBVEFfQ0hBTkdFIiwiTUVESUFfSU5GTyIsIlJFTVVYX01FVEFEQVRBIiwiUkVNVVhfTUVESUEiLCJNRURJQV9TRUdNRU5UIiwiUkVNVVhfRVJST1IiLCJJTklUX1NFR01FTlQiLCJERVRFQ1RfQ0hBTkdFX1NUUkVBTSIsIlNPVVJDRV9VUERBVEVfRU5EIiwiUkVUUllfVElNRV9FWENFRURFRCIsImFzc2lnbiIsImgiLCJwdXNoIiwiQUxMRVZFTlRTIiwiSExTX0VWRU5UUyIsIlJFTVVYX0VWRU5UUyIsIkRFTVVYX0VWRU5UUyIsIk1TRV9FVkVOVFMiLCJMT0FERVJfRVZFTlRTIiwiRmx2QWxsb3dlZEV2ZW50cyIsIkhsc0FsbG93ZWRFdmVudHMiLCJDUllUT19FVkVOVFMiLCJTVEFSVF9ERUNSWVBUIiwiREVDUllQVEVEIiwiY29uZmlnIiwicmVmU2FtcGxlRHVyYXRpb24iLCJ0aW1lc2NhbGUiLCJpbml0IiwiYXZjYyIsInNwcyIsIlVpbnQ4QXJyYXkiLCJwcHMiLCJjb2RlY0hlaWdodCIsImNvZGVjV2lkdGgiLCJwcmVzZW50SGVpZ2h0IiwicHJlc2VudFdpZHRoIiwiZ2V0RGVmYXVsdCIsImR0cyIsInB0cyIsImRhdGEiLCJpc0tleWZyYW1lIiwib3JpZ2luRHRzIiwiTmFsdW5pdCIsIlNwc1BhcnNlciIsIkNvbXBhdGliaWxpdHkiLCJieXRlTGVuZ3RoIiwiYnVmZmVyIiwiX2Vic3AycmJzcCIsInJlYWRCeXRlIiwicmVhZFVFRyIsImdldFByb2ZpbGVTdHJpbmciLCJnZXRMZXZlbFN0cmluZyIsInJlYWRCaXRzIiwicmVhZEJvb2wiLCJfc2tpcFNjYWxpbmdMaXN0IiwiZiIsInJlYWRTRUciLCJnIiwiXyIsInkiLCJFIiwiUyIsIkEiLCJ2IiwiVCIsImIiLCJSIiwiRCIsInciLCJ4IiwiTCIsIk8iLCJNIiwiQiIsIk1hdGgiLCJjZWlsIiwiZGVzdHJveSIsInByb2ZpbGVfc3RyaW5nIiwibGV2ZWxfc3RyaW5nIiwiYml0X2RlcHRoIiwiY2hyb21hX2Zvcm1hdCIsImNocm9tYV9mb3JtYXRfc3RyaW5nIiwiZ2V0Q2hyb21hRm9ybWF0U3RyaW5nIiwiZnJhbWVfcmF0ZSIsInBhcl9yYXRpbyIsImNvZGVjX3NpemUiLCJwcmVzZW50X3NpemUiLCJ0b0ZpeGVkIiwiYml0RGVwdGgiLCJmbG9vciIsIlRyYWNrIiwiWGdCdWZmZXIiLCJSZW11eEJ1ZmZlciIsIlByZVNvdXJjZSIsImhpc3RvcnlMZW4iLCJhcnJheSIsIm9mZnNldCIsIl9zaGlmdEJ1ZmZlciIsInNsaWNlIiwic2hpZnQiLCJzZXQiLCJjbGVhciIsImlzTGl2ZSIsImN1cnJlbnRUaW1lIiwiZ2V0QnVmZmVyZWRSYW5nZSIsImVtaXQiLCJtc2UiLCJlbmRPZlN0cmVhbSIsImNvbnRleHQiLCJpbml0RXZlbnRzIiwicmVnaXN0cnkiLCJmbHYiLCJzdGFydCIsInVybCIsIm9uIiwiaGFuZGxlVGltZVVwZGF0ZSIsImhhbmRsZVNlZWsiLCJvbmNlIiwiX2Rlc3Ryb3kiLCJsb2FkRGF0YSIsInNlZWsiLCJwcmVsb2FkVGltZSIsImxvYWROZXh0IiwiY3VycmVudFNyYyIsInBsYXllciIsInBhdXNlZCIsInBhdXNlIiwicGxheSIsIl9lbWl0dGVyIiwiRXZlbnRFbWl0dGVyIiwiX2luc3RhbmNlTWFwIiwiX2Nsc01hcCIsIl9pbml0ZWQiLCJtZWRpYUluZm8iLCJhbGxvd2VkRXZlbnRzIiwiX2hvb2tzIiwiRXJyb3IiLCJpbml0SW5zdGFuY2UiLCJfaXNNZXNzYWdlTmFtZVZhbGlkIiwibGlzdGVuZXJzIiwib25jZUxpc3RlbmVycyIsIl9jb250ZXh0Iiwib2ZmIiwicmVtb3ZlTGlzdGVuZXJzIiwia2V5cyIsImZvckVhY2giLCJkZXN0cm95SW5zdGFuY2VzIiwiaW5kZXhPZiIsIlJlZmxlY3QiLCJhcHBseSIsIkZ1bmN0aW9uIiwib3duS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5TmFtZXMiLCJjb25jYXQiLCJOdW1iZXIiLCJpc05hTiIsIl9ldmVudHMiLCJfZXZlbnRzQ291bnQiLCJfbWF4TGlzdGVuZXJzIiwiZGVmYXVsdE1heExpc3RlbmVycyIsIlR5cGVFcnJvciIsIm5ld0xpc3RlbmVyIiwibGlzdGVuZXIiLCJ1bnNoaWZ0Iiwid2FybmVkIiwiU3RyaW5nIiwiZW1pdHRlciIsImNvdW50IiwiY29uc29sZSIsIndhcm4iLCJ1IiwiYXJndW1lbnRzIiwiZmlyZWQiLCJ0YXJnZXQiLCJyZW1vdmVMaXN0ZW5lciIsIndyYXBGbiIsIkFycmF5IiwiUmFuZ2VFcnJvciIsImdldFByb3RvdHlwZU9mIiwic2V0TWF4TGlzdGVuZXJzIiwiZ2V0TWF4TGlzdGVuZXJzIiwiZXJyb3IiLCJtZXNzYWdlIiwiYWRkTGlzdGVuZXIiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwicG9wIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicmF3TGlzdGVuZXJzIiwibGlzdGVuZXJDb3VudCIsImV2ZW50TmFtZXMiLCJDT05URVhUX0NPTU9NQU5EUyIsIk9OIiwiT05DRSIsIk9GRiIsIkVNSVQiLCJERVNUUk9ZIiwiQXJyYXlCdWZmZXIiLCJEYXRhVmlldyIsInNldEludDE2IiwiSW50MTZBcnJheSIsIm9zIiwiaXNQYyIsImlzVGFibGV0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidG9Mb3dlckNhc2UiLCJpZSIsImZpcmZveCIsImNocm9tZSIsIm9wZXJhIiwic2FmYXJpIiwiZmlsdGVyIiwidGVzdCIsImlzUGhvbmUiLCJpc0FuZHJvaWQiLCJpc1N5bWJpYW4iLCJpc1dpbmRvd3NQaG9uZSIsImlzRmlyZUZveCIsImZyb21DaGFyQ29kZSIsIl9jaGVja0NvbnRpbnVhdGlvbiIsImpvaW4iLCJnZXREZWZhdWx0SW5mIiwidG9TdHJpbmciLCJlbnRyaWVzIiwicG9zaXRpb24iLCJpc1JBUCIsInN0YXJ0RHRzIiwiZW5kRHRzIiwic3RhcnRQdHMiLCJlbmRQdHMiLCJvcmlnaW5TdGFydER0cyIsIm9yaWdpbkVuZER0cyIsInJhbmRvbUFjY2Vzc1BvaW50cyIsImZpcnN0U2FtcGxlIiwibGFzdFNhbXBsZSIsIl90eXBlIiwiX2xpc3QiLCJfbGFzdEFwcGVuZExvY2F0aW9uIiwiX3NlYXJjaE5lYXJlc3RTZWdtZW50QmVmb3JlIiwic3BsaWNlIiwiZ2V0TGFzdFNlZ21lbnRCZWZvcmUiLCJjb25maWdzIiwiY29udGFpbmVyIiwibWVkaWFTb3VyY2UiLCJzb3VyY2VCdWZmZXJzIiwib25Tb3VyY2VPcGVuIiwib25UaW1lVXBkYXRlIiwib25VcGRhdGVFbmQiLCJvbldhaXRpbmciLCJzZWxmIiwiTWVkaWFTb3VyY2UiLCJhZGRFdmVudExpc3RlbmVyIiwic3JjIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiYWRkU291cmNlQnVmZmVycyIsImRvQXBwZW5kIiwicmVhZHlTdGF0ZSIsImdldEluc3RhbmNlIiwic291cmNlcyIsIm1ldGEiLCJtaW1ldHlwZSIsImFkZFNvdXJjZUJ1ZmZlciIsInVwZGF0aW5nIiwiaW5pdGVkIiwiYXBwZW5kQnVmZmVyIiwiYWN0aXZlU291cmNlQnVmZmVycyIsInJlbW92ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJQcm9taXNlIiwic2V0VGltZW91dCIsImNsZWFyQnVmZmVyIiwicmVzb2x2ZSIsImFsbCIsInJlbW92ZUJ1ZmZlcnMiLCJ0aGVuIiwicmVtb3ZlU291cmNlQnVmZmVyIiwicmV2b2tlT2JqZWN0VVJMIiwiYnVmZmVyZWQiLCJlbmQiLCJkYXRhdmlldyIsImdldEludDgiLCJnZXRVaW50OCIsImdldEludDE2IiwiZ2V0VWludDE2IiwiZ2V0SW50MzIiLCJnZXRVaW50MzIiLCJwYWRTdGFydCIsInBhcnNlSW50IiwiaXRlcmF0b3IiLCJuZXh0IiwiZG9uZSIsInJldHVybiIsImlucHV0QnVmZmVyIiwiaW5wdXRidWZmZXIiLCJvdXRwdXRCdWZmZXIiLCJvdXRwdXRidWZmZXIiLCJpdiIsIm1ldGhvZCIsImNyeXB0byIsIm1zQ3J5cHRvIiwiZGVjcmlwdCIsImFlc2tleSIsImRlY3JpcHREYXRhIiwic3VidGxlIiwiaW1wb3J0S2V5IiwiZGVjcnlwdCIsIl9wbGF5ZXIiLCJzdGF0ZSIsImluaXRTZWdtZW50QXJyaXZlZCIsInJhbmdlIiwicmFuZ2VTdXBwb3J0IiwidGltZXMiLCJNQVhfU0FGRV9JTlRFR0VSIiwiZmlsZXBvc2l0aW9ucyIsIkZldGNoTG9hZGVyIiwiTXA0UmVtdXhlciIsImluaXRMaXN0ZW5lcnMiLCJsb2FkTWV0YSIsIl9oYW5kbGVMb2FkZXJEYXRhTG9hZGVkIiwiX2hhbmRsZU5ldHdvcmtFcnJvciIsIl9oYW5kbGVNZWRpYUluZm8iLCJfaGFuZGxlTWV0YWRhdGFQYXJzZWQiLCJfaGFuZGxlRGVtdXhDb21wbGV0ZSIsIl9oYW5kbGVEZW11eEVycm9yIiwiX2hhbmRsZUFwcGVuZEluaXRTZWdtZW50IiwiX2hhbmRsZU1lZGlhU2VnbWVudCIsIm9uTWV0YURhdGEiLCJpc1NlZWthYmxlIiwiY2FuY2VsIiwiZW1pdFRvIiwiRXJyb3JzIiwiX29uRXJyb3IiLCJlcnJvclR5cGUiLCJlcnJvckRldGFpbHMiLCJlcnJvckZhdGFsIiwiZ2V0U2Vla1JhbmdlIiwiY29tcGF0IiwibG9hZGVyIiwibG9hZGluZyIsImdldE5leHRSYW5nZSIsImhlYWRlcnMiLCJSYW5nZSIsImxvYWQiLCJjYXRjaCIsImxvYWRGYWxsYmFjayIsImtleWZyYW1lcyIsImZpbmRGaWxlUG9zaXRpb24iLCJpc0NvbXBsZXRlIiwiX2ZpcnN0RnJhZ21lbnRMb2FkZWQiLCJfdHJhY2tOdW0iLCJfaGFzU2NyaXB0IiwiZG9QYXJzZUZsdiIsImxvYWRlckJ1ZmZlciIsIl9wYXJzZUZsdlRhZyIsInBhcnNlRmx2SGVhZGVyIiwiaXNGbHZGaWxlIiwiZ2V0UGxheVR5cGUiLCJpbml0VmlkZW9UcmFjayIsImluaXRBdWRpb1RyYWNrIiwidHJhY2tzIiwiX3BhcnNlRmx2VGFnSGVhZGVyIiwiX3Byb2Nlc3NDaHVuayIsInRvSW50IiwiZmlsdGVyZWQiLCJ0YWdUeXBlIiwiZGF0YXNpemUiLCJfcGFyc2VTY3JpcHREYXRhIiwiX3BhcnNlQUFDRGF0YSIsIl9wYXJzZUhldmNEYXRhIiwiaHNhQXVkaW8iLCJfZGF0YXNpemVWYWxpZGF0b3IiLCJoYXNTcGVjaWZpY0NvbmZpZyIsImF1ZGlvc2FtcGxlcmF0ZSIsImF1ZGlvY2hhbm5lbHMiLCJmcmFtZXJhdGUiLCJvYmplY3RUeXBlIiwiX3N3aXRjaEF1ZGlvU2FtcGxlUmF0ZSIsImZyYW1lTGVuZ3RoIiwiZGVwZW5kc09uQ29yZUNvZGVyIiwiZXh0ZW5zaW9uRmxhZ0luZGV4IiwiZm9ybWF0IiwiX2hhc0F1ZGlvU2VxdWVuY2UiLCJfc3dpdGNoQXVkaW9TYW1wbGluZ0ZyZXF1ZW5jeSIsImZyYW1lTGVudGgiLCJhdWRpb1NhbXBsZVJhdGUiLCJfYWFjU2VxdWVuY2VIZWFkZXJQYXJzZXIiLCJhdWRpb1NhbXBsZVJhdGVJbmRleCIsIl9tZXRhQ2hhbmdlIiwib3B0aW9ucyIsImZyYW1lVHlwZSIsImNvZGVjSUQiLCJhdmNQYWNrZXRUeXBlIiwiY3RzIiwic2l6ZSIsIl9hdmNTZXF1ZW5jZUhlYWRlclBhcnNlciIsIl9oYXNWaWRlb1NlcXVlbmNlIiwiY29uZmlndXJhdGlvblZlcnNpb24iLCJhdmNQcm9maWxlSW5kaWNhdGlvbiIsInByb2ZpbGVDb21wYXRpYmlsaXR5IiwiYXZjTGV2ZWxJbmRpY2F0aW9uIiwibmFsVW5pdExlbmd0aCIsInBhcnNlU1BTIiwidG9WaWRlb01ldGEiLCJnZXRBbm5leGJOYWxzIiwiZ2V0QXZjY05hbHMiLCJnZXRIZWFkZXJQb3NpdGlvbkFubmV4QiIsInBvcyIsImhlYWRlckxlbmd0aCIsInNraXAiLCJoZWFkZXIiLCJib2R5IiwiYW5hbHlzZU5hbCIsIm5kciIsImlkciIsIl9idWZmZXIiLCJfYnVmZmVySW5kZXgiLCJfdG90YWxCeXRlcyIsIl90b3RhbEJpdHMiLCJfY3VycmVudFdvcmQiLCJfY3VycmVudFdvcmRCaXRzTGVmdCIsIm1pbiIsInN1YmFycmF5IiwiX2ZpbGxDdXJyZW50V29yZCIsIl9za2lwTGVhZGluZ1plcm8iLCJuZXh0QXVkaW9EdHMiLCJuZXh0VmlkZW9EdHMiLCJsYXN0QXVkaW9TYW1wbGVzTGVuIiwibGFzdFZpZGVvU2FtcGxlc0xlbiIsImxhc3RWaWRlb0R0cyIsImxhc3RBdWRpb0R0cyIsImFsbEF1ZGlvU2FtcGxlc0NvdW50IiwiYWxsVmlkZW9TYW1wbGVzQ291bnQiLCJfZmlyc3RBdWRpb1NhbXBsZSIsIl9maXJzdFZpZGVvU2FtcGxlIiwiZmlsbGVkQXVkaW9TYW1wbGVzIiwiZmlsbGVkVmlkZW9TYW1wbGVzIiwiX3ZpZGVvTGFyZ2VHYXAiLCJfYXVkaW9MYXJnZUdhcCIsImJlZm9yZSIsImRvRml4IiwiaXNGaXJzdEF1ZGlvU2FtcGxlcyIsImlzRmlyc3RWaWRlb1NhbXBsZXMiLCJnZXRGaXJzdFNhbXBsZSIsInJlY29yZFNhbXBsZXNDb3VudCIsImZpeFJlZlNhbXBsZUR1cmF0aW9uIiwiY2hhbmdlZCIsImNoYW5nZWRJZHgiLCJkZXRhY3RDaGFuZ2VTdHJlYW0iLCJmaXhDaGFuZ2VTdHJlYW1WaWRlbyIsImRvRml4VmlkZW8iLCJmaXhDaGFuZ2VTdHJlYW1BdWRpbyIsImRvRml4QXVkaW8iLCJkb0ZpeExhcmdlR2FwIiwiZGV0ZWN0TGFyZ2VHYXAiLCJhYnMiLCJnZXRTaWxlbnRGcmFtZSIsInJlZlNhbXBsZUR1cmF0aW9uRml4ZWQiLCJzb3J0QXVkaW9TYW1wbGVzIiwiZ2V0U3RyZWFtQ2hhbmdlU3RhcnQiLCJpc0NvbnRpbnVlIiwiZmluZEZpcnN0VmlkZW9TYW1wbGUiLCJmaW5kRmlyc3RBdWRpb1NhbXBsZSIsImR0c0Jhc2UiLCJzb3J0IiwiZGlzY29udGludWUiLCJsb2ciLCJfZHRzQmFzZSIsIk5VTUJFUiIsIkJPT0xFQU4iLCJTVFJJTkciLCJPQkpFQ1QiLCJNSVhfQVJSQVkiLCJPQkpFQ1RfRU5EIiwiU1RSSUNUX0FSUkFZIiwiREFURSIsIkxPTkVfU1RSSU5HIiwicmVhZE9mZnNldCIsInBhcnNlVmFsdWUiLCJib2R5U2l6ZSIsInJlc2V0U3RhdHVzIiwiZGVjb2RlIiwiZ2V0RmxvYXQ2NCIsIkRhdGUiLCJwYXJzZVN0cmluZyIsImlzT2JqRW5kIiwicGFyc2VPYmplY3QiLCJpc09iamVjdEVuZCIsInBhcnNlRGF0ZSIsInBhcnNlTG9uZ1N0cmluZyIsIl9pc0R0c0Jhc2VJbml0ZWQiLCJfYXVkaW9OZXh0RHRzIiwiX3ZpZGVvTmV4dER0cyIsIl92aWRlb1NlZ21lbnRMaXN0IiwiX2F1ZGlvU2VnbWVudExpc3QiLCJicm93c2VyIiwiX2ZpbGxTaWxlbmNlRnJhbWUiLCJpc0ZpcnN0VmlkZW8iLCJpc0ZpcnN0QXVkaW8iLCJ2aWRlb0FsbER1cmF0aW9uIiwiYXVkaW9BbGxEdXJhdGlvbiIsInJlbXV4Iiwib25NZXRhRGF0YVJlYWR5IiwicmVzZXREdHNCYXNlIiwiX2R0c0Jhc2VJbml0ZWQiLCJjYWxjRHRzQmFzZSIsIl9yZW11eFZpZGVvIiwiX3JlbXV4QXVkaW8iLCJnZXRTb3VyY2UiLCJjcmVhdGVTb3VyY2UiLCJyZW11eEluaXRTZWdtZW50IiwiZnR5cCIsIm1vb3YiLCJ3cml0ZSIsInZpZGVvTWV0YSIsImZsYWdzIiwiaXNMZWFkaW5nIiwiZGVwZW5kc09uIiwiaXNEZXBlbmRlZE9uIiwiaGFzUmVkdW5kYW5jeSIsImlzTm9uU3luYyIsIm1vb2YiLCJ0aW1lIiwibWRhdCIsIndyaXRlVG9Tb3VyY2UiLCJhdWRpb01ldGEiLCJfYXVkaW9NZXRhIiwidW5pdCIsIndyaXRlVWludDMyIiwiaW5pdEJveCIsIm12aGQiLCJ2aWRlb1RyYWsiLCJhdWRpb1RyYWsiLCJtdmV4IiwidGtoZCIsIm1kaWEiLCJzYW1wbGVyYXRlIiwibWVkaWFUaW1lIiwibWRoZCIsImhkbHIiLCJtaW5mIiwiZXh0ZW5zaW9uIiwidm1oZCIsInNtaGQiLCJkaW5mIiwic3RibCIsInN0c2QiLCJzdHRzIiwic3RzYyIsInN0c3oiLCJzdGNvIiwibXA0YSIsImF2YzEiLCJlc2RzIiwidHJleCIsIm1maGQiLCJ0cmFmIiwic2VxdWVuY2UiLCJ0ZmhkIiwidGZkdCIsInNkdHAiLCJ0cnVuIiwiY2hhckNvZGVBdCIsInN0YXR1cyIsIl9yZWFkZXIiLCJfY2FuY2VsZWQiLCJfZGVzdHJveWVkIiwicmVhZHR5cGUiLCJfbG9hZGVyVGFza05vIiwiZ2V0UGFyYW1zIiwiZmV0Y2giLCJvayIsIl9vbkZldGNoUmVzcG9uc2UiLCJqc29uIiwidGV4dCIsImFycmF5QnVmZmVyIiwiX29uUmVhZGVyIiwiZ2V0UmVhZGVyIiwicmVhZCIsIkhlYWRlcnMiLCJjYWNoZSIsImFwcGVuZCIsImNvcnMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJjcmVkZW50aWFscyIsIkZsdkxpdmVQbGF5ZXIiLCJGbHZWb2RQbGF5ZXIiXSwibWFwcGluZ3MiOiI2QkFDRSxJQUFJQSxFQUFtQixHQUd2QixTQUFTQyxFQUFvQkMsR0FHNUIsR0FBR0YsRUFBaUJFLEdBQ25CLE9BQU9G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QUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLFVBQVUsQ0FBQyxHQUFHLElBQUl6SCxFQUFFLE9BQU8sSUFBSXlILFdBQVcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxJQUFJLElBQUksR0FBRyxJQUFJLElBQUksSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxJQUFJLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxJQUFJekgsRUFBRSxPQUFPLElBQUl5SCxXQUFXLENBQUMsRUFBRSxHQUFHLEdBQUcsSUFBSSxJQUFJLEdBQUcsSUFBSSxJQUFJLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLElBQUksSUFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsSUFBSXpILEVBQUUsT0FBTyxJQUFJeUgsV0FBVyxDQUFDLEVBQUUsR0FBRyxHQUFHLElBQUksSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxJQUFJLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFH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UixPQUFPNkcsT0FBTyxHQUFHckYsR0FBR2xDLEVBQUUsSUFBSWtyQixRQUFRbnBCLEVBQUUsQ0FBQzBYLE9BQU8sTUFBTTJDLFFBQVFwYyxFQUFFbUIsS0FBSyxPQUFPZ3FCLE1BQU0sV0FBVyxHQUFHLGlCQUFpQnZuQixLQUFLb1MsUUFBUW9HLFFBQVEsQ0FBQyxJQUFJbGEsRUFBRTBCLEtBQUtvUyxRQUFRb0csUUFBUSxJQUFJLElBQUlsYixLQUFLZ0IsRUFBRUEsRUFBRUwsZUFBZVgsSUFBSWxCLEVBQUVvckIsT0FBT2xxQixFQUFFZ0IsRUFBRWhCLElBQUksR0FBRyxpQkFBaUJBLEVBQUVrYixRQUFRLENBQUMsSUFBSWxhLEVBQUVoQixFQUFFa2IsUUFBUSxJQUFJLElBQUlsYixLQUFLZ0IsRUFBRUEsRUFBRUwsZUFBZVgsSUFBSWxCLEVBQUVvckIsT0FBT2xxQixFQUFFZ0IsRUFBRWhCLElBQUksT0FBTSxJQUFLQSxFQUFFbXFCLE9BQU90cEIsRUFBRVosS0FBSyxlQUFlRCxFQUFFb3FCLGtCQUFrQnZwQixFQUFFd3BCLFlBQVksV0FBV3hwQixFQUFFLFNBQVMsR0FBRzZCLEtBQUt1bUIsUUFBUSxDQUFDLElBQUl2bUIsS0FBS3VtQixRQUFRM08sU0FBUyxNQUFNdFosSUFBSTBCLEtBQUt1bUIsUUFBUSxLQUFLdm1CLEtBQUtzWSxTQUFRLEVBQUd0WSxLQUFLd21CLFdBQVUsR0FBSSxVQUFVeG1CLEtBQUt5bUIsWUFBVyxFQUFHem1CLEtBQUs0WCxnQjs7OzsyRENBeGozRSxJLElBQUEsaUUsSUFDQSwrRCxtREFZQXpiLEVBQU9ELFFBVEwsV0FBYXVJLEdBQ1gsTyw0RkFEbUIsU0FDZkEsRUFBTzhFLE9BQ0YsSUFBSXFlLFVBQWNuakIsR0FFbEIsSUFBSW9qQixVQUFhcGpCLEs7Ozs7Ozs7OzRDQ1JoQnRJLEVBQU9ELFFBQVVrQyxPQUFlIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuIiwiIWZ1bmN0aW9uKGUsbil7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9bihyZXF1aXJlKFwieGdwbGF5ZXJcIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wieGdwbGF5ZXJcIl0sbik6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0c1tcInhncGxheWVyLWZsdlwiXT1uKHJlcXVpcmUoXCJ4Z3BsYXllclwiKSk6ZVtcInhncGxheWVyLWZsdlwiXT1uKGUueGdwbGF5ZXIpfSh3aW5kb3csKGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfeGdwbGF5ZXJfXyl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciBuPXt9O2Z1bmN0aW9uIHQoYSl7aWYoblthXSlyZXR1cm4gblthXS5leHBvcnRzO3ZhciByPW5bYV09e2k6YSxsOiExLGV4cG9ydHM6e319O3JldHVybiBlW2FdLmNhbGwoci5leHBvcnRzLHIsci5leHBvcnRzLHQpLHIubD0hMCxyLmV4cG9ydHN9cmV0dXJuIHQubT1lLHQuYz1uLHQuZD1mdW5jdGlvbihlLG4sYSl7dC5vKGUsbil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se2VudW1lcmFibGU6ITAsZ2V0OmF9KX0sdC5yPWZ1bmN0aW9uKGUpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LHQudD1mdW5jdGlvbihlLG4pe2lmKDEmbiYmKGU9dChlKSksOCZuKXJldHVybiBlO2lmKDQmbiYmXCJvYmplY3RcIj09dHlwZW9mIGUmJmUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgYT1PYmplY3QuY3JlYXRlKG51bGwpO2lmKHQucihhKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTplfSksMiZuJiZcInN0cmluZ1wiIT10eXBlb2YgZSlmb3IodmFyIHIgaW4gZSl0LmQoYSxyLGZ1bmN0aW9uKG4pe3JldHVybiBlW25dfS5iaW5kKG51bGwscikpO3JldHVybiBhfSx0Lm49ZnVuY3Rpb24oZSl7dmFyIG49ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIHQuZChuLFwiYVwiLG4pLG59LHQubz1mdW5jdGlvbihlLG4pe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxuKX0sdC5wPVwiXCIsdCh0LnM9MCl9KHtcIi4uLy4uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAvVXNlcnMvbGVvbmFyZG8vRG9jdW1lbnRzL2Zyb250LWVuZC9wbGF5ZXIveGdwbGF5ZXIvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcblxcblxcbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGw7XFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbicgPyBSLmFwcGx5IDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcXG4gIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcXG59O1xcblxcbnZhciBSZWZsZWN0T3duS2V5cztcXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XFxuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5cztcXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcXG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XFxuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xcbiAgfTtcXG59IGVsc2Uge1xcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcXG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XFxuICB9O1xcbn1cXG5cXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XFxufVxcblxcbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcXG59O1xcblxcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcXG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XFxufVxcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xcblxcbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XFxuXFxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXFxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xcbiAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gIGdldDogZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcXG4gIH0sXFxuICBzZXQ6IGZ1bmN0aW9uIChhcmcpIHtcXG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXFxcImRlZmF1bHRNYXhMaXN0ZW5lcnNcXFwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xcbiAgICB9XFxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XFxuICB9XFxufSk7XFxuXFxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbiAoKSB7XFxuXFxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHwgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XFxuICB9XFxuXFxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xcbn07XFxuXFxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXFxuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFxcXCJuXFxcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XFxuICB9XFxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcXG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcXG59XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XFxuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xcbiAgdmFyIGFyZ3MgPSBbXTtcXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcXG4gIHZhciBkb0Vycm9yID0gdHlwZSA9PT0gJ2Vycm9yJztcXG5cXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XFxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIGRvRXJyb3IgPSBkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkO2Vsc2UgaWYgKCFkb0Vycm9yKSByZXR1cm4gZmFsc2U7XFxuXFxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXFxuICBpZiAoZG9FcnJvcikge1xcbiAgICB2YXIgZXI7XFxuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIGVyID0gYXJnc1swXTtcXG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcXG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcXG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxcbiAgICB9XFxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XFxuICAgIGVyci5jb250ZXh0ID0gZXI7XFxuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcXG4gIH1cXG5cXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xcblxcbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xcblxcbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcXG4gIH0gZWxzZSB7XFxuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcXG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XFxuICB9XFxuXFxuICByZXR1cm4gdHJ1ZTtcXG59O1xcblxcbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XFxuICB2YXIgbTtcXG4gIHZhciBldmVudHM7XFxuICB2YXIgZXhpc3Rpbmc7XFxuXFxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcXFwibGlzdGVuZXJcXFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcXG4gIH1cXG5cXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcXG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XFxuICB9IGVsc2Uge1xcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcXFwibmV3TGlzdGVuZXJcXFwiISBCZWZvcmVcXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXFxcIm5ld0xpc3RlbmVyXFxcIi5cXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcXG5cXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXFxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xcbiAgICB9XFxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xcbiAgfVxcblxcbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXFxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XFxuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcXG4gIH0gZWxzZSB7XFxuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XFxuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XFxuICAgIH1cXG5cXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcXG4gICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcXG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XFxuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcXG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICsgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArICdpbmNyZWFzZSBsaW1pdCcpO1xcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcXG4gICAgICB3LnR5cGUgPSB0eXBlO1xcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XFxuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gdGFyZ2V0O1xcbn1cXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcXG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID0gZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XFxuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcXG59O1xcblxcbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xcbiAgdmFyIGFyZ3MgPSBbXTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcXG4gIGlmICghdGhpcy5maXJlZCkge1xcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcXG4gICAgdGhpcy5maXJlZCA9IHRydWU7XFxuICAgIFJlZmxlY3RBcHBseSh0aGlzLmxpc3RlbmVyLCB0aGlzLnRhcmdldCwgYXJncyk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XFxuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcXG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XFxuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XFxuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xcbiAgcmV0dXJuIHdyYXBwZWQ7XFxufVxcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFxcXCJsaXN0ZW5lclxcXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xcbiAgfVxcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID0gZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXFxcImxpc3RlbmVyXFxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XFxuICB9XFxuICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcXG4gIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xcblxcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXFxcImxpc3RlbmVyXFxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XFxuICB9XFxuXFxuICBldmVudHMgPSB0aGlzLl9ldmVudHM7XFxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzO1xcblxcbiAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcXG4gIGlmIChsaXN0ID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzO1xcblxcbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XFxuICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO2Vsc2Uge1xcbiAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcikgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xcbiAgICB9XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgIHBvc2l0aW9uID0gLTE7XFxuXFxuICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcXG4gICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xcbiAgICAgICAgcG9zaXRpb24gPSBpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChwb3NpdGlvbiA8IDApIHJldHVybiB0aGlzO1xcblxcbiAgICBpZiAocG9zaXRpb24gPT09IDApIGxpc3Quc2hpZnQoKTtlbHNlIHtcXG4gICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xcbiAgICB9XFxuXFxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcXG5cXG4gICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XFxuICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XFxuXFxuICBldmVudHMgPSB0aGlzLl9ldmVudHM7XFxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzO1xcblxcbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxcbiAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcXG4gICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XFxuICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtlbHNlIGRlbGV0ZSBldmVudHNbdHlwZV07XFxuICAgIH1cXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuXFxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XFxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcXG4gICAgdmFyIGtleTtcXG4gICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcXG4gICAgICBrZXkgPSBrZXlzW2ldO1xcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XFxuICAgIH1cXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XFxuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XFxuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuXFxuICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XFxuXFxuICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XFxuICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIC8vIExJRk8gb3JkZXJcXG4gICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XFxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcXG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcXG5cXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdO1xcblxcbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XFxuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XFxuXFxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcXG5cXG4gIHJldHVybiB1bndyYXAgPyB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcXG59XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XFxuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XFxuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcXG4gIH1cXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XFxuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XFxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xcblxcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xcblxcbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICByZXR1cm4gMTtcXG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiAwO1xcbn1cXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcXG59O1xcblxcbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XFxuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBjb3B5W2ldID0gYXJyW2ldO1xcbiAgcmV0dXJuIGNvcHk7XFxufVxcblxcbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKSBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcXG4gIGxpc3QucG9wKCk7XFxufVxcblxcbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcXG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xcbiAgfVxcbiAgcmV0dXJuIHJldDtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly9Vc2Vycy9sZW9uYXJkby9Eb2N1bWVudHMvZnJvbnQtZW5kL3BsYXllci94Z3BsYXllci9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcz9cIil9LFwiLi4veGdwbGF5ZXItYnVmZmVyL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci1idWZmZXIvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbCgnXFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBUcmFjazogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvdHJhY2sgKi8gXCIuLi94Z3BsYXllci1idWZmZXIvc3JjL3RyYWNrLmpzXCIpLmRlZmF1bHQsXFxuICBUcmFja3M6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3RyYWNrICovIFwiLi4veGdwbGF5ZXItYnVmZmVyL3NyYy90cmFjay5qc1wiKS5UcmFja3MsXFxuICBBdWRpb1RyYWNrOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy90cmFjayAqLyBcIi4uL3hncGxheWVyLWJ1ZmZlci9zcmMvdHJhY2suanNcIikuQXVkaW9UcmFjayxcXG4gIFZpZGVvVHJhY2s6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3RyYWNrICovIFwiLi4veGdwbGF5ZXItYnVmZmVyL3NyYy90cmFjay5qc1wiKS5WaWRlb1RyYWNrLFxcblxcbiAgWGdCdWZmZXI6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2J1ZmZlciAqLyBcIi4uL3hncGxheWVyLWJ1ZmZlci9zcmMvYnVmZmVyLmpzXCIpLlhnQnVmZmVyLFxcbiAgUmVtdXhCdWZmZXI6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2J1ZmZlciAqLyBcIi4uL3hncGxheWVyLWJ1ZmZlci9zcmMvYnVmZmVyLmpzXCIpLlJlbXV4QnVmZmVyLFxcblxcbiAgUHJlU291cmNlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wcmVzb3VjZSAqLyBcIi4uL3hncGxheWVyLWJ1ZmZlci9zcmMvcHJlc291Y2UuanNcIikuZGVmYXVsdFxcbn07XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLWJ1ZmZlci9pbmRleC5qcz8nKX0sXCIuLi94Z3BsYXllci1idWZmZXIvc3JjL2J1ZmZlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci1idWZmZXIvc3JjL2J1ZmZlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoJ1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5jbGFzcyBYZ0J1ZmZlciB7XFxuICAvKipcXG4gICAqIEEgYnVmZmVyIHRvIHN0b3JlIGxvYWRlZCBkYXRhLlxcbiAgICpcXG4gICAqIEBjbGFzcyBMb2FkZXJCdWZmZXJcXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggLSBPcHRpb25hbCB0aGUgYnVmZmVyIHNpemVcXG4gICAqL1xcbiAgY29uc3RydWN0b3IobGVuZ3RoKSB7XFxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoIHx8IDA7XFxuICAgIHRoaXMuaGlzdG9yeUxlbiA9IGxlbmd0aCB8fCAwO1xcbiAgICB0aGlzLmFycmF5ID0gW107XFxuICAgIHRoaXMub2Zmc2V0ID0gMDtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogVGhlIGZ1bmN0aW9uIHRvIHB1c2ggZGF0YS5cXG4gICAqXFxuICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YSAtIFRoZSBkYXRhIHRvIHB1c2ggaW50byB0aGUgYnVmZmVyXFxuICAgKi9cXG4gIHB1c2goZGF0YSkge1xcbiAgICB0aGlzLmFycmF5LnB1c2goZGF0YSk7XFxuICAgIHRoaXMubGVuZ3RoICs9IGRhdGEuYnl0ZUxlbmd0aDtcXG4gICAgdGhpcy5oaXN0b3J5TGVuICs9IGRhdGEuYnl0ZUxlbmd0aDtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogVGhlIGZ1bmN0aW9uIHRvIHNoaWZ0IGRhdGEuXFxuICAgKlxcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCAtIFRoZSBzaXplIG9mIHNoaWZ0LlxcbiAgICovXFxuICBzaGlmdChsZW5ndGgpIHtcXG4gICAgaWYgKHRoaXMuYXJyYXkubGVuZ3RoIDwgMSkge1xcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcXG4gICAgfVxcblxcbiAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fc2hpZnRCdWZmZXIoKTtcXG4gICAgfVxcbiAgICBpZiAodGhpcy5vZmZzZXQgKyBsZW5ndGggPT09IHRoaXMuYXJyYXlbMF0ubGVuZ3RoKSB7XFxuICAgICAgbGV0IHJldCA9IHRoaXMuYXJyYXlbMF0uc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICsgbGVuZ3RoKTtcXG4gICAgICB0aGlzLm9mZnNldCA9IDA7XFxuICAgICAgdGhpcy5hcnJheS5zaGlmdCgpO1xcbiAgICAgIHRoaXMubGVuZ3RoIC09IGxlbmd0aDtcXG4gICAgICByZXR1cm4gcmV0O1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLm9mZnNldCArIGxlbmd0aCA8IHRoaXMuYXJyYXlbMF0ubGVuZ3RoKSB7XFxuICAgICAgbGV0IHJldCA9IHRoaXMuYXJyYXlbMF0uc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICsgbGVuZ3RoKTtcXG4gICAgICB0aGlzLm9mZnNldCArPSBsZW5ndGg7XFxuICAgICAgdGhpcy5sZW5ndGggLT0gbGVuZ3RoO1xcbiAgICAgIHJldHVybiByZXQ7XFxuICAgIH1cXG5cXG4gICAgbGV0IHJldCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XFxuICAgIGxldCB0bXBvZmYgPSAwO1xcbiAgICB3aGlsZSAodGhpcy5hcnJheS5sZW5ndGggPiAwICYmIGxlbmd0aCA+IDApIHtcXG4gICAgICBpZiAodGhpcy5vZmZzZXQgKyBsZW5ndGggPCB0aGlzLmFycmF5WzBdLmxlbmd0aCkge1xcbiAgICAgICAgbGV0IHRtcCA9IHRoaXMuYXJyYXlbMF0uc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICsgbGVuZ3RoKTtcXG4gICAgICAgIHJldC5zZXQodG1wLCB0bXBvZmYpO1xcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xcbiAgICAgICAgdGhpcy5sZW5ndGggLT0gbGVuZ3RoO1xcbiAgICAgICAgbGVuZ3RoID0gMDtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBsZXQgdGVtcGxlbmd0aCA9IHRoaXMuYXJyYXlbMF0ubGVuZ3RoIC0gdGhpcy5vZmZzZXQ7XFxuICAgICAgICByZXQuc2V0KHRoaXMuYXJyYXlbMF0uc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMuYXJyYXlbMF0ubGVuZ3RoKSwgdG1wb2ZmKTtcXG4gICAgICAgIHRoaXMuYXJyYXkuc2hpZnQoKTtcXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcXG4gICAgICAgIHRtcG9mZiArPSB0ZW1wbGVuZ3RoO1xcbiAgICAgICAgdGhpcy5sZW5ndGggLT0gdGVtcGxlbmd0aDtcXG4gICAgICAgIGxlbmd0aCAtPSB0ZW1wbGVuZ3RoO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gcmV0O1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBGdW5jdGlvbiB0byBjbGVhciB0aGUgYnVmZmVyLlxcbiAgICovXFxuICBjbGVhcigpIHtcXG4gICAgdGhpcy5hcnJheSA9IFtdO1xcbiAgICB0aGlzLmxlbmd0aCA9IDA7XFxuICAgIHRoaXMub2Zmc2V0ID0gMDtcXG4gIH1cXG5cXG4gIGRlc3Ryb3koKSB7XFxuICAgIHRoaXMuY2xlYXIoKTtcXG4gICAgdGhpcy5oaXN0b3J5TGVuID0gMDtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogRnVuY3Rpb24gdG8gc2hpZnQgb25lIHVuaXQ4QXJyYXkuXFxuICAgKi9cXG4gIF9zaGlmdEJ1ZmZlcigpIHtcXG4gICAgdGhpcy5sZW5ndGggLT0gdGhpcy5hcnJheVswXS5sZW5ndGg7XFxuICAgIHRoaXMub2Zmc2V0ID0gMDtcXG4gICAgcmV0dXJuIHRoaXMuYXJyYXkuc2hpZnQoKTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogQ29udmVydCB1aW50OCBkYXRhIHRvIG51bWJlci5cXG4gICAqXFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSB0aGUgc3RhcnQgcG9zdGlvbi5cXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggLSB0aGUgbGVuZ3RoIG9mIGRhdGEuXFxuICAgKi9cXG4gIHRvSW50KHN0YXJ0LCBsZW5ndGgpIHtcXG4gICAgbGV0IHJldEludCA9IDA7XFxuICAgIGxldCBpID0gdGhpcy5vZmZzZXQgKyBzdGFydDtcXG4gICAgd2hpbGUgKGkgPCB0aGlzLm9mZnNldCArIGxlbmd0aCArIHN0YXJ0KSB7XFxuICAgICAgaWYgKGkgPCB0aGlzLmFycmF5WzBdLmxlbmd0aCkge1xcbiAgICAgICAgcmV0SW50ID0gcmV0SW50ICogMjU2ICsgdGhpcy5hcnJheVswXVtpXTtcXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYXJyYXlbMV0pIHtcXG4gICAgICAgIHJldEludCA9IHJldEludCAqIDI1NiArIHRoaXMuYXJyYXlbMV1baSAtIHRoaXMuYXJyYXlbMF0ubGVuZ3RoXTtcXG4gICAgICB9XFxuXFxuICAgICAgaSsrO1xcbiAgICB9XFxuICAgIHJldHVybiByZXRJbnQ7XFxuICB9XFxufVxcblxcbmV4cG9ydHMuWGdCdWZmZXIgPSBYZ0J1ZmZlcjtcXG5jbGFzcyBSZW11eEJ1ZmZlciB7XFxuICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgdGhpcy52aWRlbyA9IFtdO1xcbiAgICB0aGlzLmF1ZGlvID0gW107XFxuICB9XFxuXFxuICBkZXN0cm95KCkge1xcbiAgICB0aGlzLnZpZGVvID0gW107XFxuICAgIHRoaXMuYXVkaW8gPSBbXTtcXG4gIH1cXG59XFxuZXhwb3J0cy5SZW11eEJ1ZmZlciA9IFJlbXV4QnVmZmVyO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci1idWZmZXIvc3JjL2J1ZmZlci5qcz8nKX0sXCIuLi94Z3BsYXllci1idWZmZXIvc3JjL3ByZXNvdWNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItYnVmZmVyL3NyYy9wcmVzb3VjZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuY2xhc3MgU291cmNlIHtcXG4gIGNvbnN0cnVjdG9yKCkge1xcbiAgICB0aGlzLm1pbWV0eXBlID0gJyc7XFxuICAgIHRoaXMuaW5pdCA9IG51bGw7XFxuICAgIHRoaXMuZGF0YSA9IFtdO1xcbiAgfVxcbn1cXG5cXG5jbGFzcyBQcmVTb3VyY2Uge1xcbiAgY29uc3RydWN0b3IoKSB7XFxuICAgIHRoaXMuc291cmNlcyA9IHt9O1xcbiAgfVxcblxcbiAgZ2V0U291cmNlKHNvdXJjZSkge1xcbiAgICByZXR1cm4gdGhpcy5zb3VyY2VzW3NvdXJjZV07XFxuICB9XFxuXFxuICBjcmVhdGVTb3VyY2UobmFtZSkge1xcbiAgICB0aGlzLnNvdXJjZXNbbmFtZV0gPSBuZXcgU291cmNlKCk7XFxuICAgIHJldHVybiB0aGlzLnNvdXJjZXNbbmFtZV07XFxuICB9XFxuXFxuICBjbGVhcigpIHtcXG4gICAgdGhpcy5zb3VyY2VzID0ge307XFxuICB9XFxuXFxuICBkZXN0cm95KCkge1xcbiAgICB0aGlzLnNvdXJjZXMgPSB7fTtcXG4gIH1cXG59XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gUHJlU291cmNlO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci1idWZmZXIvc3JjL3ByZXNvdWNlLmpzP1wiKX0sXCIuLi94Z3BsYXllci1idWZmZXIvc3JjL3RyYWNrLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItYnVmZmVyL3NyYy90cmFjay5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuY2xhc3MgVHJhY2sge1xcbiAgLyoqXFxuICAgKiBUaGUgY29uc3RydWN0b3IuXFxuICAgKi9cXG4gIGNvbnN0cnVjdG9yKCkge1xcbiAgICB0aGlzLmlkID0gLTE7XFxuICAgIHRoaXMuc2VxdWVuY2VOdW1iZXIgPSAwO1xcbiAgICB0aGlzLnNhbXBsZXMgPSBbXTtcXG4gICAgdGhpcy5kcm9wcGVkU2FtcGxlcyA9IFtdO1xcbiAgICB0aGlzLmxlbmd0aCA9IDA7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIFJlc2V0IHRoZSB0cmFjay5cXG4gICAqL1xcbiAgcmVzZXQoKSB7XFxuICAgIHRoaXMuc2VxdWVuY2VOdW1iZXIgPSAwO1xcbiAgICB0aGlzLnNhbXBsZXMgPSBbXTtcXG4gICAgdGhpcy5sZW5ndGggPSAwO1xcbiAgfVxcbiAgLyoqXFxuICAgKiBkZXN0cm95IHRoZSB0cmFjay5cXG4gICAqL1xcbiAgZGlzdHJveSgpIHtcXG4gICAgdGhpcy5yZXNldCgpO1xcbiAgICB0aGlzLmlkID0gLTE7XFxuICB9XFxufVxcblxcbmV4cG9ydHMuZGVmYXVsdCA9IFRyYWNrO1xcbmNsYXNzIEF1ZGlvVHJhY2sgZXh0ZW5kcyBUcmFjayB7XFxuICAvKipcXG4gICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgYXVkaW8gdHJhY2suXFxuICAgKi9cXG4gIGNvbnN0cnVjdG9yKCkge1xcbiAgICBzdXBlcigpO1xcbiAgICB0aGlzLlRBRyA9ICdBdWRpb1RyYWNrJztcXG4gICAgdGhpcy50eXBlID0gJ2F1ZGlvJztcXG4gIH1cXG59XFxuXFxuZXhwb3J0cy5BdWRpb1RyYWNrID0gQXVkaW9UcmFjaztcXG5jbGFzcyBWaWRlb1RyYWNrIGV4dGVuZHMgVHJhY2sge1xcbiAgLyoqXFxuICAgKiBUaGUgY29uc3RydWN0b3IgZm9yIHZpZGVvIHRyYWNrLlxcbiAgICovXFxuICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgc3VwZXIoKTtcXG4gICAgdGhpcy5UQUcgPSAnVmlkZW9UcmFjayc7XFxuICAgIHRoaXMudHlwZSA9ICd2aWRlbyc7XFxuICAgIHRoaXMuZHJvcHBlZCA9IDA7XFxuICB9XFxuICAvKipcXG4gICAqIHJlc2V0IHRoZSB2aWRlbyB0cmFjay5cXG4gICAqL1xcbiAgcmVzZXQoKSB7XFxuICAgIHRoaXMuc2VxdWVuY2VOdW1iZXIgPSAwO1xcbiAgICB0aGlzLnNhbXBsZXMgPSBbXTtcXG4gICAgdGhpcy5sZW5ndGggPSAwO1xcbiAgICB0aGlzLmRyb3BwZWQgPSAwO1xcbiAgfVxcbn1cXG5cXG5leHBvcnRzLlZpZGVvVHJhY2sgPSBWaWRlb1RyYWNrO1xcbmNsYXNzIFRyYWNrcyB7XFxuICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgdGhpcy5hdWRpb1RyYWNrID0gbnVsbDtcXG4gICAgdGhpcy52aWRlb1RyYWNrID0gbnVsbDtcXG4gIH1cXG5cXG4gIGRlc3Ryb3koKSB7XFxuICAgIHRoaXMuYXVkaW9UcmFjayA9IG51bGw7XFxuICAgIHRoaXMudmlkZW9UcmFjayA9IG51bGw7XFxuICB9XFxufVxcbmV4cG9ydHMuVHJhY2tzID0gVHJhY2tzO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci1idWZmZXIvc3JjL3RyYWNrLmpzP1wiKX0sXCIuLi94Z3BsYXllci1jb2RlYy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci1jb2RlYy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoJ1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgTmFsdW5pdDogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvaDI2NC9uYWx1bml0ICovIFwiLi4veGdwbGF5ZXItY29kZWMvc3JjL2gyNjQvbmFsdW5pdC9pbmRleC5qc1wiKS5kZWZhdWx0LFxcbiAgU3BzUGFyc2VyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9oMjY0L25hbHVuaXQvc3BzICovIFwiLi4veGdwbGF5ZXItY29kZWMvc3JjL2gyNjQvbmFsdW5pdC9zcHMuanNcIikuZGVmYXVsdCxcXG5cXG4gIENvbXBhdGliaWxpdHk6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2NvbXBhdGliaWxpdHkgKi8gXCIuLi94Z3BsYXllci1jb2RlYy9zcmMvY29tcGF0aWJpbGl0eS5qc1wiKS5kZWZhdWx0XFxufTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItY29kZWMvaW5kZXguanM/Jyl9LFwiLi4veGdwbGF5ZXItY29kZWMvc3JjL2FhYy9hYWMtaGVscGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci1jb2RlYy9zcmMvYWFjL2FhYy1oZWxwZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbCgnXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbmNsYXNzIEFBQyB7XFxuXFxuICBzdGF0aWMgZ2V0U2lsZW50RnJhbWUoY29kZWMsIGNoYW5uZWxDb3VudCkge1xcbiAgICBpZiAoY29kZWMgPT09IFxcJ21wNGEuNDAuMlxcJykge1xcbiAgICAgIC8vIGhhbmRsZSBMQy1BQUNcXG4gICAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjMsIDB4ODBdKTtcXG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDIxLCAweDAwLCAweDQ5LCAweDkwLCAweDAyLCAweDE5LCAweDAwLCAweDIzLCAweDgwXSk7XFxuICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4ZV0pO1xcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA0KSB7XFxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODAsIDB4MmMsIDB4ODAsIDB4MDgsIDB4MDIsIDB4MzhdKTtcXG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNSkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDM4XSk7XFxuICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDYpIHtcXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgwMCwgMHhiMiwgMHgwMCwgMHgyMCwgMHgwOCwgMHhlMF0pO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBoYW5kbGUgSEUtQUFDIChtcDRhLjQwLjUgLyBtcDRhLjQwLjI5KVxcbiAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcXG4gICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lIFxcJzE2LzEgXCIweCV4LFwiIFwiXFxcXG5cIlxcJyAtdiBvdXRwdXQuYWFjXFxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg0ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDFjLCAweDYsIDB4ZjEsIDB4YzEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XFxuICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lIFxcJzE2LzEgXCIweCV4LFwiIFwiXFxcXG5cIlxcJyAtdiBvdXRwdXQuYWFjXFxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcXG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xcbiAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MHwwfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lIFxcJzE2LzEgXCIweCV4LFwiIFwiXFxcXG5cIlxcJyAtdiBvdXRwdXQuYWFjXFxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIG51bGw7XFxuICB9XFxuXFxufVxcblxcbmV4cG9ydHMuZGVmYXVsdCA9IEFBQztcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItY29kZWMvc3JjL2FhYy9hYWMtaGVscGVyLmpzPycpfSxcIi4uL3hncGxheWVyLWNvZGVjL3NyYy9jb21wYXRpYmlsaXR5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLWNvZGVjL3NyYy9jb21wYXRpYmlsaXR5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIF94Z3BsYXllclV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgeGdwbGF5ZXItdXRpbHMgKi8gXFxcIi4uL3hncGxheWVyLXV0aWxzL2luZGV4LmpzXFxcIik7XFxuXFxudmFyIF9hYWNIZWxwZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FhYy9hYWMtaGVscGVyICovIFxcXCIuLi94Z3BsYXllci1jb2RlYy9zcmMvYWFjL2FhYy1oZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgX2FhY0hlbHBlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hYWNIZWxwZXIpO1xcblxcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFxuY29uc3QgeyBSRU1VWF9FVkVOVFMsIERFTVVYX0VWRU5UUyB9ID0gX3hncGxheWVyVXRpbHMuRVZFTlRTO1xcblxcbmNsYXNzIENvbXBhdGliaWxpdHkge1xcbiAgY29uc3RydWN0b3IoKSB7XFxuICAgIHRoaXMubmV4dEF1ZGlvRHRzID0gMDsgLy8g5qih5ouf5LiL5LiA5q616Z+z6aKR5pWw5o2u55qEZHRzXFxuICAgIHRoaXMubmV4dFZpZGVvRHRzID0gMDsgLy8g5qih5ouf5LiL5LiA5q616KeG6aKR5pWw5o2u55qEZHRzXFxuXFxuICAgIHRoaXMubGFzdEF1ZGlvU2FtcGxlc0xlbiA9IDA7IC8vIOS4iuS4gOautemfs+mikeaVsOaNrueahOmVv+W6plxcbiAgICB0aGlzLmxhc3RWaWRlb1NhbXBsZXNMZW4gPSAwOyAvLyDkuIrkuIDmrrXop4bpopHmlbDmja7nmoTplb/luqZcXG5cXG4gICAgdGhpcy5sYXN0VmlkZW9EdHMgPSB1bmRlZmluZWQ7IC8vIOS4iuS4gOautemfs+mikeaVsOaNrueahOmVv+W6plxcbiAgICB0aGlzLmxhc3RBdWRpb0R0cyA9IHVuZGVmaW5lZDsgLy8g5LiK5LiA5q616KeG6aKR5pWw5o2u55qE6ZW/5bqmXFxuXFxuICAgIHRoaXMuYWxsQXVkaW9TYW1wbGVzQ291bnQgPSAwOyAvLyDpn7PpopHmgLvmlbDmja7ph48o5Y6f5aeL5binKVxcbiAgICB0aGlzLmFsbFZpZGVvU2FtcGxlc0NvdW50ID0gMDsgLy8g6KeG6aKR5oC75pWw5o2u6YePKOWOn+Wni+W4pylcXG5cXG4gICAgdGhpcy5fZmlyc3RBdWRpb1NhbXBsZSA9IG51bGw7XFxuICAgIHRoaXMuX2ZpcnN0VmlkZW9TYW1wbGUgPSBudWxsO1xcblxcbiAgICB0aGlzLmZpbGxlZEF1ZGlvU2FtcGxlcyA9IFtdOyAvLyDooaXlhYXpn7PpopHluKfvvIjvvIlcXG4gICAgdGhpcy5maWxsZWRWaWRlb1NhbXBsZXMgPSBbXTsgLy8g6KGl5YWF6KeG6aKR5bin77yI77yJXFxuXFxuICAgIHRoaXMuX3ZpZGVvTGFyZ2VHYXAgPSAwO1xcbiAgICB0aGlzLl9hdWRpb0xhcmdlR2FwID0gMDtcXG4gIH1cXG5cXG4gIGluaXQoKSB7XFxuICAgIHRoaXMuYmVmb3JlKFJFTVVYX0VWRU5UUy5SRU1VWF9NRURJQSwgdGhpcy5kb0ZpeC5iaW5kKHRoaXMpKTtcXG4gIH1cXG5cXG4gIHJlc2V0KCkge1xcbiAgICB0aGlzLm5leHRBdWRpb0R0cyA9IG51bGw7IC8vIOS8sOeul+S4i+S4gOautemfs+mikeaVsOaNrueahGR0c1xcbiAgICB0aGlzLm5leHRWaWRlb0R0cyA9IG51bGw7IC8vIOS8sOeul+S4i+S4gOauteinhumikeaVsOaNrueahGR0c1xcblxcbiAgICB0aGlzLmxhc3RBdWRpb1NhbXBsZXNMZW4gPSAwOyAvLyDkuIrkuIDmrrXpn7PpopHmlbDmja7nmoTplb/luqZcXG4gICAgdGhpcy5sYXN0VmlkZW9TYW1wbGVzTGVuID0gMDsgLy8g5LiK5LiA5q616KeG6aKR5pWw5o2u55qE6ZW/5bqmXFxuXFxuICAgIHRoaXMubGFzdFZpZGVvRHRzID0gdW5kZWZpbmVkOyAvLyDkuIrkuIDmrrXpn7PpopHmlbDmja7nmoTplb/luqZcXG4gICAgdGhpcy5sYXN0QXVkaW9EdHMgPSB1bmRlZmluZWQ7IC8vIOS4iuS4gOauteinhumikeaVsOaNrueahOmVv+W6plxcblxcbiAgICAvLyB0aGlzLmFsbEF1ZGlvU2FtcGxlc0NvdW50ID0gMCAvLyDpn7PpopHmgLvmlbDmja7ph48o5Y6f5aeL5binKVxcbiAgICAvLyB0aGlzLmFsbFZpZGVvU2FtcGxlc0NvdW50ID0gMCAvLyDop4bpopHmgLvmlbDmja7ph48o5Y6f5aeL5binKVxcblxcbiAgICAvLyB0aGlzLl9maXJzdEF1ZGlvU2FtcGxlID0gbnVsbFxcbiAgICAvLyB0aGlzLl9maXJzdFZpZGVvU2FtcGxlID0gbnVsbFxcblxcbiAgICB0aGlzLmZpbGxlZEF1ZGlvU2FtcGxlcyA9IFtdOyAvLyDooaXlhYXpn7PpopHluKfvvIjvvIlcXG4gICAgdGhpcy5maWxsZWRWaWRlb1NhbXBsZXMgPSBbXTsgLy8g6KGl5YWF6KeG6aKR5bin77yI77yJXFxuICB9XFxuXFxuICBkb0ZpeCgpIHtcXG4gICAgY29uc3QgeyBpc0ZpcnN0QXVkaW9TYW1wbGVzLCBpc0ZpcnN0VmlkZW9TYW1wbGVzIH0gPSB0aGlzLmdldEZpcnN0U2FtcGxlKCk7XFxuXFxuICAgIC8vIHRoaXMucmVtb3ZlSW52YWxpZFNhbXBsZXMoKVxcblxcbiAgICB0aGlzLnJlY29yZFNhbXBsZXNDb3VudCgpO1xcblxcbiAgICBpZiAodGhpcy5fZmlyc3RWaWRlb1NhbXBsZSkge1xcbiAgICAgIHRoaXMuZml4UmVmU2FtcGxlRHVyYXRpb24odGhpcy52aWRlb1RyYWNrLm1ldGEsIHRoaXMudmlkZW9UcmFjay5zYW1wbGVzKTtcXG4gICAgfVxcbiAgICBpZiAodGhpcy5fZmlyc3RBdWRpb1NhbXBsZSkge1xcbiAgICAgIHRoaXMuZml4UmVmU2FtcGxlRHVyYXRpb24odGhpcy5hdWRpb1RyYWNrLm1ldGEsIHRoaXMuYXVkaW9UcmFjay5zYW1wbGVzKTtcXG4gICAgfVxcblxcbiAgICBjb25zdCB7IGNoYW5nZWQ6IHZpZGVvQ2hhbmdlZCwgY2hhbmdlZElkeDogdmlkZW9DaGFuZ2VkSWR4IH0gPSBDb21wYXRpYmlsaXR5LmRldGFjdENoYW5nZVN0cmVhbSh0aGlzLnZpZGVvVHJhY2suc2FtcGxlcyk7XFxuICAgIGlmICh2aWRlb0NoYW5nZWQgJiYgIWlzRmlyc3RBdWRpb1NhbXBsZXMpIHtcXG4gICAgICB0aGlzLmZpeENoYW5nZVN0cmVhbVZpZGVvKHZpZGVvQ2hhbmdlZElkeCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhpcy5kb0ZpeFZpZGVvKGlzRmlyc3RWaWRlb1NhbXBsZXMpO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHsgY2hhbmdlZDogYXVkaW9DaGFuZ2VkLCBjaGFuZ2VkSWR4OiBhdWRpb0NoYW5nZWRJZHggfSA9IENvbXBhdGliaWxpdHkuZGV0YWN0Q2hhbmdlU3RyZWFtKHRoaXMuYXVkaW9UcmFjay5zYW1wbGVzKTtcXG4gICAgaWYgKGF1ZGlvQ2hhbmdlZCkge1xcbiAgICAgIHRoaXMuZml4Q2hhbmdlU3RyZWFtQXVkaW8oYXVkaW9DaGFuZ2VkSWR4KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLmRvRml4QXVkaW8oaXNGaXJzdEF1ZGlvU2FtcGxlcyk7XFxuICAgIH1cXG5cXG4gICAgLy8gdGhpcy5yZW1vdmVJbnZhbGlkU2FtcGxlcygpXFxuICB9XFxuXFxuICBkb0ZpeFZpZGVvKGZpcnN0LCBzdHJlYW1DaGFuZ2VTdGFydCkge1xcbiAgICBsZXQgeyBzYW1wbGVzOiB2aWRlb1NhbXBsZXMsIG1ldGEgfSA9IHRoaXMudmlkZW9UcmFjaztcXG5cXG4gICAgaWYgKG1ldGEuZnJhbWVSYXRlICYmIG1ldGEuZnJhbWVSYXRlLmZpeGVkID09PSBmYWxzZSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAoIXZpZGVvU2FtcGxlcyB8fCAhdmlkZW9TYW1wbGVzLmxlbmd0aCB8fCAhdGhpcy5fZmlyc3RWaWRlb1NhbXBsZSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICAvLyBjb25zb2xlLmxvZyhgdmlkZW8gbGFzdFNhbXBsZSwgJHt2aWRlb1NhbXBsZXNbdmlkZW9TYW1wbGVzLmxlbmd0aCAtIDFdLmR0c31gKVxcblxcbiAgICBjb25zdCBmaXJzdFNhbXBsZSA9IHZpZGVvU2FtcGxlc1swXTtcXG5cXG4gICAgY29uc3Qgc2FtcGxlc0xlbiA9IHZpZGVvU2FtcGxlcy5sZW5ndGg7XFxuXFxuICAgIC8vIHN0ZXAwLuS/ruWkjWhsc+a1geWHuueOsOW3qOWkp2dhcO+8jOmcgOimgeW8uuWItumHjeWumuS9jeeahOmXrumimFxcbiAgICBpZiAodGhpcy5fdmlkZW9MYXJnZUdhcCA+IDApIHtcXG4gICAgICBDb21wYXRpYmlsaXR5LmRvRml4TGFyZ2VHYXAodmlkZW9TYW1wbGVzLCB0aGlzLl92aWRlb0xhcmdlR2FwKTtcXG4gICAgfVxcblxcbiAgICBpZiAoZmlyc3RTYW1wbGUuZHRzICE9PSB0aGlzLl9maXJzdFZpZGVvU2FtcGxlLmR0cyAmJiAoc3RyZWFtQ2hhbmdlU3RhcnQgfHwgQ29tcGF0aWJpbGl0eS5kZXRlY3RMYXJnZUdhcCh0aGlzLm5leHRWaWRlb0R0cywgZmlyc3RTYW1wbGUpKSkge1xcbiAgICAgIGlmIChzdHJlYW1DaGFuZ2VTdGFydCkge1xcbiAgICAgICAgdGhpcy5uZXh0VmlkZW9EdHMgPSBzdHJlYW1DaGFuZ2VTdGFydDsgLy8gRklYOiBIbHPkuK3pgJTliIdjb2RlY++8jOWcqOWmguaenOebtOaOpXNlZWvliLDlkI7pnaLnmoTngrnkvJrlr7zoh7RsYXJnZUdhcOiuoeeul+Wksei0pVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl92aWRlb0xhcmdlR2FwID0gdGhpcy5uZXh0VmlkZW9EdHMgLSBmaXJzdFNhbXBsZS5kdHM7XFxuICAgICAgQ29tcGF0aWJpbGl0eS5kb0ZpeExhcmdlR2FwKHZpZGVvU2FtcGxlcywgdGhpcy5fdmlkZW9MYXJnZUdhcCk7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgZmlyc3REdHMgPSBmaXJzdFNhbXBsZS5kdHM7XFxuXFxuICAgIC8vIHN0ZXAxLiDkv67lpI3kuI5hdWRpb+mmluW4p+W3rui3neWkquWkp+eahOmXrumimFxcbiAgICBpZiAoZmlyc3QgJiYgdGhpcy5fZmlyc3RBdWRpb1NhbXBsZSkge1xcbiAgICAgIGNvbnN0IHZpZGVvRmlyc3REdHMgPSB0aGlzLl9maXJzdFZpZGVvU2FtcGxlLmR0cztcXG4gICAgICBjb25zdCBhdWRpb0ZpcnN0RHRzID0gdGhpcy5fZmlyc3RBdWRpb1NhbXBsZS5kdHM7XFxuICAgICAgY29uc3QgZ2FwID0gdmlkZW9GaXJzdER0cyAtIGF1ZGlvRmlyc3REdHM7XFxuICAgICAgaWYgKGdhcCA+IDIgKiBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uKSB7XFxuICAgICAgICBjb25zdCBmaWxsQ291bnQgPSBNYXRoLmZsb29yKGdhcCAvIG1ldGEucmVmU2FtcGxlRHVyYXRpb24pO1xcblxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxsQ291bnQ7IGkrKykge1xcbiAgICAgICAgICBjb25zdCBjbG9uZWRGaXJzdFNhbXBsZSA9IE9iamVjdC5hc3NpZ24oe30sIGZpcnN0U2FtcGxlKTsgLy8g6KeG6aKR5aS06YOo5bin57y65aSx6ZyA6KaB5aSN5Yi256ys5LiA5binXFxuICAgICAgICAgIC8vIOmHjeaWsOiuoeeul3NhbXBsZeeahGR0c+WSjHB0c1xcbiAgICAgICAgICBjbG9uZWRGaXJzdFNhbXBsZS5kdHMgPSB2aWRlb0ZpcnN0RHRzIC0gKGkgKyAxKSAqIG1ldGEucmVmU2FtcGxlRHVyYXRpb247XFxuICAgICAgICAgIGNsb25lZEZpcnN0U2FtcGxlLnB0cyA9IGNsb25lZEZpcnN0U2FtcGxlLmR0cyArIGNsb25lZEZpcnN0U2FtcGxlLmN0cztcXG5cXG4gICAgICAgICAgdmlkZW9TYW1wbGVzLnVuc2hpZnQoY2xvbmVkRmlyc3RTYW1wbGUpO1xcblxcbiAgICAgICAgICB0aGlzLmZpbGxlZFZpZGVvU2FtcGxlcy5wdXNoKHtcXG4gICAgICAgICAgICBkdHM6IGNsb25lZEZpcnN0U2FtcGxlLmR0cyxcXG4gICAgICAgICAgICBzaXplOiBjbG9uZWRGaXJzdFNhbXBsZS5kYXRhLmJ5dGVMZW5ndGhcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGxldCBnYXA7XFxuICAgIC8vIHN0ZXAyLiDkv67lpI1zYW1wbGVz5q615LmL6Ze055qE6Ze06Led6Zeu6aKY44CBXFxuICAgIGlmICh0aGlzLm5leHRWaWRlb0R0cykge1xcbiAgICAgIC8vIHN0ZXAxLiDlpITnkIZzYW1wbGVz5q615LmL6Ze055qE5Lii5bin5oOF5Ya1XFxuICAgICAgLy8g5b2T5Y+R546wZHVyYXRpb27lt67ot53lpKfkuo4y5bin5pe26L+b6KGM6KGl5binXFxuICAgICAgZ2FwID0gZmlyc3REdHMgLSB0aGlzLm5leHRWaWRlb0R0cztcXG4gICAgICBjb25zdCBhYnNHYXAgPSBNYXRoLmFicyhnYXApO1xcbiAgICAgIGlmIChnYXAgPiAyICogbWV0YS5yZWZTYW1wbGVEdXJhdGlvbikge1xcbiAgICAgICAgY29uc3QgZmlsbEZyYW1lQ291bnQgPSBNYXRoLmZsb29yKGdhcCAvIG1ldGEucmVmU2FtcGxlRHVyYXRpb24pO1xcblxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxsRnJhbWVDb3VudDsgaSsrKSB7XFxuICAgICAgICAgIGNvbnN0IGNsb25lZFNhbXBsZSA9IE9iamVjdC5hc3NpZ24oe30sIHZpZGVvU2FtcGxlc1swXSk7XFxuICAgICAgICAgIGNvbnN0IGNvbXB1dGVkID0gZmlyc3REdHMgLSAoaSArIDEpICogbWV0YS5yZWZTYW1wbGVEdXJhdGlvbjtcXG5cXG4gICAgICAgICAgY2xvbmVkU2FtcGxlLmR0cyA9IGNvbXB1dGVkID4gdGhpcy5uZXh0VmlkZW9EdHMgPyBjb21wdXRlZCA6IHRoaXMubmV4dFZpZGVvRHRzOyAvLyDooaXnmoTnrKzkuIDluKfkuIDlrpropoHmmK9uZXh0VmlkZW9EdHNcXG4gICAgICAgICAgY2xvbmVkU2FtcGxlLnB0cyA9IGNsb25lZFNhbXBsZS5kdHMgKyBjbG9uZWRTYW1wbGUuY3RzO1xcblxcbiAgICAgICAgICB0aGlzLnZpZGVvVHJhY2suc2FtcGxlcy51bnNoaWZ0KGNsb25lZFNhbXBsZSk7XFxuXFxuICAgICAgICAgIHRoaXMuZmlsbGVkVmlkZW9TYW1wbGVzLnB1c2goe1xcbiAgICAgICAgICAgIGR0czogY2xvbmVkU2FtcGxlLmR0cyxcXG4gICAgICAgICAgICBzaXplOiBjbG9uZWRTYW1wbGUuZGF0YS5ieXRlTGVuZ3RoXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAoYWJzR2FwIDw9IG1ldGEucmVmU2FtcGxlRHVyYXRpb24gJiYgYWJzR2FwID4gMCkge1xcbiAgICAgICAgLy8g5b2T5beu6Led5ZyoKy3kuIDluKfkuYvpl7Tml7blsIbnrKzkuIDluKfnmoRkdHPlvLrooYzlrprkvY3liLDmnJ/mnJvkvY3nva5cXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCfph43lrprkvY3op4bpopHluKdkdHMnLCB2aWRlb1NhbXBsZXNbMF0uZHRzLCB0aGlzLm5leHRWaWRlb0R0cylcXG4gICAgICAgIHZpZGVvU2FtcGxlc1swXS5kdHMgPSB0aGlzLm5leHRWaWRlb0R0cztcXG4gICAgICAgIHZpZGVvU2FtcGxlc1swXS5vcmlnaW5EdHMgPSB2aWRlb1NhbXBsZXNbMF0uZHRzO1xcbiAgICAgICAgdmlkZW9TYW1wbGVzWzBdLmN0cyA9IHZpZGVvU2FtcGxlc1swXS5jdHMgIT09IHVuZGVmaW5lZCA/IHZpZGVvU2FtcGxlc1swXS5jdHMgOiB2aWRlb1NhbXBsZXNbMF0ucHRzIC0gdmlkZW9TYW1wbGVzWzBdLmR0cztcXG4gICAgICAgIHZpZGVvU2FtcGxlc1swXS5wdHMgPSB2aWRlb1NhbXBsZXNbMF0uZHRzICsgdmlkZW9TYW1wbGVzWzBdLmN0cztcXG4gICAgICB9IGVsc2UgaWYgKGdhcCA8IDApIHtcXG4gICAgICAgIC8vIOWHuueOsOWkp+eahGdhcFxcbiAgICAgICAgQ29tcGF0aWJpbGl0eS5kb0ZpeExhcmdlR2FwKHZpZGVvU2FtcGxlcywgLTEgKiBnYXApO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBjb25zdCBsYXN0RHRzID0gdmlkZW9TYW1wbGVzW3ZpZGVvU2FtcGxlcy5sZW5ndGggLSAxXS5kdHM7XFxuXFxuICAgIGNvbnN0IGxhc3RTYW1wbGVEdXJhdGlvbiA9IHZpZGVvU2FtcGxlcy5sZW5ndGggPj0gMiA/IGxhc3REdHMgLSB2aWRlb1NhbXBsZXNbdmlkZW9TYW1wbGVzLmxlbmd0aCAtIDJdLmR0cyA6IG1ldGEucmVmU2FtcGxlRHVyYXRpb247XFxuXFxuICAgIHRoaXMubGFzdFZpZGVvU2FtcGxlc0xlbiA9IHNhbXBsZXNMZW47XFxuICAgIHRoaXMubmV4dFZpZGVvRHRzID0gbGFzdER0cyArIGxhc3RTYW1wbGVEdXJhdGlvbjtcXG4gICAgdGhpcy5sYXN0VmlkZW9EdHMgPSBsYXN0RHRzO1xcblxcbiAgICAvLyBzdGVwMi4g5L+u5aSNc2FtcGxl5q615LmL5YaF55qE6Ze06Led6Zeu6aKYXFxuICAgIC8vIHN0ZXAzLiDkv67lpI1zYW1wbGVz5q615YaF6YOo55qEZHRz5byC5bi46Zeu6aKYXFxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2aWRlb1NhbXBsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICBjb25zdCBjdXJyZW50ID0gdmlkZW9TYW1wbGVzW2ldO1xcbiAgICAgIGNvbnN0IG5leHQgPSB2aWRlb1NhbXBsZXNbaSArIDFdO1xcblxcbiAgICAgIGlmICghbmV4dCkge1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gbmV4dC5kdHMgLSBjdXJyZW50LmR0cztcXG5cXG4gICAgICBpZiAoZHVyYXRpb24gPiAyICogbWV0YS5yZWZTYW1wbGVEdXJhdGlvbikge1xcbiAgICAgICAgLy8g5Lik5bin5LmL6Ze06Ze06ZqU5aSq5aSn77yM6ZyA6KaB6KGl56m655m95binXFxuICAgICAgICBsZXQgZmlsbEZyYW1lQ291bnQgPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gbWV0YS5yZWZTYW1wbGVEdXJhdGlvbik7XFxuXFxuICAgICAgICBsZXQgZmlsbEZyYW1lSWR4ID0gMDtcXG4gICAgICAgIHdoaWxlIChmaWxsRnJhbWVJZHggPCBmaWxsRnJhbWVDb3VudCkge1xcbiAgICAgICAgICBjb25zdCBmaWxsRnJhbWUgPSBPYmplY3QuYXNzaWduKHt9LCBuZXh0KTtcXG4gICAgICAgICAgZmlsbEZyYW1lLmR0cyA9IGN1cnJlbnQuZHRzICsgKGZpbGxGcmFtZUlkeCArIDEpICogbWV0YS5yZWZTYW1wbGVEdXJhdGlvbjtcXG4gICAgICAgICAgZmlsbEZyYW1lLnB0cyA9IGZpbGxGcmFtZS5kdHMgKyBmaWxsRnJhbWUuY3RzO1xcbiAgICAgICAgICBpZiAoZmlsbEZyYW1lIDwgbmV4dC5kdHMpIHtcXG4gICAgICAgICAgICB2aWRlb1NhbXBsZXMuc3BsaWNlKGksIDAsIGZpbGxGcmFtZSk7XFxuXFxuICAgICAgICAgICAgdGhpcy5maWxsZWRWaWRlb1NhbXBsZXMucHVzaCh7XFxuICAgICAgICAgICAgICBkdHM6IGZpbGxGcmFtZS5kdHMsXFxuICAgICAgICAgICAgICBzaXplOiBmaWxsRnJhbWUuZGF0YS5ieXRlTGVuZ3RoXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZmlsbEZyYW1lSWR4Kys7XFxuICAgICAgICAgIGkrKztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdGhpcy52aWRlb1RyYWNrLnNhbXBsZXMgPSB2aWRlb1NhbXBsZXM7XFxuICB9XFxuXFxuICBkb0ZpeEF1ZGlvKGZpcnN0LCBzdHJlYW1DaGFuZ2VTdGFydCkge1xcbiAgICBsZXQgeyBzYW1wbGVzOiBhdWRpb1NhbXBsZXMsIG1ldGEgfSA9IHRoaXMuYXVkaW9UcmFjaztcXG5cXG4gICAgaWYgKCFhdWRpb1NhbXBsZXMgfHwgIWF1ZGlvU2FtcGxlcy5sZW5ndGgpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgLy8gY29uc29sZS5sb2coYGF1ZGlvIGxhc3RTYW1wbGUsICR7YXVkaW9TYW1wbGVzW2F1ZGlvU2FtcGxlcy5sZW5ndGggLSAxXS5kdHN9YClcXG5cXG4gICAgY29uc3Qgc2FtcGxlc0xlbiA9IGF1ZGlvU2FtcGxlcy5sZW5ndGg7XFxuICAgIGNvbnN0IHNpbGVudEZyYW1lID0gX2FhY0hlbHBlcjIuZGVmYXVsdC5nZXRTaWxlbnRGcmFtZShtZXRhLmNvZGVjLCBtZXRhLmNoYW5uZWxDb3VudCk7XFxuXFxuICAgIGNvbnN0IGZpcnN0U2FtcGxlID0gdGhpcy5fZmlyc3RBdWRpb1NhbXBsZTtcXG5cXG4gICAgY29uc3QgX2ZpcnN0U2FtcGxlID0gYXVkaW9TYW1wbGVzWzBdO1xcbiAgICAvLyDlr7lhdWRpb1NhbXBsZXPmjInnhadkdHPlgZrmjpLluo9cXG4gICAgLy8gYXVkaW9TYW1wbGVzID0gQ29tcGF0aWJpbGl0eS5zb3J0QXVkaW9TYW1wbGVzKGF1ZGlvU2FtcGxlcylcXG4gICAgaWYgKHRoaXMuX2F1ZGlvTGFyZ2VHYXAgPiAwKSB7XFxuICAgICAgQ29tcGF0aWJpbGl0eS5kb0ZpeExhcmdlR2FwKGF1ZGlvU2FtcGxlcywgdGhpcy5fYXVkaW9MYXJnZUdhcCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKF9maXJzdFNhbXBsZS5kdHMgIT09IHRoaXMuX2ZpcnN0QXVkaW9TYW1wbGUuZHRzICYmIChzdHJlYW1DaGFuZ2VTdGFydCB8fCBDb21wYXRpYmlsaXR5LmRldGVjdExhcmdlR2FwKHRoaXMubmV4dEF1ZGlvRHRzLCBfZmlyc3RTYW1wbGUpKSkge1xcbiAgICAgIGlmIChzdHJlYW1DaGFuZ2VTdGFydCkge1xcbiAgICAgICAgdGhpcy5uZXh0QXVkaW9EdHMgPSBzdHJlYW1DaGFuZ2VTdGFydDsgLy8gRklYOiBIbHPkuK3pgJTliIdjb2RlY++8jOWcqOWmguaenOebtOaOpXNlZWvliLDlkI7pnaLnmoTngrnkvJrlr7zoh7RsYXJnZUdhcOiuoeeul+Wksei0pVxcbiAgICAgIH1cXG4gICAgICB0aGlzLl9hdWRpb0xhcmdlR2FwID0gdGhpcy5uZXh0QXVkaW9EdHMgLSBfZmlyc3RTYW1wbGUuZHRzO1xcbiAgICAgIENvbXBhdGliaWxpdHkuZG9GaXhMYXJnZUdhcChhdWRpb1NhbXBsZXMsIHRoaXMuX2F1ZGlvTGFyZ2VHYXApO1xcbiAgICB9XFxuICAgIC8vIHN0ZXAwLiDpppbluKfkuI52aWRlb+mmluW4p+mXtOi3neWkp+eahOmXrumimFxcbiAgICBpZiAodGhpcy5fZmlyc3RWaWRlb1NhbXBsZSAmJiBmaXJzdCkge1xcbiAgICAgIGNvbnN0IHZpZGVvRmlyc3RQdHMgPSB0aGlzLl9maXJzdFZpZGVvU2FtcGxlLnB0cyA/IHRoaXMuX2ZpcnN0VmlkZW9TYW1wbGUucHRzIDogdGhpcy5fZmlyc3RWaWRlb1NhbXBsZS5kdHMgKyB0aGlzLl9maXJzdFZpZGVvU2FtcGxlLmN0cztcXG5cXG4gICAgICBpZiAoZmlyc3RTYW1wbGUuZHRzIC0gdmlkZW9GaXJzdFB0cyA+IG1ldGEucmVmU2FtcGxlRHVyYXRpb24pIHtcXG4gICAgICAgIGNvbnN0IHNpbGVudFNhbXBsZUNvdW50ID0gTWF0aC5mbG9vcigoZmlyc3RTYW1wbGUuZHRzIC0gdmlkZW9GaXJzdFB0cykgLyBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uKTtcXG5cXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lsZW50U2FtcGxlQ291bnQ7IGkrKykge1xcbiAgICAgICAgICBjb25zdCBzaWxlbnRTYW1wbGUgPSB7XFxuICAgICAgICAgICAgZGF0YTogc2lsZW50RnJhbWUsXFxuICAgICAgICAgICAgZGF0YXNpemU6IHNpbGVudEZyYW1lLmJ5dGVMZW5ndGgsXFxuICAgICAgICAgICAgZHRzOiBmaXJzdFNhbXBsZS5kdHMgLSAoaSArIDEpICogbWV0YS5yZWZTYW1wbGVEdXJhdGlvbixcXG4gICAgICAgICAgICBmaWx0ZXJlZDogMFxcbiAgICAgICAgICB9O1xcblxcbiAgICAgICAgICBhdWRpb1NhbXBsZXMudW5zaGlmdChzaWxlbnRTYW1wbGUpO1xcblxcbiAgICAgICAgICB0aGlzLmZpbGxlZEF1ZGlvU2FtcGxlcy5wdXNoKHtcXG4gICAgICAgICAgICBkdHM6IHNpbGVudFNhbXBsZS5kdHMsXFxuICAgICAgICAgICAgc2l6ZTogc2lsZW50U2FtcGxlLmRhdGEuYnl0ZUxlbmd0aFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgbGV0IGdhcDtcXG4gICAgY29uc3QgZmlyc3REdHMgPSBhdWRpb1NhbXBsZXNbMF0uZHRzO1xcblxcbiAgICBpZiAodGhpcy5uZXh0QXVkaW9EdHMpIHtcXG4gICAgICAvLyBzdGVwMS4g5aSE55CGc2FtcGxlc+auteS5i+mXtOeahOS4ouW4p+aDheWGtVxcbiAgICAgIC8vIOW9k+WPkeeOsGR1cmF0aW9u5beu6Led5aSn5LqOMeW4p+aXtui/m+ihjOihpeW4p1xcbiAgICAgIGdhcCA9IGZpcnN0RHRzIC0gdGhpcy5uZXh0QXVkaW9EdHM7XFxuICAgICAgY29uc3QgYWJzR2FwID0gTWF0aC5hYnMoZ2FwKTtcXG5cXG4gICAgICBpZiAoYWJzR2FwID4gbWV0YS5yZWZTYW1wbGVEdXJhdGlvbiAmJiBzYW1wbGVzTGVuID09PSAxICYmIHRoaXMubGFzdEF1ZGlvU2FtcGxlc0xlbiA9PT0gMSkge1xcbiAgICAgICAgbWV0YS5yZWZTYW1wbGVEdXJhdGlvbkZpeGVkID0gdW5kZWZpbmVkO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZ2FwID4gMiAqIG1ldGEucmVmU2FtcGxlRHVyYXRpb24pIHtcXG4gICAgICAgIGlmIChzYW1wbGVzTGVuID09PSAxICYmIHRoaXMubGFzdEF1ZGlvU2FtcGxlc0xlbiA9PT0gMSkge1xcbiAgICAgICAgICAvLyDlpoLmnpxzYW1wbGXnmoRsZW5ndGjkuIDnm7TmmK8x77yM6ICM5LiU5LiA55u05LiN56ym5ZCIcmVmU2FtcGxlRHVyYXRpb27vvIzpnIDopoHliqjmgIHkv67mlLlyZWZTYW1wbGVEdXJhdGlvblxcbiAgICAgICAgICBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uRml4ZWQgPSBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uRml4ZWQgIT09IHVuZGVmaW5lZCA/IG1ldGEucmVmU2FtcGxlRHVyYXRpb25GaXhlZCArIGdhcCA6IG1ldGEucmVmU2FtcGxlRHVyYXRpb24gKyBnYXA7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBjb25zdCBzaWxlbnRGcmFtZUNvdW50ID0gTWF0aC5mbG9vcihnYXAgLyBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uKTtcXG5cXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWxlbnRGcmFtZUNvdW50OyBpKyspIHtcXG4gICAgICAgICAgICBjb25zdCBjb21wdXRlZCA9IGZpcnN0RHRzIC0gKGkgKyAxKSAqIG1ldGEucmVmU2FtcGxlRHVyYXRpb247XFxuICAgICAgICAgICAgY29uc3Qgc2lsZW50U2FtcGxlID0gT2JqZWN0LmFzc2lnbih7fSwgYXVkaW9TYW1wbGVzWzBdLCB7XFxuICAgICAgICAgICAgICBkdHM6IGNvbXB1dGVkID4gdGhpcy5uZXh0QXVkaW9EdHMgPyBjb21wdXRlZCA6IHRoaXMubmV4dEF1ZGlvRHRzXFxuICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgdGhpcy5maWxsZWRBdWRpb1NhbXBsZXMucHVzaCh7XFxuICAgICAgICAgICAgICBkdHM6IHNpbGVudFNhbXBsZS5kdHMsXFxuICAgICAgICAgICAgICBzaXplOiBzaWxlbnRTYW1wbGUuZGF0YS5ieXRlTGVuZ3RoXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgdGhpcy5hdWRpb1RyYWNrLnNhbXBsZXMudW5zaGlmdChzaWxlbnRTYW1wbGUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmIChhYnNHYXAgPD0gbWV0YS5yZWZTYW1wbGVEdXJhdGlvbiAmJiBhYnNHYXAgPiAwKSB7XFxuICAgICAgICAvLyDlvZPlt67ot53mr5TovoPlsI/nmoTml7blgJnlsIbpn7PpopHluKfph43lrprkvY1cXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCfph43lrprkvY3pn7PpopHluKdkdHMnLCBhdWRpb1NhbXBsZXNbMF0uZHRzLCB0aGlzLm5leHRBdWRpb0R0cylcXG4gICAgICAgIGF1ZGlvU2FtcGxlc1swXS5kdHMgPSB0aGlzLm5leHRBdWRpb0R0cztcXG4gICAgICAgIGF1ZGlvU2FtcGxlc1swXS5wdHMgPSB0aGlzLm5leHRBdWRpb0R0cztcXG4gICAgICB9IGVsc2UgaWYgKGdhcCA8IDApIHtcXG4gICAgICAgIENvbXBhdGliaWxpdHkuZG9GaXhMYXJnZUdhcChhdWRpb1NhbXBsZXMsIC0xICogZ2FwKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgY29uc3QgbGFzdER0cyA9IGF1ZGlvU2FtcGxlc1thdWRpb1NhbXBsZXMubGVuZ3RoIC0gMV0uZHRzO1xcbiAgICBjb25zdCBsYXN0U2FtcGxlRHVyYXRpb24gPSBhdWRpb1NhbXBsZXMubGVuZ3RoID49IDIgPyBsYXN0RHRzIC0gYXVkaW9TYW1wbGVzW2F1ZGlvU2FtcGxlcy5sZW5ndGggLSAyXS5kdHMgOiBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uO1xcblxcbiAgICB0aGlzLmxhc3RBdWRpb1NhbXBsZXNMZW4gPSBzYW1wbGVzTGVuO1xcbiAgICB0aGlzLm5leHRBdWRpb0R0cyA9IG1ldGEucmVmU2FtcGxlRHVyYXRpb25GaXhlZCA/IGxhc3REdHMgKyBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uRml4ZWQgOiBsYXN0RHRzICsgbGFzdFNhbXBsZUR1cmF0aW9uO1xcbiAgICB0aGlzLmxhc3RBdWRpb0R0cyA9IGxhc3REdHM7XFxuXFxuICAgIC8vIHN0ZXAzLiDkv67lpI1zYW1wbGVz5q615YaF6YOo55qEZHRz5byC5bi46Zeu6aKYXFxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhdWRpb1NhbXBsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICBjb25zdCBjdXJyZW50ID0gYXVkaW9TYW1wbGVzW2ldO1xcbiAgICAgIGNvbnN0IG5leHQgPSBhdWRpb1NhbXBsZXNbaSArIDFdO1xcblxcbiAgICAgIGlmICghbmV4dCkge1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gbmV4dC5kdHMgLSBjdXJyZW50LmR0cztcXG4gICAgICBhdWRpb1NhbXBsZXNbaV0uZHVyYXRpb24gPSBkdXJhdGlvbjtcXG4gICAgICAvKlxcbiAgICAgIGlmIChkdXJhdGlvbiA+ICgyICogbWV0YS5yZWZTYW1wbGVEdXJhdGlvbikpIHtcXG4gICAgICAgIC8vIOS4pOW4p+S5i+mXtOmXtOmalOWkquWkp++8jOmcgOimgeihpeepuueZveW4p1xcbiAgICAgICAgLyoqXFxuICAgICAgICBsZXQgc2lsZW50RnJhbWVDb3VudCA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uKVxcbiAgICAgICAgbGV0IGZyYW1lSWR4ID0gMFxcbiAgICAgICAgIHdoaWxlIChmcmFtZUlkeCA8IHNpbGVudEZyYW1lQ291bnQpIHtcXG4gICAgICAgICAgY29uc3Qgc2lsZW50U2FtcGxlID0ge1xcbiAgICAgICAgICAgIGRhdGE6IHNpbGVudEZyYW1lLFxcbiAgICAgICAgICAgIGRhdGFzaXplOiBzaWxlbnRGcmFtZS5ieXRlTGVuZ3RoLFxcbiAgICAgICAgICAgIGR0czogY3VycmVudC5kdHMgKyAoZnJhbWVJZHggKyAxKSAqIG1ldGEucmVmU2FtcGxlRHVyYXRpb24sXFxuICAgICAgICAgICAgZmlsdGVyZWQ6IDAsXFxuICAgICAgICAgICAgaXNTaWxlbnQ6IHRydWVcXG4gICAgICAgICAgfVxcbiAgICAgICAgICAgYXVkaW9TYW1wbGVzLnNwbGljZShpLCAwLCBzaWxlbnRTYW1wbGUpXFxuICAgICAgICAgICB0aGlzLmZpbGxlZEF1ZGlvU2FtcGxlcy5wdXNoKHtcXG4gICAgICAgICAgICBkdHM6IHNpbGVudFNhbXBsZS5kdHMsXFxuICAgICAgICAgICAgc2l6ZTogc2lsZW50U2FtcGxlLmRhdGEuYnl0ZUxlbmd0aFxcbiAgICAgICAgICB9KVxcbiAgICAgICAgICAgZnJhbWVJZHgrK1xcbiAgICAgICAgICBpKysgLy8g5LiN5a+56Z2Z6Z+z5bin5YGa5q+U6L6DXFxuICAgICAgICB9XFxuICAgICAgfSAqL1xcbiAgICB9XFxuXFxuICAgIHRoaXMuYXVkaW9UcmFjay5zYW1wbGVzID0gQ29tcGF0aWJpbGl0eS5zb3J0QXVkaW9TYW1wbGVzKGF1ZGlvU2FtcGxlcyk7XFxuICB9XFxuXFxuICBmaXhDaGFuZ2VTdHJlYW1WaWRlbyhjaGFuZ2VJZHgpIHtcXG4gICAgY29uc3QgeyBzYW1wbGVzLCBtZXRhIH0gPSB0aGlzLnZpZGVvVHJhY2s7XFxuICAgIGNvbnN0IHByZXZEdHMgPSBjaGFuZ2VJZHggPT09IDAgPyB0aGlzLmdldFN0cmVhbUNoYW5nZVN0YXJ0KHNhbXBsZXNbMF0pIDogc2FtcGxlc1tjaGFuZ2VJZHggLSAxXS5kdHM7XFxuICAgIGNvbnN0IGN1ckR0cyA9IHNhbXBsZXNbY2hhbmdlSWR4XS5kdHM7XFxuICAgIGNvbnN0IGlzQ29udGludWUgPSBNYXRoLmFicyhwcmV2RHRzIC0gY3VyRHRzKSA8PSAyICogbWV0YS5yZWZTYW1wbGVEdXJhdGlvbjtcXG5cXG4gICAgaWYgKGlzQ29udGludWUpIHtcXG4gICAgICBpZiAoIXNhbXBsZXNbY2hhbmdlSWR4XS5vcHRpb25zKSB7XFxuICAgICAgICBzYW1wbGVzW2NoYW5nZUlkeF0ub3B0aW9ucyA9IHtcXG4gICAgICAgICAgaXNDb250aW51ZTogdHJ1ZVxcbiAgICAgICAgfTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2FtcGxlc1tjaGFuZ2VJZHhdLm9wdGlvbnMuaXNDb250aW51ZSA9IHRydWU7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB0aGlzLmRvRml4VmlkZW8oZmFsc2UpO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IGZpcnN0UGFydFNhbXBsZXMgPSBzYW1wbGVzLnNsaWNlKDAsIGNoYW5nZUlkeCk7XFxuICAgIGNvbnN0IHNlY29uZFBhcnRTYW1wbGVzID0gc2FtcGxlcy5zbGljZShjaGFuZ2VJZHgpO1xcbiAgICBjb25zdCBmaXJzdFNhbXBsZSA9IHNhbXBsZXNbMF07XFxuXFxuICAgIGNvbnN0IGNoYW5nZVNhbXBsZSA9IHNlY29uZFBhcnRTYW1wbGVzWzBdO1xcbiAgICBjb25zdCBmaXJzdFBhcnREdXJhdGlvbiA9IGNoYW5nZVNhbXBsZS5kdHMgLSBmaXJzdFNhbXBsZS5kdHM7XFxuICAgIGNvbnN0IHN0cmVhbUNoYW5nZVN0YXJ0ID0gZmlyc3RTYW1wbGUub3B0aW9ucyAmJiBmaXJzdFNhbXBsZS5vcHRpb25zLnN0YXJ0ICsgZmlyc3RQYXJ0RHVyYXRpb24gPyBmaXJzdFNhbXBsZS5vcHRpb25zLnN0YXJ0IDogbnVsbDtcXG5cXG4gICAgdGhpcy52aWRlb1RyYWNrLnNhbXBsZXMgPSBzYW1wbGVzLnNsaWNlKDAsIGNoYW5nZUlkeCk7XFxuXFxuICAgIHRoaXMuZG9GaXhWaWRlbyhmYWxzZSk7XFxuXFxuICAgIHRoaXMudmlkZW9UcmFjay5zYW1wbGVzID0gc2FtcGxlcy5zbGljZShjaGFuZ2VJZHgpO1xcblxcbiAgICB0aGlzLmRvRml4VmlkZW8oZmFsc2UsIHN0cmVhbUNoYW5nZVN0YXJ0KTtcXG5cXG4gICAgdGhpcy52aWRlb1RyYWNrLnNhbXBsZXMgPSBmaXJzdFBhcnRTYW1wbGVzLmNvbmNhdChzZWNvbmRQYXJ0U2FtcGxlcyk7XFxuICB9XFxuXFxuICBmaXhDaGFuZ2VTdHJlYW1BdWRpbyhjaGFuZ2VJZHgpIHtcXG4gICAgY29uc3QgeyBzYW1wbGVzLCBtZXRhIH0gPSB0aGlzLmF1ZGlvVHJhY2s7XFxuXFxuICAgIGNvbnN0IHByZXZEdHMgPSBjaGFuZ2VJZHggPT09IDAgPyB0aGlzLmdldFN0cmVhbUNoYW5nZVN0YXJ0KHNhbXBsZXNbMF0pIDogc2FtcGxlc1tjaGFuZ2VJZHggLSAxXS5kdHM7XFxuICAgIGNvbnN0IGN1ckR0cyA9IHNhbXBsZXNbY2hhbmdlSWR4XS5kdHM7XFxuICAgIGNvbnN0IGlzQ29udGludWUgPSBNYXRoLmFicyhwcmV2RHRzIC0gY3VyRHRzKSA8PSAyICogbWV0YS5yZWZTYW1wbGVEdXJhdGlvbjtcXG5cXG4gICAgaWYgKGlzQ29udGludWUpIHtcXG4gICAgICBpZiAoIXNhbXBsZXNbY2hhbmdlSWR4XS5vcHRpb25zKSB7XFxuICAgICAgICBzYW1wbGVzW2NoYW5nZUlkeF0ub3B0aW9ucyA9IHtcXG4gICAgICAgICAgaXNDb250aW51ZTogdHJ1ZVxcbiAgICAgICAgfTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2FtcGxlc1tjaGFuZ2VJZHhdLm9wdGlvbnMuaXNDb250aW51ZSA9IHRydWU7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB0aGlzLmRvRml4QXVkaW8oZmFsc2UpO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IGZpcnN0UGFydFNhbXBsZXMgPSBzYW1wbGVzLnNsaWNlKDAsIGNoYW5nZUlkeCk7XFxuICAgIGNvbnN0IHNlY29uZFBhcnRTYW1wbGVzID0gc2FtcGxlcy5zbGljZShjaGFuZ2VJZHgpO1xcbiAgICBjb25zdCBmaXJzdFNhbXBsZSA9IHNhbXBsZXNbMF07XFxuXFxuICAgIGNvbnN0IGNoYW5nZVNhbXBsZSA9IHNlY29uZFBhcnRTYW1wbGVzWzBdO1xcbiAgICBjb25zdCBmaXJzdFBhcnREdXJhdGlvbiA9IGNoYW5nZVNhbXBsZS5kdHMgLSBmaXJzdFNhbXBsZS5kdHM7XFxuICAgIGNvbnN0IHN0cmVhbUNoYW5nZVN0YXJ0ID0gZmlyc3RTYW1wbGUub3B0aW9ucyAmJiBmaXJzdFNhbXBsZS5vcHRpb25zLnN0YXJ0ICsgZmlyc3RQYXJ0RHVyYXRpb24gPyBmaXJzdFNhbXBsZS5vcHRpb25zLnN0YXJ0IDogbnVsbDtcXG5cXG4gICAgdGhpcy5hdWRpb1RyYWNrLnNhbXBsZXMgPSBmaXJzdFBhcnRTYW1wbGVzO1xcblxcbiAgICB0aGlzLmRvRml4QXVkaW8oZmFsc2UpO1xcblxcbiAgICB0aGlzLmF1ZGlvVHJhY2suc2FtcGxlcyA9IHNlY29uZFBhcnRTYW1wbGVzO1xcblxcbiAgICB0aGlzLmRvRml4QXVkaW8oZmFsc2UsIHN0cmVhbUNoYW5nZVN0YXJ0KTtcXG5cXG4gICAgdGhpcy5hdWRpb1RyYWNrLnNhbXBsZXMgPSBmaXJzdFBhcnRTYW1wbGVzLmNvbmNhdChzZWNvbmRQYXJ0U2FtcGxlcyk7XFxuICB9XFxuXFxuICBnZXRGaXJzdFNhbXBsZSgpIHtcXG4gICAgLy8g6I635Y+WdmlkZW/lkoxhdWRpb+eahOmmluW4p+aVsOaNrlxcbiAgICBsZXQgeyBzYW1wbGVzOiB2aWRlb1NhbXBsZXMgfSA9IHRoaXMudmlkZW9UcmFjaztcXG4gICAgbGV0IHsgc2FtcGxlczogYXVkaW9TYW1wbGVzIH0gPSB0aGlzLmF1ZGlvVHJhY2s7XFxuXFxuICAgIGxldCBpc0ZpcnN0VmlkZW9TYW1wbGVzID0gZmFsc2U7XFxuICAgIGxldCBpc0ZpcnN0QXVkaW9TYW1wbGVzID0gZmFsc2U7XFxuXFxuICAgIGlmICghdGhpcy5fZmlyc3RWaWRlb1NhbXBsZSAmJiB2aWRlb1NhbXBsZXMubGVuZ3RoKSB7XFxuICAgICAgdGhpcy5fZmlyc3RWaWRlb1NhbXBsZSA9IENvbXBhdGliaWxpdHkuZmluZEZpcnN0VmlkZW9TYW1wbGUodmlkZW9TYW1wbGVzKTtcXG4gICAgICBpc0ZpcnN0VmlkZW9TYW1wbGVzID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBpZiAoIXRoaXMuX2ZpcnN0QXVkaW9TYW1wbGUgJiYgYXVkaW9TYW1wbGVzLmxlbmd0aCkge1xcbiAgICAgIHRoaXMuX2ZpcnN0QXVkaW9TYW1wbGUgPSBDb21wYXRpYmlsaXR5LmZpbmRGaXJzdEF1ZGlvU2FtcGxlKGF1ZGlvU2FtcGxlcyk7IC8vIOWvu+aJvmR0c+acgOWwj+eahOW4p+S9nOS4uummluS4qumfs+mikeW4p1xcbiAgICAgIGlzRmlyc3RBdWRpb1NhbXBsZXMgPSB0cnVlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgaXNGaXJzdFZpZGVvU2FtcGxlcyxcXG4gICAgICBpc0ZpcnN0QXVkaW9TYW1wbGVzXFxuICAgIH07XFxuICB9XFxuXFxuICAvKipcXG4gICAqIOWcqOayoeaciXJlZlNhbXBsZUR1cmF0aW9u55qE6Zeu6aKY5rWB5Lit77yMXFxuICAgKi9cXG4gIGZpeFJlZlNhbXBsZUR1cmF0aW9uKG1ldGEsIHNhbXBsZXMpIHtcXG4gICAgY29uc3QgaXNWaWRlbyA9IG1ldGEudHlwZSA9PT0gJ3ZpZGVvJztcXG4gICAgY29uc3QgYWxsU2FtcGxlc0NvdW50ID0gaXNWaWRlbyA/IHRoaXMuYWxsVmlkZW9TYW1wbGVzQ291bnQgOiB0aGlzLmFsbEF1ZGlvU2FtcGxlc0NvdW50O1xcbiAgICBjb25zdCBmaXJzdER0cyA9IGlzVmlkZW8gPyB0aGlzLl9maXJzdFZpZGVvU2FtcGxlLmR0cyA6IHRoaXMuX2ZpcnN0QXVkaW9TYW1wbGUuZHRzO1xcbiAgICBjb25zdCBmaWxsZWRTYW1wbGVzQ291bnQgPSBpc1ZpZGVvID8gdGhpcy5maWxsZWRWaWRlb1NhbXBsZXMubGVuZ3RoIDogdGhpcy5maWxsZWRBdWRpb1NhbXBsZXMubGVuZ3RoO1xcblxcbiAgICBpZiAoIW1ldGEucmVmU2FtcGxlRHVyYXRpb24gfHwgbWV0YS5yZWZTYW1wbGVEdXJhdGlvbiA8PSAwIHx8IE51bWJlci5pc05hTihtZXRhLnJlZlNhbXBsZUR1cmF0aW9uKSkge1xcbiAgICAgIGlmIChzYW1wbGVzLmxlbmd0aCA+PSAxKSB7XFxuICAgICAgICBjb25zdCBsYXN0RHRzID0gc2FtcGxlc1tzYW1wbGVzLmxlbmd0aCAtIDFdLmR0cztcXG5cXG4gICAgICAgIG1ldGEucmVmU2FtcGxlRHVyYXRpb24gPSBNYXRoLmZsb29yKChsYXN0RHRzIC0gZmlyc3REdHMpIC8gKGFsbFNhbXBsZXNDb3VudCArIGZpbGxlZFNhbXBsZXNDb3VudCAtIDEpKTsgLy8g5bCGcmVmU2FtcGxlRHVyYXRpb27ph43nva7kuLrorqHnrpflkI7nmoTlubPlnYflgLxcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAobWV0YS5yZWZTYW1wbGVEdXJhdGlvbikge1xcbiAgICAgIGlmIChzYW1wbGVzLmxlbmd0aCA+PSA1KSB7XFxuICAgICAgICBjb25zdCBsYXN0RHRzID0gc2FtcGxlc1tzYW1wbGVzLmxlbmd0aCAtIDFdLmR0cztcXG4gICAgICAgIGNvbnN0IGZpcnN0RHRzID0gc2FtcGxlc1swXS5kdHM7XFxuICAgICAgICBjb25zdCBkdXJhdGlvbkF2ZyA9IChsYXN0RHRzIC0gZmlyc3REdHMpIC8gKHNhbXBsZXMubGVuZ3RoIC0gMSk7XFxuXFxuICAgICAgICBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uID0gTWF0aC5mbG9vcihNYXRoLmFicyhtZXRhLnJlZlNhbXBsZUR1cmF0aW9uIC0gZHVyYXRpb25BdmcpIDw9IDUgPyBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uIDogZHVyYXRpb25BdmcpOyAvLyDlsIZyZWZTYW1wbGVEdXJhdGlvbumHjee9ruS4uuiuoeeul+WQjueahOW5s+Wdh+WAvFxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiDorrDlvZXmiKrmraLnm67liY3kuIDlhbHmkq3mlL7kuoblpJrlsJHluKdcXG4gICAqL1xcbiAgcmVjb3JkU2FtcGxlc0NvdW50KCkge1xcbiAgICBjb25zdCB7IGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2sgfSA9IHRoaXM7XFxuXFxuICAgIHRoaXMuYWxsQXVkaW9TYW1wbGVzQ291bnQgKz0gYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aDtcXG4gICAgdGhpcy5hbGxWaWRlb1NhbXBsZXNDb3VudCArPSB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiDljrvpmaTkuI3lkIjms5XnmoTluKfvvIjlgJLpgIDjgIHph43lpI3luKfvvIlcXG4gICAqL1xcbiAgcmVtb3ZlSW52YWxpZFNhbXBsZXMoKSB7XFxuICAgIGNvbnN0IHsgX2ZpcnN0VmlkZW9TYW1wbGUsIF9maXJzdEF1ZGlvU2FtcGxlIH0gPSB0aGlzO1xcblxcbiAgICB0aGlzLmF1ZGlvVHJhY2suc2FtcGxlcyA9IHRoaXMuYXVkaW9UcmFjay5zYW1wbGVzLmZpbHRlcihzYW1wbGUgPT4ge1xcbiAgICAgIHJldHVybiBzYW1wbGUuZHRzID49IF9maXJzdEF1ZGlvU2FtcGxlLmR0cyAmJiAodGhpcy5sYXN0QXVkaW9EdHMgPT09IHVuZGVmaW5lZCB8fCBzYW1wbGUuZHRzID4gdGhpcy5sYXN0QXVkaW9EdHMpO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy52aWRlb1RyYWNrLnNhbXBsZXMgPSB0aGlzLnZpZGVvVHJhY2suc2FtcGxlcy5maWx0ZXIoc2FtcGxlID0+IHtcXG4gICAgICByZXR1cm4gc2FtcGxlLmR0cyA+PSBfZmlyc3RWaWRlb1NhbXBsZS5kdHMgJiYgKHRoaXMubGFzdFZpZGVvRHRzID09PSB1bmRlZmluZWQgfHwgc2FtcGxlLmR0cyA+IHRoaXMubGFzdFZpZGVvRHRzKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBnZXRTdHJlYW1DaGFuZ2VTdGFydChzYW1wbGUpIHtcXG4gICAgaWYgKHNhbXBsZS5vcHRpb25zICYmIHNhbXBsZS5vcHRpb25zLnN0YXJ0KSB7XFxuICAgICAgcmV0dXJuIHNhbXBsZS5vcHRpb25zLnN0YXJ0IC0gdGhpcy5kdHNCYXNlO1xcbiAgICB9XFxuICAgIHJldHVybiBJbmZpbml0eTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBzb3J0QXVkaW9TYW1wbGVzKHNhbXBsZXMpIHtcXG4gICAgaWYgKHNhbXBsZXMubGVuZ3RoID09PSAxKSB7XFxuICAgICAgcmV0dXJuIHNhbXBsZXM7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHNhbXBsZXMuc29ydCgoYSwgYikgPT4ge1xcbiAgICAgIHJldHVybiBhLmR0cyAtIGIuZHRzO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICog5a+75om+ZHRz5pyA5bCP55qEc2FtcGxlXFxuICAgKiBAcGFyYW0gc2FtcGxlc1xcbiAgICovXFxuICBzdGF0aWMgZmluZEZpcnN0QXVkaW9TYW1wbGUoc2FtcGxlcykge1xcbiAgICBpZiAoIXNhbXBsZXMgfHwgc2FtcGxlcy5sZW5ndGggPT09IDApIHtcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gQ29tcGF0aWJpbGl0eS5zb3J0QXVkaW9TYW1wbGVzKHNhbXBsZXMpWzBdO1xcbiAgfVxcblxcbiAgc3RhdGljIGZpbmRGaXJzdFZpZGVvU2FtcGxlKHNhbXBsZXMpIHtcXG4gICAgaWYgKCFzYW1wbGVzLmxlbmd0aCkge1xcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHNvcnRlZCA9IHNhbXBsZXMuc29ydCgoYSwgYikgPT4ge1xcbiAgICAgIHJldHVybiBhLmR0cyAtIGIuZHRzO1xcbiAgICB9KTtcXG5cXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNvcnRlZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgIGlmIChzb3J0ZWRbaV0uaXNLZXlmcmFtZSkge1xcbiAgICAgICAgcmV0dXJuIHNvcnRlZFtpXTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHN0YXRpYyBkZXRlY3RMYXJnZUdhcChuZXh0RHRzLCBmaXJzdFNhbXBsZSkge1xcbiAgICBpZiAobmV4dER0cyA9PT0gbnVsbCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBjb25zdCBjdXJEdHMgPSBmaXJzdFNhbXBsZS5kdHMgfHwgMDtcXG4gICAgY29uc3QgY29uZDEgPSBuZXh0RHRzIC0gY3VyRHRzID49IDEwMDAgfHwgY3VyRHRzIC0gbmV4dER0cyA+PSAxMDAwOyAvLyBmaXggaGxz5rWB5Ye6546w5aSn6YeP5rWBZHRz6Ze06Led6Zeu6aKYXFxuICAgIGNvbnN0IGNvbmQyID0gZmlyc3RTYW1wbGUub3B0aW9ucyAmJiBmaXJzdFNhbXBsZS5vcHRpb25zLmRpc2NvbnRpbnVlO1xcblxcbiAgICByZXR1cm4gY29uZDEgfHwgY29uZDI7XFxuICB9XFxuXFxuICBzdGF0aWMgZG9GaXhMYXJnZUdhcChzYW1wbGVzLCBnYXApIHtcXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNhbXBsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICBjb25zdCBzYW1wbGUgPSBzYW1wbGVzW2ldO1xcbiAgICAgIHNhbXBsZS5kdHMgKz0gZ2FwO1xcbiAgICAgIGlmIChzYW1wbGUucHRzKSB7XFxuICAgICAgICBzYW1wbGUucHRzICs9IGdhcDtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8qKlxcbiAgICog5Lit6YCU5o2i5rWBXFxuICAgKi9cXG4gIHN0YXRpYyBkZXRhY3RDaGFuZ2VTdHJlYW0oc2FtcGxlcykge1xcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xcbiAgICBsZXQgY2hhbmdlZElkeCA9IC0xO1xcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc2FtcGxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgIGlmIChzYW1wbGVzW2ldLm9wdGlvbnMgJiYgc2FtcGxlc1tpXS5vcHRpb25zLm1ldGEpIHtcXG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xcbiAgICAgICAgY2hhbmdlZElkeCA9IGk7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHtcXG4gICAgICBjaGFuZ2VkLFxcbiAgICAgIGNoYW5nZWRJZHhcXG4gICAgfTtcXG4gIH1cXG5cXG4gIGdldCB0cmFja3MoKSB7XFxuICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKCdUUkFDS1MnKTtcXG4gIH1cXG5cXG4gIGdldCBhdWRpb1RyYWNrKCkge1xcbiAgICBpZiAodGhpcy50cmFja3MpIHtcXG4gICAgICByZXR1cm4gdGhpcy50cmFja3MuYXVkaW9UcmFjaztcXG4gICAgfVxcbiAgICByZXR1cm4gbnVsbDtcXG4gIH1cXG5cXG4gIGdldCB2aWRlb1RyYWNrKCkge1xcbiAgICBpZiAodGhpcy50cmFja3MpIHtcXG4gICAgICByZXR1cm4gdGhpcy50cmFja3MudmlkZW9UcmFjaztcXG4gICAgfVxcbiAgICByZXR1cm4gbnVsbDtcXG4gIH1cXG5cXG4gIGdldCBkdHNCYXNlKCkge1xcbiAgICBjb25zdCByZW11eGVyID0gdGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZSgnTVA0X1JFTVVYRVInKTtcXG4gICAgaWYgKHJlbXV4ZXIpIHtcXG4gICAgICByZXR1cm4gcmVtdXhlci5fZHRzQmFzZTtcXG4gICAgfVxcbiAgICByZXR1cm4gMDtcXG4gIH1cXG59XFxuZXhwb3J0cy5kZWZhdWx0ID0gQ29tcGF0aWJpbGl0eTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItY29kZWMvc3JjL2NvbXBhdGliaWxpdHkuanM/XCIpfSxcIi4uL3hncGxheWVyLWNvZGVjL3NyYy9oMjY0L25hbHVuaXQvZ29sb21iLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLWNvZGVjL3NyYy9oMjY0L25hbHVuaXQvZ29sb21iLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuY2xhc3MgR29sb21iIHtcXG4gIGNvbnN0cnVjdG9yKHVpbnQ4YXJyYXkpIHtcXG4gICAgdGhpcy5UQUcgPSAnR29sb21iJztcXG4gICAgdGhpcy5fYnVmZmVyID0gdWludDhhcnJheTtcXG4gICAgdGhpcy5fYnVmZmVySW5kZXggPSAwO1xcbiAgICB0aGlzLl90b3RhbEJ5dGVzID0gdWludDhhcnJheS5ieXRlTGVuZ3RoO1xcbiAgICB0aGlzLl90b3RhbEJpdHMgPSB1aW50OGFycmF5LmJ5dGVMZW5ndGggKiA4O1xcbiAgICB0aGlzLl9jdXJyZW50V29yZCA9IDA7XFxuICAgIHRoaXMuX2N1cnJlbnRXb3JkQml0c0xlZnQgPSAwO1xcbiAgfVxcblxcbiAgZGVzdHJveSgpIHtcXG4gICAgdGhpcy5fYnVmZmVyID0gbnVsbDtcXG4gIH1cXG5cXG4gIF9maWxsQ3VycmVudFdvcmQoKSB7XFxuICAgIGxldCBidWZmZXJCeXRlc0xlZnQgPSB0aGlzLl90b3RhbEJ5dGVzIC0gdGhpcy5fYnVmZmVySW5kZXg7XFxuICAgIGlmIChidWZmZXJCeXRlc0xlZnQgPD0gMCkge1xcbiAgICAgIC8vIFRPRE8g5byC5bi45aSE55CGXFxuICAgIH1cXG5cXG4gICAgbGV0IGJ5dGVzUmVhZCA9IE1hdGgubWluKDQsIGJ1ZmZlckJ5dGVzTGVmdCk7XFxuICAgIGxldCB3b3JkID0gbmV3IFVpbnQ4QXJyYXkoNCk7XFxuICAgIHdvcmQuc2V0KHRoaXMuX2J1ZmZlci5zdWJhcnJheSh0aGlzLl9idWZmZXJJbmRleCwgdGhpcy5fYnVmZmVySW5kZXggKyBieXRlc1JlYWQpKTtcXG4gICAgdGhpcy5fY3VycmVudFdvcmQgPSBuZXcgRGF0YVZpZXcod29yZC5idWZmZXIpLmdldFVpbnQzMigwKTtcXG5cXG4gICAgdGhpcy5fYnVmZmVySW5kZXggKz0gYnl0ZXNSZWFkO1xcbiAgICB0aGlzLl9jdXJyZW50V29yZEJpdHNMZWZ0ID0gYnl0ZXNSZWFkICogODtcXG4gIH1cXG5cXG4gIHJlYWRCaXRzKHNpemUpIHtcXG4gICAgbGV0IGJpdHMgPSBNYXRoLm1pbih0aGlzLl9jdXJyZW50V29yZEJpdHNMZWZ0LCBzaXplKTsgLy8gOnVpbnRcXG4gICAgbGV0IHZhbHUgPSB0aGlzLl9jdXJyZW50V29yZCA+Pj4gMzIgLSBiaXRzO1xcbiAgICBpZiAoc2l6ZSA+IDMyKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBtb3JlIHRoYW4gMzIgYml0cyBhdCBhIHRpbWUnKTtcXG4gICAgfVxcbiAgICB0aGlzLl9jdXJyZW50V29yZEJpdHNMZWZ0IC09IGJpdHM7XFxuICAgIGlmICh0aGlzLl9jdXJyZW50V29yZEJpdHNMZWZ0ID4gMCkge1xcbiAgICAgIHRoaXMuX2N1cnJlbnRXb3JkIDw8PSBiaXRzO1xcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3RvdGFsQnl0ZXMgLSB0aGlzLl9idWZmZXJJbmRleCA+IDApIHtcXG4gICAgICB0aGlzLl9maWxsQ3VycmVudFdvcmQoKTtcXG4gICAgfVxcblxcbiAgICBiaXRzID0gc2l6ZSAtIGJpdHM7XFxuICAgIGlmIChiaXRzID4gMCAmJiB0aGlzLl9jdXJyZW50V29yZEJpdHNMZWZ0KSB7XFxuICAgICAgcmV0dXJuIHZhbHUgPDwgYml0cyB8IHRoaXMucmVhZEJpdHMoYml0cyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIHZhbHU7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJlYWRCb29sKCkge1xcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygxKSA9PT0gMTtcXG4gIH1cXG5cXG4gIHJlYWRCeXRlKCkge1xcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cyg4KTtcXG4gIH1cXG5cXG4gIF9za2lwTGVhZGluZ1plcm8oKSB7XFxuICAgIGxldCB6ZXJvQ291bnQ7XFxuICAgIGZvciAoemVyb0NvdW50ID0gMDsgemVyb0NvdW50IDwgdGhpcy5fY3VycmVudFdvcmRCaXRzTGVmdDsgemVyb0NvdW50KyspIHtcXG4gICAgICBpZiAoKHRoaXMuX2N1cnJlbnRXb3JkICYgMHg4MDAwMDAwMCA+Pj4gemVyb0NvdW50KSAhPT0gMCkge1xcbiAgICAgICAgdGhpcy5fY3VycmVudFdvcmQgPDw9IHplcm9Db3VudDtcXG4gICAgICAgIHRoaXMuX2N1cnJlbnRXb3JkQml0c0xlZnQgLT0gemVyb0NvdW50O1xcbiAgICAgICAgcmV0dXJuIHplcm9Db3VudDtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgdGhpcy5fZmlsbEN1cnJlbnRXb3JkKCk7XFxuICAgIHJldHVybiB6ZXJvQ291bnQgKyB0aGlzLl9za2lwTGVhZGluZ1plcm8oKTtcXG4gIH1cXG5cXG4gIHJlYWRVRUcoKSB7XFxuICAgIC8vIHVuc2lnbmVkIGV4cG9uZW50aWFsIGdvbG9tYlxcbiAgICBsZXQgbGVhZGluZ1plcm9zID0gdGhpcy5fc2tpcExlYWRpbmdaZXJvKCk7XFxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKGxlYWRpbmdaZXJvcyArIDEpIC0gMTtcXG4gIH1cXG5cXG4gIHJlYWRTRUcoKSB7XFxuICAgIC8vIHNpZ25lZCBleHBvbmVudGlhbCBnb2xvbWJcXG4gICAgbGV0IHZhbHVlID0gdGhpcy5yZWFkVUVHKCk7XFxuICAgIGlmICh2YWx1ZSAmIDB4MDEpIHtcXG4gICAgICByZXR1cm4gdmFsdWUgKyAxID4+PiAxO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiAtMSAqICh2YWx1ZSA+Pj4gMSk7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gR29sb21iO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci1jb2RlYy9zcmMvaDI2NC9uYWx1bml0L2dvbG9tYi5qcz9cIil9LFwiLi4veGdwbGF5ZXItY29kZWMvc3JjL2gyNjQvbmFsdW5pdC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLWNvZGVjL3NyYy9oMjY0L25hbHVuaXQvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoJ1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgX3NwcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3BzICovIFwiLi4veGdwbGF5ZXItY29kZWMvc3JjL2gyNjQvbmFsdW5pdC9zcHMuanNcIik7XFxuXFxudmFyIF9zcHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3BzKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxcblxcbmNsYXNzIE5hbHVuaXQge1xcbiAgc3RhdGljIGdldE5hbHVuaXRzKGJ1ZmZlcikge1xcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCAtIGJ1ZmZlci5wb3NpdGlvbiA8IDQpIHtcXG4gICAgICByZXR1cm4gW107XFxuICAgIH1cXG5cXG4gICAgbGV0IGJ1ZiA9IGJ1ZmZlci5kYXRhdmlldztcXG4gICAgbGV0IHBvc2l0aW9uID0gYnVmZmVyLnBvc2l0aW9uO1xcbiAgICBpZiAoYnVmLmdldEludDMyKHBvc2l0aW9uKSA9PT0gMSB8fCBidWYuZ2V0SW50MTYocG9zaXRpb24pID09PSAwICYmIGJ1Zi5nZXRJbnQ4KHBvc2l0aW9uICsgMikgPT09IDEpIHtcXG4gICAgICByZXR1cm4gTmFsdW5pdC5nZXRBbm5leGJOYWxzKGJ1ZmZlcik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIE5hbHVuaXQuZ2V0QXZjY05hbHMoYnVmZmVyKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgc3RhdGljIGdldEFubmV4Yk5hbHMoYnVmZmVyKSB7XFxuICAgIGxldCBuYWxzID0gW107XFxuICAgIGxldCBwb3NpdGlvbiA9IE5hbHVuaXQuZ2V0SGVhZGVyUG9zaXRpb25Bbm5leEIoYnVmZmVyKTtcXG4gICAgbGV0IHN0YXJ0ID0gcG9zaXRpb24ucG9zO1xcbiAgICBsZXQgZW5kID0gc3RhcnQ7XFxuICAgIHdoaWxlIChzdGFydCA8IGJ1ZmZlci5sZW5ndGggLSA0KSB7XFxuICAgICAgbGV0IGhlYWRlciA9IGJ1ZmZlci5idWZmZXIuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgcG9zaXRpb24uaGVhZGVyTGVuZ3RoKTtcXG4gICAgICBpZiAocG9zaXRpb24ucG9zID09PSBidWZmZXIucG9zaXRpb24pIHtcXG4gICAgICAgIGJ1ZmZlci5za2lwKHBvc2l0aW9uLmhlYWRlckxlbmd0aCk7XFxuICAgICAgfVxcbiAgICAgIHBvc2l0aW9uID0gTmFsdW5pdC5nZXRIZWFkZXJQb3NpdGlvbkFubmV4QihidWZmZXIpO1xcbiAgICAgIGVuZCA9IHBvc2l0aW9uLnBvcztcXG4gICAgICBsZXQgYm9keSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5idWZmZXIuc2xpY2Uoc3RhcnQgKyBoZWFkZXIuYnl0ZUxlbmd0aCwgZW5kKSk7XFxuICAgICAgbGV0IHVuaXQgPSB7IGhlYWRlciwgYm9keSB9O1xcbiAgICAgIE5hbHVuaXQuYW5hbHlzZU5hbCh1bml0KTtcXG4gICAgICBuYWxzLnB1c2godW5pdCk7XFxuICAgICAgYnVmZmVyLnNraXAoZW5kIC0gYnVmZmVyLnBvc2l0aW9uKTtcXG4gICAgICBzdGFydCA9IGVuZDtcXG4gICAgfVxcbiAgICByZXR1cm4gbmFscztcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXRBdmNjTmFscyhidWZmZXIpIHtcXG4gICAgbGV0IG5hbHMgPSBbXTtcXG4gICAgd2hpbGUgKGJ1ZmZlci5wb3NpdGlvbiA8IGJ1ZmZlci5sZW5ndGggLSA0KSB7XFxuICAgICAgbGV0IGxlbmd0aCA9IGJ1ZmZlci5kYXRhdmlldy5nZXRJbnQzMihidWZmZXIucG9zaXRpb24pO1xcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoIC0gYnVmZmVyLnBvc2l0aW9uID49IGxlbmd0aCkge1xcbiAgICAgICAgbGV0IGhlYWRlciA9IGJ1ZmZlci5idWZmZXIuc2xpY2UoYnVmZmVyLnBvc2l0aW9uLCBidWZmZXIucG9zaXRpb24gKyA0KTtcXG4gICAgICAgIGJ1ZmZlci5za2lwKDQpO1xcbiAgICAgICAgbGV0IGJvZHkgPSBidWZmZXIuYnVmZmVyLnNsaWNlKGJ1ZmZlci5wb3NpdGlvbiwgYnVmZmVyLnBvc2l0aW9uICsgbGVuZ3RoKTtcXG4gICAgICAgIGJ1ZmZlci5za2lwKGxlbmd0aCk7XFxuICAgICAgICBsZXQgdW5pdCA9IHsgaGVhZGVyLCBib2R5IH07XFxuICAgICAgICBOYWx1bml0LmFuYWx5c2VOYWwodW5pdCk7XFxuICAgICAgICBuYWxzLnB1c2godW5pdCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gbmFscztcXG4gIH1cXG5cXG4gIHN0YXRpYyBhbmFseXNlTmFsKHVuaXQpIHtcXG4gICAgbGV0IHR5cGUgPSB1bml0LmJvZHlbMF0gJiAweDFmO1xcbiAgICBzd2l0Y2ggKHR5cGUpIHtcXG4gICAgICBjYXNlIDE6XFxuICAgICAgICAvLyBORFJcXG4gICAgICAgIHVuaXQubmRyID0gdHJ1ZTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgNTpcXG4gICAgICAgIC8vIElEUlxcbiAgICAgICAgdW5pdC5pZHIgPSB0cnVlO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSA2OlxcbiAgICAgICAgLy8gU0VJXFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIDc6XFxuICAgICAgICAvLyBTUFNcXG4gICAgICAgIHVuaXQuc3BzID0gX3NwczIuZGVmYXVsdC5wYXJzZVNQUyh1bml0LmJvZHkpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSA4OlxcbiAgICAgICAgLy8gUFBTXFxuICAgICAgICB1bml0LnBwcyA9IHRydWU7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIDk6XFxuICAgICAgICAvLyBBVURcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICBicmVhaztcXG4gICAgfVxcbiAgfVxcblxcbiAgc3RhdGljIGdldEhlYWRlclBvc2l0aW9uQW5uZXhCKGJ1ZmZlcikge1xcbiAgICAvLyBzZXBlcmF0ZVxcbiAgICBsZXQgcG9zID0gYnVmZmVyLnBvc2l0aW9uO1xcbiAgICBsZXQgaGVhZGVyTGVuZ3RoID0gMDtcXG4gICAgd2hpbGUgKGhlYWRlckxlbmd0aCAhPT0gMyAmJiBoZWFkZXJMZW5ndGggIT09IDQgJiYgcG9zIDwgYnVmZmVyLmxlbmd0aCAtIDQpIHtcXG4gICAgICBpZiAoYnVmZmVyLmRhdGF2aWV3LmdldEludDE2KHBvcykgPT09IDApIHtcXG4gICAgICAgIGlmIChidWZmZXIuZGF0YXZpZXcuZ2V0SW50MTYocG9zICsgMikgPT09IDEpIHtcXG4gICAgICAgICAgLy8gMHgwMDAwMDFcXG4gICAgICAgICAgaGVhZGVyTGVuZ3RoID0gNDtcXG4gICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyLmRhdGF2aWV3LmdldEludDgocG9zICsgMikgPT09IDEpIHtcXG4gICAgICAgICAgaGVhZGVyTGVuZ3RoID0gMztcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHBvcysrO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBwb3MrKztcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKHBvcyA9PT0gYnVmZmVyLmxlbmd0aCAtIDQpIHtcXG4gICAgICBpZiAoYnVmZmVyLmRhdGF2aWV3LmdldEludDE2KHBvcykgPT09IDApIHtcXG4gICAgICAgIGlmIChidWZmZXIuZGF0YXZpZXcuZ2V0SW50MTYocG9zICsgMikgPT09IDEpIHtcXG4gICAgICAgICAgLy8gMHgwMDAwMDFcXG4gICAgICAgICAgaGVhZGVyTGVuZ3RoID0gNDtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcG9zKys7XFxuICAgICAgICBpZiAoYnVmZmVyLmRhdGF2aWV3LmdldEludDE2KHBvcykgPT09IDAgJiYgYnVmZmVyLmRhdGF2aWV3LmdldEludDgocG9zKSA9PT0gMSkge1xcbiAgICAgICAgICAvLyAweDAwMDAwMDFcXG4gICAgICAgICAgaGVhZGVyTGVuZ3RoID0gMztcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHBvcyA9IGJ1ZmZlci5sZW5ndGg7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiB7IHBvcywgaGVhZGVyTGVuZ3RoIH07XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0QXZjYyhzcHMsIHBwcykge1xcbiAgICBsZXQgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoc3BzLmJ5dGVMZW5ndGggKyBwcHMuYnl0ZUxlbmd0aCArIDExKTtcXG4gICAgcmV0WzBdID0gMHgwMTtcXG4gICAgcmV0WzFdID0gc3BzWzFdO1xcbiAgICByZXRbMl0gPSBzcHNbMl07XFxuICAgIHJldFszXSA9IHNwc1szXTtcXG4gICAgcmV0WzRdID0gMjU1O1xcbiAgICByZXRbNV0gPSAyMjU7XFxuXFxuICAgIGxldCBvZmZzZXQgPSA2O1xcblxcbiAgICByZXQuc2V0KG5ldyBVaW50OEFycmF5KFtzcHMuYnl0ZUxlbmd0aCA+Pj4gOCAmIDB4ZmYsIHNwcy5ieXRlTGVuZ3RoICYgMHhmZl0pLCBvZmZzZXQpO1xcbiAgICBvZmZzZXQgKz0gMjtcXG4gICAgcmV0LnNldChzcHMsIG9mZnNldCk7XFxuICAgIG9mZnNldCArPSBzcHMuYnl0ZUxlbmd0aDtcXG5cXG4gICAgcmV0W29mZnNldF0gPSAxO1xcbiAgICBvZmZzZXQrKztcXG5cXG4gICAgcmV0LnNldChuZXcgVWludDhBcnJheShbcHBzLmJ5dGVMZW5ndGggPj4+IDggJiAweGZmLCBwcHMuYnl0ZUxlbmd0aCAmIDB4ZmZdKSwgb2Zmc2V0KTtcXG4gICAgb2Zmc2V0ICs9IDI7XFxuICAgIHJldC5zZXQocHBzLCBvZmZzZXQpO1xcbiAgICByZXR1cm4gcmV0O1xcbiAgfVxcbn1cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBOYWx1bml0O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci1jb2RlYy9zcmMvaDI2NC9uYWx1bml0L2luZGV4LmpzPycpfSxcIi4uL3hncGxheWVyLWNvZGVjL3NyYy9oMjY0L25hbHVuaXQvc3BzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLWNvZGVjL3NyYy9oMjY0L25hbHVuaXQvc3BzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIF9nb2xvbWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dvbG9tYiAqLyBcXFwiLi4veGdwbGF5ZXItY29kZWMvc3JjL2gyNjQvbmFsdW5pdC9nb2xvbWIuanNcXFwiKTtcXG5cXG52YXIgX2dvbG9tYjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nb2xvbWIpO1xcblxcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFxuY2xhc3MgU1BTUGFyc2VyIHtcXG4gIHN0YXRpYyBfZWJzcDJyYnNwKHVpbnQ4YXJyYXkpIHtcXG4gICAgbGV0IHNyYyA9IHVpbnQ4YXJyYXk7XFxuICAgIGxldCBzcmNMZW5ndGggPSBzcmMuYnl0ZUxlbmd0aDtcXG4gICAgbGV0IGRzdCA9IG5ldyBVaW50OEFycmF5KHNyY0xlbmd0aCk7XFxuICAgIGxldCBkc3RJZHggPSAwO1xcblxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNyY0xlbmd0aDsgaSsrKSB7XFxuICAgICAgaWYgKGkgPj0gMikge1xcbiAgICAgICAgaWYgKHNyY1tpXSA9PT0gMHgwMyAmJiBzcmNbaSAtIDFdID09PSAweDAwICYmIHNyY1tpIC0gMl0gPT09IDB4MDApIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGRzdFtkc3RJZHhdID0gc3JjW2ldO1xcbiAgICAgIGRzdElkeCsrO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShkc3QuYnVmZmVyLCAwLCBkc3RJZHgpO1xcbiAgfVxcblxcbiAgc3RhdGljIHBhcnNlU1BTKHVpbnQ4YXJyYXkpIHtcXG4gICAgbGV0IHJic3AgPSBTUFNQYXJzZXIuX2Vic3AycmJzcCh1aW50OGFycmF5KTtcXG4gICAgbGV0IGdiID0gbmV3IF9nb2xvbWIyLmRlZmF1bHQocmJzcCk7XFxuXFxuICAgIGdiLnJlYWRCeXRlKCk7XFxuICAgIGxldCBwcm9maWxlSWRjID0gZ2IucmVhZEJ5dGUoKTtcXG4gICAgZ2IucmVhZEJ5dGUoKTtcXG4gICAgbGV0IGxldmVsSWRjID0gZ2IucmVhZEJ5dGUoKTtcXG4gICAgZ2IucmVhZFVFRygpO1xcblxcbiAgICBsZXQgcHJvZmlsZV9zdHJpbmcgPSBTUFNQYXJzZXIuZ2V0UHJvZmlsZVN0cmluZyhwcm9maWxlSWRjKTtcXG4gICAgbGV0IGxldmVsX3N0cmluZyA9IFNQU1BhcnNlci5nZXRMZXZlbFN0cmluZyhsZXZlbElkYyk7XFxuICAgIGxldCBjaHJvbWFfZm9ybWF0X2lkYyA9IDE7XFxuICAgIGxldCBjaHJvbWFfZm9ybWF0ID0gNDIwO1xcbiAgICBsZXQgY2hyb21hX2Zvcm1hdF90YWJsZSA9IFswLCA0MjAsIDQyMiwgNDQ0XTtcXG4gICAgbGV0IGJpdF9kZXB0aCA9IDg7XFxuXFxuICAgIGlmIChwcm9maWxlSWRjID09PSAxMDAgfHwgcHJvZmlsZUlkYyA9PT0gMTEwIHx8IHByb2ZpbGVJZGMgPT09IDEyMiB8fCBwcm9maWxlSWRjID09PSAyNDQgfHwgcHJvZmlsZUlkYyA9PT0gNDQgfHwgcHJvZmlsZUlkYyA9PT0gODMgfHwgcHJvZmlsZUlkYyA9PT0gODYgfHwgcHJvZmlsZUlkYyA9PT0gMTE4IHx8IHByb2ZpbGVJZGMgPT09IDEyOCB8fCBwcm9maWxlSWRjID09PSAxMzggfHwgcHJvZmlsZUlkYyA9PT0gMTQ0KSB7XFxuICAgICAgY2hyb21hX2Zvcm1hdF9pZGMgPSBnYi5yZWFkVUVHKCk7XFxuICAgICAgaWYgKGNocm9tYV9mb3JtYXRfaWRjID09PSAzKSB7XFxuICAgICAgICBnYi5yZWFkQml0cygxKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGNocm9tYV9mb3JtYXRfaWRjIDw9IDMpIHtcXG4gICAgICAgIGNocm9tYV9mb3JtYXQgPSBjaHJvbWFfZm9ybWF0X3RhYmxlW2Nocm9tYV9mb3JtYXRfaWRjXTtcXG4gICAgICB9XFxuXFxuICAgICAgYml0X2RlcHRoID0gZ2IucmVhZFVFRygpICsgODtcXG4gICAgICBnYi5yZWFkVUVHKCk7XFxuICAgICAgZ2IucmVhZEJpdHMoMSk7XFxuICAgICAgaWYgKGdiLnJlYWRCb29sKCkpIHtcXG4gICAgICAgIGxldCBzY2FsaW5nX2xpc3RfY291bnQgPSBjaHJvbWFfZm9ybWF0X2lkYyAhPT0gMyA/IDggOiAxMjtcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NhbGluZ19saXN0X2NvdW50OyBpKyspIHtcXG4gICAgICAgICAgaWYgKGdiLnJlYWRCb29sKCkpIHtcXG4gICAgICAgICAgICBpZiAoaSA8IDYpIHtcXG4gICAgICAgICAgICAgIFNQU1BhcnNlci5fc2tpcFNjYWxpbmdMaXN0KGdiLCAxNik7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIFNQU1BhcnNlci5fc2tpcFNjYWxpbmdMaXN0KGdiLCA2NCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGdiLnJlYWRVRUcoKTtcXG4gICAgbGV0IHBpY19vcmRlcl9jbnRfdHlwZSA9IGdiLnJlYWRVRUcoKTtcXG4gICAgaWYgKHBpY19vcmRlcl9jbnRfdHlwZSA9PT0gMCkge1xcbiAgICAgIGdiLnJlYWRVRUcoKTtcXG4gICAgfSBlbHNlIGlmIChwaWNfb3JkZXJfY250X3R5cGUgPT09IDEpIHtcXG4gICAgICBnYi5yZWFkQml0cygxKTtcXG4gICAgICBnYi5yZWFkU0VHKCk7XFxuICAgICAgZ2IucmVhZFNFRygpO1xcbiAgICAgIGxldCBudW1fcmVmX2ZyYW1lc19pbl9waWNfb3JkZXJfY250X2N5Y2xlID0gZ2IucmVhZFVFRygpO1xcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtX3JlZl9mcmFtZXNfaW5fcGljX29yZGVyX2NudF9jeWNsZTsgaSsrKSB7XFxuICAgICAgICBnYi5yZWFkU0VHKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGdiLnJlYWRVRUcoKTtcXG4gICAgZ2IucmVhZEJpdHMoMSk7XFxuXFxuICAgIGxldCBwaWNfd2lkdGhfaW5fbWJzX21pbnVzMSA9IGdiLnJlYWRVRUcoKTtcXG4gICAgbGV0IHBpY19oZWlnaHRfaW5fbWFwX3VuaXRzX21pbnVzMSA9IGdiLnJlYWRVRUcoKTtcXG5cXG4gICAgbGV0IGZyYW1lX21ic19vbmx5X2ZsYWcgPSBnYi5yZWFkQml0cygxKTtcXG4gICAgaWYgKGZyYW1lX21ic19vbmx5X2ZsYWcgPT09IDApIHtcXG4gICAgICBnYi5yZWFkQml0cygxKTtcXG4gICAgfVxcbiAgICBnYi5yZWFkQml0cygxKTtcXG5cXG4gICAgbGV0IGZyYW1lX2Nyb3BfbGVmdF9vZmZzZXQgPSAwO1xcbiAgICBsZXQgZnJhbWVfY3JvcF9yaWdodF9vZmZzZXQgPSAwO1xcbiAgICBsZXQgZnJhbWVfY3JvcF90b3Bfb2Zmc2V0ID0gMDtcXG4gICAgbGV0IGZyYW1lX2Nyb3BfYm90dG9tX29mZnNldCA9IDA7XFxuXFxuICAgIGxldCBmcmFtZV9jcm9wcGluZ19mbGFnID0gZ2IucmVhZEJvb2woKTtcXG4gICAgaWYgKGZyYW1lX2Nyb3BwaW5nX2ZsYWcpIHtcXG4gICAgICBmcmFtZV9jcm9wX2xlZnRfb2Zmc2V0ID0gZ2IucmVhZFVFRygpO1xcbiAgICAgIGZyYW1lX2Nyb3BfcmlnaHRfb2Zmc2V0ID0gZ2IucmVhZFVFRygpO1xcbiAgICAgIGZyYW1lX2Nyb3BfdG9wX29mZnNldCA9IGdiLnJlYWRVRUcoKTtcXG4gICAgICBmcmFtZV9jcm9wX2JvdHRvbV9vZmZzZXQgPSBnYi5yZWFkVUVHKCk7XFxuICAgIH1cXG5cXG4gICAgbGV0IHBhcl93aWR0aCA9IDEsXFxuICAgICAgICBwYXJfaGVpZ2h0ID0gMTtcXG4gICAgbGV0IGZwcyA9IDAsXFxuICAgICAgICBmcHNfZml4ZWQgPSB0cnVlLFxcbiAgICAgICAgZnBzX251bSA9IDAsXFxuICAgICAgICBmcHNfZGVuID0gMDtcXG5cXG4gICAgbGV0IHZ1aV9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZyA9IGdiLnJlYWRCb29sKCk7XFxuICAgIGlmICh2dWlfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWcpIHtcXG4gICAgICBpZiAoZ2IucmVhZEJvb2woKSkge1xcbiAgICAgICAgLy8gYXNwZWN0X3JhdGlvX2luZm9fcHJlc2VudF9mbGFnXFxuICAgICAgICBsZXQgYXNwZWN0X3JhdGlvX2lkYyA9IGdiLnJlYWRCeXRlKCk7XFxuICAgICAgICBsZXQgcGFyX3dfdGFibGUgPSBbMSwgMTIsIDEwLCAxNiwgNDAsIDI0LCAyMCwgMzIsIDgwLCAxOCwgMTUsIDY0LCAxNjAsIDQsIDMsIDJdO1xcbiAgICAgICAgbGV0IHBhcl9oX3RhYmxlID0gWzEsIDExLCAxMSwgMTEsIDMzLCAxMSwgMTEsIDExLCAzMywgMTEsIDExLCAzMywgOTksIDMsIDIsIDFdO1xcblxcbiAgICAgICAgaWYgKGFzcGVjdF9yYXRpb19pZGMgPiAwICYmIGFzcGVjdF9yYXRpb19pZGMgPCAxNikge1xcbiAgICAgICAgICBwYXJfd2lkdGggPSBwYXJfd190YWJsZVthc3BlY3RfcmF0aW9faWRjIC0gMV07XFxuICAgICAgICAgIHBhcl9oZWlnaHQgPSBwYXJfaF90YWJsZVthc3BlY3RfcmF0aW9faWRjIC0gMV07XFxuICAgICAgICB9IGVsc2UgaWYgKGFzcGVjdF9yYXRpb19pZGMgPT09IDI1NSkge1xcbiAgICAgICAgICBwYXJfd2lkdGggPSBnYi5yZWFkQnl0ZSgpIDw8IDggfCBnYi5yZWFkQnl0ZSgpO1xcbiAgICAgICAgICBwYXJfaGVpZ2h0ID0gZ2IucmVhZEJ5dGUoKSA8PCA4IHwgZ2IucmVhZEJ5dGUoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGdiLnJlYWRCb29sKCkpIHtcXG4gICAgICAgIGdiLnJlYWRCb29sKCk7XFxuICAgICAgfVxcbiAgICAgIGlmIChnYi5yZWFkQm9vbCgpKSB7XFxuICAgICAgICBnYi5yZWFkQml0cyg0KTtcXG4gICAgICAgIGlmIChnYi5yZWFkQm9vbCgpKSB7XFxuICAgICAgICAgIGdiLnJlYWRCaXRzKDI0KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKGdiLnJlYWRCb29sKCkpIHtcXG4gICAgICAgIGdiLnJlYWRVRUcoKTtcXG4gICAgICAgIGdiLnJlYWRVRUcoKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGdiLnJlYWRCb29sKCkpIHtcXG4gICAgICAgIGxldCBudW1fdW5pdHNfaW5fdGljayA9IGdiLnJlYWRCaXRzKDMyKTtcXG4gICAgICAgIGxldCB0aW1lX3NjYWxlID0gZ2IucmVhZEJpdHMoMzIpO1xcbiAgICAgICAgZnBzX2ZpeGVkID0gZ2IucmVhZEJvb2woKTtcXG5cXG4gICAgICAgIGZwc19udW0gPSB0aW1lX3NjYWxlO1xcbiAgICAgICAgZnBzX2RlbiA9IG51bV91bml0c19pbl90aWNrICogMjtcXG4gICAgICAgIGZwcyA9IGZwc19udW0gLyBmcHNfZGVuO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBsZXQgcGFyU2NhbGUgPSAxO1xcbiAgICBpZiAocGFyX3dpZHRoICE9PSAxIHx8IHBhcl9oZWlnaHQgIT09IDEpIHtcXG4gICAgICBwYXJTY2FsZSA9IHBhcl93aWR0aCAvIHBhcl9oZWlnaHQ7XFxuICAgIH1cXG5cXG4gICAgbGV0IGNyb3BfdW5pdF94ID0gMCxcXG4gICAgICAgIGNyb3BfdW5pdF95ID0gMDtcXG4gICAgaWYgKGNocm9tYV9mb3JtYXRfaWRjID09PSAwKSB7XFxuICAgICAgY3JvcF91bml0X3ggPSAxO1xcbiAgICAgIGNyb3BfdW5pdF95ID0gMiAtIGZyYW1lX21ic19vbmx5X2ZsYWc7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbGV0IHN1Yl93YyA9IGNocm9tYV9mb3JtYXRfaWRjID09PSAzID8gMSA6IDI7XFxuICAgICAgbGV0IHN1Yl9oYyA9IGNocm9tYV9mb3JtYXRfaWRjID09PSAxID8gMiA6IDE7XFxuICAgICAgY3JvcF91bml0X3ggPSBzdWJfd2M7XFxuICAgICAgY3JvcF91bml0X3kgPSBzdWJfaGMgKiAoMiAtIGZyYW1lX21ic19vbmx5X2ZsYWcpO1xcbiAgICB9XFxuXFxuICAgIGxldCBjb2RlY193aWR0aCA9IChwaWNfd2lkdGhfaW5fbWJzX21pbnVzMSArIDEpICogMTY7XFxuICAgIGxldCBjb2RlY19oZWlnaHQgPSAoMiAtIGZyYW1lX21ic19vbmx5X2ZsYWcpICogKChwaWNfaGVpZ2h0X2luX21hcF91bml0c19taW51czEgKyAxKSAqIDE2KTtcXG5cXG4gICAgY29kZWNfd2lkdGggLT0gKGZyYW1lX2Nyb3BfbGVmdF9vZmZzZXQgKyBmcmFtZV9jcm9wX3JpZ2h0X29mZnNldCkgKiBjcm9wX3VuaXRfeDtcXG4gICAgY29kZWNfaGVpZ2h0IC09IChmcmFtZV9jcm9wX3RvcF9vZmZzZXQgKyBmcmFtZV9jcm9wX2JvdHRvbV9vZmZzZXQpICogY3JvcF91bml0X3k7XFxuXFxuICAgIGxldCBwcmVzZW50X3dpZHRoID0gTWF0aC5jZWlsKGNvZGVjX3dpZHRoICogcGFyU2NhbGUpO1xcblxcbiAgICBnYi5kZXN0cm95KCk7XFxuICAgIGdiID0gbnVsbDtcXG5cXG4gICAgcmV0dXJuIHtcXG4gICAgICBwcm9maWxlX3N0cmluZzogcHJvZmlsZV9zdHJpbmcsXFxuICAgICAgbGV2ZWxfc3RyaW5nOiBsZXZlbF9zdHJpbmcsXFxuICAgICAgYml0X2RlcHRoOiBiaXRfZGVwdGgsXFxuICAgICAgY2hyb21hX2Zvcm1hdDogY2hyb21hX2Zvcm1hdCxcXG4gICAgICBjaHJvbWFfZm9ybWF0X3N0cmluZzogU1BTUGFyc2VyLmdldENocm9tYUZvcm1hdFN0cmluZyhjaHJvbWFfZm9ybWF0KSxcXG5cXG4gICAgICBmcmFtZV9yYXRlOiB7XFxuICAgICAgICBmaXhlZDogZnBzX2ZpeGVkLFxcbiAgICAgICAgZnBzOiBmcHMsXFxuICAgICAgICBmcHNfZGVuOiBmcHNfZGVuLFxcbiAgICAgICAgZnBzX251bTogZnBzX251bVxcbiAgICAgIH0sXFxuXFxuICAgICAgcGFyX3JhdGlvOiB7XFxuICAgICAgICB3aWR0aDogcGFyX3dpZHRoLFxcbiAgICAgICAgaGVpZ2h0OiBwYXJfaGVpZ2h0XFxuICAgICAgfSxcXG5cXG4gICAgICBjb2RlY19zaXplOiB7XFxuICAgICAgICB3aWR0aDogY29kZWNfd2lkdGgsXFxuICAgICAgICBoZWlnaHQ6IGNvZGVjX2hlaWdodFxcbiAgICAgIH0sXFxuXFxuICAgICAgcHJlc2VudF9zaXplOiB7XFxuICAgICAgICB3aWR0aDogcHJlc2VudF93aWR0aCxcXG4gICAgICAgIGhlaWdodDogY29kZWNfaGVpZ2h0XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgc3RhdGljIF9za2lwU2NhbGluZ0xpc3QoZ2IsIGNvdW50KSB7XFxuICAgIGxldCBsYXN0X3NjYWxlID0gOCxcXG4gICAgICAgIG5leHRfc2NhbGUgPSA4O1xcbiAgICBsZXQgZGVsdGFfc2NhbGUgPSAwO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcXG4gICAgICBpZiAobmV4dF9zY2FsZSAhPT0gMCkge1xcbiAgICAgICAgZGVsdGFfc2NhbGUgPSBnYi5yZWFkU0VHKCk7XFxuICAgICAgICBuZXh0X3NjYWxlID0gKGxhc3Rfc2NhbGUgKyBkZWx0YV9zY2FsZSArIDI1NikgJSAyNTY7XFxuICAgICAgfVxcbiAgICAgIGxhc3Rfc2NhbGUgPSBuZXh0X3NjYWxlID09PSAwID8gbGFzdF9zY2FsZSA6IG5leHRfc2NhbGU7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXRQcm9maWxlU3RyaW5nKHByb2ZpbGVJZGMpIHtcXG4gICAgc3dpdGNoIChwcm9maWxlSWRjKSB7XFxuICAgICAgY2FzZSA2NjpcXG4gICAgICAgIHJldHVybiAnQmFzZWxpbmUnO1xcbiAgICAgIGNhc2UgNzc6XFxuICAgICAgICByZXR1cm4gJ01haW4nO1xcbiAgICAgIGNhc2UgODg6XFxuICAgICAgICByZXR1cm4gJ0V4dGVuZGVkJztcXG4gICAgICBjYXNlIDEwMDpcXG4gICAgICAgIHJldHVybiAnSGlnaCc7XFxuICAgICAgY2FzZSAxMTA6XFxuICAgICAgICByZXR1cm4gJ0hpZ2gxMCc7XFxuICAgICAgY2FzZSAxMjI6XFxuICAgICAgICByZXR1cm4gJ0hpZ2g0MjInO1xcbiAgICAgIGNhc2UgMjQ0OlxcbiAgICAgICAgcmV0dXJuICdIaWdoNDQ0JztcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgcmV0dXJuICdVbmtub3duJztcXG4gICAgfVxcbiAgfVxcblxcbiAgc3RhdGljIGdldExldmVsU3RyaW5nKGxldmVsSWRjKSB7XFxuICAgIHJldHVybiAobGV2ZWxJZGMgLyAxMCkudG9GaXhlZCgxKTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXRDaHJvbWFGb3JtYXRTdHJpbmcoY2hyb21hKSB7XFxuICAgIHN3aXRjaCAoY2hyb21hKSB7XFxuICAgICAgY2FzZSA0MjA6XFxuICAgICAgICByZXR1cm4gJzQ6MjowJztcXG4gICAgICBjYXNlIDQyMjpcXG4gICAgICAgIHJldHVybiAnNDoyOjInO1xcbiAgICAgIGNhc2UgNDQ0OlxcbiAgICAgICAgcmV0dXJuICc0OjQ6NCc7XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHJldHVybiAnVW5rbm93bic7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHN0YXRpYyB0b1ZpZGVvTWV0YShzcHNDb25maWcpIHtcXG4gICAgbGV0IG1ldGEgPSB7fTtcXG4gICAgaWYgKHNwc0NvbmZpZyAmJiBzcHNDb25maWcuY29kZWNfc2l6ZSkge1xcbiAgICAgIG1ldGEuY29kZWNXaWR0aCA9IHNwc0NvbmZpZy5jb2RlY19zaXplLndpZHRoO1xcbiAgICAgIG1ldGEuY29kZWNIZWlnaHQgPSBzcHNDb25maWcuY29kZWNfc2l6ZS5oZWlnaHQ7XFxuICAgICAgbWV0YS5wcmVzZW50V2lkdGggPSBzcHNDb25maWcucHJlc2VudF9zaXplLndpZHRoO1xcbiAgICAgIG1ldGEucHJlc2VudEhlaWdodCA9IHNwc0NvbmZpZy5wcmVzZW50X3NpemUuaGVpZ2h0O1xcbiAgICB9XFxuXFxuICAgIG1ldGEucHJvZmlsZSA9IHNwc0NvbmZpZy5wcm9maWxlX3N0cmluZztcXG4gICAgbWV0YS5sZXZlbCA9IHNwc0NvbmZpZy5sZXZlbF9zdHJpbmc7XFxuICAgIG1ldGEuYml0RGVwdGggPSBzcHNDb25maWcuYml0X2RlcHRoO1xcbiAgICBtZXRhLmNocm9tYUZvcm1hdCA9IHNwc0NvbmZpZy5jaHJvbWFfZm9ybWF0O1xcblxcbiAgICBtZXRhLnBhclJhdGlvID0ge1xcbiAgICAgIHdpZHRoOiBzcHNDb25maWcucGFyX3JhdGlvLndpZHRoLFxcbiAgICAgIGhlaWdodDogc3BzQ29uZmlnLnBhcl9yYXRpby5oZWlnaHRcXG4gICAgfTtcXG5cXG4gICAgbWV0YS5mcmFtZVJhdGUgPSBzcHNDb25maWcuZnJhbWVfcmF0ZTtcXG5cXG4gICAgbGV0IGZwc0RlbiA9IG1ldGEuZnJhbWVSYXRlLmZwc19kZW47XFxuICAgIGxldCBmcHNOdW0gPSBtZXRhLmZyYW1lUmF0ZS5mcHNfbnVtO1xcbiAgICBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uID0gTWF0aC5mbG9vcihtZXRhLnRpbWVzY2FsZSAqIChmcHNEZW4gLyBmcHNOdW0pKTtcXG4gICAgcmV0dXJuIG1ldGE7XFxuICB9XFxufSAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgICovXFxuLyogZXNsaW50LWRpc2FibGUgb25lLXZhciAgKi9cXG5leHBvcnRzLmRlZmF1bHQgPSBTUFNQYXJzZXI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLWNvZGVjL3NyYy9oMjY0L25hbHVuaXQvc3BzLmpzP1wiKX0sXCIuLi94Z3BsYXllci1kZW11eC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci1kZW11eC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoJ1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgLy8gSExTXFxuICBNM1U4UGFyc2VyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9obHMvZGVtdXhlci9tM3U4cGFyc2VyICovIFwiLi4veGdwbGF5ZXItZGVtdXgvc3JjL2hscy9kZW11eGVyL20zdThwYXJzZXIuanNcIikuZGVmYXVsdCxcXG4gIFRzRGVtdXhlcjogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvaGxzL2RlbXV4ZXIvdHMgKi8gXCIuLi94Z3BsYXllci1kZW11eC9zcmMvaGxzL2RlbXV4ZXIvdHMuanNcIikuZGVmYXVsdCxcXG4gIFBsYXlsaXN0OiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9obHMvcGxheWxpc3QgKi8gXCIuLi94Z3BsYXllci1kZW11eC9zcmMvaGxzL3BsYXlsaXN0LmpzXCIpLmRlZmF1bHQsXFxuICBGbHZEZW11eGVyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9mbHYvaW5kZXggKi8gXCIuLi94Z3BsYXllci1kZW11eC9zcmMvZmx2L2luZGV4LmpzXCIpLmRlZmF1bHRcXG59O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci1kZW11eC9pbmRleC5qcz8nKX0sXCIuLi94Z3BsYXllci1kZW11eC9zcmMvZmx2L2FtZi1wYXJzZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLWRlbXV4L3NyYy9mbHYvYW1mLXBhcnNlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgX3hncGxheWVyVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB4Z3BsYXllci11dGlscyAqLyBcXFwiLi4veGdwbGF5ZXItdXRpbHMvaW5kZXguanNcXFwiKTtcXG5cXG5jb25zdCBEQVRBX1RZUEVTID0ge1xcbiAgTlVNQkVSOiAwLFxcbiAgQk9PTEVBTjogMSxcXG4gIFNUUklORzogMixcXG4gIE9CSkVDVDogMyxcXG4gIE1JWF9BUlJBWTogOCxcXG4gIE9CSkVDVF9FTkQ6IDksXFxuICBTVFJJQ1RfQVJSQVk6IDEwLFxcbiAgREFURTogMTEsXFxuICBMT05FX1NUUklORzogMTJcXG5cXG4gIC8qKlxcbiAgICogbWV0YeS/oeaBr+ino+aekFxcbiAgICovXFxufTtjbGFzcyBBTUZQYXJzZXIge1xcbiAgY29uc3RydWN0b3IoKSB7XFxuICAgIHRoaXMub2Zmc2V0ID0gMDtcXG4gICAgdGhpcy5yZWFkT2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XFxuICB9XFxuXFxuICByZXNvbHZlKG1ldGEsIHNpemUpIHtcXG4gICAgaWYgKHNpemUgPCAzKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgZW5vdWdoIGRhdGEgZm9yIG1ldGFpbmZvJyk7XFxuICAgIH1cXG4gICAgY29uc3QgbWV0YURhdGEgPSB7fTtcXG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VWYWx1ZShtZXRhKTtcXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnBhcnNlVmFsdWUobWV0YSwgc2l6ZSAtIG5hbWUuYm9keVNpemUpO1xcbiAgICBtZXRhRGF0YVtuYW1lLmRhdGFdID0gdmFsdWUuZGF0YTtcXG5cXG4gICAgdGhpcy5yZXNldFN0YXR1cygpO1xcbiAgICByZXR1cm4gbWV0YURhdGE7XFxuICB9XFxuXFxuICByZXNldFN0YXR1cygpIHtcXG4gICAgdGhpcy5vZmZzZXQgPSAwO1xcbiAgICB0aGlzLnJlYWRPZmZzZXQgPSB0aGlzLm9mZnNldDtcXG4gIH1cXG5cXG4gIHBhcnNlU3RyaW5nKGJ1ZmZlcikge1xcbiAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhidWZmZXIsIHRoaXMucmVhZE9mZnNldCk7XFxuICAgIGNvbnN0IHN0ckxlbiA9IGR2LmdldFVpbnQxNigwLCAhX3hncGxheWVyVXRpbHMuaXNMZSk7XFxuICAgIGxldCBzdHIgPSAnJztcXG4gICAgaWYgKHN0ckxlbiA+IDApIHtcXG4gICAgICBzdHIgPSBfeGdwbGF5ZXJVdGlscy5VVEY4LmRlY29kZShuZXcgVWludDhBcnJheShidWZmZXIsIHRoaXMucmVhZE9mZnNldCArIDIsIHN0ckxlbikpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN0ciA9ICcnO1xcbiAgICB9XFxuICAgIGxldCBzaXplID0gc3RyTGVuICsgMjtcXG4gICAgdGhpcy5yZWFkT2Zmc2V0ICs9IHNpemU7XFxuICAgIHJldHVybiB7XFxuICAgICAgZGF0YTogc3RyLFxcbiAgICAgIGJvZHlTaXplOiBzdHJMZW4gKyAyXFxuICAgIH07XFxuICB9XFxuXFxuICBwYXJzZURhdGUoYnVmZmVyLCBzaXplKSB7XFxuICAgIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KGJ1ZmZlciwgdGhpcy5yZWFkT2Zmc2V0LCBzaXplKTtcXG4gICAgbGV0IHRzID0gZHYuZ2V0RmxvYXQ2NCgwLCAhX3hncGxheWVyVXRpbHMuaXNMZSk7XFxuICAgIGNvbnN0IHRpbWVPZmZzZXQgPSBkdi5nZXRJbnQxNig4LCAhX3hncGxheWVyVXRpbHMuaXNMZSk7XFxuICAgIHRzICs9IHRpbWVPZmZzZXQgKiA2MCAqIDEwMDA7XFxuXFxuICAgIHRoaXMucmVhZE9mZnNldCArPSAxMDtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBkYXRhOiBuZXcgRGF0ZSh0cyksXFxuICAgICAgYm9keVNpemU6IDEwXFxuICAgIH07XFxuICB9XFxuXFxuICBwYXJzZU9iamVjdChidWZmZXIsIHNpemUpIHtcXG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VTdHJpbmcoYnVmZmVyLCBzaXplKTtcXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnBhcnNlVmFsdWUoYnVmZmVyLCBzaXplIC0gbmFtZS5ib2R5U2l6ZSk7XFxuICAgIHJldHVybiB7XFxuICAgICAgZGF0YToge1xcbiAgICAgICAgbmFtZTogbmFtZS5kYXRhLFxcbiAgICAgICAgdmFsdWU6IHZhbHVlLmRhdGFcXG4gICAgICB9LFxcbiAgICAgIGJvZHlTaXplOiBuYW1lLmJvZHlTaXplICsgdmFsdWUuYm9keVNpemUsXFxuICAgICAgaXNPYmpFbmQ6IHZhbHVlLmlzT2JqRW5kXFxuICAgIH07XFxuICB9XFxuXFxuICBwYXJzZUxvbmdTdHJpbmcoYnVmZmVyKSB7XFxuICAgIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KGJ1ZmZlciwgdGhpcy5yZWFkT2Zmc2V0KTtcXG4gICAgY29uc3Qgc3RyTGVuID0gZHYuZ2V0VWludDMyKDAsICFfeGdwbGF5ZXJVdGlscy5pc0xlKTtcXG4gICAgbGV0IHN0ciA9ICcnO1xcbiAgICBpZiAoc3RyTGVuID4gMCkge1xcbiAgICAgIHN0ciA9IF94Z3BsYXllclV0aWxzLlVURjguZGVjb2RlKG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgdGhpcy5yZWFkT2Zmc2V0ICsgMiwgc3RyTGVuKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3RyID0gJyc7XFxuICAgIH1cXG4gICAgLy8gY29uc3Qgc2l6ZSA9IHN0ckxlbiArIDQ7XFxuICAgIHRoaXMucmVhZE9mZnNldCArPSBzdHJMZW4gKyA0O1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGRhdGE6IHN0cixcXG4gICAgICBib2R5U2l6ZTogc3RyTGVuICsgNFxcbiAgICB9O1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiDop6PmnpBtZXRh5Lit55qE5Y+Y6YePXFxuICAgKi9cXG4gIHBhcnNlVmFsdWUoZGF0YSwgc2l6ZSkge1xcbiAgICBsZXQgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKCk7XFxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcXG4gICAgICBidWZmZXIgPSBkYXRhO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGJ1ZmZlciA9IGRhdGEuYnVmZmVyO1xcbiAgICB9XFxuICAgIGNvbnN0IHtcXG4gICAgICBOVU1CRVIsXFxuICAgICAgQk9PTEVBTixcXG4gICAgICBTVFJJTkcsXFxuICAgICAgT0JKRUNULFxcbiAgICAgIE1JWF9BUlJBWSxcXG4gICAgICBPQkpFQ1RfRU5ELFxcbiAgICAgIFNUUklDVF9BUlJBWSxcXG4gICAgICBEQVRFLFxcbiAgICAgIExPTkVfU1RSSU5HXFxuICAgIH0gPSBEQVRBX1RZUEVTO1xcbiAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIsIHRoaXMucmVhZE9mZnNldCwgc2l6ZSk7XFxuICAgIGxldCBpc09iakVuZCA9IGZhbHNlO1xcbiAgICBjb25zdCB0eXBlID0gZGF0YVZpZXcuZ2V0VWludDgoMCk7XFxuICAgIGxldCBvZmZzZXQgPSAxO1xcbiAgICB0aGlzLnJlYWRPZmZzZXQgKz0gMTtcXG4gICAgbGV0IHZhbHVlID0gbnVsbDtcXG5cXG4gICAgc3dpdGNoICh0eXBlKSB7XFxuICAgICAgY2FzZSBOVU1CRVI6XFxuICAgICAgICB7XFxuICAgICAgICAgIHZhbHVlID0gZGF0YVZpZXcuZ2V0RmxvYXQ2NCgxLCAhX3hncGxheWVyVXRpbHMuaXNMZSk7XFxuICAgICAgICAgIHRoaXMucmVhZE9mZnNldCArPSA4O1xcbiAgICAgICAgICBvZmZzZXQgKz0gODtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgY2FzZSBCT09MRUFOOlxcbiAgICAgICAge1xcbiAgICAgICAgICBjb25zdCBib29sTnVtID0gZGF0YVZpZXcuZ2V0VWludDgoMSk7XFxuICAgICAgICAgIHZhbHVlID0gISFib29sTnVtO1xcbiAgICAgICAgICB0aGlzLnJlYWRPZmZzZXQgKz0gMTtcXG4gICAgICAgICAgb2Zmc2V0ICs9IDE7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIGNhc2UgU1RSSU5HOlxcbiAgICAgICAge1xcbiAgICAgICAgICBjb25zdCBzdHIgPSB0aGlzLnBhcnNlU3RyaW5nKGJ1ZmZlcik7XFxuICAgICAgICAgIHZhbHVlID0gc3RyLmRhdGE7XFxuICAgICAgICAgIG9mZnNldCArPSBzdHIuYm9keVNpemU7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIGNhc2UgT0JKRUNUOlxcbiAgICAgICAge1xcbiAgICAgICAgICB2YWx1ZSA9IHt9O1xcbiAgICAgICAgICBsZXQgb2JqRW5kU2l6ZSA9IDA7XFxuICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MzIoc2l6ZSAtIDQsICFfeGdwbGF5ZXJVdGlscy5pc0xlKSAmIDB4MDBGRkZGRkYpIHtcXG4gICAgICAgICAgICBvYmpFbmRTaXplID0gMztcXG4gICAgICAgICAgfVxcbiAgICAgICAgICAvLyB0aGlzLnJlYWRPZmZzZXQgKz0gb2Zmc2V0IC0gMTtcXG4gICAgICAgICAgd2hpbGUgKG9mZnNldCA8IHNpemUgLSA0KSB7XFxuICAgICAgICAgICAgY29uc3QgYW1mT2JqID0gdGhpcy5wYXJzZU9iamVjdChidWZmZXIsIHNpemUgLSBvZmZzZXQgLSBvYmpFbmRTaXplKTtcXG4gICAgICAgICAgICBpZiAoYW1mT2JqLmlzT2JqZWN0RW5kKSB7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdmFsdWVbYW1mT2JqLmRhdGEubmFtZV0gPSBhbWZPYmouZGF0YS52YWx1ZTtcXG4gICAgICAgICAgICBvZmZzZXQgKz0gYW1mT2JqLmJvZHlTaXplO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChvZmZzZXQgPD0gc2l6ZSAtIDMpIHtcXG4gICAgICAgICAgICBjb25zdCBtYXJrID0gZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCAtIDEsICFfeGdwbGF5ZXJVdGlscy5pc0xlKSAmIDB4MDBGRkZGRkY7XFxuICAgICAgICAgICAgaWYgKG1hcmsgPT09IDkpIHtcXG4gICAgICAgICAgICAgIHRoaXMucmVhZE9mZnNldCArPSAzO1xcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IDM7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIGNhc2UgTUlYX0FSUkFZOlxcbiAgICAgICAge1xcbiAgICAgICAgICB2YWx1ZSA9IHt9O1xcbiAgICAgICAgICBvZmZzZXQgKz0gNDtcXG4gICAgICAgICAgdGhpcy5yZWFkT2Zmc2V0ICs9IDQ7XFxuICAgICAgICAgIGxldCBvYmpFbmRTaXplID0gMDtcXG4gICAgICAgICAgaWYgKChkYXRhVmlldy5nZXRVaW50MzIoc2l6ZSAtIDQsICFfeGdwbGF5ZXJVdGlscy5pc0xlKSAmIDB4MDBGRkZGRkYpID09PSA5KSB7XFxuICAgICAgICAgICAgb2JqRW5kU2l6ZSA9IDM7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgd2hpbGUgKG9mZnNldCA8IHNpemUgLSA4KSB7XFxuICAgICAgICAgICAgY29uc3QgYW1mVmFyID0gdGhpcy5wYXJzZU9iamVjdChidWZmZXIsIHNpemUgLSBvZmZzZXQgLSBvYmpFbmRTaXplKTtcXG4gICAgICAgICAgICBpZiAoYW1mVmFyLmlzT2JqZWN0RW5kKSB7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdmFsdWVbYW1mVmFyLmRhdGEubmFtZV0gPSBhbWZWYXIuZGF0YS52YWx1ZTtcXG4gICAgICAgICAgICBvZmZzZXQgKz0gYW1mVmFyLmJvZHlTaXplO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChvZmZzZXQgPD0gc2l6ZSAtIDMpIHtcXG4gICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0IC0gMSwgIV94Z3BsYXllclV0aWxzLmlzTGUpICYgMHgwMEZGRkZGRjtcXG4gICAgICAgICAgICBpZiAobWFya2VyID09PSA5KSB7XFxuICAgICAgICAgICAgICBvZmZzZXQgKz0gMztcXG4gICAgICAgICAgICAgIHRoaXMucmVhZE9mZnNldCArPSAzO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG5cXG4gICAgICBjYXNlIE9CSkVDVF9FTkQ6XFxuICAgICAgICB7XFxuICAgICAgICAgIHZhbHVlID0gbnVsbDtcXG4gICAgICAgICAgaXNPYmpFbmQgPSB0cnVlO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG5cXG4gICAgICBjYXNlIFNUUklDVF9BUlJBWTpcXG4gICAgICAgIHtcXG4gICAgICAgICAgdmFsdWUgPSBbXTtcXG4gICAgICAgICAgY29uc3QgYXJyTGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDMyKDEsICFfeGdwbGF5ZXJVdGlscy5pc0xlKTtcXG4gICAgICAgICAgb2Zmc2V0ICs9IDQ7XFxuICAgICAgICAgIHRoaXMucmVhZE9mZnNldCArPSA0O1xcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgY29uc3Qgc2NyaXB0ID0gdGhpcy5wYXJzZVZhbHVlKGJ1ZmZlciwgc2l6ZSAtIG9mZnNldCk7XFxuICAgICAgICAgICAgdmFsdWUucHVzaChzY3JpcHQuZGF0YSk7XFxuICAgICAgICAgICAgb2Zmc2V0ICs9IHNjcmlwdC5ib2R5U2l6ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG5cXG4gICAgICBjYXNlIERBVEU6XFxuICAgICAgICB7XFxuICAgICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLnBhcnNlRGF0ZShidWZmZXIsIHNpemUgLSAxKTtcXG4gICAgICAgICAgdmFsdWUgPSBkYXRlLmRhdGE7XFxuICAgICAgICAgIG9mZnNldCArPSBkYXRlLmJvZHlTaXplO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG5cXG4gICAgICBjYXNlIExPTkVfU1RSSU5HOlxcbiAgICAgICAge1xcbiAgICAgICAgICBjb25zdCBsb25nU3RyID0gdGhpcy5wYXJzZUxvbmdTdHJpbmcoYnVmZmVyLCBzaXplIC0gMSk7XFxuICAgICAgICAgIHZhbHVlID0gbG9uZ1N0ci5kYXRhO1xcbiAgICAgICAgICBvZmZzZXQgKz0gbG9uZ1N0ci5ib2R5U2l6ZTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuXFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHtcXG4gICAgICAgICAgb2Zmc2V0ID0gc2l6ZTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4ge1xcbiAgICAgIGRhdGE6IHZhbHVlLFxcbiAgICAgIGJvZHlTaXplOiBvZmZzZXQsXFxuICAgICAgaXNPYmpFbmQ6IGlzT2JqRW5kXFxuICAgIH07XFxuICB9XFxufVxcbmV4cG9ydHMuZGVmYXVsdCA9IEFNRlBhcnNlcjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItZGVtdXgvc3JjL2Zsdi9hbWYtcGFyc2VyLmpzP1wiKX0sXCIuLi94Z3BsYXllci1kZW11eC9zcmMvZmx2L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItZGVtdXgvc3JjL2Zsdi9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIF94Z3BsYXllclV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgeGdwbGF5ZXItdXRpbHMgKi8gXFxcIi4uL3hncGxheWVyLXV0aWxzL2luZGV4LmpzXFxcIik7XFxuXFxudmFyIF94Z3BsYXllckNvZGVjID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgeGdwbGF5ZXItY29kZWMgKi8gXFxcIi4uL3hncGxheWVyLWNvZGVjL2luZGV4LmpzXFxcIik7XFxuXFxudmFyIF94Z3BsYXllckJ1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHhncGxheWVyLWJ1ZmZlciAqLyBcXFwiLi4veGdwbGF5ZXItYnVmZmVyL2luZGV4LmpzXFxcIik7XFxuXFxudmFyIF9hbWZQYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FtZi1wYXJzZXIgKi8gXFxcIi4uL3hncGxheWVyLWRlbXV4L3NyYy9mbHYvYW1mLXBhcnNlci5qc1xcXCIpO1xcblxcbnZhciBfYW1mUGFyc2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FtZlBhcnNlcik7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG5jb25zdCBERU1VWF9FVkVOVFMgPSBfeGdwbGF5ZXJVdGlscy5FVkVOVFMuREVNVVhfRVZFTlRTO1xcblxcbmNsYXNzIEZsdkRlbXV4ZXIge1xcbiAgY29uc3RydWN0b3IoKSB7XFxuICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnRMb2FkZWQgPSBmYWxzZTtcXG4gICAgdGhpcy5fdHJhY2tOdW0gPSAwO1xcbiAgICB0aGlzLl9oYXNTY3JpcHQgPSBmYWxzZTtcXG4gIH1cXG5cXG4gIGluaXQoKSB7XFxuICAgIHRoaXMub24oREVNVVhfRVZFTlRTLkRFTVVYX1NUQVJULCB0aGlzLmRvUGFyc2VGbHYuYmluZCh0aGlzKSk7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIGlmIHRoZSBmbHYgaGVhZCBpcyB2YWxpZFxcbiAgICogQHBhcmFtIGRhdGFcXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxcbiAgICovXFxuICBzdGF0aWMgaXNGbHZGaWxlKGRhdGEpIHtcXG4gICAgcmV0dXJuICEoZGF0YVswXSAhPT0gMHg0NiB8fCBkYXRhWzFdICE9PSAweDRDIHx8IGRhdGFbMl0gIT09IDB4NTYgfHwgZGF0YVszXSAhPT0gMHgwMSk7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIElmIHRoZSBzdHJlYW0gaGFzIGF1ZGlvIG9yIHZpZGVvLlxcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmVhbUZsYWcgLSBEYXRhIGZyb20gdGhlIHN0cmVhbSB3aGljaCBpcyBkZWZpbmUgd2hldGhlciB0aGUgYXVkaW8gLyB2aWRlbyB0cmFjayBpcyBleGlzdC5cXG4gICAqL1xcbiAgc3RhdGljIGdldFBsYXlUeXBlKHN0cmVhbUZsYWcpIHtcXG4gICAgY29uc3QgcmVzdWx0ID0ge1xcbiAgICAgIGhhc1ZpZGVvOiBmYWxzZSxcXG4gICAgICBoYXNBdWRpbzogZmFsc2VcXG4gICAgfTtcXG5cXG4gICAgaWYgKHN0cmVhbUZsYWcgJiAweDAxID4gMCkge1xcbiAgICAgIHJlc3VsdC5oYXNWaWRlbyA9IHRydWU7XFxuICAgIH1cXG5cXG4gICAgaWYgKHN0cmVhbUZsYWcgJiAweDA0ID4gMCkge1xcbiAgICAgIHJlc3VsdC5oYXNBdWRpbyA9IHRydWU7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH1cXG5cXG4gIGRvUGFyc2VGbHYoKSB7XFxuICAgIGlmICghdGhpcy5fZmlyc3RGcmFnbWVudExvYWRlZCkge1xcbiAgICAgIGlmICh0aGlzLmxvYWRlckJ1ZmZlci5sZW5ndGggPCAxMykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICBjb25zdCBoZWFkZXIgPSB0aGlzLmxvYWRlckJ1ZmZlci5zaGlmdCgxMyk7XFxuICAgICAgdGhpcy5wYXJzZUZsdkhlYWRlcihoZWFkZXIpO1xcbiAgICAgIHRoaXMuZG9QYXJzZUZsdigpOyAvLyDpgJLlvZLosIPnlKjvvIznu6fnu63op6PmnpBmbHbmtYFcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAodGhpcy5sb2FkZXJCdWZmZXIubGVuZ3RoIDwgMTEpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgICAgbGV0IGNodW5rO1xcblxcbiAgICAgIGxldCBsb29wTWF4ID0gMTAwMDAwOyAvLyDpmLLmraLmrbvlvqrnjq/kuqfnlJ9cXG4gICAgICBkbyB7XFxuICAgICAgICBjaHVuayA9IHRoaXMuX3BhcnNlRmx2VGFnKCk7XFxuICAgICAgfSB3aGlsZSAoY2h1bmsgJiYgbG9vcE1heC0tID4gMCk7XFxuXFxuICAgICAgdGhpcy5lbWl0KERFTVVYX0VWRU5UUy5ERU1VWF9DT01QTEVURSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHBhcnNlRmx2SGVhZGVyKGhlYWRlcikge1xcbiAgICBpZiAoIUZsdkRlbXV4ZXIuaXNGbHZGaWxlKGhlYWRlcikpIHtcXG4gICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLkRFTVVYX0VSUk9SLCBuZXcgRXJyb3IoJ2ludmFsaWQgZmx2IGZpbGUnKSk7XFxuICAgICAgdGhpcy5kb1BhcnNlRmx2KCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhpcy5fZmlyc3RGcmFnbWVudExvYWRlZCA9IHRydWU7XFxuICAgICAgY29uc3QgcGxheVR5cGUgPSBGbHZEZW11eGVyLmdldFBsYXlUeXBlKGhlYWRlcls0XSk7XFxuXFxuICAgICAgaWYgKHBsYXlUeXBlLmhhc1ZpZGVvKSB7XFxuICAgICAgICB0aGlzLmluaXRWaWRlb1RyYWNrKCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChwbGF5VHlwZS5oYXNBdWRpbykge1xcbiAgICAgICAgdGhpcy5pbml0QXVkaW9UcmFjaygpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICB0aGlzLmRvUGFyc2VGbHYoKTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogaW5pdCBkZWZhdWx0IHZpZGVvIHRyYWNrIGNvbmZpZ3NcXG4gICAqL1xcbiAgaW5pdFZpZGVvVHJhY2soKSB7XFxuICAgIHRoaXMuX3RyYWNrTnVtKys7XFxuICAgIGxldCB2aWRlb1RyYWNrID0gbmV3IF94Z3BsYXllckJ1ZmZlci5WaWRlb1RyYWNrKCk7XFxuICAgIHZpZGVvVHJhY2subWV0YSA9IG5ldyBfeGdwbGF5ZXJVdGlscy5WaWRlb1RyYWNrTWV0YSgpO1xcbiAgICB2aWRlb1RyYWNrLmlkID0gdmlkZW9UcmFjay5tZXRhLmlkID0gdGhpcy5fdHJhY2tOdW07XFxuXFxuICAgIHRoaXMudHJhY2tzLnZpZGVvVHJhY2sgPSB2aWRlb1RyYWNrO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBpbml0IGRlZmF1bHQgYXVkaW8gdHJhY2sgY29uZmlnc1xcbiAgICovXFxuICBpbml0QXVkaW9UcmFjaygpIHtcXG4gICAgdGhpcy5fdHJhY2tOdW0rKztcXG4gICAgbGV0IGF1ZGlvVHJhY2sgPSBuZXcgX3hncGxheWVyQnVmZmVyLkF1ZGlvVHJhY2soKTtcXG4gICAgYXVkaW9UcmFjay5tZXRhID0gbmV3IF94Z3BsYXllclV0aWxzLkF1ZGlvVHJhY2tNZXRhKCk7XFxuICAgIGF1ZGlvVHJhY2suaWQgPSBhdWRpb1RyYWNrLm1ldGEuaWQgPSB0aGlzLl90cmFja051bTtcXG5cXG4gICAgdGhpcy50cmFja3MuYXVkaW9UcmFjayA9IGF1ZGlvVHJhY2s7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIFBhY2thZ2UgdGhlIGRhdGEgYXMgdGhlIGZvbGxvd2luZyBkYXRhIHN0cnVjdHVyZVxcbiAgICoge1xcbiAgICogICAgZGF0YTogVWludDhBcnJheS4gdGhlIFN0cmVhbSBkYXRhLlxcbiAgICogICAgaW5mbzogVGhlIGZpcnN0IGJ5dGUgaW5mbyBvZiB0aGUgVGFnLlxcbiAgICogICAgdGFnVHlwZTogOOOAgTnjgIExOFxcbiAgICogICAgdGltZVN0YW1wOiB0aGUgdGltZXN0ZW1wXFxuICAgKiB9XFxuICAgKi9cXG4gIF9wYXJzZUZsdlRhZygpIHtcXG4gICAgaWYgKHRoaXMubG9hZGVyQnVmZmVyLmxlbmd0aCA8IDExKSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gICAgbGV0IGNodW5rID0gdGhpcy5fcGFyc2VGbHZUYWdIZWFkZXIoKTtcXG4gICAgaWYgKGNodW5rKSB7XFxuICAgICAgdGhpcy5fcHJvY2Vzc0NodW5rKGNodW5rKTtcXG4gICAgfVxcbiAgICByZXR1cm4gY2h1bms7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIFBhcnNlIHRoZSAxMSBieXRlIHRhZyBIZWFkZXJcXG4gICAqL1xcbiAgX3BhcnNlRmx2VGFnSGVhZGVyKCkge1xcbiAgICBsZXQgb2Zmc2V0ID0gMDtcXG4gICAgbGV0IGNodW5rID0ge307XFxuXFxuICAgIGxldCB0YWdUeXBlID0gdGhpcy5sb2FkZXJCdWZmZXIudG9JbnQob2Zmc2V0LCAxKTtcXG4gICAgb2Zmc2V0ICs9IDE7XFxuXFxuICAgIC8vIDIgYml0IEZNUyByZXNlcnZlZCwgMSBiaXQgZmlsdGVyZWQsIDUgYml0IHRhZyB0eXBlXFxuICAgIGNodW5rLmZpbHRlcmVkID0gKHRhZ1R5cGUgJiAzMikgPj4+IDU7XFxuICAgIGNodW5rLnRhZ1R5cGUgPSB0YWdUeXBlICYgMzE7XFxuXFxuICAgIC8vIDMgQnl0ZSBkYXRhc2l6ZVxcbiAgICBjaHVuay5kYXRhc2l6ZSA9IHRoaXMubG9hZGVyQnVmZmVyLnRvSW50KG9mZnNldCwgMyk7XFxuICAgIG9mZnNldCArPSAzO1xcblxcbiAgICBpZiAoY2h1bmsudGFnVHlwZSAhPT0gOCAmJiBjaHVuay50YWdUeXBlICE9PSA5ICYmIGNodW5rLnRhZ1R5cGUgIT09IDExICYmIGNodW5rLnRhZ1R5cGUgIT09IDE4IHx8IHRoaXMubG9hZGVyQnVmZmVyLnRvSW50KDgsIDMpICE9PSAwKSB7XFxuICAgICAgaWYgKHRoaXMubG9hZGVyQnVmZmVyICYmIHRoaXMubG9hZGVyQnVmZmVyLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIHRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDEpO1xcbiAgICAgIH1cXG4gICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLkRFTVVYX0VSUk9SLCB0aGlzLlRBRywgbmV3IEVycm9yKCd0YWdUeXBlICcgKyBjaHVuay50YWdUeXBlKSwgZmFsc2UpO1xcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLmxvYWRlckJ1ZmZlci5sZW5ndGggPCBjaHVuay5kYXRhc2l6ZSArIDE1KSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG5cXG4gICAgLy8gcmVhZCB0aGUgZGF0YS5cXG4gICAgdGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoNCk7XFxuXFxuICAgIC8vIDMgQnl0ZSB0aW1lc3RhbXBcXG4gICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubG9hZGVyQnVmZmVyLnRvSW50KDAsIDMpO1xcbiAgICB0aGlzLmxvYWRlckJ1ZmZlci5zaGlmdCgzKTtcXG5cXG4gICAgLy8gMSBCeXRlIHRpbWVzdGFtcEV4dFxcbiAgICBsZXQgdGltZXN0YW1wRXh0ID0gdGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoMSlbMF07XFxuICAgIGlmICh0aW1lc3RhbXBFeHQgPiAwKSB7XFxuICAgICAgdGltZXN0YW1wICs9IHRpbWVzdGFtcEV4dCAqIDB4MTAwMDAwMDtcXG4gICAgfVxcblxcbiAgICBjaHVuay5kdHMgPSB0aW1lc3RhbXA7XFxuXFxuICAgIC8vIHN0cmVhbUlkXFxuICAgIHRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDMpO1xcbiAgICByZXR1cm4gY2h1bms7XFxuICB9XFxuXFxuICBfcHJvY2Vzc0NodW5rKGNodW5rKSB7XFxuICAgIHN3aXRjaCAoY2h1bmsudGFnVHlwZSkge1xcbiAgICAgIGNhc2UgMTg6XFxuICAgICAgICB0aGlzLl9wYXJzZVNjcmlwdERhdGEoY2h1bmspO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSA4OlxcbiAgICAgICAgdGhpcy5fcGFyc2VBQUNEYXRhKGNodW5rKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgOTpcXG4gICAgICAgIHRoaXMuX3BhcnNlSGV2Y0RhdGEoY2h1bmspO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAxMTpcXG4gICAgICAgIC8vIGZvciBzb21lIENETiB0aGF0IGRpZCBub3QgcHJvY2VzcyB0aGUgY3VycmVjdCBSVE1QIG1lc3NhZ2VzXFxuICAgICAgICB0aGlzLmxvYWRlckJ1ZmZlci5zaGlmdCgzKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICB0aGlzLmxvYWRlckJ1ZmZlci5zaGlmdCgxKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBwYXJzZSBmbHYgc2NyaXB0IGRhdGFcXG4gICAqIEBwYXJhbSBjaHVua1xcbiAgICogQHByaXZhdGVcXG4gICAqL1xcbiAgX3BhcnNlU2NyaXB0RGF0YShjaHVuaykge1xcbiAgICBsZXQgYXVkaW9UcmFjayA9IHRoaXMudHJhY2tzLmF1ZGlvVHJhY2s7XFxuICAgIGxldCB2aWRlb1RyYWNrID0gdGhpcy50cmFja3MudmlkZW9UcmFjaztcXG5cXG4gICAgbGV0IGRhdGEgPSB0aGlzLmxvYWRlckJ1ZmZlci5zaGlmdChjaHVuay5kYXRhc2l6ZSk7XFxuXFxuICAgIGNvbnN0IGluZm8gPSBuZXcgX2FtZlBhcnNlcjIuZGVmYXVsdCgpLnJlc29sdmUoZGF0YSwgZGF0YS5sZW5ndGgpO1xcblxcbiAgICBjb25zdCBvbk1ldGFEYXRhID0gdGhpcy5fY29udGV4dC5vbk1ldGFEYXRhID0gaW5mbyA/IGluZm8ub25NZXRhRGF0YSA6IHVuZGVmaW5lZDtcXG5cXG4gICAgLy8gZmlsbCBtZWRpYUluZm9cXG4gICAgdGhpcy5fY29udGV4dC5tZWRpYUluZm8uZHVyYXRpb24gPSBvbk1ldGFEYXRhLmR1cmF0aW9uO1xcbiAgICB0aGlzLl9jb250ZXh0Lm1lZGlhSW5mby5oYXNWaWRlbyA9IG9uTWV0YURhdGEuaGFzVmlkZW87XFxuICAgIHRoaXMuX2NvbnRleHQubWVkaWFJbmZvLmhzYUF1ZGlvID0gb25NZXRhRGF0YS5oYXNBdWRpbztcXG5cXG4gICAgbGV0IHZhbGlkYXRlID0gdGhpcy5fZGF0YXNpemVWYWxpZGF0b3IoY2h1bmsuZGF0YXNpemUpO1xcbiAgICBpZiAodmFsaWRhdGUpIHtcXG4gICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLk1FRElBX0lORk8pO1xcbiAgICAgIHRoaXMuX2hhc1NjcmlwdCA9IHRydWU7XFxuICAgIH1cXG5cXG4gICAgLy8gRWRpdCBkZWZhdWx0IG1ldGEuXFxuICAgIGlmIChhdWRpb1RyYWNrICYmICFhdWRpb1RyYWNrLmhhc1NwZWNpZmljQ29uZmlnKSB7XFxuICAgICAgbGV0IG1ldGEgPSBhdWRpb1RyYWNrLm1ldGE7XFxuICAgICAgaWYgKG9uTWV0YURhdGEuYXVkaW9zYW1wbGVyYXRlKSB7XFxuICAgICAgICBtZXRhLnNhbXBsZVJhdGUgPSBvbk1ldGFEYXRhLmF1ZGlvc2FtcGxlcmF0ZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9uTWV0YURhdGEuYXVkaW9jaGFubmVscykge1xcbiAgICAgICAgbWV0YS5jaGFubmVsQ291bnQgPSBvbk1ldGFEYXRhLmF1ZGlvY2hhbm5lbHM7XFxuICAgICAgfVxcblxcbiAgICAgIHN3aXRjaCAob25NZXRhRGF0YS5hdWRpb3NhbXBsZXJhdGUpIHtcXG4gICAgICAgIGNhc2UgNDQxMDA6XFxuICAgICAgICAgIG1ldGEuc2FtcGxlUmF0ZUluZGV4ID0gNDtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlIDIyMDUwOlxcbiAgICAgICAgICBtZXRhLnNhbXBsZVJhdGVJbmRleCA9IDc7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSAxMTAyNTpcXG4gICAgICAgICAgbWV0YS5zYW1wbGVSYXRlSW5kZXggPSAxMDtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmICh2aWRlb1RyYWNrICYmICF2aWRlb1RyYWNrLmhhc1NwZWNpZmljQ29uZmlnKSB7XFxuICAgICAgbGV0IG1ldGEgPSB2aWRlb1RyYWNrLm1ldGE7XFxuICAgICAgaWYgKHR5cGVvZiBvbk1ldGFEYXRhLmZyYW1lcmF0ZSA9PT0gJ251bWJlcicpIHtcXG4gICAgICAgIGxldCBmcHNOdW0gPSBNYXRoLmZsb29yKG9uTWV0YURhdGEuZnJhbWVyYXRlICogMTAwMCk7XFxuICAgICAgICBpZiAoZnBzTnVtID4gMCkge1xcbiAgICAgICAgICBsZXQgZnBzID0gZnBzTnVtIC8gMTAwMDtcXG4gICAgICAgICAgaWYgKCFtZXRhLmZyYW1lUmF0ZSkge1xcbiAgICAgICAgICAgIG1ldGEuZnJhbWVSYXRlID0ge307XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgbWV0YS5mcmFtZVJhdGUuZml4ZWQgPSB0cnVlO1xcbiAgICAgICAgICBtZXRhLmZyYW1lUmF0ZS5mcHMgPSBmcHM7XFxuICAgICAgICAgIG1ldGEuZnJhbWVSYXRlLmZwc19udW0gPSBmcHNOdW07XFxuICAgICAgICAgIG1ldGEuZnJhbWVSYXRlLmZwc19kZW4gPSAxMDAwO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgX2FhY1NlcXVlbmNlSGVhZGVyUGFyc2VyKGRhdGEpIHtcXG4gICAgbGV0IHJldCA9IHt9O1xcbiAgICByZXQuaGFzU3BlY2lmaWNDb25maWcgPSB0cnVlO1xcbiAgICByZXQub2JqZWN0VHlwZSA9IGRhdGFbMV0gPj4+IDM7XFxuICAgIHJldC5zYW1wbGVSYXRlSW5kZXggPSAoZGF0YVsxXSAmIDcpIDw8IDEgfCBkYXRhWzJdID4+PiA3O1xcbiAgICByZXQuYXVkaW9zYW1wbGVyYXRlID0gdGhpcy5fc3dpdGNoQXVkaW9TYW1wbGVSYXRlKHJldC5zYW1wbGVSYXRlSW5kZXgpO1xcbiAgICByZXQuY2hhbm5lbENvdW50ID0gKGRhdGFbMl0gJiAxMjApID4+PiAzO1xcbiAgICByZXQuZnJhbWVMZW5ndGggPSAoZGF0YVsyXSAmIDQpID4+PiAyO1xcbiAgICByZXQuZGVwZW5kc09uQ29yZUNvZGVyID0gKGRhdGFbMl0gJiAyKSA+Pj4gMTtcXG4gICAgcmV0LmV4dGVuc2lvbkZsYWdJbmRleCA9IGRhdGFbMl0gJiAxO1xcblxcbiAgICByZXQuY29kZWMgPSBgbXA0YS40MC4ke3JldC5vYmplY3RUeXBlfWA7XFxuICAgIGxldCB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xcbiAgICBsZXQgZXh0ZW5zaW9uU2FtcGxpbmdJbmRleDtcXG5cXG4gICAgbGV0IGNvbmZpZztcXG4gICAgbGV0IHNhbXBsaW5nSW5kZXggPSByZXQuc2FtcGxlUmF0ZUluZGV4O1xcblxcbiAgICBpZiAodXNlckFnZW50LmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTEpIHtcXG4gICAgICAvLyBmaXJlZm94OiB1c2UgU0JSIChIRS1BQUMpIGlmIGZyZXEgbGVzcyB0aGFuIDI0a0h6XFxuICAgICAgaWYgKHJldC5zYW1wbGVSYXRlSW5kZXggPj0gNikge1xcbiAgICAgICAgcmV0Lm9iamVjdFR5cGUgPSA1O1xcbiAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xcbiAgICAgICAgZXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IHNhbXBsaW5nSW5kZXggLSAzO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAvLyB1c2UgTEMtQUFDXFxuICAgICAgICByZXQub2JqZWN0VHlwZSA9IDI7XFxuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XFxuICAgICAgICBleHRlbnNpb25TYW1wbGluZ0luZGV4ID0gc2FtcGxpbmdJbmRleDtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEpIHtcXG4gICAgICAvLyBhbmRyb2lkOiBhbHdheXMgdXNlIExDLUFBQ1xcbiAgICAgIHJldC5vYmplY3RUeXBlID0gMjtcXG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XFxuICAgICAgZXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IHNhbXBsaW5nSW5kZXg7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gZm9yIG90aGVyIGJyb3dzZXJzLCBlLmcuIGNocm9tZS4uLlxcbiAgICAgIC8vIEFsd2F5cyB1c2UgSEUtQUFDIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHN3aXRjaCBhYWMgY29kZWMgcHJvZmlsZVxcbiAgICAgIHJldC5vYmplY3RUeXBlID0gNTtcXG4gICAgICBleHRlbnNpb25TYW1wbGluZ0luZGV4ID0gcmV0LnNhbXBsZVJhdGVJbmRleDtcXG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XFxuXFxuICAgICAgaWYgKHJldC5zYW1wbGVSYXRlSW5kZXggPj0gNikge1xcbiAgICAgICAgZXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IHJldC5zYW1wbGVSYXRlSW5kZXggLSAzO1xcbiAgICAgIH0gZWxzZSBpZiAocmV0LmNoYW5uZWxDb3VudCA9PT0gMSkge1xcbiAgICAgICAgLy8gTW9ubyBjaGFubmVsXFxuICAgICAgICByZXQub2JqZWN0VHlwZSA9IDI7XFxuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XFxuICAgICAgICBleHRlbnNpb25TYW1wbGluZ0luZGV4ID0gcmV0LnNhbXBsZVJhdGVJbmRleDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgY29uZmlnWzBdID0gcmV0Lm9iamVjdFR5cGUgPDwgMztcXG4gICAgY29uZmlnWzBdIHw9IChyZXQuc2FtcGxlUmF0ZUluZGV4ICYgMHgwRikgPj4+IDE7XFxuICAgIGNvbmZpZ1sxXSA9IChyZXQuc2FtcGxlUmF0ZUluZGV4ICYgMHgwRikgPDwgNztcXG4gICAgY29uZmlnWzFdIHw9IChyZXQuY2hhbm5lbENvdW50ICYgMHgwRikgPDwgMztcXG4gICAgaWYgKHJldC5vYmplY3RUeXBlID09PSA1KSB7XFxuICAgICAgY29uZmlnWzFdIHw9IChleHRlbnNpb25TYW1wbGluZ0luZGV4ICYgMHgwRikgPj4+IDE7XFxuICAgICAgY29uZmlnWzJdID0gKGV4dGVuc2lvblNhbXBsaW5nSW5kZXggJiAweDAxKSA8PCA3O1xcbiAgICAgIC8vIGV4dGVuZGVkIGF1ZGlvIG9iamVjdCB0eXBlOiBmb3JjZSB0byAyIChMQy1BQUMpXFxuICAgICAgY29uZmlnWzJdIHw9IDIgPDwgMjtcXG4gICAgICBjb25maWdbM10gPSAwO1xcbiAgICB9XFxuICAgIHJldC5jb25maWcgPSBjb25maWc7XFxuICAgIHJldHVybiByZXQ7XFxuICB9XFxuXFxuICBfcGFyc2VBQUNEYXRhKGNodW5rKSB7XFxuICAgIGxldCB0cmFjayA9IHRoaXMudHJhY2tzLmF1ZGlvVHJhY2s7XFxuICAgIGlmICghdHJhY2spIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgbGV0IG1ldGEgPSB0cmFjay5tZXRhO1xcblxcbiAgICBpZiAoIW1ldGEpIHtcXG4gICAgICB0cmFjay5tZXRhID0gbmV3IF94Z3BsYXllclV0aWxzLkF1ZGlvVHJhY2tNZXRhKCk7XFxuICAgICAgbWV0YSA9IHRyYWNrLm1ldGE7XFxuICAgIH1cXG5cXG4gICAgbGV0IGluZm8gPSB0aGlzLmxvYWRlckJ1ZmZlci5zaGlmdCgxKVswXTtcXG5cXG4gICAgY2h1bmsuZGF0YSA9IHRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KGNodW5rLmRhdGFzaXplIC0gMSk7XFxuXFxuICAgIGxldCBmb3JtYXQgPSAoaW5mbyAmIDI0MCkgPj4+IDQ7XFxuXFxuICAgIHRyYWNrLmZvcm1hdCA9IGZvcm1hdDtcXG5cXG4gICAgaWYgKGZvcm1hdCAhPT0gMTApIHtcXG4gICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLkRFTVVYX0VSUk9SLCBuZXcgRXJyb3IoYGludmFsaWQgYXVkaW8gZm9ybWF0OiAke2Zvcm1hdH1gKSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGZvcm1hdCA9PT0gMTAgJiYgIXRoaXMuX2hhc0F1ZGlvU2VxdWVuY2UpIHtcXG4gICAgICBtZXRhLnNhbXBsZVJhdGUgPSB0aGlzLl9zd2l0Y2hBdWRpb1NhbXBsaW5nRnJlcXVlbmN5KGluZm8pO1xcbiAgICAgIG1ldGEuc2FtcGxlUmF0ZUluZGV4ID0gKGluZm8gJiAxMikgPj4+IDI7XFxuICAgICAgbWV0YS5mcmFtZUxlbnRoID0gKGluZm8gJiAyKSA+Pj4gMTtcXG4gICAgICBtZXRhLmNoYW5uZWxDb3VudCA9IGluZm8gJiAxO1xcbiAgICAgIG1ldGEucmVmU2FtcGxlRHVyYXRpb24gPSBNYXRoLmZsb29yKDEwMjQgLyBtZXRhLmF1ZGlvU2FtcGxlUmF0ZSAqIG1ldGEudGltZXNjYWxlKTtcXG4gICAgfVxcblxcbiAgICBsZXQgYXVkaW9TYW1wbGVSYXRlID0gbWV0YS5hdWRpb1NhbXBsZVJhdGU7XFxuICAgIGxldCBhdWRpb1NhbXBsZVJhdGVJbmRleCA9IG1ldGEuc2FtcGxlUmF0ZUluZGV4O1xcbiAgICBsZXQgcmVmU2FtcGxlRHVyYXRpb24gPSBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uO1xcblxcbiAgICBkZWxldGUgY2h1bmsudGFnVHlwZTtcXG4gICAgbGV0IHZhbGlkYXRlID0gdGhpcy5fZGF0YXNpemVWYWxpZGF0b3IoY2h1bmsuZGF0YXNpemUpO1xcblxcbiAgICBpZiAoY2h1bmsuZGF0YVswXSA9PT0gMCkge1xcbiAgICAgIC8vIEFBQyBTZXF1ZW5jZSBIZWFkZXJcXG4gICAgICBsZXQgYWFjSGVhZGVyID0gdGhpcy5fYWFjU2VxdWVuY2VIZWFkZXJQYXJzZXIoY2h1bmsuZGF0YSk7XFxuICAgICAgYXVkaW9TYW1wbGVSYXRlID0gYWFjSGVhZGVyLmF1ZGlvc2FtcGxlcmF0ZSB8fCBtZXRhLmF1ZGlvU2FtcGxlUmF0ZTtcXG4gICAgICBhdWRpb1NhbXBsZVJhdGVJbmRleCA9IGFhY0hlYWRlci5zYW1wbGVSYXRlSW5kZXggfHwgbWV0YS5zYW1wbGVSYXRlSW5kZXg7XFxuICAgICAgcmVmU2FtcGxlRHVyYXRpb24gPSBNYXRoLmZsb29yKDEwMjQgLyBhdWRpb1NhbXBsZVJhdGUgKiBtZXRhLnRpbWVzY2FsZSk7XFxuXFxuICAgICAgbWV0YS5jaGFubmVsQ291bnQgPSBhYWNIZWFkZXIuY2hhbm5lbENvdW50O1xcbiAgICAgIG1ldGEuc2FtcGxlUmF0ZSA9IGF1ZGlvU2FtcGxlUmF0ZTtcXG4gICAgICBtZXRhLnNhbXBsZVJhdGVJbmRleCA9IGF1ZGlvU2FtcGxlUmF0ZUluZGV4O1xcbiAgICAgIG1ldGEucmVmU2FtcGxlRHVyYXRpb24gPSByZWZTYW1wbGVEdXJhdGlvbjtcXG4gICAgICBtZXRhLmR1cmF0aW9uID0gdGhpcy5fY29udGV4dC5tZWRpYUluZm8uZHVyYXRpb24gKiBtZXRhLnRpbWVzY2FsZTtcXG4gICAgICBtZXRhLmNvbmZpZyA9IGFhY0hlYWRlci5jb25maWc7XFxuICAgICAgbWV0YS5vYmplY3RUeXBlID0gYWFjSGVhZGVyLm9iamVjdFR5cGU7XFxuXFxuICAgICAgY29uc3QgYXVkaW9NZWRpYSA9IHRoaXMuX2NvbnRleHQubWVkaWFJbmZvLmF1ZGlvO1xcblxcbiAgICAgIC8vIGZpbGwgYXVkaW8gbWVkaWEgaW5mb1xcbiAgICAgIGF1ZGlvTWVkaWEuY29kZWMgPSBhYWNIZWFkZXIuY29kZWM7XFxuICAgICAgYXVkaW9NZWRpYS5jaGFubmVsQ291bnQgPSBhYWNIZWFkZXIuY2hhbm5lbENvdW50O1xcbiAgICAgIGF1ZGlvTWVkaWEuc2FtcGxlUmF0ZSA9IGF1ZGlvU2FtcGxlUmF0ZTtcXG4gICAgICBhdWRpb01lZGlhLnNhbXBsZVJhdGVJbmRleCA9IGFhY0hlYWRlci5hdWRpb1NhbXBsZVJhdGVJbmRleDtcXG5cXG4gICAgICBpZiAodGhpcy5faGFzU2NyaXB0ICYmICF0aGlzLl9oYXNBdWRpb1NlcXVlbmNlKSB7XFxuICAgICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLk1FVEFEQVRBX1BBUlNFRCwgJ2F1ZGlvJyk7XFxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9oYXNTY3JpcHQgJiYgdGhpcy5faGFzQXVkaW9TZXF1ZW5jZSkge1xcbiAgICAgICAgdGhpcy5lbWl0KERFTVVYX0VWRU5UUy5NRVRBREFUQV9QQVJTRUQsICdhdWRpbycpO1xcbiAgICAgICAgdGhpcy5lbWl0KERFTVVYX0VWRU5UUy5BVURJT19NRVRBREFUQV9DSEFOR0UpO1xcbiAgICAgICAgLy8gdGhpcy5lbWl0KERFTVVYX0VWRU5UUy5NRVRBREFUQV9QQVJTRUQsICdhdWRpbycpXFxuICAgICAgfVxcbiAgICAgIHRoaXMuX2hhc0F1ZGlvU2VxdWVuY2UgPSB0cnVlO1xcblxcbiAgICAgIHRoaXMuX21ldGFDaGFuZ2UgPSB0cnVlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGlmICh0aGlzLl9tZXRhQ2hhbmdlKSB7XFxuICAgICAgICBjaHVuay5vcHRpb25zID0ge1xcbiAgICAgICAgICBtZXRhOiB0cmFjay5tZXRhXFxuICAgICAgICB9O1xcbiAgICAgICAgdGhpcy5fbWV0YUNoYW5nZSA9IGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBjaHVuay5kYXRhID0gY2h1bmsuZGF0YS5zbGljZSgxLCBjaHVuay5kYXRhLmxlbmd0aCk7XFxuICAgICAgdHJhY2suc2FtcGxlcy5wdXNoKGNodW5rKTtcXG4gICAgfVxcbiAgICBpZiAoIXZhbGlkYXRlKSB7XFxuICAgICAgdGhpcy5lbWl0KERFTVVYX0VWRU5UUy5ERU1VWF9FUlJPUiwgdGhpcy5UQUcsIG5ldyBFcnJvcignVEFHIGxlbmd0aCBlcnJvciBhdCAnICsgY2h1bmsuZGF0YXNpemUpLCBmYWxzZSk7XFxuICAgICAgLy8gdGhpcy5sb2dnZXIud2Fybih0aGlzLlRBRywgZXJyb3IubWVzc2FnZSlcXG4gICAgfVxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBwYXJzZSBoZXZjL2F2YyB2aWRlbyBkYXRhXFxuICAgKiBAcGFyYW0gY2h1bmtcXG4gICAqIEBwcml2YXRlXFxuICAgKi9cXG4gIF9wYXJzZUhldmNEYXRhKGNodW5rKSB7XFxuICAgIC8vIGhlYWRlclxcbiAgICBsZXQgaW5mbyA9IHRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDEpWzBdO1xcbiAgICBjaHVuay5mcmFtZVR5cGUgPSAoaW5mbyAmIDB4ZjApID4+PiA0O1xcbiAgICBjaHVuay5pc0tleWZyYW1lID0gY2h1bmsuZnJhbWVUeXBlID09PSAxO1xcbiAgICAvLyBsZXQgdGVtcENvZGVjSUQgPSB0aGlzLnRyYWNrcy52aWRlb1RyYWNrLmNvZGVjSURcXG4gICAgbGV0IGNvZGVjSUQgPSBpbmZvICYgMHgwZjtcXG4gICAgdGhpcy50cmFja3MudmlkZW9UcmFjay5jb2RlY0lEID0gY29kZWNJRDtcXG5cXG4gICAgLy8gaGV2Y+WSjGF2Y+eahGhlYWRlcuino+aekOaWueW8j+S4gOagt1xcbiAgICBjaHVuay5hdmNQYWNrZXRUeXBlID0gdGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoMSlbMF07XFxuICAgIGNodW5rLmN0cyA9IHRoaXMubG9hZGVyQnVmZmVyLnRvSW50KDAsIDMpO1xcbiAgICB0aGlzLmxvYWRlckJ1ZmZlci5zaGlmdCgzKTtcXG5cXG4gICAgLy8gMTIgZm9yIGhldmMsIDcgZm9yIGF2Y1xcbiAgICBpZiAoY29kZWNJRCA9PT0gMTIpIHtcXG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoY2h1bmsuZGF0YXNpemUgLSA1KTtcXG4gICAgICBjaHVuay5kYXRhID0gZGF0YTtcXG5cXG4gICAgICBpZiAoTnVtYmVyLnBhcnNlSW50KGNodW5rLmF2Y1BhY2tldFR5cGUpICE9PSAwKSB7XFxuICAgICAgICBpZiAoIXRoaXMuX2RhdGFzaXplVmFsaWRhdG9yKGNodW5rLmRhdGFzaXplKSkge1xcbiAgICAgICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLkRFTVVYX0VSUk9SLCB0aGlzLlRBRywgbmV3IEVycm9yKGBpbnZhbGlkIHZpZGVvIHRhZyBkYXRhc2l6ZTogJHtjaHVuay5kYXRhc2l6ZX1gKSwgZmFsc2UpO1xcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IG5hbHUgPSB7fTtcXG4gICAgICAgIGxldCByID0gMDtcXG4gICAgICAgIG5hbHUuY3RzID0gY2h1bmsuY3RzO1xcbiAgICAgICAgbmFsdS5kdHMgPSBjaHVuay5kdHM7XFxuICAgICAgICB3aGlsZSAoY2h1bmsuZGF0YS5sZW5ndGggPiByKSB7XFxuICAgICAgICAgIGxldCBzaXplcyA9IGNodW5rLmRhdGEuc2xpY2UoTnVtYmVyLnBhcnNlSW50KHIpLCA0ICsgcik7XFxuICAgICAgICAgIG5hbHUuc2l6ZSA9IHNpemVzWzNdO1xcbiAgICAgICAgICBuYWx1LnNpemUgKz0gc2l6ZXNbMl0gKiAyNTY7XFxuICAgICAgICAgIG5hbHUuc2l6ZSArPSBzaXplc1sxXSAqIDI1NiAqIDI1NjtcXG4gICAgICAgICAgbmFsdS5zaXplICs9IHNpemVzWzBdICogMjU2ICogMjU2ICogMjU2O1xcbiAgICAgICAgICByICs9IDQ7XFxuICAgICAgICAgIG5hbHUuZGF0YSA9IGNodW5rLmRhdGEuc2xpY2UoTnVtYmVyLnBhcnNlSW50KHIpLCBuYWx1LnNpemUgKyByKTtcXG4gICAgICAgICAgciArPSBuYWx1LnNpemU7XFxuICAgICAgICAgIHRoaXMudHJhY2tzLnZpZGVvVHJhY2suc2FtcGxlcy5wdXNoKG5hbHUpO1xcbiAgICAgICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLk1FVEFEQVRBX1BBUlNFRCwgJ3ZpZGVvJyk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmIChOdW1iZXIucGFyc2VJbnQoY2h1bmsuYXZjUGFja2V0VHlwZSkgPT09IDApIHtcXG4gICAgICAgIGlmICghdGhpcy5fZGF0YXNpemVWYWxpZGF0b3IoY2h1bmsuZGF0YXNpemUpKSB7XFxuICAgICAgICAgIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuREVNVVhfRVJST1IsIHRoaXMuVEFHLCBuZXcgRXJyb3IoYGludmFsaWQgdmlkZW8gdGFnIGRhdGFzaXplOiAke2NodW5rLmRhdGFzaXplfWApLCBmYWxzZSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLk1FVEFEQVRBX1BBUlNFRCwgJ3ZpZGVvJyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKGNvZGVjSUQgPT09IDcpIHtcXG4gICAgICBsZXQgZGF0YSA9IHRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KGNodW5rLmRhdGFzaXplIC0gNSk7XFxuICAgICAgaWYgKGRhdGFbNF0gPT09IDAgJiYgZGF0YVs1XSA9PT0gMCAmJiBkYXRhWzZdID09PSAwICYmIGRhdGFbN10gPT09IDEpIHtcXG4gICAgICAgIGxldCBhdmNjbGVuZ3RoID0gMDtcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XFxuICAgICAgICAgIGF2Y2NsZW5ndGggPSBhdmNjbGVuZ3RoICogMjU2ICsgZGF0YVtpXTtcXG4gICAgICAgIH1cXG4gICAgICAgIGF2Y2NsZW5ndGggLT0gNDtcXG4gICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKDQsIGRhdGEubGVuZ3RoKTtcXG4gICAgICAgIGRhdGFbM10gPSBhdmNjbGVuZ3RoICUgMjU2O1xcbiAgICAgICAgYXZjY2xlbmd0aCA9IChhdmNjbGVuZ3RoIC0gZGF0YVszXSkgLyAyNTY7XFxuICAgICAgICBkYXRhWzJdID0gYXZjY2xlbmd0aCAlIDI1NjtcXG4gICAgICAgIGF2Y2NsZW5ndGggPSAoYXZjY2xlbmd0aCAtIGRhdGFbMl0pIC8gMjU2O1xcbiAgICAgICAgZGF0YVsxXSA9IGF2Y2NsZW5ndGggJSAyNTY7XFxuICAgICAgICBkYXRhWzBdID0gKGF2Y2NsZW5ndGggLSBkYXRhWzFdKSAvIDI1NjtcXG4gICAgICB9XFxuXFxuICAgICAgY2h1bmsuZGF0YSA9IGRhdGE7XFxuICAgICAgLy8gSWYgaXQgaXMgQVZDIHNlcXVlY2UgSGVhZGVyLlxcbiAgICAgIGlmIChjaHVuay5hdmNQYWNrZXRUeXBlID09PSAwKSB7XFxuICAgICAgICB0aGlzLl9hdmNTZXF1ZW5jZUhlYWRlclBhcnNlcihjaHVuay5kYXRhKTtcXG4gICAgICAgIGxldCB2YWxpZGF0ZSA9IHRoaXMuX2RhdGFzaXplVmFsaWRhdG9yKGNodW5rLmRhdGFzaXplKTtcXG4gICAgICAgIGlmICh2YWxpZGF0ZSkge1xcbiAgICAgICAgICBpZiAodGhpcy5faGFzU2NyaXB0ICYmICF0aGlzLl9oYXNWaWRlb1NlcXVlbmNlKSB7XFxuICAgICAgICAgICAgdGhpcy5lbWl0KERFTVVYX0VWRU5UUy5NRVRBREFUQV9QQVJTRUQsICd2aWRlbycpO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2hhc1NjcmlwdCAmJiB0aGlzLl9oYXNWaWRlb1NlcXVlbmNlKSB7XFxuICAgICAgICAgICAgdGhpcy5lbWl0KERFTVVYX0VWRU5UUy5NRVRBREFUQV9QQVJTRUQsICdhdWRpbycpO1xcbiAgICAgICAgICAgIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuVklERU9fTUVUQURBVEFfQ0hBTkdFKTtcXG4gICAgICAgICAgICAvLyB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLk1FVEFEQVRBX1BBUlNFRCwgJ3ZpZGVvJylcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB0aGlzLl9oYXNWaWRlb1NlcXVlbmNlID0gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMuX21ldGFDaGFuZ2UgPSB0cnVlO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoIXRoaXMuX2RhdGFzaXplVmFsaWRhdG9yKGNodW5rLmRhdGFzaXplKSkge1xcbiAgICAgICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLkRFTVVYX0VSUk9SLCB0aGlzLlRBRywgbmV3IEVycm9yKGBpbnZhbGlkIHZpZGVvIHRhZyBkYXRhc2l6ZTogJHtjaHVuay5kYXRhc2l6ZX1gKSwgZmFsc2UpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodGhpcy5fbWV0YUNoYW5nZSkge1xcbiAgICAgICAgICBjaHVuay5vcHRpb25zID0ge1xcbiAgICAgICAgICAgIG1ldGE6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMudHJhY2tzLnZpZGVvVHJhY2subWV0YSlcXG4gICAgICAgICAgfTtcXG4gICAgICAgICAgdGhpcy5fbWV0YUNoYW5nZSA9IGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy50cmFja3MudmlkZW9UcmFjay5zYW1wbGVzLnB1c2goY2h1bmspO1xcbiAgICAgICAgLy8gdGhpcy5lbWl0KERFTVVYX0VWRU5UUy5ERU1VWF9DT01QTEVURSlcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhpcy5lbWl0KERFTVVYX0VWRU5UUy5ERU1VWF9FUlJPUiwgdGhpcy5UQUcsIG5ldyBFcnJvcihgdmlkZW8gY29kZWlkIGlzICR7Y29kZWNJRH1gKSwgZmFsc2UpO1xcbiAgICAgIGNodW5rLmRhdGEgPSB0aGlzLmxvYWRlckJ1ZmZlci5zaGlmdChjaHVuay5kYXRhc2l6ZSAtIDEpO1xcbiAgICAgIGlmICghdGhpcy5fZGF0YXNpemVWYWxpZGF0b3IoY2h1bmsuZGF0YXNpemUpKSB7XFxuICAgICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLkRFTVVYX0VSUk9SLCB0aGlzLlRBRywgbmV3IEVycm9yKGBpbnZhbGlkIHZpZGVvIHRhZyBkYXRhc2l6ZTogJHtjaHVuay5kYXRhc2l6ZX1gKSwgZmFsc2UpO1xcbiAgICAgIH1cXG4gICAgICB0aGlzLnRyYWNrcy52aWRlb1RyYWNrLnNhbXBsZXMucHVzaChjaHVuayk7XFxuICAgICAgdGhpcy5lbWl0KERFTVVYX0VWRU5UUy5ERU1VWF9DT01QTEVURSk7XFxuICAgIH1cXG4gICAgZGVsZXRlIGNodW5rLnRhZ1R5cGU7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIHBhcnNlIGF2YyBtZXRhZGF0YVxcbiAgICogQHBhcmFtIGRhdGFcXG4gICAqIEBwcml2YXRlXFxuICAgKi9cXG4gIF9hdmNTZXF1ZW5jZUhlYWRlclBhcnNlcihkYXRhKSB7XFxuICAgIGxldCB0cmFjayA9IHRoaXMudHJhY2tzLnZpZGVvVHJhY2s7XFxuXFxuICAgIGlmICghdHJhY2spIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgbGV0IG9mZnNldCA9IDA7XFxuXFxuICAgIGlmICghdHJhY2subWV0YSkge1xcbiAgICAgIHRyYWNrLm1ldGEgPSBuZXcgX3hncGxheWVyVXRpbHMuVmlkZW9UcmFja01ldGEoKTtcXG4gICAgfVxcbiAgICBsZXQgbWV0YSA9IHRyYWNrLm1ldGE7XFxuXFxuICAgIG1ldGEuY29uZmlndXJhdGlvblZlcnNpb24gPSBkYXRhWzBdO1xcbiAgICBtZXRhLmF2Y1Byb2ZpbGVJbmRpY2F0aW9uID0gZGF0YVsxXTtcXG4gICAgbWV0YS5wcm9maWxlQ29tcGF0aWJpbGl0eSA9IGRhdGFbMl07XFxuICAgIG1ldGEuYXZjTGV2ZWxJbmRpY2F0aW9uID0gZGF0YVszXSAvIDEwO1xcbiAgICBtZXRhLm5hbFVuaXRMZW5ndGggPSAoZGF0YVs0XSAmIDB4MDMpICsgMTtcXG5cXG4gICAgbGV0IG51bU9mU3BzID0gZGF0YVs1XSAmIDB4MWY7XFxuICAgIG9mZnNldCA9IDY7XFxuICAgIGxldCBjb25maWcgPSB7fTtcXG5cXG4gICAgLy8gcGFyc2UgU1BTXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtT2ZTcHM7IGkrKykge1xcbiAgICAgIGxldCBzaXplID0gZGF0YVtvZmZzZXRdICogMjU1ICsgZGF0YVtvZmZzZXQgKyAxXTtcXG4gICAgICBvZmZzZXQgKz0gMjtcXG5cXG4gICAgICBsZXQgc3BzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XFxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzaXplOyBqKyspIHtcXG4gICAgICAgIHNwc1tqXSA9IGRhdGFbb2Zmc2V0ICsgal07XFxuICAgICAgfVxcblxcbiAgICAgIC8vIGNvZGVjIHN0cmluZ1xcbiAgICAgIGxldCBjb2RlY1N0cmluZyA9ICdhdmMxLic7XFxuICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCA0OyBqKyspIHtcXG4gICAgICAgIGxldCBoID0gc3BzW2pdLnRvU3RyaW5nKDE2KTtcXG4gICAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcXG4gICAgICAgICAgaCA9ICcwJyArIGg7XFxuICAgICAgICB9XFxuICAgICAgICBjb2RlY1N0cmluZyArPSBoO1xcbiAgICAgIH1cXG5cXG4gICAgICBtZXRhLmNvZGVjID0gY29kZWNTdHJpbmc7XFxuXFxuICAgICAgb2Zmc2V0ICs9IHNpemU7XFxuICAgICAgdGhpcy50cmFja3MudmlkZW9UcmFjay5tZXRhLnNwcyA9IHNwcztcXG4gICAgICBjb25maWcgPSBfeGdwbGF5ZXJDb2RlYy5TcHNQYXJzZXIucGFyc2VTUFMoc3BzKTtcXG4gICAgfVxcblxcbiAgICBsZXQgbnVtT2ZQcHMgPSBkYXRhW29mZnNldF07XFxuXFxuICAgIG9mZnNldCsrO1xcblxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU9mUHBzOyBpKyspIHtcXG4gICAgICBsZXQgc2l6ZSA9IGRhdGFbb2Zmc2V0XSAqIDI1NSArIGRhdGFbb2Zmc2V0ICsgMV07XFxuICAgICAgb2Zmc2V0ICs9IDI7XFxuICAgICAgbGV0IHBwcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2l6ZTsgaisrKSB7XFxuICAgICAgICBwcHNbal0gPSBkYXRhW29mZnNldCArIGpdO1xcbiAgICAgIH1cXG4gICAgICBvZmZzZXQgKz0gc2l6ZTtcXG4gICAgICB0aGlzLnRyYWNrcy52aWRlb1RyYWNrLm1ldGEucHBzID0gcHBzO1xcbiAgICB9XFxuXFxuICAgIE9iamVjdC5hc3NpZ24obWV0YSwgX3hncGxheWVyQ29kZWMuU3BzUGFyc2VyLnRvVmlkZW9NZXRhKGNvbmZpZykpO1xcblxcbiAgICAvLyBmaWxsIHZpZGVvIG1lZGlhIGluZm9cXG4gICAgY29uc3QgdmlkZW9NZWRpYSA9IHRoaXMuX2NvbnRleHQubWVkaWFJbmZvLnZpZGVvO1xcblxcbiAgICB2aWRlb01lZGlhLmNvZGVjID0gbWV0YS5jb2RlYztcXG4gICAgdmlkZW9NZWRpYS5wcm9maWxlID0gbWV0YS5wcm9maWxlO1xcbiAgICB2aWRlb01lZGlhLmxldmVsID0gbWV0YS5sZXZlbDtcXG4gICAgdmlkZW9NZWRpYS5jaHJvbWFGb3JtYXQgPSBtZXRhLmNocm9tYUZvcm1hdDtcXG4gICAgdmlkZW9NZWRpYS5mcmFtZVJhdGUgPSBtZXRhLmZyYW1lUmF0ZTtcXG4gICAgdmlkZW9NZWRpYS5wYXJSYXRpbyA9IG1ldGEucGFyUmF0aW87XFxuICAgIHZpZGVvTWVkaWEud2lkdGggPSB2aWRlb01lZGlhLndpZHRoID09PSBtZXRhLnByZXNlbnRXaWR0aCA/IHZpZGVvTWVkaWEud2lkdGggOiBtZXRhLnByZXNlbnRXaWR0aDtcXG4gICAgdmlkZW9NZWRpYS5oZWlnaHQgPSB2aWRlb01lZGlhLmhlaWdodCA9PT0gbWV0YS5wcmVzZW50SGVpZ2h0ID8gdmlkZW9NZWRpYS53aWR0aCA6IG1ldGEucHJlc2VudEhlaWdodDtcXG5cXG4gICAgbWV0YS5kdXJhdGlvbiA9IHRoaXMuX2NvbnRleHQubWVkaWFJbmZvLmR1cmF0aW9uICogbWV0YS50aW1lc2NhbGU7XFxuICAgIG1ldGEuYXZjYyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoKTtcXG4gICAgbWV0YS5hdmNjLnNldChkYXRhKTtcXG4gICAgdHJhY2subWV0YSA9IG1ldGE7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIGNob29zZSBhdWRpbyBzYW1wbGUgcmF0ZVxcbiAgICogQHBhcmFtIHNhbXBsaW5nRnJlcXVlbmN5SW5kZXhcXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XFxuICAgKiBAcHJpdmF0ZVxcbiAgICovXFxuICBfc3dpdGNoQXVkaW9TYW1wbGVSYXRlKHNhbXBsaW5nRnJlcXVlbmN5SW5kZXgpIHtcXG4gICAgbGV0IHNhbXBsaW5nRnJlcXVlbmN5TGlzdCA9IFs5NjAwMCwgODgyMDAsIDY0MDAwLCA0ODAwMCwgNDQxMDAsIDMyMDAwLCAyNDAwMCwgMjIwNTAsIDE2MDAwLCAxMjAwMCwgMTEwMjUsIDgwMDAsIDczNTBdO1xcbiAgICByZXR1cm4gc2FtcGxpbmdGcmVxdWVuY3lMaXN0W3NhbXBsaW5nRnJlcXVlbmN5SW5kZXhdO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBjaG9vc2UgYXVkaW8gc2FtcGxpbmcgZnJlcXVlbmNlXFxuICAgKiBAcGFyYW0gaW5mb1xcbiAgICogQHJldHVybnMge251bWJlcn1cXG4gICAqIEBwcml2YXRlXFxuICAgKi9cXG4gIF9zd2l0Y2hBdWRpb1NhbXBsaW5nRnJlcXVlbmN5KGluZm8pIHtcXG4gICAgbGV0IHNhbXBsaW5nRnJlcXVlbmN5SW5kZXggPSAoaW5mbyAmIDEyKSA+Pj4gMjtcXG4gICAgbGV0IHNhbXBsaW5nRnJlcXVlbmN5TGlzdCA9IFs1NTAwLCAxMTAyNSwgMjIwNTAsIDQ0MTAwLCA0ODAwMF07XFxuICAgIHJldHVybiBzYW1wbGluZ0ZyZXF1ZW5jeUxpc3Rbc2FtcGxpbmdGcmVxdWVuY3lJbmRleF07XFxuICB9XFxuXFxuICAvKipcXG4gICAqIGNob29zZSBhdWRpbyBjaGFubmVsIGNvdW50XFxuICAgKiBAcGFyYW0gaW5mb1xcbiAgICogQHJldHVybnMge251bWJlcn1cXG4gICAqIEBwcml2YXRlXFxuICAgKi9cXG4gIF9zd2l0Y2hBdWRpb0NoYW5uZWwoaW5mbykge1xcbiAgICBsZXQgc2FtcGxlVHJhY2tOdW1JbmRleCA9IGluZm8gJiAxO1xcbiAgICBsZXQgc2FtcGxlVHJhY2tOdW1MaXN0ID0gWzEsIDJdO1xcbiAgICByZXR1cm4gc2FtcGxlVHJhY2tOdW1MaXN0W3NhbXBsZVRyYWNrTnVtSW5kZXhdO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBjaGVjayBkYXRhc2l6ZSBpcyB2YWxpZCB1c2UgNCBCeXRlIGFmdGVyIGN1cnJlbnQgdGFnXFxuICAgKiBAcGFyYW0gZGF0YXNpemVcXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxcbiAgICogQHByaXZhdGVcXG4gICAqL1xcbiAgX2RhdGFzaXplVmFsaWRhdG9yKGRhdGFzaXplKSB7XFxuICAgIGxldCBkYXRhc2l6ZUNvbmZpcm0gPSB0aGlzLmxvYWRlckJ1ZmZlci50b0ludCgwLCA0KTtcXG4gICAgdGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoNCk7XFxuICAgIHJldHVybiBkYXRhc2l6ZUNvbmZpcm0gPT09IGRhdGFzaXplICsgMTE7XFxuICB9XFxuXFxuICBnZXQgbG9hZGVyQnVmZmVyKCkge1xcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKCdMT0FERVJfQlVGRkVSJyk7XFxuICAgIGlmIChidWZmZXIpIHtcXG4gICAgICByZXR1cm4gYnVmZmVyO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuREVNVVhfRVJST1IsIG5ldyBFcnJvcign5om+5LiN5YiwIGxvYWRlckJ1ZmZlciDlrp7kvosnKSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGdldCB0cmFja3MoKSB7XFxuICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKCdUUkFDS1MnKTtcXG4gIH1cXG5cXG4gIGdldCBsb2dnZXIoKSB7XFxuICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKCdMT0dHRVInKTtcXG4gIH1cXG59XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gRmx2RGVtdXhlcjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItZGVtdXgvc3JjL2Zsdi9pbmRleC5qcz9cIil9LFwiLi4veGdwbGF5ZXItZGVtdXgvc3JjL2hscy9kZW11eGVyL20zdThwYXJzZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItZGVtdXgvc3JjL2hscy9kZW11eGVyL20zdThwYXJzZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG4vKipcXG4gKiBSZWZlcmVuY2U6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM4MjE2I3NlY3Rpb24tNC4zXFxuICovXFxuY2xhc3MgTTNVOFBhcnNlciB7XFxuICBzdGF0aWMgcGFyc2UodGV4dCwgYmFzZXVybCA9ICcnKSB7XFxuICAgIGxldCByZXQgPSB7XFxuICAgICAgZHVyYXRpb246IDBcXG4gICAgfTtcXG4gICAgaWYgKCF0ZXh0IHx8ICF0ZXh0LnNwbGl0KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGxldCByZWZzID0gdGV4dC5zcGxpdCgvXFxcXHJ8XFxcXG4vKTtcXG4gICAgcmVmcyA9IHJlZnMuZmlsdGVyKHJlZiA9PiB7XFxuICAgICAgcmV0dXJuIHJlZjtcXG4gICAgfSk7XFxuICAgIGxldCByZWYgPSByZWZzLnNoaWZ0KCk7XFxuICAgIGlmICghcmVmLm1hdGNoKCcjRVhUTTNVJykpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbTN1OCBmaWxlOiBub3QgXFxcIiNFWFRNM1VcXFwiYCk7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gICAgcmVmID0gcmVmcy5zaGlmdCgpO1xcbiAgICB3aGlsZSAocmVmKSB7XFxuICAgICAgbGV0IHJlZm0gPSByZWYubWF0Y2goLyMoLltBLVp8LV0qKTooLiopLyk7XFxuICAgICAgbGV0IHJlZmQgPSByZWYubWF0Y2goLyMoLltBLVp8LV0qKS8pO1xcbiAgICAgIGlmIChyZWZkICYmIHJlZm0gJiYgcmVmbS5sZW5ndGggPiAyKSB7XFxuICAgICAgICBzd2l0Y2ggKHJlZm1bMV0pIHtcXG4gICAgICAgICAgY2FzZSAnRVhULVgtVkVSU0lPTic6XFxuICAgICAgICAgICAgcmV0LnZlcnNpb24gPSBwYXJzZUludChyZWZtWzJdKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSAnRVhULVgtTUVESUEtU0VRVUVOQ0UnOlxcbiAgICAgICAgICAgIHJldC5zZXF1ZW5jZSA9IHBhcnNlSW50KHJlZm1bMl0pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlICdFWFQtWC1UQVJHRVREVVJBVElPTic6XFxuICAgICAgICAgICAgcmV0LnRhcmdldGR1cmF0aW9uID0gcGFyc2VGbG9hdChyZWZtWzJdKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSAnRVhUSU5GJzpcXG4gICAgICAgICAgICBNM1U4UGFyc2VyLnBhcnNlRnJhZyhyZWZtLCByZWZzLCByZXQsIGJhc2V1cmwpO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlICdFWFQtWC1LRVknOlxcbiAgICAgICAgICAgIE0zVThQYXJzZXIucGFyc2VEZWNyeXB0KHJlZm1bMl0sIHJldCk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfWlmIChyZWZkICYmIHJlZmQubGVuZ3RoID4gMSkge1xcbiAgICAgICAgc3dpdGNoIChyZWZkWzFdKSB7XFxuICAgICAgICAgIGNhc2UgJ0VYVC1YLURJU0NPTlRJTlVJVFknOlxcbiAgICAgICAgICAgIHJlZiA9IHJlZnMuc2hpZnQoKTtcXG4gICAgICAgICAgICBsZXQgcmVmbSA9IHJlZi5tYXRjaCgvIyguW0EtWnwtXSopOiguKikvKTtcXG4gICAgICAgICAgICBpZiAocmVmbS5sZW5ndGggPiAyICYmIHJlZm1bMV0gPT09ICdFWFRJTkYnKSB7XFxuICAgICAgICAgICAgICBNM1U4UGFyc2VyLnBhcnNlRnJhZyhyZWZtLCByZWZzLCByZXQsIGJhc2V1cmwsIHRydWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmVmID0gcmVmcy5zaGlmdCgpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXQ7XFxuICB9XFxuXFxuICBzdGF0aWMgcGFyc2VGcmFnKHJlZm0sIHJlZnMsIHJldCwgYmFzZXVybCwgZGlzY29udGludWUpIHtcXG4gICAgaWYgKCFyZXQuZnJhZ3MpIHtcXG4gICAgICByZXQuZnJhZ3MgPSBbXTtcXG4gICAgfVxcblxcbiAgICBsZXQgZnJlZyA9IHtcXG4gICAgICBzdGFydDogcmV0LmR1cmF0aW9uLFxcbiAgICAgIGR1cmF0aW9uOiBwYXJzZUZsb2F0KHJlZm1bMl0pICogMTAwMFxcbiAgICB9O1xcblxcbiAgICByZXQuZHVyYXRpb24gKz0gZnJlZy5kdXJhdGlvbjtcXG4gICAgbGV0IG5leHRsaW5lID0gcmVmcy5zaGlmdCgpO1xcbiAgICBpZiAobmV4dGxpbmUubWF0Y2goLyMoLiopOiguKikvKSkge1xcbiAgICAgIG5leHRsaW5lID0gcmVmcy5zaGlmdCgpO1xcbiAgICB9XFxuICAgIGlmIChuZXh0bGluZS5sZW5ndGggPiAwICYmIG5leHRsaW5lLmNoYXJBdCgwKSA9PT0gJy8nICYmIGJhc2V1cmwubWF0Y2goLy4qXFxcXC9cXFxcLy4qXFxcXC5cXFxcdysvZykpIHtcXG4gICAgICBiYXNldXJsID0gYmFzZXVybC5tYXRjaCgvLipcXFxcL1xcXFwvLipcXFxcLlxcXFx3Ky9nKVswXTtcXG4gICAgfVxcbiAgICBpZiAobmV4dGxpbmUubWF0Y2goLy4qOlxcXFwvXFxcXC8uKi8pKSB7XFxuICAgICAgZnJlZy51cmwgPSBuZXh0bGluZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBmcmVnLnVybCA9IGJhc2V1cmwgKyBuZXh0bGluZTtcXG4gICAgfVxcbiAgICBmcmVnLmRpc2NvbnRpbnVlID0gZGlzY29udGludWU7XFxuICAgIHJldC5mcmFncy5wdXNoKGZyZWcpO1xcbiAgfVxcblxcbiAgc3RhdGljIHBhcnNlVVJMKHVybCkge1xcbiAgICBsZXQgYmFzZXVybCA9ICcnO1xcbiAgICBsZXQgdXJscyA9IHVybC5tYXRjaCgvKC4qXFxcXC8pLipcXFxcLm0zdTgvKTtcXG4gICAgaWYgKHVybHMgJiYgdXJscy5sZW5ndGggPiAwKSB7XFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBpZiAodXJsc1tpXS5tYXRjaCgvLipcXFxcLyQvZykgJiYgdXJsc1tpXS5sZW5ndGggPiBiYXNldXJsLmxlbmd0aCkge1xcbiAgICAgICAgICBiYXNldXJsID0gdXJsc1tpXTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGJhc2V1cmw7XFxuICB9XFxuXFxuICBzdGF0aWMgcGFyc2VEZWNyeXB0KHJlZm0sIHJldCkge1xcbiAgICByZXQuZW5jcnlwdCA9IHt9O1xcbiAgICBsZXQgcmVmcyA9IHJlZm0uc3BsaXQoJywnKTtcXG4gICAgZm9yIChsZXQgaSBpbiByZWZzKSB7XFxuICAgICAgbGV0IGNtZCA9IHJlZnNbaV07XFxuICAgICAgaWYgKGNtZC5tYXRjaCgvTUVUSE9EPSguKikvKSkge1xcbiAgICAgICAgcmV0LmVuY3J5cHQubWV0aG9kID0gY21kLm1hdGNoKC9NRVRIT0Q9KC4qKS8pWzFdO1xcbiAgICAgIH1cXG4gICAgICBpZiAoY21kLm1hdGNoKC9VUkk9XFxcIiguKilcXFwiLykpIHtcXG4gICAgICAgIHJldC5lbmNyeXB0LnVyaSA9IGNtZC5tYXRjaCgvVVJJPVxcXCIoLiopXFxcIi8pWzFdO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoY21kLm1hdGNoKC9JVj0weCguKikvKSkge1xcbiAgICAgICAgbGV0IGl2ID0gY21kLm1hdGNoKC9JVj0weCguKikvKVsxXTtcXG4gICAgICAgIGxldCBsZW5ndGggPSBNYXRoLmNlaWwoaXYubGVuZ3RoIC8gMik7XFxuICAgICAgICByZXQuZW5jcnlwdC5pdmIgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xcbiAgICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XFxuICAgICAgICAgIGxldCBpbSA9IHBhcnNlSW50KGl2LnN1YnN0cihpICogMiwgMiksIDE2KTtcXG4gICAgICAgICAgcmV0LmVuY3J5cHQuaXZiW2ldID0gaW07XFxuICAgICAgICB9XFxuICAgICAgICByZXQuZW5jcnlwdC5pdiA9IGl2O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG59XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gTTNVOFBhcnNlcjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItZGVtdXgvc3JjL2hscy9kZW11eGVyL20zdThwYXJzZXIuanM/XCIpfSxcIi4uL3hncGxheWVyLWRlbXV4L3NyYy9obHMvZGVtdXhlci90cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItZGVtdXgvc3JjL2hscy9kZW11eGVyL3RzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBfeGdwbGF5ZXJDb2RlYyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHhncGxheWVyLWNvZGVjICovIFxcXCIuLi94Z3BsYXllci1jb2RlYy9pbmRleC5qc1xcXCIpO1xcblxcbnZhciBfeGdwbGF5ZXJCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB4Z3BsYXllci1idWZmZXIgKi8gXFxcIi4uL3hncGxheWVyLWJ1ZmZlci9pbmRleC5qc1xcXCIpO1xcblxcbnZhciBfeGdwbGF5ZXJVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHhncGxheWVyLXV0aWxzICovIFxcXCIuLi94Z3BsYXllci11dGlscy9pbmRleC5qc1xcXCIpO1xcblxcbmNvbnN0IERFTVVYX0VWRU5UUyA9IF94Z3BsYXllclV0aWxzLkVWRU5UUy5ERU1VWF9FVkVOVFM7XFxuY29uc3QgU3RyZWFtVHlwZSA9IHtcXG4gIDB4MDE6IFsndmlkZW8nLCAnTVBFRy0xJ10sXFxuICAweDAyOiBbJ3ZpZGVvJywgJ01QRUctMiddLFxcbiAgMHgxYjogWyd2aWRlbycsICdBVkMuSDI2NCddLFxcbiAgMHhlYTogWyd2aWRlbycsICdWQy0xJ10sXFxuICAweDAzOiBbJ2F1ZGlvJywgJ01QRUctMSddLFxcbiAgMHgwNDogWydhdWRpbycsICdNUEVHLTInXSxcXG4gIDB4MGY6IFsnYXVkaW8nLCAnTVBFRy0yLkFBQyddLFxcbiAgMHgxMTogWydhdWRpbycsICdNUEVHLTQuQUFDJ10sXFxuICAweDgwOiBbJ2F1ZGlvJywgJ0xQQ00nXSxcXG4gIDB4ODE6IFsnYXVkaW8nLCAnQUMzJ10sXFxuICAweDA2OiBbJ2F1ZGlvJywgJ0FDMyddLFxcbiAgMHg4MjogWydhdWRpbycsICdEVFMnXSxcXG4gIDB4ODM6IFsnYXVkaW8nLCAnRG9sYnkgVHJ1ZUhEJ10sXFxuICAweDg0OiBbJ2F1ZGlvJywgJ0FDMy1QbHVzJ10sXFxuICAweDg1OiBbJ2F1ZGlvJywgJ0RUUy1IRCddLFxcbiAgMHg4NjogWydhdWRpbycsICdEVFMtTUEnXSxcXG4gIDB4YTE6IFsnYXVkaW8nLCAnQUMzLVBsdXMtU0VDJ10sXFxuICAweGEyOiBbJ2F1ZGlvJywgJ0RUUy1IRC1TRUMnXVxcbn07XFxuXFxuY2xhc3MgVHNEZW11eGVyIHtcXG4gIGNvbnN0cnVjdG9yKGNvbmZpZ3MpIHtcXG4gICAgdGhpcy5jb25maWdzID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlncyk7XFxuICAgIHRoaXMuZGVtdXhpbmcgPSBmYWxzZTtcXG4gICAgdGhpcy5wYXQgPSBbXTtcXG4gICAgdGhpcy5wbXQgPSBbXTtcXG4gICAgdGhpcy5faGFzVmlkZW9NZXRhID0gZmFsc2U7XFxuICAgIHRoaXMuX2hhc0F1ZGlvTWV0YSA9IGZhbHNlO1xcbiAgfVxcblxcbiAgaW5pdCgpIHtcXG4gICAgdGhpcy5vbihERU1VWF9FVkVOVFMuREVNVVhfU1RBUlQsIHRoaXMuZGVtdXguYmluZCh0aGlzKSk7XFxuICB9XFxuXFxuICBkZW11eChmcmFnKSB7XFxuICAgIGlmICh0aGlzLmRlbXV4aW5nKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGxldCBidWZmZXIgPSB0aGlzLmlucHV0QnVmZmVyO1xcbiAgICBsZXQgZnJhZ3MgPSB7IHBhdDogW10sIHBtdDogW10gfTtcXG4gICAgbGV0IHBlc2VzID0ge307XFxuXFxuICAgIC8vIFJlYWQgVFMgc2VnbWVudFxcbiAgICB3aGlsZSAoYnVmZmVyLmxlbmd0aCA+PSAxODgpIHtcXG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+PSAxICYmIGJ1ZmZlci5hcnJheVswXVtidWZmZXIub2Zmc2V0XSAhPT0gNzEpIHtcXG4gICAgICAgIHRoaXMuZW1pdChERU1VWF9FVkVOVFMuREVNVVhfRVJST1IsIHRoaXMuVEFHLCBuZXcgRXJyb3IoYFVudHJ1c3Qgc3luYyBjb2RlOiAke2J1ZmZlci5hcnJheVswXVtidWZmZXIub2Zmc2V0XX0sIHRyeSB0byByZWNvdmVyO2ApLCBmYWxzZSk7XFxuICAgICAgfVxcbiAgICAgIHdoaWxlIChidWZmZXIubGVuZ3RoID49IDEgJiYgYnVmZmVyLmFycmF5WzBdW2J1ZmZlci5vZmZzZXRdICE9PSA3MSkge1xcbiAgICAgICAgYnVmZmVyLnNoaWZ0KDEpO1xcbiAgICAgIH1cXG4gICAgICBsZXQgYnVmID0gYnVmZmVyLnNoaWZ0KDE4OCk7XFxuICAgICAgLy8gY29uc29sZS5sb2coYnVmKTtcXG4gICAgICBsZXQgdHNTdHJlYW0gPSBuZXcgX3hncGxheWVyVXRpbHMuU3RyZWFtKGJ1Zi5idWZmZXIpO1xcbiAgICAgIGxldCB0cyA9IHt9O1xcbiAgICAgIFRzRGVtdXhlci5yZWFkKHRzU3RyZWFtLCB0cywgZnJhZ3MpO1xcbiAgICAgIGlmICh0cy5wZXMpIHtcXG4gICAgICAgIGlmICghcGVzZXNbdHMuaGVhZGVyLnBpZF0pIHtcXG4gICAgICAgICAgcGVzZXNbdHMuaGVhZGVyLnBpZF0gPSBbXTtcXG4gICAgICAgIH1cXG4gICAgICAgIHBlc2VzW3RzLmhlYWRlci5waWRdLnB1c2godHMucGVzKTtcXG4gICAgICAgIHRzLnBlcy5FUy5idWZmZXIgPSBbdHMucGVzLkVTLmJ1ZmZlcl07XFxuICAgICAgfSBlbHNlIGlmIChwZXNlc1t0cy5oZWFkZXIucGlkXSkge1xcbiAgICAgICAgcGVzZXNbdHMuaGVhZGVyLnBpZF1bcGVzZXNbdHMuaGVhZGVyLnBpZF0ubGVuZ3RoIC0gMV0uRVMuYnVmZmVyLnB1c2godHMucGF5bG9hZC5zdHJlYW0pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBsZXQgQXVkaW9PcHRpb25zID0gZnJhZztcXG4gICAgbGV0IFZpZGVvT3B0aW9ucyA9IGZyYWc7XFxuXFxuICAgIC8vIEdldCBGcmFtZXMgZGF0YVxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE9iamVjdC5rZXlzKHBlc2VzKS5sZW5ndGg7IGkrKykge1xcbiAgICAgIGxldCBlcGVzZXMgPSBwZXNlc1tPYmplY3Qua2V5cyhwZXNlcylbaV1dO1xcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZXBlc2VzLmxlbmd0aDsgaisrKSB7XFxuICAgICAgICBlcGVzZXNbal0uaWQgPSBPYmplY3Qua2V5cyhwZXNlcylbaV07XFxuICAgICAgICBlcGVzZXNbal0uRVMuYnVmZmVyID0gVHNEZW11eGVyLk1lcmdlKGVwZXNlc1tqXS5FUy5idWZmZXIpO1xcbiAgICAgICAgaWYgKGVwZXNlc1tqXS50eXBlID09PSAnYXVkaW8nKSB7XFxuICAgICAgICAgIHRoaXMucHVzaEF1ZGlvU2FtcGxlKGVwZXNlc1tqXSwgQXVkaW9PcHRpb25zKTtcXG4gICAgICAgICAgQXVkaW9PcHRpb25zID0ge307XFxuICAgICAgICB9IGVsc2UgaWYgKGVwZXNlc1tqXS50eXBlID09PSAndmlkZW8nKSB7XFxuICAgICAgICAgIHRoaXMucHVzaFZpZGVvU2FtcGxlKGVwZXNlc1tqXSwgVmlkZW9PcHRpb25zKTtcXG4gICAgICAgICAgVmlkZW9PcHRpb25zID0ge307XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLl9oYXNBdWRpb01ldGEpIHtcXG4gICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLkRFTVVYX0NPTVBMRVRFLCAnYXVkaW8nKTtcXG4gICAgfVxcbiAgICBpZiAodGhpcy5faGFzVmlkZW9NZXRhKSB7XFxuICAgICAgdGhpcy5lbWl0KERFTVVYX0VWRU5UUy5ERU1VWF9DT01QTEVURSwgJ3ZpZGVvJyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHB1c2hBdWRpb1NhbXBsZShwZXMsIG9wdGlvbnMpIHtcXG4gICAgbGV0IHRyYWNrO1xcbiAgICBpZiAoIXRoaXMuX3RyYWNrcy5hdWRpb1RyYWNrKSB7XFxuICAgICAgdGhpcy5fdHJhY2tzLmF1ZGlvVHJhY2sgPSBuZXcgX3hncGxheWVyQnVmZmVyLkF1ZGlvVHJhY2soKTtcXG4gICAgICB0cmFjayA9IHRoaXMuX3RyYWNrcy5hdWRpb1RyYWNrO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRyYWNrID0gdGhpcy5fdHJhY2tzLmF1ZGlvVHJhY2s7XFxuICAgIH1cXG4gICAgbGV0IG1ldGEgPSBuZXcgX3hncGxheWVyVXRpbHMuQXVkaW9UcmFja01ldGEoe1xcbiAgICAgIGF1ZGlvU2FtcGxlUmF0ZTogcGVzLkVTLmZyZXF1ZW5jZSxcXG4gICAgICBzYW1wbGVSYXRlOiBwZXMuRVMuZnJlcXVlbmNlLFxcbiAgICAgIGNoYW5uZWxDb3VudDogcGVzLkVTLmNoYW5uZWwsXFxuICAgICAgY29kZWM6ICdtcDRhLjQwLicgKyBwZXMuRVMuYXVkaW9PYmplY3RUeXBlLFxcbiAgICAgIGNvbmZpZzogcGVzLkVTLmF1ZGlvQ29uZmlnLFxcbiAgICAgIGlkOiAyLFxcbiAgICAgIHNhbXBsZVJhdGVJbmRleDogcGVzLkVTLmZyZXF1ZW5jeUluZGV4XFxuICAgIH0pO1xcbiAgICBtZXRhLnJlZlNhbXBsZUR1cmF0aW9uID0gTWF0aC5mbG9vcigxMDI0IC8gbWV0YS5hdWRpb1NhbXBsZVJhdGUgKiBtZXRhLnRpbWVzY2FsZSk7XFxuXFxuICAgIGxldCBtZXRhRXF1YWwgPSBUc0RlbXV4ZXIuY29tcGFpcmVNZXRhKHRyYWNrLm1ldGEsIG1ldGEsIHRydWUpO1xcblxcbiAgICBpZiAoIXRoaXMuX2hhc0F1ZGlvTWV0YSB8fCAhbWV0YUVxdWFsKSB7XFxuICAgICAgdHJhY2subWV0YSA9IG1ldGE7XFxuICAgICAgdGhpcy5faGFzQXVkaW9NZXRhID0gdHJ1ZTtcXG4gICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLk1FVEFEQVRBX1BBUlNFRCwgJ2F1ZGlvJyk7XFxuICAgIH1cXG5cXG4gICAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheShwZXMuRVMuYnVmZmVyLmJ1ZmZlci5zbGljZShwZXMuRVMuYnVmZmVyLnBvc2l0aW9uLCBwZXMuRVMuYnVmZmVyLmxlbmd0aCkpO1xcbiAgICBsZXQgZHRzID0gcGFyc2VJbnQocGVzLnB0cyAvIDkwKTtcXG4gICAgbGV0IHB0cyA9IHBhcnNlSW50KHBlcy5wdHMgLyA5MCk7XFxuICAgIGxldCBzYW1wbGUgPSBuZXcgX3hncGxheWVyVXRpbHMuQXVkaW9UcmFja1NhbXBsZSh7IGR0cywgcHRzLCBkYXRhLCBvcHRpb25zIH0pO1xcbiAgICB0cmFjay5zYW1wbGVzLnB1c2goc2FtcGxlKTtcXG4gIH1cXG5cXG4gIHB1c2hWaWRlb1NhbXBsZShwZXMsIG9wdGlvbnMpIHtcXG4gICAgbGV0IG5hbHMgPSBfeGdwbGF5ZXJDb2RlYy5OYWx1bml0LmdldE5hbHVuaXRzKHBlcy5FUy5idWZmZXIpO1xcbiAgICBsZXQgdHJhY2s7XFxuICAgIGxldCBtZXRhID0gbmV3IF94Z3BsYXllclV0aWxzLlZpZGVvVHJhY2tNZXRhKCk7XFxuICAgIGlmICghdGhpcy5fdHJhY2tzLnZpZGVvVHJhY2spIHtcXG4gICAgICB0aGlzLl90cmFja3MudmlkZW9UcmFjayA9IG5ldyBfeGdwbGF5ZXJCdWZmZXIuVmlkZW9UcmFjaygpO1xcbiAgICAgIHRyYWNrID0gdGhpcy5fdHJhY2tzLnZpZGVvVHJhY2s7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdHJhY2sgPSB0aGlzLl90cmFja3MudmlkZW9UcmFjaztcXG4gICAgfVxcbiAgICBsZXQgc2FtcGxlTGVuZ3RoID0gMDtcXG4gICAgbGV0IHNwcyA9IGZhbHNlO1xcbiAgICBsZXQgcHBzID0gZmFsc2U7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFscy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGxldCBuYWwgPSBuYWxzW2ldO1xcbiAgICAgIGlmIChuYWwuc3BzKSB7XFxuICAgICAgICBzcHMgPSBuYWw7XFxuICAgICAgICB0cmFjay5zcHMgPSBuYWwuYm9keTtcXG4gICAgICAgIG1ldGEuY2hyb21hRm9ybWF0ID0gc3BzLnNwcy5jaHJvbWFfZm9ybWF0O1xcbiAgICAgICAgbWV0YS5jb2RlYyA9ICdhdmMxLic7XFxuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IDQ7IGorKykge1xcbiAgICAgICAgICB2YXIgaCA9IHNwcy5ib2R5W2pdLnRvU3RyaW5nKDE2KTtcXG4gICAgICAgICAgaWYgKGgubGVuZ3RoIDwgMikge1xcbiAgICAgICAgICAgIGggPSAnMCcgKyBoO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIG1ldGEuY29kZWMgKz0gaDtcXG4gICAgICAgIH1cXG4gICAgICAgIG1ldGEuY29kZWNIZWlnaHQgPSBzcHMuc3BzLmNvZGVjX3NpemUuaGVpZ2h0O1xcbiAgICAgICAgbWV0YS5jb2RlY1dpZHRoID0gc3BzLnNwcy5jb2RlY19zaXplLndpZHRoO1xcbiAgICAgICAgbWV0YS5mcmFtZVJhdGUgPSBzcHMuc3BzLmZyYW1lX3JhdGU7XFxuICAgICAgICBtZXRhLmlkID0gMTtcXG4gICAgICAgIG1ldGEubGV2ZWwgPSBzcHMuc3BzLmxldmVsX3N0cmluZztcXG4gICAgICAgIG1ldGEucHJlc2VudEhlaWdodCA9IHNwcy5zcHMucHJlc2VudF9zaXplLmhlaWdodDtcXG4gICAgICAgIG1ldGEucHJlc2VudFdpZHRoID0gc3BzLnNwcy5wcmVzZW50X3NpemUud2lkdGg7XFxuICAgICAgICBtZXRhLnByb2ZpbGUgPSBzcHMuc3BzLnByb2ZpbGVfc3RyaW5nO1xcbiAgICAgICAgbWV0YS5yZWZTYW1wbGVEdXJhdGlvbiA9IE1hdGguZmxvb3IobWV0YS50aW1lc2NhbGUgKiAoc3BzLnNwcy5mcmFtZV9yYXRlLmZwc19kZW4gLyBzcHMuc3BzLmZyYW1lX3JhdGUuZnBzX251bSkpO1xcbiAgICAgICAgbWV0YS5zYXJSYXRpbyA9IHNwcy5zcHMuc2FyX3JhdGlvID8gc3BzLnNwcy5zYXJfcmF0aW8gOiBzcHMuc3BzLnBhcl9yYXRpbztcXG4gICAgICB9IGVsc2UgaWYgKG5hbC5wcHMpIHtcXG4gICAgICAgIHRyYWNrLnBwcyA9IG5hbC5ib2R5O1xcbiAgICAgICAgcHBzID0gbmFsO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzYW1wbGVMZW5ndGggKz0gNCArIG5hbC5ib2R5LmJ5dGVMZW5ndGg7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChzcHMgJiYgcHBzKSB7XFxuICAgICAgbWV0YS5hdmNjID0gX3hncGxheWVyQ29kZWMuTmFsdW5pdC5nZXRBdmNjKHNwcy5ib2R5LCBwcHMuYm9keSk7XFxuICAgICAgbGV0IG1ldGFFcXVhbCA9IFRzRGVtdXhlci5jb21wYWlyZU1ldGEodHJhY2subWV0YSwgbWV0YSwgdHJ1ZSk7XFxuICAgICAgaWYgKCF0aGlzLl9oYXNWaWRlb01ldGEgfHwgIW1ldGFFcXVhbCkge1xcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcXG4gICAgICAgICAgb3B0aW9ucy5tZXRhID0gT2JqZWN0LmFzc2lnbih7fSwgbWV0YSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBvcHRpb25zID0ge1xcbiAgICAgICAgICAgIG1ldGE6IE9iamVjdC5hc3NpZ24oe30sIG1ldGEpXFxuICAgICAgICAgIH07XFxuICAgICAgICB9XFxuICAgICAgICB0cmFjay5tZXRhID0gbWV0YTtcXG4gICAgICAgIHRoaXMuX2hhc1ZpZGVvTWV0YSA9IHRydWU7XFxuICAgICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLk1FVEFEQVRBX1BBUlNFRCwgJ3ZpZGVvJyk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoc2FtcGxlTGVuZ3RoKTtcXG4gICAgbGV0IG9mZnNldCA9IDA7XFxuICAgIGxldCBpc0tleWZyYW1lID0gZmFsc2U7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFscy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGxldCBuYWwgPSBuYWxzW2ldO1xcbiAgICAgIGxldCBsZW5ndGggPSBuYWwuYm9keS5ieXRlTGVuZ3RoO1xcbiAgICAgIGlmIChuYWwuaWRyKSB7XFxuICAgICAgICBpc0tleWZyYW1lID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgICAgaWYgKCFuYWwucHBzICYmICFuYWwuc3BzKSB7XFxuICAgICAgICBkYXRhLnNldChuZXcgVWludDhBcnJheShbbGVuZ3RoID4+PiAyNCAmIDB4ZmYsIGxlbmd0aCA+Pj4gMTYgJiAweGZmLCBsZW5ndGggPj4+IDggJiAweGZmLCBsZW5ndGggJiAweGZmXSksIG9mZnNldCk7XFxuICAgICAgICBvZmZzZXQgKz0gNDtcXG4gICAgICAgIGRhdGEuc2V0KG5hbC5ib2R5LCBvZmZzZXQpO1xcbiAgICAgICAgb2Zmc2V0ICs9IGxlbmd0aDtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgbGV0IHNhbXBsZSA9IG5ldyBfeGdwbGF5ZXJVdGlscy5WaWRlb1RyYWNrU2FtcGxlKHtcXG4gICAgICBkdHM6IHBhcnNlSW50KHBlcy5kdHMgLyA5MCksXFxuICAgICAgcHRzOiBwYXJzZUludChwZXMucHRzIC8gOTApLFxcbiAgICAgIGN0czogKHBlcy5wdHMgLSBwZXMuZHRzKSAvIDkwLFxcbiAgICAgIG9yaWdpbkR0czogcGVzLmR0cyxcXG4gICAgICBpc0tleWZyYW1lLFxcbiAgICAgIGRhdGEsXFxuICAgICAgb3B0aW9uc1xcbiAgICB9KTtcXG4gICAgdHJhY2suc2FtcGxlcy5wdXNoKHNhbXBsZSk7XFxuICB9XFxuXFxuICBkZXN0b3J5KCkge1xcbiAgICB0aGlzLm9mZihERU1VWF9FVkVOVFMuREVNVVhfU1RBUlQsIHRoaXMuZGVtdXgpO1xcbiAgICB0aGlzLmNvbmZpZ3MgPSB7fTtcXG4gICAgdGhpcy5kZW11eGluZyA9IGZhbHNlO1xcbiAgICB0aGlzLnBhdCA9IFtdO1xcbiAgICB0aGlzLnBtdCA9IFtdO1xcbiAgICB0aGlzLl9oYXNWaWRlb01ldGEgPSBmYWxzZTtcXG4gICAgdGhpcy5faGFzQXVkaW9NZXRhID0gZmFsc2U7XFxuICB9XFxuXFxuICBzdGF0aWMgY29tcGFpcmVBcnJheShhLCBiLCB0eXBlKSB7XFxuICAgIGxldCBhbCA9IDA7XFxuICAgIGxldCBibCA9IDA7XFxuICAgIGlmICh0eXBlID09PSAnVWludDhBcnJheScpIHtcXG4gICAgICBhbCA9IGEuYnl0ZUxlbmd0aDtcXG4gICAgICBibCA9IGIuYnl0ZUxlbmd0aDtcXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnQXJyYXknKSB7XFxuICAgICAgYWwgPSBhLmxlbmd0aDtcXG4gICAgICBibCA9IGIubGVuZ3RoO1xcbiAgICB9XFxuICAgIGlmIChhbCAhPT0gYmwpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbDsgaSsrKSB7XFxuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICBzdGF0aWMgY29tcGFpcmVNZXRhKGEsIGIsIGlnbm9yZUR1cmF0aW9uKSB7XFxuICAgIGlmICghYSB8fCAhYikge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICBmb3IgKGxldCBpID0gMCwgayA9IE9iamVjdC5rZXlzKGEpLmxlbmd0aDsgaSA8IGs7IGkrKykge1xcbiAgICAgIGxldCBpdGVtYSA9IGFbT2JqZWN0LmtleXMoYSlbaV1dO1xcbiAgICAgIGxldCBpdGVtYiA9IGJbT2JqZWN0LmtleXMoYSlbaV1dO1xcbiAgICAgIGlmICh0eXBlb2YgaXRlbWEgIT09ICdvYmplY3QnKSB7XFxuICAgICAgICBpZiAoaWdub3JlRHVyYXRpb24gJiYgT2JqZWN0LmtleXMoYSlbaV0gIT09ICdkdXJhdGlvbicgJiYgT2JqZWN0LmtleXMoYSlbaV0gIT09ICdyZWZTYW1wbGVEdXJhdGlvbicgJiYgT2JqZWN0LmtleXMoYSlbaV0gIT09ICdyZWZTYW1wbGVEdXJhdGlvbkZpeGVkJyAmJiBpdGVtYSAhPT0gaXRlbWIpIHtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAoaXRlbWEuYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBpZiAoaXRlbWIuYnl0ZUxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghVHNEZW11eGVyLmNvbXBhaXJlQXJyYXkoaXRlbWEsIGl0ZW1iLCAnVWludDhBcnJheScpKSB7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKGl0ZW1hLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBpZiAoaXRlbWIubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFUc0RlbXV4ZXIuY29tcGFpcmVBcnJheShpdGVtYSwgaXRlbWIsICdBcnJheScpKSB7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKCFUc0RlbXV4ZXIuY29tcGFpcmVNZXRhKGl0ZW1hLCBpdGVtYikpIHtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBNZXJnZShidWZmZXJzKSB7XFxuICAgIGxldCBkYXRhO1xcbiAgICBsZXQgbGVuZ3RoID0gMDtcXG4gICAgbGV0IG9mZnNldCA9IDA7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGxlbmd0aCArPSBidWZmZXJzW2ldLmxlbmd0aCAtIGJ1ZmZlcnNbaV0ucG9zaXRpb247XFxuICAgIH1cXG5cXG4gICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGxldCBidWZmZXIgPSBidWZmZXJzW2ldO1xcbiAgICAgIGRhdGEuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5wb3NpdGlvbiksIG9mZnNldCk7XFxuICAgICAgb2Zmc2V0ICs9IGJ1ZmZlci5sZW5ndGggLSBidWZmZXIucG9zaXRpb247XFxuICAgIH1cXG4gICAgcmV0dXJuIG5ldyBfeGdwbGF5ZXJVdGlscy5TdHJlYW0oZGF0YS5idWZmZXIpO1xcbiAgfVxcblxcbiAgc3RhdGljIHJlYWQoc3RyZWFtLCB0cywgZnJhZ3MpIHtcXG4gICAgVHNEZW11eGVyLnJlYWRIZWFkZXIoc3RyZWFtLCB0cyk7XFxuICAgIFRzRGVtdXhlci5yZWFkUGF5bG9hZChzdHJlYW0sIHRzLCBmcmFncyk7XFxuICAgIGlmICh0cy5oZWFkZXIucGFja2V0ID09PSAnTUVESUEnICYmIHRzLmhlYWRlci5wYXlsb2FkID09PSAxICYmICF0cy51bmtub3duUElEcykge1xcbiAgICAgIHRzLnBlcyA9IFRzRGVtdXhlci5QRVModHMpO1xcbiAgICB9XFxuICB9XFxuXFxuICBzdGF0aWMgcmVhZFBheWxvYWQoc3RyZWFtLCB0cywgZnJhZ3MpIHtcXG4gICAgbGV0IGhlYWRlciA9IHRzLmhlYWRlcjtcXG4gICAgbGV0IHBpZCA9IGhlYWRlci5waWQ7XFxuICAgIHN3aXRjaCAocGlkKSB7XFxuICAgICAgY2FzZSAwOlxcbiAgICAgICAgVHNEZW11eGVyLlBBVChzdHJlYW0sIHRzLCBmcmFncyk7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIDE6XFxuICAgICAgICBUc0RlbXV4ZXIuQ0FUKHN0cmVhbSwgdHMsIGZyYWdzKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgMjpcXG4gICAgICAgIFRzRGVtdXhlci5UU0RUKHN0cmVhbSwgdHMsIGZyYWdzKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgMHgxZmZmOlxcbiAgICAgICAgYnJlYWs7XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIC8vIFRPRE86IHNvbWXnmoTlhpnms5XkuI3lpKrlpb3vvIzlvpfmlLlcXG4gICAgICAgIGlmIChmcmFncy5wYXQuc29tZShpdGVtID0+IHtcXG4gICAgICAgICAgcmV0dXJuIGl0ZW0ucGlkID09PSBwaWQ7XFxuICAgICAgICB9KSkge1xcbiAgICAgICAgICBUc0RlbXV4ZXIuUE1UKHN0cmVhbSwgdHMsIGZyYWdzKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGxldCBzdHMgPSBmcmFncy5wbXQgPyBmcmFncy5wbXQuZmlsdGVyKGl0ZW0gPT4gaXRlbS5waWQgPT09IHBpZCkgOiBbXTtcXG4gICAgICAgICAgaWYgKHN0cy5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgVHNEZW11eGVyLk1lZGlhKHN0cmVhbSwgdHMsIFN0cmVhbVR5cGVbc3RzWzBdLnN0cmVhbVR5cGVdWzBdKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0cy51bmtub3duUElEcyA9IHRydWU7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHN0YXRpYyByZWFkSGVhZGVyKHN0cmVhbSwgdHMpIHtcXG4gICAgbGV0IGhlYWRlciA9IHt9O1xcbiAgICBoZWFkZXIuc3luYyA9IHN0cmVhbS5yZWFkVWludDgoKTtcXG4gICAgbGV0IG5leHQgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xcbiAgICBoZWFkZXIuZXJyb3IgPSBuZXh0ID4+PiAxNTtcXG4gICAgaGVhZGVyLnBheWxvYWQgPSBuZXh0ID4+PiAxNCAmIDE7XFxuICAgIGhlYWRlci5wcmlvcml0eSA9IG5leHQgPj4+IDEzICYgMTtcXG4gICAgaGVhZGVyLnBpZCA9IG5leHQgJiAweDFmZmY7XFxuXFxuICAgIG5leHQgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XFxuXFxuICAgIGhlYWRlci5zY3JhbWJsaW5nID0gbmV4dCA+PiA2ICYgMHgzOyAvLyDmmK/lkKbliqDlr4bvvIwwMOihqOekuuS4jeWKoOWvhlxcblxcbiAgICAvKipcXG4gICAgICogMDAgSVNPL0lFQ+acquadpeS9v+eUqOS/neeVmVxcbiAgICAgKiAwMSDmsqHmnInosIPmlbTlrZfmrrXvvIzku4XlkKvmnIkxODRC5pyJ5pWI5YeA6I23XFxuICAgICAqIDAyIOayoeacieacieaViOWHgOiNt++8jOS7heWQq+aciTE4M0LosIPmlbTlrZfmrrVcXG4gICAgICogMDMgMH4xODJC6LCD5pW05a2X5q615ZCO5Li65pyJ5pWI5YeA6I23XFxuICAgICAqL1xcbiAgICBoZWFkZXIuYWRhcHRhdGlvbiA9IG5leHQgPj4gNCAmIDB4MztcXG4gICAgaGVhZGVyLmNvbnRpbnVpdHkgPSBuZXh0ICYgMTU7XFxuICAgIGhlYWRlci5wYWNrZXQgPSBoZWFkZXIucGlkID09PSAwID8gJ1BBVCcgOiAnTUVESUEnO1xcbiAgICB0cy5oZWFkZXIgPSBoZWFkZXI7XFxuICB9XFxuXFxuICBzdGF0aWMgUEFUKHN0cmVhbSwgdHMsIGZyYWdzKSB7XFxuICAgIGxldCByZXQgPSB7fTtcXG4gICAgbGV0IG5leHQgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XFxuICAgIHN0cmVhbS5za2lwKG5leHQpO1xcbiAgICBuZXh0ID0gc3RyZWFtLnJlYWRVaW50OCgpO1xcbiAgICByZXQudGFiZWxJRCA9IG5leHQ7XFxuICAgIG5leHQgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xcbiAgICByZXQuZXJyb3IgPSBuZXh0ID4+PiA3O1xcbiAgICByZXQuemVybyA9IG5leHQgPj4+IDYgJiAxO1xcbiAgICByZXQuc2VjdGlvbkxlbmd0aCA9IG5leHQgJiAweGZmZjtcXG4gICAgcmV0LnN0cmVhbUlEID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcXG4gICAgcmV0LmN1cnJlbnQgPSBzdHJlYW0ucmVhZFVpbnQ4KCkgJiAxO1xcbiAgICByZXQuc2VjdGlvbk51bWJlciA9IHN0cmVhbS5yZWFkVWludDgoKTtcXG4gICAgcmV0Lmxhc3RTZWN0aW9uTnVtYmVyID0gc3RyZWFtLnJlYWRVaW50OCgpO1xcbiAgICBsZXQgTiA9IChyZXQuc2VjdGlvbkxlbmd0aCAtIDkpIC8gNDtcXG4gICAgbGV0IGxpc3QgPSBbXTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpKyspIHtcXG4gICAgICBsZXQgcHJvZ3JhbU51bWJlciA9IHN0cmVhbS5yZWFkVWludDE2KCk7XFxuICAgICAgbGV0IHBpZCA9IHN0cmVhbS5yZWFkVWludDE2KCkgJiAweDFmZmY7XFxuICAgICAgbGlzdC5wdXNoKHtcXG4gICAgICAgIHByb2dyYW06IHByb2dyYW1OdW1iZXIsXFxuICAgICAgICBwaWQsXFxuICAgICAgICB0eXBlOiBwcm9ncmFtTnVtYmVyID09PSAwID8gJ25ldHdvcmsnIDogJ21hcFBJRCdcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBpZiAobGlzdC5sZW5ndGggPiAwKSB7XFxuICAgICAgZnJhZ3MucGF0ID0gZnJhZ3MucGF0LmNvbmNhdChsaXN0KTtcXG4gICAgfVxcbiAgICByZXQubGlzdCA9IGxpc3Q7XFxuICAgIHJldC5wcm9ncmFtID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcXG4gICAgcmV0LnBpZCA9IHN0cmVhbS5yZWFkVWludDE2KCkgJiAweDFmZmY7XFxuICAgIHRzLnBheWxvYWQgPSByZXQ7XFxuICAgIC8vIFRPRE8gQ1JDXFxuICB9XFxuXFxuICBzdGF0aWMgUE1UKHN0cmVhbSwgdHMsIGZyYWdzKSB7XFxuICAgIGxldCByZXQgPSB7fTtcXG4gICAgbGV0IGhlYWRlciA9IHRzLmhlYWRlcjtcXG4gICAgaGVhZGVyLnBhY2tldCA9ICdQTVQnO1xcbiAgICBsZXQgbmV4dCA9IHN0cmVhbS5yZWFkVWludDgoKTtcXG4gICAgc3RyZWFtLnNraXAobmV4dCk7XFxuICAgIG5leHQgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XFxuICAgIHJldC50YWJsZUlEID0gbmV4dDtcXG4gICAgbmV4dCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XFxuICAgIHJldC5zZWN0aW9uTGVuZ3RoID0gbmV4dCAmIDB4ZmZmO1xcbiAgICByZXQucHJvZ3JhbSA9IHN0cmVhbS5yZWFkVWludDE2KCk7XFxuICAgIHJldC5jdXJyZW50ID0gc3RyZWFtLnJlYWRVaW50OCgpICYgMTtcXG4gICAgcmV0Lm9yZGVyID0gc3RyZWFtLnJlYWRVaW50OCgpO1xcbiAgICByZXQubGFzdE9yZGVyID0gc3RyZWFtLnJlYWRVaW50OCgpO1xcbiAgICByZXQuUENSX1BJRCA9IHN0cmVhbS5yZWFkVWludDE2KCkgJiAweDFmZmY7XFxuICAgIHJldC5wcm9ncmFtTGVuZ3RoID0gc3RyZWFtLnJlYWRVaW50MTYoKSAmIDB4ZmZmO1xcbiAgICBsZXQgTiA9IChyZXQuc2VjdGlvbkxlbmd0aCAtIDEzKSAvIDU7XFxuICAgIGxldCBsaXN0ID0gW107XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSsrKSB7XFxuICAgICAgbGlzdC5wdXNoKHtcXG4gICAgICAgIHN0cmVhbVR5cGU6IHN0cmVhbS5yZWFkVWludDgoKSxcXG4gICAgICAgIHBpZDogc3RyZWFtLnJlYWRVaW50MTYoKSAmIDB4MWZmZiwgLy8gMHgwN2U1IOinhumike+8jDB4MDdlNlxcbiAgICAgICAgZXM6IHN0cmVhbS5yZWFkVWludDE2KCkgJiAweGZmZlxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIHJldC5saXN0ID0gbGlzdDtcXG4gICAgaWYgKCF0aGlzLnBtdCkge1xcbiAgICAgIHRoaXMucG10ID0gW107XFxuICAgIH1cXG4gICAgZnJhZ3MucG10ID0gdGhpcy5wbXQuY29uY2F0KGxpc3QubWFwKGl0ZW0gPT4ge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBwaWQ6IGl0ZW0ucGlkLFxcbiAgICAgICAgZXM6IGl0ZW0uZXMsXFxuICAgICAgICBzdHJlYW1UeXBlOiBpdGVtLnN0cmVhbVR5cGUsXFxuICAgICAgICBwcm9ncmFtOiByZXQucHJvZ3JhbVxcbiAgICAgIH07XFxuICAgIH0pKTtcXG4gICAgdHMucGF5bG9hZCA9IHJldDtcXG4gIH1cXG5cXG4gIHN0YXRpYyBNZWRpYShzdHJlYW0sIHRzLCB0eXBlKSB7XFxuICAgIGxldCBoZWFkZXIgPSB0cy5oZWFkZXI7XFxuICAgIGxldCBwYXlsb2FkID0ge307XFxuICAgIGhlYWRlci50eXBlID0gdHlwZTtcXG4gICAgaWYgKGhlYWRlci5hZGFwdGF0aW9uID09PSAweDAzKSB7XFxuICAgICAgcGF5bG9hZC5hZGFwdGF0aW9uTGVuZ3RoID0gc3RyZWFtLnJlYWRVaW50OCgpO1xcbiAgICAgIGlmIChwYXlsb2FkLmFkYXB0YXRpb25MZW5ndGggPiAwKSB7XFxuICAgICAgICBsZXQgbmV4dCA9IHN0cmVhbS5yZWFkVWludDgoKTtcXG4gICAgICAgIHBheWxvYWQuZGlzY29udGludWUgPSBuZXh0ID4+PiA3O1xcbiAgICAgICAgcGF5bG9hZC5hY2Nlc3MgPSBuZXh0ID4+PiA2ICYgMHgwMTtcXG4gICAgICAgIHBheWxvYWQucHJpb3JpdHkgPSBuZXh0ID4+PiA1ICYgMHgwMTtcXG4gICAgICAgIHBheWxvYWQuUENSID0gbmV4dCA+Pj4gNCAmIDB4MDE7XFxuICAgICAgICBwYXlsb2FkLk9QQ1IgPSBuZXh0ID4+PiAzICYgMHgwMTtcXG4gICAgICAgIHBheWxvYWQuc3BsaWNlUG9pbnQgPSBuZXh0ID4+PiAyICYgMHgwMTtcXG4gICAgICAgIHBheWxvYWQudHJhbnNwb3J0UHJpdmF0ZSA9IG5leHQgPj4+IDEgJiAweDAxO1xcbiAgICAgICAgcGF5bG9hZC5hZGFwdGF0aW9uRmllbGQgPSBuZXh0ICYgMHgwMTtcXG4gICAgICAgIGxldCBfc3RhcnQgPSBzdHJlYW0ucG9zaXRpb247XFxuICAgICAgICBpZiAocGF5bG9hZC5QQ1IgPT09IDEpIHtcXG4gICAgICAgICAgcGF5bG9hZC5wcm9ncmFtQ2xvY2tCYXNlID0gc3RyZWFtLnJlYWRVaW50MzIoKSA8PCAxO1xcbiAgICAgICAgICBuZXh0ID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcXG4gICAgICAgICAgcGF5bG9hZC5wcm9ncmFtQ2xvY2tCYXNlIHw9IG5leHQgPj4+IDE1O1xcbiAgICAgICAgICBwYXlsb2FkLnByb2dyYW1DbG9ja0V4dGVuc2lvbiA9IG5leHQgJiAweDFmZjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChwYXlsb2FkLk9QQ1IgPT09IDEpIHtcXG4gICAgICAgICAgcGF5bG9hZC5vcmlnaW5Qcm9ncmFtQ2xvY2tCYXNlID0gc3RyZWFtLnJlYWRVaW50MzIoKSA8PCAxO1xcbiAgICAgICAgICBuZXh0ID0gc3RyZWFtLnJlYWRVaW50MTYoKTtcXG4gICAgICAgICAgcGF5bG9hZC5vcmlnaW5Qcm9ncmFtQ2xvY2tCYXNlICs9IG5leHQgPj4+IDE1O1xcbiAgICAgICAgICBwYXlsb2FkLm9yaWdpblByb2dyYW1DbG9ja0V4dGVuc2lvbiA9IG5leHQgJiAweDFmZjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChwYXlsb2FkLnNwbGljZVBvaW50ID09PSAxKSB7XFxuICAgICAgICAgIHBheWxvYWQuc3BsaWNlQ291bnRkb3duID0gc3RyZWFtLnJlYWRVaW50OCgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHBheWxvYWQudHJhbnNwb3J0UHJpdmF0ZSA9PT0gMSkge1xcbiAgICAgICAgICBsZXQgbGVuZ3RoID0gc3RyZWFtLnJlYWRVaW50OCgpO1xcbiAgICAgICAgICBsZXQgdHJhbnNwb3J0UHJpdmF0ZURhdGEgPSBbXTtcXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIHRyYW5zcG9ydFByaXZhdGVEYXRhLnB1c2goc3RyZWFtLnJlYWRVaW50OCgpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHBheWxvYWQuYWRhcHRhdGlvbkZpZWxkID09PSAxKSB7XFxuICAgICAgICAgIGxldCBsZW5ndGggPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XFxuICAgICAgICAgIGxldCBuZXh0ID0gc3RyZWFtLnJlYWRVaW50OCgpO1xcbiAgICAgICAgICBsZXQgc3RhcnQgPSBzdHJlYW0ucG9zaXRpb247XFxuICAgICAgICAgIGxldCBsdHcgPSBuZXh0ID4+PiA3O1xcbiAgICAgICAgICBsZXQgcGllY2V3aXNlID0gbmV4dCA+Pj4gNiAmIDB4MTtcXG4gICAgICAgICAgbGV0IHNlYW1sZXNzID0gbmV4dCA+Pj4gNSAmIDB4MTtcXG4gICAgICAgICAgaWYgKGx0dyA9PT0gMSkge1xcbiAgICAgICAgICAgIG5leHQgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xcbiAgICAgICAgICAgIHBheWxvYWQubHR3VmFsaWQgPSBuZXh0ID4+PiAxNTtcXG4gICAgICAgICAgICBwYXlsb2FkLmx0d09mZnNldCA9IG5leHQgJiAweGVmZmY7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKHBpZWNld2lzZSA9PT0gMSkge1xcbiAgICAgICAgICAgIG5leHQgPSBzdHJlYW0ucmVhZFVpbnQyNCgpO1xcbiAgICAgICAgICAgIHBheWxvYWQucGllY2V3aXNlUmF0ZSA9IG5leHQgJiAweDNmZmZmZjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoc2VhbWxlc3MgPT09IDEpIHtcXG4gICAgICAgICAgICBuZXh0ID0gc3RyZWFtLnJlYWRJbnQ4KCk7XFxuICAgICAgICAgICAgcGF5bG9hZC5zcGxpY2VUeXBlID0gbmV4dCA+Pj4gNDtcXG4gICAgICAgICAgICBwYXlsb2FkLmR0c05leHRBVTEgPSBuZXh0ID4+PiAxICYgMHg3O1xcbiAgICAgICAgICAgIHBheWxvYWQubWFya2VyMSA9IG5leHQgJiAweDE7XFxuICAgICAgICAgICAgbmV4dCA9IHN0cmVhbS5yZWFkVWludDE2KCk7XFxuICAgICAgICAgICAgcGF5bG9hZC5kdHNOZXh0QVUyID0gbmV4dCA+Pj4gMTtcXG4gICAgICAgICAgICBwYXlsb2FkLm1hcmtlcjIgPSBuZXh0ICYgMHgxO1xcbiAgICAgICAgICAgIG5leHQgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xcbiAgICAgICAgICAgIHBheWxvYWQuZHRzTmV4dEFVMyA9IG5leHQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc3RyZWFtLnNraXAobGVuZ3RoIC0gMSAtIChzdHJlYW0ucG9zaXRpb24gLSBzdGFydCkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IGxhc3RTdHVmZmluZyA9IHBheWxvYWQuYWRhcHRhdGlvbkxlbmd0aCAtIDEgLSAoc3RyZWFtLnBvc2l0aW9uIC0gX3N0YXJ0KTtcXG4gICAgICAgIHN0cmVhbS5za2lwKGxhc3RTdHVmZmluZyk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHBheWxvYWQuc3RyZWFtID0gbmV3IF94Z3BsYXllclV0aWxzLlN0cmVhbShzdHJlYW0uYnVmZmVyLnNsaWNlKHN0cmVhbS5wb3NpdGlvbikpO1xcbiAgICB0cy5wYXlsb2FkID0gcGF5bG9hZDtcXG4gIH1cXG5cXG4gIHN0YXRpYyBQRVModHMpIHtcXG4gICAgbGV0IHJldCA9IHt9O1xcbiAgICBsZXQgYnVmZmVyID0gdHMucGF5bG9hZC5zdHJlYW07XFxuXFxuICAgIGxldCBuZXh0ID0gYnVmZmVyLnJlYWRVaW50MjQoKTtcXG4gICAgaWYgKG5leHQgIT09IDEpIHtcXG4gICAgICByZXQuRVMgPSB7fTtcXG4gICAgICByZXQuRVMuYnVmZmVyID0gYnVmZmVyO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGxldCBzdHJlYW1JRCA9IGJ1ZmZlci5yZWFkVWludDgoKTtcXG4gICAgICBpZiAoc3RyZWFtSUQgPj0gMHhlMCAmJiBzdHJlYW1JRCA8PSAweGVmKSB7XFxuICAgICAgICByZXQudHlwZSA9ICd2aWRlbyc7XFxuICAgICAgfVxcbiAgICAgIGlmIChzdHJlYW1JRCA+PSAweGMwICYmIHN0cmVhbUlEIDw9IDB4ZGYpIHtcXG4gICAgICAgIHJldC50eXBlID0gJ2F1ZGlvJztcXG4gICAgICB9XFxuICAgICAgbGV0IHBhY2tldExlbmd0aCA9IGJ1ZmZlci5yZWFkVWludDE2KCk7XFxuICAgICAgcmV0LnBhY2tldExlbmd0aCA9IHBhY2tldExlbmd0aDtcXG4gICAgICBpZiAocmV0LnR5cGUgPT09ICd2aWRlbycgfHwgcmV0LnR5cGUgPT09ICdhdWRpbycpIHtcXG4gICAgICAgIGxldCBuZXh0ID0gYnVmZmVyLnJlYWRVaW50OCgpO1xcbiAgICAgICAgbGV0IGZpcnN0ID0gbmV4dCA+Pj4gNjtcXG4gICAgICAgIGlmIChmaXJzdCAhPT0gMHgwMikge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Vycm9yIHdoZW4gcGFyc2UgcGVzIGhlYWRlcicpO1xcbiAgICAgICAgfVxcbiAgICAgICAgbmV4dCA9IGJ1ZmZlci5yZWFkVWludDgoKTtcXG4gICAgICAgIHJldC5wdHNEVFNGbGFnID0gbmV4dCA+Pj4gNjtcXG4gICAgICAgIHJldC5lc2NyRmxhZyA9IG5leHQgPj4+IDUgJiAweDAxO1xcbiAgICAgICAgcmV0LmVzUmF0ZUZsYWcgPSBuZXh0ID4+PiA0ICYgMHgwMTtcXG4gICAgICAgIHJldC5kc21GbGFnID0gbmV4dCA+Pj4gMyAmIDB4MDE7XFxuICAgICAgICByZXQuYWRkaXRpb25hbEZsYWcgPSBuZXh0ID4+PiAyICYgMHgwMTtcXG4gICAgICAgIHJldC5jcmNGbGFnID0gbmV4dCA+Pj4gMSAmIDB4MDE7XFxuICAgICAgICByZXQuZXh0ZW5zaW9uRmxhZyA9IG5leHQgJiAweDAxO1xcbiAgICAgICAgcmV0LnBlc0hlYWRlckxlbmd0aCA9IGJ1ZmZlci5yZWFkVWludDgoKTtcXG4gICAgICAgIGxldCBOMSA9IHJldC5wZXNIZWFkZXJMZW5ndGg7XFxuXFxuICAgICAgICBpZiAocmV0LnB0c0RUU0ZsYWcgPT09IDIpIHtcXG4gICAgICAgICAgbGV0IHB0cyA9IFtdO1xcbiAgICAgICAgICBuZXh0ID0gYnVmZmVyLnJlYWRVaW50OCgpO1xcbiAgICAgICAgICBwdHMucHVzaChuZXh0ID4+PiAxICYgMHgwNyk7XFxuICAgICAgICAgIG5leHQgPSBidWZmZXIucmVhZFVpbnQxNigpO1xcbiAgICAgICAgICBwdHMucHVzaChuZXh0ID4+PiAxKTtcXG4gICAgICAgICAgbmV4dCA9IGJ1ZmZlci5yZWFkVWludDE2KCk7XFxuICAgICAgICAgIHB0cy5wdXNoKG5leHQgPj4+IDEpO1xcbiAgICAgICAgICByZXQucHRzID0gcHRzWzBdIDw8IDMwIHwgcHRzWzFdIDw8IDE1IHwgcHRzWzJdO1xcbiAgICAgICAgICBOMSAtPSA1O1xcbiAgICAgICAgICAvLyDop4bpopHlpoLmnpzmsqHmnIlkdHPnlKhwdHNcXG4gICAgICAgICAgaWYgKHJldC50eXBlID09PSAndmlkZW8nKSB7XFxuICAgICAgICAgICAgcmV0LmR0cyA9IHJldC5wdHM7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChyZXQucHRzRFRTRmxhZyA9PT0gMykge1xcbiAgICAgICAgICBsZXQgcHRzID0gW107XFxuICAgICAgICAgIG5leHQgPSBidWZmZXIucmVhZFVpbnQ4KCk7XFxuICAgICAgICAgIHB0cy5wdXNoKG5leHQgPj4+IDEgJiAweDA3KTtcXG4gICAgICAgICAgbmV4dCA9IGJ1ZmZlci5yZWFkVWludDE2KCk7XFxuICAgICAgICAgIHB0cy5wdXNoKG5leHQgPj4+IDEpO1xcbiAgICAgICAgICBuZXh0ID0gYnVmZmVyLnJlYWRVaW50MTYoKTtcXG4gICAgICAgICAgcHRzLnB1c2gobmV4dCA+Pj4gMSk7XFxuICAgICAgICAgIHJldC5wdHMgPSBwdHNbMF0gPDwgMzAgfCBwdHNbMV0gPDwgMTUgfCBwdHNbMl07XFxuICAgICAgICAgIGxldCBkdHMgPSBbXTtcXG4gICAgICAgICAgbmV4dCA9IGJ1ZmZlci5yZWFkVWludDgoKTtcXG4gICAgICAgICAgZHRzLnB1c2gobmV4dCA+Pj4gMSAmIDB4MDcpO1xcbiAgICAgICAgICBuZXh0ID0gYnVmZmVyLnJlYWRVaW50MTYoKTtcXG4gICAgICAgICAgZHRzLnB1c2gobmV4dCA+Pj4gMSk7XFxuICAgICAgICAgIG5leHQgPSBidWZmZXIucmVhZFVpbnQxNigpO1xcbiAgICAgICAgICBkdHMucHVzaChuZXh0ID4+PiAxKTtcXG4gICAgICAgICAgcmV0LmR0cyA9IGR0c1swXSA8PCAzMCB8IGR0c1sxXSA8PCAxNSB8IGR0c1syXTtcXG4gICAgICAgICAgTjEgLT0gMTA7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAocmV0LmVzY3JGbGFnID09PSAxKSB7XFxuICAgICAgICAgIGxldCBlc2NyID0gW107XFxuICAgICAgICAgIGxldCBleCA9IFtdO1xcbiAgICAgICAgICBuZXh0ID0gYnVmZmVyLnJlYWRVaW50OCgpO1xcbiAgICAgICAgICBlc2NyLnB1c2gobmV4dCA+Pj4gMyAmIDB4MDcpO1xcbiAgICAgICAgICBlc2NyLnB1c2gobmV4dCAmIDB4MDMpO1xcbiAgICAgICAgICBuZXh0ID0gYnVmZmVyLnJlYWRVaW50MTYoKTtcXG4gICAgICAgICAgZXNjci5wdXNoKG5leHQgPj4+IDEzKTtcXG4gICAgICAgICAgZXNjci5wdXNoKG5leHQgJiAweDAzKTtcXG4gICAgICAgICAgbmV4dCA9IGJ1ZmZlci5yZWFkVWludDE2KCk7XFxuICAgICAgICAgIGVzY3IucHVzaChuZXh0ID4+PiAxMyk7XFxuICAgICAgICAgIGV4LnB1c2gobmV4dCAmIDB4MDMpO1xcbiAgICAgICAgICBuZXh0ID0gYnVmZmVyLnJlYWRVaW50OCgpO1xcbiAgICAgICAgICBleC5wdXNoKG5leHQgPj4+IDEpO1xcbiAgICAgICAgICByZXQuZXNjciA9IChlc2NyWzBdIDw8IDMwIHwgZXNjclsxXSA8PCAyOCB8IGVzY3JbMl0gPDwgMTUgfCBlc2NyWzNdIDw8IDEzIHwgZXNjcls0XSkgKiAzMDAgKyAoZXhbMF0gPDwgNyB8IGV4WzFdKTtcXG4gICAgICAgICAgTjEgLT0gNjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChyZXQuZXNSYXRlRmxhZyA9PT0gMSkge1xcbiAgICAgICAgICBuZXh0ID0gYnVmZmVyLnJlYWRVaW50MjQoKTtcXG4gICAgICAgICAgcmV0LmVzUmF0ZSA9IG5leHQgPj4+IDEgJiAweDNmZmZmZjtcXG4gICAgICAgICAgTjEgLT0gMztcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChyZXQuZHNtRmxhZyA9PT0gMSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBzdXBwb3J0IERTTV90cmlja19tb2RlJyk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAocmV0LmFkZGl0aW9uYWxGbGFnID09PSAxKSB7XFxuICAgICAgICAgIG5leHQgPSBidWZmZXIucmVhZFVpbnQ4KCk7XFxuICAgICAgICAgIHJldC5hZGRpdGlvbmFsQ29weUluZm8gPSBuZXh0ICYgMHg3ZjtcXG4gICAgICAgICAgTjEgLT0gMTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChyZXQuY3JjRmxhZyA9PT0gMSkge1xcbiAgICAgICAgICByZXQucGVzQ1JDID0gYnVmZmVyLnJlYWRVaW50MTYoKTtcXG4gICAgICAgICAgTjEgLT0gMjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChyZXQuZXh0ZW5zaW9uRmxhZyA9PT0gMSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBzdXBwb3J0IGV4dGVuc2lvbicpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKE4xID4gMCkge1xcbiAgICAgICAgICBidWZmZXIuc2tpcChOMSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXQuRVMgPSBUc0RlbXV4ZXIuRVMoYnVmZmVyLCByZXQudHlwZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZm9ybWF0IGlzIG5vdCBzdXBwb3J0ZWQnKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHJldDtcXG4gIH1cXG5cXG4gIHN0YXRpYyBFUyhidWZmZXIsIHR5cGUpIHtcXG4gICAgbGV0IG5leHQ7XFxuICAgIGxldCByZXQgPSB7fTtcXG4gICAgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcXG4gICAgICBuZXh0ID0gYnVmZmVyLnJlYWRVaW50MzIoKTtcXG4gICAgICBpZiAobmV4dCAhPT0gMSkge1xcbiAgICAgICAgYnVmZmVyLmJhY2soNCk7XFxuICAgICAgICBuZXh0ID0gYnVmZmVyLnJlYWRVaW50MjQoKTtcXG4gICAgICAgIGlmIChuZXh0ICE9PSAxKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaDI2NCBuYWwgaGVhZGVyIHBhcnNlIGZhaWxlZCcpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBidWZmZXIuc2tpcCgyKTsgLy8gMDkgRjBcXG4gICAgICAvLyBUT0RPIHJlYWRuYWx1XFxuICAgICAgcmV0LmJ1ZmZlciA9IGJ1ZmZlcjtcXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYXVkaW8nKSB7XFxuICAgICAgbmV4dCA9IGJ1ZmZlci5yZWFkVWludDE2KCk7XFxuICAgICAgLy8gYWR0c+eahOWQjOatpeWtl+iKgu+8jDEy5L2NXFxuICAgICAgaWYgKG5leHQgPj4+IDQgIT09IDB4ZmZmKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FhYyBFUyBwYXJzZSBFcnJvcicpO1xcbiAgICAgIH1cXG4gICAgICBjb25zdCBmcSA9IFs5NjAwMCwgODgyMDAsIDY0MDAwLCA0ODAwMCwgNDQxMDAsIDMyMDAwLCAyNDAwMCwgMjIwNTAsIDE2MDAwLCAxMjAwMCwgMTEwMjUsIDgwMDAsIDczNTBdO1xcbiAgICAgIHJldC5pZCA9IChuZXh0ID4+PiAzICYgMHgwMSkgPT09IDAgPyAnTVBFRy00JyA6ICdNUEVHLTInO1xcbiAgICAgIHJldC5sYXllciA9IG5leHQgPj4+IDEgJiAweDAzO1xcbiAgICAgIHJldC5hYnNlbnQgPSBuZXh0ICYgMHgwMTtcXG4gICAgICBuZXh0ID0gYnVmZmVyLnJlYWRVaW50MTYoKTtcXG4gICAgICByZXQuYXVkaW9PYmplY3RUeXBlID0gKG5leHQgPj4+IDE0ICYgMHgwMykgKyAxO1xcbiAgICAgIHJldC5wcm9maWxlID0gcmV0LmF1ZGlvT2JqZWN0VHlwZSAtIDE7XFxuICAgICAgcmV0LmZyZXF1ZW5jeUluZGV4ID0gbmV4dCA+Pj4gMTAgJiAweDBmO1xcbiAgICAgIHJldC5mcmVxdWVuY2UgPSBmcVtyZXQuZnJlcXVlbmN5SW5kZXhdO1xcbiAgICAgIHJldC5jaGFubmVsID0gbmV4dCA+Pj4gNiAmIDB4MDc7XFxuICAgICAgcmV0LmZyYW1lTGVuZ3RoID0gKG5leHQgJiAweDAzKSA8PCAxMSB8IGJ1ZmZlci5yZWFkVWludDE2KCkgPj4+IDU7XFxuICAgICAgVHNEZW11eGVyLmdldEF1ZGlvQ29uZmlnKHJldCk7XFxuICAgICAgYnVmZmVyLnNraXAoMSk7XFxuICAgICAgcmV0LmJ1ZmZlciA9IGJ1ZmZlcjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVTICR7dHlwZX0gaXMgbm90IHN1cHBvcnRlZGApO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiByZXQ7XFxuICB9XFxuXFxuICBzdGF0aWMgVFNEVChzdHJlYW0sIHRzLCBmcmFncykge1xcbiAgICAvLyBUT0RPXFxuICAgIHRzLnBheWxvYWQgPSB7fTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBDQVQoc3RyZWFtLCB0cywgZnJhZ3MpIHtcXG4gICAgbGV0IHJldCA9IHt9O1xcbiAgICByZXQudGFibGVJRCA9IHN0cmVhbS5yZWFkVWludDgoKTtcXG4gICAgbGV0IG5leHQgPSBzdHJlYW0ucmVhZFVpbnQxNigpO1xcbiAgICByZXQuc2VjdGlvbkluZGljYXRvciA9IG5leHQgPj4+IDc7XFxuICAgIHJldC5zZWN0aW9uTGVuZ3RoID0gbmV4dCAmIDB4MGZmZjtcXG4gICAgc3RyZWFtLnNraXAoMik7XFxuICAgIG5leHQgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XFxuICAgIHJldC52ZXJzaW9uID0gbmV4dCA+Pj4gMztcXG4gICAgcmV0LmN1cnJlbnROZXh0SW5kaWNhdG9yID0gbmV4dCAmIDB4MDE7XFxuICAgIHJldC5zZWN0aW9uTnVtYmVyID0gc3RyZWFtLnJlYWRVaW50OCgpO1xcbiAgICByZXQubGFzdFNlY3Rpb25OdW1iZXIgPSBzdHJlYW0ucmVhZFVpbnQ4KCk7XFxuICAgIGxldCBOID0gKHRoaXMuc2VjdGlvbkxlbmd0aCAtIDkpIC8gNDtcXG4gICAgbGV0IGxpc3QgPSBbXTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpKyspIHtcXG4gICAgICBsaXN0LnB1c2goe30pO1xcbiAgICB9XFxuICAgIHJldC5jcmMzMiA9IHN0cmVhbS5yZWFkVWludDMyKCk7XFxuICAgIHRzLnBheWxvYWQgPSByZXQ7XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0QXVkaW9Db25maWcocmV0KSB7XFxuICAgIGxldCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XFxuICAgIGxldCBjb25maWc7XFxuICAgIGxldCBleHRlbnNpb25TYW1wbGVJbmRleDtcXG4gICAgaWYgKC9maXJlZm94L2kudGVzdCh1c2VyQWdlbnQpKSB7XFxuICAgICAgaWYgKHJldC5mcmVxdWVuY3lJbmRleCA+PSA2KSB7XFxuICAgICAgICByZXQuYXVkaW9PYmplY3RUeXBlID0gNTtcXG4gICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSg0KTtcXG4gICAgICAgIGV4dGVuc2lvblNhbXBsZUluZGV4ID0gcmV0LmZyZXF1ZW5jeUluZGV4IC0gMztcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0LmF1ZGlvT2JqZWN0VHlwZSA9IDI7XFxuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XFxuICAgICAgICBleHRlbnNpb25TYW1wbGVJbmRleCA9IHJldC5mcmVxdWVuY3lJbmRleDtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEpIHtcXG4gICAgICByZXQuYXVkaW9PYmplY3RUeXBlID0gMjtcXG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XFxuICAgICAgZXh0ZW5zaW9uU2FtcGxlSW5kZXggPSByZXQuZnJlcXVlbmN5SW5kZXg7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0LmF1ZGlvT2JqZWN0VHlwZSA9IDU7XFxuICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xcbiAgICAgIGlmIChyZXQuZnJlcXVlbmN5SW5kZXggPj0gNikge1xcbiAgICAgICAgZXh0ZW5zaW9uU2FtcGxlSW5kZXggPSByZXQuZnJlcXVlbmN5SW5kZXggLSAzO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAocmV0LmNoYW5uZWwgPT09IDEpIHtcXG4gICAgICAgICAgcmV0LmF1ZGlvT2JqZWN0VHlwZSA9IDI7XFxuICAgICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGV4dGVuc2lvblNhbXBsZUluZGV4ID0gcmV0LmZyZXF1ZW5jeUluZGV4O1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBjb25maWdbMF0gPSByZXQuYXVkaW9PYmplY3RUeXBlIDw8IDM7XFxuICAgIGNvbmZpZ1swXSB8PSAocmV0LmZyZXF1ZW5jeUluZGV4ICYgMHgwZSkgPj4gMTtcXG4gICAgY29uZmlnWzFdID0gKHJldC5mcmVxdWVuY3lJbmRleCAmIDB4MDEpIDw8IDc7XFxuICAgIGNvbmZpZ1sxXSB8PSByZXQuY2hhbm5lbCA8PCAzO1xcbiAgICBpZiAocmV0LmF1ZGlvT2JqZWN0VHlwZSA9PT0gNSkge1xcbiAgICAgIGNvbmZpZ1sxXSB8PSAoZXh0ZW5zaW9uU2FtcGxlSW5kZXggJiAweDBlKSA+PiAxO1xcbiAgICAgIGNvbmZpZ1syXSA9IChleHRlbnNpb25TYW1wbGVJbmRleCAmIDB4MDEpIDw8IDc7XFxuICAgICAgY29uZmlnWzJdIHw9IDIgPDwgMjtcXG4gICAgICBjb25maWdbM10gPSAwO1xcbiAgICB9XFxuICAgIHJldC5hdWRpb0NvbmZpZyA9IGNvbmZpZztcXG4gIH1cXG5cXG4gIGdldCBpbnB1dEJ1ZmZlcigpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UodGhpcy5jb25maWdzLmlucHV0YnVmZmVyKTtcXG4gIH1cXG5cXG4gIGdldCBfdHJhY2tzKCkge1xcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZSgnVFJBQ0tTJyk7XFxuICB9XFxufVxcblxcbmV4cG9ydHMuZGVmYXVsdCA9IFRzRGVtdXhlcjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItZGVtdXgvc3JjL2hscy9kZW11eGVyL3RzLmpzP1wiKX0sXCIuLi94Z3BsYXllci1kZW11eC9zcmMvaGxzL3BsYXlsaXN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItZGVtdXgvc3JjL2hscy9wbGF5bGlzdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuY2xhc3MgUGxheWxpc3Qge1xcbiAgY29uc3RydWN0b3IoY29uZmlncykge1xcbiAgICB0aGlzLl9iYXNlVVJMID0gJyc7XFxuICAgIHRoaXMuX2xpc3QgPSB7fTtcXG4gICAgdGhpcy5fdHMgPSB7fTtcXG4gICAgdGhpcy52ZXJzaW9uID0gMDtcXG4gICAgdGhpcy5zZXF1ZW5jZSA9IC0xO1xcbiAgICB0aGlzLnRhcmdldGR1cmF0aW9uID0gMDtcXG4gICAgdGhpcy5kdXJhdGlvbiA9IDA7XFxuICAgIHRoaXMuZnJhZ0xlbmd0aCA9IDA7XFxuICAgIHRoaXMuX2xhc3RnZXQgPSB1bmRlZmluZWQ7XFxuICAgIHRoaXMuX2F1ZG9jbGVhciA9IGNvbmZpZ3MuYXV0b2NsZWFyIHx8IGZhbHNlO1xcbiAgfVxcblxcbiAgZ2V0IGxpc3QoKSB7XFxuICAgIHJldHVybiB0aGlzLl9saXN0O1xcbiAgfVxcblxcbiAgc2V0IGJhc2VVUkwoYmFzZVVSTCkge1xcbiAgICBpZiAodGhpcy5iYXNlVVJMICE9PSBiYXNlVVJMKSB7XFxuICAgICAgdGhpcy5jbGVhcigpO1xcbiAgICAgIHRoaXMuX2Jhc2VVUkwgPSBiYXNlVVJMO1xcbiAgICB9XFxuICB9XFxuXFxuICBnZXQgYmFzZVVSTCgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2Jhc2VVUkw7XFxuICB9XFxuXFxuICBwdXNoKHRzLCBkdXJhdGlvbiwgZGlzY29udGludWUpIHtcXG4gICAgaWYgKCF0aGlzLl90c1t0c10pIHtcXG4gICAgICB0aGlzLl90c1t0c10gPSB7IGR1cmF0aW9uOiBkdXJhdGlvbixcXG4gICAgICAgIGRvd25sb2FkZWQ6IGZhbHNlLFxcbiAgICAgICAgZG93bmxvYWRpbmc6IGZhbHNlLFxcbiAgICAgICAgc3RhcnQ6IHRoaXMuZHVyYXRpb24sXFxuICAgICAgICBkaXNjb250aW51ZTogZGlzY29udGludWUgPyB0cnVlIDogZmFsc2VcXG4gICAgICB9O1xcbiAgICAgIHRoaXMuX2xpc3RbdGhpcy5kdXJhdGlvbl0gPSB0cztcXG4gICAgICB0aGlzLmR1cmF0aW9uICs9IGR1cmF0aW9uO1xcbiAgICAgIHRoaXMuZnJhZ0xlbmd0aCArPSAxO1xcbiAgICB9XFxuICB9XFxuXFxuICBkZWxldGVGcmFnKHVybCkge1xcbiAgICBpZiAodGhpcy5fdHNbdXJsXSkge1xcbiAgICAgIGlmICh0aGlzLl90c1t1cmxdLnN0YXJ0ID4gdGhpcy5fbGFzdGdldC50aW1lKSB7XFxuICAgICAgICB0aGlzLl9sYXN0Z2V0ID0ge1xcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5fdHNbdXJsXS5kdXJhdGlvbixcXG4gICAgICAgICAgdGltZTogdGhpcy5fdHNbdXJsXS5zdGFydCxcXG4gICAgICAgICAgZG93bmxvYWRlZDogZmFsc2UsXFxuICAgICAgICAgIGRvd25sb2FkaW5nOiBmYWxzZSxcXG4gICAgICAgICAgdXJsOiB1cmxcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICAgIGRlbGV0ZSB0aGlzLl9saXN0W3RoaXMuX3RzW3VybF0uc3RhcnRdO1xcbiAgICAgIGRlbGV0ZSB0aGlzLl90c1t1cmxdO1xcbiAgICAgIHRoaXMuZnJhZ0xlbmd0aCAtPSAxO1xcbiAgICB9XFxuICB9XFxuXFxuICBwdXNoTTNVOChkYXRhLCBkZWxldGVwcmUpIHtcXG4gICAgLy8g5bi46KeE5L+h5oGv5pu/5o2iXFxuICAgIGlmICghZGF0YSkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gbTN1OCBkYXRhIHJlY2VpdmVkLmApO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICB0aGlzLnZlcnNpb24gPSBkYXRhLnZlcnNpb247XFxuICAgIHRoaXMudGFyZ2V0ZHVyYXRpb24gPSBkYXRhLnRhcmdldGR1cmF0aW9uO1xcbiAgICBpZiAoZGF0YS5lbmNyeXB0ICYmICF0aGlzLmVuY3J5cHQpIHtcXG4gICAgICB0aGlzLmVuY3J5cHQgPSBkYXRhLmVuY3J5cHQ7XFxuICAgIH1cXG4gICAgLy8g5paw5YiG54mH5L+h5oGvXFxuICAgIGlmIChkYXRhLnNlcXVlbmNlID4gdGhpcy5zZXF1ZW5jZSkge1xcbiAgICAgIHRoaXMuc2VxdWVuY2UgPSBkYXRhLnNlcXVlbmNlO1xcbiAgICAgIGxldCBuZXdmcmFnbGlzdCA9IFtdO1xcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5mcmFncy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgbGV0IGZyYWcgPSBkYXRhLmZyYWdzW2ldO1xcbiAgICAgICAgaWYgKCF0aGlzLl90c1tmcmFnLnVybF0pIHtcXG4gICAgICAgICAgbmV3ZnJhZ2xpc3QucHVzaChmcmFnLnVybCk7XFxuICAgICAgICAgIHRoaXMucHVzaChmcmFnLnVybCwgZnJhZy5kdXJhdGlvbiwgZnJhZy5kaXNjb250aW51ZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChuZXdmcmFnbGlzdC5sZW5ndGggPCAxKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgcmVhZCB0cyBmaWxlIGxpc3QuYCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkZWxldGVwcmUpIHtcXG4gICAgICAgIGxldCB0c2xpc3QgPSB0aGlzLmdldFRzTGlzdCgpO1xcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0c2xpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgaWYgKG5ld2ZyYWdsaXN0LmluZGV4T2YodHNsaXN0W2ldKSA8IDApIHtcXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZUZyYWcodHNsaXN0W2ldKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9sZCBtM3U4IGZpbGUgcmVjZWl2ZWQsICR7ZGF0YS5zZXF1ZW5jZX1gKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZ2V0VHNMaXN0KCkge1xcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fdHMpO1xcbiAgfVxcblxcbiAgZG93bmxvYWRlZCh0c25hbWUsIGlzbG9hZGVkKSB7XFxuICAgIGxldCB0cyA9IHRoaXMuX3RzW3RzbmFtZV07XFxuICAgIGlmICh0cykge1xcbiAgICAgIHRzLmRvd25sb2FkZWQgPSBpc2xvYWRlZDtcXG4gICAgfVxcbiAgfVxcblxcbiAgZG93bmxvYWRpbmcodHNuYW1lLCBsb2FkaW5nKSB7XFxuICAgIGxldCB0cyA9IHRoaXMuX3RzW3RzbmFtZV07XFxuICAgIGlmICh0cykge1xcbiAgICAgIHRzLmRvd25sb2FkaW5nID0gbG9hZGluZztcXG4gICAgfVxcbiAgfVxcblxcbiAgZ2V0VHNCeU5hbWUobmFtZSkge1xcbiAgICByZXR1cm4gdGhpcy5fdHNbbmFtZV07XFxuICB9XFxuXFxuICBnZXRUcyh0aW1lKSB7XFxuICAgIGxldCB0aW1lbGlzdCA9IE9iamVjdC5rZXlzKHRoaXMuX2xpc3QpO1xcbiAgICBsZXQgdHM7XFxuXFxuICAgIGlmICh0aW1lID09PSB1bmRlZmluZWQpIHtcXG4gICAgICBpZiAodGhpcy5fbGFzdGdldCkge1xcbiAgICAgICAgdGltZSA9IHRoaXMuX2xhc3RnZXQudGltZSArIHRoaXMuX2xhc3RnZXQuZHVyYXRpb247XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRpbWUgPSAwO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAodGltZWxpc3QubGVuZ3RoIDwgMSB8fCB0aW1lID49IHRoaXMuZHVyYXRpb24pIHtcXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xcbiAgICB9XFxuICAgIHRpbWVsaXN0LnNvcnQoKGEsIGIpID0+IHtcXG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChhKSAtIHBhcnNlRmxvYXQoYik7XFxuICAgIH0pO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVsaXN0Lmxlbmd0aDsgaSsrKSB7XFxuICAgICAgaWYgKHRpbWUgPj0gcGFyc2VJbnQodGltZWxpc3RbaV0pKSB7XFxuICAgICAgICBsZXQgdXJsID0gdGhpcy5fbGlzdFt0aW1lbGlzdFtpXV07XFxuICAgICAgICBsZXQgZG93bmxvYWRlZCA9IHRoaXMuX3RzW3VybF0uZG93bmxvYWRlZDtcXG4gICAgICAgIGxldCBkb3dubG9hZGluZyA9IHRoaXMuX3RzW3VybF0uZG93bmxvYWRpbmc7XFxuICAgICAgICB0cyA9IHsgdXJsLCBkb3dubG9hZGVkLCBkb3dubG9hZGluZywgdGltZTogcGFyc2VJbnQodGltZWxpc3RbaV0pLCBkdXJhdGlvbjogcGFyc2VJbnQodGhpcy5fdHNbdXJsXS5kdXJhdGlvbikgfTtcXG4gICAgICAgIGlmICh0aGlzLmF1dG9jbGVhcikge1xcbiAgICAgICAgICBkZWxldGUgdGhpcy5fdHNbdGhpcy5fbGFzdGdldC51cmxdO1xcbiAgICAgICAgICBkZWxldGUgdGhpcy5fbGlzdFt0aGlzLl9sYXN0Z2V0LnRpbWVdO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5fbGFzdGdldCA9IHRzO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHRzO1xcbiAgfVxcblxcbiAgY2xlYXIoKSB7XFxuICAgIHRoaXMuX2Jhc2VVUkwgPSAnJztcXG4gICAgdGhpcy5fbGlzdCA9IHt9O1xcbiAgICB0aGlzLl90cyA9IHt9O1xcbiAgICB0aGlzLnZlcnNpb24gPSAwO1xcbiAgICB0aGlzLnNlcXVlbmNlID0gLTE7XFxuICAgIHRoaXMudGFyZ2V0ZHVyYXRpb24gPSAwO1xcbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcXG4gIH1cXG5cXG4gIGNsZWFyRG93bmxvYWRlZCgpIHtcXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBPYmplY3Qua2V5cyh0aGlzLl90cykubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgbGV0IHRzID0gdGhpcy5fdHNbT2JqZWN0LmtleXModGhpcy5fdHMpW2ldXTtcXG4gICAgICB0cy5kb3dubG9hZGVkID0gZmFsc2U7XFxuICAgICAgdHMuZG93bmxvYWRpbmcgPSBmYWxzZTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZGVzdHJveSgpIHtcXG4gICAgdGhpcy5fYmFzZVVSTCA9ICcnO1xcbiAgICB0aGlzLl9saXN0ID0ge307XFxuICAgIHRoaXMuX3RzID0ge307XFxuICAgIHRoaXMudmVyc2lvbiA9IDA7XFxuICAgIHRoaXMuc2VxdWVuY2UgPSAtMTtcXG4gICAgdGhpcy50YXJnZXRkdXJhdGlvbiA9IDA7XFxuICAgIHRoaXMuZHVyYXRpb24gPSAwO1xcbiAgICB0aGlzLmZyYWdMZW5ndGggPSAwO1xcbiAgICB0aGlzLl9sYXN0Z2V0ID0gdW5kZWZpbmVkO1xcbiAgICB0aGlzLl9hdWRvY2xlYXIgPSBmYWxzZTtcXG4gIH1cXG59XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gUGxheWxpc3Q7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLWRlbXV4L3NyYy9obHMvcGxheWxpc3QuanM/XCIpfSxcIi4uL3hncGxheWVyLWxvYWRlci9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItbG9hZGVyL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoJ1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgRmV0Y2hMb2FkZXI6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2ZldGNoLWxvYWRlciAqLyBcIi4uL3hncGxheWVyLWxvYWRlci9zcmMvZmV0Y2gtbG9hZGVyLmpzXCIpLmRlZmF1bHRcXG59O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci1sb2FkZXIvaW5kZXguanM/Jyl9LFwiLi4veGdwbGF5ZXItbG9hZGVyL3NyYy9mZXRjaC1sb2FkZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItbG9hZGVyL3NyYy9mZXRjaC1sb2FkZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgX3hncGxheWVyVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB4Z3BsYXllci11dGlscyAqLyBcXFwiLi4veGdwbGF5ZXItdXRpbHMvaW5kZXguanNcXFwiKTtcXG5cXG5jb25zdCBMT0FERVJfRVZFTlRTID0gX3hncGxheWVyVXRpbHMuRVZFTlRTLkxPQURFUl9FVkVOVFM7XFxuY29uc3QgUkVBRF9TVFJFQU0gPSAwO1xcbmNvbnN0IFJFQURfVEVYVCA9IDE7XFxuY29uc3QgUkVBRF9KU09OID0gMjtcXG5jb25zdCBSRUFEX0JVRkZFUiA9IDM7XFxuY2xhc3MgRmV0Y2hMb2FkZXIge1xcbiAgY29uc3RydWN0b3IoY29uZmlncykge1xcbiAgICB0aGlzLmNvbmZpZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWdzKTtcXG4gICAgdGhpcy51cmwgPSBudWxsO1xcbiAgICB0aGlzLnN0YXR1cyA9IDA7XFxuICAgIHRoaXMuZXJyb3IgPSBudWxsO1xcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xcbiAgICB0aGlzLl9jYW5jZWxlZCA9IGZhbHNlO1xcbiAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcXG4gICAgdGhpcy5yZWFkdHlwZSA9IHRoaXMuY29uZmlncy5yZWFkdHlwZTtcXG4gICAgdGhpcy5idWZmZXIgPSB0aGlzLmNvbmZpZ3MuYnVmZmVyIHx8ICdMT0FERVJfQlVGRkVSJztcXG4gICAgdGhpcy5fbG9hZGVyVGFza05vID0gMDtcXG4gIH1cXG5cXG4gIGluaXQoKSB7XFxuICAgIHRoaXMub24oTE9BREVSX0VWRU5UUy5MQURFUl9TVEFSVCwgdGhpcy5sb2FkLmJpbmQodGhpcykpO1xcbiAgfVxcblxcbiAgc3RhdGljIGdldCB0eXBlKCkge1xcbiAgICByZXR1cm4gJ2xvYWRlcic7XFxuICB9XFxuXFxuICBsb2FkKHVybCwgb3B0cykge1xcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xcbiAgICB0aGlzLnVybCA9IHVybDtcXG4gICAgdGhpcy5fY2FuY2VsZWQgPSBmYWxzZTtcXG5cXG4gICAgLy8gVE9ETzogQWRkIFJhbmdlc1xcbiAgICBsZXQgcGFyYW1zID0gdGhpcy5nZXRQYXJhbXMob3B0cyk7XFxuICAgIF90aGlzLmxvYWRpbmcgPSB0cnVlO1xcbiAgICByZXR1cm4gZmV0Y2godGhpcy51cmwsIHBhcmFtcykudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcXG4gICAgICAgIF90aGlzLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcXG4gICAgICAgIHJldHVybiBfdGhpcy5fb25GZXRjaFJlc3BvbnNlKHJlc3BvbnNlKTtcXG4gICAgICB9XFxuICAgICAgX3RoaXMubG9hZGluZyA9IGZhbHNlO1xcbiAgICAgIF90aGlzLmVtaXQoTE9BREVSX0VWRU5UUy5MT0FERVJfRVJST1IsIF90aGlzLlRBRywgbmV3IEVycm9yKGBpbnZhbGlkIHJlc3BvbnNlLmApKTtcXG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XFxuICAgICAgX3RoaXMubG9hZGluZyA9IGZhbHNlO1xcbiAgICAgIF90aGlzLmVtaXQoTE9BREVSX0VWRU5UUy5MT0FERVJfRVJST1IsIF90aGlzLlRBRywgZXJyb3IpO1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBfb25GZXRjaFJlc3BvbnNlKHJlc3BvbnNlKSB7XFxuICAgIGxldCBfdGhpcyA9IHRoaXM7XFxuICAgIGxldCBidWZmZXIgPSB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKHRoaXMuYnVmZmVyKTtcXG4gICAgdGhpcy5fbG9hZGVyVGFza05vKys7XFxuICAgIGxldCB0YXNrbm8gPSB0aGlzLl9sb2FkZXJUYXNrTm87XFxuICAgIGlmIChyZXNwb25zZS5vayA9PT0gdHJ1ZSkge1xcbiAgICAgIHN3aXRjaCAodGhpcy5yZWFkdHlwZSkge1xcbiAgICAgICAgY2FzZSBSRUFEX0pTT046XFxuICAgICAgICAgIHJlc3BvbnNlLmpzb24oKS50aGVuKGRhdGEgPT4ge1xcbiAgICAgICAgICAgIF90aGlzLmxvYWRpbmcgPSBmYWxzZTtcXG4gICAgICAgICAgICBpZiAoIV90aGlzLl9jYW5jZWxlZCAmJiAhX3RoaXMuX2Rlc3Ryb3llZCkge1xcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlcikge1xcbiAgICAgICAgICAgICAgICBidWZmZXIucHVzaChkYXRhKTtcXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChMT0FERVJfRVZFTlRTLkxPQURFUl9DT01QTEVURSwgYnVmZmVyKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoTE9BREVSX0VWRU5UUy5MT0FERVJfQ09NUExFVEUsIGRhdGEpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSBSRUFEX1RFWFQ6XFxuICAgICAgICAgIHJlc3BvbnNlLnRleHQoKS50aGVuKGRhdGEgPT4ge1xcbiAgICAgICAgICAgIF90aGlzLmxvYWRpbmcgPSBmYWxzZTtcXG4gICAgICAgICAgICBpZiAoIV90aGlzLl9jYW5jZWxlZCAmJiAhX3RoaXMuX2Rlc3Ryb3llZCkge1xcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlcikge1xcbiAgICAgICAgICAgICAgICBidWZmZXIucHVzaChkYXRhKTtcXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChMT0FERVJfRVZFTlRTLkxPQURFUl9DT01QTEVURSwgYnVmZmVyKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoTE9BREVSX0VWRU5UUy5MT0FERVJfQ09NUExFVEUsIGRhdGEpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgY2FzZSBSRUFEX0JVRkZFUjpcXG4gICAgICAgICAgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKS50aGVuKGRhdGEgPT4ge1xcbiAgICAgICAgICAgIF90aGlzLmxvYWRpbmcgPSBmYWxzZTtcXG4gICAgICAgICAgICBpZiAoIV90aGlzLl9jYW5jZWxlZCAmJiAhX3RoaXMuX2Rlc3Ryb3llZCkge1xcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlcikge1xcbiAgICAgICAgICAgICAgICBidWZmZXIucHVzaChuZXcgVWludDhBcnJheShkYXRhKSk7XFxuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoTE9BREVSX0VWRU5UUy5MT0FERVJfQ09NUExFVEUsIGJ1ZmZlcik7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KExPQURFUl9FVkVOVFMuTE9BREVSX0NPTVBMRVRFLCBkYXRhKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIGNhc2UgUkVBRF9TVFJFQU06XFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb25SZWFkZXIocmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKSwgdGFza25vKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIF9vblJlYWRlcihyZWFkZXIsIHRhc2tubykge1xcbiAgICBsZXQgYnVmZmVyID0gdGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZSh0aGlzLmJ1ZmZlcik7XFxuICAgIGlmICghYnVmZmVyICYmIHRoaXMuX3JlYWRlciB8fCB0aGlzLl9kZXN0cm95ZWQpIHtcXG4gICAgICB0cnkge1xcbiAgICAgICAgdGhpcy5fcmVhZGVyLmNhbmNlbCgpO1xcbiAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIC8vIERPIE5PVEhJTkdcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fcmVhZGVyID0gcmVhZGVyO1xcbiAgICBpZiAodGhpcy5sb2FkaW5nID09PSBmYWxzZSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xcbiAgICAvLyByZWFkZXIgcmVhZCBmdW5jdGlvbiByZXR1cm5zIGEgUHJvbWlzZS4gZ2V0IGRhdGEgd2hlbiBjYWxsYmFjayBhbmQgaGFzIHZhbHVlLmRvbmUgd2hlbiBkaXNjb25uZWN0ZWQuXFxuICAgIC8vIHJlYWTmlrnms5Xov5Tlm57kuIDkuKpQcm9taXNlLiDlm57osIPkuK3lj6/ku6Xojrflj5bliLDmlbDmja7jgILlvZN2YWx1ZS5kb25l5a2Y5Zyo5pe277yM6K+05piO6ZO+5o6l5pat5byA44CCXFxuICAgIHRoaXMuX3JlYWRlciAmJiB0aGlzLl9yZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHZhbCkge1xcbiAgICAgIGlmICh2YWwuZG9uZSkge1xcbiAgICAgICAgLy8gVE9ETzog5a6M5oiQ5aSE55CGXFxuICAgICAgICBfdGhpcy5sb2FkaW5nID0gZmFsc2U7XFxuICAgICAgICBfdGhpcy5zdGF0dXMgPSAwO1xcbiAgICAgICAgX3RoaXMuZW1pdChMT0FERVJfRVZFTlRTLkxPQURFUl9DT01QTEVURSwgYnVmZmVyKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKF90aGlzLl9jYW5jZWxlZCB8fCBfdGhpcy5fZGVzdHJveWVkKSB7XFxuICAgICAgICBpZiAoX3RoaXMuX3JlYWRlcikge1xcbiAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIF90aGlzLl9yZWFkZXIuY2FuY2VsKCk7XFxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICAvLyBETyBOT1RISU5HXFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgICAgYnVmZmVyLnB1c2godmFsLnZhbHVlKTtcXG4gICAgICBfdGhpcy5lbWl0KExPQURFUl9FVkVOVFMuTE9BREVSX0RBVEFMT0FERUQsIGJ1ZmZlcik7XFxuICAgICAgcmV0dXJuIF90aGlzLl9vblJlYWRlcihyZWFkZXIsIHRhc2tubyk7XFxuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcXG4gICAgICBfdGhpcy5sb2FkaW5nID0gZmFsc2U7XFxuICAgICAgX3RoaXMuZW1pdChMT0FERVJfRVZFTlRTLkxPQURFUl9FUlJPUiwgX3RoaXMuVEFHLCBlcnJvcik7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgZ2V0UGFyYW1zKG9wdHMpIHtcXG4gICAgbGV0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzKTtcXG4gICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xcblxcbiAgICBsZXQgcGFyYW1zID0ge1xcbiAgICAgIG1ldGhvZDogJ0dFVCcsXFxuICAgICAgaGVhZGVyczogaGVhZGVycyxcXG4gICAgICBtb2RlOiAnY29ycycsXFxuICAgICAgY2FjaGU6ICdkZWZhdWx0J1xcblxcbiAgICAgIC8vIGFkZCBjdXN0bW9yIGhlYWRlcnNcXG4gICAgICAvLyDmt7vliqDoh6rlrprkuYnlpLRcXG4gICAgfTtpZiAodHlwZW9mIHRoaXMuY29uZmlncy5oZWFkZXJzID09PSAnb2JqZWN0Jykge1xcbiAgICAgIGxldCBjb25maWdIZWFkZXJzID0gdGhpcy5jb25maWdzLmhlYWRlcnM7XFxuICAgICAgZm9yIChsZXQga2V5IGluIGNvbmZpZ0hlYWRlcnMpIHtcXG4gICAgICAgIGlmIChjb25maWdIZWFkZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcXG4gICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCBjb25maWdIZWFkZXJzW2tleV0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuaGVhZGVycyA9PT0gJ29iamVjdCcpIHtcXG4gICAgICBsZXQgb3B0SGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycztcXG4gICAgICBmb3IgKGxldCBrZXkgaW4gb3B0SGVhZGVycykge1xcbiAgICAgICAgaWYgKG9wdEhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIG9wdEhlYWRlcnNba2V5XSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChvcHRpb25zLmNvcnMgPT09IGZhbHNlKSB7XFxuICAgICAgcGFyYW1zLm1vZGUgPSAnc2FtZS1vcmlnaW4nO1xcbiAgICB9XFxuXFxuICAgIC8vIHdpdGhDcmVkZW50aWFscyBpcyBkaXNhYmxlZCBieSBkZWZhdWx0XFxuICAgIC8vIHdpdGhDcmVkZW50aWFscyDlnKjpu5jorqTmg4XlhrXkuIvkuI3ooqvkvb/nlKjjgIJcXG4gICAgaWYgKG9wdGlvbnMud2l0aENyZWRlbnRpYWxzKSB7XFxuICAgICAgcGFyYW1zLmNyZWRlbnRpYWxzID0gJ2luY2x1ZGUnO1xcbiAgICB9XFxuXFxuICAgIC8vIFRPRE86IEFkZCByYW5nZXM7XFxuICAgIHJldHVybiBwYXJhbXM7XFxuICB9XFxuXFxuICBjYW5jZWwoKSB7XFxuICAgIGlmICh0aGlzLl9yZWFkZXIpIHtcXG4gICAgICB0cnkge1xcbiAgICAgICAgdGhpcy5fcmVhZGVyLmNhbmNlbCgpO1xcbiAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIC8vIOmYsuatomZhaWxlZDogMjAw6ZSZ6K+v6KKr5omT5Y2w5Yiw5o6n5Yi25Y+w5LiKXFxuICAgICAgfVxcbiAgICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XFxuICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XFxuICAgICAgdGhpcy5fY2FuY2VsZWQgPSB0cnVlO1xcbiAgICB9XFxuICB9XFxuXFxuICBkZXN0cm95KCkge1xcbiAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xcbiAgICB0aGlzLmNhbmNlbCgpO1xcbiAgfVxcbn1cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBGZXRjaExvYWRlcjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItbG9hZGVyL3NyYy9mZXRjaC1sb2FkZXIuanM/XCIpfSxcIi4uL3hncGxheWVyLXJlbXV4L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXJlbXV4L2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbCgnXFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBNcDRSZW11eGVyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9tcDQgKi8gXCIuLi94Z3BsYXllci1yZW11eC9zcmMvbXA0L2luZGV4LmpzXCIpLmRlZmF1bHRcXG59O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci1yZW11eC9pbmRleC5qcz8nKX0sXCIuLi94Z3BsYXllci1yZW11eC9zcmMvbXA0L2ZtcDQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXJlbXV4L3NyYy9tcDQvZm1wNC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgX3hncGxheWVyVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB4Z3BsYXllci11dGlscyAqLyBcXFwiLi4veGdwbGF5ZXItdXRpbHMvaW5kZXguanNcXFwiKTtcXG5cXG4vLyBjb25zdCBVSU5UMzJfTUFYID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcXG5jbGFzcyBGbXA0IHtcXG4gIHN0YXRpYyBzaXplKHZhbHVlKSB7XFxuICAgIHJldHVybiBfeGdwbGF5ZXJVdGlscy5CdWZmZXIud3JpdGVVaW50MzIodmFsdWUpO1xcbiAgfVxcbiAgc3RhdGljIGluaXRCb3goc2l6ZSwgbmFtZSwgLi4uY29udGVudCkge1xcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgX3hncGxheWVyVXRpbHMuQnVmZmVyKCk7XFxuICAgIGJ1ZmZlci53cml0ZShGbXA0LnNpemUoc2l6ZSksIEZtcDQudHlwZShuYW1lKSwgLi4uY29udGVudCk7XFxuICAgIHJldHVybiBidWZmZXIuYnVmZmVyO1xcbiAgfVxcbiAgc3RhdGljIGV4dGVuc2lvbih2ZXJzaW9uLCBmbGFnKSB7XFxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShbdmVyc2lvbiwgZmxhZyA+PiAxNiAmIDB4ZmYsIGZsYWcgPj4gOCAmIDB4ZmYsIGZsYWcgJiAweGZmXSk7XFxuICB9XFxuICBzdGF0aWMgZnR5cCgpIHtcXG4gICAgcmV0dXJuIEZtcDQuaW5pdEJveCgyNCwgJ2Z0eXAnLCBuZXcgVWludDhBcnJheShbMHg2OSwgMHg3MywgMHg2RiwgMHg2RCwgLy8gaXNvbSxcXG4gICAgMHgwLCAweDAsIDB4MDAsIDB4MDEsIC8vIG1pbm9yX3ZlcnNpb246IDB4MDFcXG4gICAgMHg2OSwgMHg3MywgMHg2RiwgMHg2RCwgLy8gaXNvbVxcbiAgICAweDYxLCAweDc2LCAweDYzLCAweDMxIC8vIGF2YzFcXG4gICAgXSkpO1xcbiAgfVxcbiAgc3RhdGljIG1vb3YoeyB0eXBlLCBtZXRhIH0pIHtcXG4gICAgbGV0IHNpemUgPSA4O1xcbiAgICBsZXQgbXZoZCA9IEZtcDQubXZoZChtZXRhLmR1cmF0aW9uLCBtZXRhLnRpbWVzY2FsZSk7XFxuICAgIGxldCB0cmFrO1xcblxcbiAgICBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xcbiAgICAgIHRyYWsgPSBGbXA0LnZpZGVvVHJhayhtZXRhKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0cmFrID0gRm1wNC5hdWRpb1RyYWsobWV0YSk7XFxuICAgIH1cXG5cXG4gICAgbGV0IG12ZXggPSBGbXA0Lm12ZXgobWV0YS5kdXJhdGlvbiwgbWV0YS50aW1lc2NhbGUgfHwgMTAwMCwgbWV0YS5pZCk7XFxuICAgIFttdmhkLCB0cmFrLCBtdmV4XS5mb3JFYWNoKGl0ZW0gPT4ge1xcbiAgICAgIHNpemUgKz0gaXRlbS5ieXRlTGVuZ3RoO1xcbiAgICB9KTtcXG4gICAgcmV0dXJuIEZtcDQuaW5pdEJveChzaXplLCAnbW9vdicsIG12aGQsIHRyYWssIG12ZXgpO1xcbiAgfVxcbiAgc3RhdGljIG12aGQoZHVyYXRpb24sIHRpbWVzY2FsZSA9IDEwMDApIHtcXG4gICAgLy8gZHVyYXRpb24gKj0gdGltZXNjYWxlO1xcbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdmVyc2lvbigwKSArIGZsYWdzICAgICAx5L2N55qEYm9454mI5pysKzPkvY1mbGFncyAgIGJveOeJiOacrO+8jDDmiJYx77yM5LiA6Iis5Li6MOOAgu+8iOS7peS4i+Wtl+iKguaVsOWdh+aMiXZlcnNpb249MO+8iVxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBjcmVhdGlvbl90aW1lICAgIOWIm+W7uuaXtumXtCAg77yI55u45a+55LqOVVRD5pe26Ze0MTkwNC0wMS0wMembtueCueeahOenkuaVsO+8iVxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBtb2RpZmljYXRpb25fdGltZSAgIOS/ruaUueaXtumXtFxcblxcbiAgICAvKipcXG4gICAgICAgICAgICogdGltZXNjYWxlOiA0IGJ5dGVz5paH5Lu25aqS5L2T5ZyoMeenkuaXtumXtOWGheeahOWIu+W6puWAvO+8jOWPr+S7peeQhuino+S4ujHnp5Lplb/luqZcXG4gICAgICAgICAgICovXFxuICAgIHRpbWVzY2FsZSA+Pj4gMjQgJiAweEZGLCB0aW1lc2NhbGUgPj4+IDE2ICYgMHhGRiwgdGltZXNjYWxlID4+PiA4ICYgMHhGRiwgdGltZXNjYWxlICYgMHhGRixcXG5cXG4gICAgLyoqXFxuICAgICAgICAgICAqIGR1cmF0aW9uOiA0IGJ5dGVz6K+ldHJhY2vnmoTml7bpl7Tplb/luqbvvIznlKhkdXJhdGlvbuWSjHRpbWUgc2NhbGXlgLzlj6/ku6XorqHnrpd0cmFja+aXtumVv++8jOavlOWmgmF1ZGlvIHRyYWNr55qEdGltZSBzY2FsZSA9IDgwMDAsXFxuICAgICAgICAgICAqIGR1cmF0aW9uID0gNTYwMTI477yM5pe26ZW/5Li6NzAuMDE277yMdmlkZW8gdHJhY2vnmoR0aW1lIHNjYWxlID0gNjAwLCBkdXJhdGlvbiA9IDQyMDAw77yM5pe26ZW/5Li6NzBcXG4gICAgICAgICAgICovXFxuICAgIGR1cmF0aW9uID4+PiAyNCAmIDB4RkYsIGR1cmF0aW9uID4+PiAxNiAmIDB4RkYsIGR1cmF0aW9uID4+PiA4ICYgMHhGRiwgZHVyYXRpb24gJiAweEZGLCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAvLyBQcmVmZXJyZWQgcmF0ZTogMS4wICAg5o6o6I2Q5pKt5pS+6YCf546H77yM6auYMTbkvY3lkozkvY4xNuS9jeWIhuWIq+S4uuWwj+aVsOeCueaVtOaVsOmDqOWIhuWSjOWwj+aVsOmDqOWIhu+8jOWNs1sxNi4xNl0g5qC85byP77yM6K+l5YC85Li6MS4w77yIMHgwMDAxMDAwMO+8ieihqOekuuato+W4uOWJjeWQkeaSreaUvlxcbiAgICAvKipcXG4gICAgICAgICAgICogUHJlZmVycmVkVm9sdW1lKDEuMCwgMmJ5dGVzKSArIHJlc2VydmVkKDJieXRlcylcXG4gICAgICAgICAgICog5LiOcmF0Zeexu+S8vO+8jFs4LjhdIOagvOW8j++8jDEuMO+8iDB4MDEwMO+8ieihqOekuuacgOWkp+mfs+mHj1xcbiAgICAgICAgICAgKi9cXG4gICAgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gIHJlc2VydmVkOiA0ICsgNCBieXRlc+S/neeVmeS9jVxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAvLyAtLS0tYmVnaW4gY29tcG9zaXRpb24gbWF0cml4LS0tLVxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyDop4bpopHlj5jmjaLnn6npmLUgICDnur/mgKfku6PmlbBcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gLS0tLWVuZCBjb21wb3NpdGlvbiBtYXRyaXgtLS0tXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIC0tLS1iZWdpbiBwcmVfZGVmaW5lZCA2ICogNCBieXRlcy0tLS1cXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlLWRlZmluZWQg5L+d55WZ5L2NXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIC0tLS1lbmQgcHJlX2RlZmluZWQgNiAqIDQgYnl0ZXMtLS0tXFxuICAgIDB4RkYsIDB4RkYsIDB4RkYsIDB4RkYgLy8gbmV4dF90cmFja19JRCDkuIvkuIDkuKp0cmFja+S9v+eUqOeahGlk5Y+3XFxuICAgIF0pO1xcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KDggKyBieXRlcy5sZW5ndGgsICdtdmhkJywgbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcXG4gIH1cXG4gIHN0YXRpYyB2aWRlb1RyYWsoZGF0YSkge1xcbiAgICBsZXQgc2l6ZSA9IDg7XFxuXFxuICAgIGxldCB0a2hkID0gRm1wNC50a2hkKHtcXG4gICAgICBpZDogMSxcXG4gICAgICBkdXJhdGlvbjogZGF0YS5kdXJhdGlvbixcXG4gICAgICB0aW1lc2NhbGU6IGRhdGEudGltZXNjYWxlIHx8IDEwMDAsXFxuICAgICAgd2lkdGg6IGRhdGEucHJlc2VudFdpZHRoLFxcbiAgICAgIGhlaWdodDogZGF0YS5wcmVzZW50SGVpZ2h0LFxcbiAgICAgIHR5cGU6ICd2aWRlbydcXG4gICAgfSk7XFxuICAgIGxldCBtZGlhID0gRm1wNC5tZGlhKHtcXG4gICAgICB0eXBlOiAndmlkZW8nLFxcbiAgICAgIHRpbWVzY2FsZTogZGF0YS50aW1lc2NhbGUgfHwgMTAwMCxcXG4gICAgICBkdXJhdGlvbjogZGF0YS5kdXJhdGlvbixcXG4gICAgICBhdmNjOiBkYXRhLmF2Y2MsXFxuICAgICAgcGFyUmF0aW86IGRhdGEucGFyUmF0aW8sXFxuICAgICAgd2lkdGg6IGRhdGEucHJlc2VudFdpZHRoLFxcbiAgICAgIGhlaWdodDogZGF0YS5wcmVzZW50SGVpZ2h0XFxuICAgIH0pO1xcbiAgICBbdGtoZCwgbWRpYV0uZm9yRWFjaChpdGVtID0+IHtcXG4gICAgICBzaXplICs9IGl0ZW0uYnl0ZUxlbmd0aDtcXG4gICAgfSk7XFxuICAgIHJldHVybiBGbXA0LmluaXRCb3goc2l6ZSwgJ3RyYWsnLCB0a2hkLCBtZGlhKTtcXG4gIH1cXG4gIHN0YXRpYyBhdWRpb1RyYWsoZGF0YSkge1xcbiAgICBsZXQgc2l6ZSA9IDg7XFxuICAgIGxldCB0a2hkID0gRm1wNC50a2hkKHtcXG4gICAgICBpZDogMixcXG4gICAgICBkdXJhdGlvbjogZGF0YS5kdXJhdGlvbixcXG4gICAgICB0aW1lc2NhbGU6IGRhdGEudGltZXNjYWxlIHx8IDEwMDAsXFxuICAgICAgd2lkdGg6IDAsXFxuICAgICAgaGVpZ2h0OiAwLFxcbiAgICAgIHR5cGU6ICdhdWRpbydcXG4gICAgfSk7XFxuICAgIGxldCBtZGlhID0gRm1wNC5tZGlhKHtcXG4gICAgICB0eXBlOiAnYXVkaW8nLFxcbiAgICAgIHRpbWVzY2FsZTogZGF0YS50aW1lc2NhbGUgfHwgMTAwMCxcXG4gICAgICBkdXJhdGlvbjogZGF0YS5kdXJhdGlvbixcXG4gICAgICBjaGFubmVsQ291bnQ6IGRhdGEuY2hhbm5lbENvdW50LFxcbiAgICAgIHNhbXBsZXJhdGU6IGRhdGEuc2FtcGxlUmF0ZSxcXG4gICAgICBjb25maWc6IGRhdGEuY29uZmlnXFxuICAgIH0pO1xcbiAgICBbdGtoZCwgbWRpYV0uZm9yRWFjaChpdGVtID0+IHtcXG4gICAgICBzaXplICs9IGl0ZW0uYnl0ZUxlbmd0aDtcXG4gICAgfSk7XFxuICAgIHJldHVybiBGbXA0LmluaXRCb3goc2l6ZSwgJ3RyYWsnLCB0a2hkLCBtZGlhKTtcXG4gIH1cXG4gIHN0YXRpYyB0a2hkKGRhdGEpIHtcXG4gICAgbGV0IGlkID0gZGF0YS5pZDtcXG4gICAgbGV0IGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcXG4gICAgbGV0IHdpZHRoID0gZGF0YS53aWR0aDtcXG4gICAgbGV0IGhlaWdodCA9IGRhdGEuaGVpZ2h0O1xcbiAgICBsZXQgY29udGVudCA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLCAweDA3LCAvLyB2ZXJzaW9uKDApICsgZmxhZ3MgMeS9jeeJiOacrCBib3jniYjmnKzvvIww5oiWMe+8jOS4gOiIrOS4ujDjgILvvIjku6XkuIvlrZfoioLmlbDlnYfmjIl2ZXJzaW9uPTDvvInmjInkvY3miJbmk43kvZznu5PmnpzlgLzvvIzpooTlrprkuYnlpoLkuIvvvJpcXG4gICAgLy8gMHgwMDAwMDEgdHJhY2tfZW5hYmxlZO+8jOWQpuWImeivpXRyYWNr5LiN6KKr5pKt5pS+77ybXFxuICAgIC8vIDB4MDAwMDAyIHRyYWNrX2luX21vdmll77yM6KGo56S66K+ldHJhY2vlnKjmkq3mlL7kuK3ooqvlvJXnlKjvvJtcXG4gICAgLy8gMHgwMDAwMDQgdHJhY2tfaW5fcHJldmlld++8jOihqOekuuivpXRyYWNr5Zyo6aKE6KeI5pe26KKr5byV55So44CCXFxuICAgIC8vIOS4gOiIrOivpeWAvOS4ujfvvIwxKzIrNCDlpoLmnpzkuIDkuKrlqpLkvZPmiYDmnIl0cmFja+Wdh+acquiuvue9rnRyYWNrX2luX21vdmll5ZKMdHJhY2tfaW5fcHJldmlld++8jOWwhuiiq+eQhuino+S4uuaJgOaciXRyYWNr5Z2H6K6+572u5LqG6L+Z5Lik6aG577yb5a+55LqOaGludCB0cmFja++8jOivpeWAvOS4ujBcXG4gICAgLy8gaGludCB0cmFjayDov5nkuKrnibnmrornmoR0cmFja+W5tuS4jeWMheWQq+WqkuS9k+aVsOaNru+8jOiAjOaYr+WMheWQq+S6huS4gOS6m+WwhuWFtuS7luaVsOaNrnRyYWNr5omT5YyF5oiQ5rWB5aqS5L2T55qE5oyH56S65L+h5oGv44CCXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGNyZWF0aW9uX3RpbWXliJvlu7rml7bpl7TvvIjnm7jlr7nkuo5VVEPml7bpl7QxOTA0LTAxLTAx6Zu254K555qE56eS5pWw77yJXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIG1vZGlmaWNhdGlvbiB0aW1lIOS/ruaUueaXtumXtFxcbiAgICBpZCA+Pj4gMjQgJiAweEZGLCAvLyB0cmFja19JRDogNCBieXRlcyBpZOWPt++8jOS4jeiDvemHjeWkjeS4lOS4jeiDveS4ujBcXG4gICAgaWQgPj4+IDE2ICYgMHhGRiwgaWQgPj4+IDggJiAweEZGLCBpZCAmIDB4RkYsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkOiA0IGJ5dGVzICAgIOS/neeVmeS9jVxcbiAgICBkdXJhdGlvbiA+Pj4gMjQgJiAweEZGLCAvLyBkdXJhdGlvbjogNCBieXRlcyB0cmFja+eahOaXtumXtOmVv+W6plxcbiAgICBkdXJhdGlvbiA+Pj4gMTYgJiAweEZGLCBkdXJhdGlvbiA+Pj4gOCAmIDB4RkYsIGR1cmF0aW9uICYgMHhGRiwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWQ6IDIgKiA0IGJ5dGVzICAgIOS/neeVmeS9jVxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBsYXllcigyYnl0ZXMpICsgYWx0ZXJuYXRlX2dyb3VwKDJieXRlcykgIOinhumikeWxgu+8jOm7mOiupOS4ujDvvIzlgLzlsI/nmoTlnKjkuIrlsYIudHJhY2vliIbnu4Tkv6Hmga/vvIzpu5jorqTkuLow6KGo56S66K+ldHJhY2vmnKrkuI7lhbbku5Z0cmFja+aciee+pOe7hOWFs+ezu1xcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyB2b2x1bWUoMmJ5dGVzKSArIHJlc2VydmVkKDJieXRlcykgICAgWzguOF0g5qC85byP77yM5aaC5p6c5Li66Z+z6aKRdHJhY2vvvIwxLjDvvIgweDAxMDDvvInooajnpLrmnIDlpKfpn7Pph4/vvJvlkKbliJnkuLowICAgK+S/neeVmeS9jVxcbiAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAvLyAtLS0tYmVnaW4gY29tcG9zaXRpb24gbWF0cml4LS0tLVxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAvLyDop4bpopHlj5jmjaLnn6npmLVcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gLS0tLWVuZCBjb21wb3NpdGlvbiBtYXRyaXgtLS0tXFxuICAgIHdpZHRoID4+PiA4ICYgMHhGRiwgLy8gLy/lrr3luqZcXG4gICAgd2lkdGggJiAweEZGLCAweDAwLCAweDAwLCBoZWlnaHQgPj4+IDggJiAweEZGLCAvLyDpq5jluqZcXG4gICAgaGVpZ2h0ICYgMHhGRiwgMHgwMCwgMHgwMF0pO1xcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KDggKyBjb250ZW50LmJ5dGVMZW5ndGgsICd0a2hkJywgY29udGVudCk7XFxuICB9XFxuICBzdGF0aWMgZWR0cyhkYXRhKSB7XFxuICAgIGxldCBidWZmZXIgPSBuZXcgX3hncGxheWVyVXRpbHMuQnVmZmVyKCk7XFxuICAgIGxldCBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XFxuICAgIGxldCBtZWRpYVRpbWUgPSBkYXRhLm1lZGlhVGltZTtcXG4gICAgYnVmZmVyLndyaXRlKEZtcDQuc2l6ZSgzNiksIEZtcDQudHlwZSgnZWR0cycpKTtcXG4gICAgLy8gZWxzdFxcbiAgICBidWZmZXIud3JpdGUoRm1wNC5zaXplKDI4KSwgRm1wNC50eXBlKCdlbHN0JykpO1xcbiAgICBidWZmZXIud3JpdGUobmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGVudHJ5IGNvdW50XFxuICAgIGR1cmF0aW9uID4+IDI0ICYgMHhmZiwgZHVyYXRpb24gPj4gMTYgJiAweGZmLCBkdXJhdGlvbiA+PiA4ICYgMHhmZiwgZHVyYXRpb24gJiAweGZmLCBtZWRpYVRpbWUgPj4gMjQgJiAweGZmLCBtZWRpYVRpbWUgPj4gMTYgJiAweGZmLCBtZWRpYVRpbWUgPj4gOCAmIDB4ZmYsIG1lZGlhVGltZSAmIDB4ZmYsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEgLy8gbWVkaWEgcmF0ZVxcbiAgICBdKSk7XFxuICAgIHJldHVybiBidWZmZXIuYnVmZmVyO1xcbiAgfVxcbiAgc3RhdGljIG1kaWEoZGF0YSkge1xcbiAgICBsZXQgc2l6ZSA9IDg7XFxuICAgIGxldCBtZGhkID0gRm1wNC5tZGhkKGRhdGEudGltZXNjYWxlLCBkYXRhLmR1cmF0aW9uKTtcXG4gICAgbGV0IGhkbHIgPSBGbXA0LmhkbHIoZGF0YS50eXBlKTtcXG4gICAgbGV0IG1pbmYgPSBGbXA0Lm1pbmYoZGF0YSk7XFxuICAgIFttZGhkLCBoZGxyLCBtaW5mXS5mb3JFYWNoKGl0ZW0gPT4ge1xcbiAgICAgIHNpemUgKz0gaXRlbS5ieXRlTGVuZ3RoO1xcbiAgICB9KTtcXG4gICAgcmV0dXJuIEZtcDQuaW5pdEJveChzaXplLCAnbWRpYScsIG1kaGQsIGhkbHIsIG1pbmYpO1xcbiAgfVxcbiAgc3RhdGljIG1kaGQodGltZXNjYWxlID0gMTAwMCwgZHVyYXRpb24pIHtcXG4gICAgbGV0IGNvbnRlbnQgPSBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gY3JlYXRpb25fdGltZSAgICDliJvlu7rml7bpl7RcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gbW9kaWZpY2F0aW9uX3RpbWXkv67mlLnml7bpl7RcXG4gICAgdGltZXNjYWxlID4+PiAyNCAmIDB4RkYsIC8vIHRpbWVzY2FsZTogNCBieXRlcyAgICDmlofku7blqpLkvZPlnKgx56eS5pe26Ze05YaF55qE5Yi75bqm5YC877yM5Y+v5Lul55CG6Kej5Li6MeenkumVv+W6plxcbiAgICB0aW1lc2NhbGUgPj4+IDE2ICYgMHhGRiwgdGltZXNjYWxlID4+PiA4ICYgMHhGRiwgdGltZXNjYWxlICYgMHhGRiwgZHVyYXRpb24gPj4+IDI0ICYgMHhGRiwgLy8gZHVyYXRpb246IDQgYnl0ZXMgIHRyYWNr55qE5pe26Ze06ZW/5bqmXFxuICAgIGR1cmF0aW9uID4+PiAxNiAmIDB4RkYsIGR1cmF0aW9uID4+PiA4ICYgMHhGRiwgZHVyYXRpb24gJiAweEZGLCAweDU1LCAweEM0LCAvLyBsYW5ndWFnZTogdW5kICh1bmRldGVybWluZWQpIOWqkuS9k+ivreiogOeggeOAguacgOmrmOS9jeS4ujDvvIzlkI7pnaIxNeS9jeS4ujPkuKrlrZfnrKbvvIjop4FJU08gNjM5LTIvVOagh+WHhuS4reWumuS5ie+8iVxcbiAgICAweDAwLCAweDAwIC8vIHByZV9kZWZpbmVkID0gMFxcbiAgICBdKTtcXG4gICAgcmV0dXJuIEZtcDQuaW5pdEJveCgxMiArIGNvbnRlbnQuYnl0ZUxlbmd0aCwgJ21kaGQnLCBGbXA0LmV4dGVuc2lvbigwLCAwKSwgY29udGVudCk7XFxuICB9XFxuICBzdGF0aWMgaGRscih0eXBlKSB7XFxuICAgIGxldCB2YWx1ZSA9IFsweDAwLCAvLyB2ZXJzaW9uIDBcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcXG4gICAgMHg3NiwgMHg2OSwgMHg2NCwgMHg2NSwgLy8gaGFuZGxlcl90eXBlOiAndmlkZSdcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcXG4gICAgMHg1NiwgMHg2OSwgMHg2NCwgMHg2NSwgMHg2ZiwgMHg0OCwgMHg2MSwgMHg2ZSwgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnVmlkZW9IYW5kbGVyJ1xcbiAgICBdO1xcbiAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJykge1xcbiAgICAgIHZhbHVlLnNwbGljZSg4LCA0LCAuLi5bMHg3MywgMHg2ZiwgMHg3NSwgMHg2ZV0pO1xcbiAgICAgIHZhbHVlLnNwbGljZSgyNCwgMTMsIC4uLlsweDUzLCAweDZmLCAweDc1LCAweDZlLCAweDY0LCAweDQ4LCAweDYxLCAweDZlLCAweDY0LCAweDZjLCAweDY1LCAweDcyLCAweDAwXSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIEZtcDQuaW5pdEJveCg4ICsgdmFsdWUubGVuZ3RoLCAnaGRscicsIG5ldyBVaW50OEFycmF5KHZhbHVlKSk7XFxuICB9XFxuICBzdGF0aWMgbWluZihkYXRhKSB7XFxuICAgIGxldCBzaXplID0gODtcXG4gICAgbGV0IHZtaGQgPSBkYXRhLnR5cGUgPT09ICd2aWRlbycgPyBGbXA0LnZtaGQoKSA6IEZtcDQuc21oZCgpO1xcbiAgICBsZXQgZGluZiA9IEZtcDQuZGluZigpO1xcbiAgICBsZXQgc3RibCA9IEZtcDQuc3RibChkYXRhKTtcXG4gICAgW3ZtaGQsIGRpbmYsIHN0YmxdLmZvckVhY2goaXRlbSA9PiB7XFxuICAgICAgc2l6ZSArPSBpdGVtLmJ5dGVMZW5ndGg7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KHNpemUsICdtaW5mJywgdm1oZCwgZGluZiwgc3RibCk7XFxuICB9XFxuICBzdGF0aWMgdm1oZCgpIHtcXG4gICAgcmV0dXJuIEZtcDQuaW5pdEJveCgyMCwgJ3ZtaGQnLCBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvblxcbiAgICAweDAwLCAweDAwLCAweDAxLCAvLyBmbGFnc1xcbiAgICAweDAwLCAweDAwLCAvLyBncmFwaGljc21vZGVcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBvcGNvbG9yXFxuICAgIF0pKTtcXG4gIH1cXG4gIHN0YXRpYyBzbWhkKCkge1xcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KDE2LCAnc21oZCcsIG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXFxuICAgIDB4MDAsIDB4MDAsIC8vIGJhbGFuY2VcXG4gICAgMHgwMCwgMHgwMCAvLyByZXNlcnZlZFxcbiAgICBdKSk7XFxuICB9XFxuICBzdGF0aWMgZGluZigpIHtcXG4gICAgbGV0IGJ1ZmZlciA9IG5ldyBfeGdwbGF5ZXJVdGlscy5CdWZmZXIoKTtcXG4gICAgbGV0IGRyZWYgPSBbMHgwMCwgLy8gdmVyc2lvbiAwXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGVudHJ5X2NvdW50XFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MGMsIC8vIGVudHJ5X3NpemVcXG4gICAgMHg3NSwgMHg3MiwgMHg2YywgMHgyMCwgLy8gJ3VybCcgdHlwZVxcbiAgICAweDAwLCAvLyB2ZXJzaW9uIDBcXG4gICAgMHgwMCwgMHgwMCwgMHgwMSAvLyBlbnRyeV9mbGFnc1xcbiAgICBdO1xcbiAgICBidWZmZXIud3JpdGUoRm1wNC5zaXplKDM2KSwgRm1wNC50eXBlKCdkaW5mJyksIEZtcDQuc2l6ZSgyOCksIEZtcDQudHlwZSgnZHJlZicpLCBuZXcgVWludDhBcnJheShkcmVmKSk7XFxuICAgIHJldHVybiBidWZmZXIuYnVmZmVyO1xcbiAgfVxcbiAgc3RhdGljIHN0YmwoZGF0YSkge1xcbiAgICBsZXQgc2l6ZSA9IDg7XFxuICAgIGxldCBzdHNkID0gRm1wNC5zdHNkKGRhdGEpO1xcbiAgICBsZXQgc3R0cyA9IEZtcDQuc3R0cygpO1xcbiAgICBsZXQgc3RzYyA9IEZtcDQuc3RzYygpO1xcbiAgICBsZXQgc3RzeiA9IEZtcDQuc3RzeigpO1xcbiAgICBsZXQgc3RjbyA9IEZtcDQuc3RjbygpO1xcbiAgICBbc3RzZCwgc3R0cywgc3RzYywgc3Rzeiwgc3Rjb10uZm9yRWFjaChpdGVtID0+IHtcXG4gICAgICBzaXplICs9IGl0ZW0uYnl0ZUxlbmd0aDtcXG4gICAgfSk7XFxuICAgIHJldHVybiBGbXA0LmluaXRCb3goc2l6ZSwgJ3N0YmwnLCBzdHNkLCBzdHRzLCBzdHNjLCBzdHN6LCBzdGNvKTtcXG4gIH1cXG4gIHN0YXRpYyBzdHNkKGRhdGEpIHtcXG4gICAgbGV0IGNvbnRlbnQ7XFxuICAgIGlmIChkYXRhLnR5cGUgPT09ICdhdWRpbycpIHtcXG4gICAgICAvLyBpZiAoIWRhdGEuaXNBQUMgJiYgZGF0YS5jb2RlYyA9PT0gJ21wNCcpIHtcXG4gICAgICAvLyAgICAgY29udGVudCA9IEZNUDQubXAzKGRhdGEpO1xcbiAgICAgIC8vIH0gZWxzZSB7XFxuICAgICAgLy9cXG4gICAgICAvLyB9XFxuICAgICAgLy8g5pSv5oyBbXA0YVxcbiAgICAgIGNvbnRlbnQgPSBGbXA0Lm1wNGEoZGF0YSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY29udGVudCA9IEZtcDQuYXZjMShkYXRhKTtcXG4gICAgfVxcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KDE2ICsgY29udGVudC5ieXRlTGVuZ3RoLCAnc3RzZCcsIEZtcDQuZXh0ZW5zaW9uKDAsIDApLCBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMV0pLCBjb250ZW50KTtcXG4gIH1cXG4gIHN0YXRpYyBtcDRhKGRhdGEpIHtcXG4gICAgbGV0IGNvbnRlbnQgPSBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcXG4gICAgMHgwMCwgMHgwMSwgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcXG4gICAgMHgwMCwgZGF0YS5jaGFubmVsQ291bnQsIC8vIGNoYW5uZWxjb3VudFxcbiAgICAweDAwLCAweDEwLCAvLyBzYW1wbGVTaXplOjE2Yml0c1xcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZDJcXG4gICAgZGF0YS5zYW1wbGVyYXRlID4+IDggJiAweGZmLCBkYXRhLnNhbXBsZXJhdGUgJiAweGZmLCAvL1xcbiAgICAweDAwLCAweDAwXSk7XFxuICAgIGxldCBlc2RzID0gRm1wNC5lc2RzKGRhdGEuY29uZmlnKTtcXG4gICAgcmV0dXJuIEZtcDQuaW5pdEJveCg4ICsgY29udGVudC5ieXRlTGVuZ3RoICsgZXNkcy5ieXRlTGVuZ3RoLCAnbXA0YScsIGNvbnRlbnQsIGVzZHMpO1xcbiAgfVxcbiAgc3RhdGljIGVzZHMoY29uZmlnID0gWzQzLCAxNDYsIDgsIDBdKSB7XFxuICAgIGNvbnN0IGNvbmZpZ2xlbiA9IGNvbmZpZy5sZW5ndGg7XFxuICAgIGxldCBidWZmZXIgPSBuZXcgX3hncGxheWVyVXRpbHMuQnVmZmVyKCk7XFxuICAgIGxldCBjb250ZW50ID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb24gMFxcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xcblxcbiAgICAweDAzLCAvLyBkZXNjcmlwdG9yX3R5cGVcXG4gICAgMHgxNyArIGNvbmZpZ2xlbiwgLy8gbGVuZ3RoXFxuICAgIDB4MDAsIDB4MDEsIC8vIGVzX2lkXFxuICAgIDB4MDAsIC8vIHN0cmVhbV9wcmlvcml0eVxcblxcbiAgICAweDA0LCAvLyBkZXNjcmlwdG9yX3R5cGVcXG4gICAgMHgwZiArIGNvbmZpZ2xlbiwgLy8gbGVuZ3RoXFxuICAgIDB4NDAsIC8vIGNvZGVjIDogbXBlZzRfYXVkaW9cXG4gICAgMHgxNSwgLy8gc3RyZWFtX3R5cGVcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gYnVmZmVyX3NpemVcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gbWF4Qml0cmF0ZVxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBhdmdCaXRyYXRlXFxuXFxuICAgIDB4MDUgLy8gZGVzY3JpcHRvcl90eXBlXFxuICAgIF0uY29uY2F0KFtjb25maWdsZW5dKS5jb25jYXQoY29uZmlnKS5jb25jYXQoWzB4MDYsIDB4MDEsIDB4MDJdKSk7XFxuICAgIGJ1ZmZlci53cml0ZShGbXA0LnNpemUoOCArIGNvbnRlbnQuYnl0ZUxlbmd0aCksIEZtcDQudHlwZSgnZXNkcycpLCBjb250ZW50KTtcXG4gICAgcmV0dXJuIGJ1ZmZlci5idWZmZXI7XFxuICB9XFxuICBzdGF0aWMgYXZjMShkYXRhKSB7XFxuICAgIGxldCBidWZmZXIgPSBuZXcgX3hncGxheWVyVXRpbHMuQnVmZmVyKCk7XFxuICAgIGxldCBzaXplID0gNDA7IC8vIDgoYXZjMSkrOChhdmNjKSs4KGJ0cnQpKzE2KHBhc3ApXFxuICAgIC8vIGxldCBzcHMgPSBkYXRhLnNwc1xcbiAgICAvLyBsZXQgcHBzID0gZGF0YS5wcHNcXG4gICAgbGV0IHdpZHRoID0gZGF0YS53aWR0aDtcXG4gICAgbGV0IGhlaWdodCA9IGRhdGEuaGVpZ2h0O1xcbiAgICBsZXQgaFNwYWNpbmcgPSBkYXRhLnBhclJhdGlvLmhlaWdodDtcXG4gICAgbGV0IHZTcGFjaW5nID0gZGF0YS5wYXJSYXRpby53aWR0aDtcXG4gICAgLy8gbGV0IGF2Y2NCdWZmZXIgPSBuZXcgQnVmZmVyKClcXG4gICAgLy8gYXZjY0J1ZmZlci53cml0ZShuZXcgVWludDhBcnJheShbXFxuICAgIC8vICAgMHgwMSwgLy8gdmVyc2lvblxcbiAgICAvLyAgIHNwc1sxXSwgLy8gcHJvZmlsZVxcbiAgICAvLyAgIHNwc1syXSwgLy8gcHJvZmlsZSBjb21wYXRpYmxlXFxuICAgIC8vICAgc3BzWzNdLCAvLyBsZXZlbFxcbiAgICAvLyAgIDB4ZmMgfCAzLFxcbiAgICAvLyAgIDB4RTAgfCAxIC8vIOebruWJjeWPquWkhOeQhuS4gOS4qnNwc1xcbiAgICAvLyBdLmNvbmNhdChbc3BzLmxlbmd0aCA+Pj4gOCAmIDB4ZmYsIHNwcy5sZW5ndGggJiAweGZmXSkpKVxcbiAgICAvLyBhdmNjQnVmZmVyLndyaXRlKHNwcywgbmV3IFVpbnQ4QXJyYXkoWzEsIHBwcy5sZW5ndGggPj4+IDggJiAweGZmLCBwcHMubGVuZ3RoICYgMHhmZl0pLCBwcHMpXFxuXFxuICAgIGxldCBhdmNjID0gZGF0YS5hdmNjO1xcbiAgICBsZXQgYXZjMSA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxcbiAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxcbiAgICAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxcbiAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxcbiAgICB3aWR0aCA+PiA4ICYgMHhmZiwgd2lkdGggJiAweGZmLCAvLyB3aWR0aFxcbiAgICBoZWlnaHQgPj4gOCAmIDB4ZmYsIGhlaWdodCAmIDB4ZmYsIC8vIGhlaWdodFxcbiAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLCAvLyBob3JpenJlc29sdXRpb25cXG4gICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCwgLy8gdmVydHJlc29sdXRpb25cXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcXG4gICAgMHgwMCwgMHgwMSwgLy8gZnJhbWVfY291bnRcXG4gICAgMHgxMiwgMHg2NCwgMHg2MSwgMHg2OSwgMHg2QywgLy8gZGFpbHltb3Rpb24vaGxzLmpzXFxuICAgIDB4NzksIDB4NkQsIDB4NkYsIDB4NzQsIDB4NjksIDB4NkYsIDB4NkUsIDB4MkYsIDB4NjgsIDB4NkMsIDB4NzMsIDB4MkUsIDB4NkEsIDB4NzMsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGNvbXByZXNzb3JuYW1lXFxuICAgIDB4MDAsIDB4MTgsIC8vIGRlcHRoID0gMjRcXG4gICAgMHgxMSwgMHgxMV0pOyAvLyBwcmVfZGVmaW5lZCA9IC0xXFxuICAgIGxldCBidHJ0ID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MWMsIDB4OWMsIDB4ODAsIC8vIGJ1ZmZlclNpemVEQlxcbiAgICAweDAwLCAweDJkLCAweGM2LCAweGMwLCAvLyBtYXhCaXRyYXRlXFxuICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzAgLy8gYXZnQml0cmF0ZVxcbiAgICBdKTtcXG4gICAgbGV0IHBhc3AgPSBuZXcgVWludDhBcnJheShbaFNwYWNpbmcgPj4gMjQsIC8vIGhTcGFjaW5nXFxuICAgIGhTcGFjaW5nID4+IDE2ICYgMHhmZiwgaFNwYWNpbmcgPj4gOCAmIDB4ZmYsIGhTcGFjaW5nICYgMHhmZiwgdlNwYWNpbmcgPj4gMjQsIC8vIHZTcGFjaW5nXFxuICAgIHZTcGFjaW5nID4+IDE2ICYgMHhmZiwgdlNwYWNpbmcgPj4gOCAmIDB4ZmYsIHZTcGFjaW5nICYgMHhmZl0pO1xcblxcbiAgICBidWZmZXIud3JpdGUoRm1wNC5zaXplKHNpemUgKyBhdmMxLmJ5dGVMZW5ndGggKyBhdmNjLmJ5dGVMZW5ndGggKyBidHJ0LmJ5dGVMZW5ndGgpLCBGbXA0LnR5cGUoJ2F2YzEnKSwgYXZjMSwgRm1wNC5zaXplKDggKyBhdmNjLmJ5dGVMZW5ndGgpLCBGbXA0LnR5cGUoJ2F2Y0MnKSwgYXZjYywgRm1wNC5zaXplKDIwKSwgRm1wNC50eXBlKCdidHJ0JyksIGJ0cnQsIEZtcDQuc2l6ZSgxNiksIEZtcDQudHlwZSgncGFzcCcpLCBwYXNwKTtcXG4gICAgcmV0dXJuIGJ1ZmZlci5idWZmZXI7XFxuICB9XFxuICBzdGF0aWMgc3R0cygpIHtcXG4gICAgbGV0IGNvbnRlbnQgPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvblxcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIGVudHJ5X2NvdW50XFxuICAgIF0pO1xcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KDE2LCAnc3R0cycsIGNvbnRlbnQpO1xcbiAgfVxcbiAgc3RhdGljIHN0c2MoKSB7XFxuICAgIGxldCBjb250ZW50ID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb25cXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBlbnRyeV9jb3VudFxcbiAgICBdKTtcXG4gICAgcmV0dXJuIEZtcDQuaW5pdEJveCgxNiwgJ3N0c2MnLCBjb250ZW50KTtcXG4gIH1cXG4gIHN0YXRpYyBzdGNvKCkge1xcbiAgICBsZXQgY29udGVudCA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gZW50cnlfY291bnRcXG4gICAgXSk7XFxuICAgIHJldHVybiBGbXA0LmluaXRCb3goMTYsICdzdGNvJywgY29udGVudCk7XFxuICB9XFxuICBzdGF0aWMgc3RzeigpIHtcXG4gICAgbGV0IGNvbnRlbnQgPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvblxcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBzYW1wbGVfc2l6ZVxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIHNhbXBsZV9jb3VudFxcbiAgICBdKTtcXG4gICAgcmV0dXJuIEZtcDQuaW5pdEJveCgyMCwgJ3N0c3onLCBjb250ZW50KTtcXG4gIH1cXG4gIHN0YXRpYyBtdmV4KGR1cmF0aW9uLCB0aW1lc2NhbGUgPSAxMDAwLCB0cmFja0lEKSB7XFxuICAgIGxldCBidWZmZXIgPSBuZXcgX3hncGxheWVyVXRpbHMuQnVmZmVyKCk7XFxuICAgIGxldCBtZWhkID0gX3hncGxheWVyVXRpbHMuQnVmZmVyLndyaXRlVWludDMyKGR1cmF0aW9uKTtcXG4gICAgYnVmZmVyLndyaXRlKEZtcDQuc2l6ZSg1NiksIEZtcDQudHlwZSgnbXZleCcpLCBGbXA0LnNpemUoMTYpLCBGbXA0LnR5cGUoJ21laGQnKSwgRm1wNC5leHRlbnNpb24oMCwgMCksIG1laGQsIEZtcDQudHJleCh0cmFja0lEKSk7XFxuICAgIHJldHVybiBidWZmZXIuYnVmZmVyO1xcbiAgfVxcbiAgc3RhdGljIHRyZXgoaWQpIHtcXG4gICAgbGV0IGNvbnRlbnQgPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvbiAwXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXFxuICAgIGlkID4+IDI0LCBpZCA+PiAxNiAmIDB4ZmYsIGlkID4+IDggJiAweGZmLCBpZCAmIDB4ZmYsIC8vIHRyYWNrX0lEXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4XFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX3NpemVcXG4gICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMSAvLyBkZWZhdWx0X3NhbXBsZV9mbGFnc1xcbiAgICBdKTtcXG4gICAgcmV0dXJuIEZtcDQuaW5pdEJveCg4ICsgY29udGVudC5ieXRlTGVuZ3RoLCAndHJleCcsIGNvbnRlbnQpO1xcbiAgfVxcbiAgc3RhdGljIG1vb2YoZGF0YSkge1xcbiAgICBsZXQgc2l6ZSA9IDg7XFxuICAgIGxldCBtZmhkID0gRm1wNC5tZmhkKCk7XFxuICAgIGxldCB0cmFmID0gRm1wNC50cmFmKGRhdGEpO1xcbiAgICBbbWZoZCwgdHJhZl0uZm9yRWFjaChpdGVtID0+IHtcXG4gICAgICBzaXplICs9IGl0ZW0uYnl0ZUxlbmd0aDtcXG4gICAgfSk7XFxuICAgIHJldHVybiBGbXA0LmluaXRCb3goc2l6ZSwgJ21vb2YnLCBtZmhkLCB0cmFmKTtcXG4gIH1cXG4gIHN0YXRpYyBtZmhkKCkge1xcbiAgICBsZXQgY29udGVudCA9IF94Z3BsYXllclV0aWxzLkJ1ZmZlci53cml0ZVVpbnQzMihGbXA0LnNlcXVlbmNlKTtcXG4gICAgRm1wNC5zZXF1ZW5jZSArPSAxO1xcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KDE2LCAnbWZoZCcsIEZtcDQuZXh0ZW5zaW9uKDAsIDApLCBjb250ZW50KTtcXG4gIH1cXG4gIHN0YXRpYyB0cmFmKGRhdGEpIHtcXG4gICAgbGV0IHNpemUgPSA4O1xcbiAgICBsZXQgdGZoZCA9IEZtcDQudGZoZChkYXRhLmlkKTtcXG4gICAgbGV0IHRmZHQgPSBGbXA0LnRmZHQoZGF0YS50aW1lKTtcXG4gICAgbGV0IHNkdHAgPSBGbXA0LnNkdHAoZGF0YSk7XFxuICAgIGxldCB0cnVuID0gRm1wNC50cnVuKGRhdGEsIHNkdHAuYnl0ZUxlbmd0aCk7XFxuXFxuICAgIFt0ZmhkLCB0ZmR0LCB0cnVuLCBzZHRwXS5mb3JFYWNoKGl0ZW0gPT4ge1xcbiAgICAgIHNpemUgKz0gaXRlbS5ieXRlTGVuZ3RoO1xcbiAgICB9KTtcXG4gICAgcmV0dXJuIEZtcDQuaW5pdEJveChzaXplLCAndHJhZicsIHRmaGQsIHRmZHQsIHRydW4sIHNkdHApO1xcbiAgfVxcbiAgc3RhdGljIHRmaGQoaWQpIHtcXG4gICAgbGV0IGNvbnRlbnQgPSBfeGdwbGF5ZXJVdGlscy5CdWZmZXIud3JpdGVVaW50MzIoaWQpO1xcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KDE2LCAndGZoZCcsIEZtcDQuZXh0ZW5zaW9uKDAsIDApLCBjb250ZW50KTtcXG4gIH1cXG4gIHN0YXRpYyB0ZmR0KHRpbWUpIHtcXG4gICAgLy8gbGV0IHVwcGVyID0gTWF0aC5mbG9vcih0aW1lIC8gKFVJTlQzMl9NQVggKyAxKSksXFxuICAgIC8vICAgICBsb3dlciA9IE1hdGguZmxvb3IodGltZSAlIChVSU5UMzJfTUFYICsgMSkpO1xcbiAgICByZXR1cm4gRm1wNC5pbml0Qm94KDE2LCAndGZkdCcsIEZtcDQuZXh0ZW5zaW9uKDAsIDApLCBfeGdwbGF5ZXJVdGlscy5CdWZmZXIud3JpdGVVaW50MzIodGltZSkpO1xcbiAgfVxcbiAgc3RhdGljIHRydW4oZGF0YSwgc2R0cExlbmd0aCkge1xcbiAgICAvLyBsZXQgaWQgPSBkYXRhLmlkO1xcbiAgICAvLyBsZXQgY2VpbCA9IGlkID09PSAxID8gMTYgOiAxMjtcXG4gICAgbGV0IGJ1ZmZlciA9IG5ldyBfeGdwbGF5ZXJVdGlscy5CdWZmZXIoKTtcXG4gICAgbGV0IHNhbXBsZUNvdW50ID0gX3hncGxheWVyVXRpbHMuQnVmZmVyLndyaXRlVWludDMyKGRhdGEuc2FtcGxlcy5sZW5ndGgpO1xcbiAgICAvLyBtZGF0LWhlYWRlciA4XFxuICAgIC8vIG1vb2YtaGVhZGVyIDhcXG4gICAgLy8gbWZoZCAxNlxcbiAgICAvLyB0cmFmLWhlYWRlciA4XFxuICAgIC8vIHRoaGQgMTZcXG4gICAgLy8gdGZkdCAyMFxcbiAgICAvLyB0cnVuLWhlYWRlciAxMlxcbiAgICAvLyBzYW1wbGVDb3VudCA0XFxuICAgIC8vIGRhdGEtb2Zmc2V0IDRcXG4gICAgLy8gc2FtcGxlcy5sZW5ndGhcXG4gICAgbGV0IG9mZnNldCA9IF94Z3BsYXllclV0aWxzLkJ1ZmZlci53cml0ZVVpbnQzMig4ICsgOCArIDE2ICsgOCArIDE2ICsgMTYgKyAxMiArIDQgKyA0ICsgMTYgKiBkYXRhLnNhbXBsZXMubGVuZ3RoICsgc2R0cExlbmd0aCk7XFxuICAgIGJ1ZmZlci53cml0ZShGbXA0LnNpemUoMjAgKyAxNiAqIGRhdGEuc2FtcGxlcy5sZW5ndGgpLCBGbXA0LnR5cGUoJ3RydW4nKSwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MEYsIDB4MDFdKSwgc2FtcGxlQ291bnQsIG9mZnNldCk7XFxuXFxuICAgIC8vIGxldCBzaXplID0gYnVmZmVyLmJ1ZmZlci5ieXRlTGVuZ3RoXFxuICAgIC8vIGxldCB3cml0ZU9mZnNldCA9IDBcXG4gICAgLy8gZGF0YS5zYW1wbGVzLmZvckVhY2goKCkgPT4ge1xcbiAgICAvLyAgIHNpemUgKz0gMTZcXG4gICAgLy8gfSlcXG4gICAgLy9cXG4gICAgLy8gbGV0IHRydW5Cb3ggPSBuZXcgVWludDhBcnJheShzaXplKVxcblxcbiAgICAvLyB0cnVuQm94LnNldChidWZmZXIuYnVmZmVyLCAwKVxcblxcbiAgICBkYXRhLnNhbXBsZXMuZm9yRWFjaChpdGVtID0+IHtcXG4gICAgICBjb25zdCBmbGFncyA9IGl0ZW0uZmxhZ3M7XFxuICAgICAgLy8gY29uc29sZS5sb2coaXRlbS50eXBlLCBpdGVtLmR0cywgaXRlbS5kdXJhdGlvbilcXG5cXG4gICAgICBidWZmZXIud3JpdGUobmV3IFVpbnQ4QXJyYXkoW2l0ZW0uZHVyYXRpb24gPj4+IDI0ICYgMHhGRiwgLy8gc2FtcGxlX2R1cmF0aW9uXFxuICAgICAgaXRlbS5kdXJhdGlvbiA+Pj4gMTYgJiAweEZGLCBpdGVtLmR1cmF0aW9uID4+PiA4ICYgMHhGRiwgaXRlbS5kdXJhdGlvbiAmIDB4RkYsIGl0ZW0uc2l6ZSA+Pj4gMjQgJiAweEZGLCAvLyBzYW1wbGVfc2l6ZVxcbiAgICAgIGl0ZW0uc2l6ZSA+Pj4gMTYgJiAweEZGLCBpdGVtLnNpemUgPj4+IDggJiAweEZGLCBpdGVtLnNpemUgJiAweEZGLCBmbGFncy5pc0xlYWRpbmcgPDwgMiB8IGZsYWdzLmRlcGVuZHNPbiwgLy8gc2FtcGxlX2ZsYWdzXFxuICAgICAgZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDYgfCBmbGFncy5oYXNSZWR1bmRhbmN5IDw8IDQgfCBmbGFncy5pc05vblN5bmMsIDB4MDAsIDB4MDAsIC8vIHNhbXBsZV9kZWdyYWRhdGlvbl9wcmlvcml0eVxcbiAgICAgIGl0ZW0uY3RzID4+PiAyNCAmIDB4RkYsIC8vIHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxcbiAgICAgIGl0ZW0uY3RzID4+PiAxNiAmIDB4RkYsIGl0ZW0uY3RzID4+PiA4ICYgMHhGRiwgaXRlbS5jdHMgJiAweEZGXSkpO1xcbiAgICAgIC8vIHdyaXRlT2Zmc2V0ICs9IDE2XFxuICAgICAgLy8gYnVmZmVyLndyaXRlKEJ1ZmZlci53cml0ZVVpbnQzMigwKSk7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gYnVmZmVyLmJ1ZmZlcjtcXG4gIH1cXG4gIHN0YXRpYyBzZHRwKGRhdGEpIHtcXG4gICAgbGV0IGJ1ZmZlciA9IG5ldyBfeGdwbGF5ZXJVdGlscy5CdWZmZXIoKTtcXG4gICAgYnVmZmVyLndyaXRlKEZtcDQuc2l6ZSgxMiArIGRhdGEuc2FtcGxlcy5sZW5ndGgpLCBGbXA0LnR5cGUoJ3NkdHAnKSwgRm1wNC5leHRlbnNpb24oMCwgMCkpO1xcbiAgICBkYXRhLnNhbXBsZXMuZm9yRWFjaChpdGVtID0+IHtcXG4gICAgICBjb25zdCBmbGFncyA9IGl0ZW0uZmxhZ3M7XFxuICAgICAgY29uc3QgbnVtID0gZmxhZ3MuaXNMZWFkaW5nIDw8IDYgfCAvLyBpc19sZWFkaW5nOiAyIChiaXQpXFxuICAgICAgZmxhZ3MuZGVwZW5kc09uIDw8IDQgfCAvLyBzYW1wbGVfZGVwZW5kc19vblxcbiAgICAgIGZsYWdzLmlzRGVwZW5kZWRPbiA8PCAyIHwgLy8gc2FtcGxlX2lzX2RlcGVuZGVkX29uXFxuICAgICAgZmxhZ3MuaGFzUmVkdW5kYW5jeTsgLy8gc2FtcGxlX2hhc19yZWR1bmRhbmN5XFxuXFxuICAgICAgYnVmZmVyLndyaXRlKG5ldyBVaW50OEFycmF5KFtudW1dKSk7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gYnVmZmVyLmJ1ZmZlcjtcXG4gIH1cXG4gIHN0YXRpYyBtZGF0KGRhdGEpIHtcXG4gICAgbGV0IGJ1ZmZlciA9IG5ldyBfeGdwbGF5ZXJVdGlscy5CdWZmZXIoKTtcXG4gICAgbGV0IHNpemUgPSA4O1xcbiAgICBkYXRhLnNhbXBsZXMuZm9yRWFjaChpdGVtID0+IHtcXG4gICAgICBzaXplICs9IGl0ZW0uc2l6ZTtcXG4gICAgfSk7XFxuICAgIGJ1ZmZlci53cml0ZShGbXA0LnNpemUoc2l6ZSksIEZtcDQudHlwZSgnbWRhdCcpKTtcXG4gICAgbGV0IG1kYXRCb3ggPSBuZXcgVWludDhBcnJheShzaXplKTtcXG4gICAgbGV0IG9mZnNldCA9IDA7XFxuICAgIG1kYXRCb3guc2V0KGJ1ZmZlci5idWZmZXIsIG9mZnNldCk7XFxuICAgIG9mZnNldCArPSA4O1xcbiAgICBkYXRhLnNhbXBsZXMuZm9yRWFjaChpdGVtID0+IHtcXG4gICAgICBpdGVtLmJ1ZmZlci5mb3JFYWNoKHVuaXQgPT4ge1xcbiAgICAgICAgbWRhdEJveC5zZXQodW5pdCwgb2Zmc2V0KTtcXG4gICAgICAgIG9mZnNldCArPSB1bml0LmJ5dGVMZW5ndGg7XFxuICAgICAgICAvLyBidWZmZXIud3JpdGUodW5pdC5kYXRhKTtcXG4gICAgICB9KTtcXG4gICAgfSk7XFxuICAgIHJldHVybiBtZGF0Qm94O1xcbiAgfVxcbn1cXG5GbXA0LnR5cGUgPSBuYW1lID0+IHtcXG4gIHJldHVybiBuZXcgVWludDhBcnJheShbbmFtZS5jaGFyQ29kZUF0KDApLCBuYW1lLmNoYXJDb2RlQXQoMSksIG5hbWUuY2hhckNvZGVBdCgyKSwgbmFtZS5jaGFyQ29kZUF0KDMpXSk7XFxufTtcXG5GbXA0LnNlcXVlbmNlID0gMTtcXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBGbXA0O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci1yZW11eC9zcmMvbXA0L2ZtcDQuanM/XCIpfSxcIi4uL3hncGxheWVyLXJlbXV4L3NyYy9tcDQvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci1yZW11eC9zcmMvbXA0L2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgX3hncGxheWVyVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB4Z3BsYXllci11dGlscyAqLyBcXFwiLi4veGdwbGF5ZXItdXRpbHMvaW5kZXguanNcXFwiKTtcXG5cXG52YXIgX2ZtcCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm1wNCAqLyBcXFwiLi4veGdwbGF5ZXItcmVtdXgvc3JjL21wNC9mbXA0LmpzXFxcIik7XFxuXFxudmFyIF9mbXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm1wKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxcblxcbmNvbnN0IFJFTVVYX0VWRU5UUyA9IF94Z3BsYXllclV0aWxzLkVWRU5UUy5SRU1VWF9FVkVOVFM7XFxuXFxuY2xhc3MgTXA0UmVtdXhlciB7XFxuICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgdGhpcy5fZHRzQmFzZSA9IDA7XFxuICAgIHRoaXMuX2lzRHRzQmFzZUluaXRlZCA9IGZhbHNlO1xcblxcbiAgICB0aGlzLmlzRmlyc3RWaWRlbyA9IHRydWU7XFxuICAgIHRoaXMuaXNGaXJzdEF1ZGlvID0gdHJ1ZTtcXG5cXG4gICAgdGhpcy52aWRlb0FsbER1cmF0aW9uID0gMDtcXG4gICAgdGhpcy5hdWRpb0FsbER1cmF0aW9uID0gMDtcXG4gIH1cXG5cXG4gIGluaXQoKSB7XFxuICAgIHRoaXMub24oUkVNVVhfRVZFTlRTLlJFTVVYX01FRElBLCB0aGlzLnJlbXV4LmJpbmQodGhpcykpO1xcbiAgICB0aGlzLm9uKFJFTVVYX0VWRU5UUy5SRU1VWF9NRVRBREFUQSwgdGhpcy5vbk1ldGFEYXRhUmVhZHkuYmluZCh0aGlzKSk7XFxuICAgIHRoaXMub24oUkVNVVhfRVZFTlRTLkRFVEVDVF9DSEFOR0VfU1RSRUFNLCB0aGlzLnJlc2V0RHRzQmFzZS5iaW5kKHRoaXMpKTtcXG4gIH1cXG5cXG4gIGRlc3Ryb3koKSB7XFxuICAgIHRoaXMuX2R0c0Jhc2UgPSAtMTtcXG4gICAgdGhpcy5fZHRzQmFzZUluaXRlZCA9IGZhbHNlO1xcbiAgfVxcblxcbiAgcmVzZXQoKSB7XFxuICAgIHRoaXMuX2R0c0Jhc2UgPSAwO1xcbiAgICB0aGlzLl9pc0R0c0Jhc2VJbml0ZWQgPSBmYWxzZTtcXG4gIH1cXG5cXG4gIHJlbXV4KCkge1xcbiAgICBjb25zdCB7IGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2sgfSA9IHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoJ1RSQUNLUycpO1xcbiAgICAhdGhpcy5faXNEdHNCYXNlSW5pdGVkICYmIHRoaXMuY2FsY0R0c0Jhc2UoYXVkaW9UcmFjaywgdmlkZW9UcmFjayk7XFxuXFxuICAgIHRoaXMuX3JlbXV4VmlkZW8odmlkZW9UcmFjayk7XFxuICAgIHRoaXMuX3JlbXV4QXVkaW8oYXVkaW9UcmFjayk7XFxuICB9XFxuXFxuICByZXNldER0c0Jhc2UoKSB7XFxuICAgIC8vIGZvciBobHMg5Lit6YCU5YiH5o2iIG1ldGHlkI5zZWVrXFxuICAgIHRoaXMuX2R0c0Jhc2UgPSAwO1xcbiAgICB0aGlzLl9kdHNCYXNlSW5pdGVkID0gZmFsc2U7XFxuICB9XFxuXFxuICBzZWVrKCkge31cXG5cXG4gIG9uTWV0YURhdGFSZWFkeSh0eXBlKSB7XFxuICAgIGxldCB0cmFjaztcXG5cXG4gICAgaWYgKHR5cGUgPT09ICdhdWRpbycpIHtcXG4gICAgICBjb25zdCB7IGF1ZGlvVHJhY2sgfSA9IHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoJ1RSQUNLUycpO1xcbiAgICAgIHRyYWNrID0gYXVkaW9UcmFjaztcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjb25zdCB7IHZpZGVvVHJhY2sgfSA9IHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoJ1RSQUNLUycpO1xcbiAgICAgIHRyYWNrID0gdmlkZW9UcmFjaztcXG4gICAgfVxcblxcbiAgICBsZXQgcHJlc291cmNlYnVmZmVyID0gdGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZSgnUFJFX1NPVVJDRV9CVUZGRVInKTtcXG4gICAgbGV0IHNvdXJjZSA9IHByZXNvdXJjZWJ1ZmZlci5nZXRTb3VyY2UodHlwZSk7XFxuICAgIGlmICghc291cmNlKSB7XFxuICAgICAgc291cmNlID0gcHJlc291cmNlYnVmZmVyLmNyZWF0ZVNvdXJjZSh0eXBlKTtcXG4gICAgfVxcblxcbiAgICBzb3VyY2UubWltZXR5cGUgPSB0cmFjay5tZXRhLmNvZGVjO1xcbiAgICBzb3VyY2UuaW5pdCA9IHRoaXMucmVtdXhJbml0U2VnbWVudCh0eXBlLCB0cmFjay5tZXRhKTtcXG4gICAgLy8gc291cmNlLmluaXRlZCA9IGZhbHNlO1xcblxcbiAgICAvLyB0aGlzLnJlc2V0RHRzQmFzZSgpXFxuICAgIHRoaXMuZW1pdChSRU1VWF9FVkVOVFMuSU5JVF9TRUdNRU5ULCB0eXBlKTtcXG4gIH1cXG5cXG4gIHJlbXV4SW5pdFNlZ21lbnQodHlwZSwgbWV0YSkge1xcbiAgICBsZXQgaW5pdFNlZ21lbnQgPSBuZXcgX3hncGxheWVyVXRpbHMuQnVmZmVyKCk7XFxuICAgIGxldCBmdHlwID0gX2ZtcDIuZGVmYXVsdC5mdHlwKCk7XFxuICAgIGxldCBtb292ID0gX2ZtcDIuZGVmYXVsdC5tb292KHsgdHlwZSwgbWV0YTogbWV0YSB9KTtcXG5cXG4gICAgaW5pdFNlZ21lbnQud3JpdGUoZnR5cCwgbW9vdik7XFxuICAgIHJldHVybiBpbml0U2VnbWVudDtcXG4gIH1cXG5cXG4gIGNhbGNEdHNCYXNlKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2spIHtcXG4gICAgaWYgKCFhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoICYmICF2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGxldCBhdWRpb0Jhc2UgPSBJbmZpbml0eTtcXG4gICAgbGV0IHZpZGVvQmFzZSA9IEluZmluaXR5O1xcblxcbiAgICBpZiAoYXVkaW9UcmFjay5zYW1wbGVzICYmIGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcXG4gICAgICBhdWRpb0Jhc2UgPSBhdWRpb1RyYWNrLnNhbXBsZXNbMF0uZHRzO1xcbiAgICB9XFxuICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMgJiYgdmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCkge1xcbiAgICAgIHZpZGVvQmFzZSA9IHZpZGVvVHJhY2suc2FtcGxlc1swXS5kdHM7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fZHRzQmFzZSA9IE1hdGgubWluKGF1ZGlvQmFzZSwgdmlkZW9CYXNlKTtcXG4gICAgdGhpcy5faXNEdHNCYXNlSW5pdGVkID0gdHJ1ZTtcXG4gIH1cXG5cXG4gIF9yZW11eFZpZGVvKHZpZGVvVHJhY2spIHtcXG4gICAgY29uc3QgdHJhY2sgPSB2aWRlb1RyYWNrO1xcblxcbiAgICBpZiAoIXZpZGVvVHJhY2suc2FtcGxlcyB8fCAhdmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBsZXQgeyBzYW1wbGVzIH0gPSB0cmFjaztcXG4gICAgbGV0IGZpcnN0RHRzID0gLTE7XFxuXFxuICAgIGxldCBpbml0U2VnbWVudCA9IG51bGw7XFxuICAgIGNvbnN0IG1wNFNhbXBsZXMgPSBbXTtcXG4gICAgY29uc3QgbWRhdEJveCA9IHtcXG4gICAgICBzYW1wbGVzOiBbXVxcbiAgICB9O1xcblxcbiAgICB3aGlsZSAoc2FtcGxlcy5sZW5ndGgpIHtcXG4gICAgICBjb25zdCBhdmNTYW1wbGUgPSBzYW1wbGVzLnNoaWZ0KCk7XFxuXFxuICAgICAgY29uc3QgeyBpc0tleWZyYW1lLCBvcHRpb25zIH0gPSBhdmNTYW1wbGU7XFxuICAgICAgaWYgKCF0aGlzLmlzRmlyc3RBdWRpbyAmJiBvcHRpb25zICYmIG9wdGlvbnMubWV0YSkge1xcbiAgICAgICAgaW5pdFNlZ21lbnQgPSB0aGlzLnJlbXV4SW5pdFNlZ21lbnQoJ3ZpZGVvJywgb3B0aW9ucy5tZXRhKTtcXG4gICAgICAgIG9wdGlvbnMubWV0YSA9IG51bGw7XFxuICAgICAgICBzYW1wbGVzLnVuc2hpZnQoYXZjU2FtcGxlKTtcXG4gICAgICAgIGlmICghb3B0aW9ucy5pc0NvbnRpbnVlKSB7XFxuICAgICAgICAgIHRoaXMucmVzZXREdHNCYXNlKCk7XFxuICAgICAgICB9XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuXFxuICAgICAgbGV0IGR0cyA9IGF2Y1NhbXBsZS5kdHMgLSB0aGlzLl9kdHNCYXNlO1xcblxcbiAgICAgIGlmIChmaXJzdER0cyA9PT0gLTEpIHtcXG4gICAgICAgIGZpcnN0RHRzID0gZHRzO1xcbiAgICAgIH1cXG5cXG4gICAgICBsZXQgY3RzO1xcbiAgICAgIGxldCBwdHM7XFxuICAgICAgaWYgKGF2Y1NhbXBsZS5wdHMgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgcHRzID0gYXZjU2FtcGxlLnB0cyAtIHRoaXMuX2R0c0Jhc2U7XFxuICAgICAgICBjdHMgPSBwdHMgLSBkdHM7XFxuICAgICAgfVxcbiAgICAgIGlmIChhdmNTYW1wbGUuY3RzICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIHB0cyA9IGF2Y1NhbXBsZS5jdHMgKyBkdHM7XFxuICAgICAgICBjdHMgPSBhdmNTYW1wbGUuY3RzO1xcbiAgICAgIH1cXG5cXG4gICAgICBsZXQgbWRhdFNhbXBsZSA9IHtcXG4gICAgICAgIGJ1ZmZlcjogW10sXFxuICAgICAgICBzaXplOiAwXFxuICAgICAgfTtcXG4gICAgICBtZGF0Qm94LnNhbXBsZXMucHVzaChtZGF0U2FtcGxlKTtcXG4gICAgICBtZGF0U2FtcGxlLmJ1ZmZlci5wdXNoKGF2Y1NhbXBsZS5kYXRhKTtcXG4gICAgICBtZGF0U2FtcGxlLnNpemUgKz0gYXZjU2FtcGxlLmRhdGEuYnl0ZUxlbmd0aDtcXG5cXG4gICAgICBsZXQgc2FtcGxlRHVyYXRpb24gPSAwO1xcbiAgICAgIGlmIChzYW1wbGVzLmxlbmd0aCA+PSAxKSB7XFxuICAgICAgICBjb25zdCBuZXh0RHRzID0gc2FtcGxlc1swXS5kdHMgLSB0aGlzLl9kdHNCYXNlO1xcbiAgICAgICAgc2FtcGxlRHVyYXRpb24gPSBuZXh0RHRzIC0gZHRzO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAobXA0U2FtcGxlcy5sZW5ndGggPj0gMSkge1xcbiAgICAgICAgICAvLyBsYXN0ZXN0IHNhbXBsZSwgdXNlIHNlY29uZCBsYXN0IGR1cmF0aW9uXFxuICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gbXA0U2FtcGxlc1ttcDRTYW1wbGVzLmxlbmd0aCAtIDFdLmR1cmF0aW9uO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy8gdGhlIG9ubHkgb25lIHNhbXBsZSwgdXNlIHJlZmVyZW5jZSBkdXJhdGlvblxcbiAgICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHRoaXMudmlkZW9NZXRhLnJlZlNhbXBsZUR1cmF0aW9uO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICB0aGlzLnZpZGVvQWxsRHVyYXRpb24gKz0gc2FtcGxlRHVyYXRpb247XFxuICAgICAgLy8gY29uc29sZS5sb2coYGR0cyAke2R0c31gLCBgcHRzICR7cHRzfWAsIGBjdHM6ICR7Y3RzfWAsIGBkdXJhdGlvbjogJHtzYW1wbGVEdXJhdGlvbn1gLCBhdmNTYW1wbGUpXFxuICAgICAgbXA0U2FtcGxlcy5wdXNoKHtcXG4gICAgICAgIGR0cyxcXG4gICAgICAgIGN0cyxcXG4gICAgICAgIHB0cyxcXG4gICAgICAgIGRhdGE6IGF2Y1NhbXBsZS5kYXRhLFxcbiAgICAgICAgc2l6ZTogYXZjU2FtcGxlLmRhdGEuYnl0ZUxlbmd0aCxcXG4gICAgICAgIGlzS2V5ZnJhbWUsXFxuICAgICAgICBkdXJhdGlvbjogc2FtcGxlRHVyYXRpb24sXFxuICAgICAgICBmbGFnczoge1xcbiAgICAgICAgICBpc0xlYWRpbmc6IDAsXFxuICAgICAgICAgIGRlcGVuZHNPbjogaXNLZXlmcmFtZSA/IDIgOiAxLFxcbiAgICAgICAgICBpc0RlcGVuZGVkT246IGlzS2V5ZnJhbWUgPyAxIDogMCxcXG4gICAgICAgICAgaGFzUmVkdW5kYW5jeTogMCxcXG4gICAgICAgICAgaXNOb25TeW5jOiBpc0tleWZyYW1lID8gMCA6IDFcXG4gICAgICAgIH0sXFxuICAgICAgICBvcmlnaW5EdHM6IGR0cyxcXG4gICAgICAgIHR5cGU6ICd2aWRlbydcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBsZXQgbW9vZk1kYXQgPSBuZXcgX3hncGxheWVyVXRpbHMuQnVmZmVyKCk7XFxuICAgIGlmIChtcDRTYW1wbGVzLmxlbmd0aCkge1xcbiAgICAgIGNvbnN0IG1vb2YgPSBfZm1wMi5kZWZhdWx0Lm1vb2Yoe1xcbiAgICAgICAgaWQ6IHRyYWNrLm1ldGEuaWQsXFxuICAgICAgICB0aW1lOiBmaXJzdER0cyxcXG4gICAgICAgIHNhbXBsZXM6IG1wNFNhbXBsZXNcXG4gICAgICB9KTtcXG4gICAgICBjb25zdCBtZGF0ID0gX2ZtcDIuZGVmYXVsdC5tZGF0KG1kYXRCb3gpO1xcbiAgICAgIG1vb2ZNZGF0LndyaXRlKG1vb2YsIG1kYXQpO1xcblxcbiAgICAgIHRoaXMud3JpdGVUb1NvdXJjZSgndmlkZW8nLCBtb29mTWRhdCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGluaXRTZWdtZW50KSB7XFxuICAgICAgdGhpcy53cml0ZVRvU291cmNlKCd2aWRlbycsIGluaXRTZWdtZW50KTtcXG5cXG4gICAgICBpZiAoc2FtcGxlcy5sZW5ndGgpIHtcXG4gICAgICAgIC8vIHNlY29uZCBwYXJ0IG9mIHN0cmVhbSBjaGFuZ2VcXG4gICAgICAgIHRyYWNrLnNhbXBsZXMgPSBzYW1wbGVzO1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbXV4VmlkZW8odHJhY2spO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB0aGlzLmlzRmlyc3RWaWRlbyA9IGZhbHNlO1xcbiAgICB0aGlzLmVtaXQoUkVNVVhfRVZFTlRTLk1FRElBX1NFR01FTlQsICd2aWRlbycpO1xcblxcbiAgICBjb25zdCBsYXN0U2FtcGxlID0gbXA0U2FtcGxlc1ttcDRTYW1wbGVzLmxlbmd0aCAtIDFdO1xcbiAgICB0aGlzLl92aWRlb05leHREdHMgPSBsYXN0U2FtcGxlLmR0cyArIGxhc3RTYW1wbGUuZHVyYXRpb247XFxuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcXG4gICAgdHJhY2subGVuZ3RoID0gMDtcXG4gIH1cXG5cXG4gIF9yZW11eEF1ZGlvKHRyYWNrKSB7XFxuICAgIGNvbnN0IHsgc2FtcGxlcyB9ID0gdHJhY2s7XFxuICAgIGxldCBmaXJzdER0cyA9IC0xO1xcbiAgICBsZXQgbXA0U2FtcGxlcyA9IFtdO1xcblxcbiAgICBsZXQgaW5pdFNlZ21lbnQgPSBudWxsO1xcbiAgICBjb25zdCBtZGF0Qm94ID0ge1xcbiAgICAgIHNhbXBsZXM6IFtdXFxuICAgIH07XFxuICAgIGlmICghc2FtcGxlcyB8fCAhc2FtcGxlcy5sZW5ndGgpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgbGV0IGlzRmlyc3REdHNJbml0ZWQgPSBmYWxzZTtcXG4gICAgd2hpbGUgKHNhbXBsZXMubGVuZ3RoKSB7XFxuICAgICAgbGV0IHNhbXBsZSA9IHNhbXBsZXMuc2hpZnQoKTtcXG4gICAgICBjb25zdCB7IGRhdGEsIG9wdGlvbnMgfSA9IHNhbXBsZTtcXG4gICAgICBpZiAoIXRoaXMuaXNGaXJzdEF1ZGlvICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5tZXRhKSB7XFxuICAgICAgICBpbml0U2VnbWVudCA9IHRoaXMucmVtdXhJbml0U2VnbWVudCgnYXVkaW8nLCBvcHRpb25zLm1ldGEpO1xcbiAgICAgICAgb3B0aW9ucy5tZXRhID0gbnVsbDtcXG4gICAgICAgIHNhbXBsZXMudW5zaGlmdChzYW1wbGUpO1xcbiAgICAgICAgaWYgKCFvcHRpb25zLmlzQ29udGludWUpIHtcXG4gICAgICAgICAgdGhpcy5yZXNldER0c0Jhc2UoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG5cXG4gICAgICBsZXQgZHRzID0gc2FtcGxlLmR0cyAtIHRoaXMuX2R0c0Jhc2U7XFxuICAgICAgY29uc3Qgb3JpZ2luRHRzID0gZHRzO1xcbiAgICAgIGlmICghaXNGaXJzdER0c0luaXRlZCkge1xcbiAgICAgICAgZmlyc3REdHMgPSBkdHM7XFxuICAgICAgICBpc0ZpcnN0RHRzSW5pdGVkID0gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgbGV0IHNhbXBsZUR1cmF0aW9uID0gMDtcXG5cXG4gICAgICBpZiAodGhpcy5hdWRpb01ldGEucmVmU2FtcGxlRHVyYXRpb25GaXhlZCkge1xcbiAgICAgICAgc2FtcGxlRHVyYXRpb24gPSB0aGlzLmF1ZGlvTWV0YS5yZWZTYW1wbGVEdXJhdGlvbkZpeGVkO1xcbiAgICAgIH0gZWxzZSBpZiAoc2FtcGxlcy5sZW5ndGggPj0gMSkge1xcbiAgICAgICAgY29uc3QgbmV4dER0cyA9IHNhbXBsZXNbMF0uZHRzIC0gdGhpcy5fZHRzQmFzZTtcXG4gICAgICAgIHNhbXBsZUR1cmF0aW9uID0gbmV4dER0cyAtIGR0cztcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKG1wNFNhbXBsZXMubGVuZ3RoID49IDEpIHtcXG4gICAgICAgICAgLy8gdXNlIHNlY29uZCBsYXN0IHNhbXBsZSBkdXJhdGlvblxcbiAgICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IG1wNFNhbXBsZXNbbXA0U2FtcGxlcy5sZW5ndGggLSAxXS5kdXJhdGlvbjtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIHRoZSBvbmx5IG9uZSBzYW1wbGUsIHVzZSByZWZlcmVuY2Ugc2FtcGxlIGR1cmF0aW9uXFxuICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gdGhpcy5hdWRpb01ldGEucmVmU2FtcGxlRHVyYXRpb247XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW11eCBhdWRpbyAnLCBkdHMpXFxuICAgICAgdGhpcy5hdWRpb0FsbER1cmF0aW9uICs9IHNhbXBsZUR1cmF0aW9uO1xcbiAgICAgIGNvbnN0IG1wNFNhbXBsZSA9IHtcXG4gICAgICAgIGR0cyxcXG4gICAgICAgIHB0czogZHRzLFxcbiAgICAgICAgY3RzOiAwLFxcbiAgICAgICAgc2l6ZTogZGF0YS5ieXRlTGVuZ3RoLFxcbiAgICAgICAgZHVyYXRpb246IHNhbXBsZS5kdXJhdGlvbiA/IHNhbXBsZS5kdXJhdGlvbiA6IHNhbXBsZUR1cmF0aW9uLFxcbiAgICAgICAgZmxhZ3M6IHtcXG4gICAgICAgICAgaXNMZWFkaW5nOiAwLFxcbiAgICAgICAgICBkZXBlbmRzT246IDIsXFxuICAgICAgICAgIGlzRGVwZW5kZWRPbjogMSxcXG4gICAgICAgICAgaGFzUmVkdW5kYW5jeTogMCxcXG4gICAgICAgICAgaXNOb25TeW5jOiAwXFxuICAgICAgICB9LFxcbiAgICAgICAgaXNLZXlmcmFtZTogdHJ1ZSxcXG4gICAgICAgIG9yaWdpbkR0cyxcXG4gICAgICAgIHR5cGU6ICdhdWRpbydcXG4gICAgICB9O1xcblxcbiAgICAgIGxldCBtZGF0U2FtcGxlID0ge1xcbiAgICAgICAgYnVmZmVyOiBbXSxcXG4gICAgICAgIHNpemU6IDBcXG4gICAgICB9O1xcbiAgICAgIG1kYXRTYW1wbGUuYnVmZmVyLnB1c2goZGF0YSk7XFxuICAgICAgbWRhdFNhbXBsZS5zaXplICs9IGRhdGEuYnl0ZUxlbmd0aDtcXG5cXG4gICAgICBtZGF0Qm94LnNhbXBsZXMucHVzaChtZGF0U2FtcGxlKTtcXG5cXG4gICAgICBtcDRTYW1wbGVzLnB1c2gobXA0U2FtcGxlKTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBtb29mTWRhdCA9IG5ldyBfeGdwbGF5ZXJVdGlscy5CdWZmZXIoKTtcXG5cXG4gICAgaWYgKG1wNFNhbXBsZXMubGVuZ3RoKSB7XFxuICAgICAgY29uc3QgbW9vZiA9IF9mbXAyLmRlZmF1bHQubW9vZih7XFxuICAgICAgICBpZDogdHJhY2subWV0YS5pZCxcXG4gICAgICAgIHRpbWU6IGZpcnN0RHRzLFxcbiAgICAgICAgc2FtcGxlczogbXA0U2FtcGxlc1xcbiAgICAgIH0pO1xcbiAgICAgIGNvbnN0IG1kYXQgPSBfZm1wMi5kZWZhdWx0Lm1kYXQobWRhdEJveCk7XFxuICAgICAgbW9vZk1kYXQud3JpdGUobW9vZiwgbWRhdCk7XFxuXFxuICAgICAgdGhpcy53cml0ZVRvU291cmNlKCdhdWRpbycsIG1vb2ZNZGF0KTtcXG4gICAgfVxcblxcbiAgICBpZiAoaW5pdFNlZ21lbnQpIHtcXG4gICAgICB0aGlzLndyaXRlVG9Tb3VyY2UoJ2F1ZGlvJywgaW5pdFNlZ21lbnQpO1xcbiAgICAgIGlmIChzYW1wbGVzLmxlbmd0aCkge1xcbiAgICAgICAgLy8gc2Vjb25kIHBhcnQgb2Ygc3RyZWFtIGNoYW5nZVxcbiAgICAgICAgdHJhY2suc2FtcGxlcyA9IHNhbXBsZXM7XFxuICAgICAgICByZXR1cm4gdGhpcy5fcmVtdXhBdWRpbyh0cmFjayk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHRoaXMuaXNGaXJzdEF1ZGlvID0gZmFsc2U7XFxuICAgIHRoaXMuZW1pdChSRU1VWF9FVkVOVFMuTUVESUFfU0VHTUVOVCwgJ2F1ZGlvJywgbW9vZk1kYXQpO1xcblxcbiAgICBjb25zdCBsYXN0U2FtcGxlID0gbXA0U2FtcGxlc1ttcDRTYW1wbGVzLmxlbmd0aCAtIDFdO1xcbiAgICB0aGlzLl92aWRlb05leHREdHMgPSBsYXN0U2FtcGxlLmR0cyArIGxhc3RTYW1wbGUuZHVyYXRpb247XFxuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcXG4gICAgdHJhY2subGVuZ3RoID0gMDtcXG4gIH1cXG5cXG4gIHdyaXRlVG9Tb3VyY2UodHlwZSwgYnVmZmVyKSB7XFxuICAgIGxldCBwcmVzb3VyY2VidWZmZXIgPSB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKCdQUkVfU09VUkNFX0JVRkZFUicpO1xcbiAgICBsZXQgc291cmNlID0gcHJlc291cmNlYnVmZmVyLmdldFNvdXJjZSh0eXBlKTtcXG4gICAgaWYgKCFzb3VyY2UpIHtcXG4gICAgICBzb3VyY2UgPSBwcmVzb3VyY2VidWZmZXIuY3JlYXRlU291cmNlKHR5cGUpO1xcbiAgICB9XFxuXFxuICAgIHNvdXJjZS5kYXRhLnB1c2goYnVmZmVyKTtcXG4gIH1cXG5cXG4gIGluaXRTaWxlbnRBdWRpbyhkdHMsIGR1cmF0aW9uKSB7XFxuICAgIGNvbnN0IHVuaXQgPSBNcDRSZW11eGVyLmdldFNpbGVudEZyYW1lKHRoaXMuYXVkaW9NZXRhLmNoYW5uZWxDb3VudCk7XFxuICAgIHJldHVybiB7XFxuICAgICAgZHRzLFxcbiAgICAgIHB0czogZHRzLFxcbiAgICAgIGN0czogMCxcXG4gICAgICBkdXJhdGlvbixcXG4gICAgICB1bml0LFxcbiAgICAgIHNpemU6IHVuaXQuYnl0ZUxlbmd0aCxcXG4gICAgICBvcmlnaW5EdHM6IGR0cyxcXG4gICAgICB0eXBlOiAndmlkZW8nXFxuICAgIH07XFxuICB9XFxuXFxuICBnZXQgdmlkZW9NZXRhKCkge1xcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZSgnVFJBQ0tTJykudmlkZW9UcmFjay5tZXRhO1xcbiAgfVxcbiAgZ2V0IGF1ZGlvTWV0YSgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoJ1RSQUNLUycpLmF1ZGlvVHJhY2subWV0YTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXRTaWxlbnRGcmFtZShjaGFubmVsQ291bnQpIHtcXG4gICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMywgMHg4MF0pO1xcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgyMSwgMHgwMCwgMHg0OSwgMHg5MCwgMHgwMiwgMHgxOSwgMHgwMCwgMHgyMywgMHg4MF0pO1xcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4ZV0pO1xcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNCkge1xcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MCwgMHgyYywgMHg4MCwgMHgwOCwgMHgwMiwgMHgzOF0pO1xcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNSkge1xcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgzOF0pO1xcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNikge1xcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgwMCwgMHhiMiwgMHgwMCwgMHgyMCwgMHgwOCwgMHhlMF0pO1xcbiAgICB9XFxuICAgIHJldHVybiBudWxsO1xcbiAgfVxcbn1cXG5leHBvcnRzLmRlZmF1bHQgPSBNcDRSZW11eGVyO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci1yZW11eC9zcmMvbXA0L2luZGV4LmpzP1wiKX0sXCIuLi94Z3BsYXllci11dGlscy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci11dGlscy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoJ1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgQ29udGV4dDogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvY29udGV4dCAqLyBcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9jb250ZXh0LmpzXCIpLmRlZmF1bHQsXFxuXFxuICAvLyBNb2R1bGVzIGZyb20gY29uc3RhbnRzXFxuICBFVkVOVFM6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2NvbnN0YW50cy9ldmVudHMgKi8gXCIuLi94Z3BsYXllci11dGlscy9zcmMvY29uc3RhbnRzL2V2ZW50cy5qc1wiKS5kZWZhdWx0LFxcbiAgV09SS0VSX0NPTU1BTkRTOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9jb25zdGFudHMvd29ya2VyLWNvbW1hbmRzICovIFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL2NvbnN0YW50cy93b3JrZXItY29tbWFuZHMuanNcIikuZGVmYXVsdCxcXG5cXG4gIC8vIE1vZHVsZXMgZnJvbSBlbnZcXG4gIHNuaWZmZXI6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2Vudi9zbmlmZmVyICovIFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL2Vudi9zbmlmZmVyLmpzXCIpLmRlZmF1bHQsXFxuICBpc0xlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9lbnYvaXNsZSAqLyBcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9lbnYvaXNsZS5qc1wiKS5kZWZhdWx0LFxcbiAgVVRGODogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvZW52L3V0ZjggKi8gXCIuLi94Z3BsYXllci11dGlscy9zcmMvZW52L3V0ZjguanNcIikuZGVmYXVsdCxcXG5cXG4gIC8vIE1vZGVsc1xcbiAgTWVkaWFJbmZvOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9tb2RlbHMvbWVkaWEtaW5mbyAqLyBcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvbWVkaWEtaW5mby5qc1wiKS5kZWZhdWx0LFxcbiAgTWVkaWFTYW1wbGU6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL21vZGVscy9tZWRpYS1zYW1wbGUgKi8gXCIuLi94Z3BsYXllci11dGlscy9zcmMvbW9kZWxzL21lZGlhLXNhbXBsZS5qc1wiKS5kZWZhdWx0LFxcbiAgTWVkaWFTZWdtZW50OiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9tb2RlbHMvbWVkaWEtc2VnbWVudCAqLyBcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvbWVkaWEtc2VnbWVudC5qc1wiKS5kZWZhdWx0LFxcbiAgTWVkaWFTZWdtZW50TGlzdDogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvbW9kZWxzL21lZGlhLXNlZ21lbnQtbGlzdCAqLyBcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvbWVkaWEtc2VnbWVudC1saXN0LmpzXCIpLmRlZmF1bHQsXFxuICBBdWRpb1RyYWNrTWV0YTogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvbW9kZWxzL3RyYWNrLW1ldGEgKi8gXCIuLi94Z3BsYXllci11dGlscy9zcmMvbW9kZWxzL3RyYWNrLW1ldGEuanNcIikuQXVkaW9UcmFja01ldGEsXFxuICBWaWRlb1RyYWNrTWV0YTogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvbW9kZWxzL3RyYWNrLW1ldGEgKi8gXCIuLi94Z3BsYXllci11dGlscy9zcmMvbW9kZWxzL3RyYWNrLW1ldGEuanNcIikuVmlkZW9UcmFja01ldGEsXFxuICBBdWRpb1RyYWNrU2FtcGxlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9tb2RlbHMvdHJhY2stc2FtcGxlICovIFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vZGVscy90cmFjay1zYW1wbGUuanNcIikuQXVkaW9UcmFja1NhbXBsZSxcXG4gIFZpZGVvVHJhY2tTYW1wbGU6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL21vZGVscy90cmFjay1zYW1wbGUgKi8gXCIuLi94Z3BsYXllci11dGlscy9zcmMvbW9kZWxzL3RyYWNrLXNhbXBsZS5qc1wiKS5WaWRlb1RyYWNrU2FtcGxlLFxcblxcbiAgLy8gTW9kdWxlcyBmcm9tIG1zZVxcbiAgTXNlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9tc2UvaW5kZXggKi8gXCIuLi94Z3BsYXllci11dGlscy9zcmMvbXNlL2luZGV4LmpzXCIpLmRlZmF1bHQsXFxuXFxuICAvLyBNb2R1bGVzIGZyb20gd3JpdGVcXG4gIFN0cmVhbTogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvd3JpdGUvc3RyZWFtICovIFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL3dyaXRlL3N0cmVhbS5qc1wiKS5kZWZhdWx0LFxcbiAgQnVmZmVyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy93cml0ZS9idWZmZXIgKi8gXCIuLi94Z3BsYXllci11dGlscy9zcmMvd3JpdGUvYnVmZmVyLmpzXCIpLmRlZmF1bHQsXFxuXFxuICBNb2JpbGVWaWRlbzogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvbW9iaWxlL21vYmlsZS12aWRlbyAqLyBcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvbW9iaWxlLXZpZGVvLmpzXCIpLFxcbiAgLy8gQ3J5cHRvXFxuICBDcnlwdG86IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL2NyeXB0byAqLyBcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9jcnlwdG8vaW5kZXguanNcIikuZGVmYXVsdFxcbn07XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL2luZGV4LmpzPycpfSxcIi4uL3hncGxheWVyLXV0aWxzL25vZGVfbW9kdWxlcy9jb25jYXQtdHlwZWQtYXJyYXkvbGliL2NvbmNhdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvbm9kZV9tb2R1bGVzL2NvbmNhdC10eXBlZC1hcnJheS9saWIvY29uY2F0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoJ1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoUmVzdWx0Q29uc3RydWN0b3IpIHtcXG4gIHZhciB0b3RhbExlbmd0aCA9IDA7XFxuXFxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJyYXlzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xcbiAgICBhcnJheXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xcbiAgfVxcblxcbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XFxuICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XFxuXFxuICB0cnkge1xcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBhcnJheXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XFxuICAgICAgdmFyIGFyciA9IF9zdGVwLnZhbHVlO1xcblxcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGFyci5sZW5ndGg7XFxuICAgIH1cXG4gIH0gY2F0Y2ggKGVycikge1xcbiAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XFxuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xcbiAgfSBmaW5hbGx5IHtcXG4gICAgdHJ5IHtcXG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xcbiAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xcbiAgICAgIH1cXG4gICAgfSBmaW5hbGx5IHtcXG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcXG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIHJlc3VsdCA9IG5ldyBSZXN1bHRDb25zdHJ1Y3Rvcih0b3RhbExlbmd0aCk7XFxuICB2YXIgb2Zmc2V0ID0gMDtcXG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XFxuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XFxuICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xcblxcbiAgdHJ5IHtcXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IGFycmF5c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xcbiAgICAgIHZhciBfYXJyID0gX3N0ZXAyLnZhbHVlO1xcblxcbiAgICAgIHJlc3VsdC5zZXQoX2Fyciwgb2Zmc2V0KTtcXG4gICAgICBvZmZzZXQgKz0gX2Fyci5sZW5ndGg7XFxuICAgIH1cXG4gIH0gY2F0Y2ggKGVycikge1xcbiAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xcbiAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XFxuICB9IGZpbmFsbHkge1xcbiAgICB0cnkge1xcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcXG4gICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XFxuICAgICAgfVxcbiAgICB9IGZpbmFsbHkge1xcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcXG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItdXRpbHMvbm9kZV9tb2R1bGVzL2NvbmNhdC10eXBlZC1hcnJheS9saWIvY29uY2F0LmpzPycpfSxcIi4uL3hncGxheWVyLXV0aWxzL25vZGVfbW9kdWxlcy9jb25jYXQtdHlwZWQtYXJyYXkvbGliL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXV0aWxzL25vZGVfbW9kdWxlcy9jb25jYXQtdHlwZWQtYXJyYXkvbGliL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbCgnXFxuXFxudmFyIF9jb25jYXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbmNhdCAqLyBcIi4uL3hncGxheWVyLXV0aWxzL25vZGVfbW9kdWxlcy9jb25jYXQtdHlwZWQtYXJyYXkvbGliL2NvbmNhdC5qc1wiKTtcXG5cXG52YXIgX2NvbmNhdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb25jYXQpO1xcblxcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XFxuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBfY29uY2F0Mi5kZWZhdWx0O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9ub2RlX21vZHVsZXMvY29uY2F0LXR5cGVkLWFycmF5L2xpYi9pbmRleC5qcz8nKX0sXCIuLi94Z3BsYXllci11dGlscy9ub2RlX21vZHVsZXMvd2Vid29ya2lmeS13ZWJwYWNrL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvbm9kZV9tb2R1bGVzL3dlYndvcmtpZnktd2VicGFjay9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbmZ1bmN0aW9uIHdlYnBhY2tCb290c3RyYXBGdW5jKG1vZHVsZXMpIHtcXG4gIC8qKioqKiovIC8vIFRoZSBtb2R1bGUgY2FjaGVcXG4gIC8qKioqKiovdmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcXG5cXG4gIC8qKioqKiovIC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXFxuICAvKioqKioqL2Z1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcXG5cXG4gICAgLyoqKioqKi8gLy8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXFxuICAgIC8qKioqKiovaWYgKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxcbiAgICAgIC8qKioqKiovcmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XFxuXFxuICAgIC8qKioqKiovIC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXFxuICAgIC8qKioqKiovdmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xcbiAgICAgIC8qKioqKiovaTogbW9kdWxlSWQsXFxuICAgICAgLyoqKioqKi9sOiBmYWxzZSxcXG4gICAgICAvKioqKioqL2V4cG9ydHM6IHt9XFxuICAgICAgLyoqKioqKi8gfTtcXG5cXG4gICAgLyoqKioqKi8gLy8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXFxuICAgIC8qKioqKiovbW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XFxuXFxuICAgIC8qKioqKiovIC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcXG4gICAgLyoqKioqKi9tb2R1bGUubCA9IHRydWU7XFxuXFxuICAgIC8qKioqKiovIC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXFxuICAgIC8qKioqKiovcmV0dXJuIG1vZHVsZS5leHBvcnRzO1xcbiAgICAvKioqKioqL1xcbiAgfVxcblxcbiAgLyoqKioqKi8gLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcXG4gIC8qKioqKiovX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcXG5cXG4gIC8qKioqKiovIC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXFxuICAvKioqKioqL19fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XFxuXFxuICAvKioqKioqLyAvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XFxuICAvKioqKioqL19fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICByZXR1cm4gdmFsdWU7XFxuICB9O1xcblxcbiAgLyoqKioqKi8gLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXFxuICAvKioqKioqL19fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uIChleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcXG4gICAgLyoqKioqKi9pZiAoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xcbiAgICAgIC8qKioqKiovT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcXG4gICAgICAgIC8qKioqKiovY29uZmlndXJhYmxlOiBmYWxzZSxcXG4gICAgICAgIC8qKioqKiovZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIC8qKioqKiovZ2V0OiBnZXR0ZXJcXG4gICAgICAgIC8qKioqKiovIH0pO1xcbiAgICAgIC8qKioqKiovXFxuICAgIH1cXG4gICAgLyoqKioqKi9cXG4gIH07XFxuXFxuICAvKioqKioqLyAvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXFxuICAvKioqKioqL19fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uIChleHBvcnRzKSB7XFxuICAgIC8qKioqKiovT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcXG4gICAgLyoqKioqKi9cXG4gIH07XFxuXFxuICAvKioqKioqLyAvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xcbiAgLyoqKioqKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbiAobW9kdWxlKSB7XFxuICAgIC8qKioqKiovdmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XFxuICAgIC8qKioqKiovZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHtcXG4gICAgICByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107XFxuICAgIH0gOlxcbiAgICAvKioqKioqL2Z1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7XFxuICAgICAgcmV0dXJuIG1vZHVsZTtcXG4gICAgfTtcXG4gICAgLyoqKioqKi9fX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XFxuICAgIC8qKioqKiovcmV0dXJuIGdldHRlcjtcXG4gICAgLyoqKioqKi9cXG4gIH07XFxuXFxuICAvKioqKioqLyAvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcXG4gIC8qKioqKiovX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHkpIHtcXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTtcXG4gIH07XFxuXFxuICAvKioqKioqLyAvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xcbiAgLyoqKioqKi9fX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcXFwiL1xcXCI7XFxuXFxuICAvKioqKioqLyAvLyBvbiBlcnJvciBmdW5jdGlvbiBmb3IgYXN5bmMgbG9hZGluZ1xcbiAgLyoqKioqKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm9lID0gZnVuY3Rpb24gKGVycikge1xcbiAgICBjb25zb2xlLmVycm9yKGVycik7dGhyb3cgZXJyO1xcbiAgfTtcXG5cXG4gIHZhciBmID0gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBFTlRSWV9NT0RVTEUpO1xcbiAgcmV0dXJuIGYuZGVmYXVsdCB8fCBmOyAvLyB0cnkgdG8gY2FsbCBkZWZhdWx0IGlmIGRlZmluZWQgdG8gYWxzbyBzdXBwb3J0IGJhYmVsIGVzbW9kdWxlIGV4cG9ydHNcXG59XFxuXFxudmFyIG1vZHVsZU5hbWVSZXFFeHAgPSAnW1xcXFxcXFxcLnxcXFxcXFxcXC18XFxcXFxcXFwrfFxcXFxcXFxcd3xcXFxcL3xAXSsnO1xcbnZhciBkZXBlbmRlbmN5UmVnRXhwID0gJ1xcXFxcXFxcKFxcXFxcXFxccyooXFxcXC9cXFxcXFxcXCouKj9cXFxcXFxcXCpcXFxcLyk/XFxcXFxcXFxzKi4qPygnICsgbW9kdWxlTmFtZVJlcUV4cCArICcpLio/XFxcXFxcXFwpJzsgLy8gYWRkaXRpb25hbCBjaGFycyB3aGVuIG91dHB1dC5wYXRoaW5mbyBpcyB0cnVlXFxuXFxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjU5MzY2MS8xMzA0NDJcXG5mdW5jdGlvbiBxdW90ZVJlZ0V4cChzdHIpIHtcXG4gIHJldHVybiAoc3RyICsgJycpLnJlcGxhY2UoL1suPyorXiRbXFxcXF1cXFxcXFxcXCgpe318LV0vZywgJ1xcXFxcXFxcJCYnKTtcXG59XFxuXFxuZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcXG4gIHJldHVybiAhaXNOYU4oMSAqIG4pOyAvLyAxICogbiBjb252ZXJ0cyBpbnRlZ2VycywgaW50ZWdlcnMgYXMgc3RyaW5nIChcXFwiMTIzXFxcIiksIDFlMyBhbmQgXFxcIjFlM1xcXCIgdG8gaW50ZWdlcnMgYW5kIHN0cmluZ3MgdG8gTmFOXFxufVxcblxcbmZ1bmN0aW9uIGdldE1vZHVsZURlcGVuZGVuY2llcyhzb3VyY2VzLCBtb2R1bGUsIHF1ZXVlTmFtZSkge1xcbiAgdmFyIHJldHZhbCA9IHt9O1xcbiAgcmV0dmFsW3F1ZXVlTmFtZV0gPSBbXTtcXG5cXG4gIHZhciBmblN0cmluZyA9IG1vZHVsZS50b1N0cmluZygpO1xcbiAgdmFyIHdyYXBwZXJTaWduYXR1cmUgPSBmblN0cmluZy5tYXRjaCgvXmZ1bmN0aW9uXFxcXHM/XFxcXHcqXFxcXChcXFxcdyssXFxcXHMqXFxcXHcrLFxcXFxzKihcXFxcdyspXFxcXCkvKTtcXG4gIGlmICghd3JhcHBlclNpZ25hdHVyZSkgcmV0dXJuIHJldHZhbDtcXG4gIHZhciB3ZWJwYWNrUmVxdWlyZU5hbWUgPSB3cmFwcGVyU2lnbmF0dXJlWzFdO1xcblxcbiAgLy8gbWFpbiBidW5kbGUgZGVwc1xcbiAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnKFxcXFxcXFxcXFxcXFxcXFxufFxcXFxcXFxcVyknICsgcXVvdGVSZWdFeHAod2VicGFja1JlcXVpcmVOYW1lKSArIGRlcGVuZGVuY3lSZWdFeHAsICdnJyk7XFxuICB2YXIgbWF0Y2g7XFxuICB3aGlsZSAobWF0Y2ggPSByZS5leGVjKGZuU3RyaW5nKSkge1xcbiAgICBpZiAobWF0Y2hbM10gPT09ICdkbGwtcmVmZXJlbmNlJykgY29udGludWU7XFxuICAgIHJldHZhbFtxdWV1ZU5hbWVdLnB1c2gobWF0Y2hbM10pO1xcbiAgfVxcblxcbiAgLy8gZGxsIGRlcHNcXG4gIHJlID0gbmV3IFJlZ0V4cCgnXFxcXFxcXFwoJyArIHF1b3RlUmVnRXhwKHdlYnBhY2tSZXF1aXJlTmFtZSkgKyAnXFxcXFxcXFwoXFxcIihkbGwtcmVmZXJlbmNlXFxcXFxcXFxzKCcgKyBtb2R1bGVOYW1lUmVxRXhwICsgJykpXFxcIlxcXFxcXFxcKVxcXFxcXFxcKScgKyBkZXBlbmRlbmN5UmVnRXhwLCAnZycpO1xcbiAgd2hpbGUgKG1hdGNoID0gcmUuZXhlYyhmblN0cmluZykpIHtcXG4gICAgaWYgKCFzb3VyY2VzW21hdGNoWzJdXSkge1xcbiAgICAgIHJldHZhbFtxdWV1ZU5hbWVdLnB1c2gobWF0Y2hbMV0pO1xcbiAgICAgIHNvdXJjZXNbbWF0Y2hbMl1dID0gX193ZWJwYWNrX3JlcXVpcmVfXyhtYXRjaFsxXSkubTtcXG4gICAgfVxcbiAgICByZXR2YWxbbWF0Y2hbMl1dID0gcmV0dmFsW21hdGNoWzJdXSB8fCBbXTtcXG4gICAgcmV0dmFsW21hdGNoWzJdXS5wdXNoKG1hdGNoWzRdKTtcXG4gIH1cXG5cXG4gIC8vIGNvbnZlcnQgMWUzIGJhY2sgdG8gMTAwMCAtIHRoaXMgY2FuIGJlIGltcG9ydGFudCBhZnRlciB1Z2xpZnktanMgY29udmVydGVkIDEwMDAgdG8gMWUzXFxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJldHZhbCk7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXR2YWxba2V5c1tpXV0ubGVuZ3RoOyBqKyspIHtcXG4gICAgICBpZiAoaXNOdW1lcmljKHJldHZhbFtrZXlzW2ldXVtqXSkpIHtcXG4gICAgICAgIHJldHZhbFtrZXlzW2ldXVtqXSA9IDEgKiByZXR2YWxba2V5c1tpXV1bal07XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gcmV0dmFsO1xcbn1cXG5cXG5mdW5jdGlvbiBoYXNWYWx1ZXNJblF1ZXVlcyhxdWV1ZXMpIHtcXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocXVldWVzKTtcXG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzVmFsdWVzLCBrZXkpIHtcXG4gICAgcmV0dXJuIGhhc1ZhbHVlcyB8fCBxdWV1ZXNba2V5XS5sZW5ndGggPiAwO1xcbiAgfSwgZmFsc2UpO1xcbn1cXG5cXG5mdW5jdGlvbiBnZXRSZXF1aXJlZE1vZHVsZXMoc291cmNlcywgbW9kdWxlSWQpIHtcXG4gIHZhciBtb2R1bGVzUXVldWUgPSB7XFxuICAgIG1haW46IFttb2R1bGVJZF1cXG4gIH07XFxuICB2YXIgcmVxdWlyZWRNb2R1bGVzID0ge1xcbiAgICBtYWluOiBbXVxcbiAgfTtcXG4gIHZhciBzZWVuTW9kdWxlcyA9IHtcXG4gICAgbWFpbjoge31cXG4gIH07XFxuXFxuICB3aGlsZSAoaGFzVmFsdWVzSW5RdWV1ZXMobW9kdWxlc1F1ZXVlKSkge1xcbiAgICB2YXIgcXVldWVzID0gT2JqZWN0LmtleXMobW9kdWxlc1F1ZXVlKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgcXVldWVOYW1lID0gcXVldWVzW2ldO1xcbiAgICAgIHZhciBxdWV1ZSA9IG1vZHVsZXNRdWV1ZVtxdWV1ZU5hbWVdO1xcbiAgICAgIHZhciBtb2R1bGVUb0NoZWNrID0gcXVldWUucG9wKCk7XFxuICAgICAgc2Vlbk1vZHVsZXNbcXVldWVOYW1lXSA9IHNlZW5Nb2R1bGVzW3F1ZXVlTmFtZV0gfHwge307XFxuICAgICAgaWYgKHNlZW5Nb2R1bGVzW3F1ZXVlTmFtZV1bbW9kdWxlVG9DaGVja10gfHwgIXNvdXJjZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSkgY29udGludWU7XFxuICAgICAgc2Vlbk1vZHVsZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSA9IHRydWU7XFxuICAgICAgcmVxdWlyZWRNb2R1bGVzW3F1ZXVlTmFtZV0gPSByZXF1aXJlZE1vZHVsZXNbcXVldWVOYW1lXSB8fCBbXTtcXG4gICAgICByZXF1aXJlZE1vZHVsZXNbcXVldWVOYW1lXS5wdXNoKG1vZHVsZVRvQ2hlY2spO1xcbiAgICAgIHZhciBuZXdNb2R1bGVzID0gZ2V0TW9kdWxlRGVwZW5kZW5jaWVzKHNvdXJjZXMsIHNvdXJjZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSwgcXVldWVOYW1lKTtcXG4gICAgICB2YXIgbmV3TW9kdWxlc0tleXMgPSBPYmplY3Qua2V5cyhuZXdNb2R1bGVzKTtcXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5ld01vZHVsZXNLZXlzLmxlbmd0aDsgaisrKSB7XFxuICAgICAgICBtb2R1bGVzUXVldWVbbmV3TW9kdWxlc0tleXNbal1dID0gbW9kdWxlc1F1ZXVlW25ld01vZHVsZXNLZXlzW2pdXSB8fCBbXTtcXG4gICAgICAgIG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0gPSBtb2R1bGVzUXVldWVbbmV3TW9kdWxlc0tleXNbal1dLmNvbmNhdChuZXdNb2R1bGVzW25ld01vZHVsZXNLZXlzW2pdXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gcmVxdWlyZWRNb2R1bGVzO1xcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtb2R1bGVJZCwgb3B0aW9ucykge1xcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuICB2YXIgc291cmNlcyA9IHtcXG4gICAgbWFpbjogX193ZWJwYWNrX3JlcXVpcmVfXy5tXFxuICB9O1xcblxcbiAgdmFyIHJlcXVpcmVkTW9kdWxlcyA9IG9wdGlvbnMuYWxsID8geyBtYWluOiBPYmplY3Qua2V5cyhzb3VyY2VzLm1haW4pIH0gOiBnZXRSZXF1aXJlZE1vZHVsZXMoc291cmNlcywgbW9kdWxlSWQpO1xcblxcbiAgdmFyIHNyYyA9ICcnO1xcblxcbiAgT2JqZWN0LmtleXMocmVxdWlyZWRNb2R1bGVzKS5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcXG4gICAgcmV0dXJuIG0gIT09ICdtYWluJztcXG4gIH0pLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xcbiAgICB2YXIgZW50cnlNb2R1bGUgPSAwO1xcbiAgICB3aGlsZSAocmVxdWlyZWRNb2R1bGVzW21vZHVsZV1bZW50cnlNb2R1bGVdKSB7XFxuICAgICAgZW50cnlNb2R1bGUrKztcXG4gICAgfVxcbiAgICByZXF1aXJlZE1vZHVsZXNbbW9kdWxlXS5wdXNoKGVudHJ5TW9kdWxlKTtcXG4gICAgc291cmNlc1ttb2R1bGVdW2VudHJ5TW9kdWxlXSA9ICcoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXzsgfSknO1xcbiAgICBzcmMgPSBzcmMgKyAndmFyICcgKyBtb2R1bGUgKyAnID0gKCcgKyB3ZWJwYWNrQm9vdHN0cmFwRnVuYy50b1N0cmluZygpLnJlcGxhY2UoJ0VOVFJZX01PRFVMRScsIEpTT04uc3RyaW5naWZ5KGVudHJ5TW9kdWxlKSkgKyAnKSh7JyArIHJlcXVpcmVkTW9kdWxlc1ttb2R1bGVdLm1hcChmdW5jdGlvbiAoaWQpIHtcXG4gICAgICByZXR1cm4gJycgKyBKU09OLnN0cmluZ2lmeShpZCkgKyAnOiAnICsgc291cmNlc1ttb2R1bGVdW2lkXS50b1N0cmluZygpO1xcbiAgICB9KS5qb2luKCcsJykgKyAnfSk7XFxcXG4nO1xcbiAgfSk7XFxuXFxuICBzcmMgPSBzcmMgKyAnbmV3ICgoJyArIHdlYnBhY2tCb290c3RyYXBGdW5jLnRvU3RyaW5nKCkucmVwbGFjZSgnRU5UUllfTU9EVUxFJywgSlNPTi5zdHJpbmdpZnkobW9kdWxlSWQpKSArICcpKHsnICsgcmVxdWlyZWRNb2R1bGVzLm1haW4ubWFwKGZ1bmN0aW9uIChpZCkge1xcbiAgICByZXR1cm4gJycgKyBKU09OLnN0cmluZ2lmeShpZCkgKyAnOiAnICsgc291cmNlcy5tYWluW2lkXS50b1N0cmluZygpO1xcbiAgfSkuam9pbignLCcpICsgJ30pKShzZWxmKTsnO1xcblxcbiAgdmFyIGJsb2IgPSBuZXcgd2luZG93LkJsb2IoW3NyY10sIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSk7XFxuICBpZiAob3B0aW9ucy5iYXJlKSB7XFxuICAgIHJldHVybiBibG9iO1xcbiAgfVxcblxcbiAgdmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCB8fCB3aW5kb3cubW96VVJMIHx8IHdpbmRvdy5tc1VSTDtcXG5cXG4gIHZhciB3b3JrZXJVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xcbiAgdmFyIHdvcmtlciA9IG5ldyB3aW5kb3cuV29ya2VyKHdvcmtlclVybCk7XFxuICB3b3JrZXIub2JqZWN0VVJMID0gd29ya2VyVXJsO1xcblxcbiAgcmV0dXJuIHdvcmtlcjtcXG59O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9ub2RlX21vZHVsZXMvd2Vid29ya2lmeS13ZWJwYWNrL2luZGV4LmpzP1wiKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvY29uc3RhbnRzL2V2ZW50cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci11dGlscy9zcmMvY29uc3RhbnRzL2V2ZW50cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbmNvbnN0IExPQURFUl9FVkVOVFMgPSB7XFxuICBMQURFUl9TVEFSVDogJ0xPQURFUl9TVEFSVCcsXFxuICBMT0FERVJfREFUQUxPQURFRDogJ0xPQURFUl9EQVRBTE9BREVEJyxcXG4gIExPQURFUl9DT01QTEVURTogJ0xPQURFUl9DT01QTEVURScsXFxuICBMT0FERVJfRVJST1I6ICdMT0FERVJfRVJST1InXFxufTtcXG5cXG5jb25zdCBERU1VWF9FVkVOVFMgPSB7XFxuICBERU1VWF9TVEFSVDogJ0RFTVVYX1NUQVJUJyxcXG4gIERFTVVYX0NPTVBMRVRFOiAnREVNVVhfQ09NUExFVEUnLFxcbiAgREVNVVhfRVJST1I6ICdERU1VWF9FUlJPUicsXFxuICBNRVRBREFUQV9QQVJTRUQ6ICdNRVRBREFUQV9QQVJTRUQnLFxcbiAgVklERU9fTUVUQURBVEFfQ0hBTkdFOiAnVklERU9fTUVUQURBVEFfQ0hBTkdFJyxcXG4gIEFVRElPX01FVEFEQVRBX0NIQU5HRTogJ0FVRElPX01FVEFEQVRBX0NIQU5HRScsXFxuICBNRURJQV9JTkZPOiAnTUVESUFfSU5GTydcXG59O1xcblxcbmNvbnN0IFJFTVVYX0VWRU5UUyA9IHtcXG4gIFJFTVVYX01FVEFEQVRBOiAnUkVNVVhfTUVUQURBVEEnLFxcbiAgUkVNVVhfTUVESUE6ICdSRU1VWF9NRURJQScsXFxuICBNRURJQV9TRUdNRU5UOiAnTUVESUFfU0VHTUVOVCcsXFxuICBSRU1VWF9FUlJPUjogJ1JFTVVYX0VSUk9SJyxcXG4gIElOSVRfU0VHTUVOVDogJ0lOSVRfU0VHTUVOVCcsXFxuICBERVRFQ1RfQ0hBTkdFX1NUUkVBTTogJ0RFVEVDVF9DSEFOR0VfU1RSRUFNJ1xcbn07XFxuXFxuY29uc3QgTVNFX0VWRU5UUyA9IHtcXG4gIFNPVVJDRV9VUERBVEVfRU5EOiAnU09VUkNFX1VQREFURV9FTkQnXFxuXFxuICAvLyBobHPkuJPmnIlldmVudHNcXG59O2NvbnN0IEhMU19FVkVOVFMgPSB7XFxuICBSRVRSWV9USU1FX0VYQ0VFREVEOiAnUkVUUllfVElNRV9FWENFRURFRCdcXG59O1xcblxcbmNvbnN0IENSWVRPX0VWRU5UUyA9IHtcXG4gIFNUQVJUX0RFQ1JZUFQ6ICdTVEFSVF9ERUNSWVBUJyxcXG4gIERFQ1JZUFRFRDogJ0RFQ1JZUFRFRCdcXG59O1xcbmNvbnN0IEFMTEVWRU5UUyA9IE9iamVjdC5hc3NpZ24oe30sIExPQURFUl9FVkVOVFMsIERFTVVYX0VWRU5UUywgUkVNVVhfRVZFTlRTLCBNU0VfRVZFTlRTLCBITFNfRVZFTlRTKTtcXG5cXG5jb25zdCBGbHZBbGxvd2VkRXZlbnRzID0gW107XFxuY29uc3QgSGxzQWxsb3dlZEV2ZW50cyA9IFtdO1xcblxcbmZvciAobGV0IGtleSBpbiBBTExFVkVOVFMpIHtcXG4gIGlmIChBTExFVkVOVFMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICBGbHZBbGxvd2VkRXZlbnRzLnB1c2goQUxMRVZFTlRTW2tleV0pO1xcbiAgfVxcbn1cXG5cXG5mb3IgKGxldCBrZXkgaW4gQUxMRVZFTlRTKSB7XFxuICBpZiAoQUxMRVZFTlRTLmhhc093blByb3BlcnR5KGtleSkpIHtcXG4gICAgSGxzQWxsb3dlZEV2ZW50cy5wdXNoKEFMTEVWRU5UU1trZXldKTtcXG4gIH1cXG59XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0ge1xcbiAgQUxMRVZFTlRTLFxcbiAgSExTX0VWRU5UUyxcXG4gIFJFTVVYX0VWRU5UUyxcXG4gIERFTVVYX0VWRU5UUyxcXG4gIE1TRV9FVkVOVFMsXFxuICBMT0FERVJfRVZFTlRTLFxcbiAgRmx2QWxsb3dlZEV2ZW50cyxcXG4gIEhsc0FsbG93ZWRFdmVudHMsXFxuICBDUllUT19FVkVOVFNcXG59O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9zcmMvY29uc3RhbnRzL2V2ZW50cy5qcz9cIil9LFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL2NvbnN0YW50cy93b3JrZXItY29tbWFuZHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvc3JjL2NvbnN0YW50cy93b3JrZXItY29tbWFuZHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5jb25zdCBDT05URVhUX0NPTU9NQU5EUyA9IGV4cG9ydHMuQ09OVEVYVF9DT01PTUFORFMgPSB7XFxuICBPTjogJ29uJyxcXG4gIE9OQ0U6ICdvbmNlJyxcXG4gIE9GRjogJ29mZicsXFxuICBFTUlUOiAnZW1pdCcsXFxuICBERVNUUk9ZOiAnZGVzdHJveSdcXG59O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9zcmMvY29uc3RhbnRzL3dvcmtlci1jb21tYW5kcy5qcz9cIil9LFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL2NvbnRleHQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvc3JjL2NvbnRleHQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKCdcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIF9tZWRpYUluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21vZGVscy9tZWRpYS1pbmZvICovIFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vZGVscy9tZWRpYS1pbmZvLmpzXCIpO1xcblxcbnZhciBfbWVkaWFJbmZvMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lZGlhSW5mbyk7XFxuXFxudmFyIF9ldmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBldmVudHMgKi8gXCIuLi8uLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qc1wiKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxcblxcbmNvbnN0IERJUkVDVF9FTUlUX0ZMQUcgPSBcXCdfX1RPX19cXCc7XFxuXFxuY2xhc3MgQ29udGV4dCB7XFxuICBjb25zdHJ1Y3RvcihhbGxvd2VkRXZlbnRzID0gW10pIHtcXG4gICAgdGhpcy5fZW1pdHRlciA9IG5ldyBfZXZlbnRzLkV2ZW50RW1pdHRlcigpO1xcbiAgICB0aGlzLl9pbnN0YW5jZU1hcCA9IHt9OyAvLyDmiYDmnInnmoTop6PnoIHmtYHnqIvlrp7kvotcXG4gICAgdGhpcy5fY2xzTWFwID0ge307IC8vIOaehOmAoOWHveaVsOeahG1hcFxcbiAgICB0aGlzLl9pbml0ZWQgPSBmYWxzZTtcXG4gICAgdGhpcy5tZWRpYUluZm8gPSBuZXcgX21lZGlhSW5mbzIuZGVmYXVsdCgpO1xcbiAgICB0aGlzLmFsbG93ZWRFdmVudHMgPSBhbGxvd2VkRXZlbnRzO1xcbiAgICB0aGlzLl9ob29rcyA9IHt9OyAvLyDms6jlhozlnKjkuovku7bliY0v5ZCO55qE6ZKp5a2Q77yM5L6L5aaCIGJlZm9yZShcXCdERU1VWF9DT01QTEVURVxcJylcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICog5LuO5LiK5LiL5paH5Lit6I635Y+W6Kej56CB5rWB56iL5a6e5L6L77yM5aaC5p6c5rKh5pyJ5a6e5L6L77yM5p6E6YCg5LiA5LiqXFxuICAgKiBAcGFyYW0gdGFnXFxuICAgKiBAcGFyYW0gYXJnc1xcbiAgICogQHJldHVybnMgeyp9XFxuICAgKi9cXG4gIGdldEluc3RhbmNlKHRhZykge1xcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlTWFwW3RhZ107XFxuICAgIGlmIChpbnN0YW5jZSkge1xcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoYCR7dGFnfeWunuS+i+WwmuacquWIneWni+WMlmApXFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8qKlxcbiAgICog5Yid5aeL5YyW5YW35L2T5a6e5L6LXFxuICAgKiBAcGFyYW0gdGFnXFxuICAgKiBAcGFyYW0gYXJnc1xcbiAgICovXFxuICBpbml0SW5zdGFuY2UodGFnLCAuLi5hcmdzKSB7XFxuICAgIGlmICh0aGlzLl9jbHNNYXBbdGFnXSkge1xcbiAgICAgIGNvbnN0IG5ld0luc3RhbmNlID0gbmV3IHRoaXMuX2Nsc01hcFt0YWddKC4uLmFyZ3MpO1xcbiAgICAgIHRoaXMuX2luc3RhbmNlTWFwW3RhZ10gPSBuZXdJbnN0YW5jZTtcXG4gICAgICBpZiAobmV3SW5zdGFuY2UuaW5pdCkge1xcbiAgICAgICAgbmV3SW5zdGFuY2UuaW5pdCgpOyAvLyBUT0RPOiBsaWZlY2lyY2xlXFxuICAgICAgfVxcbiAgICAgIHJldHVybiBuZXdJbnN0YW5jZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGFnfeacquWcqGNvbnRleHTkuK3ms6jlhoxgKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiDpgb/lhY3lpKfph4/nmoRpbml0SW5zdGFuY2XosIPnlKjvvIzliJ3lp4vljJbmiYDmnInnmoTnu4Tku7ZcXG4gICAqIEBwYXJhbSBjb25maWdcXG4gICAqL1xcbiAgaW5pdChjb25maWcpIHtcXG4gICAgaWYgKHRoaXMuX2luaXRlZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBmb3IgKGxldCB0YWcgaW4gdGhpcy5fY2xzTWFwKSB7XFxuICAgICAgLy8gaWYgbm90IGluaXRlZCwgaW5pdCBhbiBpbnN0YW5jZVxcbiAgICAgIGlmICh0aGlzLl9jbHNNYXAuaGFzT3duUHJvcGVydHkodGFnKSAmJiAhdGhpcy5faW5zdGFuY2VNYXBbdGFnXSkge1xcbiAgICAgICAgdGhpcy5pbml0SW5zdGFuY2UodGFnLCBjb25maWcpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICB0aGlzLl9pbml0ZWQgPSB0cnVlO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiDms6jlhozkuIDkuKrkuIrkuIvmlofmtYHnqIvvvIzmj5DkvpvlronlhajnmoTkuovku7blj5HpgIHmnLrliLZcXG4gICAqIEBwYXJhbSB0YWdcXG4gICAqIEBwYXJhbSBjbHNcXG4gICAqL1xcbiAgcmVnaXN0cnkodGFnLCBjbHMpIHtcXG4gICAgY29uc3QgZW1pdHRlciA9IHRoaXMuX2VtaXR0ZXI7XFxuICAgIGNvbnN0IGNoZWNrTWVzc2FnZU5hbWUgPSB0aGlzLl9pc01lc3NhZ2VOYW1lVmFsaWQuYmluZCh0aGlzKTtcXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XFxuICAgIGNvbnN0IGVuaGFuY2VkID0gY2xhc3MgZXh0ZW5kcyBjbHMge1xcbiAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcXG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcXG4gICAgICAgIHRoaXMub25jZUxpc3RlbmVycyA9IHt9O1xcbiAgICAgICAgdGhpcy5UQUcgPSB0YWc7XFxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gc2VsZjtcXG4gICAgICB9XFxuXFxuICAgICAgb24obWVzc2FnZU5hbWUsIGNhbGxiYWNrKSB7XFxuICAgICAgICBjaGVja01lc3NhZ2VOYW1lKG1lc3NhZ2VOYW1lKTtcXG5cXG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmVyc1ttZXNzYWdlTmFtZV0pIHtcXG4gICAgICAgICAgdGhpcy5saXN0ZW5lcnNbbWVzc2FnZU5hbWVdLnB1c2goY2FsbGJhY2spO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5saXN0ZW5lcnNbbWVzc2FnZU5hbWVdID0gW2NhbGxiYWNrXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGVtaXR0ZXIub24oYCR7bWVzc2FnZU5hbWV9JHtESVJFQ1RfRU1JVF9GTEFHfSR7dGFnfWAsIGNhbGxiYWNrKTsgLy8g5bu656uL5a6a5ZCR6YCa5L+h55uR5ZCsXFxuICAgICAgICByZXR1cm4gZW1pdHRlci5vbihtZXNzYWdlTmFtZSwgY2FsbGJhY2spO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiDlnKjmn5DkuKrkuovku7bop6blj5HliY3miafooYxcXG4gICAgICAgKiBAcGFyYW0gbWVzc2FnZU5hbWVcXG4gICAgICAgKiBAcGFyYW0gY2FsbGJhY2tcXG4gICAgICAgKi9cXG4gICAgICBiZWZvcmUobWVzc2FnZU5hbWUsIGNhbGxiYWNrKSB7XFxuICAgICAgICBjaGVja01lc3NhZ2VOYW1lKG1lc3NhZ2VOYW1lKTtcXG4gICAgICAgIGlmIChzZWxmLl9ob29rc1ttZXNzYWdlTmFtZV0pIHtcXG4gICAgICAgICAgc2VsZi5faG9va3NbbWVzc2FnZU5hbWVdLnB1c2goY2FsbGJhY2spO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc2VsZi5faG9va3NbbWVzc2FnZU5hbWVdID0gW2NhbGxiYWNrXTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgb25jZShtZXNzYWdlTmFtZSwgY2FsbGJhY2spIHtcXG4gICAgICAgIGNoZWNrTWVzc2FnZU5hbWUobWVzc2FnZU5hbWUpO1xcblxcbiAgICAgICAgaWYgKHRoaXMub25jZUxpc3RlbmVyc1ttZXNzYWdlTmFtZV0pIHtcXG4gICAgICAgICAgdGhpcy5vbmNlTGlzdGVuZXJzW21lc3NhZ2VOYW1lXS5wdXNoKGNhbGxiYWNrKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMub25jZUxpc3RlbmVyc1ttZXNzYWdlTmFtZV0gPSBbY2FsbGJhY2tdO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZW1pdHRlci5vbmNlKGAke21lc3NhZ2VOYW1lfSR7RElSRUNUX0VNSVRfRkxBR30ke3RhZ31gLCBjYWxsYmFjayk7XFxuICAgICAgICByZXR1cm4gZW1pdHRlci5vbmNlKG1lc3NhZ2VOYW1lLCBjYWxsYmFjayk7XFxuICAgICAgfVxcblxcbiAgICAgIGVtaXQobWVzc2FnZU5hbWUsIC4uLmFyZ3MpIHtcXG4gICAgICAgIGNoZWNrTWVzc2FnZU5hbWUobWVzc2FnZU5hbWUpO1xcblxcbiAgICAgICAgY29uc3QgYmVmb3JlTGlzdCA9IHNlbGYuX2hvb2tzID8gc2VsZi5faG9va3NbbWVzc2FnZU5hbWVdIDogbnVsbDtcXG5cXG4gICAgICAgIGlmIChiZWZvcmVMaXN0KSB7XFxuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBiZWZvcmVMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBiZWZvcmVMaXN0W2ldO1xcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBlbWl0dGVyLmVtaXQobWVzc2FnZU5hbWUsIC4uLmFyZ3MpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiDlrprlkJHlj5HpgIHnu5nmn5DkuKrnu4Tku7bljZXkvovnmoTmtojmga9cXG4gICAgICAgKiBAcGFyYW0gbWVzc2FnZU5hbWVcXG4gICAgICAgKiBAcGFyYW0gYXJnc1xcbiAgICAgICAqL1xcbiAgICAgIGVtaXRUbyh0YWcsIG1lc3NhZ2VOYW1lLCAuLi5hcmdzKSB7XFxuICAgICAgICBjaGVja01lc3NhZ2VOYW1lKG1lc3NhZ2VOYW1lKTtcXG5cXG4gICAgICAgIHJldHVybiBlbWl0dGVyLmVtaXQoYCR7bWVzc2FnZU5hbWV9JHtESVJFQ1RfRU1JVF9GTEFHfSR7dGFnfWAsIC4uLmFyZ3MpO1xcbiAgICAgIH1cXG5cXG4gICAgICBvZmYobWVzc2FnZU5hbWUsIGNhbGxiYWNrKSB7XFxuICAgICAgICBjaGVja01lc3NhZ2VOYW1lKG1lc3NhZ2VOYW1lKTtcXG4gICAgICAgIHJldHVybiBlbWl0dGVyLm9mZihtZXNzYWdlTmFtZSwgY2FsbGJhY2spO1xcbiAgICAgIH1cXG5cXG4gICAgICByZW1vdmVMaXN0ZW5lcnMoKSB7XFxuICAgICAgICBjb25zdCBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmJpbmQodGhpcy5saXN0ZW5lcnMpO1xcblxcbiAgICAgICAgZm9yIChsZXQgbWVzc2FnZU5hbWUgaW4gdGhpcy5saXN0ZW5lcnMpIHtcXG4gICAgICAgICAgaWYgKGhhc093bihtZXNzYWdlTmFtZSkpIHtcXG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmxpc3RlbmVyc1ttZXNzYWdlTmFtZV0gfHwgW107XFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tzW2ldO1xcbiAgICAgICAgICAgICAgZW1pdHRlci5vZmYobWVzc2FnZU5hbWUsIGNhbGxiYWNrKTtcXG4gICAgICAgICAgICAgIGVtaXR0ZXIub2ZmKGAke21lc3NhZ2VOYW1lfSR7RElSRUNUX0VNSVRfRkxBR30ke3RhZ31gLCBjYWxsYmFjayk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKGxldCBtZXNzYWdlTmFtZSBpbiB0aGlzLm9uY2VMaXN0ZW5lcnMpIHtcXG4gICAgICAgICAgaWYgKGhhc093bihtZXNzYWdlTmFtZSkpIHtcXG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLm9uY2VMaXN0ZW5lcnNbbWVzc2FnZU5hbWVdIHx8IFtdO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcXG4gICAgICAgICAgICAgIGVtaXR0ZXIub2ZmKG1lc3NhZ2VOYW1lLCBjYWxsYmFjayk7XFxuICAgICAgICAgICAgICBlbWl0dGVyLm9mZihgJHttZXNzYWdlTmFtZX0ke0RJUkVDVF9FTUlUX0ZMQUd9JHt0YWd9YCwgY2FsbGJhY2spO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiDlnKjnu4Tku7bplIDmr4Hml7bvvIzpu5jorqTlsIblroPms6jlhoznmoTkuovku7blhajpg6jljbjovb3vvIznoa7kv53kuI3kvJrpgKDmiJDlhoXlrZjms4TmvI9cXG4gICAgICAgKi9cXG4gICAgICBkZXN0cm95KCkge1xcbiAgICAgICAgLy8gc3RlcDEgdW5saXN0ZW4gZXZlbnRzXFxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycygpO1xcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcXG5cXG4gICAgICAgIC8vIHN0ZXAyIHJlbGVhc2UgZnJvbSBjb250ZXh0XFxuICAgICAgICBkZWxldGUgc2VsZi5faW5zdGFuY2VNYXBbdGFnXTtcXG4gICAgICAgIGlmIChzdXBlci5kZXN0cm95KSB7XFxuICAgICAgICAgIHJldHVybiBzdXBlci5kZXN0cm95KCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICB0aGlzLl9jbHNNYXBbdGFnXSA9IGVuaGFuY2VkO1xcblxcbiAgICAvKipcXG4gICAgICogZ2V0IGluc3RhbmNlIGltbWVkaWF0ZWx5XFxuICAgICAqIGUuZyBjb25zdCBpbnN0YW5jZSA9IGNvbnRleHQucmVnaXN0cnkodGFnLCBDbHMpKGNvbmZpZylcXG4gICAgICogKi9cXG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XFxuICAgICAgcmV0dXJuIHRoaXMuaW5pdEluc3RhbmNlKHRhZywgLi4uYXJncyk7XFxuICAgIH07XFxuICB9XFxuXFxuICAvKipcXG4gICAqIOWvueWtmOWcqOeahOWunuS+i+i/m+ihjFxcbiAgICovXFxuICBkZXN0cm95SW5zdGFuY2VzKCkge1xcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9pbnN0YW5jZU1hcCkuZm9yRWFjaCh0YWcgPT4ge1xcbiAgICAgIGlmICh0aGlzLl9pbnN0YW5jZU1hcFt0YWddLmRlc3Ryb3kpIHtcXG4gICAgICAgIHRoaXMuX2luc3RhbmNlTWFwW3RhZ10uZGVzdHJveSgpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIOe8luino+eggea1geeoi+aXoOmcgOWFs+azqOS6i+S7tueahOino+e7kVxcbiAgICovXFxuICBkZXN0cm95KCkge1xcbiAgICB0aGlzLl9lbWl0dGVyID0gbnVsbDtcXG4gICAgdGhpcy5hbGxvd2VkRXZlbnRzID0gW107XFxuICAgIHRoaXMuX2Nsc01hcCA9IG51bGw7XFxuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xcbiAgICB0aGlzLl9ob29rcyA9IG51bGw7XFxuICAgIHRoaXMuZGVzdHJveUluc3RhbmNlcygpO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiDlr7nkv6HpgZPov5vooYzmlLbmi6JcXG4gICAqIEBwYXJhbSBtZXNzYWdlTmFtZVxcbiAgICogQHByaXZhdGVcXG4gICAqL1xcbiAgX2lzTWVzc2FnZU5hbWVWYWxpZChtZXNzYWdlTmFtZSkge1xcbiAgICBpZiAoIXRoaXMuYWxsb3dlZEV2ZW50cy5pbmRleE9mKG1lc3NhZ2VOYW1lKSA8IDApIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVnaXN0ZXJlZCBtZXNzYWdlIG5hbWU6ICR7bWVzc2FnZU5hbWV9YCk7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gQ29udGV4dDtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItdXRpbHMvc3JjL2NvbnRleHQuanM/Jyl9LFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL2NyeXB0by9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXV0aWxzL3NyYy9jcnlwdG8vaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICAgIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIF9ldmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9jb25zdGFudHMvZXZlbnRzICovIFxcXCIuLi94Z3BsYXllci11dGlscy9zcmMvY29uc3RhbnRzL2V2ZW50cy5qc1xcXCIpO1xcblxcbnZhciBfZXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50cyk7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG5jb25zdCBDUllUT19FVkVOVFMgPSBfZXZlbnRzMi5kZWZhdWx0LkNSWVRPX0VWRU5UUztcXG5jbGFzcyBDcnlwdG8ge1xcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcXG4gICAgICAgIHRoaXMuaW5wdXRCdWZmZXIgPSBjb25maWcuaW5wdXRidWZmZXI7XFxuICAgICAgICB0aGlzLm91dHB1dEJ1ZmZlciA9IGNvbmZpZy5vdXRwdXRidWZmZXI7XFxuICAgICAgICB0aGlzLmtleSA9IGNvbmZpZy5rZXk7XFxuICAgICAgICB0aGlzLml2ID0gY29uZmlnLml2O1xcbiAgICAgICAgdGhpcy5tZXRob2QgPSBjb25maWcubWV0aG9kO1xcblxcbiAgICAgICAgdGhpcy5jcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0bztcXG4gICAgfVxcblxcbiAgICBpbml0KCkge1xcbiAgICAgICAgdGhpcy5vbihDUllUT19FVkVOVFMuU1RBUlRfREVDUllQVCwgdGhpcy5kZWNyaXB0LmJpbmQodGhpcykpO1xcbiAgICB9XFxuXFxuICAgIGRlY3JpcHQoKSB7XFxuICAgICAgICBpZiAoIXRoaXMuYWVza2V5KSB7XFxuICAgICAgICAgICAgbGV0IHNia2V5ID0gdGhpcy5jcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3JywgdGhpcy5rZXkuYnVmZmVyLCB7IG5hbWU6ICdBRVMtQ0JDJyB9LCBmYWxzZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XFxuICAgICAgICAgICAgc2JrZXkudGhlbihrZXkgPT4ge1xcbiAgICAgICAgICAgICAgICB0aGlzLmFlc2tleSA9IGtleTtcXG4gICAgICAgICAgICAgICAgdGhpcy5kZWNyaXB0RGF0YSgpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLmRlY3JpcHREYXRhKCk7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgZGVjcmlwdERhdGEoKSB7XFxuICAgICAgICBsZXQgaW5wdXRidWZmZXIgPSB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKHRoaXMuaW5wdXRCdWZmZXIpO1xcbiAgICAgICAgbGV0IG91dHB1dGJ1ZmZlciA9IHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UodGhpcy5vdXRwdXRCdWZmZXIpO1xcbiAgICAgICAgbGV0IGRhdGEgPSBpbnB1dGJ1ZmZlci5zaGlmdCgpO1xcbiAgICAgICAgaWYgKGRhdGEpIHtcXG4gICAgICAgICAgICB0aGlzLmNyeXB0by5zdWJ0bGUuZGVjcnlwdCh7IG5hbWU6ICdBRVMtQ0JDJywgaXY6IHRoaXMuaXYuYnVmZmVyIH0sIHRoaXMuYWVza2V5LCBkYXRhKS50aGVuKHJlcyA9PiB7XFxuICAgICAgICAgICAgICAgIG91dHB1dGJ1ZmZlci5wdXNoKG5ldyBVaW50OEFycmF5KHJlcykpO1xcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoQ1JZVE9fRVZFTlRTLkRFQ1JZUFRFRCk7XFxuICAgICAgICAgICAgICAgIHRoaXMuZGVjcmlwdERhdGEoZGF0YSk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuZXhwb3J0cy5kZWZhdWx0ID0gQ3J5cHRvO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9zcmMvY3J5cHRvL2luZGV4LmpzP1wiKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvZW52L2lzbGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXV0aWxzL3NyYy9lbnYvaXNsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKCdcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuY29uc3QgbGUgPSBmdW5jdGlvbiAoKSB7XFxuICBjb25zdCBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMik7XFxuICBuZXcgRGF0YVZpZXcoYnVmKS5zZXRJbnQxNigwLCAyNTYsIHRydWUpOyAvLyBsaXR0bGUtZW5kaWFuIHdyaXRlXFxuICByZXR1cm4gbmV3IEludDE2QXJyYXkoYnVmKVswXSA9PT0gMjU2OyAvLyBwbGF0Zm9ybS1zcGVjIHJlYWQsIGlmIGVxdWFsIHRoZW4gTEVcXG59KCk7XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gbGU7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL3NyYy9lbnYvaXNsZS5qcz8nKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvZW52L3NuaWZmZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXV0aWxzL3NyYy9lbnYvc25pZmZlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5jb25zdCBsZSA9IGZ1bmN0aW9uICgpIHtcXG4gIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigyKTtcXG4gIG5ldyBEYXRhVmlldyhidWYpLnNldEludDE2KDAsIDI1NiwgdHJ1ZSk7IC8vIGxpdHRsZS1lbmRpYW4gd3JpdGVcXG4gIHJldHVybiBuZXcgSW50MTZBcnJheShidWYpWzBdID09PSAyNTY7IC8vIHBsYXRmb3JtLXNwZWMgcmVhZCwgaWYgZXF1YWwgdGhlbiBMRVxcbn0oKTtcXG5cXG5jb25zdCBzbmlmZmVyID0ge1xcbiAgZ2V0IGRldmljZSgpIHtcXG4gICAgbGV0IHIgPSBzbmlmZmVyLm9zO1xcbiAgICByZXR1cm4gci5pc1BjID8gJ3BjJyA6IHIuaXNUYWJsZXQgPyAndGFibGV0JyA6ICdtb2JpbGUnO1xcbiAgfSxcXG4gIGdldCBicm93c2VyKCkge1xcbiAgICBsZXQgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XFxuICAgIGxldCByZWcgPSB7XFxuICAgICAgaWU6IC9ydjooW1xcXFxkLl0rKVxcXFwpIGxpa2UgZ2Vja28vLFxcbiAgICAgIGZpcmZveDogL2ZpcmVmb3hcXFxcLyhbXFxcXGQuXSspLyxcXG4gICAgICBjaHJvbWU6IC9jaHJvbWVcXFxcLyhbXFxcXGQuXSspLyxcXG4gICAgICBvcGVyYTogL29wZXJhLihbXFxcXGQuXSspLyxcXG4gICAgICBzYWZhcmk6IC92ZXJzaW9uXFxcXC8oW1xcXFxkLl0rKS4qc2FmYXJpL1xcbiAgICB9O1xcbiAgICByZXR1cm4gW10uY29uY2F0KE9iamVjdC5rZXlzKHJlZykuZmlsdGVyKGtleSA9PiByZWdba2V5XS50ZXN0KHVhKSkpWzBdO1xcbiAgfSxcXG4gIGdldCBvcygpIHtcXG4gICAgbGV0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcXG4gICAgbGV0IGlzV2luZG93c1Bob25lID0gLyg/OldpbmRvd3MgUGhvbmUpLy50ZXN0KHVhKTtcXG4gICAgbGV0IGlzU3ltYmlhbiA9IC8oPzpTeW1iaWFuT1MpLy50ZXN0KHVhKSB8fCBpc1dpbmRvd3NQaG9uZTtcXG4gICAgbGV0IGlzQW5kcm9pZCA9IC8oPzpBbmRyb2lkKS8udGVzdCh1YSk7XFxuICAgIGxldCBpc0ZpcmVGb3ggPSAvKD86RmlyZWZveCkvLnRlc3QodWEpO1xcbiAgICBsZXQgaXNUYWJsZXQgPSAvKD86aVBhZHxQbGF5Qm9vaykvLnRlc3QodWEpIHx8IGlzQW5kcm9pZCAmJiAhLyg/Ok1vYmlsZSkvLnRlc3QodWEpIHx8IGlzRmlyZUZveCAmJiAvKD86VGFibGV0KS8udGVzdCh1YSk7XFxuICAgIGxldCBpc1Bob25lID0gLyg/OmlQaG9uZSkvLnRlc3QodWEpICYmICFpc1RhYmxldDtcXG4gICAgbGV0IGlzUGMgPSAhaXNQaG9uZSAmJiAhaXNBbmRyb2lkICYmICFpc1N5bWJpYW47XFxuICAgIHJldHVybiB7XFxuICAgICAgaXNUYWJsZXQsXFxuICAgICAgaXNQaG9uZSxcXG4gICAgICBpc0FuZHJvaWQsXFxuICAgICAgaXNQYyxcXG4gICAgICBpc1N5bWJpYW4sXFxuICAgICAgaXNXaW5kb3dzUGhvbmUsXFxuICAgICAgaXNGaXJlRm94XFxuICAgIH07XFxuICB9LFxcblxcbiAgZ2V0IGlzTGUoKSB7XFxuICAgIHJldHVybiBsZTtcXG4gIH1cXG59O1xcblxcbmV4cG9ydHMuZGVmYXVsdCA9IHNuaWZmZXI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL3NyYy9lbnYvc25pZmZlci5qcz9cIil9LFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL2Vudi91dGY4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci11dGlscy9zcmMvZW52L3V0ZjguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuY2xhc3MgVVRGOCB7XFxuICBzdGF0aWMgZGVjb2RlKHVpbnQ4YXJyYXkpIHtcXG4gICAgY29uc3Qgb3V0ID0gW107XFxuICAgIGNvbnN0IGlucHV0ID0gdWludDhhcnJheTtcXG4gICAgbGV0IGkgPSAwO1xcbiAgICBjb25zdCBsZW5ndGggPSB1aW50OGFycmF5Lmxlbmd0aDtcXG5cXG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcXG4gICAgICBpZiAoaW5wdXRbaV0gPCAweDgwKSB7XFxuICAgICAgICBvdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGlucHV0W2ldKSk7XFxuICAgICAgICArK2k7XFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICB9IGVsc2UgaWYgKGlucHV0W2ldIDwgMHhDMCkge1xcbiAgICAgICAgLy8gZmFsbHRocm91Z2hcXG4gICAgICB9IGVsc2UgaWYgKGlucHV0W2ldIDwgMHhFMCkge1xcbiAgICAgICAgaWYgKFVURjguX2NoZWNrQ29udGludWF0aW9uKGlucHV0LCBpLCAxKSkge1xcbiAgICAgICAgICBjb25zdCB1Y3M0ID0gKGlucHV0W2ldICYgMHgxRikgPDwgNiB8IGlucHV0W2kgKyAxXSAmIDB4M0Y7XFxuICAgICAgICAgIGlmICh1Y3M0ID49IDB4ODApIHtcXG4gICAgICAgICAgICBvdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHVjczQgJiAweEZGRkYpKTtcXG4gICAgICAgICAgICBpICs9IDI7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKGlucHV0W2ldIDwgMHhGMCkge1xcbiAgICAgICAgaWYgKFVURjguX2NoZWNrQ29udGludWF0aW9uKGlucHV0LCBpLCAyKSkge1xcbiAgICAgICAgICBjb25zdCB1Y3M0ID0gKGlucHV0W2ldICYgMHhGKSA8PCAxMiB8IChpbnB1dFtpICsgMV0gJiAweDNGKSA8PCA2IHwgaW5wdXRbaSArIDJdICYgMHgzRjtcXG4gICAgICAgICAgaWYgKHVjczQgPj0gMHg4MDAgJiYgKHVjczQgJiAweEY4MDApICE9PSAweEQ4MDApIHtcXG4gICAgICAgICAgICBvdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHVjczQgJiAweEZGRkYpKTtcXG4gICAgICAgICAgICBpICs9IDM7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKGlucHV0W2ldIDwgMHhGOCkge1xcbiAgICAgICAgaWYgKFVURjguX2NoZWNrQ29udGludWF0aW9uKGlucHV0LCBpLCAzKSkge1xcbiAgICAgICAgICBsZXQgdWNzNCA9IChpbnB1dFtpXSAmIDB4NykgPDwgMTggfCAoaW5wdXRbaSArIDFdICYgMHgzRikgPDwgMTIgfCAoaW5wdXRbaSArIDJdICYgMHgzRikgPDwgNiB8IGlucHV0W2kgKyAzXSAmIDB4M0Y7XFxuICAgICAgICAgIGlmICh1Y3M0ID4gMHgxMDAwMCAmJiB1Y3M0IDwgMHgxMTAwMDApIHtcXG4gICAgICAgICAgICB1Y3M0IC09IDB4MTAwMDA7XFxuICAgICAgICAgICAgb3V0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSh1Y3M0ID4+PiAxMCB8IDB4RDgwMCkpO1xcbiAgICAgICAgICAgIG91dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUodWNzNCAmIDB4M0ZGIHwgMHhEQzAwKSk7XFxuICAgICAgICAgICAgaSArPSA0O1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIG91dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSk7XFxuICAgICAgKytpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBvdXQuam9pbignJyk7XFxuICB9XFxuXFxuICBzdGF0aWMgX2NoZWNrQ29udGludWF0aW9uKHVpbnQ4YXJyYXksIHN0YXJ0LCBjaGVja0xlbmd0aCkge1xcbiAgICBsZXQgYXJyYXkgPSB1aW50OGFycmF5O1xcbiAgICBpZiAoc3RhcnQgKyBjaGVja0xlbmd0aCA8IGFycmF5Lmxlbmd0aCkge1xcbiAgICAgIHdoaWxlIChjaGVja0xlbmd0aC0tKSB7XFxuICAgICAgICBpZiAoKGFycmF5Wysrc3RhcnRdICYgMHhDMCkgIT09IDB4ODApIHtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gVVRGODtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItdXRpbHMvc3JjL2Vudi91dGY4LmpzP1wiKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvbW9iaWxlL2F1ZGlvLWNvbnRleHQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvYXVkaW8tY29udGV4dC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKCdcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIF9ldmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBldmVudHMgKi8gXCIuLi8uLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qc1wiKTtcXG5cXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xcblxcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFxuY2xhc3MgQXVkaW9DdHggZXh0ZW5kcyBfZXZlbnRzMi5kZWZhdWx0IHtcXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xcbiAgICBzdXBlcigpO1xcbiAgICB0aGlzLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyk7XFxuICAgIGxldCBBdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XFxuICAgIHRoaXMuY29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcXG4gICAgdGhpcy5nYWluTm9kZSA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XFxuICAgIHRoaXMuZ2Fpbk5vZGUuY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO1xcbiAgICB0aGlzLm1ldGEgPSB1bmRlZmluZWQ7XFxuICAgIHRoaXMuc2FtcGxlcyA9IFtdO1xcbiAgICB0aGlzLnByZWxvYWRUaW1lID0gdGhpcy5jb25maWcucHJlbG9hZFRpbWUgfHwgMztcXG4gICAgdGhpcy5kdXJhdGlvbiA9IDA7XFxuXFxuICAgIHRoaXMuX2N1cnJlbnRCdWZmZXIgPSB1bmRlZmluZWQ7XFxuICAgIHRoaXMuX25leHRCdWZmZXIgPSB1bmRlZmluZWQ7XFxuICAgIHRoaXMuX2xhc3RwdHMgPSB1bmRlZmluZWQ7XFxuICAgIHRoaXMuX3ByZURlY29kZSA9IFtdO1xcbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IDA7XFxuICAgIHRoaXMuX2RlY29kaW5nID0gZmFsc2U7XFxuICAgIC8vIOiusOW9leWklumDqOS8oOi+k+eahOeKtuaAgVxcbiAgICB0aGlzLl9wbGF5ZWQgPSBmYWxzZTtcXG4gIH1cXG5cXG4gIGdldCBjdXJyZW50VGltZSgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUaW1lO1xcbiAgfVxcblxcbiAgZGVjb2RlQXVkaW8oYXVkaW9UcmFjaykge1xcbiAgICBsZXQgeyBzYW1wbGVzIH0gPSBhdWRpb1RyYWNrO1xcbiAgICBsZXQgZGF0YSA9IHNhbXBsZXM7XFxuICAgIGF1ZGlvVHJhY2suc2FtcGxlcyA9IFtdO1xcbiAgICB0aGlzLnNldEF1ZGlvRGF0YShkYXRhKTtcXG4gIH1cXG4gIHNldEF1ZGlvRGF0YShkYXRhKSB7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xcbiAgICAgIGRhdGFbaV0ucHRzID0gZGF0YVtpXS5wdHMgPT09IHVuZGVmaW5lZCA/IGRhdGFbaV0uZHRzIDogZGF0YVtpXS5wdHM7XFxuICAgICAgdGhpcy5fcHJlRGVjb2RlLnB1c2goZGF0YVtpXSk7XFxuICAgIH1cXG4gICAgaWYgKHRoaXMuX3ByZURlY29kZS5sZW5ndGggPiAwKSB7XFxuICAgICAgaWYgKHRoaXMuX2xhc3RwdHMgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgdGhpcy5fbGFzdHB0cyA9IHRoaXMuX3ByZURlY29kZVswXS5wdHM7XFxuICAgICAgfVxcbiAgICAgIGlmICgodGhpcy5fcHJlRGVjb2RlW3RoaXMuX3ByZURlY29kZS5sZW5ndGggLSAxXS5wdHMgLSB0aGlzLl9sYXN0cHRzKSAvIDEwMDAgPiB0aGlzLnByZWxvYWRUaW1lKSB7XFxuICAgICAgICB0aGlzLmRlY29kZUFBQygpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZGVjb2RlQUFDKCkge1xcbiAgICBpZiAodGhpcy5fZGVjb2RpbmcpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgdGhpcy5fZGVjb2RpbmcgPSB0cnVlO1xcbiAgICBsZXQgZGF0YSA9IHRoaXMuX3ByZURlY29kZTtcXG4gICAgbGV0IHNhbXBsZXMgPSBbXTtcXG4gICAgbGV0IF90aGlzID0gdGhpcztcXG4gICAgbGV0IHNhbXBsZSA9IGRhdGEuc2hpZnQoKTtcXG4gICAgd2hpbGUgKHNhbXBsZSkge1xcbiAgICAgIGxldCBzYW1wbGVEYXRhID0gQXVkaW9DdHguZ2V0QUFDRGF0YSh0aGlzLm1ldGEsIHNhbXBsZSk7XFxuICAgICAgc2FtcGxlcy5wdXNoKHNhbXBsZURhdGEpO1xcbiAgICAgIHRoaXMuX2xhc3RwdHMgPSBzYW1wbGUucHRzO1xcbiAgICAgIHNhbXBsZSA9IGRhdGEuc2hpZnQoKTtcXG4gICAgfVxcbiAgICBsZXQgYnVmZmVyID0gQXVkaW9DdHguY29tYmlsZURhdGEoc2FtcGxlcyk7XFxuICAgIHRyeSB7XFxuICAgICAgdGhpcy5jb250ZXh0LmRlY29kZUF1ZGlvRGF0YShidWZmZXIuYnVmZmVyLCBmdW5jdGlvbiAoYnVmZmVyKSB7XFxuICAgICAgICBsZXQgYXVkaW9Tb3VyY2UgPSBfdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xcbiAgICAgICAgYXVkaW9Tb3VyY2UuYnVmZmVyID0gYnVmZmVyO1xcbiAgICAgICAgYXVkaW9Tb3VyY2Uub25lbmRlZCA9IF90aGlzLm9uU291cmNlRW5kZWQuYmluZChfdGhpcyk7XFxuICAgICAgICBfdGhpcy5zYW1wbGVzLnB1c2goe1xcbiAgICAgICAgICB0aW1lOiBfdGhpcy5kdXJhdGlvbixcXG4gICAgICAgICAgZHVyYXRpb246IGJ1ZmZlci5kdXJhdGlvbixcXG4gICAgICAgICAgZGF0YTogYXVkaW9Tb3VyY2VcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgX3RoaXMuZHVyYXRpb24gKz0gYnVmZmVyLmR1cmF0aW9uO1xcblxcbiAgICAgICAgaWYgKCFfdGhpcy5fY3VycmVudEJ1ZmZlcikge1xcbiAgICAgICAgICBfdGhpcy5fY3VycmVudEJ1ZmZlciA9IF90aGlzLmdldFRpbWVCdWZmZXIoX3RoaXMuY3VycmVudFRpbWUpO1xcblxcbiAgICAgICAgICBpZiAoX3RoaXMuX3BsYXllZCkge1xcbiAgICAgICAgICAgIF90aGlzLnBsYXkoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFfdGhpcy5fbmV4dEJ1ZmZlciAmJiBfdGhpcy5fY3VycmVudEJ1ZmZlcikge1xcbiAgICAgICAgICBfdGhpcy5fbmV4dEJ1ZmZlciA9IF90aGlzLmdldFRpbWVCdWZmZXIoX3RoaXMuY3VycmVudFRpbWUgKyBfdGhpcy5fY3VycmVudEJ1ZmZlci5kdXJhdGlvbik7XFxuICAgICAgICB9XFxuICAgICAgICBfdGhpcy5fZGVjb2RpbmcgPSBmYWxzZTtcXG5cXG4gICAgICAgIGlmICgoX3RoaXMuX3ByZURlY29kZS5sZW5ndGggPiAwICYmIF90aGlzLl9wcmVEZWNvZGVbX3RoaXMuX3ByZURlY29kZS5sZW5ndGggLSAxXS5wdHMgLSBfdGhpcy5fbGFzdHB0cykgLyAxMDAwID49IF90aGlzLnByZWxvYWRUaW1lKSB7XFxuICAgICAgICAgIF90aGlzLmRlY29kZUFBQygpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XFxuICAgIH1cXG4gIH1cXG5cXG4gIG9uU291cmNlRW5kZWQoKSB7XFxuICAgIGlmICghdGhpcy5fbmV4dEJ1ZmZlciB8fCAhdGhpcy5fcGxheWVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGxldCBhdWRpb1NvdXJjZSA9IHRoaXMuX25leHRCdWZmZXIuZGF0YTtcXG4gICAgYXVkaW9Tb3VyY2Uuc3RhcnQoKTtcXG4gICAgYXVkaW9Tb3VyY2UuY29ubmVjdCh0aGlzLmdhaW5Ob2RlKTtcXG4gICAgdGhpcy5fY3VycmVudEJ1ZmZlciA9IHRoaXMuX25leHRCdWZmZXI7XFxuICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gdGhpcy5fY3VycmVudEJ1ZmZlci50aW1lO1xcbiAgICB0aGlzLl9uZXh0QnVmZmVyID0gdGhpcy5nZXRUaW1lQnVmZmVyKHRoaXMuY3VycmVudFRpbWUpO1xcbiAgICBpZiAodGhpcy5fY3VycmVudEJ1ZmZlcikge1xcbiAgICAgIHRoaXMuX25leHRCdWZmZXIgPSB0aGlzLmdldFRpbWVCdWZmZXIodGhpcy5jdXJyZW50VGltZSArIHRoaXMuX2N1cnJlbnRCdWZmZXIuZHVyYXRpb24pO1xcbiAgICB9XFxuICAgIHRoaXMuZW1pdChcXCdBVURJT19TT1VSQ0VfRU5EXFwnKTtcXG4gIH1cXG5cXG4gIHBsYXkoKSB7XFxuICAgIHRoaXMuX3BsYXllZCA9IHRydWU7XFxuICAgIGlmICghdGhpcy5fY3VycmVudEJ1ZmZlcikge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBsZXQgYXVkaW9Tb3VyY2UgPSB0aGlzLl9jdXJyZW50QnVmZmVyLmRhdGE7XFxuICAgIGF1ZGlvU291cmNlLmNvbm5lY3QodGhpcy5nYWluTm9kZSk7XFxuICAgIGF1ZGlvU291cmNlLnN0YXJ0KCk7XFxuICB9XFxuXFxuICBnZXRUaW1lQnVmZmVyKHRpbWUpIHtcXG4gICAgbGV0IHJldDtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNhbXBsZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICBsZXQgc2FtcGxlID0gdGhpcy5zYW1wbGVzW2ldO1xcbiAgICAgIGlmIChzYW1wbGUudGltZSA8PSB0aW1lICYmIHNhbXBsZS50aW1lICsgc2FtcGxlLmR1cmF0aW9uID4gdGltZSkge1xcbiAgICAgICAgcmV0ID0gc2FtcGxlO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiByZXQ7XFxuICB9XFxuXFxuICBzZXRBdWRpb01ldGFEYXRhKG1ldGEpIHtcXG4gICAgdGhpcy5tZXRhID0gbWV0YTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXRBQUNEYXRhKG1ldGEsIHNhbXBsZSkge1xcbiAgICBsZXQgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc2FtcGxlLmRhdGEuYnl0ZUxlbmd0aCArIDcpO1xcbiAgICBsZXQgYWR0cyA9IEF1ZGlvQ3R4LmdldEFkdHMobWV0YSwgc2FtcGxlLmRhdGEpO1xcbiAgICBidWZmZXIuc2V0KGFkdHMpO1xcbiAgICBidWZmZXIuc2V0KHNhbXBsZS5kYXRhLCA3KTtcXG4gICAgcmV0dXJuIGJ1ZmZlcjtcXG4gIH1cXG5cXG4gIHN0YXRpYyBjb21iaWxlRGF0YShzYW1wbGVzKSB7XFxuICAgIC8vIGdldCBsZW5ndGhcXG4gICAgbGV0IGxlbmd0aCA9IDA7XFxuICAgIGZvciAobGV0IGkgPSAwLCBrID0gc2FtcGxlcy5sZW5ndGg7IGkgPCBrOyBpKyspIHtcXG4gICAgICBsZW5ndGggKz0gc2FtcGxlc1tpXS5ieXRlTGVuZ3RoO1xcbiAgICB9XFxuXFxuICAgIGxldCByZXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xcbiAgICBsZXQgb2Zmc2V0ID0gMDtcXG4gICAgLy8gY29tYmlsZSBkYXRhO1xcbiAgICBmb3IgKGxldCBpID0gMCwgayA9IHNhbXBsZXMubGVuZ3RoOyBpIDwgazsgaSsrKSB7XFxuICAgICAgcmV0LnNldChzYW1wbGVzW2ldLCBvZmZzZXQpO1xcbiAgICAgIG9mZnNldCArPSBzYW1wbGVzW2ldLmJ5dGVMZW5ndGg7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJldDtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXRBZHRzKG1ldGEsIGRhdGEpIHtcXG4gICAgbGV0IGFkdHMgPSBuZXcgVWludDhBcnJheSg3KTtcXG5cXG4gICAgLy8g6K6+572u5ZCM5q2l5L2NIDB4ZmZmIDEyYml0XFxuICAgIGFkdHNbMF0gPSAweGZmO1xcbiAgICBhZHRzWzFdID0gMHhmMDtcXG5cXG4gICAgLy8gT2JqZWN0IGRhdGEgKOayoeS7gOS5iOS6uueUqE1QRUctMuS6hu+8jEhMU+WSjEZMVuS5n+WFqOaYr01QRUctNO+8jOi/memHjOebtOaOpTApICAxYml0XFxuICAgIC8vIExldmVsIGFsd2F5cyAwMCAyYml0XFxuICAgIC8vIENSQyBhbHdheXMgMSAxYml0XFxuICAgIGFkdHNbMV0gPSBhZHRzWzFdIHwgMHgwMTtcXG5cXG4gICAgLy8gcHJvZmlsZSAyYml0XFxuICAgIGFkdHNbMl0gPSAweGMwICYgbWV0YS5vYmplY3RUeXBlIC0gMSA8PCA2O1xcblxcbiAgICAvL3NhbXBsZUZyZXF1ZW5jeUluZGV4XFxuICAgIGFkdHNbMl0gPSBhZHRzWzJdIHwgMHgzYyAmIG1ldGEuc2FtcGxlUmF0ZUluZGV4IDw8IDI7XFxuXFxuICAgIC8vcHJpdmF0ZSBiaXQgMCAxYml0XFxuICAgIC8vIGNoYW5lbCBjb25maWd1cmF0aW9uIDNiaXRcXG4gICAgYWR0c1syXSA9IGFkdHNbMl0gfCAweDAxICYgbWV0YS5jaGFubmVsQ291bnQgPj4gMjtcXG4gICAgYWR0c1szXSA9IDB4YzAgJiBtZXRhLmNoYW5uZWxDb3VudCA8PCA2O1xcblxcbiAgICAvLyBvcmlnaW5hbF9jb3B5OiAwIDFiaXRcXG4gICAgLy8gaG9tZTogMCAxYml0XFxuXFxuICAgIC8vIGFkdHNfdmFyaWFibGVfaGVhZGVyKClcXG4gICAgLy8gY29weXJpZ2h0ZWRfaWRfYml0IDAgMWJpdFxcbiAgICAvLyBjb3B5cmlnaHRlZF9pZF9zdGFydCAwIDFiaXRcXG5cXG4gICAgLy8gYWFjX2ZyYW1lX2xlbmd0aCAxM2JpdDtcXG4gICAgbGV0IGFhY2ZyYW1lbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoICsgNztcXG5cXG4gICAgYWR0c1szXSA9IGFkdHNbM10gfCAweDAzICYgYWFjZnJhbWVsZW5ndGggPj4gMTE7XFxuICAgIGFkdHNbNF0gPSAweGZmICYgYWFjZnJhbWVsZW5ndGggPj4gMztcXG4gICAgYWR0c1s1XSA9IDB4ZTAgJiBhYWNmcmFtZWxlbmd0aCA8PCA1O1xcblxcbiAgICAvLyBhZHRzX2J1ZmZlcl9mdWxsbmVzcyAweDdmZiAxMWJpdFxcbiAgICBhZHRzWzVdID0gYWR0c1s1XSB8IDB4MWY7XFxuICAgIGFkdHNbNl0gPSAweGZjO1xcblxcbiAgICAvLyBudW1iZXJfb2ZfcmF3X2RhdGFfYmxvY2tzX2luX2ZyYW1lIDAgMmJpdDtcXG4gICAgcmV0dXJuIGFkdHM7XFxuICB9XFxufVxcblxcbmV4cG9ydHMuZGVmYXVsdCA9IEF1ZGlvQ3R4O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9zcmMvbW9iaWxlL2F1ZGlvLWNvbnRleHQuanM/Jyl9LFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vYmlsZS9tb2JpbGUtdmlkZW8uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vYmlsZS9tb2JpbGUtdmlkZW8uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxudmFyIF92aWRlb0NvbnRleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3ZpZGVvLWNvbnRleHQgKi8gXFxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvdmlkZW8tY29udGV4dC5qc1xcXCIpO1xcblxcbnZhciBfdmlkZW9Db250ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZpZGVvQ29udGV4dCk7XFxuXFxudmFyIF9hdWRpb0NvbnRleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2F1ZGlvLWNvbnRleHQgKi8gXFxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvYXVkaW8tY29udGV4dC5qc1xcXCIpO1xcblxcbnZhciBfYXVkaW9Db250ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2F1ZGlvQ29udGV4dCk7XFxuXFxudmFyIF90aWNrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RpY2tlciAqLyBcXFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vYmlsZS90aWNrZXIuanNcXFwiKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxcblxcbi8qKlxcbiAqIOmfs+eUu+WQjOatpeiwg+WSjOWZqFxcbiAqL1xcbmNsYXNzIEFWUmVjb25jaWxlciB7XFxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xcbiAgICB0aGlzLmFDdHggPSBwcm9wcy5hQ3R4O1xcbiAgICB0aGlzLnZDdHggPSBwcm9wcy52Q3R4O1xcbiAgICB0aGlzLnZpZGVvID0gcHJvcHMudmlkZW87XFxuICAgIHRoaXMudGltZW91dElkID0gbnVsbDtcXG4gICAgdGhpcy5zdGFydCA9IG51bGw7XFxuICB9XFxuXFxuICBkb1JlY29uY2lsZSgpIHtcXG4gICAgY29uc3QgdkN1clRpbWUgPSAodGhpcy52aWRlby5jdXJyZW50VGltZSB8fCAwKSAqIDEwMDA7XFxuICAgIGNvbnN0IGFDdXJUaW1lID0gKHRoaXMuYUN0eC5jdXJyZW50VGltZSB8fCAwKSAqIDEwMDA7XFxuXFxuICAgIGNvbnN0IGdhcCA9IHZDdXJUaW1lIC0gYUN1clRpbWU7XFxuICAgIGlmICh0aGlzLnRpbWVvdXRJZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBpZiAoZ2FwID4gMjAwKSB7XFxuICAgICAgLy8gYXVkaW8gZGVsYXllZCBmb3IgbW9yZSB0aGFuIDEwMG1zXFxuICAgICAgY29uc29sZS5sb2coZ2FwKTtcXG4gICAgICB0aGlzLnZpZGVvLnN0YXJ0ICs9IGdhcDtcXG4gICAgICB0aGlzLnZDdHgucGF1c2UoKTtcXG4gICAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xcbiAgICAgICAgdGhpcy52Q3R4LnBsYXkoKTtcXG4gICAgICAgIHRoaXMudGltZW91dElkID0gbnVsbDtcXG4gICAgICB9LCBnYXApO1xcbiAgICB9IGVsc2UgaWYgKGdhcCA8IC0xMjApIHtcXG4gICAgICB0aGlzLnZDdHguY3VycmVudFRpbWUgPSB0aGlzLnZDdHguY3VycmVudFRpbWUgKyBNYXRoLmFicyhnYXApO1xcbiAgICB9XFxuICB9XFxuXFxuICBkZXN0cm95KCkge1xcbiAgICB0aGlzLmFDdHggPSBudWxsO1xcbiAgICB0aGlzLnZDdHggPSBudWxsO1xcbiAgfVxcbn1cXG5cXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcXG5jbGFzcyBNb2JpbGVWaWRlbyBleHRlbmRzIEhUTUxFbGVtZW50IHtcXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xcbiAgICBzdXBlcigpO1xcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xcbiAgICB0aGlzLnZDdHggPSBuZXcgX3ZpZGVvQ29udGV4dDIuZGVmYXVsdCgpO1xcbiAgICB0aGlzLmFDdHggPSBuZXcgX2F1ZGlvQ29udGV4dDIuZGVmYXVsdChjb25maWcpO1xcbiAgICB0aGlzLnRpY2tlciA9IG5ldyAoKDAsIF90aWNrZXIuZ2V0VGlja2VyKSgpKSgpO1xcbiAgICB0aGlzLmhpc3RvcnlUaW1lID0gMDtcXG4gICAgdGhpcy5yZWNvbmNpbGVyID0gbmV3IEFWUmVjb25jaWxlcih7XFxuICAgICAgdkN0eDogdGhpcy52Q3R4LFxcbiAgICAgIGFDdHg6IHRoaXMuYUN0eCxcXG4gICAgICB2aWRlbzogdGhpc1xcbiAgICB9KTtcXG4gICAgdGhpcy5oYW5kbGVBdWRpb1NvdXJjZUVuZCA9IHRoaXMuaGFuZGxlQXVkaW9Tb3VyY2VFbmQuYmluZCh0aGlzKTtcXG4gICAgdGhpcy5pbml0KCk7XFxuICB9XFxuXFxuICBpbml0KCkge1xcbiAgICB0aGlzLnZDdHgub25jYW5wbGF5ID0gKCkgPT4ge1xcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy52Q3R4LmNhbnZhcyk7XFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXFxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2FucGxheScpKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy50aWNrZXIuc3RhcnQoKCkgPT4ge1xcbiAgICAgIC8vXFxuICAgICAgaWYgKCF0aGlzLnN0YXJ0KSB7XFxuICAgICAgICB0aGlzLnN0YXJ0ID0gRGF0ZS5ub3coKTtcXG4gICAgICB9XFxuICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC0gdGhpcy5zdGFydDtcXG4gICAgICB0aGlzLnZDdHguX29uVGltZXIodGhpcy5fY3VycmVudFRpbWUpO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5hQ3R4Lm9uKCdBVURJT19TT1VSQ0VfRU5EJywgdGhpcy5oYW5kbGVBdWRpb1NvdXJjZUVuZCk7XFxuICB9XFxuXFxuICBoYW5kbGVBdWRpb1NvdXJjZUVuZCgpIHtcXG4gICAgY29uc29sZS5sb2codGhpcy5hQ3R4LmN1cnJlbnRUaW1lKTtcXG4gICAgdGhpcy5yZWNvbmNpbGVyLmRvUmVjb25jaWxlKCk7XFxuICB9XFxuXFxuICBfY2xlYW5CdWZmZXIoKSB7XFxuICAgIHRoaXMudkN0eC5jbGVhbkJ1ZmZlcigpO1xcbiAgfVxcblxcbiAgZGVzdHJveSgpIHtcXG4gICAgdGhpcy5yZWNvbmNpbGVyLmRlc3Ryb3koKTtcXG4gIH1cXG5cXG4gIG9uRGVtdXhDb21wbGV0ZSh2aWRlb1RyYWNrLCBhdWRpb1RyYWNrKSB7XFxuICAgIHRoaXMuYUN0eC5kZWNvZGVBdWRpbyhhdWRpb1RyYWNrKTtcXG4gICAgdGhpcy52Q3R4LmRlY29kZVZpZGVvKHZpZGVvVHJhY2spO1xcbiAgfVxcblxcbiAgc2V0QXVkaW9NZXRhKG1ldGEpIHtcXG4gICAgdGhpcy5hQ3R4LnNldEF1ZGlvTWV0YURhdGEobWV0YSk7XFxuICB9XFxuXFxuICBzZXRWaWRlb01ldGEobWV0YSkge1xcbiAgICB0aGlzLnZDdHguc2V0VmlkZW9NZXRhRGF0YShtZXRhKTtcXG4gIH1cXG5cXG4gIGdldCBjdXJyZW50VGltZSgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUaW1lIC8gMTAwMDtcXG4gIH1cXG5cXG4gIHBsYXkoKSB7XFxuICAgIC8vIGlmICghdGhpcy52Q3R4LilcXG4gICAgdGhpcy52Q3R4LnBsYXkoKTtcXG4gICAgdGhpcy5hQ3R4LnBsYXkoKTtcXG4gIH1cXG59XFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXFxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdtb2JpbGUtdmlkZW8nLCBNb2JpbGVWaWRlbyk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvbW9iaWxlLXZpZGVvLmpzP1wiKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvbW9iaWxlL3NvdXJjZWJ1ZmZlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci11dGlscy9zcmMvbW9iaWxlL3NvdXJjZWJ1ZmZlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbmNsYXNzIFNvdXJjZUJ1ZmZlciB7XFxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcXG4gICAgdGhpcy5jb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcpO1xcbiAgICB0aGlzLnR5cGUgPSB0aGlzLmNvbmZpZy50eXBlO1xcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xcbiAgICB0aGlzLmN1cnJlbnRHb3AgPSB1bmRlZmluZWQ7XFxuICAgIHRoaXMuX2xhc3RHZXQgPSB1bmRlZmluZWQ7XFxuICB9XFxuXFxuICBwdXNoKGZyYW1lKSB7XFxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd2aWRlbycpIHtcXG4gICAgICBpZiAoZnJhbWUuaXNLZXlmcmFtZSkge1xcbiAgICAgICAgbGV0IGN1cnJlbnRHb3AgPSB7XFxuICAgICAgICAgIHNhbXBsZXM6IFtdLFxcbiAgICAgICAgICBzdGFydDogZnJhbWUuZHRzLFxcbiAgICAgICAgICBlbmQ6IGZyYW1lLmR0cyxcXG4gICAgICAgICAgbmV4dEdvcDogdW5kZWZpbmVkXFxuICAgICAgICB9O1xcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEdvcCkge1xcbiAgICAgICAgICB0aGlzLmN1cnJlbnRHb3AubmV4dEdvcCA9IGN1cnJlbnRHb3A7XFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLmN1cnJlbnRHb3AgPSBjdXJyZW50R29wO1xcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaCh0aGlzLmN1cnJlbnRHb3ApO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5jdXJyZW50R29wKSB7XFxuICAgICAgICB0aGlzLmN1cnJlbnRHb3Auc2FtcGxlcy5wdXNoKGZyYW1lKTtcXG5cXG4gICAgICAgIGlmIChmcmFtZS5kdHMgPCB0aGlzLmN1cnJlbnRHb3Auc3RhcnQpIHtcXG4gICAgICAgICAgdGhpcy5jdXJyZW50R29wLnN0YXJ0ID0gZnJhbWUuZHRzO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGZyYW1lLmR0cyA+IHRoaXMuY3VycmVudEdvcC5lbmQpIHtcXG4gICAgICAgICAgdGhpcy5jdXJyZW50R29wLmVuZCA9IGZyYW1lLmR0cztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGdldCh0aW1lKSB7XFxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd2aWRlbycpIHtcXG4gICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoIDwgMSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGltZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBsZXQgc2FtcGxlID0gdGhpcy5fZ2V0TmV4dCgpO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIF9nZXROZXh0KCkge1xcbiAgICBpZiAoIXRoaXMuX2xhc3RHZXQpIHtcXG4gICAgICBsZXQgZ29wID0gdGhpcy5idWZmZXJbMF07XFxuICAgICAgaWYgKGdvcC5zYW1wbGVzLmxlbmd0aCA8IDEpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fbGFzdEdldCA9IHtcXG4gICAgICAgIGdvcCxcXG4gICAgICAgIGluZGV4OiAwXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gZ29wLnNhbXBsZXNbMF07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbGV0IGdvcCA9IHRoaXMuX2xhc3RHZXQuZ29wO1xcbiAgICAgIGxldCBzYW1wbGUgPSBnb3Auc2FtcGxlc1t0aGlzLl9sYXN0R2V0LmluZGV4ICsgMV07XFxuICAgICAgaWYgKHNhbXBsZSkge1xcbiAgICAgICAgdGhpcy5fbGFzdEdldC5pbmRleCA9IHRoaXMuX2xhc3RHZXQuaW5kZXggKyAxO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZ29wID0gZ29wLm5leHRHb3A7XFxuICAgICAgICBpZiAoIWdvcCB8fCBnb3Auc2FtcGxlcy5sZW5ndGggPCAxKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHNhbXBsZSA9IGdvcC5zYW1wbGVzWzBdO1xcbiAgICAgICAgdGhpcy5fbGFzdEdldCA9IHtcXG4gICAgICAgICAgZ29wLFxcbiAgICAgICAgICBpbmRleDogMFxcbiAgICAgICAgfTtcXG4gICAgICAgIHJldHVybiBzYW1wbGU7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICByZW1vdmUoc3RhcnQsIGVuZCkge1xcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoIDwgMCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBsZXQgaSA9IDA7XFxuICAgIGxldCBnb3AgPSB0aGlzLmJ1ZmZlclswXTtcXG4gICAgd2hpbGUgKGdvcCkge1xcbiAgICAgIGlmIChnb3AuZW5kIDwgZW5kICYmIGdvcC5zdGFydCA+PSBzdGFydCkge1xcbiAgICAgICAgZGVsZXRlIHRoaXMuYnVmZmVyW2ldO1xcbiAgICAgICAgZ29wID0gdGhpcy5idWZmZXJbaV07XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGkgKz0gMTtcXG4gICAgICAgIGdvcCA9IHRoaXMuYnVmZmVyW2ldO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBTb3VyY2VCdWZmZXI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvc291cmNlYnVmZmVyLmpzP1wiKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvbW9iaWxlL3RpY2tlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci11dGlscy9zcmMvbW9iaWxlL3RpY2tlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoJ1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG4vKipcXG4gKiBAYXV0aG9yIGZ1eXVoYW9AYnl0ZWRhbmNlLmNvbVxcbiAqL1xcblxcbmNsYXNzIFRpY2tlciB7XFxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XFxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMgfHwge30sIHtcXG4gICAgICBpbnRlcnZhbDogMTZcXG4gICAgfSk7XFxuXFxuICAgIHRoaXMuY2FsbGJhY2tzID0gW107XFxuICB9XFxuXFxuICBzdGFydCguLi5jYWxsYmFja3MpIHtcXG4gICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XFxuICB9XFxuXFxuICBvblRpY2soKSB7XFxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5jYWxsYmFja3NbaV07XFxuICAgICAgY2FsbGJhY2soKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgc2V0SW50ZXJ2YWwoaW50ZXJ2YWwpIHtcXG4gICAgdGhpcy5vcHRpb25zLmludGVydmFsID0gaW50ZXJ2YWw7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiB0aWNrZXIgdXNlIHJlcXVlc3RBbmltYXRpb25GcmFtZVxcbiAqL1xcbmNsYXNzIFJhZlRpY2tlciBleHRlbmRzIFRpY2tlciB7XFxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xcbiAgICBzdXBlcihwcm9wcyk7XFxuICAgIHRoaXMucHJldiA9IG51bGw7XFxuICAgIHRoaXMudGltZXJJZCA9IG51bGw7XFxuICAgIHRoaXMuX3N1YlRpbWVySWQgPSBudWxsO1xcblxcbiAgICB0aGlzLl90aWNrRnVuYyA9IFJhZlRpY2tlci5nZXRUaWNrRnVuYygpO1xcbiAgICB0aGlzLnRpY2sgPSB0aGlzLnRpY2suYmluZCh0aGlzKTtcXG4gIH1cXG5cXG4gIHN0YXJ0KC4uLmNhbGxiYWNrcykge1xcbiAgICBzdXBlci5zdGFydCguLi5jYWxsYmFja3MpO1xcbiAgICB0aGlzLnRpY2soKTtcXG4gIH1cXG5cXG4gIHRpY2sodGltZXN0YW1wKSB7XFxuICAgIHRoaXMubmV4dFRpY2soKTtcXG4gICAgdGhpcy5vblRpY2soKTtcXG4gIH1cXG5cXG4gIG5leHRUaWNrKCkge1xcbiAgICBjb25zdCB7IF90aWNrRnVuYyB9ID0gdGhpcztcXG4gICAgdGhpcy50aW1lcklkID0gX3RpY2tGdW5jKHRoaXMudGljayk7XFxuICB9XFxuXFxuICBzdG9wKCkge1xcbiAgICBpZiAodGhpcy50aW1lcklkKSB7XFxuICAgICAgY29uc3QgY2FuY2VsRnVuYyA9IFJhZlRpY2tlci5nZXRDYW5jZWxGdW5jKCk7XFxuXFxuICAgICAgY2FuY2VsRnVuYyh0aGlzLnRpbWVySWQpO1xcbiAgICB9XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0VGlja0Z1bmMoKSB7XFxuICAgIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0Q2FuY2VsRnVuYygpIHtcXG4gICAgcmV0dXJuIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWU7XFxuICB9XFxuXFxuICBzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XFxuICAgIHJldHVybiBSYWZUaWNrZXIuZ2V0VGlja0Z1bmMoKSAhPT0gdW5kZWZpbmVkO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiB1c2Ugc2V0VGltZW91dCBmb3IgYnJvd3NlcnMgd2l0aG91dCByYWYgc3VwcG9ydFxcbiAqL1xcbmNsYXNzIFRpbWVvdXRUaWNrZXIgZXh0ZW5kcyBUaWNrZXIge1xcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XFxuICAgIHN1cGVyKGNvbmZpZyk7XFxuICAgIHRoaXMudGltZW91dElkID0gbnVsbDtcXG4gIH1cXG5cXG4gIHN0YXJ0KC4uLmNhbGxiYWNrcykge1xcbiAgICBzdXBlci5uZXh0VGljayguLi5jYWxsYmFja3MpO1xcbiAgICB0aGlzLnRpbWVvdXRJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XFxuICAgICAgdGhpcy5vblRpY2soKTtcXG4gICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsIHx8IDE2KTtcXG4gIH1cXG5cXG4gIHN0b3AoKSB7XFxuICAgIGlmICh0aGlzLnRpbWVvdXRJZCkge1xcbiAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMudGltZW91dElkKTtcXG4gICAgfVxcbiAgfVxcblxcbn1cXG5cXG4vKipcXG4gKiDov5Tlm55UaWNrZXLmnoTpgKDlh73mlbBcXG4gKiBAcmV0dXJucyB7VGlja2VyfVxcbiAqL1xcbmNvbnN0IGdldFRpY2tlciA9IGV4cG9ydHMuZ2V0VGlja2VyID0gKCkgPT4ge1xcbiAgaWYgKFJhZlRpY2tlci5pc1N1cHBvcnRlZCgpKSB7XFxuICAgIHJldHVybiBSYWZUaWNrZXI7XFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gVGltZW91dFRpY2tlcjtcXG4gIH1cXG59O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9zcmMvbW9iaWxlL3RpY2tlci5qcz8nKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvbW9iaWxlL3ZpZGVvLWNvbnRleHQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvdmlkZW8tY29udGV4dC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgX3dlYndvcmtpZnlXZWJwYWNrID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgd2Vid29ya2lmeS13ZWJwYWNrICovIFxcXCIuLi94Z3BsYXllci11dGlscy9ub2RlX21vZHVsZXMvd2Vid29ya2lmeS13ZWJwYWNrL2luZGV4LmpzXFxcIik7XFxuXFxudmFyIF93ZWJ3b3JraWZ5V2VicGFjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93ZWJ3b3JraWZ5V2VicGFjayk7XFxuXFxudmFyIF9zdHJlYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi93cml0ZS9zdHJlYW0gKi8gXFxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy93cml0ZS9zdHJlYW0uanNcXFwiKTtcXG5cXG52YXIgX3N0cmVhbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHJlYW0pO1xcblxcbnZhciBfbmFsdW5pdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uLy4uL3hncGxheWVyLWNvZGVjL3NyYy9oMjY0L25hbHVuaXQgKi8gXFxcIi4uL3hncGxheWVyLWNvZGVjL3NyYy9oMjY0L25hbHVuaXQvaW5kZXguanNcXFwiKTtcXG5cXG52YXIgX25hbHVuaXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbmFsdW5pdCk7XFxuXFxudmFyIF95dXZDYW52YXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3l1di1jYW52YXMgKi8gXFxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUveXV2LWNhbnZhcy5qc1xcXCIpO1xcblxcbnZhciBfeXV2Q2FudmFzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3l1dkNhbnZhcyk7XFxuXFxudmFyIF9zb3VyY2VidWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NvdXJjZWJ1ZmZlciAqLyBcXFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vYmlsZS9zb3VyY2VidWZmZXIuanNcXFwiKTtcXG5cXG52YXIgX3NvdXJjZWJ1ZmZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zb3VyY2VidWZmZXIpO1xcblxcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFxuY2xhc3MgVmlkZW9DYW52YXMge1xcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XFxuICAgIHRoaXMuY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcXG4gICAgdGhpcy5jYW52YXMgPSB0aGlzLmNvbmZpZy5jYW52YXMgPyB0aGlzLmNvbmZpZy5jYW52YXMgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcXG4gICAgdGhpcy5zb3VyY2UgPSBuZXcgX3NvdXJjZWJ1ZmZlcjIuZGVmYXVsdCh7IHR5cGU6ICd2aWRlbycgfSk7XFxuICAgIHRoaXMucHJlbG9hZFRpbWUgPSB0aGlzLmNvbmZpZy5wcmVsb2FkVGltZSB8fCAzO1xcbiAgICB0aGlzLm9uY2FucGxheSA9IHVuZGVmaW5lZDtcXG4gICAgdGhpcy5vbkZpcnN0RnJhbWUgPSB1bmRlZmluZWQ7XFxuICAgIHRoaXMubWV0YSA9IHVuZGVmaW5lZDtcXG4gICAgdGhpcy5yZWFkeVN0YXR1cyA9IDA7XFxuICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcXG4gICAgdGhpcy5jb3VudCA9IDA7XFxuICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xcbiAgICB0aGlzLmxhc3RQbGF5ZWQgPSAwO1xcblxcbiAgICB0aGlzLl9kZWNvZGVySW5pdGVkID0gZmFsc2U7XFxuICAgIHRoaXMuX2F2Y2NwdXNoZWQgPSBmYWxzZTtcXG4gICAgdGhpcy5fZGVjb2RlZEZyYW1lcyA9IHt9O1xcbiAgICB0aGlzLl9sYXN0U2FtcGxlRHRzID0gdW5kZWZpbmVkO1xcbiAgICB0aGlzLl9iYXNlRHRzID0gdW5kZWZpbmVkO1xcbiAgICB0aGlzLl9sYXN0UmVuZGVyVGltZSA9IG51bGw7XFxuICAgIHRoaXMucGxheUZpbmlzaCA9IG51bGw7XFxuICB9XFxuXFxuICBwYXVzZSgpIHtcXG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xcbiAgfVxcblxcbiAgaW5pdFdhc21Xb3JrZXIoKSB7XFxuICAgIGxldCBfdGhpcyA9IHRoaXM7XFxuICAgIHRoaXMud2FzbXdvcmtlciA9ICgwLCBfd2Vid29ya2lmeVdlYnBhY2syLmRlZmF1bHQpKC8qcmVxdWlyZS5yZXNvbHZlKi8oLyohIC4vd29ya2VyLmpzICovIFxcXCIuLi94Z3BsYXllci11dGlscy9zcmMvbW9iaWxlL3dvcmtlci5qc1xcXCIpKTtcXG4gICAgdGhpcy53YXNtd29ya2VyLnBvc3RNZXNzYWdlKHtcXG4gICAgICBtc2c6ICdpbml0JyxcXG4gICAgICBtZXRhOiB0aGlzLm1ldGFcXG4gICAgfSk7XFxuICAgIHRoaXMud2FzbXdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbXNnID0+IHtcXG4gICAgICBzd2l0Y2ggKG1zZy5kYXRhLm1zZykge1xcbiAgICAgICAgY2FzZSAnREVDT0RFUl9SRUFEWSc6XFxuICAgICAgICAgIF90aGlzLl9kZWNvZGVySW5pdGVkID0gdHJ1ZTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlICdERUNPREVEJzpcXG4gICAgICAgICAgdGhpcy5fb25EZWNvZGVkKG1zZy5kYXRhKTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHNldFZpZGVvTWV0YURhdGEobWV0YSkge1xcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xcbiAgICBpZiAoIXRoaXMuX2RlY29kZXJJbml0ZWQpIHtcXG4gICAgICB0aGlzLmluaXRXYXNtV29ya2VyKCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHRoaXMuX2F2Y2NwdXNoZWQgPSB0cnVlO1xcbiAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KG1ldGEuc3BzLmJ5dGVMZW5ndGggKyA0KTtcXG4gICAgZGF0YS5zZXQoWzAsIDAsIDAsIDFdKTtcXG4gICAgZGF0YS5zZXQobWV0YS5zcHMsIDQpO1xcbiAgICB0aGlzLndhc213b3JrZXIucG9zdE1lc3NhZ2Uoe1xcbiAgICAgIG1zZzogJ2RlY29kZScsXFxuICAgICAgZGF0YTogZGF0YVxcbiAgICB9KTtcXG5cXG4gICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KG1ldGEucHBzLmJ5dGVMZW5ndGggKyA0KTtcXG4gICAgZGF0YS5zZXQoWzAsIDAsIDAsIDFdKTtcXG4gICAgZGF0YS5zZXQobWV0YS5wcHMsIDQpO1xcbiAgICB0aGlzLndhc213b3JrZXIucG9zdE1lc3NhZ2Uoe1xcbiAgICAgIG1zZzogJ2RlY29kZScsXFxuICAgICAgZGF0YTogZGF0YVxcbiAgICB9KTtcXG5cXG4gICAgaWYgKCF0aGlzLnl1dkNhbnZhcykge1xcbiAgICAgIGxldCBjb25maWcgPSBPYmplY3QuYXNzaWduKHsgbWV0YSwgY2FudmFzOiB0aGlzLmNhbnZhcyB9LCB0aGlzLmNvbmZpZyk7XFxuICAgICAgdGhpcy55dXZDYW52YXMgPSBuZXcgX3l1dkNhbnZhczIuZGVmYXVsdChjb25maWcpO1xcbiAgICB9XFxuICAgIHRoaXMucmVhZHlTdGF0dXMgPSAxO1xcbiAgfVxcblxcbiAgZGVjb2RlVmlkZW8odmlkZW9UcmFjaykge1xcbiAgICBpZiAoIXRoaXMuX2RlY29kZXJJbml0ZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKCF0aGlzLl9hdmNjcHVzaGVkKSB7XFxuICAgICAgdGhpcy5zZXRWaWRlb01ldGFEYXRhKHRoaXMubWV0YSk7XFxuICAgIH1cXG4gICAgbGV0IHsgc2FtcGxlcyB9ID0gdmlkZW9UcmFjaztcXG4gICAgbGV0IHNhbXBsZSA9IHNhbXBsZXMuc2hpZnQoKTtcXG5cXG4gICAgd2hpbGUgKHNhbXBsZSkge1xcbiAgICAgIGlmICghdGhpcy5fYmFzZUR0cykge1xcbiAgICAgICAgdGhpcy5fYmFzZUR0cyA9IHNhbXBsZS5kdHM7XFxuICAgICAgfVxcbiAgICAgIHRoaXMuc291cmNlLnB1c2goc2FtcGxlKTtcXG4gICAgICBzYW1wbGUgPSBzYW1wbGVzLnNoaWZ0KCk7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fcHJlbG9hZCgpO1xcbiAgfVxcblxcbiAgX3ByZWxvYWQoKSB7XFxuICAgIGlmICghdGhpcy5fbGFzdFNhbXBsZUR0cyB8fCB0aGlzLl9sYXN0U2FtcGxlRHRzIC0gdGhpcy5fYmFzZUR0cyA8IHRoaXMuY3VycmVudFRpbWUgKyB0aGlzLnByZWxvYWRUaW1lICogMTAwMCkge1xcbiAgICAgIGxldCBzYW1wbGUgPSB0aGlzLnNvdXJjZS5nZXQoKTtcXG4gICAgICBpZiAoc2FtcGxlKSB7XFxuICAgICAgICB0aGlzLl9sYXN0U2FtcGxlRHRzID0gc2FtcGxlLmR0cztcXG4gICAgICAgIHRoaXMuX2FuYWx5c2VOYWwoc2FtcGxlKTtcXG4gICAgICB9XFxuXFxuICAgICAgd2hpbGUgKHNhbXBsZSAmJiB0aGlzLl9sYXN0U2FtcGxlRHRzIC0gdGhpcy5fYmFzZUR0cyA8IHRoaXMuY3VycmVudFRpbWUgKyB0aGlzLnByZWxvYWRUaW1lICogMTAwMCkge1xcbiAgICAgICAgc2FtcGxlID0gdGhpcy5zb3VyY2UuZ2V0KCk7XFxuICAgICAgICBpZiAoc2FtcGxlKSB7XFxuICAgICAgICAgIHRoaXMuX2FuYWx5c2VOYWwoc2FtcGxlKTtcXG4gICAgICAgICAgdGhpcy5fbGFzdFNhbXBsZUR0cyA9IHNhbXBsZS5kdHM7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBfYW5hbHlzZU5hbChzYW1wbGUpIHtcXG4gICAgbGV0IG5hbHMgPSBfbmFsdW5pdDIuZGVmYXVsdC5nZXRBdmNjTmFscyhuZXcgX3N0cmVhbTIuZGVmYXVsdChzYW1wbGUuZGF0YS5idWZmZXIpKTtcXG5cXG4gICAgbGV0IGxlbmd0aCA9IDA7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFscy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGxldCBuYWwgPSBuYWxzW2ldO1xcbiAgICAgIGxlbmd0aCArPSBuYWwuYm9keS5ieXRlTGVuZ3RoICsgNDtcXG4gICAgfVxcbiAgICBsZXQgb2Zmc2V0ID0gMDtcXG4gICAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICBsZXQgbmFsID0gbmFsc1tpXTtcXG4gICAgICBkYXRhLnNldChbMCwgMCwgMCwgMV0sIG9mZnNldCk7XFxuICAgICAgb2Zmc2V0ICs9IDQ7XFxuICAgICAgZGF0YS5zZXQobmV3IFVpbnQ4QXJyYXkobmFsLmJvZHkpLCBvZmZzZXQpO1xcbiAgICAgIG9mZnNldCArPSBuYWwuYm9keS5ieXRlTGVuZ3RoO1xcbiAgICB9XFxuICAgIHRoaXMud2FzbXdvcmtlci5wb3N0TWVzc2FnZSh7XFxuICAgICAgbXNnOiAnZGVjb2RlJyxcXG4gICAgICBkYXRhOiBkYXRhLFxcbiAgICAgIGluZm86IHtcXG4gICAgICAgIGR0czogc2FtcGxlLmR0cyxcXG4gICAgICAgIHB0czogc2FtcGxlLnB0cyA/IHNhbXBsZS5wdHMgOiBzYW1wbGUuZHRzICsgc2FtcGxlLmN0cyxcXG4gICAgICAgIGtleTogc2FtcGxlLmlzS2V5ZnJhbWVcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgX29uRGVjb2RlZChkYXRhKSB7XFxuICAgIGxldCB7IGR0cyB9ID0gZGF0YS5pbmZvO1xcbiAgICB0aGlzLl9kZWNvZGVkRnJhbWVzW2R0c10gPSBkYXRhO1xcbiAgfVxcblxcbiAgcGxheSgpIHtcXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xcbiAgICAgIHRoaXMucGxheUZpbmlzaCA9IHJlc29sdmU7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgX29uVGltZXIoY3VycmVudFRpbWUpIHtcXG4gICAgaWYgKHRoaXMucGF1c2VkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGlmICh0aGlzLm1ldGEpIHtcXG4gICAgICBpZiAodGhpcy5tZXRhLmZyYW1lUmF0ZSAmJiB0aGlzLm1ldGEuZnJhbWVSYXRlLmZpeGVkICYmIHRoaXMubWV0YS5mcmFtZVJhdGUuZnBzKSB7fVxcbiAgICAgIGxldCBmcmFtZVRpbWVzID0gT2JqZWN0LmtleXModGhpcy5fZGVjb2RlZEZyYW1lcyk7XFxuICAgICAgaWYgKGZyYW1lVGltZXMubGVuZ3RoID4gMCkge1xcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xcbiAgICAgICAgbGV0IGZyYW1lVGltZSA9IC0xO1xcbiAgICAgICAgbGV0IGN1cnJlbnRJZHggPSAwO1xcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZVRpbWVzLmxlbmd0aCAmJiBOdW1iZXIucGFyc2VJbnQoZnJhbWVUaW1lc1tpXSkgLSB0aGlzLl9iYXNlRHRzIDw9IHRoaXMuY3VycmVudFRpbWU7IGkrKykge1xcbiAgICAgICAgICBmcmFtZVRpbWUgPSBOdW1iZXIucGFyc2VJbnQoZnJhbWVUaW1lc1tpIC0gMV0pO1xcbiAgICAgICAgICBjdXJyZW50SWR4ID0gaTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGxldCBmcmFtZSA9IHRoaXMuX2RlY29kZWRGcmFtZXNbZnJhbWVUaW1lXTtcXG4gICAgICAgIGlmIChmcmFtZSkge1xcblxcbiAgICAgICAgICBpZiAodGhpcy5vbmNhbnBsYXkgJiYgdGhpcy5yZWFkeVN0YXR1cyA8IDQpIHtcXG4gICAgICAgICAgICB0aGlzLm9uY2FucGxheSgpO1xcbiAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0dXMgPSA0O1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHRoaXMueXV2Q2FudmFzLnJlbmRlcihmcmFtZS5idWZmZXIsIGZyYW1lLndpZHRoLCBmcmFtZS5oZWlnaHQsIGZyYW1lLnlMaW5lc2l6ZSwgZnJhbWUudXZMaW5lc2l6ZSk7XFxuXFxuICAgICAgICAgIGlmICh0aGlzLnBsYXlGaW5pc2gpIHtcXG4gICAgICAgICAgICB0aGlzLnBsYXlGaW5pc2goKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRJZHg7IGkrKykge1xcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9kZWNvZGVkRnJhbWVzW2ldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHRoaXMuX2xhc3RSZW5kZXJUaW1lID0gRGF0ZS5ub3coKTtcXG4gIH1cXG5cXG4gIGNsZWFuQnVmZmVyKCkge1xcbiAgICBpZiAodGhpcy5jdXJyZW50VGltZSA+IDEpIHtcXG4gICAgICB0aGlzLnNvdXJjZS5yZW1vdmUoMCwgdGhpcy5jdXJyZW50VGltZSAtIDEpO1xcbiAgICB9XFxuICB9XFxufVxcbmV4cG9ydHMuZGVmYXVsdCA9IFZpZGVvQ2FudmFzO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9zcmMvbW9iaWxlL3ZpZGVvLWNvbnRleHQuanM/XCIpfSxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvd29ya2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUvd29ya2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbmNvbnN0IE1BWF9TVFJFQU1fQlVGRkVSX0xFTkdUSCA9IDEwMjQgKiAxMDI0O1xcbnZhciBEZWNvZGVyID0gZnVuY3Rpb24gKHNlbGYpIHtcXG4gIHRoaXMuaW5pdGVkID0gZmFsc2U7XFxuICB0aGlzLnNlbGYgPSBzZWxmO1xcbiAgdGhpcy5tZXRhID0gdGhpcy5zZWxmLm1ldGE7XFxuICB0aGlzLmluZm9saXN0ID0ge307XFxuICBzZWxmLnBhcl9icm9hZHdheU9uQnJvYWR3YXlJbml0ZWQgPSB0aGlzLmJyb2Fkd2F5T25Ccm9hZHdheUluaXRlZC5iaW5kKHRoaXMpO1xcbiAgc2VsZi5wYXJfYnJvYWR3YXlPblBpY3R1cmVEZWNvZGVkID0gdGhpcy5icm9hZHdheU9uUGljdHVyZURlY29kZWQuYmluZCh0aGlzKTtcXG59O1xcblxcbkRlY29kZXIucHJvdG90eXBlLnRvVThBcnJheSA9IGZ1bmN0aW9uIChwdHIsIGxlbmd0aCkge1xcbiAgcmV0dXJuIHRoaXMuc2VsZi5IRUFQVTguc3ViYXJyYXkocHRyLCBwdHIgKyBsZW5ndGgpO1xcbn07XFxuXFxuRGVjb2Rlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcXG4gIE1vZHVsZS5fYnJvYWR3YXlJbml0KCk7XFxuICB0aGlzLnN0cmVhbUJ1ZmZlciA9IHRoaXMudG9VOEFycmF5KE1vZHVsZS5fYnJvYWR3YXlDcmVhdGVTdHJlYW0oTUFYX1NUUkVBTV9CVUZGRVJfTEVOR1RIKSwgTUFYX1NUUkVBTV9CVUZGRVJfTEVOR1RIKTtcXG59O1xcblxcbkRlY29kZXIucHJvdG90eXBlLmJyb2Fkd2F5T25QaWN0dXJlRGVjb2RlZCA9IGZ1bmN0aW9uIChvZmZzZXQsIHdpZHRoLCBoZWlnaHQsIHlMaW5lc2l6ZSwgdXZMaW5lc2l6ZSwgaW5mb2lkKSB7XFxuICBsZXQgaW5mbyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaW5mb2xpc3RbaW5mb2lkXSk7XFxuICBsZXQgeVJvd2NvdW50ID0gaGVpZ2h0O1xcbiAgbGV0IHV2Um93Y291bnQgPSBoZWlnaHQgLyAyO1xcbiAgaWYgKHRoaXMubWV0YS5jaHJvbWFGb3JtYXQgPT09IDQ0NCB8fCB0aGlzLm1ldGEuY2hyb21hRm9ybWF0ID09PSA0MjIpIHtcXG4gICAgdXZSb3djb3VudCA9IGhlaWdodDtcXG4gIH1cXG4gIGxldCBkYXRhID0gdGhpcy50b1U4QXJyYXkob2Zmc2V0LCB5TGluZXNpemUgKiB5Um93Y291bnQgKyAyICogKHV2TGluZXNpemUgKiB1dlJvd2NvdW50KSk7XFxuICB0aGlzLmluZm9saXN0W2luZm9pZF0gPSBudWxsO1xcbiAgbGV0IGRhdGV0ZW1wID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xcbiAgZGF0ZXRlbXAuc2V0KGRhdGEpO1xcbiAgbGV0IGJ1ZmZlciA9IGRhdGV0ZW1wLmJ1ZmZlcjtcXG4gIHRoaXMuc2VsZi5wb3N0TWVzc2FnZSh7XFxuICAgIG1zZzogJ0RFQ09ERUQnLFxcbiAgICB3aWR0aCxcXG4gICAgaGVpZ2h0LFxcbiAgICB5TGluZXNpemUsXFxuICAgIHV2TGluZXNpemUsXFxuICAgIGluZm8sXFxuICAgIGJ1ZmZlclxcbiAgfSwgW2J1ZmZlcl0pO1xcbn07XFxuXFxuRGVjb2Rlci5wcm90b3R5cGUuYnJvYWR3YXlPbkJyb2Fkd2F5SW5pdGVkID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5pbml0ZWQgPSB0cnVlO1xcbiAgdGhpcy5zZWxmLnBvc3RNZXNzYWdlKHsgbXNnOiAnREVDT0RFUl9SRUFEWScgfSk7XFxufTtcXG5cXG5EZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoZGF0YSwgaW5mbykge1xcbiAgbGV0IHRpbWUgPSBwYXJzZUludChuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XFxuICBsZXQgaW5mb2lkID0gdGltZSAtIE1hdGguZmxvb3IodGltZSAvIDEwZTgpICogMTBlODtcXG4gIHRoaXMuaW5mb2xpc3RbaW5mb2lkXSA9IGluZm87XFxuICB0aGlzLnN0cmVhbUJ1ZmZlci5zZXQoZGF0YSk7XFxuICBNb2R1bGUuX2Jyb2Fkd2F5UGxheVN0cmVhbShkYXRhLmxlbmd0aCwgaW5mb2lkKTtcXG59O1xcblxcbnZhciBkZWNvZGVyO1xcblxcbmZ1bmN0aW9uIG9uUG9zdFJ1bigpIHtcXG4gIGRlY29kZXIgPSBuZXcgRGVjb2Rlcih0aGlzKTtcXG4gIGRlY29kZXIuaW5pdCgpO1xcbn1cXG5cXG5mdW5jdGlvbiBpbml0KG1ldGEpIHtcXG4gIHNlbGYuaW1wb3J0U2NyaXB0cygnaHR0cHM6Ly9zZjEtdmNsb3VkY2RuLnBzdGF0cC5jb20vb2JqL3R0ZmUvbWVkaWEvZGVjb2Rlci9oMjY0L2RlY29kZXIuanMnKTtcXG4gIGFkZE9uUG9zdFJ1bihvblBvc3RSdW4uYmluZChzZWxmKSk7XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlbGYpIHtcXG4gIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChlKSB7XFxuICAgIHZhciBkYXRhID0gZS5kYXRhO1xcbiAgICBpZiAoIWRhdGEubXNnKSB7XFxuICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XFxuICAgICAgICBtc2c6ICdFUlJPUjppbnZhbGlkIG1lc3NhZ2UnXFxuICAgICAgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3dpdGNoIChkYXRhLm1zZykge1xcbiAgICAgICAgY2FzZSAnaW5pdCc6XFxuICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xcbiAgICAgICAgICBzZWxmLm1ldGEgPSBkYXRhLm1ldGE7XFxuICAgICAgICAgIGluaXQoKTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICBjYXNlICdkZWNvZGUnOlxcbiAgICAgICAgICBkZWNvZGVyLmRlY29kZShkYXRhLmRhdGEsIGRhdGEuaW5mbyk7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LCBmYWxzZSk7XFxufTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vYmlsZS93b3JrZXIuanM/XCIpfSxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2JpbGUveXV2LWNhbnZhcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vYmlsZS95dXYtY2FudmFzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbmNsYXNzIFlVVkNhbnZhcyB7XFxuICBjb25zdHJ1Y3Rvcihjb25maWdzKSB7XFxuICAgIHRoaXMuY29uZmlncyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZ3MpO1xcbiAgICB0aGlzLmNhbnZhcyA9IHRoaXMuY29uZmlncy5jYW52YXM7XFxuICAgIHRoaXMubWV0YSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29uZmlncy5tZXRhKTtcXG4gICAgdGhpcy5jaHJvbWEgPSB0aGlzLm1ldGEuY2hyb21hRm9ybWF0O1xcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMubWV0YS5wcmVzZW50SGVpZ2h0O1xcbiAgICB0aGlzLndpZHRoID0gdGhpcy5tZXRhLnByZXNlbnRXaWR0aDtcXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSAxMjgwO1xcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSA3MjA7XFxuICAgIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMCUnO1xcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XFxuICAgIHRoaXMuX2luaXRDb250ZXh0R0woKTtcXG4gICAgaWYgKHRoaXMuY29udGV4dEdMKSB7XFxuICAgICAgdGhpcy5faW5pdFByb2dyYW0oKTtcXG4gICAgICB0aGlzLl9pbml0QnVmZmVycygpO1xcbiAgICAgIHRoaXMuX2luaXRUZXh0dXJlcygpO1xcbiAgICB9O1xcbiAgfVxcblxcbiAgX2luaXRDb250ZXh0R0woKSB7XFxuICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcXG4gICAgdmFyIGdsID0gbnVsbDtcXG5cXG4gICAgdmFyIHZhbGlkQ29udGV4dE5hbWVzID0gWyd3ZWJnbCcsICdleHBlcmltZW50YWwtd2ViZ2wnLCAnbW96LXdlYmdsJywgJ3dlYmtpdC0zZCddO1xcbiAgICB2YXIgbmFtZUluZGV4ID0gMDtcXG5cXG4gICAgd2hpbGUgKCFnbCAmJiBuYW1lSW5kZXggPCB2YWxpZENvbnRleHROYW1lcy5sZW5ndGgpIHtcXG4gICAgICB2YXIgY29udGV4dE5hbWUgPSB2YWxpZENvbnRleHROYW1lc1tuYW1lSW5kZXhdO1xcblxcbiAgICAgIHRyeSB7XFxuICAgICAgICBpZiAodGhpcy5jb250ZXh0T3B0aW9ucykge1xcbiAgICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KGNvbnRleHROYW1lLCB0aGlzLmNvbnRleHRPcHRpb25zKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoY29udGV4dE5hbWUpO1xcbiAgICAgICAgfTtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBnbCA9IG51bGw7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghZ2wgfHwgdHlwZW9mIGdsLmdldFBhcmFtZXRlciAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgZ2wgPSBudWxsO1xcbiAgICAgIH1cXG5cXG4gICAgICArK25hbWVJbmRleDtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5jb250ZXh0R0wgPSBnbDtcXG4gIH1cXG5cXG4gIF9pbml0UHJvZ3JhbSgpIHtcXG4gICAgdmFyIGdsID0gdGhpcy5jb250ZXh0R0w7XFxuXFxuICAgIC8vIHZlcnRleCBzaGFkZXIgaXMgdGhlIHNhbWUgZm9yIGFsbCB0eXBlc1xcbiAgICB2YXIgdmVydGV4U2hhZGVyU2NyaXB0O1xcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXJTY3JpcHQ7XFxuICAgIHZlcnRleFNoYWRlclNjcmlwdCA9IFsnYXR0cmlidXRlIHZlYzQgdmVydGV4UG9zOycsICdhdHRyaWJ1dGUgdmVjNCB0ZXh0dXJlUG9zOycsICdhdHRyaWJ1dGUgdmVjNCB1VGV4dHVyZVBvczsnLCAnYXR0cmlidXRlIHZlYzQgdlRleHR1cmVQb3M7JywgJ3ZhcnlpbmcgdmVjMiB0ZXh0dXJlQ29vcmQ7JywgJ3ZhcnlpbmcgdmVjMiB1VGV4dHVyZUNvb3JkOycsICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLCAndm9pZCBtYWluKCknLCAneycsICcgIGdsX1Bvc2l0aW9uID0gdmVydGV4UG9zOycsICcgIHRleHR1cmVDb29yZCA9IHRleHR1cmVQb3MueHk7JywgJyAgdVRleHR1cmVDb29yZCA9IHVUZXh0dXJlUG9zLnh5OycsICcgIHZUZXh0dXJlQ29vcmQgPSB2VGV4dHVyZVBvcy54eTsnLCAnfSddLmpvaW4oJ1xcXFxuJyk7XFxuXFxuICAgIGZyYWdtZW50U2hhZGVyU2NyaXB0ID0gWydwcmVjaXNpb24gaGlnaHAgZmxvYXQ7JywgJ3ZhcnlpbmcgaGlnaHAgdmVjMiB0ZXh0dXJlQ29vcmQ7JywgJ3ZhcnlpbmcgaGlnaHAgdmVjMiB1VGV4dHVyZUNvb3JkOycsICd2YXJ5aW5nIGhpZ2hwIHZlYzIgdlRleHR1cmVDb29yZDsnLCAndW5pZm9ybSBzYW1wbGVyMkQgeVNhbXBsZXI7JywgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsICd1bmlmb3JtIHNhbXBsZXIyRCB2U2FtcGxlcjsnLCAndW5pZm9ybSBtYXQ0IFlVVjJSR0I7JywgJ3ZvaWQgbWFpbih2b2lkKSB7JywgJyAgaGlnaHAgZmxvYXQgeSA9IHRleHR1cmUyRCh5U2FtcGxlciwgIHRleHR1cmVDb29yZCkucjsnLCAnICBoaWdocCBmbG9hdCB1ID0gdGV4dHVyZTJEKHVTYW1wbGVyLCAgdVRleHR1cmVDb29yZCkucjsnLCAnICBoaWdocCBmbG9hdCB2ID0gdGV4dHVyZTJEKHZTYW1wbGVyLCAgdlRleHR1cmVDb29yZCkucjsnLCAnICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHksIHUsIHYsIDEpICogWVVWMlJHQjsnLCAnfSddLmpvaW4oJ1xcXFxuJyk7XFxuXFxuICAgIHZhciBZVVYyUkdCID0gWzEuMTY0MzgsIDAuMDAwMDAsIDEuNTk2MDMsIC0wLjg3MDc5LCAxLjE2NDM4LCAtMC4zOTE3NiwgLTAuODEyOTcsIDAuNTI5NTksIDEuMTY0MzgsIDIuMDE3MjMsIDAuMDAwMDAsIC0xLjA4MTM5LCAwLCAwLCAwLCAxXTtcXG4gICAgdmFyIHZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTtcXG4gICAgZ2wuc2hhZGVyU291cmNlKHZlcnRleFNoYWRlciwgdmVydGV4U2hhZGVyU2NyaXB0KTtcXG4gICAgZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0ZXhTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xcbiAgICAgIGNvbnNvbGUubG9nKCdWZXJ0ZXggc2hhZGVyIGZhaWxlZCB0byBjb21waWxlOiAnICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyh2ZXJ0ZXhTaGFkZXIpKTtcXG4gICAgfVxcblxcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcXG4gICAgZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNoYWRlclNjcmlwdCk7XFxuICAgIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnbWVudFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XFxuICAgICAgY29uc29sZS5sb2coJ0ZyYWdtZW50IHNoYWRlciBmYWlsZWQgdG8gY29tcGlsZTogJyArIGdsLmdldFNoYWRlckluZm9Mb2coZnJhZ21lbnRTaGFkZXIpKTtcXG4gICAgfVxcblxcbiAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XFxuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XFxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xcbiAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XFxuICAgICAgY29uc29sZS5sb2coJ1Byb2dyYW0gZmFpbGVkIHRvIGNvbXBpbGU6ICcgKyBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XFxuICAgIH1cXG5cXG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcXG5cXG4gICAgdmFyIFlVVjJSR0JSZWYgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ1lVVjJSR0InKTtcXG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdihZVVYyUkdCUmVmLCBmYWxzZSwgWVVWMlJHQik7XFxuXFxuICAgIHRoaXMuc2hhZGVyUHJvZ3JhbSA9IHByb2dyYW07XFxuICB9XFxuXFxuICBfaW5pdEJ1ZmZlcnMoKSB7XFxuICAgIHZhciBnbCA9IHRoaXMuY29udGV4dEdMO1xcbiAgICB2YXIgcHJvZ3JhbSA9IHRoaXMuc2hhZGVyUHJvZ3JhbTtcXG5cXG4gICAgdmFyIHZlcnRleFBvc0J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4UG9zQnVmZmVyKTtcXG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIC0xLCAxLCAxLCAtMSwgLTEsIC0xXSksIGdsLlNUQVRJQ19EUkFXKTtcXG5cXG4gICAgdmFyIHZlcnRleFBvc1JlZiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICd2ZXJ0ZXhQb3MnKTtcXG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodmVydGV4UG9zUmVmKTtcXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhQb3NSZWYsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XFxuXFxuICAgIHZhciB0ZXh0dXJlUG9zQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XFxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0ZXh0dXJlUG9zQnVmZmVyKTtcXG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDAsIDEsIDEsIDAsIDFdKSwgZ2wuU1RBVElDX0RSQVcpO1xcblxcbiAgICB2YXIgdGV4dHVyZVBvc1JlZiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICd0ZXh0dXJlUG9zJyk7XFxuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRleHR1cmVQb3NSZWYpO1xcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRleHR1cmVQb3NSZWYsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XFxuXFxuICAgIHRoaXMudGV4dHVyZVBvc0J1ZmZlciA9IHRleHR1cmVQb3NCdWZmZXI7XFxuXFxuICAgIHZhciB1VGV4dHVyZVBvc0J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdVRleHR1cmVQb3NCdWZmZXIpO1xcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMSwgMSwgMCwgMV0pLCBnbC5TVEFUSUNfRFJBVyk7XFxuXFxuICAgIHZhciB1VGV4dHVyZVBvc1JlZiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICd1VGV4dHVyZVBvcycpO1xcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh1VGV4dHVyZVBvc1JlZik7XFxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodVRleHR1cmVQb3NSZWYsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XFxuXFxuICAgIHRoaXMudVRleHR1cmVQb3NCdWZmZXIgPSB1VGV4dHVyZVBvc0J1ZmZlcjtcXG5cXG4gICAgdmFyIHZUZXh0dXJlUG9zQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XFxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2VGV4dHVyZVBvc0J1ZmZlcik7XFxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAxLCAxLCAwLCAxXSksIGdsLlNUQVRJQ19EUkFXKTtcXG5cXG4gICAgdmFyIHZUZXh0dXJlUG9zUmVmID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ3ZUZXh0dXJlUG9zJyk7XFxuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZUZXh0dXJlUG9zUmVmKTtcXG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih2VGV4dHVyZVBvc1JlZiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcXG5cXG4gICAgdGhpcy52VGV4dHVyZVBvc0J1ZmZlciA9IHZUZXh0dXJlUG9zQnVmZmVyO1xcbiAgfVxcblxcbiAgX2luaXRUZXh0dXJlcygpIHtcXG4gICAgdmFyIGdsID0gdGhpcy5jb250ZXh0R0w7XFxuICAgIHZhciBwcm9ncmFtID0gdGhpcy5zaGFkZXJQcm9ncmFtO1xcbiAgICB2YXIgeVRleHR1cmVSZWYgPSB0aGlzLl9pbml0VGV4dHVyZSgpO1xcbiAgICB2YXIgeVNhbXBsZXJSZWYgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3lTYW1wbGVyJyk7XFxuICAgIGdsLnVuaWZvcm0xaSh5U2FtcGxlclJlZiwgMCk7XFxuICAgIHRoaXMueVRleHR1cmVSZWYgPSB5VGV4dHVyZVJlZjtcXG5cXG4gICAgdmFyIHVUZXh0dXJlUmVmID0gdGhpcy5faW5pdFRleHR1cmUoKTtcXG4gICAgdmFyIHVTYW1wbGVyUmVmID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U2FtcGxlcicpO1xcbiAgICBnbC51bmlmb3JtMWkodVNhbXBsZXJSZWYsIDEpO1xcbiAgICB0aGlzLnVUZXh0dXJlUmVmID0gdVRleHR1cmVSZWY7XFxuXFxuICAgIHZhciB2VGV4dHVyZVJlZiA9IHRoaXMuX2luaXRUZXh0dXJlKCk7XFxuICAgIHZhciB2U2FtcGxlclJlZiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndlNhbXBsZXInKTtcXG4gICAgZ2wudW5pZm9ybTFpKHZTYW1wbGVyUmVmLCAyKTtcXG4gICAgdGhpcy52VGV4dHVyZVJlZiA9IHZUZXh0dXJlUmVmO1xcbiAgfVxcblxcbiAgX2luaXRUZXh0dXJlKCkge1xcbiAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHRHTDtcXG5cXG4gICAgdmFyIHRleHR1cmVSZWYgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XFxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmVSZWYpO1xcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XFxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XFxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcXG5cXG4gICAgcmV0dXJuIHRleHR1cmVSZWY7XFxuICB9XFxuXFxuICBfZHJhd1BpY3R1cmVHTChkYXRhLCB3aWR0aCwgaGVpZ2h0LCB5TGluZXNpemUsIHV2TGluZXNpemUpIHtcXG4gICAgdmFyIHlsZW4gPSB5TGluZXNpemUgKiBoZWlnaHQ7XFxuICAgIHZhciB1dmxlbiA9IHV2TGluZXNpemUgKiBoZWlnaHQgLyAyO1xcbiAgICBpZiAodGhpcy5jaHJvbWEgPT09IDQ0NCB8fCB0aGlzLmNocm9tYSA9PT0gNDIyKSB7XFxuICAgICAgdXZsZW4gKj0gMjtcXG4gICAgfVxcbiAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XFxuICAgIGxldCByZW5kZXJEYXRhID0ge1xcbiAgICAgIHlEYXRhOiBkYXRhLnN1YmFycmF5KDAsIHlsZW4pLFxcbiAgICAgIHVEYXRhOiBkYXRhLnN1YmFycmF5KHlsZW4sIHlsZW4gKyB1dmxlbiksXFxuICAgICAgdkRhdGE6IGRhdGEuc3ViYXJyYXkoeWxlbiArIHV2bGVuLCB5bGVuICsgdXZsZW4gKyB1dmxlbilcXG4gICAgfTtcXG4gICAgdGhpcy5fZHJhd1BpY3R1cmVHTDQyMChyZW5kZXJEYXRhLCB3aWR0aCwgaGVpZ2h0LCB5TGluZXNpemUsIHV2TGluZXNpemUpO1xcbiAgfVxcblxcbiAgX2RyYXdQaWN0dXJlR0w0MjAoZGF0YSwgd2lkdGgsIGhlaWdodCwgeUxpbmVzaXplLCB1dkxpbmVzaXplKSB7XFxuICAgIHZhciBnbCA9IHRoaXMuY29udGV4dEdMO1xcbiAgICB2YXIgdGV4dHVyZVBvc0J1ZmZlciA9IHRoaXMudGV4dHVyZVBvc0J1ZmZlcjtcXG4gICAgdmFyIHVUZXh0dXJlUG9zQnVmZmVyID0gdGhpcy51VGV4dHVyZVBvc0J1ZmZlcjtcXG4gICAgdmFyIHZUZXh0dXJlUG9zQnVmZmVyID0gdGhpcy52VGV4dHVyZVBvc0J1ZmZlcjtcXG5cXG4gICAgdmFyIHlUZXh0dXJlUmVmID0gdGhpcy55VGV4dHVyZVJlZjtcXG4gICAgdmFyIHVUZXh0dXJlUmVmID0gdGhpcy51VGV4dHVyZVJlZjtcXG4gICAgdmFyIHZUZXh0dXJlUmVmID0gdGhpcy52VGV4dHVyZVJlZjtcXG5cXG4gICAgdmFyIHlEYXRhID0gZGF0YS55RGF0YTtcXG4gICAgdmFyIHVEYXRhID0gZGF0YS51RGF0YTtcXG4gICAgdmFyIHZEYXRhID0gZGF0YS52RGF0YTtcXG5cXG4gICAgdmFyIHlEYXRhUGVyUm93ID0geUxpbmVzaXplO1xcbiAgICB2YXIgeVJvd0NudCA9IGhlaWdodDtcXG5cXG4gICAgdmFyIHVEYXRhUGVyUm93ID0gd2lkdGggLyAyO1xcbiAgICB2YXIgdVJvd0NudCA9IGhlaWdodCAvIDI7XFxuXFxuICAgIGlmICh0aGlzLmNocm9tYSA9PT0gNDIyIHx8IHRoaXMuY2hyb21hID09PSA0NDQpIHtcXG4gICAgICB1Um93Q250ID0gaGVpZ2h0O1xcbiAgICB9XFxuXFxuICAgIHZhciB2RGF0YVBlclJvdyA9IHV2TGluZXNpemU7XFxuICAgIHZhciB2Um93Q250ID0gdVJvd0NudDtcXG5cXG4gICAgbGV0IHJhdGlvdyA9IHRoaXMuY2FudmFzLndpZHRoIC8gdGhpcy53aWR0aDtcXG4gICAgbGV0IHJhdGlvaCA9IHRoaXMuY2FudmFzLmhlaWdodCAvIHRoaXMuaGVpZ2h0O1xcbiAgICBsZXQgbGVmdCA9IDA7XFxuICAgIGxldCB0b3AgPSAwO1xcbiAgICBsZXQgdyA9IHRoaXMuY2FudmFzLndpZHRoO1xcbiAgICBsZXQgaCA9IHRoaXMuY2FudmFzLmhlaWdodDtcXG4gICAgaWYgKHJhdGlvdyA8IHJhdGlvaCkge1xcbiAgICAgIGggPSB0aGlzLmhlaWdodCAqIHRoaXMuY2FudmFzLndpZHRoIC8gdGhpcy53aWR0aDtcXG4gICAgICB0b3AgPSBwYXJzZUludCgodGhpcy5jYW52YXMuaGVpZ2h0IC0gdGhpcy5oZWlnaHQgKiB0aGlzLmNhbnZhcy53aWR0aCAvIHRoaXMud2lkdGgpIC8gMik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdyA9IHRoaXMud2lkdGggKiB0aGlzLmNhbnZhcy5oZWlnaHQgLyB0aGlzLmhlaWdodDtcXG4gICAgICBsZWZ0ID0gcGFyc2VJbnQoKHRoaXMuY2FudmFzLndpZHRoIC0gdGhpcy53aWR0aCAqIHRoaXMuY2FudmFzLmhlaWdodCAvIHRoaXMuaGVpZ2h0KSAvIDIpO1xcbiAgICB9XFxuICAgIGdsLnZpZXdwb3J0KGxlZnQsIHRvcCwgdywgaCk7XFxuXFxuICAgIHZhciB0ZXh0dXJlUG9zVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMSwgMSwgMCwgMV0pO1xcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGV4dHVyZVBvc0J1ZmZlcik7XFxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0ZXh0dXJlUG9zVmFsdWVzLCBnbC5EWU5BTUlDX0RSQVcpO1xcblxcbiAgICB2YXIgdVRleHR1cmVQb3NWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAxLCAxLCAwLCAxXSk7XFxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB1VGV4dHVyZVBvc0J1ZmZlcik7XFxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB1VGV4dHVyZVBvc1ZhbHVlcywgZ2wuRFlOQU1JQ19EUkFXKTtcXG5cXG4gICAgdmFyIHZUZXh0dXJlUG9zVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMSwgMSwgMCwgMV0pO1xcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdlRleHR1cmVQb3NCdWZmZXIpO1xcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdlRleHR1cmVQb3NWYWx1ZXMsIGdsLkRZTkFNSUNfRFJBVyk7XFxuXFxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB5VGV4dHVyZVJlZik7XFxuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuTFVNSU5BTkNFLCB5RGF0YVBlclJvdywgeVJvd0NudCwgMCwgZ2wuTFVNSU5BTkNFLCBnbC5VTlNJR05FRF9CWVRFLCB5RGF0YSk7XFxuXFxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTEpO1xcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB1VGV4dHVyZVJlZik7XFxuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuTFVNSU5BTkNFLCB1RGF0YVBlclJvdywgdVJvd0NudCwgMCwgZ2wuTFVNSU5BTkNFLCBnbC5VTlNJR05FRF9CWVRFLCB1RGF0YSk7XFxuXFxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTIpO1xcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB2VGV4dHVyZVJlZik7XFxuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuTFVNSU5BTkNFLCB2RGF0YVBlclJvdywgdlJvd0NudCwgMCwgZ2wuTFVNSU5BTkNFLCBnbC5VTlNJR05FRF9CWVRFLCB2RGF0YSk7XFxuXFxuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xcbiAgfVxcblxcbiAgX2RyYXdQaWN0dXJlUkdCKGRhdGEpIHt9XFxuXFxuICByZW5kZXIoZGF0YSwgd2lkdGgsIGhlaWdodCwgeUxpbmVzaXplLCB1dkxpbmVzaXplKSB7XFxuICAgIHZhciBnbCA9IHRoaXMuY29udGV4dEdMO1xcbiAgICBpZiAoZ2wpIHtcXG4gICAgICB0aGlzLl9kcmF3UGljdHVyZUdMKGRhdGEsIHdpZHRoLCBoZWlnaHQsIHlMaW5lc2l6ZSwgdXZMaW5lc2l6ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhpcy5fZHJhd1BpY3R1cmVSR0IoZGF0YSk7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gWVVWQ2FudmFzO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9zcmMvbW9iaWxlL3l1di1jYW52YXMuanM/XCIpfSxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvbWVkaWEtaW5mby5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vZGVscy9tZWRpYS1pbmZvLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoJ1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5jb25zdCBpc09iamVjdEZpbGxlZCA9IG9iaiA9PiB7XFxuICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XFxuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICAgIGlmIChvYmpba2V5XSA9PT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHRydWU7XFxufTtcXG5cXG5jbGFzcyBNZWRpYUluZm8ge1xcbiAgY29uc3RydWN0b3IoKSB7XFxuICAgIHRoaXMubWltZVR5cGUgPSBudWxsO1xcbiAgICB0aGlzLmR1cmF0aW9uID0gbnVsbDtcXG5cXG4gICAgdGhpcy5oYXNWaWRlbyA9IG51bGw7XFxuICAgIHRoaXMudmlkZW8gPSB7XFxuICAgICAgY29kZWM6IG51bGwsXFxuICAgICAgd2lkdGg6IG51bGwsXFxuICAgICAgaGVpZ2h0OiBudWxsLFxcbiAgICAgIHByb2ZpbGU6IG51bGwsXFxuICAgICAgbGV2ZWw6IG51bGwsXFxuICAgICAgZnJhbWVSYXRlOiB7XFxuICAgICAgICBmaXhlZDogdHJ1ZSxcXG4gICAgICAgIGZwczogMjUsXFxuICAgICAgICBmcHNfbnVtOiAyNTAwMCxcXG4gICAgICAgIGZwc19kZW46IDEwMDBcXG4gICAgICB9LFxcbiAgICAgIGNocm9tYUZvcm1hdDogbnVsbCxcXG4gICAgICBwYXJSYXRpbzoge1xcbiAgICAgICAgd2lkdGg6IDEsXFxuICAgICAgICBoZWlnaHQ6IDFcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIHRoaXMuaGFzQXVkaW8gPSBudWxsO1xcblxcbiAgICB0aGlzLmF1ZGlvID0ge1xcbiAgICAgIGNvZGVjOiBudWxsLFxcbiAgICAgIHNhbXBsZVJhdGU6IG51bGwsXFxuICAgICAgc2FtcGxlUmF0ZUluZGV4OiBudWxsLFxcbiAgICAgIGNoYW5uZWxDb3VudDogbnVsbFxcbiAgICB9O1xcbiAgfVxcblxcbiAgaXNDb21wbGV0ZSgpIHtcXG4gICAgcmV0dXJuIE1lZGlhSW5mby5pc0Jhc2VJbmZvUmVhZHkodGhpcykgJiYgTWVkaWFJbmZvLmlzVmlkZW9SZWFkeSh0aGlzKSAmJiBNZWRpYUluZm8uaXNBdWRpb1JlYWR5KHRoaXMpO1xcbiAgfVxcblxcbiAgc3RhdGljIGlzQmFzZUluZm9SZWFkeShtZWRpYUluZm8pIHtcXG4gICAgcmV0dXJuIGlzT2JqZWN0RmlsbGVkKG1lZGlhSW5mbyk7XFxuICB9XFxuXFxuICBzdGF0aWMgaXNWaWRlb1JlYWR5KG1lZGlhSW5mbykge1xcbiAgICBpZiAoIW1lZGlhSW5mby5oYXNWaWRlbykge1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBpc09iamVjdEZpbGxlZChtZWRpYUluZm8udmlkZW8pO1xcbiAgfVxcblxcbiAgc3RhdGljIGlzQXVkaW9SZWFkeShtZWRpYUluZm8pIHtcXG4gICAgaWYgKCFtZWRpYUluZm8uaGFzQXVkaW8pIHtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gaXNPYmplY3RGaWxsZWQobWVkaWFJbmZvLnZpZGVvKTtcXG4gIH1cXG59XFxuZXhwb3J0cy5kZWZhdWx0ID0gTWVkaWFJbmZvO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9zcmMvbW9kZWxzL21lZGlhLWluZm8uanM/Jyl9LFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vZGVscy9tZWRpYS1zYW1wbGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vZGVscy9tZWRpYS1zYW1wbGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5jbGFzcyBNZWRpYVNhbXBsZSB7XFxuICBjb25zdHJ1Y3RvcihpbmZvKSB7XFxuICAgIGxldCBfZGVmYXVsdCA9IE1lZGlhU2FtcGxlLmdldERlZmF1bHRJbmYoKTtcXG5cXG4gICAgaWYgKCFpbmZvIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbmZvKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcXG4gICAgICByZXR1cm4gX2RlZmF1bHQ7XFxuICAgIH1cXG4gICAgbGV0IHNhbXBsZSA9IE9iamVjdC5hc3NpZ24oe30sIF9kZWZhdWx0LCBpbmZvKTtcXG5cXG4gICAgT2JqZWN0LmVudHJpZXMoc2FtcGxlKS5mb3JFYWNoKChbaywgdl0pID0+IHtcXG4gICAgICB0aGlzW2tdID0gdjtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0RGVmYXVsdEluZigpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBkdHM6IG51bGwsXFxuICAgICAgcHRzOiBudWxsLFxcbiAgICAgIGR1cmF0aW9uOiBudWxsLFxcbiAgICAgIHBvc2l0aW9uOiBudWxsLFxcbiAgICAgIGlzUkFQOiBmYWxzZSwgLy8gaXMgUmFuZG9tIGFjY2VzcyBwb2ludFxcbiAgICAgIG9yaWdpbkR0czogbnVsbFxcbiAgICB9O1xcbiAgfVxcbn1cXG5leHBvcnRzLmRlZmF1bHQgPSBNZWRpYVNhbXBsZTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vZGVscy9tZWRpYS1zYW1wbGUuanM/XCIpfSxcIi4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvbWVkaWEtc2VnbWVudC1saXN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvbWVkaWEtc2VnbWVudC1saXN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbCgnXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XFxuICAgIHZhbHVlOiB0cnVlXFxufSk7XFxuY2xhc3MgTWVkaWFTZWdtZW50TGlzdCB7XFxuXFxuICAgIGNvbnN0cnVjdG9yKHR5cGUpIHtcXG4gICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xcbiAgICAgICAgdGhpcy5fbGlzdCA9IFtdO1xcbiAgICAgICAgdGhpcy5fbGFzdEFwcGVuZExvY2F0aW9uID0gLTE7IC8vIGNhY2hlZCBsYXN0IGluc2VydCBsb2NhdGlvblxcbiAgICB9XFxuXFxuICAgIGdldCB0eXBlKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XFxuICAgIH1cXG5cXG4gICAgZ2V0IGxlbmd0aCgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9saXN0Lmxlbmd0aDtcXG4gICAgfVxcblxcbiAgICBpc0VtcHR5KCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3QubGVuZ3RoID09PSAwO1xcbiAgICB9XFxuXFxuICAgIGNsZWFyKCkge1xcbiAgICAgICAgdGhpcy5fbGlzdCA9IFtdO1xcbiAgICAgICAgdGhpcy5fbGFzdEFwcGVuZExvY2F0aW9uID0gLTE7XFxuICAgIH1cXG5cXG4gICAgX3NlYXJjaE5lYXJlc3RTZWdtZW50QmVmb3JlKGJlZ2luRHRzKSB7XFxuICAgICAgICBsZXQgbGlzdCA9IHRoaXMuX2xpc3Q7XFxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gLTI7XFxuICAgICAgICB9XFxuICAgICAgICBsZXQgbGFzdCA9IGxpc3QubGVuZ3RoIC0gMTtcXG4gICAgICAgIGxldCBtaWQgPSAwO1xcbiAgICAgICAgbGV0IGxib3VuZCA9IDA7XFxuICAgICAgICBsZXQgdWJvdW5kID0gbGFzdDtcXG5cXG4gICAgICAgIGxldCBpZHggPSAwO1xcblxcbiAgICAgICAgaWYgKGJlZ2luRHRzIDwgbGlzdFswXS5vcmlnaW5EdHMpIHtcXG4gICAgICAgICAgICBpZHggPSAtMTtcXG4gICAgICAgICAgICByZXR1cm4gaWR4O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgd2hpbGUgKGxib3VuZCA8PSB1Ym91bmQpIHtcXG4gICAgICAgICAgICBtaWQgPSBsYm91bmQgKyBNYXRoLmZsb29yKCh1Ym91bmQgLSBsYm91bmQpIC8gMik7XFxuICAgICAgICAgICAgaWYgKG1pZCA9PT0gbGFzdCB8fCBiZWdpbkR0cyA+IGxpc3RbbWlkXS5sYXN0U2FtcGxlLm9yaWdpbkR0cyAmJiBiZWdpbkR0cyA8IGxpc3RbbWlkICsgMV0ub3JpZ2luRHRzKSB7XFxuICAgICAgICAgICAgICAgIGlkeCA9IG1pZDtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChsaXN0W21pZF0ub3JpZ2luRHRzIDwgYmVnaW5EdHMpIHtcXG4gICAgICAgICAgICAgICAgbGJvdW5kID0gbWlkICsgMTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB1Ym91bmQgPSBtaWQgLSAxO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBpZHg7XFxuICAgIH1cXG5cXG4gICAgX3NlYXJjaE5lYXJlc3RTZWdtZW50QWZ0ZXIoYmVnaW5EdHMpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9zZWFyY2hOZWFyZXN0U2VnbWVudEJlZm9yZShiZWdpbkR0cykgKyAxO1xcbiAgICB9XFxuXFxuICAgIGFwcGVuZChzZWdtZW50KSB7XFxuICAgICAgICBsZXQgbGlzdCA9IHRoaXMuX2xpc3Q7XFxuICAgICAgICBsZXQgbGFzdEFwcGVuZElkeCA9IHRoaXMuX2xhc3RBcHBlbmRMb2NhdGlvbjtcXG4gICAgICAgIGxldCBpbnNlcnRJZHggPSAwO1xcblxcbiAgICAgICAgaWYgKGxhc3RBcHBlbmRJZHggIT09IC0xICYmIGxhc3RBcHBlbmRJZHggPCBsaXN0Lmxlbmd0aCAmJiBzZWdtZW50Lm9yaWdpblN0YXJ0RHRzID49IGxpc3RbbGFzdEFwcGVuZElkeF0ubGFzdFNhbXBsZS5vcmlnaW5EdHMgJiYgKGxhc3RBcHBlbmRJZHggPT09IGxpc3QubGVuZ3RoIC0gMSB8fCBsYXN0QXBwZW5kSWR4IDwgbGlzdC5sZW5ndGggLSAxICYmIHNlZ21lbnQub3JpZ2luU3RhcnREdHMgPCBsaXN0W2xhc3RBcHBlbmRJZHggKyAxXS5vcmlnaW5TdGFydER0cykpIHtcXG4gICAgICAgICAgICBpbnNlcnRJZHggPSBsYXN0QXBwZW5kSWR4ICsgMTsgLy8gdXNlIGNhY2hlZCBsb2NhdGlvbiBpZHhcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgaWYgKGxpc3QubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgICAgICBpbnNlcnRJZHggPSB0aGlzLl9zZWFyY2hOZWFyZXN0U2VnbWVudEJlZm9yZShzZWdtZW50Lm9yaWdpblN0YXJ0RHRzKSArIDE7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fbGFzdEFwcGVuZExvY2F0aW9uID0gaW5zZXJ0SWR4O1xcbiAgICAgICAgdGhpcy5fbGlzdC5zcGxpY2UoaW5zZXJ0SWR4LCAwLCBzZWdtZW50KTtcXG4gICAgfVxcblxcbiAgICBnZXRMYXN0U2VnbWVudEJlZm9yZShiZWdpbkR0cykge1xcbiAgICAgICAgbGV0IGlkeCA9IHRoaXMuX3NlYXJjaE5lYXJlc3RTZWdtZW50QmVmb3JlKGJlZ2luRHRzKTtcXG4gICAgICAgIGlmIChpZHggPj0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saXN0W2lkeF07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIC8vIC0xXFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgZ2V0TGFzdFNhbXBsZUJlZm9yZShiZWdpbkR0cykge1xcbiAgICAgICAgbGV0IHNlZ21lbnQgPSB0aGlzLmdldExhc3RTZWdtZW50QmVmb3JlKGJlZ2luRHRzKTtcXG4gICAgICAgIGlmIChzZWdtZW50ICE9PSBudWxsKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnQubGFzdFNhbXBsZTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgZ2V0TGFzdFJBUEJlZm9yZShiZWdpbkR0cykge1xcbiAgICAgICAgbGV0IHNlZ21lbnRJZHggPSB0aGlzLl9zZWFyY2hOZWFyZXN0U2VnbWVudEJlZm9yZShiZWdpbkR0cyk7XFxuICAgICAgICBsZXQgcmFuZG9tQWNjZXNzUG9pbnRzID0gdGhpcy5fbGlzdFtzZWdtZW50SWR4XS5yYW5kb21BY2Nlc3NQb2ludHM7XFxuICAgICAgICB3aGlsZSAocmFuZG9tQWNjZXNzUG9pbnRzLmxlbmd0aCA9PT0gMCAmJiBzZWdtZW50SWR4ID4gMCkge1xcbiAgICAgICAgICAgIHNlZ21lbnRJZHgtLTtcXG4gICAgICAgICAgICByYW5kb21BY2Nlc3NQb2ludHMgPSB0aGlzLl9saXN0W3NlZ21lbnRJZHhdLnJhbmRvbUFjY2Vzc1BvaW50cztcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChyYW5kb21BY2Nlc3NQb2ludHMubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgIHJldHVybiByYW5kb21BY2Nlc3NQb2ludHNbcmFuZG9tQWNjZXNzUG9pbnRzLmxlbmd0aCAtIDFdO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbn1cXG5leHBvcnRzLmRlZmF1bHQgPSBNZWRpYVNlZ21lbnRMaXN0O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9zcmMvbW9kZWxzL21lZGlhLXNlZ21lbnQtbGlzdC5qcz8nKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvbW9kZWxzL21lZGlhLXNlZ21lbnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvbWVkaWEtc2VnbWVudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKCdcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcXG4gICAgdmFsdWU6IHRydWVcXG59KTtcXG5jbGFzcyBNZWRpYVNlZ21lbnQge1xcbiAgICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgICAgIHRoaXMuc3RhcnREdHMgPSAtMTtcXG4gICAgICAgIHRoaXMuZW5kRHRzID0gLTE7XFxuICAgICAgICB0aGlzLnN0YXJ0UHRzID0gLTE7XFxuICAgICAgICB0aGlzLmVuZFB0cyA9IC0xO1xcbiAgICAgICAgdGhpcy5vcmlnaW5TdGFydER0cyA9IC0xO1xcbiAgICAgICAgdGhpcy5vcmlnaW5FbmREdHMgPSAtMTtcXG4gICAgICAgIHRoaXMucmFuZG9tQWNjZXNzUG9pbnRzID0gW107XFxuICAgICAgICB0aGlzLmZpcnN0U2FtcGxlID0gbnVsbDtcXG4gICAgICAgIHRoaXMubGFzdFNhbXBsZSA9IG51bGw7XFxuICAgIH1cXG5cXG4gICAgYWRkUkFQKHNhbXBsZSkge1xcbiAgICAgICAgc2FtcGxlLmlzUkFQID0gdHJ1ZTtcXG4gICAgICAgIHRoaXMucmFuZG9tQWNjZXNzUG9pbnRzLnB1c2goc2FtcGxlKTtcXG4gICAgfVxcbn1cXG5leHBvcnRzLmRlZmF1bHQgPSBNZWRpYVNlZ21lbnQ7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvbWVkaWEtc2VnbWVudC5qcz8nKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvbW9kZWxzL3RyYWNrLW1ldGEuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXV0aWxzL3NyYy9tb2RlbHMvdHJhY2stbWV0YS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5jbGFzcyBBdWRpb1RyYWNrTWV0YSB7XFxuICBjb25zdHJ1Y3RvcihtZXRhKSB7XFxuICAgIGNvbnN0IF9kZWZhdWx0ID0ge1xcbiAgICAgIHNhbXBsZVJhdGU6IDQ4MDAwLFxcbiAgICAgIGNoYW5uZWxDb3VudDogMixcXG4gICAgICBjb2RlYzogJ21wNGEuNDAuMicsXFxuICAgICAgY29uZmlnOiBbNDEsIDQwMSwgMTM2LCAwXSxcXG4gICAgICBkdXJhdGlvbjogMCxcXG4gICAgICBpZDogMixcXG4gICAgICByZWZTYW1wbGVEdXJhdGlvbjogMjEsXFxuICAgICAgc2FtcGxlUmF0ZUluZGV4OiAzLFxcbiAgICAgIHRpbWVzY2FsZTogMTAwMCxcXG4gICAgICB0eXBlOiAnYXVkaW8nXFxuICAgIH07XFxuICAgIGlmIChtZXRhKSB7XFxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIF9kZWZhdWx0LCBtZXRhKTtcXG4gICAgfVxcbiAgICByZXR1cm4gX2RlZmF1bHQ7XFxuICB9XFxuXFxuICBkZXN0cm95KCkge1xcbiAgICB0aGlzLmluaXQgPSBudWxsO1xcbiAgfVxcbn1cXG5cXG5leHBvcnRzLkF1ZGlvVHJhY2tNZXRhID0gQXVkaW9UcmFja01ldGE7XFxuY2xhc3MgVmlkZW9UcmFja01ldGEge1xcbiAgY29uc3RydWN0b3IobWV0YSkge1xcbiAgICBjb25zdCBfZGVmYXVsdCA9IHtcXG4gICAgICBhdmNjOiBudWxsLFxcbiAgICAgIHNwczogbmV3IFVpbnQ4QXJyYXkoMCksXFxuICAgICAgcHBzOiBuZXcgVWludDhBcnJheSgwKSxcXG4gICAgICBjaHJvbWFGb3JtYXQ6IDQyMCxcXG4gICAgICBjb2RlYzogJ2F2YzEuNjQwMDIwJyxcXG4gICAgICBjb2RlY0hlaWdodDogNzIwLFxcbiAgICAgIGNvZGVjV2lkdGg6IDEyODAsXFxuICAgICAgZHVyYXRpb246IDAsXFxuICAgICAgZnJhbWVSYXRlOiB7XFxuICAgICAgICBmaXhlZDogdHJ1ZSxcXG4gICAgICAgIGZwczogMjUsXFxuICAgICAgICBmcHNfbnVtOiAyNTAwMCxcXG4gICAgICAgIGZwc19kZW46IDEwMDBcXG4gICAgICB9LFxcbiAgICAgIGlkOiAxLFxcbiAgICAgIGxldmVsOiAnMy4yJyxcXG4gICAgICBwcmVzZW50SGVpZ2h0OiA3MjAsXFxuICAgICAgcHJlc2VudFdpZHRoOiAxMjgwLFxcbiAgICAgIHByb2ZpbGU6ICdIaWdoJyxcXG4gICAgICByZWZTYW1wbGVEdXJhdGlvbjogNDAsXFxuICAgICAgcGFyUmF0aW86IHtcXG4gICAgICAgIGhlaWdodDogMSxcXG4gICAgICAgIHdpZHRoOiAxXFxuICAgICAgfSxcXG4gICAgICB0aW1lc2NhbGU6IDEwMDAsXFxuICAgICAgdHlwZTogJ3ZpZGVvJ1xcbiAgICB9O1xcblxcbiAgICBpZiAobWV0YSkge1xcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBfZGVmYXVsdCwgbWV0YSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIF9kZWZhdWx0O1xcbiAgfVxcblxcbiAgZGVzdHJveSgpIHtcXG4gICAgdGhpcy5pbml0ID0gbnVsbDtcXG4gICAgdGhpcy5zcHMgPSBudWxsO1xcbiAgICB0aGlzLnBwcyA9IG51bGw7XFxuICB9XFxufVxcbmV4cG9ydHMuVmlkZW9UcmFja01ldGEgPSBWaWRlb1RyYWNrTWV0YTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItdXRpbHMvc3JjL21vZGVscy90cmFjay1tZXRhLmpzP1wiKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvbW9kZWxzL3RyYWNrLXNhbXBsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi94Z3BsYXllci11dGlscy9zcmMvbW9kZWxzL3RyYWNrLXNhbXBsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoJ1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5jbGFzcyBBdWRpb1RyYWNrU2FtcGxlIHtcXG4gIGNvbnN0cnVjdG9yKGluZm8pIHtcXG4gICAgbGV0IF9kZWZhdWx0ID0gQXVkaW9UcmFja1NhbXBsZS5nZXREZWZhdWx0KCk7XFxuICAgIGlmICghaW5mbykge1xcbiAgICAgIHJldHVybiBfZGVmYXVsdDtcXG4gICAgfVxcbiAgICBsZXQgc2FtcGxlID0gT2JqZWN0LmFzc2lnbih7fSwgX2RlZmF1bHQsIGluZm8pO1xcblxcbiAgICByZXR1cm4gc2FtcGxlO1xcbiAgfVxcblxcbiAgc3RhdGljIGdldERlZmF1bHQoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgZHRzOiBudWxsLFxcbiAgICAgIHB0czogbnVsbCxcXG4gICAgICBkYXRhOiBuZXcgVWludDhBcnJheSgpXFxuICAgIH07XFxuICB9XFxufVxcblxcbmV4cG9ydHMuQXVkaW9UcmFja1NhbXBsZSA9IEF1ZGlvVHJhY2tTYW1wbGU7XFxuY2xhc3MgVmlkZW9UcmFja1NhbXBsZSB7XFxuICBjb25zdHJ1Y3RvcihpbmZvKSB7XFxuICAgIGxldCBfZGVmYXVsdCA9IFZpZGVvVHJhY2tTYW1wbGUuZ2V0RGVmYXVsdCgpO1xcblxcbiAgICBpZiAoIWluZm8pIHtcXG4gICAgICByZXR1cm4gX2RlZmF1bHQ7XFxuICAgIH1cXG4gICAgbGV0IHNhbXBsZSA9IE9iamVjdC5hc3NpZ24oe30sIF9kZWZhdWx0LCBpbmZvKTtcXG5cXG4gICAgcmV0dXJuIHNhbXBsZTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXREZWZhdWx0KCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGR0czogbnVsbCxcXG4gICAgICBwdHM6IG51bGwsXFxuICAgICAgaXNLZXlmcmFtZTogZmFsc2UsIC8vIGlzIFJhbmRvbSBhY2Nlc3MgcG9pbnRcXG4gICAgICBvcmlnaW5EdHM6IG51bGwsXFxuICAgICAgZGF0YTogbmV3IFVpbnQ4QXJyYXkoKVxcbiAgICB9O1xcbiAgfVxcbn1cXG5leHBvcnRzLlZpZGVvVHJhY2tTYW1wbGUgPSBWaWRlb1RyYWNrU2FtcGxlO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9zcmMvbW9kZWxzL3RyYWNrLXNhbXBsZS5qcz8nKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvbXNlL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvc3JjL21zZS9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuY2xhc3MgTVNFIHtcXG4gIGNvbnN0cnVjdG9yKGNvbmZpZ3MpIHtcXG4gICAgdGhpcy5jb25maWdzID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlncyk7XFxuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5jb25maWdzLmNvbnRhaW5lcjtcXG4gICAgdGhpcy5tZWRpYVNvdXJjZSA9IG51bGw7XFxuICAgIHRoaXMuc291cmNlQnVmZmVycyA9IHt9O1xcbiAgICB0aGlzLnByZWxvYWRUaW1lID0gdGhpcy5jb25maWdzLnByZWxvYWRUaW1lIHx8IDE7XFxuICAgIHRoaXMub25Tb3VyY2VPcGVuID0gdGhpcy5vblNvdXJjZU9wZW4uYmluZCh0aGlzKTtcXG4gICAgdGhpcy5vblRpbWVVcGRhdGUgPSB0aGlzLm9uVGltZVVwZGF0ZS5iaW5kKHRoaXMpO1xcbiAgICB0aGlzLm9uVXBkYXRlRW5kID0gdGhpcy5vblVwZGF0ZUVuZC5iaW5kKHRoaXMpO1xcbiAgICB0aGlzLm9uV2FpdGluZyA9IHRoaXMub25XYWl0aW5nLmJpbmQodGhpcyk7XFxuICB9XFxuXFxuICBpbml0KCkge1xcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcXG4gICAgdGhpcy5tZWRpYVNvdXJjZSA9IG5ldyBzZWxmLk1lZGlhU291cmNlKCk7XFxuICAgIHRoaXMubWVkaWFTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMub25Tb3VyY2VPcGVuKTtcXG4gICAgdGhpcy5jb250YWluZXIuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh0aGlzLm1lZGlhU291cmNlKTtcXG4gICAgdGhpcy51cmwgPSB0aGlzLmNvbnRhaW5lci5zcmM7XFxuICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLm9uVGltZVVwZGF0ZSk7XFxuICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dhaXRpbmcnLCB0aGlzLm9uV2FpdGluZyk7XFxuICB9XFxuXFxuICBvblRpbWVVcGRhdGUoKSB7XFxuICAgIHRoaXMuZW1pdCgnVElNRV9VUERBVEUnLCB0aGlzLmNvbnRhaW5lcik7XFxuICB9XFxuXFxuICBvbldhaXRpbmcoKSB7XFxuICAgIHRoaXMuZW1pdCgnV0FJVElORycsIHRoaXMuY29udGFpbmVyKTtcXG4gIH1cXG5cXG4gIG9uU291cmNlT3BlbigpIHtcXG4gICAgdGhpcy5hZGRTb3VyY2VCdWZmZXJzKCk7XFxuICB9XFxuXFxuICBvblVwZGF0ZUVuZCgpIHtcXG4gICAgdGhpcy5lbWl0KCdTT1VSQ0VfVVBEQVRFX0VORCcpO1xcbiAgICB0aGlzLmRvQXBwZW5kKCk7XFxuICB9XFxuICBhZGRTb3VyY2VCdWZmZXJzKCkge1xcbiAgICBpZiAodGhpcy5tZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgbGV0IHNvdXJjZXMgPSB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKCdQUkVfU09VUkNFX0JVRkZFUicpO1xcbiAgICBsZXQgdHJhY2tzID0gdGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZSgnVFJBQ0tTJyk7XFxuICAgIGxldCB0cmFjaztcXG5cXG4gICAgc291cmNlcyA9IHNvdXJjZXMuc291cmNlcztcXG4gICAgbGV0IGFkZCA9IGZhbHNlO1xcbiAgICBmb3IgKGxldCBpID0gMCwgayA9IE9iamVjdC5rZXlzKHNvdXJjZXMpLmxlbmd0aDsgaSA8IGs7IGkrKykge1xcbiAgICAgIGxldCB0eXBlID0gT2JqZWN0LmtleXMoc291cmNlcylbaV07XFxuICAgICAgaWYgKHR5cGUgPT09ICdhdWRpbycpIHtcXG4gICAgICAgIHRyYWNrID0gdHJhY2tzLmF1ZGlvVHJhY2s7XFxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndmlkZW8nKSB7XFxuICAgICAgICB0cmFjayA9IHRyYWNrcy52aWRlb1RyYWNrO1xcbiAgICAgICAgLy8gcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICBpZiAodHJhY2spIHtcXG4gICAgICAgIGxldCBkdXIgPSB0eXBlID09PSAnYXVkaW8nID8gMjEgOiA0MDtcXG4gICAgICAgIGlmICh0cmFjay5tZXRhICYmIHRyYWNrLm1ldGEucmVmU2FtcGxlRHVyYXRpb24pIGR1ciA9IHRyYWNrLm1ldGEucmVmU2FtcGxlRHVyYXRpb247XFxuICAgICAgICBpZiAoc291cmNlc1t0eXBlXS5kYXRhLmxlbmd0aCA+PSB0aGlzLnByZWxvYWRUaW1lIC8gZHVyKSB7XFxuICAgICAgICAgIGFkZCA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChhZGQpIHtcXG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXJzKS5sZW5ndGggPiAwKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICAgIGZvciAobGV0IGkgPSAwLCBrID0gT2JqZWN0LmtleXMoc291cmNlcykubGVuZ3RoOyBpIDwgazsgaSsrKSB7XFxuICAgICAgICBsZXQgdHlwZSA9IE9iamVjdC5rZXlzKHNvdXJjZXMpW2ldO1xcbiAgICAgICAgbGV0IHNvdXJjZSA9IHNvdXJjZXNbdHlwZV07XFxuICAgICAgICBsZXQgbWltZSA9IHR5cGUgPT09ICd2aWRlbycgPyAndmlkZW8vbXA0O2NvZGVjcz0nICsgc291cmNlLm1pbWV0eXBlIDogJ2F1ZGlvL21wNDtjb2RlY3M9JyArIHNvdXJjZS5taW1ldHlwZTtcXG4gICAgICAgIGxldCBzb3VyY2VCdWZmZXIgPSB0aGlzLm1lZGlhU291cmNlLmFkZFNvdXJjZUJ1ZmZlcihtaW1lKTtcXG4gICAgICAgIHRoaXMuc291cmNlQnVmZmVyc1t0eXBlXSA9IHNvdXJjZUJ1ZmZlcjtcXG4gICAgICAgIHNvdXJjZUJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCB0aGlzLm9uVXBkYXRlRW5kKTtcXG4gICAgICAgIHRoaXMuZG9BcHBlbmQoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGRvQXBwZW5kKCkge1xcbiAgICBsZXQgc291cmNlcyA9IHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoJ1BSRV9TT1VSQ0VfQlVGRkVSJyk7XFxuICAgIGlmIChzb3VyY2VzKSB7XFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcnMpLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBsZXQgdHlwZSA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVycylbaV07XFxuICAgICAgICBsZXQgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXJzW3R5cGVdO1xcbiAgICAgICAgaWYgKCFzb3VyY2VCdWZmZXIudXBkYXRpbmcpIHtcXG4gICAgICAgICAgbGV0IHNvdXJjZSA9IHNvdXJjZXMuc291cmNlc1t0eXBlXTtcXG4gICAgICAgICAgaWYgKHNvdXJjZSAmJiAhc291cmNlLmluaXRlZCkge1xcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdhcHBlbmQgaW5pdGlhbCBzZWdtZW50JylcXG4gICAgICAgICAgICBzb3VyY2VCdWZmZXIuYXBwZW5kQnVmZmVyKHNvdXJjZS5pbml0LmJ1ZmZlci5idWZmZXIpO1xcbiAgICAgICAgICAgIHNvdXJjZS5pbml0ZWQgPSB0cnVlO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZSkge1xcbiAgICAgICAgICAgIGxldCBkYXRhID0gc291cmNlLmRhdGEuc2hpZnQoKTtcXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xcbiAgICAgICAgICAgICAgc291cmNlQnVmZmVyLmFwcGVuZEJ1ZmZlcihkYXRhLmJ1ZmZlci5idWZmZXIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZW5kT2ZTdHJlYW0oKSB7XFxuICAgIGNvbnN0IHsgcmVhZHlTdGF0ZSwgYWN0aXZlU291cmNlQnVmZmVycyB9ID0gdGhpcy5tZWRpYVNvdXJjZTtcXG4gICAgaWYgKHJlYWR5U3RhdGUgPT09ICdvcGVuJyAmJiBhY3RpdmVTb3VyY2VCdWZmZXJzLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICB0aGlzLm1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCk7XFxuICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgLy8gbG9nXFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICByZW1vdmUoZW5kLCBzdGFydCA9IDApIHtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcnMpLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgbGV0IGJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyc1tPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcnMpW2ldXTtcXG4gICAgICBpZiAoIWJ1ZmZlci51cGRhdGluZykge1xcbiAgICAgICAgLy8gY29uc29sZS5sb2coc3RhcnQsIGVuZClcXG4gICAgICAgIGJ1ZmZlci5yZW1vdmUoc3RhcnQsIGVuZCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICByZW1vdmVCdWZmZXJzKCkge1xcbiAgICBjb25zdCB0YXNrTGlzdCA9IFtdO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVycykubGVuZ3RoOyBpKyspIHtcXG4gICAgICBsZXQgYnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXJzW09iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVycylbaV1dO1xcbiAgICAgIGJ1ZmZlci5yZW1vdmVFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCB0aGlzLm9uVXBkYXRlRW5kKTtcXG5cXG4gICAgICBsZXQgdGFzaztcXG4gICAgICBpZiAoYnVmZmVyLnVwZGF0aW5nKSB7XFxuICAgICAgICB0YXNrID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XFxuICAgICAgICAgIGNvbnN0IGRvQ2xlYW5CdWZmZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgbGV0IHJldHJ5VGltZSA9IDM7XFxuXFxuICAgICAgICAgICAgY29uc3QgY2xlYW4gPSAoKSA9PiB7XFxuICAgICAgICAgICAgICBpZiAoIWJ1ZmZlci51cGRhdGluZykge1xcbiAgICAgICAgICAgICAgICBNU0UuY2xlYXJCdWZmZXIoYnVmZmVyKTtcXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXRyeVRpbWUgPiAwKSB7XFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2xlYW4sIDIwMCk7XFxuICAgICAgICAgICAgICAgIHJldHJ5VGltZS0tO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH07XFxuXFxuICAgICAgICAgICAgc2V0VGltZW91dChjbGVhbiwgMjAwKTtcXG4gICAgICAgICAgICBidWZmZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgZG9DbGVhbkJ1ZmZlcik7XFxuICAgICAgICAgIH07XFxuICAgICAgICAgIGJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVlbmQnLCBkb0NsZWFuQnVmZmVyKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBNU0UuY2xlYXJCdWZmZXIoYnVmZmVyKTtcXG4gICAgICAgIHRhc2sgPSBQcm9taXNlLnJlc29sdmUoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGFza0xpc3QucHVzaCh0YXNrKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodGFza0xpc3QpO1xcbiAgfVxcblxcbiAgZGVzdHJveSgpIHtcXG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlQnVmZmVycygpLnRoZW4oKCkgPT4ge1xcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXJzKS5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgbGV0IGJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyc1tPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcnMpW2ldXTtcXG4gICAgICAgIHRoaXMubWVkaWFTb3VyY2UucmVtb3ZlU291cmNlQnVmZmVyKGJ1ZmZlcik7XFxuICAgICAgICBkZWxldGUgdGhpcy5zb3VyY2VCdWZmZXJzW09iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVycylbaV1dO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGhpcy5vblRpbWVVcGRhdGUpO1xcbiAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dhaXRpbmcnLCB0aGlzLm9uV2FpdGluZyk7XFxuICAgICAgdGhpcy5tZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5vblNvdXJjZU9wZW4pO1xcblxcbiAgICAgIHRoaXMuZW5kT2ZTdHJlYW0oKTtcXG4gICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLnVybCk7XFxuXFxuICAgICAgdGhpcy51cmwgPSBudWxsO1xcbiAgICAgIHRoaXMuY29uZmlncyA9IHt9O1xcbiAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcXG4gICAgICB0aGlzLm1lZGlhU291cmNlID0gbnVsbDtcXG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMgPSB7fTtcXG4gICAgICB0aGlzLnByZWxvYWRUaW1lID0gMTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBzdGF0aWMgY2xlYXJCdWZmZXIoYnVmZmVyKSB7XFxuICAgIGNvbnN0IGJ1ZmZlcmVkID0gYnVmZmVyLmJ1ZmZlcmVkO1xcbiAgICBsZXQgYkVuZCA9IDAuMTtcXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGJ1ZmZlcmVkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgYkVuZCA9IGJ1ZmZlcmVkLmVuZChpKTtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgIGJ1ZmZlci5yZW1vdmUoMCwgYkVuZCk7XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAvLyBETyBOT1RISU5HXFxuICAgIH1cXG4gIH1cXG59XFxuZXhwb3J0cy5kZWZhdWx0ID0gTVNFO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9zcmMvbXNlL2luZGV4LmpzP1wiKX0sXCIuLi94Z3BsYXllci11dGlscy9zcmMvd3JpdGUvYnVmZmVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4veGdwbGF5ZXItdXRpbHMvc3JjL3dyaXRlL2J1ZmZlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovZnVuY3Rpb24obW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIF9jb25jYXRUeXBlZEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29uY2F0LXR5cGVkLWFycmF5ICovIFxcXCIuLi94Z3BsYXllci11dGlscy9ub2RlX21vZHVsZXMvY29uY2F0LXR5cGVkLWFycmF5L2xpYi9pbmRleC5qc1xcXCIpO1xcblxcbnZhciBfY29uY2F0VHlwZWRBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb25jYXRUeXBlZEFycmF5KTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxcblxcbmNsYXNzIEJ1ZmZlciB7XFxuICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcXG4gICAgdGhpcy5idWZmZXIgPSBidWZmZXIgfHwgbmV3IFVpbnQ4QXJyYXkoMCk7XFxuICB9XFxuXFxuICB3cml0ZSguLi5idWZmZXIpIHtcXG4gICAgYnVmZmVyLmZvckVhY2goaXRlbSA9PiB7XFxuICAgICAgdGhpcy5idWZmZXIgPSAoMCwgX2NvbmNhdFR5cGVkQXJyYXkyLmRlZmF1bHQpKFVpbnQ4QXJyYXksIHRoaXMuYnVmZmVyLCBpdGVtKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBzdGF0aWMgd3JpdGVVaW50MzIodmFsdWUpIHtcXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFt2YWx1ZSA+PiAyNCwgdmFsdWUgPj4gMTYgJiAweGZmLCB2YWx1ZSA+PiA4ICYgMHhmZiwgdmFsdWUgJiAweGZmXSk7XFxuICB9XFxuXFxuICBzdGF0aWMgcmVhZEFzSW50KGFycikge1xcbiAgICBsZXQgdGVtcCA9ICcnO1xcblxcbiAgICBmdW5jdGlvbiBwYWRTdGFydDRIZXgoaGV4TnVtKSB7XFxuICAgICAgbGV0IGhleFN0ciA9IGhleE51bS50b1N0cmluZygxNik7XFxuICAgICAgcmV0dXJuIGhleFN0ci5wYWRTdGFydCgyLCAnMCcpO1xcbiAgICB9XFxuXFxuICAgIGFyci5mb3JFYWNoKG51bSA9PiB7XFxuICAgICAgdGVtcCArPSBwYWRTdGFydDRIZXgobnVtKTtcXG4gICAgfSk7XFxuICAgIHJldHVybiBwYXJzZUludCh0ZW1wLCAxNik7XFxuICB9XFxufVxcblxcbmV4cG9ydHMuZGVmYXVsdCA9IEJ1ZmZlcjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi4veGdwbGF5ZXItdXRpbHMvc3JjL3dyaXRlL2J1ZmZlci5qcz9cIil9LFwiLi4veGdwbGF5ZXItdXRpbHMvc3JjL3dyaXRlL3N0cmVhbS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL3hncGxheWVyLXV0aWxzL3NyYy93cml0ZS9zdHJlYW0uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbmNsYXNzIFN0cmVhbSB7XFxuICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcXG4gICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XFxuICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XFxuICAgICAgdGhpcy5kYXRhdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xcbiAgICAgIHRoaXMuZGF0YXZpZXcucG9zaXRpb24gPSAwO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGF0YSBpcyBpbnZhbGlkJyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGdldCBsZW5ndGgoKSB7XFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xcbiAgfVxcblxcbiAgc2V0IHBvc2l0aW9uKHZhbHVlKSB7XFxuICAgIHRoaXMuZGF0YXZpZXcucG9zaXRpb24gPSB2YWx1ZTtcXG4gIH1cXG5cXG4gIGdldCBwb3NpdGlvbigpIHtcXG4gICAgcmV0dXJuIHRoaXMuZGF0YXZpZXcucG9zaXRpb247XFxuICB9XFxuXFxuICBiYWNrKGNvdW50KSB7XFxuICAgIHRoaXMucG9zaXRpb24gLT0gY291bnQ7XFxuICB9XFxuXFxuICBza2lwKGNvdW50KSB7XFxuICAgIGxldCBsb29wID0gTWF0aC5mbG9vcihjb3VudCAvIDQpO1xcbiAgICBsZXQgbGFzdCA9IGNvdW50ICUgNDtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb29wOyBpKyspIHtcXG4gICAgICBTdHJlYW0ucmVhZEJ5dGUodGhpcy5kYXRhdmlldywgNCk7XFxuICAgIH1cXG4gICAgaWYgKGxhc3QgPiAwKSB7XFxuICAgICAgU3RyZWFtLnJlYWRCeXRlKHRoaXMuZGF0YXZpZXcsIGxhc3QpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvKipcXG4gICAqIFtyZWFkQnl0ZSDku45EYXRhVmlld+S4reivu+WPluaVsOaNrl1cXG4gICAqIEBwYXJhbSAge0RhdGFWaWV3fSBidWZmZXIgW0RhdGFWaWV35a6e5L6LXVxcbiAgICogQHBhcmFtICB7TnVtYmVyfSBzaXplICAgW+ivu+WPluWtl+iKguaVsF1cXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgIFvmlbTmlbBdXFxuICAgKi9cXG4gIHN0YXRpYyByZWFkQnl0ZShidWZmZXIsIHNpemUsIHNpZ24pIHtcXG4gICAgbGV0IHJlcztcXG4gICAgc3dpdGNoIChzaXplKSB7XFxuICAgICAgY2FzZSAxOlxcbiAgICAgICAgaWYgKHNpZ24pIHtcXG4gICAgICAgICAgcmVzID0gYnVmZmVyLmdldEludDgoYnVmZmVyLnBvc2l0aW9uKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJlcyA9IGJ1ZmZlci5nZXRVaW50OChidWZmZXIucG9zaXRpb24pO1xcbiAgICAgICAgfVxcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAyOlxcbiAgICAgICAgaWYgKHNpZ24pIHtcXG4gICAgICAgICAgcmVzID0gYnVmZmVyLmdldEludDE2KGJ1ZmZlci5wb3NpdGlvbik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXMgPSBidWZmZXIuZ2V0VWludDE2KGJ1ZmZlci5wb3NpdGlvbik7XFxuICAgICAgICB9XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIDM6XFxuICAgICAgICBpZiAoc2lnbikge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBzdXBwb3J0ZWQgZm9yIHJlYWRCeXRlIDMnKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJlcyA9IGJ1ZmZlci5nZXRVaW50OChidWZmZXIucG9zaXRpb24pIDw8IDE2O1xcbiAgICAgICAgICByZXMgfD0gYnVmZmVyLmdldFVpbnQ4KGJ1ZmZlci5wb3NpdGlvbiArIDEpIDw8IDg7XFxuICAgICAgICAgIHJlcyB8PSBidWZmZXIuZ2V0VWludDgoYnVmZmVyLnBvc2l0aW9uICsgMik7XFxuICAgICAgICB9XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIDQ6XFxuICAgICAgICBpZiAoc2lnbikge1xcbiAgICAgICAgICByZXMgPSBidWZmZXIuZ2V0SW50MzIoYnVmZmVyLnBvc2l0aW9uKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJlcyA9IGJ1ZmZlci5nZXRVaW50MzIoYnVmZmVyLnBvc2l0aW9uKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgODpcXG4gICAgICAgIGlmIChzaWduKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IHN1cHBvcnRlZCBmb3IgcmVhZEJvZHkgOCcpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmVzID0gYnVmZmVyLmdldFVpbnQzMihidWZmZXIucG9zaXRpb24pIDw8IDMyO1xcbiAgICAgICAgICByZXMgfD0gYnVmZmVyLmdldFVpbnQzMihidWZmZXIucG9zaXRpb24gKyA0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICByZXMgPSAnJztcXG4gICAgfVxcbiAgICBidWZmZXIucG9zaXRpb24gKz0gc2l6ZTtcXG4gICAgcmV0dXJuIHJlcztcXG4gIH1cXG5cXG4gIHJlYWRVaW50OCgpIHtcXG4gICAgcmV0dXJuIFN0cmVhbS5yZWFkQnl0ZSh0aGlzLmRhdGF2aWV3LCAxKTtcXG4gIH1cXG5cXG4gIHJlYWRVaW50MTYoKSB7XFxuICAgIHJldHVybiBTdHJlYW0ucmVhZEJ5dGUodGhpcy5kYXRhdmlldywgMik7XFxuICB9XFxuXFxuICByZWFkVWludDI0KCkge1xcbiAgICByZXR1cm4gU3RyZWFtLnJlYWRCeXRlKHRoaXMuZGF0YXZpZXcsIDMpO1xcbiAgfVxcblxcbiAgcmVhZFVpbnQzMigpIHtcXG4gICAgcmV0dXJuIFN0cmVhbS5yZWFkQnl0ZSh0aGlzLmRhdGF2aWV3LCA0KTtcXG4gIH1cXG5cXG4gIHJlYWRVaW50NjQoKSB7XFxuICAgIHJldHVybiBTdHJlYW0ucmVhZEJ5dGUodGhpcy5kYXRhdmlldywgOCk7XFxuICB9XFxuXFxuICByZWFkSW50OCgpIHtcXG4gICAgcmV0dXJuIFN0cmVhbS5yZWFkQnl0ZSh0aGlzLmRhdGF2aWV3LCAxLCB0cnVlKTtcXG4gIH1cXG4gIHJlYWRJbnQxNigpIHtcXG4gICAgcmV0dXJuIFN0cmVhbS5yZWFkQnl0ZSh0aGlzLmRhdGF2aWV3LCAyLCB0cnVlKTtcXG4gIH1cXG5cXG4gIHJlYWRJbnQzMigpIHtcXG4gICAgcmV0dXJuIFN0cmVhbS5yZWFkQnl0ZSh0aGlzLmRhdGF2aWV3LCA0LCB0cnVlKTtcXG4gIH1cXG5cXG4gIHdyaXRlVWludDMyKHZhbHVlKSB7XFxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShbdmFsdWUgPj4+IDI0ICYgMHhmZiwgdmFsdWUgPj4+IDE2ICYgMHhmZiwgdmFsdWUgPj4+IDggJiAweGZmLCB2YWx1ZSAmIDB4ZmZdKTtcXG4gIH1cXG59XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gU3RyZWFtO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi8uLi94Z3BsYXllci11dGlscy9zcmMvd3JpdGUvc3RyZWFtLmpzP1wiKX0sXCIuL3NyYy9mbHYtbGl2ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9mbHYtbGl2ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBfeGdwbGF5ZXJSZW11eCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHhncGxheWVyLXJlbXV4ICovIFxcXCIuLi94Z3BsYXllci1yZW11eC9pbmRleC5qc1xcXCIpO1xcblxcbnZhciBfeGdwbGF5ZXJSZW11eDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF94Z3BsYXllclJlbXV4KTtcXG5cXG52YXIgX3hncGxheWVyTG9hZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgeGdwbGF5ZXItbG9hZGVyICovIFxcXCIuLi94Z3BsYXllci1sb2FkZXIvaW5kZXguanNcXFwiKTtcXG5cXG52YXIgX3hncGxheWVyRGVtdXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB4Z3BsYXllci1kZW11eCAqLyBcXFwiLi4veGdwbGF5ZXItZGVtdXgvaW5kZXguanNcXFwiKTtcXG5cXG52YXIgX3hncGxheWVyQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgeGdwbGF5ZXItYnVmZmVyICovIFxcXCIuLi94Z3BsYXllci1idWZmZXIvaW5kZXguanNcXFwiKTtcXG5cXG52YXIgX3hncGxheWVyVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB4Z3BsYXllci11dGlscyAqLyBcXFwiLi4veGdwbGF5ZXItdXRpbHMvaW5kZXguanNcXFwiKTtcXG5cXG52YXIgX3hncGxheWVyQ29kZWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB4Z3BsYXllci1jb2RlYyAqLyBcXFwiLi4veGdwbGF5ZXItY29kZWMvaW5kZXguanNcXFwiKTtcXG5cXG52YXIgX3hncGxheWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgeGdwbGF5ZXIgKi8gXFxcInhncGxheWVyXFxcIik7XFxuXFxudmFyIF94Z3BsYXllcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF94Z3BsYXllcik7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG5jb25zdCBSRU1VWF9FVkVOVFMgPSBfeGdwbGF5ZXJVdGlscy5FVkVOVFMuUkVNVVhfRVZFTlRTO1xcbmNvbnN0IERFTVVYX0VWRU5UUyA9IF94Z3BsYXllclV0aWxzLkVWRU5UUy5ERU1VWF9FVkVOVFM7XFxuY29uc3QgTE9BREVSX0VWRU5UUyA9IF94Z3BsYXllclV0aWxzLkVWRU5UUy5MT0FERVJfRVZFTlRTO1xcbmNvbnN0IE1TRV9FVkVOVFMgPSBfeGdwbGF5ZXJVdGlscy5FVkVOVFMuTVNFX0VWRU5UUztcXG5cXG5jb25zdCBUYWcgPSAnRkxWQ29udHJvbGxlcic7XFxuXFxuY2xhc3MgTG9nZ2VyIHtcXG4gIHdhcm4oKSB7fVxcbn1cXG5cXG5jb25zdCBGTFZfRVJST1IgPSAnRkxWX0VSUk9SJztcXG5cXG5jbGFzcyBGbHZDb250cm9sbGVyIHtcXG4gIGNvbnN0cnVjdG9yKHBsYXllcikge1xcbiAgICB0aGlzLlRBRyA9IFRhZztcXG4gICAgdGhpcy5fcGxheWVyID0gcGxheWVyO1xcblxcbiAgICB0aGlzLnN0YXRlID0ge1xcbiAgICAgIGluaXRTZWdtZW50QXJyaXZlZDogZmFsc2VcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5idWZmZXJDbGVhclRpbWVyID0gbnVsbDtcXG4gIH1cXG5cXG4gIGluaXQoKSB7XFxuICAgIHRoaXMuX2NvbnRleHQucmVnaXN0cnkoJ0ZFVENIX0xPQURFUicsIF94Z3BsYXllckxvYWRlci5GZXRjaExvYWRlcik7XFxuICAgIHRoaXMuX2NvbnRleHQucmVnaXN0cnkoJ0xPQURFUl9CVUZGRVInLCBfeGdwbGF5ZXJCdWZmZXIuWGdCdWZmZXIpO1xcblxcbiAgICB0aGlzLl9jb250ZXh0LnJlZ2lzdHJ5KCdGTFZfREVNVVhFUicsIF94Z3BsYXllckRlbXV4LkZsdkRlbXV4ZXIpO1xcbiAgICB0aGlzLl9jb250ZXh0LnJlZ2lzdHJ5KCdUUkFDS1MnLCBfeGdwbGF5ZXJCdWZmZXIuVHJhY2tzKTtcXG5cXG4gICAgdGhpcy5fY29udGV4dC5yZWdpc3RyeSgnTVA0X1JFTVVYRVInLCBfeGdwbGF5ZXJSZW11eDIuZGVmYXVsdC5NcDRSZW11eGVyKTtcXG4gICAgdGhpcy5fY29udGV4dC5yZWdpc3RyeSgnUFJFX1NPVVJDRV9CVUZGRVInLCBfeGdwbGF5ZXJCdWZmZXIuUHJlU291cmNlKTtcXG5cXG4gICAgaWYgKHRoaXMuX3BsYXllci5jb25maWcuY29tcGF0aWJpbGl0eSAhPT0gZmFsc2UpIHtcXG4gICAgICB0aGlzLl9jb250ZXh0LnJlZ2lzdHJ5KCdDT01QQVRJQklMSVRZJywgX3hncGxheWVyQ29kZWMuQ29tcGF0aWJpbGl0eSk7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fY29udGV4dC5yZWdpc3RyeSgnTE9HR0VSJywgTG9nZ2VyKTtcXG4gICAgdGhpcy5tc2UgPSB0aGlzLl9jb250ZXh0LnJlZ2lzdHJ5KCdNU0UnLCBfeGdwbGF5ZXJVdGlscy5Nc2UpKHsgY29udGFpbmVyOiB0aGlzLl9wbGF5ZXIudmlkZW8gfSk7XFxuXFxuICAgIHRoaXMuX2hhbmRsZVRpbWVVcGRhdGUgPSB0aGlzLl9oYW5kbGVUaW1lVXBkYXRlLmJpbmQodGhpcyk7XFxuXFxuICAgIHRoaXMuaW5pdExpc3RlbmVycygpO1xcbiAgfVxcblxcbiAgaW5pdExpc3RlbmVycygpIHtcXG4gICAgdGhpcy5vbihMT0FERVJfRVZFTlRTLkxPQURFUl9EQVRBTE9BREVELCB0aGlzLl9oYW5kbGVMb2FkZXJEYXRhTG9hZGVkLmJpbmQodGhpcykpO1xcbiAgICB0aGlzLm9uKExPQURFUl9FVkVOVFMuTE9BREVSX0VSUk9SLCB0aGlzLl9oYW5kbGVOZXR3b3JrRXJyb3IuYmluZCh0aGlzKSk7XFxuXFxuICAgIHRoaXMub24oREVNVVhfRVZFTlRTLk1FRElBX0lORk8sIHRoaXMuX2hhbmRsZU1lZGlhSW5mby5iaW5kKHRoaXMpKTtcXG4gICAgdGhpcy5vbihERU1VWF9FVkVOVFMuTUVUQURBVEFfUEFSU0VELCB0aGlzLl9oYW5kbGVNZXRhZGF0YVBhcnNlZC5iaW5kKHRoaXMpKTtcXG4gICAgdGhpcy5vbihERU1VWF9FVkVOVFMuREVNVVhfQ09NUExFVEUsIHRoaXMuX2hhbmRsZURlbXV4Q29tcGxldGUuYmluZCh0aGlzKSk7XFxuICAgIHRoaXMub24oREVNVVhfRVZFTlRTLkRFTVVYX0VSUk9SLCB0aGlzLl9oYW5kbGVEZW11eEVycm9yLmJpbmQodGhpcykpO1xcblxcbiAgICB0aGlzLm9uKFJFTVVYX0VWRU5UUy5JTklUX1NFR01FTlQsIHRoaXMuX2hhbmRsZUFwcGVuZEluaXRTZWdtZW50LmJpbmQodGhpcykpO1xcbiAgICB0aGlzLm9uKFJFTVVYX0VWRU5UUy5NRURJQV9TRUdNRU5ULCB0aGlzLl9oYW5kbGVNZWRpYVNlZ21lbnQuYmluZCh0aGlzKSk7XFxuXFxuICAgIHRoaXMub24oTVNFX0VWRU5UUy5TT1VSQ0VfVVBEQVRFX0VORCwgdGhpcy5faGFuZGxlU291cmNlVXBkYXRlRW5kLmJpbmQodGhpcykpO1xcblxcbiAgICB0aGlzLl9wbGF5ZXIub24oJ3RpbWV1cGRhdGUnLCB0aGlzLl9oYW5kbGVUaW1lVXBkYXRlKTtcXG4gIH1cXG5cXG4gIF9oYW5kbGVNZWRpYUluZm8oKSB7XFxuICAgIGlmICghdGhpcy5fY29udGV4dC5tZWRpYUluZm8pIHtcXG4gICAgICB0aGlzLmVtaXQoREVNVVhfRVZFTlRTLkRFTVVYX0VSUk9SLCBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgbWVkaWFpbmZvJykpO1xcbiAgICB9XFxuICB9XFxuXFxuICBfaGFuZGxlTG9hZGVyRGF0YUxvYWRlZCgpIHtcXG4gICAgdGhpcy5lbWl0VG8oJ0ZMVl9ERU1VWEVSJywgREVNVVhfRVZFTlRTLkRFTVVYX1NUQVJUKTtcXG4gIH1cXG5cXG4gIF9oYW5kbGVNZXRhZGF0YVBhcnNlZCh0eXBlKSB7XFxuICAgIHRoaXMuZW1pdChSRU1VWF9FVkVOVFMuUkVNVVhfTUVUQURBVEEsIHR5cGUpO1xcbiAgfVxcbiAgX2hhbmRsZURlbXV4Q29tcGxldGUoKSB7XFxuICAgIHRoaXMuZW1pdChSRU1VWF9FVkVOVFMuUkVNVVhfTUVESUEpO1xcbiAgfVxcblxcbiAgX2hhbmRsZUFwcGVuZEluaXRTZWdtZW50KCkge1xcbiAgICB0aGlzLnN0YXRlLmluaXRTZWdtZW50QXJyaXZlZCA9IHRydWU7XFxuICAgIHRoaXMubXNlLmFkZFNvdXJjZUJ1ZmZlcnMoKTtcXG4gIH1cXG5cXG4gIF9oYW5kbGVNZWRpYVNlZ21lbnQoKSB7XFxuICAgIHRoaXMubXNlLmFkZFNvdXJjZUJ1ZmZlcnMoKTtcXG4gICAgdGhpcy5tc2UuZG9BcHBlbmQoKTtcXG4gIH1cXG5cXG4gIF9oYW5kbGVTb3VyY2VVcGRhdGVFbmQoKSB7XFxuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl9wbGF5ZXIuY3VycmVudFRpbWU7XFxuICAgIGNvbnN0IHZpZGVvID0gdGhpcy5fcGxheWVyLnZpZGVvO1xcbiAgICBjb25zdCBwcmVsb2FkVGltZSA9IHRoaXMuX3BsYXllci5jb25maWcucHJlbG9hZFRpbWUgfHwgNTtcXG5cXG4gICAgY29uc3QgeyBsZW5ndGggfSA9IHZpZGVvLmJ1ZmZlcmVkO1xcblxcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IGJ1ZmZlckVuZCA9IHZpZGVvLmJ1ZmZlcmVkLmVuZChsZW5ndGggLSAxKTtcXG4gICAgaWYgKGJ1ZmZlckVuZCAtIHRpbWUgPiBwcmVsb2FkVGltZSAqIDIpIHtcXG4gICAgICB0aGlzLl9wbGF5ZXIuY3VycmVudFRpbWUgPSBidWZmZXJFbmQgLSBwcmVsb2FkVGltZTtcXG4gICAgfVxcbiAgICB0aGlzLm1zZS5kb0FwcGVuZCgpO1xcbiAgfVxcblxcbiAgX2hhbmRsZVRpbWVVcGRhdGUoKSB7XFxuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl9wbGF5ZXIuY3VycmVudFRpbWU7XFxuXFxuICAgIGNvbnN0IHZpZGVvID0gdGhpcy5fcGxheWVyLnZpZGVvO1xcbiAgICBsZXQgYnVmZmVyZWQgPSB2aWRlby5idWZmZXJlZDtcXG5cXG4gICAgaWYgKCFidWZmZXJlZCB8fCAhYnVmZmVyZWQubGVuZ3RoKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IGJ1ZmZlclN0YXJ0ID0gYnVmZmVyZWQuc3RhcnQoYnVmZmVyZWQubGVuZ3RoIC0gMSk7XFxuICAgIC8vIGNvbnN0IGJ1ZmZlclN0YXJ0ID0gdGhpcy5fcGxheWVyLmdldEJ1ZmZlcmVkUmFuZ2UoKVswXVxcbiAgICBpZiAodGltZSAtIGJ1ZmZlclN0YXJ0ID4gMTApIHtcXG4gICAgICAvLyDlnKjnm7Tmkq3ml7blj4rml7bmuIXnqbpidWZmZXLvvIzpmY3kvY7nm7Tmkq3lhoXlrZjljaDnlKhcXG4gICAgICBpZiAodGhpcy5idWZmZXJDbGVhclRpbWVyKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMubXNlLnJlbW92ZSh0aW1lIC0gMSwgYnVmZmVyU3RhcnQpO1xcbiAgICAgIHRoaXMuYnVmZmVyQ2xlYXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xcbiAgICAgICAgdGhpcy5idWZmZXJDbGVhclRpbWVyID0gbnVsbDtcXG4gICAgICB9LCA1MDAwKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgX2hhbmRsZU5ldHdvcmtFcnJvcih0YWcsIGVycikge1xcbiAgICB0aGlzLl9wbGF5ZXIuZW1pdCgnZXJyb3InLCBuZXcgX3hncGxheWVyMi5kZWZhdWx0LkVycm9ycygnbmV0d29yaycsIHRoaXMuX3BsYXllci5jb25maWcudXJsKSk7XFxuICAgIHRoaXMuX29uRXJyb3IoTE9BREVSX0VWRU5UUy5MT0FERVJfRVJST1IsIHRhZywgZXJyLCB0cnVlKTtcXG4gIH1cXG5cXG4gIF9oYW5kbGVEZW11eEVycm9yKHRhZywgZXJyLCBmYXRhbCkge1xcbiAgICBpZiAoZmF0YWwgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIGZhdGFsID0gZmFsc2U7XFxuICAgIH1cXG4gICAgdGhpcy5fcGxheWVyLmVtaXQoJ2Vycm9yJywgbmV3IF94Z3BsYXllcjIuZGVmYXVsdC5FcnJvcnMoJ3BhcnNlJywgdGhpcy5fcGxheWVyLmNvbmZpZy51cmwpKTtcXG4gICAgdGhpcy5fb25FcnJvcihMT0FERVJfRVZFTlRTLkxPQURFUl9FUlJPUiwgdGFnLCBlcnIsIGZhdGFsKTtcXG4gIH1cXG5cXG4gIF9vbkVycm9yKHR5cGUsIG1vZCwgZXJyLCBmYXRhbCkge1xcbiAgICBsZXQgZXJyb3IgPSB7XFxuICAgICAgZXJyb3JUeXBlOiB0eXBlLFxcbiAgICAgIGVycm9yRGV0YWlsczogYFske21vZH1dOiAke2Vyci5tZXNzYWdlfWAsXFxuICAgICAgZXJyb3JGYXRhbDogZmF0YWwgfHwgZmFsc2VcXG4gICAgfTtcXG4gICAgdGhpcy5fcGxheWVyLmVtaXQoRkxWX0VSUk9SLCBlcnJvcik7XFxuICB9XFxuXFxuICBzZWVrKCkge1xcbiAgICBpZiAoIXRoaXMuc3RhdGUuaW5pdFNlZ21lbnRBcnJpdmVkKSB7XFxuICAgICAgdGhpcy5sb2FkRGF0YSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBsb2FkRGF0YSgpIHtcXG4gICAgdGhpcy5lbWl0KExPQURFUl9FVkVOVFMuTEFERVJfU1RBUlQsIHRoaXMuX3BsYXllci5jb25maWcudXJsKTtcXG4gIH1cXG5cXG4gIHBhdXNlKCkge1xcbiAgICBjb25zdCBsb2FkZXIgPSB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKCdGRVRDSF9MT0FERVInKTtcXG5cXG4gICAgaWYgKGxvYWRlcikge1xcbiAgICAgIGxvYWRlci5jYW5jZWwoKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZGVzdHJveSgpIHtcXG4gICAgdGhpcy5fcGxheWVyLm9mZigndGltZXVwZGF0ZScsIHRoaXMuX2hhbmRsZVRpbWVVcGRhdGUpO1xcbiAgICB0aGlzLl9wbGF5ZXIgPSBudWxsO1xcbiAgICB0aGlzLm1zZSA9IG51bGw7XFxuICB9XFxufVxcbmV4cG9ydHMuZGVmYXVsdCA9IEZsdkNvbnRyb2xsZXI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8veGdwbGF5ZXItZmx2Ly4vc3JjL2Zsdi1saXZlLmpzP1wiKX0sXCIuL3NyYy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJcXG5cXG52YXIgX3hncGxheWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgeGdwbGF5ZXIgKi8gXFxcInhncGxheWVyXFxcIik7XFxuXFxudmFyIF94Z3BsYXllcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF94Z3BsYXllcik7XFxuXFxudmFyIF94Z3BsYXllclV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgeGdwbGF5ZXItdXRpbHMgKi8gXFxcIi4uL3hncGxheWVyLXV0aWxzL2luZGV4LmpzXFxcIik7XFxuXFxudmFyIF9mbHZMaXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mbHYtbGl2ZSAqLyBcXFwiLi9zcmMvZmx2LWxpdmUuanNcXFwiKTtcXG5cXG52YXIgX2ZsdkxpdmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmx2TGl2ZSk7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG5jb25zdCBmbHZBbGxvd2VkRXZlbnRzID0gX3hncGxheWVyVXRpbHMuRVZFTlRTLkZsdkFsbG93ZWRFdmVudHM7XFxuXFxuY2xhc3MgRmx2UGxheWVyIGV4dGVuZHMgX3hncGxheWVyMi5kZWZhdWx0IHtcXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xcbiAgICBzdXBlcihjb25maWcpO1xcbiAgICB0aGlzLmNvbnRleHQgPSBuZXcgX3hncGxheWVyVXRpbHMuQ29udGV4dChmbHZBbGxvd2VkRXZlbnRzKTtcXG4gICAgdGhpcy5pbml0RXZlbnRzKCk7XFxuICAgIHRoaXMubG9hZGVyQ29tcGxldGVUaW1lciA9IG51bGw7XFxuICAgIC8vIGNvbnN0IHByZWxvYWRUaW1lID0gcGxheWVyLmNvbmZpZy5wcmVsb2FkVGltZSB8fCAxNVxcbiAgfVxcblxcbiAgc3RhcnQoKSB7XFxuICAgIHRoaXMuaW5pdEZsdigpO1xcbiAgICB0aGlzLmNvbnRleHQuaW5pdCgpO1xcbiAgICBzdXBlci5zdGFydCh0aGlzLmZsdi5tc2UudXJsKTtcXG4gIH1cXG5cXG4gIGluaXRGbHZFdmVudHMoZmx2KSB7XFxuICAgIGNvbnN0IHBsYXllciA9IHRoaXM7XFxuICAgIGZsdi5vbmNlKF94Z3BsYXllclV0aWxzLkVWRU5UUy5SRU1VWF9FVkVOVFMuSU5JVF9TRUdNRU5ULCAoKSA9PiB7XFxuICAgICAgX3hncGxheWVyMi5kZWZhdWx0LnV0aWwuYWRkQ2xhc3MocGxheWVyLnJvb3QsICd4Z3BsYXllci1pcy1saXZlJyk7XFxuICAgICAgaWYgKCFfeGdwbGF5ZXIyLmRlZmF1bHQudXRpbC5maW5kRG9tKHRoaXMucm9vdCwgJ3hnLWxpdmUnKSkge1xcbiAgICAgICAgY29uc3QgbGl2ZSA9IF94Z3BsYXllcjIuZGVmYXVsdC51dGlsLmNyZWF0ZURvbSgneGctbGl2ZScsICfmraPlnKjnm7Tmkq0nLCB7fSwgJ3hncGxheWVyLWxpdmUnKTtcXG4gICAgICAgIHBsYXllci5jb250cm9scy5hcHBlbmRDaGlsZChsaXZlKTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBmbHYub25jZShfeGdwbGF5ZXJVdGlscy5FVkVOVFMuTE9BREVSX0VWRU5UUy5MT0FERVJfQ09NUExFVEUsICgpID0+IHtcXG4gICAgICAvLyDnm7Tmkq3lrozmiJDvvIzlvoXmkq3mlL7lmajmkq3lroznvJPlrZjlkI7lj5HpgIHlhbPpl63kuovku7ZcXG4gICAgICBpZiAoIXBsYXllci5wYXVzZWQpIHtcXG4gICAgICAgIHRoaXMubG9hZGVyQ29tcGxldGVUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcXG4gICAgICAgICAgY29uc3QgZW5kID0gcGxheWVyLmdldEJ1ZmZlcmVkUmFuZ2UoKVsxXTtcXG4gICAgICAgICAgaWYgKE1hdGguYWJzKHBsYXllci5jdXJyZW50VGltZSAtIGVuZCkgPCAwLjUpIHtcXG4gICAgICAgICAgICBwbGF5ZXIuZW1pdCgnZW5kZWQnKTtcXG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmxvYWRlckNvbXBsZXRlVGltZXIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LCAyMDApO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxuICBpbml0RXZlbnRzKCkge1xcbiAgICB0aGlzLm9uKCd0aW1ldXBkYXRlJywgKCkgPT4ge1xcbiAgICAgIHRoaXMubG9hZERhdGEoKTtcXG4gICAgfSk7XFxuXFxuICAgIHRoaXMub24oJ3NlZWtpbmcnLCAoKSA9PiB7XFxuICAgICAgY29uc3QgdGltZSA9IHRoaXMuY3VycmVudFRpbWU7XFxuICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLmdldEJ1ZmZlcmVkUmFuZ2UoKTtcXG4gICAgICBpZiAodGltZSA+IHJhbmdlWzFdIHx8IHRpbWUgPCByYW5nZVswXSkge1xcbiAgICAgICAgdGhpcy5mbHYuc2Vlayh0aGlzLmN1cnJlbnRUaW1lKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgaW5pdEZsdigpIHtcXG4gICAgY29uc3QgZmx2ID0gdGhpcy5jb250ZXh0LnJlZ2lzdHJ5KCdGTFZfQ09OVFJPTExFUicsIF9mbHZMaXZlMi5kZWZhdWx0KSh0aGlzKTtcXG4gICAgdGhpcy5pbml0Rmx2RXZlbnRzKGZsdik7XFxuICAgIHRoaXMuZmx2ID0gZmx2O1xcbiAgfVxcblxcbiAgcGxheSgpIHtcXG4gICAgaWYgKHRoaXMuX2hhc1N0YXJ0KSB7XFxuICAgICAgdGhpcy5fZGVzdHJveSgpLnRoZW4oKCkgPT4ge1xcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbmV3IF94Z3BsYXllclV0aWxzLkNvbnRleHQoZmx2QWxsb3dlZEV2ZW50cyk7XFxuICAgICAgICBjb25zdCBmbHYgPSB0aGlzLmNvbnRleHQucmVnaXN0cnkoJ0ZMVl9DT05UUk9MTEVSJywgX2ZsdkxpdmUyLmRlZmF1bHQpKHRoaXMpO1xcbiAgICAgICAgdGhpcy5pbml0Rmx2RXZlbnRzKGZsdik7XFxuICAgICAgICB0aGlzLmZsdiA9IGZsdjtcXG4gICAgICAgIHRoaXMuY29udGV4dC5pbml0KCk7XFxuICAgICAgICBzdXBlci5zdGFydChmbHYubXNlLnVybCk7XFxuICAgICAgICBzdXBlci5wbGF5KCk7XFxuICAgICAgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3VwZXIucGxheSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBwYXVzZSgpIHtcXG4gICAgc3VwZXIucGF1c2UoKTtcXG4gICAgaWYgKHRoaXMuZmx2KSB7XFxuICAgICAgdGhpcy5mbHYucGF1c2UoKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgbG9hZERhdGEodGltZSA9IHRoaXMuY3VycmVudFRpbWUpIHtcXG4gICAgaWYgKHRoaXMuZmx2KSB7XFxuICAgICAgdGhpcy5mbHYuc2Vlayh0aW1lKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZGVzdHJveSgpIHtcXG4gICAgdGhpcy5fZGVzdHJveSgpLnRoZW4oKCkgPT4ge1xcbiAgICAgIHN1cGVyLmRlc3Ryb3koKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBfZGVzdHJveSgpIHtcXG4gICAgcmV0dXJuIHRoaXMuZmx2Lm1zZS5kZXN0cm95KCkudGhlbigoKSA9PiB7XFxuICAgICAgdGhpcy5jb250ZXh0LmRlc3Ryb3koKTtcXG4gICAgICB0aGlzLmZsdiA9IG51bGw7XFxuICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcXG4gICAgICBpZiAodGhpcy5sb2FkZXJDb21wbGV0ZVRpbWVyKSB7XFxuICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmxvYWRlckNvbXBsZXRlVGltZXIpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxuICBnZXQgc3JjKCkge1xcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U3JjO1xcbiAgfVxcblxcbiAgc2V0IHNyYyh1cmwpIHtcXG4gICAgdGhpcy5wbGF5ZXIuY29uZmlnLnVybCA9IHVybDtcXG4gICAgaWYgKCF0aGlzLnBhdXNlZCkge1xcbiAgICAgIHRoaXMucGF1c2UoKTtcXG4gICAgICB0aGlzLm9uY2UoJ3BhdXNlJywgKCkgPT4ge1xcbiAgICAgICAgdGhpcy5zdGFydCh1cmwpO1xcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMub25jZSgnY2FucGxheScsICgpID0+IHtcXG4gICAgICAgIHRoaXMucGxheSgpO1xcbiAgICAgIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRoaXMuc3RhcnQodXJsKTtcXG4gICAgfVxcbiAgICB0aGlzLm9uY2UoJ2NhbnBsYXknLCAoKSA9PiB7XFxuICAgICAgdGhpcy5jdXJyZW50VGltZSA9IDA7XFxuICAgIH0pO1xcbiAgfVxcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IEZsdlBsYXllcjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly94Z3BsYXllci1mbHYvLi9zcmMvaW5kZXguanM/XCIpfSwwOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiBtdWx0aSAuL3NyYy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL2Z1bmN0aW9uKG1vZHVsZSxleHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pe2V2YWwoJ21vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvaW5kZXguanMgKi9cIi4vc3JjL2luZGV4LmpzXCIpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi9tdWx0aV8uL3NyYy9pbmRleC5qcz8nKX0seGdwbGF5ZXI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogZXh0ZXJuYWwgXCJ4Z3BsYXllclwiICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9mdW5jdGlvbihtb2R1bGUsZXhwb3J0cyl7ZXZhbChcIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV94Z3BsYXllcl9fO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL3hncGxheWVyLWZsdi9leHRlcm5hbF8lMjJ4Z3BsYXllciUyMj9cIil9fSl9KSk7IiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dChyZXF1aXJlKFwieGdwbGF5ZXJcIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wieGdwbGF5ZXJcIl0sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0c1tcInhncGxheWVyLWZsdlwiXT10KHJlcXVpcmUoXCJ4Z3BsYXllclwiKSk6ZVtcInhncGxheWVyLWZsdlwiXT10KGUueGdwbGF5ZXIpfSh3aW5kb3csKGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD17fTtmdW5jdGlvbiBpKHMpe2lmKHRbc10pcmV0dXJuIHRbc10uZXhwb3J0czt2YXIgcj10W3NdPXtpOnMsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtzXS5jYWxsKHIuZXhwb3J0cyxyLHIuZXhwb3J0cyxpKSxyLmw9ITAsci5leHBvcnRzfXJldHVybiBpLm09ZSxpLmM9dCxpLmQ9ZnVuY3Rpb24oZSx0LHMpe2kubyhlLHQpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOiEwLGdldDpzfSl9LGkucj1mdW5jdGlvbihlKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxpLnQ9ZnVuY3Rpb24oZSx0KXtpZigxJnQmJihlPWkoZSkpLDgmdClyZXR1cm4gZTtpZig0JnQmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHM9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihpLnIocyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pLDImdCYmXCJzdHJpbmdcIiE9dHlwZW9mIGUpZm9yKHZhciByIGluIGUpaS5kKHMscixmdW5jdGlvbih0KXtyZXR1cm4gZVt0XX0uYmluZChudWxsLHIpKTtyZXR1cm4gc30saS5uPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiBpLmQodCxcImFcIix0KSx0fSxpLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LGkucD1cIlwiLGkoaS5zPTExKX0oW2Z1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9e0NvbnRleHQ6aSgxMykuZGVmYXVsdCxFVkVOVFM6aSg0KS5kZWZhdWx0LFdPUktFUl9DT01NQU5EUzppKDE1KS5kZWZhdWx0LHNuaWZmZXI6aSgxNikuZGVmYXVsdCxpc0xlOmkoMTcpLmRlZmF1bHQsVVRGODppKDE4KS5kZWZhdWx0LE1lZGlhSW5mbzppKDMpLmRlZmF1bHQsTWVkaWFTYW1wbGU6aSgxOSkuZGVmYXVsdCxNZWRpYVNlZ21lbnQ6aSgyMCkuZGVmYXVsdCxNZWRpYVNlZ21lbnRMaXN0OmkoMjEpLmRlZmF1bHQsQXVkaW9UcmFja01ldGE6aSg1KS5BdWRpb1RyYWNrTWV0YSxWaWRlb1RyYWNrTWV0YTppKDUpLlZpZGVvVHJhY2tNZXRhLEF1ZGlvVHJhY2tTYW1wbGU6aSg2KS5BdWRpb1RyYWNrU2FtcGxlLFZpZGVvVHJhY2tTYW1wbGU6aSg2KS5WaWRlb1RyYWNrU2FtcGxlLE1zZTppKDIyKS5kZWZhdWx0LFN0cmVhbTppKDIzKS5kZWZhdWx0LEJ1ZmZlcjppKDI0KS5kZWZhdWx0LENyeXB0bzppKDI3KS5kZWZhdWx0fX0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NsYXNzIHN7Y29uc3RydWN0b3IoKXt0aGlzLmlkPS0xLHRoaXMuc2VxdWVuY2VOdW1iZXI9MCx0aGlzLnNhbXBsZXM9W10sdGhpcy5kcm9wcGVkU2FtcGxlcz1bXSx0aGlzLmxlbmd0aD0wfXJlc2V0KCl7dGhpcy5zZXF1ZW5jZU51bWJlcj0wLHRoaXMuc2FtcGxlcz1bXSx0aGlzLmxlbmd0aD0wfWRpc3Ryb3koKXt0aGlzLnJlc2V0KCksdGhpcy5pZD0tMX19dC5kZWZhdWx0PXM7dC5BdWRpb1RyYWNrPWNsYXNzIGV4dGVuZHMgc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5UQUc9XCJBdWRpb1RyYWNrXCIsdGhpcy50eXBlPVwiYXVkaW9cIn19O3QuVmlkZW9UcmFjaz1jbGFzcyBleHRlbmRzIHN7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuVEFHPVwiVmlkZW9UcmFja1wiLHRoaXMudHlwZT1cInZpZGVvXCIsdGhpcy5kcm9wcGVkPTB9cmVzZXQoKXt0aGlzLnNlcXVlbmNlTnVtYmVyPTAsdGhpcy5zYW1wbGVzPVtdLHRoaXMubGVuZ3RoPTAsdGhpcy5kcm9wcGVkPTB9fTt0LlRyYWNrcz1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuYXVkaW9UcmFjaz1udWxsLHRoaXMudmlkZW9UcmFjaz1udWxsfWRlc3Ryb3koKXt0aGlzLmF1ZGlvVHJhY2s9bnVsbCx0aGlzLnZpZGVvVHJhY2s9bnVsbH19fSxmdW5jdGlvbih0LGkpe3QuZXhwb3J0cz1lfSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3Qgcz1lPT57Zm9yKGxldCB0IGluIGUpaWYoZS5oYXNPd25Qcm9wZXJ0eSh0KSYmbnVsbD09PWVbdF0pcmV0dXJuITE7cmV0dXJuITB9O2NsYXNzIHJ7Y29uc3RydWN0b3IoKXt0aGlzLm1pbWVUeXBlPW51bGwsdGhpcy5kdXJhdGlvbj1udWxsLHRoaXMuaGFzVmlkZW89bnVsbCx0aGlzLnZpZGVvPXtjb2RlYzpudWxsLHdpZHRoOm51bGwsaGVpZ2h0Om51bGwscHJvZmlsZTpudWxsLGxldmVsOm51bGwsZnJhbWVSYXRlOntmaXhlZDohMCxmcHM6MjUsZnBzX251bToyNWUzLGZwc19kZW46MWUzfSxjaHJvbWFGb3JtYXQ6bnVsbCxwYXJSYXRpbzp7d2lkdGg6MSxoZWlnaHQ6MX19LHRoaXMuaGFzQXVkaW89bnVsbCx0aGlzLmF1ZGlvPXtjb2RlYzpudWxsLHNhbXBsZVJhdGU6bnVsbCxzYW1wbGVSYXRlSW5kZXg6bnVsbCxjaGFubmVsQ291bnQ6bnVsbH19aXNDb21wbGV0ZSgpe3JldHVybiByLmlzQmFzZUluZm9SZWFkeSh0aGlzKSYmci5pc1ZpZGVvUmVhZHkodGhpcykmJnIuaXNBdWRpb1JlYWR5KHRoaXMpfXN0YXRpYyBpc0Jhc2VJbmZvUmVhZHkoZSl7cmV0dXJuIHMoZSl9c3RhdGljIGlzVmlkZW9SZWFkeShlKXtyZXR1cm4hZS5oYXNWaWRlb3x8cyhlLnZpZGVvKX1zdGF0aWMgaXNBdWRpb1JlYWR5KGUpe3JldHVybiFlLmhhc0F1ZGlvfHxzKGUudmlkZW8pfX10LmRlZmF1bHQ9cn0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IHM9e0xBREVSX1NUQVJUOlwiTE9BREVSX1NUQVJUXCIsTE9BREVSX0RBVEFMT0FERUQ6XCJMT0FERVJfREFUQUxPQURFRFwiLExPQURFUl9DT01QTEVURTpcIkxPQURFUl9DT01QTEVURVwiLExPQURFUl9FUlJPUjpcIkxPQURFUl9FUlJPUlwifSxyPXtERU1VWF9TVEFSVDpcIkRFTVVYX1NUQVJUXCIsREVNVVhfQ09NUExFVEU6XCJERU1VWF9DT01QTEVURVwiLERFTVVYX0VSUk9SOlwiREVNVVhfRVJST1JcIixNRVRBREFUQV9QQVJTRUQ6XCJNRVRBREFUQV9QQVJTRURcIixWSURFT19NRVRBREFUQV9DSEFOR0U6XCJWSURFT19NRVRBREFUQV9DSEFOR0VcIixBVURJT19NRVRBREFUQV9DSEFOR0U6XCJBVURJT19NRVRBREFUQV9DSEFOR0VcIixNRURJQV9JTkZPOlwiTUVESUFfSU5GT1wifSxhPXtSRU1VWF9NRVRBREFUQTpcIlJFTVVYX01FVEFEQVRBXCIsUkVNVVhfTUVESUE6XCJSRU1VWF9NRURJQVwiLE1FRElBX1NFR01FTlQ6XCJNRURJQV9TRUdNRU5UXCIsUkVNVVhfRVJST1I6XCJSRU1VWF9FUlJPUlwiLElOSVRfU0VHTUVOVDpcIklOSVRfU0VHTUVOVFwiLERFVEVDVF9DSEFOR0VfU1RSRUFNOlwiREVURUNUX0NIQU5HRV9TVFJFQU1cIn0sbj17U09VUkNFX1VQREFURV9FTkQ6XCJTT1VSQ0VfVVBEQVRFX0VORFwifSxvPXtSRVRSWV9USU1FX0VYQ0VFREVEOlwiUkVUUllfVElNRV9FWENFRURFRFwifSxkPU9iamVjdC5hc3NpZ24oe30scyxyLGEsbixvKSxsPVtdLGg9W107Zm9yKGxldCBlIGluIGQpZC5oYXNPd25Qcm9wZXJ0eShlKSYmbC5wdXNoKGRbZV0pO2ZvcihsZXQgZSBpbiBkKWQuaGFzT3duUHJvcGVydHkoZSkmJmgucHVzaChkW2VdKTt0LmRlZmF1bHQ9e0FMTEVWRU5UUzpkLEhMU19FVkVOVFM6byxSRU1VWF9FVkVOVFM6YSxERU1VWF9FVkVOVFM6cixNU0VfRVZFTlRTOm4sTE9BREVSX0VWRU5UUzpzLEZsdkFsbG93ZWRFdmVudHM6bCxIbHNBbGxvd2VkRXZlbnRzOmgsQ1JZVE9fRVZFTlRTOntTVEFSVF9ERUNSWVBUOlwiU1RBUlRfREVDUllQVFwiLERFQ1JZUFRFRDpcIkRFQ1JZUFRFRFwifX19LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt0LkF1ZGlvVHJhY2tNZXRhPWNsYXNze2NvbnN0cnVjdG9yKGUpe2NvbnN0IHQ9e3NhbXBsZVJhdGU6NDhlMyxjaGFubmVsQ291bnQ6Mixjb2RlYzpcIm1wNGEuNDAuMlwiLGNvbmZpZzpbNDEsNDAxLDEzNiwwXSxkdXJhdGlvbjowLGlkOjIscmVmU2FtcGxlRHVyYXRpb246MjEsc2FtcGxlUmF0ZUluZGV4OjMsdGltZXNjYWxlOjFlMyx0eXBlOlwiYXVkaW9cIn07cmV0dXJuIGU/T2JqZWN0LmFzc2lnbih7fSx0LGUpOnR9ZGVzdHJveSgpe3RoaXMuaW5pdD1udWxsfX07dC5WaWRlb1RyYWNrTWV0YT1jbGFzc3tjb25zdHJ1Y3RvcihlKXtjb25zdCB0PXthdmNjOm51bGwsc3BzOm5ldyBVaW50OEFycmF5KDApLHBwczpuZXcgVWludDhBcnJheSgwKSxjaHJvbWFGb3JtYXQ6NDIwLGNvZGVjOlwiYXZjMS42NDAwMjBcIixjb2RlY0hlaWdodDo3MjAsY29kZWNXaWR0aDoxMjgwLGR1cmF0aW9uOjAsZnJhbWVSYXRlOntmaXhlZDohMCxmcHM6MjUsZnBzX251bToyNWUzLGZwc19kZW46MWUzfSxpZDoxLGxldmVsOlwiMy4yXCIscHJlc2VudEhlaWdodDo3MjAscHJlc2VudFdpZHRoOjEyODAscHJvZmlsZTpcIkhpZ2hcIixyZWZTYW1wbGVEdXJhdGlvbjo0MCxwYXJSYXRpbzp7aGVpZ2h0OjEsd2lkdGg6MX0sdGltZXNjYWxlOjFlMyx0eXBlOlwidmlkZW9cIn07cmV0dXJuIGU/T2JqZWN0LmFzc2lnbih7fSx0LGUpOnR9ZGVzdHJveSgpe3RoaXMuaW5pdD1udWxsLHRoaXMuc3BzPW51bGwsdGhpcy5wcHM9bnVsbH19fSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y2xhc3Mgc3tjb25zdHJ1Y3RvcihlKXtsZXQgdD1zLmdldERlZmF1bHQoKTtyZXR1cm4gZT9PYmplY3QuYXNzaWduKHt9LHQsZSk6dH1zdGF0aWMgZ2V0RGVmYXVsdCgpe3JldHVybntkdHM6bnVsbCxwdHM6bnVsbCxkYXRhOm5ldyBVaW50OEFycmF5fX19dC5BdWRpb1RyYWNrU2FtcGxlPXM7Y2xhc3Mgcntjb25zdHJ1Y3RvcihlKXtsZXQgdD1yLmdldERlZmF1bHQoKTtyZXR1cm4gZT9PYmplY3QuYXNzaWduKHt9LHQsZSk6dH1zdGF0aWMgZ2V0RGVmYXVsdCgpe3JldHVybntkdHM6bnVsbCxwdHM6bnVsbCxpc0tleWZyYW1lOiExLG9yaWdpbkR0czpudWxsLGRhdGE6bmV3IFVpbnQ4QXJyYXl9fX10LlZpZGVvVHJhY2tTYW1wbGU9cn0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz17TmFsdW5pdDppKDMwKS5kZWZhdWx0LFNwc1BhcnNlcjppKDgpLmRlZmF1bHQsQ29tcGF0aWJpbGl0eTppKDMyKS5kZWZhdWx0fX0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzLHI9aSgzMSksYT0ocz1yKSYmcy5fX2VzTW9kdWxlP3M6e2RlZmF1bHQ6c307Y2xhc3MgbntzdGF0aWMgX2Vic3AycmJzcChlKXtsZXQgdD1lLGk9dC5ieXRlTGVuZ3RoLHM9bmV3IFVpbnQ4QXJyYXkoaSkscj0wO2ZvcihsZXQgZT0wO2U8aTtlKyspZT49MiYmMz09PXRbZV0mJjA9PT10W2UtMV0mJjA9PT10W2UtMl18fChzW3JdPXRbZV0scisrKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkocy5idWZmZXIsMCxyKX1zdGF0aWMgcGFyc2VTUFMoZSl7bGV0IHQ9bi5fZWJzcDJyYnNwKGUpLGk9bmV3IGEuZGVmYXVsdCh0KTtpLnJlYWRCeXRlKCk7bGV0IHM9aS5yZWFkQnl0ZSgpO2kucmVhZEJ5dGUoKTtsZXQgcj1pLnJlYWRCeXRlKCk7aS5yZWFkVUVHKCk7bGV0IG89bi5nZXRQcm9maWxlU3RyaW5nKHMpLGQ9bi5nZXRMZXZlbFN0cmluZyhyKSxsPTEsaD00MjAsdT1bMCw0MjAsNDIyLDQ0NF0sYz04O2lmKCgxMDA9PT1zfHwxMTA9PT1zfHwxMjI9PT1zfHwyNDQ9PT1zfHw0ND09PXN8fDgzPT09c3x8ODY9PT1zfHwxMTg9PT1zfHwxMjg9PT1zfHwxMzg9PT1zfHwxNDQ9PT1zKSYmKDM9PT0obD1pLnJlYWRVRUcoKSkmJmkucmVhZEJpdHMoMSksbDw9MyYmKGg9dVtsXSksYz1pLnJlYWRVRUcoKSs4LGkucmVhZFVFRygpLGkucmVhZEJpdHMoMSksaS5yZWFkQm9vbCgpKSl7bGV0IGU9MyE9PWw/ODoxMjtmb3IobGV0IHQ9MDt0PGU7dCsrKWkucmVhZEJvb2woKSYmKHQ8Nj9uLl9za2lwU2NhbGluZ0xpc3QoaSwxNik6bi5fc2tpcFNjYWxpbmdMaXN0KGksNjQpKX1pLnJlYWRVRUcoKTtsZXQgZj1pLnJlYWRVRUcoKTtpZigwPT09ZilpLnJlYWRVRUcoKTtlbHNlIGlmKDE9PT1mKXtpLnJlYWRCaXRzKDEpLGkucmVhZFNFRygpLGkucmVhZFNFRygpO2xldCBlPWkucmVhZFVFRygpO2ZvcihsZXQgdD0wO3Q8ZTt0KyspaS5yZWFkU0VHKCl9aS5yZWFkVUVHKCksaS5yZWFkQml0cygxKTtsZXQgcD1pLnJlYWRVRUcoKSxtPWkucmVhZFVFRygpLGc9aS5yZWFkQml0cygxKTswPT09ZyYmaS5yZWFkQml0cygxKSxpLnJlYWRCaXRzKDEpO2xldCBfPTAseT0wLEU9MCxTPTA7aS5yZWFkQm9vbCgpJiYoXz1pLnJlYWRVRUcoKSx5PWkucmVhZFVFRygpLEU9aS5yZWFkVUVHKCksUz1pLnJlYWRVRUcoKSk7bGV0IEE9MSx2PTEsVD0wLGI9ITAsUj0wLEQ9MDtpZihpLnJlYWRCb29sKCkpe2lmKGkucmVhZEJvb2woKSl7bGV0IGU9aS5yZWFkQnl0ZSgpLHQ9WzEsMTIsMTAsMTYsNDAsMjQsMjAsMzIsODAsMTgsMTUsNjQsMTYwLDQsMywyXSxzPVsxLDExLDExLDExLDMzLDExLDExLDExLDMzLDExLDExLDMzLDk5LDMsMiwxXTtlPjAmJmU8MTY/KEE9dFtlLTFdLHY9c1tlLTFdKToyNTU9PT1lJiYoQT1pLnJlYWRCeXRlKCk8PDh8aS5yZWFkQnl0ZSgpLHY9aS5yZWFkQnl0ZSgpPDw4fGkucmVhZEJ5dGUoKSl9aWYoaS5yZWFkQm9vbCgpJiZpLnJlYWRCb29sKCksaS5yZWFkQm9vbCgpJiYoaS5yZWFkQml0cyg0KSxpLnJlYWRCb29sKCkmJmkucmVhZEJpdHMoMjQpKSxpLnJlYWRCb29sKCkmJihpLnJlYWRVRUcoKSxpLnJlYWRVRUcoKSksaS5yZWFkQm9vbCgpKXtsZXQgZT1pLnJlYWRCaXRzKDMyKSx0PWkucmVhZEJpdHMoMzIpO2I9aS5yZWFkQm9vbCgpLFQ9KFI9dCkvKEQ9MiplKX19bGV0IHc9MTsxPT09QSYmMT09PXZ8fCh3PUEvdik7bGV0IHg9MCxMPTA7aWYoMD09PWwpeD0xLEw9Mi1nO2Vsc2V7eD0zPT09bD8xOjIsTD0oMT09PWw/MjoxKSooMi1nKX1sZXQgTz0xNioocCsxKSxNPTE2KihtKzEpKigyLWcpO08tPShfK3kpKngsTS09KEUrUykqTDtsZXQgQj1NYXRoLmNlaWwoTyp3KTtyZXR1cm4gaS5kZXN0cm95KCksaT1udWxsLHtwcm9maWxlX3N0cmluZzpvLGxldmVsX3N0cmluZzpkLGJpdF9kZXB0aDpjLGNocm9tYV9mb3JtYXQ6aCxjaHJvbWFfZm9ybWF0X3N0cmluZzpuLmdldENocm9tYUZvcm1hdFN0cmluZyhoKSxmcmFtZV9yYXRlOntmaXhlZDpiLGZwczpULGZwc19kZW46RCxmcHNfbnVtOlJ9LHBhcl9yYXRpbzp7d2lkdGg6QSxoZWlnaHQ6dn0sY29kZWNfc2l6ZTp7d2lkdGg6TyxoZWlnaHQ6TX0scHJlc2VudF9zaXplOnt3aWR0aDpCLGhlaWdodDpNfX19c3RhdGljIF9za2lwU2NhbGluZ0xpc3QoZSx0KXtsZXQgaT04LHM9OCxyPTA7Zm9yKGxldCBhPTA7YTx0O2ErKykwIT09cyYmKHM9KGkrKHI9ZS5yZWFkU0VHKCkpKzI1NiklMjU2KSxpPTA9PT1zP2k6c31zdGF0aWMgZ2V0UHJvZmlsZVN0cmluZyhlKXtzd2l0Y2goZSl7Y2FzZSA2NjpyZXR1cm5cIkJhc2VsaW5lXCI7Y2FzZSA3NzpyZXR1cm5cIk1haW5cIjtjYXNlIDg4OnJldHVyblwiRXh0ZW5kZWRcIjtjYXNlIDEwMDpyZXR1cm5cIkhpZ2hcIjtjYXNlIDExMDpyZXR1cm5cIkhpZ2gxMFwiO2Nhc2UgMTIyOnJldHVyblwiSGlnaDQyMlwiO2Nhc2UgMjQ0OnJldHVyblwiSGlnaDQ0NFwiO2RlZmF1bHQ6cmV0dXJuXCJVbmtub3duXCJ9fXN0YXRpYyBnZXRMZXZlbFN0cmluZyhlKXtyZXR1cm4oZS8xMCkudG9GaXhlZCgxKX1zdGF0aWMgZ2V0Q2hyb21hRm9ybWF0U3RyaW5nKGUpe3N3aXRjaChlKXtjYXNlIDQyMDpyZXR1cm5cIjQ6MjowXCI7Y2FzZSA0MjI6cmV0dXJuXCI0OjI6MlwiO2Nhc2UgNDQ0OnJldHVyblwiNDo0OjRcIjtkZWZhdWx0OnJldHVyblwiVW5rbm93blwifX1zdGF0aWMgdG9WaWRlb01ldGEoZSl7bGV0IHQ9e307ZSYmZS5jb2RlY19zaXplJiYodC5jb2RlY1dpZHRoPWUuY29kZWNfc2l6ZS53aWR0aCx0LmNvZGVjSGVpZ2h0PWUuY29kZWNfc2l6ZS5oZWlnaHQsdC5wcmVzZW50V2lkdGg9ZS5wcmVzZW50X3NpemUud2lkdGgsdC5wcmVzZW50SGVpZ2h0PWUucHJlc2VudF9zaXplLmhlaWdodCksdC5wcm9maWxlPWUucHJvZmlsZV9zdHJpbmcsdC5sZXZlbD1lLmxldmVsX3N0cmluZyx0LmJpdERlcHRoPWUuYml0X2RlcHRoLHQuY2hyb21hRm9ybWF0PWUuY2hyb21hX2Zvcm1hdCx0LnBhclJhdGlvPXt3aWR0aDplLnBhcl9yYXRpby53aWR0aCxoZWlnaHQ6ZS5wYXJfcmF0aW8uaGVpZ2h0fSx0LmZyYW1lUmF0ZT1lLmZyYW1lX3JhdGU7bGV0IGk9dC5mcmFtZVJhdGUuZnBzX2RlbixzPXQuZnJhbWVSYXRlLmZwc19udW07dC5yZWZTYW1wbGVEdXJhdGlvbj1NYXRoLmZsb29yKHQudGltZXNjYWxlKihpL3MpKX19dC5kZWZhdWx0PW59LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9e1RyYWNrOmkoMSkuZGVmYXVsdCxUcmFja3M6aSgxKS5UcmFja3MsQXVkaW9UcmFjazppKDEpLkF1ZGlvVHJhY2ssVmlkZW9UcmFjazppKDEpLlZpZGVvVHJhY2ssWGdCdWZmZXI6aSgxMCkuWGdCdWZmZXIsUmVtdXhCdWZmZXI6aSgxMCkuUmVtdXhCdWZmZXIsUHJlU291cmNlOmkoMzQpLmRlZmF1bHR9fSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dC5YZ0J1ZmZlcj1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLmxlbmd0aD1lfHwwLHRoaXMuaGlzdG9yeUxlbj1lfHwwLHRoaXMuYXJyYXk9W10sdGhpcy5vZmZzZXQ9MH1wdXNoKGUpe3RoaXMuYXJyYXkucHVzaChlKSx0aGlzLmxlbmd0aCs9ZS5ieXRlTGVuZ3RoLHRoaXMuaGlzdG9yeUxlbis9ZS5ieXRlTGVuZ3RofXNoaWZ0KGUpe2lmKHRoaXMuYXJyYXkubGVuZ3RoPDEpcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO2lmKHZvaWQgMD09PWUpcmV0dXJuIHRoaXMuX3NoaWZ0QnVmZmVyKCk7aWYodGhpcy5vZmZzZXQrZT09PXRoaXMuYXJyYXlbMF0ubGVuZ3RoKXtsZXQgdD10aGlzLmFycmF5WzBdLnNsaWNlKHRoaXMub2Zmc2V0LHRoaXMub2Zmc2V0K2UpO3JldHVybiB0aGlzLm9mZnNldD0wLHRoaXMuYXJyYXkuc2hpZnQoKSx0aGlzLmxlbmd0aC09ZSx0fWlmKHRoaXMub2Zmc2V0K2U8dGhpcy5hcnJheVswXS5sZW5ndGgpe2xldCB0PXRoaXMuYXJyYXlbMF0uc2xpY2UodGhpcy5vZmZzZXQsdGhpcy5vZmZzZXQrZSk7cmV0dXJuIHRoaXMub2Zmc2V0Kz1lLHRoaXMubGVuZ3RoLT1lLHR9bGV0IHQ9bmV3IFVpbnQ4QXJyYXkoZSksaT0wO2Zvcig7dGhpcy5hcnJheS5sZW5ndGg+MCYmZT4wOyl7aWYodGhpcy5vZmZzZXQrZTx0aGlzLmFycmF5WzBdLmxlbmd0aCl7bGV0IHM9dGhpcy5hcnJheVswXS5zbGljZSh0aGlzLm9mZnNldCx0aGlzLm9mZnNldCtlKTt0LnNldChzLGkpLHRoaXMub2Zmc2V0Kz1lLHRoaXMubGVuZ3RoLT1lLGU9MDticmVha317bGV0IHM9dGhpcy5hcnJheVswXS5sZW5ndGgtdGhpcy5vZmZzZXQ7dC5zZXQodGhpcy5hcnJheVswXS5zbGljZSh0aGlzLm9mZnNldCx0aGlzLmFycmF5WzBdLmxlbmd0aCksaSksdGhpcy5hcnJheS5zaGlmdCgpLHRoaXMub2Zmc2V0PTAsaSs9cyx0aGlzLmxlbmd0aC09cyxlLT1zfX1yZXR1cm4gdH1jbGVhcigpe3RoaXMuYXJyYXk9W10sdGhpcy5sZW5ndGg9MCx0aGlzLm9mZnNldD0wfWRlc3Ryb3koKXt0aGlzLmNsZWFyKCksdGhpcy5oaXN0b3J5TGVuPTB9X3NoaWZ0QnVmZmVyKCl7cmV0dXJuIHRoaXMubGVuZ3RoLT10aGlzLmFycmF5WzBdLmxlbmd0aCx0aGlzLm9mZnNldD0wLHRoaXMuYXJyYXkuc2hpZnQoKX10b0ludChlLHQpe2xldCBpPTAscz10aGlzLm9mZnNldCtlO2Zvcig7czx0aGlzLm9mZnNldCt0K2U7KXM8dGhpcy5hcnJheVswXS5sZW5ndGg/aT0yNTYqaSt0aGlzLmFycmF5WzBdW3NdOnRoaXMuYXJyYXlbMV0mJihpPTI1NippK3RoaXMuYXJyYXlbMV1bcy10aGlzLmFycmF5WzBdLmxlbmd0aF0pLHMrKztyZXR1cm4gaX19O3QuUmVtdXhCdWZmZXI9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLnZpZGVvPVtdLHRoaXMuYXVkaW89W119ZGVzdHJveSgpe3RoaXMudmlkZW89W10sdGhpcy5hdWRpbz1bXX19fSxmdW5jdGlvbihlLHQsaSl7ZS5leHBvcnRzPWkoMTIpfSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHM9bihpKDIpKSxyPWkoMCksYT1uKGkoMjgpKTtmdW5jdGlvbiBuKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1jb25zdCBvPXIuRVZFTlRTLkZsdkFsbG93ZWRFdmVudHMsZD0oZSx0KT0+e2lmKCFlLmNvbmZpZy5pc0xpdmUmJmUuZHVyYXRpb24tZS5jdXJyZW50VGltZTwyKXtjb25zdCBpPWUuZ2V0QnVmZmVyZWRSYW5nZSgpO2UuY3VycmVudFRpbWUtaVsxXTwuMSYmKGUuZW1pdChcImVuZGVkXCIpLHQubXNlLmVuZE9mU3RyZWFtKCkpfX07Y2xhc3MgbCBleHRlbmRzIHMuZGVmYXVsdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLmNvbnRleHQ9bmV3IHIuQ29udGV4dChvKSx0aGlzLmluaXRFdmVudHMoKX1zdGFydCgpe2NvbnN0IGU9dGhpcy5jb250ZXh0LnJlZ2lzdHJ5KFwiRkxWX0NPTlRST0xMRVJcIixhLmRlZmF1bHQpKHRoaXMpO3RoaXMuZmx2PWUsdGhpcy5jb250ZXh0LmluaXQoKSxzdXBlci5zdGFydChlLm1zZS51cmwpfWluaXRFdmVudHMoKXt0aGlzLm9uKFwidGltZXVwZGF0ZVwiLHRoaXMuaGFuZGxlVGltZVVwZGF0ZS5iaW5kKHRoaXMpKSx0aGlzLm9uKFwic2Vla2luZ1wiLHRoaXMuaGFuZGxlU2Vlay5iaW5kKHRoaXMpKSx0aGlzLm9uY2UoXCJkZXN0cm95XCIsdGhpcy5fZGVzdHJveS5iaW5kKHRoaXMpKX1oYW5kbGVUaW1lVXBkYXRlKCl7dGhpcy5sb2FkRGF0YSgpLGQodGhpcyx0aGlzLmZsdil9aGFuZGxlU2Vlaygpe2NvbnN0IGU9dGhpcy5jdXJyZW50VGltZSx0PXRoaXMuZ2V0QnVmZmVyZWRSYW5nZSgpOyhlPnRbMV18fGU8dFswXSkmJnRoaXMuZmx2LnNlZWsodGhpcy5jdXJyZW50VGltZSl9X2Rlc3Ryb3koKXt0aGlzLmNvbnRleHQuZGVzdHJveSgpLHRoaXMuY29udGV4dD1udWxsLHRoaXMuZmx2PW51bGx9bG9hZERhdGEoZT10aGlzLmN1cnJlbnRUaW1lKXtjb25zdCB0PXRoaXMuZ2V0QnVmZmVyZWRSYW5nZSgpO3RbMV0tZTwodGhpcy5jb25maWcucHJlbG9hZFRpbWV8fDE1KS01JiZ0aGlzLmZsdi5sb2FkTmV4dCh0WzFdKzEpfWdldCBzcmMoKXtyZXR1cm4gdGhpcy5jdXJyZW50U3JjfXNldCBzcmMoZSl7dGhpcy5wbGF5ZXIuY29uZmlnLnVybD1lLHRoaXMucGF1c2VkP3RoaXMuc3RhcnQoZSk6KHRoaXMucGF1c2UoKSx0aGlzLm9uY2UoXCJwYXVzZVwiLCgpPT57dGhpcy5zdGFydChlKX0pLHRoaXMub25jZShcImNhbnBsYXlcIiwoKT0+e3RoaXMucGxheSgpfSkpLHRoaXMub25jZShcImNhbnBsYXlcIiwoKT0+e3RoaXMuY3VycmVudFRpbWU9MH0pfX1lLmV4cG9ydHM9bH0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzLHI9aSgzKSxhPShzPXIpJiZzLl9fZXNNb2R1bGU/czp7ZGVmYXVsdDpzfSxuPWkoMTQpO2NvbnN0IG89XCJfX1RPX19cIjt0LmRlZmF1bHQ9Y2xhc3N7Y29uc3RydWN0b3IoZT1bXSl7dGhpcy5fZW1pdHRlcj1uZXcgbi5FdmVudEVtaXR0ZXIsdGhpcy5faW5zdGFuY2VNYXA9e30sdGhpcy5fY2xzTWFwPXt9LHRoaXMuX2luaXRlZD0hMSx0aGlzLm1lZGlhSW5mbz1uZXcgYS5kZWZhdWx0LHRoaXMuYWxsb3dlZEV2ZW50cz1lLHRoaXMuX2hvb2tzPXt9fWdldEluc3RhbmNlKGUpe2NvbnN0IHQ9dGhpcy5faW5zdGFuY2VNYXBbZV07cmV0dXJuIHR8fG51bGx9aW5pdEluc3RhbmNlKGUsLi4udCl7aWYodGhpcy5fY2xzTWFwW2VdKXtjb25zdCBpPW5ldyB0aGlzLl9jbHNNYXBbZV0oLi4udCk7cmV0dXJuIHRoaXMuX2luc3RhbmNlTWFwW2VdPWksaS5pbml0JiZpLmluaXQoKSxpfXRocm93IG5ldyBFcnJvcihgJHtlfeacquWcqGNvbnRleHTkuK3ms6jlhoxgKX1pbml0KGUpe2lmKCF0aGlzLl9pbml0ZWQpe2ZvcihsZXQgdCBpbiB0aGlzLl9jbHNNYXApdGhpcy5fY2xzTWFwLmhhc093blByb3BlcnR5KHQpJiYhdGhpcy5faW5zdGFuY2VNYXBbdF0mJnRoaXMuaW5pdEluc3RhbmNlKHQsZSk7dGhpcy5faW5pdGVkPSEwfX1yZWdpc3RyeShlLHQpe2NvbnN0IGk9dGhpcy5fZW1pdHRlcixzPXRoaXMuX2lzTWVzc2FnZU5hbWVWYWxpZC5iaW5kKHRoaXMpLHI9dGhpcztyZXR1cm4gdGhpcy5fY2xzTWFwW2VdPWNsYXNzIGV4dGVuZHMgdHtjb25zdHJ1Y3RvciguLi50KXtzdXBlciguLi50KSx0aGlzLmxpc3RlbmVycz17fSx0aGlzLm9uY2VMaXN0ZW5lcnM9e30sdGhpcy5UQUc9ZSx0aGlzLl9jb250ZXh0PXJ9b24odCxyKXtyZXR1cm4gcyh0KSx0aGlzLmxpc3RlbmVyc1t0XT90aGlzLmxpc3RlbmVyc1t0XS5wdXNoKHIpOnRoaXMubGlzdGVuZXJzW3RdPVtyXSxpLm9uKGAke3R9JHtvfSR7ZX1gLHIpLGkub24odCxyKX1iZWZvcmUoZSx0KXtzKGUpLHIuX2hvb2tzW2VdP3IuX2hvb2tzW2VdLnB1c2godCk6ci5faG9va3NbZV09W3RdfW9uY2UodCxyKXtyZXR1cm4gcyh0KSx0aGlzLm9uY2VMaXN0ZW5lcnNbdF0/dGhpcy5vbmNlTGlzdGVuZXJzW3RdLnB1c2gocik6dGhpcy5vbmNlTGlzdGVuZXJzW3RdPVtyXSxpLm9uY2UoYCR7dH0ke299JHtlfWAsciksaS5vbmNlKHQscil9ZW1pdChlLC4uLnQpe3MoZSk7Y29uc3QgYT1yLl9ob29rcz9yLl9ob29rc1tlXTpudWxsO2lmKGEpZm9yKGxldCBlPTAsdD1hLmxlbmd0aDtlPHQ7ZSsrKXsoMCxhW2VdKSgpfXJldHVybiBpLmVtaXQoZSwuLi50KX1lbWl0VG8oZSx0LC4uLnIpe3JldHVybiBzKHQpLGkuZW1pdChgJHt0fSR7b30ke2V9YCwuLi5yKX1vZmYoZSx0KXtyZXR1cm4gcyhlKSxpLm9mZihlLHQpfXJlbW92ZUxpc3RlbmVycygpe2NvbnN0IHQ9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5iaW5kKHRoaXMubGlzdGVuZXJzKTtmb3IobGV0IHMgaW4gdGhpcy5saXN0ZW5lcnMpaWYodChzKSl7Y29uc3QgdD10aGlzLmxpc3RlbmVyc1tzXXx8W107Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspe2NvbnN0IGE9dFtyXTtpLm9mZihzLGEpLGkub2ZmKGAke3N9JHtvfSR7ZX1gLGEpfX1mb3IobGV0IHMgaW4gdGhpcy5vbmNlTGlzdGVuZXJzKWlmKHQocykpe2NvbnN0IHQ9dGhpcy5vbmNlTGlzdGVuZXJzW3NdfHxbXTtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyl7Y29uc3QgYT10W3JdO2kub2ZmKHMsYSksaS5vZmYoYCR7c30ke299JHtlfWAsYSl9fX1kZXN0cm95KCl7aWYodGhpcy5yZW1vdmVMaXN0ZW5lcnMoKSx0aGlzLmxpc3RlbmVycz17fSxkZWxldGUgci5faW5zdGFuY2VNYXBbZV0sc3VwZXIuZGVzdHJveSlyZXR1cm4gc3VwZXIuZGVzdHJveSgpfX0sKC4uLnQpPT50aGlzLmluaXRJbnN0YW5jZShlLC4uLnQpfWRlc3Ryb3lJbnN0YW5jZXMoKXtPYmplY3Qua2V5cyh0aGlzLl9pbnN0YW5jZU1hcCkuZm9yRWFjaChlPT57dGhpcy5faW5zdGFuY2VNYXBbZV0uZGVzdHJveSYmdGhpcy5faW5zdGFuY2VNYXBbZV0uZGVzdHJveSgpfSl9ZGVzdHJveSgpe3RoaXMuX2VtaXR0ZXI9bnVsbCx0aGlzLmFsbG93ZWRFdmVudHM9W10sdGhpcy5fY2xzTWFwPW51bGwsdGhpcy5fY29udGV4dD1udWxsLHRoaXMuX2hvb2tzPW51bGwsdGhpcy5kZXN0cm95SW5zdGFuY2VzKCl9X2lzTWVzc2FnZU5hbWVWYWxpZChlKXtpZighdGhpcy5hbGxvd2VkRXZlbnRzLmluZGV4T2YoZSk8MCl0aHJvdyBuZXcgRXJyb3IoYHVucmVnaXN0ZXJlZCBtZXNzYWdlIG5hbWU6ICR7ZX1gKX19fSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHMscj1cIm9iamVjdFwiPT10eXBlb2YgUmVmbGVjdD9SZWZsZWN0Om51bGwsYT1yJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiByLmFwcGx5P3IuYXBwbHk6ZnVuY3Rpb24oZSx0LGkpe3JldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChlLHQsaSl9O3M9ciYmXCJmdW5jdGlvblwiPT10eXBlb2Ygci5vd25LZXlzP3Iub3duS2V5czpPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzP2Z1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlKS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKSl9OmZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlKX07dmFyIG49TnVtYmVyLmlzTmFOfHxmdW5jdGlvbihlKXtyZXR1cm4gZSE9ZX07ZnVuY3Rpb24gbygpe28uaW5pdC5jYWxsKHRoaXMpfWUuZXhwb3J0cz1vLG8uRXZlbnRFbWl0dGVyPW8sby5wcm90b3R5cGUuX2V2ZW50cz12b2lkIDAsby5wcm90b3R5cGUuX2V2ZW50c0NvdW50PTAsby5wcm90b3R5cGUuX21heExpc3RlbmVycz12b2lkIDA7dmFyIGQ9MTA7ZnVuY3Rpb24gbChlKXtyZXR1cm4gdm9pZCAwPT09ZS5fbWF4TGlzdGVuZXJzP28uZGVmYXVsdE1heExpc3RlbmVyczplLl9tYXhMaXN0ZW5lcnN9ZnVuY3Rpb24gaChlLHQsaSxzKXt2YXIgcixhLG4sbztpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcrdHlwZW9mIGkpO2lmKHZvaWQgMD09PShhPWUuX2V2ZW50cyk/KGE9ZS5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCksZS5fZXZlbnRzQ291bnQ9MCk6KHZvaWQgMCE9PWEubmV3TGlzdGVuZXImJihlLmVtaXQoXCJuZXdMaXN0ZW5lclwiLHQsaS5saXN0ZW5lcj9pLmxpc3RlbmVyOmkpLGE9ZS5fZXZlbnRzKSxuPWFbdF0pLHZvaWQgMD09PW4pbj1hW3RdPWksKytlLl9ldmVudHNDb3VudDtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG4/bj1hW3RdPXM/W2ksbl06W24saV06cz9uLnVuc2hpZnQoaSk6bi5wdXNoKGkpLChyPWwoZSkpPjAmJm4ubGVuZ3RoPnImJiFuLndhcm5lZCl7bi53YXJuZWQ9ITA7dmFyIGQ9bmV3IEVycm9yKFwiUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiBcIituLmxlbmd0aCtcIiBcIitTdHJpbmcodCkrXCIgbGlzdGVuZXJzIGFkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdFwiKTtkLm5hbWU9XCJNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmdcIixkLmVtaXR0ZXI9ZSxkLnR5cGU9dCxkLmNvdW50PW4ubGVuZ3RoLG89ZCxjb25zb2xlJiZjb25zb2xlLndhcm4mJmNvbnNvbGUud2FybihvKX1yZXR1cm4gZX1mdW5jdGlvbiB1KCl7Zm9yKHZhciBlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWUucHVzaChhcmd1bWVudHNbdF0pO3RoaXMuZmlyZWR8fCh0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsdGhpcy53cmFwRm4pLHRoaXMuZmlyZWQ9ITAsYSh0aGlzLmxpc3RlbmVyLHRoaXMudGFyZ2V0LGUpKX1mdW5jdGlvbiBjKGUsdCxpKXt2YXIgcz17ZmlyZWQ6ITEsd3JhcEZuOnZvaWQgMCx0YXJnZXQ6ZSx0eXBlOnQsbGlzdGVuZXI6aX0scj11LmJpbmQocyk7cmV0dXJuIHIubGlzdGVuZXI9aSxzLndyYXBGbj1yLHJ9ZnVuY3Rpb24gZihlLHQsaSl7dmFyIHM9ZS5fZXZlbnRzO2lmKHZvaWQgMD09PXMpcmV0dXJuW107dmFyIHI9c1t0XTtyZXR1cm4gdm9pZCAwPT09cj9bXTpcImZ1bmN0aW9uXCI9PXR5cGVvZiByP2k/W3IubGlzdGVuZXJ8fHJdOltyXTppP2Z1bmN0aW9uKGUpe2Zvcih2YXIgdD1uZXcgQXJyYXkoZS5sZW5ndGgpLGk9MDtpPHQubGVuZ3RoOysraSl0W2ldPWVbaV0ubGlzdGVuZXJ8fGVbaV07cmV0dXJuIHR9KHIpOm0ocixyLmxlbmd0aCl9ZnVuY3Rpb24gcChlKXt2YXIgdD10aGlzLl9ldmVudHM7aWYodm9pZCAwIT09dCl7dmFyIGk9dFtlXTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBpKXJldHVybiAxO2lmKHZvaWQgMCE9PWkpcmV0dXJuIGkubGVuZ3RofXJldHVybiAwfWZ1bmN0aW9uIG0oZSx0KXtmb3IodmFyIGk9bmV3IEFycmF5KHQpLHM9MDtzPHQ7KytzKWlbc109ZVtzXTtyZXR1cm4gaX1PYmplY3QuZGVmaW5lUHJvcGVydHkobyxcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZH0sc2V0OmZ1bmN0aW9uKGUpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBlfHxlPDB8fG4oZSkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnK2UrXCIuXCIpO2Q9ZX19KSxvLmluaXQ9ZnVuY3Rpb24oKXt2b2lkIDAhPT10aGlzLl9ldmVudHMmJnRoaXMuX2V2ZW50cyE9PU9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzfHwodGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5fZXZlbnRzQ291bnQ9MCksdGhpcy5fbWF4TGlzdGVuZXJzPXRoaXMuX21heExpc3RlbmVyc3x8dm9pZCAwfSxvLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnM9ZnVuY3Rpb24oZSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGV8fGU8MHx8bihlKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcrZStcIi5cIik7cmV0dXJuIHRoaXMuX21heExpc3RlbmVycz1lLHRoaXN9LG8ucHJvdG90eXBlLmdldE1heExpc3RlbmVycz1mdW5jdGlvbigpe3JldHVybiBsKHRoaXMpfSxvLnByb3RvdHlwZS5lbWl0PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxpPTE7aTxhcmd1bWVudHMubGVuZ3RoO2krKyl0LnB1c2goYXJndW1lbnRzW2ldKTt2YXIgcz1cImVycm9yXCI9PT1lLHI9dGhpcy5fZXZlbnRzO2lmKHZvaWQgMCE9PXIpcz1zJiZ2b2lkIDA9PT1yLmVycm9yO2Vsc2UgaWYoIXMpcmV0dXJuITE7aWYocyl7dmFyIG47aWYodC5sZW5ndGg+MCYmKG49dFswXSksbiBpbnN0YW5jZW9mIEVycm9yKXRocm93IG47dmFyIG89bmV3IEVycm9yKFwiVW5oYW5kbGVkIGVycm9yLlwiKyhuP1wiIChcIituLm1lc3NhZ2UrXCIpXCI6XCJcIikpO3Rocm93IG8uY29udGV4dD1uLG99dmFyIGQ9cltlXTtpZih2b2lkIDA9PT1kKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGQpYShkLHRoaXMsdCk7ZWxzZXt2YXIgbD1kLmxlbmd0aCxoPW0oZCxsKTtmb3IoaT0wO2k8bDsrK2kpYShoW2ldLHRoaXMsdCl9cmV0dXJuITB9LG8ucHJvdG90eXBlLmFkZExpc3RlbmVyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGgodGhpcyxlLHQsITEpfSxvLnByb3RvdHlwZS5vbj1vLnByb3RvdHlwZS5hZGRMaXN0ZW5lcixvLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gaCh0aGlzLGUsdCwhMCl9LG8ucHJvdG90eXBlLm9uY2U9ZnVuY3Rpb24oZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcrdHlwZW9mIHQpO3JldHVybiB0aGlzLm9uKGUsYyh0aGlzLGUsdCkpLHRoaXN9LG8ucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXI9ZnVuY3Rpb24oZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcrdHlwZW9mIHQpO3JldHVybiB0aGlzLnByZXBlbmRMaXN0ZW5lcihlLGModGhpcyxlLHQpKSx0aGlzfSxvLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcj1mdW5jdGlvbihlLHQpe3ZhciBpLHMscixhLG47aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnK3R5cGVvZiB0KTtpZih2b2lkIDA9PT0ocz10aGlzLl9ldmVudHMpKXJldHVybiB0aGlzO2lmKHZvaWQgMD09PShpPXNbZV0pKXJldHVybiB0aGlzO2lmKGk9PT10fHxpLmxpc3RlbmVyPT09dCkwPT0tLXRoaXMuX2V2ZW50c0NvdW50P3RoaXMuX2V2ZW50cz1PYmplY3QuY3JlYXRlKG51bGwpOihkZWxldGUgc1tlXSxzLnJlbW92ZUxpc3RlbmVyJiZ0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lclwiLGUsaS5saXN0ZW5lcnx8dCkpO2Vsc2UgaWYoXCJmdW5jdGlvblwiIT10eXBlb2YgaSl7Zm9yKHI9LTEsYT1pLmxlbmd0aC0xO2E+PTA7YS0tKWlmKGlbYV09PT10fHxpW2FdLmxpc3RlbmVyPT09dCl7bj1pW2FdLmxpc3RlbmVyLHI9YTticmVha31pZihyPDApcmV0dXJuIHRoaXM7MD09PXI/aS5zaGlmdCgpOmZ1bmN0aW9uKGUsdCl7Zm9yKDt0KzE8ZS5sZW5ndGg7dCsrKWVbdF09ZVt0KzFdO2UucG9wKCl9KGksciksMT09PWkubGVuZ3RoJiYoc1tlXT1pWzBdKSx2b2lkIDAhPT1zLnJlbW92ZUxpc3RlbmVyJiZ0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lclwiLGUsbnx8dCl9cmV0dXJuIHRoaXN9LG8ucHJvdG90eXBlLm9mZj1vLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcixvLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnM9ZnVuY3Rpb24oZSl7dmFyIHQsaSxzO2lmKHZvaWQgMD09PShpPXRoaXMuX2V2ZW50cykpcmV0dXJuIHRoaXM7aWYodm9pZCAwPT09aS5yZW1vdmVMaXN0ZW5lcilyZXR1cm4gMD09PWFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX2V2ZW50cz1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuX2V2ZW50c0NvdW50PTApOnZvaWQgMCE9PWlbZV0mJigwPT0tLXRoaXMuX2V2ZW50c0NvdW50P3RoaXMuX2V2ZW50cz1PYmplY3QuY3JlYXRlKG51bGwpOmRlbGV0ZSBpW2VdKSx0aGlzO2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcixhPU9iamVjdC5rZXlzKGkpO2ZvcihzPTA7czxhLmxlbmd0aDsrK3MpXCJyZW1vdmVMaXN0ZW5lclwiIT09KHI9YVtzXSkmJnRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKHIpO3JldHVybiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhcInJlbW92ZUxpc3RlbmVyXCIpLHRoaXMuX2V2ZW50cz1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuX2V2ZW50c0NvdW50PTAsdGhpc31pZihcImZ1bmN0aW9uXCI9PXR5cGVvZih0PWlbZV0pKXRoaXMucmVtb3ZlTGlzdGVuZXIoZSx0KTtlbHNlIGlmKHZvaWQgMCE9PXQpZm9yKHM9dC5sZW5ndGgtMTtzPj0wO3MtLSl0aGlzLnJlbW92ZUxpc3RlbmVyKGUsdFtzXSk7cmV0dXJuIHRoaXN9LG8ucHJvdG90eXBlLmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm4gZih0aGlzLGUsITApfSxvLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuIGYodGhpcyxlLCExKX0sby5saXN0ZW5lckNvdW50PWZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZS5saXN0ZW5lckNvdW50P2UubGlzdGVuZXJDb3VudCh0KTpwLmNhbGwoZSx0KX0sby5wcm90b3R5cGUubGlzdGVuZXJDb3VudD1wLG8ucHJvdG90eXBlLmV2ZW50TmFtZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQ+MD9zKHRoaXMuX2V2ZW50cyk6W119fSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dC5DT05URVhUX0NPTU9NQU5EUz17T046XCJvblwiLE9OQ0U6XCJvbmNlXCIsT0ZGOlwib2ZmXCIsRU1JVDpcImVtaXRcIixERVNUUk9ZOlwiZGVzdHJveVwifX0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IHM9ZnVuY3Rpb24oKXtjb25zdCBlPW5ldyBBcnJheUJ1ZmZlcigyKTtyZXR1cm4gbmV3IERhdGFWaWV3KGUpLnNldEludDE2KDAsMjU2LCEwKSwyNTY9PT1uZXcgSW50MTZBcnJheShlKVswXX0oKSxyPXtnZXQgZGV2aWNlKCl7bGV0IGU9ci5vcztyZXR1cm4gZS5pc1BjP1wicGNcIjplLmlzVGFibGV0P1widGFibGV0XCI6XCJtb2JpbGVcIn0sZ2V0IGJyb3dzZXIoKXtsZXQgZT1uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksdD17aWU6L3J2OihbXFxkLl0rKVxcKSBsaWtlIGdlY2tvLyxmaXJmb3g6L2ZpcmVmb3hcXC8oW1xcZC5dKykvLGNocm9tZTovY2hyb21lXFwvKFtcXGQuXSspLyxvcGVyYTovb3BlcmEuKFtcXGQuXSspLyxzYWZhcmk6L3ZlcnNpb25cXC8oW1xcZC5dKykuKnNhZmFyaS99O3JldHVybltdLmNvbmNhdChPYmplY3Qua2V5cyh0KS5maWx0ZXIoaT0+dFtpXS50ZXN0KGUpKSlbMF19LGdldCBvcygpe2xldCBlPW5hdmlnYXRvci51c2VyQWdlbnQsdD0vKD86V2luZG93cyBQaG9uZSkvLnRlc3QoZSksaT0vKD86U3ltYmlhbk9TKS8udGVzdChlKXx8dCxzPS8oPzpBbmRyb2lkKS8udGVzdChlKSxyPS8oPzpGaXJlZm94KS8udGVzdChlKSxhPS8oPzppUGFkfFBsYXlCb29rKS8udGVzdChlKXx8cyYmIS8oPzpNb2JpbGUpLy50ZXN0KGUpfHxyJiYvKD86VGFibGV0KS8udGVzdChlKSxuPS8oPzppUGhvbmUpLy50ZXN0KGUpJiYhYTtyZXR1cm57aXNUYWJsZXQ6YSxpc1Bob25lOm4saXNBbmRyb2lkOnMsaXNQYzohbiYmIXMmJiFpLGlzU3ltYmlhbjppLGlzV2luZG93c1Bob25lOnQsaXNGaXJlRm94OnJ9fSxnZXQgaXNMZSgpe3JldHVybiBzfX07dC5kZWZhdWx0PXJ9LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBzPWZ1bmN0aW9uKCl7Y29uc3QgZT1uZXcgQXJyYXlCdWZmZXIoMik7cmV0dXJuIG5ldyBEYXRhVmlldyhlKS5zZXRJbnQxNigwLDI1NiwhMCksMjU2PT09bmV3IEludDE2QXJyYXkoZSlbMF19KCk7dC5kZWZhdWx0PXN9LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjbGFzcyBze3N0YXRpYyBkZWNvZGUoZSl7Y29uc3QgdD1bXSxpPWU7bGV0IHI9MDtjb25zdCBhPWUubGVuZ3RoO2Zvcig7cjxhOylpZihpW3JdPDEyOCl0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpW3JdKSksKytyO2Vsc2V7aWYoaVtyXTwxOTIpO2Vsc2UgaWYoaVtyXTwyMjQpe2lmKHMuX2NoZWNrQ29udGludWF0aW9uKGksciwxKSl7Y29uc3QgZT0oMzEmaVtyXSk8PDZ8NjMmaVtyKzFdO2lmKGU+PTEyOCl7dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoNjU1MzUmZSkpLHIrPTI7Y29udGludWV9fX1lbHNlIGlmKGlbcl08MjQwKXtpZihzLl9jaGVja0NvbnRpbnVhdGlvbihpLHIsMikpe2NvbnN0IGU9KDE1Jmlbcl0pPDwxMnwoNjMmaVtyKzFdKTw8Nnw2MyZpW3IrMl07aWYoZT49MjA0OCYmNTUyOTYhPSg2MzQ4OCZlKSl7dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoNjU1MzUmZSkpLHIrPTM7Y29udGludWV9fX1lbHNlIGlmKGlbcl08MjQ4JiZzLl9jaGVja0NvbnRpbnVhdGlvbihpLHIsMykpe2xldCBlPSg3Jmlbcl0pPDwxOHwoNjMmaVtyKzFdKTw8MTJ8KDYzJmlbcisyXSk8PDZ8NjMmaVtyKzNdO2lmKGU+NjU1MzYmJmU8MTExNDExMil7ZS09NjU1MzYsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoZT4+PjEwfDU1Mjk2KSksdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMTAyMyZlfDU2MzIwKSkscis9NDtjb250aW51ZX19dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoNjU1MzMpKSwrK3J9cmV0dXJuIHQuam9pbihcIlwiKX1zdGF0aWMgX2NoZWNrQ29udGludWF0aW9uKGUsdCxpKXtsZXQgcz1lO2lmKHQraTxzLmxlbmd0aCl7Zm9yKDtpLS07KWlmKDEyOCE9KDE5MiZzWysrdF0pKXJldHVybiExO3JldHVybiEwfXJldHVybiExfX10LmRlZmF1bHQ9c30sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NsYXNzIHN7Y29uc3RydWN0b3IoZSl7bGV0IHQ9cy5nZXREZWZhdWx0SW5mKCk7aWYoIWV8fFwiW29iamVjdCBPYmplY3RdXCIhPT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkpcmV0dXJuIHQ7bGV0IGk9T2JqZWN0LmFzc2lnbih7fSx0LGUpO09iamVjdC5lbnRyaWVzKGkpLmZvckVhY2goKFtlLHRdKT0+e3RoaXNbZV09dH0pfXN0YXRpYyBnZXREZWZhdWx0SW5mKCl7cmV0dXJue2R0czpudWxsLHB0czpudWxsLGR1cmF0aW9uOm51bGwscG9zaXRpb246bnVsbCxpc1JBUDohMSxvcmlnaW5EdHM6bnVsbH19fXQuZGVmYXVsdD1zfSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dC5kZWZhdWx0PWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5zdGFydER0cz0tMSx0aGlzLmVuZER0cz0tMSx0aGlzLnN0YXJ0UHRzPS0xLHRoaXMuZW5kUHRzPS0xLHRoaXMub3JpZ2luU3RhcnREdHM9LTEsdGhpcy5vcmlnaW5FbmREdHM9LTEsdGhpcy5yYW5kb21BY2Nlc3NQb2ludHM9W10sdGhpcy5maXJzdFNhbXBsZT1udWxsLHRoaXMubGFzdFNhbXBsZT1udWxsfWFkZFJBUChlKXtlLmlzUkFQPSEwLHRoaXMucmFuZG9tQWNjZXNzUG9pbnRzLnB1c2goZSl9fX0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3QuZGVmYXVsdD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl90eXBlPWUsdGhpcy5fbGlzdD1bXSx0aGlzLl9sYXN0QXBwZW5kTG9jYXRpb249LTF9Z2V0IHR5cGUoKXtyZXR1cm4gdGhpcy5fdHlwZX1nZXQgbGVuZ3RoKCl7cmV0dXJuIHRoaXMuX2xpc3QubGVuZ3RofWlzRW1wdHkoKXtyZXR1cm4gMD09PXRoaXMuX2xpc3QubGVuZ3RofWNsZWFyKCl7dGhpcy5fbGlzdD1bXSx0aGlzLl9sYXN0QXBwZW5kTG9jYXRpb249LTF9X3NlYXJjaE5lYXJlc3RTZWdtZW50QmVmb3JlKGUpe2xldCB0PXRoaXMuX2xpc3Q7aWYoMD09PXQubGVuZ3RoKXJldHVybi0yO2xldCBpPXQubGVuZ3RoLTEscz0wLHI9MCxhPWksbj0wO2lmKGU8dFswXS5vcmlnaW5EdHMpcmV0dXJuIG49LTE7Zm9yKDtyPD1hOyl7aWYoKHM9citNYXRoLmZsb29yKChhLXIpLzIpKT09PWl8fGU+dFtzXS5sYXN0U2FtcGxlLm9yaWdpbkR0cyYmZTx0W3MrMV0ub3JpZ2luRHRzKXtuPXM7YnJlYWt9dFtzXS5vcmlnaW5EdHM8ZT9yPXMrMTphPXMtMX1yZXR1cm4gbn1fc2VhcmNoTmVhcmVzdFNlZ21lbnRBZnRlcihlKXtyZXR1cm4gdGhpcy5fc2VhcmNoTmVhcmVzdFNlZ21lbnRCZWZvcmUoZSkrMX1hcHBlbmQoZSl7bGV0IHQ9dGhpcy5fbGlzdCxpPXRoaXMuX2xhc3RBcHBlbmRMb2NhdGlvbixzPTA7LTEhPT1pJiZpPHQubGVuZ3RoJiZlLm9yaWdpblN0YXJ0RHRzPj10W2ldLmxhc3RTYW1wbGUub3JpZ2luRHRzJiYoaT09PXQubGVuZ3RoLTF8fGk8dC5sZW5ndGgtMSYmZS5vcmlnaW5TdGFydER0czx0W2krMV0ub3JpZ2luU3RhcnREdHMpP3M9aSsxOnQubGVuZ3RoPjAmJihzPXRoaXMuX3NlYXJjaE5lYXJlc3RTZWdtZW50QmVmb3JlKGUub3JpZ2luU3RhcnREdHMpKzEpLHRoaXMuX2xhc3RBcHBlbmRMb2NhdGlvbj1zLHRoaXMuX2xpc3Quc3BsaWNlKHMsMCxlKX1nZXRMYXN0U2VnbWVudEJlZm9yZShlKXtsZXQgdD10aGlzLl9zZWFyY2hOZWFyZXN0U2VnbWVudEJlZm9yZShlKTtyZXR1cm4gdD49MD90aGlzLl9saXN0W3RdOm51bGx9Z2V0TGFzdFNhbXBsZUJlZm9yZShlKXtsZXQgdD10aGlzLmdldExhc3RTZWdtZW50QmVmb3JlKGUpO3JldHVybiBudWxsIT09dD90Lmxhc3RTYW1wbGU6bnVsbH1nZXRMYXN0UkFQQmVmb3JlKGUpe2xldCB0PXRoaXMuX3NlYXJjaE5lYXJlc3RTZWdtZW50QmVmb3JlKGUpLGk9dGhpcy5fbGlzdFt0XS5yYW5kb21BY2Nlc3NQb2ludHM7Zm9yKDswPT09aS5sZW5ndGgmJnQ+MDspdC0tLGk9dGhpcy5fbGlzdFt0XS5yYW5kb21BY2Nlc3NQb2ludHM7cmV0dXJuIGkubGVuZ3RoPjA/aVtpLmxlbmd0aC0xXTpudWxsfX19LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjbGFzcyBze2NvbnN0cnVjdG9yKGUpe3RoaXMuY29uZmlncz1PYmplY3QuYXNzaWduKHt9LGUpLHRoaXMuY29udGFpbmVyPXRoaXMuY29uZmlncy5jb250YWluZXIsdGhpcy5tZWRpYVNvdXJjZT1udWxsLHRoaXMuc291cmNlQnVmZmVycz17fSx0aGlzLnByZWxvYWRUaW1lPXRoaXMuY29uZmlncy5wcmVsb2FkVGltZXx8MSx0aGlzLm9uU291cmNlT3Blbj10aGlzLm9uU291cmNlT3Blbi5iaW5kKHRoaXMpLHRoaXMub25UaW1lVXBkYXRlPXRoaXMub25UaW1lVXBkYXRlLmJpbmQodGhpcyksdGhpcy5vblVwZGF0ZUVuZD10aGlzLm9uVXBkYXRlRW5kLmJpbmQodGhpcyksdGhpcy5vbldhaXRpbmc9dGhpcy5vbldhaXRpbmcuYmluZCh0aGlzKX1pbml0KCl7dGhpcy5tZWRpYVNvdXJjZT1uZXcgc2VsZi5NZWRpYVNvdXJjZSx0aGlzLm1lZGlhU291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJzb3VyY2VvcGVuXCIsdGhpcy5vblNvdXJjZU9wZW4pLHRoaXMuY29udGFpbmVyLnNyYz1VUkwuY3JlYXRlT2JqZWN0VVJMKHRoaXMubWVkaWFTb3VyY2UpLHRoaXMudXJsPXRoaXMuY29udGFpbmVyLnNyYyx0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwidGltZXVwZGF0ZVwiLHRoaXMub25UaW1lVXBkYXRlKSx0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwid2FpdGluZ1wiLHRoaXMub25XYWl0aW5nKX1vblRpbWVVcGRhdGUoKXt0aGlzLmVtaXQoXCJUSU1FX1VQREFURVwiLHRoaXMuY29udGFpbmVyKX1vbldhaXRpbmcoKXt0aGlzLmVtaXQoXCJXQUlUSU5HXCIsdGhpcy5jb250YWluZXIpfW9uU291cmNlT3Blbigpe3RoaXMuYWRkU291cmNlQnVmZmVycygpfW9uVXBkYXRlRW5kKCl7dGhpcy5lbWl0KFwiU09VUkNFX1VQREFURV9FTkRcIiksdGhpcy5kb0FwcGVuZCgpfWFkZFNvdXJjZUJ1ZmZlcnMoKXtpZihcIm9wZW5cIiE9PXRoaXMubWVkaWFTb3VyY2UucmVhZHlTdGF0ZSlyZXR1cm47bGV0IGUsdD10aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKFwiUFJFX1NPVVJDRV9CVUZGRVJcIiksaT10aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKFwiVFJBQ0tTXCIpO3Q9dC5zb3VyY2VzO2xldCBzPSExO2ZvcihsZXQgcj0wLGE9T2JqZWN0LmtleXModCkubGVuZ3RoO3I8YTtyKyspe2xldCBhPU9iamVjdC5rZXlzKHQpW3JdO2lmKFwiYXVkaW9cIj09PWE/ZT1pLmF1ZGlvVHJhY2s6XCJ2aWRlb1wiPT09YSYmKGU9aS52aWRlb1RyYWNrKSxlKXtsZXQgaT1cImF1ZGlvXCI9PT1hPzIxOjQwO2UubWV0YSYmZS5tZXRhLnJlZlNhbXBsZUR1cmF0aW9uJiYoaT1lLm1ldGEucmVmU2FtcGxlRHVyYXRpb24pLHRbYV0uZGF0YS5sZW5ndGg+PXRoaXMucHJlbG9hZFRpbWUvaSYmKHM9ITApfX1pZihzKXtpZihPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcnMpLmxlbmd0aD4wKXJldHVybjtmb3IobGV0IGU9MCxpPU9iamVjdC5rZXlzKHQpLmxlbmd0aDtlPGk7ZSsrKXtsZXQgaT1PYmplY3Qua2V5cyh0KVtlXSxzPXRbaV0scj1cInZpZGVvXCI9PT1pP1widmlkZW8vbXA0O2NvZGVjcz1cIitzLm1pbWV0eXBlOlwiYXVkaW8vbXA0O2NvZGVjcz1cIitzLm1pbWV0eXBlLGE9dGhpcy5tZWRpYVNvdXJjZS5hZGRTb3VyY2VCdWZmZXIocik7dGhpcy5zb3VyY2VCdWZmZXJzW2ldPWEsYS5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZW5kXCIsdGhpcy5vblVwZGF0ZUVuZCksdGhpcy5kb0FwcGVuZCgpfX19ZG9BcHBlbmQoKXtsZXQgZT10aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKFwiUFJFX1NPVVJDRV9CVUZGRVJcIik7aWYoZSlmb3IobGV0IHQ9MDt0PE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVycykubGVuZ3RoO3QrKyl7bGV0IGk9T2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXJzKVt0XSxzPXRoaXMuc291cmNlQnVmZmVyc1tpXTtpZighcy51cGRhdGluZyl7bGV0IHQ9ZS5zb3VyY2VzW2ldO2lmKHQmJiF0LmluaXRlZClzLmFwcGVuZEJ1ZmZlcih0LmluaXQuYnVmZmVyLmJ1ZmZlciksdC5pbml0ZWQ9ITA7ZWxzZSBpZih0KXtsZXQgZT10LmRhdGEuc2hpZnQoKTtlJiZzLmFwcGVuZEJ1ZmZlcihlLmJ1ZmZlci5idWZmZXIpfX19fWVuZE9mU3RyZWFtKCl7Y29uc3R7cmVhZHlTdGF0ZTplLGFjdGl2ZVNvdXJjZUJ1ZmZlcnM6dH09dGhpcy5tZWRpYVNvdXJjZTtpZihcIm9wZW5cIj09PWUmJjA9PT10Lmxlbmd0aCl0cnl7dGhpcy5tZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpfWNhdGNoKGUpe319cmVtb3ZlKGUsdD0wKXtmb3IobGV0IGk9MDtpPE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVycykubGVuZ3RoO2krKyl7bGV0IHM9dGhpcy5zb3VyY2VCdWZmZXJzW09iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVycylbaV1dO3MudXBkYXRpbmd8fHMucmVtb3ZlKHQsZSl9fXJlbW92ZUJ1ZmZlcnMoKXtjb25zdCBlPVtdO2ZvcihsZXQgdD0wO3Q8T2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXJzKS5sZW5ndGg7dCsrKXtsZXQgaSxyPXRoaXMuc291cmNlQnVmZmVyc1tPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcnMpW3RdXTtyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVlbmRcIix0aGlzLm9uVXBkYXRlRW5kKSxyLnVwZGF0aW5nP2k9bmV3IFByb21pc2UoZT0+e2NvbnN0IHQ9ZnVuY3Rpb24oKXtsZXQgaT0zO2NvbnN0IGE9KCk9PntyLnVwZGF0aW5nP2k+MD8oc2V0VGltZW91dChhLDIwMCksaS0tKTplKCk6KHMuY2xlYXJCdWZmZXIociksZSgpKX07c2V0VGltZW91dChhLDIwMCksci5yZW1vdmVFdmVudExpc3RlbmVyKFwidXBkYXRlZW5kXCIsdCl9O3IuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWVuZFwiLHQpfSk6KHMuY2xlYXJCdWZmZXIociksaT1Qcm9taXNlLnJlc29sdmUoKSksZS5wdXNoKGkpfXJldHVybiBQcm9taXNlLmFsbChlKX1kZXN0cm95KCl7cmV0dXJuIHRoaXMucmVtb3ZlQnVmZmVycygpLnRoZW4oKCk9Pntmb3IobGV0IGU9MDtlPE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVycykubGVuZ3RoO2UrKyl7bGV0IHQ9dGhpcy5zb3VyY2VCdWZmZXJzW09iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVycylbZV1dO3RoaXMubWVkaWFTb3VyY2UucmVtb3ZlU291cmNlQnVmZmVyKHQpLGRlbGV0ZSB0aGlzLnNvdXJjZUJ1ZmZlcnNbT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXJzKVtlXV19dGhpcy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRpbWV1cGRhdGVcIix0aGlzLm9uVGltZVVwZGF0ZSksdGhpcy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndhaXRpbmdcIix0aGlzLm9uV2FpdGluZyksdGhpcy5tZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwic291cmNlb3BlblwiLHRoaXMub25Tb3VyY2VPcGVuKSx0aGlzLmVuZE9mU3RyZWFtKCksd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodGhpcy51cmwpLHRoaXMudXJsPW51bGwsdGhpcy5jb25maWdzPXt9LHRoaXMuY29udGFpbmVyPW51bGwsdGhpcy5tZWRpYVNvdXJjZT1udWxsLHRoaXMuc291cmNlQnVmZmVycz17fSx0aGlzLnByZWxvYWRUaW1lPTF9KX1zdGF0aWMgY2xlYXJCdWZmZXIoZSl7Y29uc3QgdD1lLmJ1ZmZlcmVkO2xldCBpPS4xO2ZvcihsZXQgZT0wLHM9dC5sZW5ndGg7ZTxzO2UrKylpPXQuZW5kKGUpO3RyeXtlLnJlbW92ZSgwLGkpfWNhdGNoKGUpe319fXQuZGVmYXVsdD1zfSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y2xhc3Mgc3tjb25zdHJ1Y3RvcihlKXtpZighKGUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpdGhyb3cgbmV3IEVycm9yKFwiZGF0YSBpcyBpbnZhbGlkXCIpO3RoaXMuYnVmZmVyPWUsdGhpcy5kYXRhdmlldz1uZXcgRGF0YVZpZXcoZSksdGhpcy5kYXRhdmlldy5wb3NpdGlvbj0wfWdldCBsZW5ndGgoKXtyZXR1cm4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aH1zZXQgcG9zaXRpb24oZSl7dGhpcy5kYXRhdmlldy5wb3NpdGlvbj1lfWdldCBwb3NpdGlvbigpe3JldHVybiB0aGlzLmRhdGF2aWV3LnBvc2l0aW9ufWJhY2soZSl7dGhpcy5wb3NpdGlvbi09ZX1za2lwKGUpe2xldCB0PU1hdGguZmxvb3IoZS80KSxpPWUlNDtmb3IobGV0IGU9MDtlPHQ7ZSsrKXMucmVhZEJ5dGUodGhpcy5kYXRhdmlldyw0KTtpPjAmJnMucmVhZEJ5dGUodGhpcy5kYXRhdmlldyxpKX1zdGF0aWMgcmVhZEJ5dGUoZSx0LGkpe2xldCBzO3N3aXRjaCh0KXtjYXNlIDE6cz1pP2UuZ2V0SW50OChlLnBvc2l0aW9uKTplLmdldFVpbnQ4KGUucG9zaXRpb24pO2JyZWFrO2Nhc2UgMjpzPWk/ZS5nZXRJbnQxNihlLnBvc2l0aW9uKTplLmdldFVpbnQxNihlLnBvc2l0aW9uKTticmVhaztjYXNlIDM6aWYoaSl0aHJvdyBuZXcgRXJyb3IoXCJub3Qgc3VwcG9ydGVkIGZvciByZWFkQnl0ZSAzXCIpO3M9ZS5nZXRVaW50OChlLnBvc2l0aW9uKTw8MTYsc3w9ZS5nZXRVaW50OChlLnBvc2l0aW9uKzEpPDw4LHN8PWUuZ2V0VWludDgoZS5wb3NpdGlvbisyKTticmVhaztjYXNlIDQ6cz1pP2UuZ2V0SW50MzIoZS5wb3NpdGlvbik6ZS5nZXRVaW50MzIoZS5wb3NpdGlvbik7YnJlYWs7Y2FzZSA4OmlmKGkpdGhyb3cgbmV3IEVycm9yKFwibm90IHN1cHBvcnRlZCBmb3IgcmVhZEJvZHkgOFwiKTtzPWUuZ2V0VWludDMyKGUucG9zaXRpb24pPDwzMixzfD1lLmdldFVpbnQzMihlLnBvc2l0aW9uKzQpO2JyZWFrO2RlZmF1bHQ6cz1cIlwifXJldHVybiBlLnBvc2l0aW9uKz10LHN9cmVhZFVpbnQ4KCl7cmV0dXJuIHMucmVhZEJ5dGUodGhpcy5kYXRhdmlldywxKX1yZWFkVWludDE2KCl7cmV0dXJuIHMucmVhZEJ5dGUodGhpcy5kYXRhdmlldywyKX1yZWFkVWludDI0KCl7cmV0dXJuIHMucmVhZEJ5dGUodGhpcy5kYXRhdmlldywzKX1yZWFkVWludDMyKCl7cmV0dXJuIHMucmVhZEJ5dGUodGhpcy5kYXRhdmlldyw0KX1yZWFkVWludDY0KCl7cmV0dXJuIHMucmVhZEJ5dGUodGhpcy5kYXRhdmlldyw4KX1yZWFkSW50OCgpe3JldHVybiBzLnJlYWRCeXRlKHRoaXMuZGF0YXZpZXcsMSwhMCl9cmVhZEludDE2KCl7cmV0dXJuIHMucmVhZEJ5dGUodGhpcy5kYXRhdmlldywyLCEwKX1yZWFkSW50MzIoKXtyZXR1cm4gcy5yZWFkQnl0ZSh0aGlzLmRhdGF2aWV3LDQsITApfXdyaXRlVWludDMyKGUpe3JldHVybiBuZXcgVWludDhBcnJheShbZT4+PjI0JjI1NSxlPj4+MTYmMjU1LGU+Pj44JjI1NSwyNTUmZV0pfX10LmRlZmF1bHQ9c30sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzLHI9aSgyNSksYT0ocz1yKSYmcy5fX2VzTW9kdWxlP3M6e2RlZmF1bHQ6c307dC5kZWZhdWx0PWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuYnVmZmVyPWV8fG5ldyBVaW50OEFycmF5KDApfXdyaXRlKC4uLmUpe2UuZm9yRWFjaChlPT57dGhpcy5idWZmZXI9KDAsYS5kZWZhdWx0KShVaW50OEFycmF5LHRoaXMuYnVmZmVyLGUpfSl9c3RhdGljIHdyaXRlVWludDMyKGUpe3JldHVybiBuZXcgVWludDhBcnJheShbZT4+MjQsZT4+MTYmMjU1LGU+PjgmMjU1LDI1NSZlXSl9c3RhdGljIHJlYWRBc0ludChlKXtsZXQgdD1cIlwiO3JldHVybiBlLmZvckVhY2goZT0+e3QrPWZ1bmN0aW9uKGUpe3JldHVybiBlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLFwiMFwiKX0oZSl9KSxwYXJzZUludCh0LDE2KX19fSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHMscj1pKDI2KSxhPShzPXIpJiZzLl9fZXNNb2R1bGU/czp7ZGVmYXVsdDpzfTtlLmV4cG9ydHM9YS5kZWZhdWx0fSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wLGk9YXJndW1lbnRzLmxlbmd0aCxzPUFycmF5KGk+MT9pLTE6MCkscj0xO3I8aTtyKyspc1tyLTFdPWFyZ3VtZW50c1tyXTt2YXIgYT0hMCxuPSExLG89dm9pZCAwO3RyeXtmb3IodmFyIGQsbD1zW1N5bWJvbC5pdGVyYXRvcl0oKTshKGE9KGQ9bC5uZXh0KCkpLmRvbmUpO2E9ITApe3ZhciBoPWQudmFsdWU7dCs9aC5sZW5ndGh9fWNhdGNoKGUpe249ITAsbz1lfWZpbmFsbHl7dHJ5eyFhJiZsLnJldHVybiYmbC5yZXR1cm4oKX1maW5hbGx5e2lmKG4pdGhyb3cgb319dmFyIHU9bmV3IGUodCksYz0wLGY9ITAscD0hMSxtPXZvaWQgMDt0cnl7Zm9yKHZhciBnLF89c1tTeW1ib2wuaXRlcmF0b3JdKCk7IShmPShnPV8ubmV4dCgpKS5kb25lKTtmPSEwKXt2YXIgeT1nLnZhbHVlO3Uuc2V0KHksYyksYys9eS5sZW5ndGh9fWNhdGNoKGUpe3A9ITAsbT1lfWZpbmFsbHl7dHJ5eyFmJiZfLnJldHVybiYmXy5yZXR1cm4oKX1maW5hbGx5e2lmKHApdGhyb3cgbX19cmV0dXJuIHV9fSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHMscj1pKDQpO2NvbnN0IGE9KChzPXIpJiZzLl9fZXNNb2R1bGU/czp7ZGVmYXVsdDpzfSkuZGVmYXVsdC5DUllUT19FVkVOVFM7dC5kZWZhdWx0PWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuaW5wdXRCdWZmZXI9ZS5pbnB1dGJ1ZmZlcix0aGlzLm91dHB1dEJ1ZmZlcj1lLm91dHB1dGJ1ZmZlcix0aGlzLmtleT1lLmtleSx0aGlzLml2PWUuaXYsdGhpcy5tZXRob2Q9ZS5tZXRob2QsdGhpcy5jcnlwdG89d2luZG93LmNyeXB0b3x8d2luZG93Lm1zQ3J5cHRvfWluaXQoKXt0aGlzLm9uKGEuU1RBUlRfREVDUllQVCx0aGlzLmRlY3JpcHQuYmluZCh0aGlzKSl9ZGVjcmlwdCgpe2lmKHRoaXMuYWVza2V5KXRoaXMuZGVjcmlwdERhdGEoKTtlbHNle3RoaXMuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIix0aGlzLmtleS5idWZmZXIse25hbWU6XCJBRVMtQ0JDXCJ9LCExLFtcImVuY3J5cHRcIixcImRlY3J5cHRcIl0pLnRoZW4oZT0+e3RoaXMuYWVza2V5PWUsdGhpcy5kZWNyaXB0RGF0YSgpfSl9fWRlY3JpcHREYXRhKCl7bGV0IGU9dGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZSh0aGlzLmlucHV0QnVmZmVyKSx0PXRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UodGhpcy5vdXRwdXRCdWZmZXIpLGk9ZS5zaGlmdCgpO2kmJnRoaXMuY3J5cHRvLnN1YnRsZS5kZWNyeXB0KHtuYW1lOlwiQUVTLUNCQ1wiLGl2OnRoaXMuaXYuYnVmZmVyfSx0aGlzLmFlc2tleSxpKS50aGVuKGU9Pnt0LnB1c2gobmV3IFVpbnQ4QXJyYXkoZSkpLHRoaXMuZW1pdChhLkRFQ1JZUFRFRCksdGhpcy5kZWNyaXB0RGF0YShpKX0pfX19LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1oKGkoMjkpKSxyPWgoaSgzNikpLGE9aSgzOSksbj1pKDkpLG89aSgwKSxkPWkoNyksbD1oKGkoMikpO2Z1bmN0aW9uIGgoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWNvbnN0IHU9by5FVkVOVFMuUkVNVVhfRVZFTlRTLGM9by5FVkVOVFMuREVNVVhfRVZFTlRTLGY9by5FVkVOVFMuTE9BREVSX0VWRU5UUyxwPVwiRkxWQ29udHJvbGxlclwiO2NsYXNzIG17d2Fybigpe319Y29uc3QgZz1cIkZMVl9FUlJPUlwiO2NsYXNzIF97Y29uc3RydWN0b3IoZSl7dGhpcy5UQUc9cCx0aGlzLl9wbGF5ZXI9ZSx0aGlzLnN0YXRlPXtpbml0U2VnbWVudEFycml2ZWQ6ITEscmFuZ2U6e3N0YXJ0OjAsZW5kOlwiXCJ9LHJhbmdlU3VwcG9ydDohMH19c3RhdGljIGZpbmRGaWxlUG9zaXRpb24oZSx0KXtmb3IobGV0IGk9MCxzPXQudGltZXMubGVuZ3RoO2k8cztpKyspe2NvbnN0IHI9dC50aW1lc1tpXSxhPWkrMTxzP3QudGltZXNbaSsxXTpOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtpZihyPD1lJiZlPD1hKXJldHVybiB0LmZpbGVwb3NpdGlvbnNbaV19cmV0dXJuXCJcIn1pbml0KCl7dGhpcy5fY29udGV4dC5yZWdpc3RyeShcIkZFVENIX0xPQURFUlwiLGEuRmV0Y2hMb2FkZXIpLHRoaXMuX2NvbnRleHQucmVnaXN0cnkoXCJMT0FERVJfQlVGRkVSXCIsbi5YZ0J1ZmZlciksdGhpcy5fY29udGV4dC5yZWdpc3RyeShcIkZMVl9ERU1VWEVSXCIscy5kZWZhdWx0KSx0aGlzLl9jb250ZXh0LnJlZ2lzdHJ5KFwiVFJBQ0tTXCIsbi5UcmFja3MpLHRoaXMuX2NvbnRleHQucmVnaXN0cnkoXCJNUDRfUkVNVVhFUlwiLHIuZGVmYXVsdC5NcDRSZW11eGVyKSx0aGlzLl9jb250ZXh0LnJlZ2lzdHJ5KFwiUFJFX1NPVVJDRV9CVUZGRVJcIixuLlByZVNvdXJjZSksdGhpcy5fY29udGV4dC5yZWdpc3RyeShcIkNPTVBBVElCSUxJVFlcIixkLkNvbXBhdGliaWxpdHkpLHRoaXMuX2NvbnRleHQucmVnaXN0cnkoXCJMT0dHRVJcIixtKSx0aGlzLm1zZT10aGlzLl9jb250ZXh0LnJlZ2lzdHJ5KFwiTVNFXCIsby5Nc2UpKHtjb250YWluZXI6dGhpcy5fcGxheWVyLnZpZGVvfSksdGhpcy5pbml0TGlzdGVuZXJzKCksc2V0VGltZW91dCgoKT0+e3RoaXMubG9hZE1ldGEoKX0sMCl9aW5pdExpc3RlbmVycygpe3RoaXMub24oZi5MT0FERVJfREFUQUxPQURFRCx0aGlzLl9oYW5kbGVMb2FkZXJEYXRhTG9hZGVkLmJpbmQodGhpcykpLHRoaXMub24oZi5MT0FERVJfRVJST1IsdGhpcy5faGFuZGxlTmV0d29ya0Vycm9yLmJpbmQodGhpcykpLHRoaXMub24oYy5NRURJQV9JTkZPLHRoaXMuX2hhbmRsZU1lZGlhSW5mby5iaW5kKHRoaXMpKSx0aGlzLm9uKGMuTUVUQURBVEFfUEFSU0VELHRoaXMuX2hhbmRsZU1ldGFkYXRhUGFyc2VkLmJpbmQodGhpcykpLHRoaXMub24oYy5ERU1VWF9DT01QTEVURSx0aGlzLl9oYW5kbGVEZW11eENvbXBsZXRlLmJpbmQodGhpcykpLHRoaXMub24oYy5ERU1VWF9FUlJPUix0aGlzLl9oYW5kbGVEZW11eEVycm9yLmJpbmQodGhpcykpLHRoaXMub24odS5JTklUX1NFR01FTlQsdGhpcy5faGFuZGxlQXBwZW5kSW5pdFNlZ21lbnQuYmluZCh0aGlzKSksdGhpcy5vbih1Lk1FRElBX1NFR01FTlQsdGhpcy5faGFuZGxlTWVkaWFTZWdtZW50LmJpbmQodGhpcykpfV9oYW5kbGVNZWRpYUluZm8oKXt0aGlzLl9jb250ZXh0Lm9uTWV0YURhdGF8fHRoaXMuZW1pdChjLkRFTVVYX0VSUk9SLG5ldyBFcnJvcihcImZhaWxlZCB0byBnZXQgbWVkaWFpbmZvXCIpKTtjb25zdCBlPXRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoXCJMT0FERVJfQlVGRkVSXCIpLHQ9dGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZShcIkZFVENIX0xPQURFUlwiKTt0aGlzLmlzU2Vla2FibGUmJih0LmNhbmNlbCgpLHRoaXMuc3RhdGUucmFuZ2U9e3N0YXJ0OjAsZW5kOmUuaGlzdG9yeUxlbi0xfSxzZXRUaW1lb3V0KCgpPT57dGhpcy5sb2FkTmV4dCgwKX0pKX1faGFuZGxlTG9hZGVyRGF0YUxvYWRlZCgpe3RoaXMuZW1pdFRvKFwiRkxWX0RFTVVYRVJcIixjLkRFTVVYX1NUQVJUKX1faGFuZGxlTWV0YWRhdGFQYXJzZWQoZSl7dGhpcy5lbWl0KHUuUkVNVVhfTUVUQURBVEEsZSl9X2hhbmRsZURlbXV4Q29tcGxldGUoKXt0aGlzLmVtaXQodS5SRU1VWF9NRURJQSl9X2hhbmRsZUFwcGVuZEluaXRTZWdtZW50KCl7dGhpcy5zdGF0ZS5pbml0U2VnbWVudEFycml2ZWQ9ITAsdGhpcy5tc2UuYWRkU291cmNlQnVmZmVycygpfV9oYW5kbGVNZWRpYVNlZ21lbnQoKXt0aGlzLm1zZS5hZGRTb3VyY2VCdWZmZXJzKCksdGhpcy5tc2UuZG9BcHBlbmQoKX1faGFuZGxlTmV0d29ya0Vycm9yKGUsdCl7dGhpcy5fcGxheWVyLmVtaXQoXCJlcnJvclwiLG5ldyBsLmRlZmF1bHQuRXJyb3JzKFwibmV0d29ya1wiLHRoaXMuX3BsYXllci5jb25maWcudXJsKSksdGhpcy5fb25FcnJvcihmLkxPQURFUl9FUlJPUixlLHQsITApfV9oYW5kbGVEZW11eEVycm9yKGUsdCxpKXt2b2lkIDA9PT1pJiYoaT0hMSksdGhpcy5fcGxheWVyLmVtaXQoXCJlcnJvclwiLG5ldyBsLmRlZmF1bHQuRXJyb3JzKFwicGFyc2VcIix0aGlzLl9wbGF5ZXIuY29uZmlnLnVybCkpLHRoaXMuX29uRXJyb3IoZi5MT0FERVJfRVJST1IsZSx0LGkpfV9vbkVycm9yKGUsdCxpLHMpe2xldCByPXtlcnJvclR5cGU6ZSxlcnJvckRldGFpbHM6YFske3R9XTogJHtpLm1lc3NhZ2V9YCxlcnJvckZhdGFsOnN8fCExfTt0aGlzLl9wbGF5ZXIuZW1pdChnLHIpfXNlZWsoZSl7aWYoIXRoaXMuX2NvbnRleHQub25NZXRhRGF0YSlyZXR1cm4gdm9pZCB0aGlzLmxvYWRNZXRhKCk7aWYoIXRoaXMuaXNTZWVrYWJsZSlyZXR1cm47dGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZShcIkxPQURFUl9CVUZGRVJcIikuY2xlYXIoKTtjb25zdHtwcmVsb2FkVGltZTp0PTE1fT10aGlzLl9wbGF5ZXIuY29uZmlnLGk9dGhpcy5nZXRTZWVrUmFuZ2UoZSx0KTt0aGlzLnN0YXRlLnJhbmdlPWksdGhpcy5jb21wYXQmJnRoaXMuY29tcGF0LnJlc2V0KCksdGhpcy5sb2FkRGF0YSgpfWxvYWROZXh0KGUpe3RoaXMuX2NvbnRleHQub25NZXRhRGF0YSYmKHRoaXMubG9hZGVyLmxvYWRpbmd8fHRoaXMuZ2V0TmV4dFJhbmdlKGUpJiZ0aGlzLmxvYWREYXRhKCkpfWxvYWREYXRhKCl7Y29uc3R7c3RhcnQ6ZSxlbmQ6dH09dGhpcy5zdGF0ZS5yYW5nZTt0aGlzLmVtaXQoZi5MQURFUl9TVEFSVCx0aGlzLl9wbGF5ZXIuY29uZmlnLnVybCx7aGVhZGVyczp7bWV0aG9kOlwiZ2V0XCIsUmFuZ2U6YGJ5dGVzPSR7ZX0tJHt0fWB9fSl9bG9hZE1ldGEoKXt0aGlzLmxvYWRlci5sb2FkKHRoaXMuX3BsYXllci5jb25maWcudXJsLHtoZWFkZXJzOntSYW5nZTpcImJ5dGVzPTAtXCJ9fSkuY2F0Y2goKCk9Pnt0aGlzLnN0YXRlLnJhbmdlU3VwcG9ydD0hMSx0aGlzLmxvYWRGYWxsYmFjaygpfSl9bG9hZEZhbGxiYWNrKCl7dGhpcy5sb2FkZXIubG9hZCh0aGlzLl9wbGF5ZXIuY29uZmlnLnVybCkuY2F0Y2goKCk9Pnt0aGlzLl9wbGF5ZXIuZW1pdChcImVycm9yXCIsbmV3IGwuZGVmYXVsdC5FcnJvcnMoXCJuZXR3b3JrXCIsdGhpcy5fcGxheWVyLmNvbmZpZy51cmwpKX0pfWdldFNlZWtSYW5nZShlLHQpe2NvbnN0e2tleWZyYW1lczppfT10aGlzLl9jb250ZXh0Lm9uTWV0YURhdGEscz10aGlzLl9jb250ZXh0Lm1lZGlhSW5mby5kdXJhdGlvbixyPWUsYT1lK3Qsbj1fLmZpbmRGaWxlUG9zaXRpb24ocixpKTtyZXR1cm4gYT49c3x8cj49cz97c3RhcnQ6bixlbmQ6XCJcIn06e3N0YXJ0Om4sZW5kOl8uZmluZEZpbGVQb3NpdGlvbihhLGkpfX1nZXROZXh0UmFuZ2UoZSl7aWYoXCJcIj09PXRoaXMuc3RhdGUucmFuZ2UuZW5kKXJldHVybjtjb25zdHtlbmQ6dH09dGhpcy5nZXRTZWVrUmFuZ2UoZSx0aGlzLmNvbmZpZy5wcmVsb2FkVGltZXx8MTUpO3JldHVybiB0PD10aGlzLnN0YXRlLnJhbmdlLmVuZCYmXCJcIiE9PXQ/dm9pZCAwOih0aGlzLnN0YXRlLnJhbmdlPXtzdGFydDp0aGlzLnN0YXRlLnJhbmdlLmVuZCsxLGVuZDp0fSwhMCl9ZGVzdHJveSgpe3RoaXMuX3BsYXllcj1udWxsLHRoaXMubXNlPW51bGwsdGhpcy5zdGF0ZT17aW5pdFNlZ21lbnRBcnJpdmVkOiExLHJhbmdlOntzdGFydDowLGVuZDpcIlwifSxyYW5nZVN1cHBvcnQ6ITB9fWdldCBpc1NlZWthYmxlKCl7cmV0dXJuISF0aGlzLnN0YXRlLnJhbmdlU3VwcG9ydCYmKCF0aGlzLl9jb250ZXh0fHwhdGhpcy5fY29udGV4dC5tZWRpYUluZm8uaXNDb21wbGV0ZSgpfHxudWxsIT09dGhpcy5fY29udGV4dC5tZWRpYUluZm8ua2V5ZnJhbWVzJiZ2b2lkIDAhPT10aGlzLl9jb250ZXh0Lm1lZGlhSW5mby5rZXlmcmFtZXMpfWdldCBjb25maWcoKXtyZXR1cm4gdGhpcy5fcGxheWVyLmNvbmZpZ31nZXQgbG9hZGVyKCl7cmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoXCJGRVRDSF9MT0FERVJcIil9Z2V0IGNvbXBhdCgpe3JldHVybiB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKFwiQ09NUEFUSUJJTElUWVwiKX19dC5kZWZhdWx0PV99LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcyxyPWkoMCksYT1pKDcpLG49aSg5KSxvPWkoMzUpLGQ9KHM9bykmJnMuX19lc01vZHVsZT9zOntkZWZhdWx0OnN9O2NvbnN0IGw9ci5FVkVOVFMuREVNVVhfRVZFTlRTO2NsYXNzIGh7Y29uc3RydWN0b3IoKXt0aGlzLl9maXJzdEZyYWdtZW50TG9hZGVkPSExLHRoaXMuX3RyYWNrTnVtPTAsdGhpcy5faGFzU2NyaXB0PSExfWluaXQoKXt0aGlzLm9uKGwuREVNVVhfU1RBUlQsdGhpcy5kb1BhcnNlRmx2LmJpbmQodGhpcykpfXN0YXRpYyBpc0ZsdkZpbGUoZSl7cmV0dXJuISg3MCE9PWVbMF18fDc2IT09ZVsxXXx8ODYhPT1lWzJdfHwxIT09ZVszXSl9c3RhdGljIGdldFBsYXlUeXBlKGUpe2NvbnN0IHQ9e2hhc1ZpZGVvOiExLGhhc0F1ZGlvOiExfTtyZXR1cm4hMCZlJiYodC5oYXNWaWRlbz0hMCksITAmZSYmKHQuaGFzQXVkaW89ITApLHR9ZG9QYXJzZUZsdigpe2lmKHRoaXMuX2ZpcnN0RnJhZ21lbnRMb2FkZWQpe2lmKHRoaXMubG9hZGVyQnVmZmVyLmxlbmd0aDwxMSlyZXR1cm47bGV0IGUsdD0xZTU7ZG97ZT10aGlzLl9wYXJzZUZsdlRhZygpfXdoaWxlKGUmJnQtLSA+MCk7dGhpcy5lbWl0KGwuREVNVVhfQ09NUExFVEUpfWVsc2V7aWYodGhpcy5sb2FkZXJCdWZmZXIubGVuZ3RoPDEzKXJldHVybjtjb25zdCBlPXRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDEzKTt0aGlzLnBhcnNlRmx2SGVhZGVyKGUpLHRoaXMuZG9QYXJzZUZsdigpfX1wYXJzZUZsdkhlYWRlcihlKXtpZihoLmlzRmx2RmlsZShlKSl7dGhpcy5fZmlyc3RGcmFnbWVudExvYWRlZD0hMDtjb25zdCB0PWguZ2V0UGxheVR5cGUoZVs0XSk7dC5oYXNWaWRlbyYmdGhpcy5pbml0VmlkZW9UcmFjaygpLHQuaGFzQXVkaW8mJnRoaXMuaW5pdEF1ZGlvVHJhY2soKX1lbHNlIHRoaXMuZW1pdChsLkRFTVVYX0VSUk9SLG5ldyBFcnJvcihcImludmFsaWQgZmx2IGZpbGVcIikpLHRoaXMuZG9QYXJzZUZsdigpO3RoaXMuZG9QYXJzZUZsdigpfWluaXRWaWRlb1RyYWNrKCl7dGhpcy5fdHJhY2tOdW0rKztsZXQgZT1uZXcgbi5WaWRlb1RyYWNrO2UubWV0YT1uZXcgci5WaWRlb1RyYWNrTWV0YSxlLmlkPWUubWV0YS5pZD10aGlzLl90cmFja051bSx0aGlzLnRyYWNrcy52aWRlb1RyYWNrPWV9aW5pdEF1ZGlvVHJhY2soKXt0aGlzLl90cmFja051bSsrO2xldCBlPW5ldyBuLkF1ZGlvVHJhY2s7ZS5tZXRhPW5ldyByLkF1ZGlvVHJhY2tNZXRhLGUuaWQ9ZS5tZXRhLmlkPXRoaXMuX3RyYWNrTnVtLHRoaXMudHJhY2tzLmF1ZGlvVHJhY2s9ZX1fcGFyc2VGbHZUYWcoKXtpZih0aGlzLmxvYWRlckJ1ZmZlci5sZW5ndGg8MTEpcmV0dXJuIG51bGw7bGV0IGU9dGhpcy5fcGFyc2VGbHZUYWdIZWFkZXIoKTtyZXR1cm4gZSYmdGhpcy5fcHJvY2Vzc0NodW5rKGUpLGV9X3BhcnNlRmx2VGFnSGVhZGVyKCl7bGV0IGU9MCx0PXt9LGk9dGhpcy5sb2FkZXJCdWZmZXIudG9JbnQoZSwxKTtpZihlKz0xLHQuZmlsdGVyZWQ9KDMyJmkpPj4+NSx0LnRhZ1R5cGU9MzEmaSx0LmRhdGFzaXplPXRoaXMubG9hZGVyQnVmZmVyLnRvSW50KGUsMyksZSs9Myw4IT09dC50YWdUeXBlJiY5IT09dC50YWdUeXBlJiYxMSE9PXQudGFnVHlwZSYmMTghPT10LnRhZ1R5cGV8fDAhPT10aGlzLmxvYWRlckJ1ZmZlci50b0ludCg4LDMpKXJldHVybiB0aGlzLmxvYWRlckJ1ZmZlciYmdGhpcy5sb2FkZXJCdWZmZXIubGVuZ3RoPjAmJnRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDEpLHRoaXMuZW1pdChsLkRFTVVYX0VSUk9SLHRoaXMuVEFHLG5ldyBFcnJvcihcInRhZ1R5cGUgXCIrdC50YWdUeXBlKSwhMSksbnVsbDtpZih0aGlzLmxvYWRlckJ1ZmZlci5sZW5ndGg8dC5kYXRhc2l6ZSsxNSlyZXR1cm4gbnVsbDt0aGlzLmxvYWRlckJ1ZmZlci5zaGlmdCg0KTtsZXQgcz10aGlzLmxvYWRlckJ1ZmZlci50b0ludCgwLDMpO3RoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDMpO2xldCByPXRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDEpWzBdO3JldHVybiByPjAmJihzKz0xNjc3NzIxNipyKSx0LmR0cz1zLHRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDMpLHR9X3Byb2Nlc3NDaHVuayhlKXtzd2l0Y2goZS50YWdUeXBlKXtjYXNlIDE4OnRoaXMuX3BhcnNlU2NyaXB0RGF0YShlKTticmVhaztjYXNlIDg6dGhpcy5fcGFyc2VBQUNEYXRhKGUpO2JyZWFrO2Nhc2UgOTp0aGlzLl9wYXJzZUhldmNEYXRhKGUpO2JyZWFrO2Nhc2UgMTE6dGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoMyk7YnJlYWs7ZGVmYXVsdDp0aGlzLmxvYWRlckJ1ZmZlci5zaGlmdCgxKX19X3BhcnNlU2NyaXB0RGF0YShlKXtsZXQgdD10aGlzLnRyYWNrcy5hdWRpb1RyYWNrLGk9dGhpcy50cmFja3MudmlkZW9UcmFjayxzPXRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KGUuZGF0YXNpemUpO2NvbnN0IHI9KG5ldyBkLmRlZmF1bHQpLnJlc29sdmUocyxzLmxlbmd0aCksYT10aGlzLl9jb250ZXh0Lm9uTWV0YURhdGE9cj9yLm9uTWV0YURhdGE6dm9pZCAwO2lmKHRoaXMuX2NvbnRleHQubWVkaWFJbmZvLmR1cmF0aW9uPWEuZHVyYXRpb24sdGhpcy5fY29udGV4dC5tZWRpYUluZm8uaGFzVmlkZW89YS5oYXNWaWRlbyx0aGlzLl9jb250ZXh0Lm1lZGlhSW5mby5oc2FBdWRpbz1hLmhhc0F1ZGlvLHRoaXMuX2RhdGFzaXplVmFsaWRhdG9yKGUuZGF0YXNpemUpJiYodGhpcy5lbWl0KGwuTUVESUFfSU5GTyksdGhpcy5faGFzU2NyaXB0PSEwKSx0JiYhdC5oYXNTcGVjaWZpY0NvbmZpZyl7bGV0IGU9dC5tZXRhO3N3aXRjaChhLmF1ZGlvc2FtcGxlcmF0ZSYmKGUuc2FtcGxlUmF0ZT1hLmF1ZGlvc2FtcGxlcmF0ZSksYS5hdWRpb2NoYW5uZWxzJiYoZS5jaGFubmVsQ291bnQ9YS5hdWRpb2NoYW5uZWxzKSxhLmF1ZGlvc2FtcGxlcmF0ZSl7Y2FzZSA0NDEwMDplLnNhbXBsZVJhdGVJbmRleD00O2JyZWFrO2Nhc2UgMjIwNTA6ZS5zYW1wbGVSYXRlSW5kZXg9NzticmVhaztjYXNlIDExMDI1OmUuc2FtcGxlUmF0ZUluZGV4PTEwfX1pZihpJiYhaS5oYXNTcGVjaWZpY0NvbmZpZyl7bGV0IGU9aS5tZXRhO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhLmZyYW1lcmF0ZSl7bGV0IHQ9TWF0aC5mbG9vcigxZTMqYS5mcmFtZXJhdGUpO2lmKHQ+MCl7bGV0IGk9dC8xZTM7ZS5mcmFtZVJhdGV8fChlLmZyYW1lUmF0ZT17fSksZS5mcmFtZVJhdGUuZml4ZWQ9ITAsZS5mcmFtZVJhdGUuZnBzPWksZS5mcmFtZVJhdGUuZnBzX251bT10LGUuZnJhbWVSYXRlLmZwc19kZW49MWUzfX19fV9hYWNTZXF1ZW5jZUhlYWRlclBhcnNlcihlKXtsZXQgdD17aGFzU3BlY2lmaWNDb25maWc6ITB9O3Qub2JqZWN0VHlwZT1lWzFdPj4+Myx0LnNhbXBsZVJhdGVJbmRleD0oNyZlWzFdKTw8MXxlWzJdPj4+Nyx0LmF1ZGlvc2FtcGxlcmF0ZT10aGlzLl9zd2l0Y2hBdWRpb1NhbXBsZVJhdGUodC5zYW1wbGVSYXRlSW5kZXgpLHQuY2hhbm5lbENvdW50PSgxMjAmZVsyXSk+Pj4zLHQuZnJhbWVMZW5ndGg9KDQmZVsyXSk+Pj4yLHQuZGVwZW5kc09uQ29yZUNvZGVyPSgyJmVbMl0pPj4+MSx0LmV4dGVuc2lvbkZsYWdJbmRleD0xJmVbMl0sdC5jb2RlYz1gbXA0YS40MC4ke3Qub2JqZWN0VHlwZX1gO2xldCBpLHMscj13aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLGE9dC5zYW1wbGVSYXRlSW5kZXg7cmV0dXJuLTEhPT1yLmluZGV4T2YoXCJmaXJlZm94XCIpP3Quc2FtcGxlUmF0ZUluZGV4Pj02Pyh0Lm9iamVjdFR5cGU9NSxzPW5ldyBBcnJheSg0KSxpPWEtMyk6KHQub2JqZWN0VHlwZT0yLHM9bmV3IEFycmF5KDIpLGk9YSk6LTEhPT1yLmluZGV4T2YoXCJhbmRyb2lkXCIpPyh0Lm9iamVjdFR5cGU9MixzPW5ldyBBcnJheSgyKSxpPWEpOih0Lm9iamVjdFR5cGU9NSxpPXQuc2FtcGxlUmF0ZUluZGV4LHM9bmV3IEFycmF5KDQpLHQuc2FtcGxlUmF0ZUluZGV4Pj02P2k9dC5zYW1wbGVSYXRlSW5kZXgtMzoxPT09dC5jaGFubmVsQ291bnQmJih0Lm9iamVjdFR5cGU9MixzPW5ldyBBcnJheSgyKSxpPXQuc2FtcGxlUmF0ZUluZGV4KSksc1swXT10Lm9iamVjdFR5cGU8PDMsc1swXXw9KDE1JnQuc2FtcGxlUmF0ZUluZGV4KT4+PjEsc1sxXT0oMTUmdC5zYW1wbGVSYXRlSW5kZXgpPDw3LHNbMV18PSgxNSZ0LmNoYW5uZWxDb3VudCk8PDMsNT09PXQub2JqZWN0VHlwZSYmKHNbMV18PSgxNSZpKT4+PjEsc1syXT0oMSZpKTw8NyxzWzJdfD04LHNbM109MCksdC5jb25maWc9cyx0fV9wYXJzZUFBQ0RhdGEoZSl7bGV0IHQ9dGhpcy50cmFja3MuYXVkaW9UcmFjaztpZighdClyZXR1cm47bGV0IGk9dC5tZXRhO2l8fCh0Lm1ldGE9bmV3IHIuQXVkaW9UcmFja01ldGEsaT10Lm1ldGEpO2xldCBzPXRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDEpWzBdO2UuZGF0YT10aGlzLmxvYWRlckJ1ZmZlci5zaGlmdChlLmRhdGFzaXplLTEpO2xldCBhPSgyNDAmcyk+Pj40O3QuZm9ybWF0PWEsMTAhPT1hJiZ0aGlzLmVtaXQobC5ERU1VWF9FUlJPUixuZXcgRXJyb3IoYGludmFsaWQgYXVkaW8gZm9ybWF0OiAke2F9YCkpLDEwIT09YXx8dGhpcy5faGFzQXVkaW9TZXF1ZW5jZXx8KGkuc2FtcGxlUmF0ZT10aGlzLl9zd2l0Y2hBdWRpb1NhbXBsaW5nRnJlcXVlbmN5KHMpLGkuc2FtcGxlUmF0ZUluZGV4PSgxMiZzKT4+PjIsaS5mcmFtZUxlbnRoPSgyJnMpPj4+MSxpLmNoYW5uZWxDb3VudD0xJnMsaS5yZWZTYW1wbGVEdXJhdGlvbj1NYXRoLmZsb29yKDEwMjQvaS5hdWRpb1NhbXBsZVJhdGUqaS50aW1lc2NhbGUpKTtsZXQgbj1pLmF1ZGlvU2FtcGxlUmF0ZSxvPWkuc2FtcGxlUmF0ZUluZGV4LGQ9aS5yZWZTYW1wbGVEdXJhdGlvbjtkZWxldGUgZS50YWdUeXBlO2xldCBoPXRoaXMuX2RhdGFzaXplVmFsaWRhdG9yKGUuZGF0YXNpemUpO2lmKDA9PT1lLmRhdGFbMF0pe2xldCB0PXRoaXMuX2FhY1NlcXVlbmNlSGVhZGVyUGFyc2VyKGUuZGF0YSk7bj10LmF1ZGlvc2FtcGxlcmF0ZXx8aS5hdWRpb1NhbXBsZVJhdGUsbz10LnNhbXBsZVJhdGVJbmRleHx8aS5zYW1wbGVSYXRlSW5kZXgsZD1NYXRoLmZsb29yKDEwMjQvbippLnRpbWVzY2FsZSksaS5jaGFubmVsQ291bnQ9dC5jaGFubmVsQ291bnQsaS5zYW1wbGVSYXRlPW4saS5zYW1wbGVSYXRlSW5kZXg9byxpLnJlZlNhbXBsZUR1cmF0aW9uPWQsaS5kdXJhdGlvbj10aGlzLl9jb250ZXh0Lm1lZGlhSW5mby5kdXJhdGlvbippLnRpbWVzY2FsZSxpLmNvbmZpZz10LmNvbmZpZztjb25zdCBzPXRoaXMuX2NvbnRleHQubWVkaWFJbmZvLmF1ZGlvO3MuY29kZWM9dC5jb2RlYyxzLmNoYW5uZWxDb3VudD10LmNoYW5uZWxDb3VudCxzLnNhbXBsZVJhdGU9bixzLnNhbXBsZVJhdGVJbmRleD10LmF1ZGlvU2FtcGxlUmF0ZUluZGV4LHRoaXMuX2hhc1NjcmlwdCYmIXRoaXMuX2hhc0F1ZGlvU2VxdWVuY2U/dGhpcy5lbWl0KGwuTUVUQURBVEFfUEFSU0VELFwiYXVkaW9cIik6dGhpcy5faGFzU2NyaXB0JiZ0aGlzLl9oYXNBdWRpb1NlcXVlbmNlJiZ0aGlzLmVtaXQobC5BVURJT19NRVRBREFUQV9DSEFOR0UpLHRoaXMuX2hhc0F1ZGlvU2VxdWVuY2U9ITAsdGhpcy5fbWV0YUNoYW5nZT0hMH1lbHNlIHRoaXMuX21ldGFDaGFuZ2UmJihlLm9wdGlvbnM9e21ldGE6dC5tZXRhfSx0aGlzLl9tZXRhQ2hhbmdlPSExKSxlLmRhdGE9ZS5kYXRhLnNsaWNlKDEsZS5kYXRhLmxlbmd0aCksdC5zYW1wbGVzLnB1c2goZSk7aHx8dGhpcy5lbWl0KGwuREVNVVhfRVJST1IsdGhpcy5UQUcsbmV3IEVycm9yKFwiVEFHIGxlbmd0aCBlcnJvciBhdCBcIitlLmRhdGFzaXplKSwhMSl9X3BhcnNlSGV2Y0RhdGEoZSl7bGV0IHQ9dGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoMSlbMF07ZS5mcmFtZVR5cGU9KDI0MCZ0KT4+PjQsZS5pc0tleWZyYW1lPTE9PT1lLmZyYW1lVHlwZTtsZXQgaT0xNSZ0O2lmKHRoaXMudHJhY2tzLnZpZGVvVHJhY2suY29kZWNJRD1pLGUuYXZjUGFja2V0VHlwZT10aGlzLmxvYWRlckJ1ZmZlci5zaGlmdCgxKVswXSxlLmN0cz10aGlzLmxvYWRlckJ1ZmZlci50b0ludCgwLDMpLHRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KDMpLDEyPT09aSl7Y29uc3QgdD10aGlzLmxvYWRlckJ1ZmZlci5zaGlmdChlLmRhdGFzaXplLTUpO2lmKGUuZGF0YT10LDAhPT1OdW1iZXIucGFyc2VJbnQoZS5hdmNQYWNrZXRUeXBlKSl7dGhpcy5fZGF0YXNpemVWYWxpZGF0b3IoZS5kYXRhc2l6ZSl8fHRoaXMuZW1pdChsLkRFTVVYX0VSUk9SLHRoaXMuVEFHLG5ldyBFcnJvcihgaW52YWxpZCB2aWRlbyB0YWcgZGF0YXNpemU6ICR7ZS5kYXRhc2l6ZX1gKSwhMSk7bGV0IHQ9e30saT0wO2Zvcih0LmN0cz1lLmN0cyx0LmR0cz1lLmR0cztlLmRhdGEubGVuZ3RoPmk7KXtsZXQgcz1lLmRhdGEuc2xpY2UoTnVtYmVyLnBhcnNlSW50KGkpLDQraSk7dC5zaXplPXNbM10sdC5zaXplKz0yNTYqc1syXSx0LnNpemUrPTI1NipzWzFdKjI1Nix0LnNpemUrPTI1NipzWzBdKjI1NioyNTYsaSs9NCx0LmRhdGE9ZS5kYXRhLnNsaWNlKE51bWJlci5wYXJzZUludChpKSx0LnNpemUraSksaSs9dC5zaXplLHRoaXMudHJhY2tzLnZpZGVvVHJhY2suc2FtcGxlcy5wdXNoKHQpLHRoaXMuZW1pdChsLk1FVEFEQVRBX1BBUlNFRCxcInZpZGVvXCIpfX1lbHNlIDA9PT1OdW1iZXIucGFyc2VJbnQoZS5hdmNQYWNrZXRUeXBlKSYmKHRoaXMuX2RhdGFzaXplVmFsaWRhdG9yKGUuZGF0YXNpemUpP3RoaXMuZW1pdChsLk1FVEFEQVRBX1BBUlNFRCxcInZpZGVvXCIpOnRoaXMuZW1pdChsLkRFTVVYX0VSUk9SLHRoaXMuVEFHLG5ldyBFcnJvcihgaW52YWxpZCB2aWRlbyB0YWcgZGF0YXNpemU6ICR7ZS5kYXRhc2l6ZX1gKSwhMSkpfWVsc2UgaWYoNz09PWkpe2xldCB0PXRoaXMubG9hZGVyQnVmZmVyLnNoaWZ0KGUuZGF0YXNpemUtNSk7aWYoMD09PXRbNF0mJjA9PT10WzVdJiYwPT09dFs2XSYmMT09PXRbN10pe2xldCBlPTA7Zm9yKGxldCBpPTA7aTw0O2krKyllPTI1NiplK3RbaV07ZS09NCwodD10LnNsaWNlKDQsdC5sZW5ndGgpKVszXT1lJTI1NixlPShlLXRbM10pLzI1Nix0WzJdPWUlMjU2LGU9KGUtdFsyXSkvMjU2LHRbMV09ZSUyNTYsdFswXT0oZS10WzFdKS8yNTZ9aWYoZS5kYXRhPXQsMD09PWUuYXZjUGFja2V0VHlwZSl7dGhpcy5fYXZjU2VxdWVuY2VIZWFkZXJQYXJzZXIoZS5kYXRhKSx0aGlzLl9kYXRhc2l6ZVZhbGlkYXRvcihlLmRhdGFzaXplKSYmKHRoaXMuX2hhc1NjcmlwdCYmIXRoaXMuX2hhc1ZpZGVvU2VxdWVuY2U/dGhpcy5lbWl0KGwuTUVUQURBVEFfUEFSU0VELFwidmlkZW9cIik6dGhpcy5faGFzU2NyaXB0JiZ0aGlzLl9oYXNWaWRlb1NlcXVlbmNlJiZ0aGlzLmVtaXQobC5WSURFT19NRVRBREFUQV9DSEFOR0UpLHRoaXMuX2hhc1ZpZGVvU2VxdWVuY2U9ITApLHRoaXMuX21ldGFDaGFuZ2U9ITB9ZWxzZXtpZighdGhpcy5fZGF0YXNpemVWYWxpZGF0b3IoZS5kYXRhc2l6ZSkpcmV0dXJuIHZvaWQgdGhpcy5lbWl0KGwuREVNVVhfRVJST1IsdGhpcy5UQUcsbmV3IEVycm9yKGBpbnZhbGlkIHZpZGVvIHRhZyBkYXRhc2l6ZTogJHtlLmRhdGFzaXplfWApLCExKTt0aGlzLl9tZXRhQ2hhbmdlJiYoZS5vcHRpb25zPXttZXRhOk9iamVjdC5hc3NpZ24oe30sdGhpcy50cmFja3MudmlkZW9UcmFjay5tZXRhKX0sdGhpcy5fbWV0YUNoYW5nZT0hMSksdGhpcy50cmFja3MudmlkZW9UcmFjay5zYW1wbGVzLnB1c2goZSl9fWVsc2UgdGhpcy5lbWl0KGwuREVNVVhfRVJST1IsdGhpcy5UQUcsbmV3IEVycm9yKGB2aWRlbyBjb2RlaWQgaXMgJHtpfWApLCExKSxlLmRhdGE9dGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoZS5kYXRhc2l6ZS0xKSx0aGlzLl9kYXRhc2l6ZVZhbGlkYXRvcihlLmRhdGFzaXplKXx8dGhpcy5lbWl0KGwuREVNVVhfRVJST1IsdGhpcy5UQUcsbmV3IEVycm9yKGBpbnZhbGlkIHZpZGVvIHRhZyBkYXRhc2l6ZTogJHtlLmRhdGFzaXplfWApLCExKSx0aGlzLnRyYWNrcy52aWRlb1RyYWNrLnNhbXBsZXMucHVzaChlKSx0aGlzLmVtaXQobC5ERU1VWF9DT01QTEVURSk7ZGVsZXRlIGUudGFnVHlwZX1fYXZjU2VxdWVuY2VIZWFkZXJQYXJzZXIoZSl7bGV0IHQ9dGhpcy50cmFja3MudmlkZW9UcmFjaztpZighdClyZXR1cm47bGV0IGk9MDt0Lm1ldGF8fCh0Lm1ldGE9bmV3IHIuVmlkZW9UcmFja01ldGEpO2xldCBzPXQubWV0YTtzLmNvbmZpZ3VyYXRpb25WZXJzaW9uPWVbMF0scy5hdmNQcm9maWxlSW5kaWNhdGlvbj1lWzFdLHMucHJvZmlsZUNvbXBhdGliaWxpdHk9ZVsyXSxzLmF2Y0xldmVsSW5kaWNhdGlvbj1lWzNdLzEwLHMubmFsVW5pdExlbmd0aD0xKygzJmVbNF0pO2xldCBuPTMxJmVbNV07aT02O2xldCBvPXt9O2ZvcihsZXQgdD0wO3Q8bjt0Kyspe2xldCB0PTI1NSplW2ldK2VbaSsxXTtpKz0yO2xldCByPW5ldyBVaW50OEFycmF5KHQpO2ZvcihsZXQgcz0wO3M8dDtzKyspcltzXT1lW2krc107bGV0IG49XCJhdmMxLlwiO2ZvcihsZXQgZT0xO2U8NDtlKyspe2xldCB0PXJbZV0udG9TdHJpbmcoMTYpO3QubGVuZ3RoPDImJih0PVwiMFwiK3QpLG4rPXR9cy5jb2RlYz1uLGkrPXQsdGhpcy50cmFja3MudmlkZW9UcmFjay5tZXRhLnNwcz1yLG89YS5TcHNQYXJzZXIucGFyc2VTUFMocil9bGV0IGQ9ZVtpXTtpKys7Zm9yKGxldCB0PTA7dDxkO3QrKyl7bGV0IHQ9MjU1KmVbaV0rZVtpKzFdO2krPTI7bGV0IHM9bmV3IFVpbnQ4QXJyYXkodCk7Zm9yKGxldCByPTA7cjx0O3IrKylzW3JdPWVbaStyXTtpKz10LHRoaXMudHJhY2tzLnZpZGVvVHJhY2subWV0YS5wcHM9c31PYmplY3QuYXNzaWduKHMsYS5TcHNQYXJzZXIudG9WaWRlb01ldGEobykpO2NvbnN0IGw9dGhpcy5fY29udGV4dC5tZWRpYUluZm8udmlkZW87bC5jb2RlYz1zLmNvZGVjLGwucHJvZmlsZT1zLnByb2ZpbGUsbC5sZXZlbD1zLmxldmVsLGwuY2hyb21hRm9ybWF0PXMuY2hyb21hRm9ybWF0LGwuZnJhbWVSYXRlPXMuZnJhbWVSYXRlLGwucGFyUmF0aW89cy5wYXJSYXRpbyxsLndpZHRoPWwud2lkdGg9PT1zLnByZXNlbnRXaWR0aD9sLndpZHRoOnMucHJlc2VudFdpZHRoLGwuaGVpZ2h0PWwuaGVpZ2h0PT09cy5wcmVzZW50SGVpZ2h0P2wud2lkdGg6cy5wcmVzZW50SGVpZ2h0LHMuZHVyYXRpb249dGhpcy5fY29udGV4dC5tZWRpYUluZm8uZHVyYXRpb24qcy50aW1lc2NhbGUscy5hdmNjPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoKSxzLmF2Y2Muc2V0KGUpLHQubWV0YT1zfV9zd2l0Y2hBdWRpb1NhbXBsZVJhdGUoZSl7cmV0dXJuWzk2ZTMsODgyMDAsNjRlMyw0OGUzLDQ0MTAwLDMyZTMsMjRlMywyMjA1MCwxNmUzLDEyZTMsMTEwMjUsOGUzLDczNTBdW2VdfV9zd2l0Y2hBdWRpb1NhbXBsaW5nRnJlcXVlbmN5KGUpe3JldHVybls1NTAwLDExMDI1LDIyMDUwLDQ0MTAwLDQ4ZTNdWygxMiZlKT4+PjJdfV9zd2l0Y2hBdWRpb0NoYW5uZWwoZSl7cmV0dXJuWzEsMl1bMSZlXX1fZGF0YXNpemVWYWxpZGF0b3IoZSl7bGV0IHQ9dGhpcy5sb2FkZXJCdWZmZXIudG9JbnQoMCw0KTtyZXR1cm4gdGhpcy5sb2FkZXJCdWZmZXIuc2hpZnQoNCksdD09PWUrMTF9Z2V0IGxvYWRlckJ1ZmZlcigpe2NvbnN0IGU9dGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZShcIkxPQURFUl9CVUZGRVJcIik7aWYoZSlyZXR1cm4gZTt0aGlzLmVtaXQobC5ERU1VWF9FUlJPUixuZXcgRXJyb3IoXCLmib7kuI3liLAgbG9hZGVyQnVmZmVyIOWunuS+i1wiKSl9Z2V0IHRyYWNrcygpe3JldHVybiB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKFwiVFJBQ0tTXCIpfWdldCBsb2dnZXIoKXtyZXR1cm4gdGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZShcIkxPR0dFUlwiKX19dC5kZWZhdWx0PWh9LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcyxyPWkoOCksYT0ocz1yKSYmcy5fX2VzTW9kdWxlP3M6e2RlZmF1bHQ6c307Y2xhc3MgbntzdGF0aWMgZ2V0TmFsdW5pdHMoZSl7aWYoZS5sZW5ndGgtZS5wb3NpdGlvbjw0KXJldHVybltdO2xldCB0PWUuZGF0YXZpZXcsaT1lLnBvc2l0aW9uO3JldHVybiAxPT09dC5nZXRJbnQzMihpKXx8MD09PXQuZ2V0SW50MTYoaSkmJjE9PT10LmdldEludDgoaSsyKT9uLmdldEFubmV4Yk5hbHMoZSk6bi5nZXRBdmNjTmFscyhlKX1zdGF0aWMgZ2V0QW5uZXhiTmFscyhlKXtsZXQgdD1bXSxpPW4uZ2V0SGVhZGVyUG9zaXRpb25Bbm5leEIoZSkscz1pLnBvcyxyPXM7Zm9yKDtzPGUubGVuZ3RoLTQ7KXtsZXQgYT1lLmJ1ZmZlci5zbGljZShzLHMraS5oZWFkZXJMZW5ndGgpO2kucG9zPT09ZS5wb3NpdGlvbiYmZS5za2lwKGkuaGVhZGVyTGVuZ3RoKSxyPShpPW4uZ2V0SGVhZGVyUG9zaXRpb25Bbm5leEIoZSkpLnBvcztsZXQgbz17aGVhZGVyOmEsYm9keTpuZXcgVWludDhBcnJheShlLmJ1ZmZlci5zbGljZShzK2EuYnl0ZUxlbmd0aCxyKSl9O24uYW5hbHlzZU5hbChvKSx0LnB1c2gobyksZS5za2lwKHItZS5wb3NpdGlvbikscz1yfXJldHVybiB0fXN0YXRpYyBnZXRBdmNjTmFscyhlKXtsZXQgdD1bXTtmb3IoO2UucG9zaXRpb248ZS5sZW5ndGgtNDspe2xldCBpPWUuZGF0YXZpZXcuZ2V0SW50MzIoKTtpZighKGUubGVuZ3RoLWUucG9zaXRpb24+PWkpKWJyZWFrO3tsZXQgcz1lLmJ1ZmZlci5zbGljZShlLnBvc2l0aW9uLGUucG9zaXRpb24rNCk7ZS5za2lwKDQpO2xldCByPWUuYnVmZmVyLnNsaWNlKGUucG9zaXRpb24sZS5wb3NpdGlvbitpKTtlLnNraXAoaSk7bGV0IGE9e2hlYWRlcjpzLGJvZHk6cn07bi5hbmFseXNlTmFsKGEpLHQucHVzaChhKX19cmV0dXJuIHR9c3RhdGljIGFuYWx5c2VOYWwoZSl7c3dpdGNoKDMxJmUuYm9keVswXSl7Y2FzZSAxOmUubmRyPSEwO2JyZWFrO2Nhc2UgNTplLmlkcj0hMDticmVhaztjYXNlIDY6YnJlYWs7Y2FzZSA3OmUuc3BzPWEuZGVmYXVsdC5wYXJzZVNQUyhlLmJvZHkpO2JyZWFrO2Nhc2UgODplLnBwcz0hMH19c3RhdGljIGdldEhlYWRlclBvc2l0aW9uQW5uZXhCKGUpe2xldCB0PWUucG9zaXRpb24saT0wO2Zvcig7MyE9PWkmJjQhPT1pJiZ0PGUubGVuZ3RoLTQ7KTA9PT1lLmRhdGF2aWV3LmdldEludDE2KHQpPzE9PT1lLmRhdGF2aWV3LmdldEludDE2KHQrMik/aT00OjE9PT1lLmRhdGF2aWV3LmdldEludDgodCsyKT9pPTM6dCsrOnQrKztyZXR1cm4gdD09PWUubGVuZ3RoLTQmJigwPT09ZS5kYXRhdmlldy5nZXRJbnQxNih0KT8xPT09ZS5kYXRhdmlldy5nZXRJbnQxNih0KzIpJiYoaT00KToodCsrLDA9PT1lLmRhdGF2aWV3LmdldEludDE2KHQpJiYxPT09ZS5kYXRhdmlldy5nZXRJbnQ4KHQpP2k9Mzp0PWUubGVuZ3RoKSkse3Bvczp0LGhlYWRlckxlbmd0aDppfX1zdGF0aWMgZ2V0QXZjYyhlLHQpe2xldCBpPW5ldyBVaW50OEFycmF5KGUuYnl0ZUxlbmd0aCt0LmJ5dGVMZW5ndGgrMTEpO2lbMF09MSxpWzFdPWVbMV0saVsyXT1lWzJdLGlbM109ZVszXSxpWzRdPTI1NSxpWzVdPTIyNTtsZXQgcz02O3JldHVybiBpLnNldChuZXcgVWludDhBcnJheShbZS5ieXRlTGVuZ3RoPj4+OCYyNTUsMjU1JmUuYnl0ZUxlbmd0aF0pLHMpLHMrPTIsaS5zZXQoZSxzKSxpW3MrPWUuYnl0ZUxlbmd0aF09MSxzKyssaS5zZXQobmV3IFVpbnQ4QXJyYXkoW3QuYnl0ZUxlbmd0aD4+PjgmMjU1LDI1NSZ0LmJ5dGVMZW5ndGhdKSxzKSxzKz0yLGkuc2V0KHQscyksaX19dC5kZWZhdWx0PW59LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt0LmRlZmF1bHQ9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5UQUc9XCJHb2xvbWJcIix0aGlzLl9idWZmZXI9ZSx0aGlzLl9idWZmZXJJbmRleD0wLHRoaXMuX3RvdGFsQnl0ZXM9ZS5ieXRlTGVuZ3RoLHRoaXMuX3RvdGFsQml0cz04KmUuYnl0ZUxlbmd0aCx0aGlzLl9jdXJyZW50V29yZD0wLHRoaXMuX2N1cnJlbnRXb3JkQml0c0xlZnQ9MH1kZXN0cm95KCl7dGhpcy5fYnVmZmVyPW51bGx9X2ZpbGxDdXJyZW50V29yZCgpe2xldCBlPXRoaXMuX3RvdGFsQnl0ZXMtdGhpcy5fYnVmZmVySW5kZXgsdD1NYXRoLm1pbig0LGUpLGk9bmV3IFVpbnQ4QXJyYXkoNCk7aS5zZXQodGhpcy5fYnVmZmVyLnN1YmFycmF5KHRoaXMuX2J1ZmZlckluZGV4LHRoaXMuX2J1ZmZlckluZGV4K3QpKSx0aGlzLl9jdXJyZW50V29yZD1uZXcgRGF0YVZpZXcoaS5idWZmZXIpLmdldFVpbnQzMigwKSx0aGlzLl9idWZmZXJJbmRleCs9dCx0aGlzLl9jdXJyZW50V29yZEJpdHNMZWZ0PTgqdH1yZWFkQml0cyhlKXtsZXQgdD1NYXRoLm1pbih0aGlzLl9jdXJyZW50V29yZEJpdHNMZWZ0LGUpLGk9dGhpcy5fY3VycmVudFdvcmQ+Pj4zMi10O2lmKGU+MzIpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlYWQgbW9yZSB0aGFuIDMyIGJpdHMgYXQgYSB0aW1lXCIpO3JldHVybiB0aGlzLl9jdXJyZW50V29yZEJpdHNMZWZ0LT10LHRoaXMuX2N1cnJlbnRXb3JkQml0c0xlZnQ+MD90aGlzLl9jdXJyZW50V29yZDw8PXQ6dGhpcy5fdG90YWxCeXRlcy10aGlzLl9idWZmZXJJbmRleD4wJiZ0aGlzLl9maWxsQ3VycmVudFdvcmQoKSwodD1lLXQpPjAmJnRoaXMuX2N1cnJlbnRXb3JkQml0c0xlZnQ/aTw8dHx0aGlzLnJlYWRCaXRzKHQpOml9cmVhZEJvb2woKXtyZXR1cm4gMT09PXRoaXMucmVhZEJpdHMoMSl9cmVhZEJ5dGUoKXtyZXR1cm4gdGhpcy5yZWFkQml0cyg4KX1fc2tpcExlYWRpbmdaZXJvKCl7bGV0IGU7Zm9yKGU9MDtlPHRoaXMuX2N1cnJlbnRXb3JkQml0c0xlZnQ7ZSsrKWlmKDAhPSh0aGlzLl9jdXJyZW50V29yZCYyMTQ3NDgzNjQ4Pj4+ZSkpcmV0dXJuIHRoaXMuX2N1cnJlbnRXb3JkPDw9ZSx0aGlzLl9jdXJyZW50V29yZEJpdHNMZWZ0LT1lLGU7cmV0dXJuIHRoaXMuX2ZpbGxDdXJyZW50V29yZCgpLGUrdGhpcy5fc2tpcExlYWRpbmdaZXJvKCl9cmVhZFVFRygpe2xldCBlPXRoaXMuX3NraXBMZWFkaW5nWmVybygpO3JldHVybiB0aGlzLnJlYWRCaXRzKGUrMSktMX1yZWFkU0VHKCl7bGV0IGU9dGhpcy5yZWFkVUVHKCk7cmV0dXJuIDEmZT9lKzE+Pj4xOi0xKihlPj4+MSl9fX0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzLHI9aSgwKSxhPWkoMzMpLG49KHM9YSkmJnMuX19lc01vZHVsZT9zOntkZWZhdWx0OnN9O2NvbnN0e1JFTVVYX0VWRU5UUzpvLERFTVVYX0VWRU5UUzpkfT1yLkVWRU5UUztjbGFzcyBse2NvbnN0cnVjdG9yKCl7dGhpcy5uZXh0QXVkaW9EdHM9MCx0aGlzLm5leHRWaWRlb0R0cz0wLHRoaXMubGFzdEF1ZGlvU2FtcGxlc0xlbj0wLHRoaXMubGFzdFZpZGVvU2FtcGxlc0xlbj0wLHRoaXMubGFzdFZpZGVvRHRzPXZvaWQgMCx0aGlzLmxhc3RBdWRpb0R0cz12b2lkIDAsdGhpcy5hbGxBdWRpb1NhbXBsZXNDb3VudD0wLHRoaXMuYWxsVmlkZW9TYW1wbGVzQ291bnQ9MCx0aGlzLl9maXJzdEF1ZGlvU2FtcGxlPW51bGwsdGhpcy5fZmlyc3RWaWRlb1NhbXBsZT1udWxsLHRoaXMuZmlsbGVkQXVkaW9TYW1wbGVzPVtdLHRoaXMuZmlsbGVkVmlkZW9TYW1wbGVzPVtdLHRoaXMuX3ZpZGVvTGFyZ2VHYXA9MCx0aGlzLl9hdWRpb0xhcmdlR2FwPTB9aW5pdCgpe3RoaXMuYmVmb3JlKG8uUkVNVVhfTUVESUEsdGhpcy5kb0ZpeC5iaW5kKHRoaXMpKX1yZXNldCgpe3RoaXMubmV4dEF1ZGlvRHRzPW51bGwsdGhpcy5uZXh0VmlkZW9EdHM9bnVsbCx0aGlzLmxhc3RBdWRpb1NhbXBsZXNMZW49MCx0aGlzLmxhc3RWaWRlb1NhbXBsZXNMZW49MCx0aGlzLmxhc3RWaWRlb0R0cz12b2lkIDAsdGhpcy5sYXN0QXVkaW9EdHM9dm9pZCAwLHRoaXMuZmlsbGVkQXVkaW9TYW1wbGVzPVtdLHRoaXMuZmlsbGVkVmlkZW9TYW1wbGVzPVtdfWRvRml4KCl7Y29uc3R7aXNGaXJzdEF1ZGlvU2FtcGxlczplLGlzRmlyc3RWaWRlb1NhbXBsZXM6dH09dGhpcy5nZXRGaXJzdFNhbXBsZSgpO3RoaXMucmVjb3JkU2FtcGxlc0NvdW50KCksdGhpcy5fZmlyc3RWaWRlb1NhbXBsZSYmdGhpcy5maXhSZWZTYW1wbGVEdXJhdGlvbih0aGlzLnZpZGVvVHJhY2subWV0YSx0aGlzLnZpZGVvVHJhY2suc2FtcGxlcyksdGhpcy5fZmlyc3RBdWRpb1NhbXBsZSYmdGhpcy5maXhSZWZTYW1wbGVEdXJhdGlvbih0aGlzLmF1ZGlvVHJhY2subWV0YSx0aGlzLmF1ZGlvVHJhY2suc2FtcGxlcyk7Y29uc3R7Y2hhbmdlZDppLGNoYW5nZWRJZHg6c309bC5kZXRhY3RDaGFuZ2VTdHJlYW0odGhpcy52aWRlb1RyYWNrLnNhbXBsZXMpO2kmJiFlP3RoaXMuZml4Q2hhbmdlU3RyZWFtVmlkZW8ocyk6dGhpcy5kb0ZpeFZpZGVvKHQpO2NvbnN0e2NoYW5nZWQ6cixjaGFuZ2VkSWR4OmF9PWwuZGV0YWN0Q2hhbmdlU3RyZWFtKHRoaXMuYXVkaW9UcmFjay5zYW1wbGVzKTtyP3RoaXMuZml4Q2hhbmdlU3RyZWFtQXVkaW8oYSk6dGhpcy5kb0ZpeEF1ZGlvKGUpfWRvRml4VmlkZW8oZSx0KXtsZXR7c2FtcGxlczppLG1ldGE6c309dGhpcy52aWRlb1RyYWNrO2lmKHMuZnJhbWVSYXRlJiYhMT09PXMuZnJhbWVSYXRlLmZpeGVkKXJldHVybjtpZighaXx8IWkubGVuZ3RofHwhdGhpcy5fZmlyc3RWaWRlb1NhbXBsZSlyZXR1cm47Y29uc3Qgcj1pWzBdLGE9aS5sZW5ndGg7dGhpcy5fdmlkZW9MYXJnZUdhcD4wJiZsLmRvRml4TGFyZ2VHYXAoaSx0aGlzLl92aWRlb0xhcmdlR2FwKSxyLmR0cyE9PXRoaXMuX2ZpcnN0VmlkZW9TYW1wbGUuZHRzJiYodHx8bC5kZXRlY3RMYXJnZUdhcCh0aGlzLm5leHRWaWRlb0R0cyxyKSkmJih0JiYodGhpcy5uZXh0VmlkZW9EdHM9dCksdGhpcy5fdmlkZW9MYXJnZUdhcD10aGlzLm5leHRWaWRlb0R0cy1yLmR0cyxsLmRvRml4TGFyZ2VHYXAoaSx0aGlzLl92aWRlb0xhcmdlR2FwKSk7Y29uc3Qgbj1yLmR0cztpZihlJiZ0aGlzLl9maXJzdEF1ZGlvU2FtcGxlKXtjb25zdCBlPXRoaXMuX2ZpcnN0VmlkZW9TYW1wbGUuZHRzLHQ9ZS10aGlzLl9maXJzdEF1ZGlvU2FtcGxlLmR0cztpZih0PjIqcy5yZWZTYW1wbGVEdXJhdGlvbil7Y29uc3QgYT1NYXRoLmZsb29yKHQvcy5yZWZTYW1wbGVEdXJhdGlvbik7Zm9yKGxldCB0PTA7dDxhO3QrKyl7Y29uc3QgYT1PYmplY3QuYXNzaWduKHt9LHIpO2EuZHRzPWUtKHQrMSkqcy5yZWZTYW1wbGVEdXJhdGlvbixhLnB0cz1hLmR0cythLmN0cyxpLnVuc2hpZnQoYSksdGhpcy5maWxsZWRWaWRlb1NhbXBsZXMucHVzaCh7ZHRzOmEuZHRzLHNpemU6YS5kYXRhLmJ5dGVMZW5ndGh9KX19fWxldCBvO2lmKHRoaXMubmV4dFZpZGVvRHRzKXtvPW4tdGhpcy5uZXh0VmlkZW9EdHM7Y29uc3QgZT1NYXRoLmFicyhvKTtpZihvPjIqcy5yZWZTYW1wbGVEdXJhdGlvbil7Y29uc3QgZT1NYXRoLmZsb29yKG8vcy5yZWZTYW1wbGVEdXJhdGlvbik7Zm9yKGxldCB0PTA7dDxlO3QrKyl7Y29uc3QgZT1PYmplY3QuYXNzaWduKHt9LGlbMF0pLHI9bi0odCsxKSpzLnJlZlNhbXBsZUR1cmF0aW9uO2UuZHRzPXI+dGhpcy5uZXh0VmlkZW9EdHM/cjp0aGlzLm5leHRWaWRlb0R0cyxlLnB0cz1lLmR0cytlLmN0cyx0aGlzLnZpZGVvVHJhY2suc2FtcGxlcy51bnNoaWZ0KGUpLHRoaXMuZmlsbGVkVmlkZW9TYW1wbGVzLnB1c2goe2R0czplLmR0cyxzaXplOmUuZGF0YS5ieXRlTGVuZ3RofSl9fWVsc2UgZTw9cy5yZWZTYW1wbGVEdXJhdGlvbiYmZT4wPyhpWzBdLmR0cz10aGlzLm5leHRWaWRlb0R0cyxpWzBdLm9yaWdpbkR0cz1pWzBdLmR0cyxpWzBdLmN0cz12b2lkIDAhPT1pWzBdLmN0cz9pWzBdLmN0czppWzBdLnB0cy1pWzBdLmR0cyxpWzBdLnB0cz1pWzBdLmR0cytpWzBdLmN0cyk6bzwwJiZsLmRvRml4TGFyZ2VHYXAoaSwtMSpvKX1jb25zdCBkPWlbaS5sZW5ndGgtMV0uZHRzLGg9aS5sZW5ndGg+PTI/ZC1pW2kubGVuZ3RoLTJdLmR0czpzLnJlZlNhbXBsZUR1cmF0aW9uO3RoaXMubGFzdFZpZGVvU2FtcGxlc0xlbj1hLHRoaXMubmV4dFZpZGVvRHRzPWQraCx0aGlzLmxhc3RWaWRlb0R0cz1kO2ZvcihsZXQgZT0wLHQ9aS5sZW5ndGg7ZTx0O2UrKyl7Y29uc3QgdD1pW2VdLHI9aVtlKzFdO2lmKCFyKWJyZWFrO2NvbnN0IGE9ci5kdHMtdC5kdHM7aWYoYT4yKnMucmVmU2FtcGxlRHVyYXRpb24pe2xldCBuPU1hdGguZmxvb3IoYS9zLnJlZlNhbXBsZUR1cmF0aW9uKSxvPTA7Zm9yKDtvPG47KXtjb25zdCBhPU9iamVjdC5hc3NpZ24oe30scik7YS5kdHM9dC5kdHMrKG8rMSkqcy5yZWZTYW1wbGVEdXJhdGlvbixhLnB0cz1hLmR0cythLmN0cyxhPHIuZHRzJiYoaS5zcGxpY2UoZSwwLGEpLHRoaXMuZmlsbGVkVmlkZW9TYW1wbGVzLnB1c2goe2R0czphLmR0cyxzaXplOmEuZGF0YS5ieXRlTGVuZ3RofSkpLG8rKyxlKyt9fX10aGlzLnZpZGVvVHJhY2suc2FtcGxlcz1pfWRvRml4QXVkaW8oZSx0KXtsZXR7c2FtcGxlczppLG1ldGE6c309dGhpcy5hdWRpb1RyYWNrO2lmKCFpfHwhaS5sZW5ndGgpcmV0dXJuO2NvbnN0IHI9aS5sZW5ndGgsYT1uLmRlZmF1bHQuZ2V0U2lsZW50RnJhbWUocy5jb2RlYyxzLmNoYW5uZWxDb3VudCksbz10aGlzLl9maXJzdEF1ZGlvU2FtcGxlLGQ9aVswXTtpZih0aGlzLl9hdWRpb0xhcmdlR2FwPjAmJmwuZG9GaXhMYXJnZUdhcChpLHRoaXMuX2F1ZGlvTGFyZ2VHYXApLGQuZHRzIT09dGhpcy5fZmlyc3RBdWRpb1NhbXBsZS5kdHMmJih0fHxsLmRldGVjdExhcmdlR2FwKHRoaXMubmV4dEF1ZGlvRHRzLGQpKSYmKHQmJih0aGlzLm5leHRBdWRpb0R0cz10KSx0aGlzLl9hdWRpb0xhcmdlR2FwPXRoaXMubmV4dEF1ZGlvRHRzLWQuZHRzLGwuZG9GaXhMYXJnZUdhcChpLHRoaXMuX2F1ZGlvTGFyZ2VHYXApKSx0aGlzLl9maXJzdFZpZGVvU2FtcGxlJiZlKXtjb25zdCBlPXRoaXMuX2ZpcnN0VmlkZW9TYW1wbGUucHRzP3RoaXMuX2ZpcnN0VmlkZW9TYW1wbGUucHRzOnRoaXMuX2ZpcnN0VmlkZW9TYW1wbGUuZHRzK3RoaXMuX2ZpcnN0VmlkZW9TYW1wbGUuY3RzO2lmKG8uZHRzLWU+cy5yZWZTYW1wbGVEdXJhdGlvbil7Y29uc3QgdD1NYXRoLmZsb29yKChvLmR0cy1lKS9zLnJlZlNhbXBsZUR1cmF0aW9uKTtmb3IobGV0IGU9MDtlPHQ7ZSsrKXtjb25zdCB0PXtkYXRhOmEsZGF0YXNpemU6YS5ieXRlTGVuZ3RoLGR0czpvLmR0cy0oZSsxKSpzLnJlZlNhbXBsZUR1cmF0aW9uLGZpbHRlcmVkOjB9O2kudW5zaGlmdCh0KSx0aGlzLmZpbGxlZEF1ZGlvU2FtcGxlcy5wdXNoKHtkdHM6dC5kdHMsc2l6ZTp0LmRhdGEuYnl0ZUxlbmd0aH0pfX19bGV0IGg7Y29uc3QgdT1pWzBdLmR0cztpZih0aGlzLm5leHRBdWRpb0R0cyl7aD11LXRoaXMubmV4dEF1ZGlvRHRzO2NvbnN0IGU9TWF0aC5hYnMoaCk7aWYoZT5zLnJlZlNhbXBsZUR1cmF0aW9uJiYxPT09ciYmMT09PXRoaXMubGFzdEF1ZGlvU2FtcGxlc0xlbiYmKHMucmVmU2FtcGxlRHVyYXRpb25GaXhlZD12b2lkIDApLGg+MipzLnJlZlNhbXBsZUR1cmF0aW9uKWlmKDE9PT1yJiYxPT09dGhpcy5sYXN0QXVkaW9TYW1wbGVzTGVuKXMucmVmU2FtcGxlRHVyYXRpb25GaXhlZD12b2lkIDAhPT1zLnJlZlNhbXBsZUR1cmF0aW9uRml4ZWQ/cy5yZWZTYW1wbGVEdXJhdGlvbkZpeGVkK2g6cy5yZWZTYW1wbGVEdXJhdGlvbitoO2Vsc2V7Y29uc3QgZT1NYXRoLmZsb29yKGgvcy5yZWZTYW1wbGVEdXJhdGlvbik7Zm9yKGxldCB0PTA7dDxlO3QrKyl7Y29uc3QgZT11LSh0KzEpKnMucmVmU2FtcGxlRHVyYXRpb24scj1PYmplY3QuYXNzaWduKHt9LGlbMF0se2R0czplPnRoaXMubmV4dEF1ZGlvRHRzP2U6dGhpcy5uZXh0QXVkaW9EdHN9KTt0aGlzLmZpbGxlZEF1ZGlvU2FtcGxlcy5wdXNoKHtkdHM6ci5kdHMsc2l6ZTpyLmRhdGEuYnl0ZUxlbmd0aH0pLHRoaXMuYXVkaW9UcmFjay5zYW1wbGVzLnVuc2hpZnQocil9fWVsc2UgZTw9cy5yZWZTYW1wbGVEdXJhdGlvbiYmZT4wPyhpWzBdLmR0cz10aGlzLm5leHRBdWRpb0R0cyxpWzBdLnB0cz10aGlzLm5leHRBdWRpb0R0cyk6aDwwJiZsLmRvRml4TGFyZ2VHYXAoaSwtMSpoKX1jb25zdCBjPWlbaS5sZW5ndGgtMV0uZHRzLGY9aS5sZW5ndGg+PTI/Yy1pW2kubGVuZ3RoLTJdLmR0czpzLnJlZlNhbXBsZUR1cmF0aW9uO3RoaXMubGFzdEF1ZGlvU2FtcGxlc0xlbj1yLHRoaXMubmV4dEF1ZGlvRHRzPXMucmVmU2FtcGxlRHVyYXRpb25GaXhlZD9jK3MucmVmU2FtcGxlRHVyYXRpb25GaXhlZDpjK2YsdGhpcy5sYXN0QXVkaW9EdHM9Yztmb3IobGV0IGU9MCx0PWkubGVuZ3RoO2U8dDtlKyspe2NvbnN0IHQ9aVtlXSxzPWlbZSsxXTtpZighcylicmVhaztjb25zdCByPXMuZHRzLXQuZHRzO2lbZV0uZHVyYXRpb249cn10aGlzLmF1ZGlvVHJhY2suc2FtcGxlcz1sLnNvcnRBdWRpb1NhbXBsZXMoaSl9Zml4Q2hhbmdlU3RyZWFtVmlkZW8oZSl7Y29uc3R7c2FtcGxlczp0LG1ldGE6aX09dGhpcy52aWRlb1RyYWNrLHM9MD09PWU/dGhpcy5nZXRTdHJlYW1DaGFuZ2VTdGFydCh0WzBdKTp0W2UtMV0uZHRzLHI9dFtlXS5kdHM7aWYoTWF0aC5hYnMocy1yKTw9MippLnJlZlNhbXBsZUR1cmF0aW9uKXJldHVybiB0W2VdLm9wdGlvbnM/dFtlXS5vcHRpb25zLmlzQ29udGludWU9ITA6dFtlXS5vcHRpb25zPXtpc0NvbnRpbnVlOiEwfSx0aGlzLmRvRml4VmlkZW8oITEpO2NvbnN0IGE9dC5zbGljZSgwLGUpLG49dC5zbGljZShlKSxvPXRbMF0sZD1uWzBdLmR0cy1vLmR0cyxsPW8ub3B0aW9ucyYmby5vcHRpb25zLnN0YXJ0K2Q/by5vcHRpb25zLnN0YXJ0Om51bGw7dGhpcy52aWRlb1RyYWNrLnNhbXBsZXM9dC5zbGljZSgwLGUpLHRoaXMuZG9GaXhWaWRlbyghMSksdGhpcy52aWRlb1RyYWNrLnNhbXBsZXM9dC5zbGljZShlKSx0aGlzLmRvRml4VmlkZW8oITEsbCksdGhpcy52aWRlb1RyYWNrLnNhbXBsZXM9YS5jb25jYXQobil9Zml4Q2hhbmdlU3RyZWFtQXVkaW8oZSl7Y29uc3R7c2FtcGxlczp0LG1ldGE6aX09dGhpcy5hdWRpb1RyYWNrLHM9MD09PWU/dGhpcy5nZXRTdHJlYW1DaGFuZ2VTdGFydCh0WzBdKTp0W2UtMV0uZHRzLHI9dFtlXS5kdHM7aWYoTWF0aC5hYnMocy1yKTw9MippLnJlZlNhbXBsZUR1cmF0aW9uKXJldHVybiB0W2VdLm9wdGlvbnM/dFtlXS5vcHRpb25zLmlzQ29udGludWU9ITA6dFtlXS5vcHRpb25zPXtpc0NvbnRpbnVlOiEwfSx0aGlzLmRvRml4QXVkaW8oITEpO2NvbnN0IGE9dC5zbGljZSgwLGUpLG49dC5zbGljZShlKSxvPXRbMF0sZD1uWzBdLmR0cy1vLmR0cyxsPW8ub3B0aW9ucyYmby5vcHRpb25zLnN0YXJ0K2Q/by5vcHRpb25zLnN0YXJ0Om51bGw7dGhpcy5hdWRpb1RyYWNrLnNhbXBsZXM9YSx0aGlzLmRvRml4QXVkaW8oITEpLHRoaXMuYXVkaW9UcmFjay5zYW1wbGVzPW4sdGhpcy5kb0ZpeEF1ZGlvKCExLGwpLHRoaXMuYXVkaW9UcmFjay5zYW1wbGVzPWEuY29uY2F0KG4pfWdldEZpcnN0U2FtcGxlKCl7bGV0e3NhbXBsZXM6ZX09dGhpcy52aWRlb1RyYWNrLHtzYW1wbGVzOnR9PXRoaXMuYXVkaW9UcmFjayxpPSExLHM9ITE7cmV0dXJuIXRoaXMuX2ZpcnN0VmlkZW9TYW1wbGUmJmUubGVuZ3RoJiYodGhpcy5fZmlyc3RWaWRlb1NhbXBsZT1sLmZpbmRGaXJzdFZpZGVvU2FtcGxlKGUpLGk9ITApLCF0aGlzLl9maXJzdEF1ZGlvU2FtcGxlJiZ0Lmxlbmd0aCYmKHRoaXMuX2ZpcnN0QXVkaW9TYW1wbGU9bC5maW5kRmlyc3RBdWRpb1NhbXBsZSh0KSxzPSEwKSx7aXNGaXJzdFZpZGVvU2FtcGxlczppLGlzRmlyc3RBdWRpb1NhbXBsZXM6c319Zml4UmVmU2FtcGxlRHVyYXRpb24oZSx0KXtjb25zdCBpPVwidmlkZW9cIj09PWUudHlwZSxzPWk/dGhpcy5hbGxWaWRlb1NhbXBsZXNDb3VudDp0aGlzLmFsbEF1ZGlvU2FtcGxlc0NvdW50LHI9aT90aGlzLl9maXJzdFZpZGVvU2FtcGxlLmR0czp0aGlzLl9maXJzdEF1ZGlvU2FtcGxlLmR0cyxhPWk/dGhpcy5maWxsZWRWaWRlb1NhbXBsZXMubGVuZ3RoOnRoaXMuZmlsbGVkQXVkaW9TYW1wbGVzLmxlbmd0aDtpZighZS5yZWZTYW1wbGVEdXJhdGlvbnx8ZS5yZWZTYW1wbGVEdXJhdGlvbjw9MHx8TnVtYmVyLmlzTmFOKGUucmVmU2FtcGxlRHVyYXRpb24pKXtpZih0Lmxlbmd0aD49MSl7Y29uc3QgaT10W3QubGVuZ3RoLTFdLmR0cztlLnJlZlNhbXBsZUR1cmF0aW9uPU1hdGguZmxvb3IoKGktcikvKHMrYS0xKSl9fWVsc2UgaWYoZS5yZWZTYW1wbGVEdXJhdGlvbiYmdC5sZW5ndGg+PTUpe2NvbnN0IGk9KHRbdC5sZW5ndGgtMV0uZHRzLXRbMF0uZHRzKS8odC5sZW5ndGgtMSk7ZS5yZWZTYW1wbGVEdXJhdGlvbj1NYXRoLmZsb29yKE1hdGguYWJzKGUucmVmU2FtcGxlRHVyYXRpb24taSk8PTU/ZS5yZWZTYW1wbGVEdXJhdGlvbjppKX19cmVjb3JkU2FtcGxlc0NvdW50KCl7Y29uc3R7YXVkaW9UcmFjazplLHZpZGVvVHJhY2s6dH09dGhpczt0aGlzLmFsbEF1ZGlvU2FtcGxlc0NvdW50Kz1lLnNhbXBsZXMubGVuZ3RoLHRoaXMuYWxsVmlkZW9TYW1wbGVzQ291bnQrPXQuc2FtcGxlcy5sZW5ndGh9cmVtb3ZlSW52YWxpZFNhbXBsZXMoKXtjb25zdHtfZmlyc3RWaWRlb1NhbXBsZTplLF9maXJzdEF1ZGlvU2FtcGxlOnR9PXRoaXM7dGhpcy5hdWRpb1RyYWNrLnNhbXBsZXM9dGhpcy5hdWRpb1RyYWNrLnNhbXBsZXMuZmlsdGVyKGU9PmUuZHRzPj10LmR0cyYmKHZvaWQgMD09PXRoaXMubGFzdEF1ZGlvRHRzfHxlLmR0cz50aGlzLmxhc3RBdWRpb0R0cykpLHRoaXMudmlkZW9UcmFjay5zYW1wbGVzPXRoaXMudmlkZW9UcmFjay5zYW1wbGVzLmZpbHRlcih0PT50LmR0cz49ZS5kdHMmJih2b2lkIDA9PT10aGlzLmxhc3RWaWRlb0R0c3x8dC5kdHM+dGhpcy5sYXN0VmlkZW9EdHMpKX1nZXRTdHJlYW1DaGFuZ2VTdGFydChlKXtyZXR1cm4gZS5vcHRpb25zJiZlLm9wdGlvbnMuc3RhcnQ/ZS5vcHRpb25zLnN0YXJ0LXRoaXMuZHRzQmFzZToxLzB9c3RhdGljIHNvcnRBdWRpb1NhbXBsZXMoZSl7cmV0dXJuIDE9PT1lLmxlbmd0aD9lOmUuc29ydCgoZSx0KT0+ZS5kdHMtdC5kdHMpfXN0YXRpYyBmaW5kRmlyc3RBdWRpb1NhbXBsZShlKXtyZXR1cm4gZSYmMCE9PWUubGVuZ3RoP2wuc29ydEF1ZGlvU2FtcGxlcyhlKVswXTpudWxsfXN0YXRpYyBmaW5kRmlyc3RWaWRlb1NhbXBsZShlKXtpZighZS5sZW5ndGgpcmV0dXJuIG51bGw7Y29uc3QgdD1lLnNvcnQoKGUsdCk9PmUuZHRzLXQuZHRzKTtmb3IobGV0IGU9MCxpPXQubGVuZ3RoO2U8aTtlKyspaWYodFtlXS5pc0tleWZyYW1lKXJldHVybiB0W2VdfXN0YXRpYyBkZXRlY3RMYXJnZUdhcChlLHQpe2lmKG51bGw9PT1lKXJldHVybjtjb25zdCBpPXQuZHRzfHwwLHM9ZS1pPj0xZTN8fGktZT49MWUzLHI9dC5vcHRpb25zJiZ0Lm9wdGlvbnMuZGlzY29udGludWU7cmV0dXJuIHN8fHJ9c3RhdGljIGRvRml4TGFyZ2VHYXAoZSx0KXtjb25zb2xlLmxvZyhcImZpeCBsYXJnZSBnYXBcIik7Zm9yKGxldCBpPTAscz1lLmxlbmd0aDtpPHM7aSsrKXtjb25zdCBzPWVbaV07cy5kdHMrPXQscy5wdHMmJihzLnB0cys9dCl9fXN0YXRpYyBkZXRhY3RDaGFuZ2VTdHJlYW0oZSl7bGV0IHQ9ITEsaT0tMTtmb3IobGV0IHM9MCxyPWUubGVuZ3RoO3M8cjtzKyspaWYoZVtzXS5vcHRpb25zJiZlW3NdLm9wdGlvbnMubWV0YSl7dD0hMCxpPXM7YnJlYWt9cmV0dXJue2NoYW5nZWQ6dCxjaGFuZ2VkSWR4Oml9fWdldCB0cmFja3MoKXtyZXR1cm4gdGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZShcIlRSQUNLU1wiKX1nZXQgYXVkaW9UcmFjaygpe3JldHVybiB0aGlzLnRyYWNrcz90aGlzLnRyYWNrcy5hdWRpb1RyYWNrOm51bGx9Z2V0IHZpZGVvVHJhY2soKXtyZXR1cm4gdGhpcy50cmFja3M/dGhpcy50cmFja3MudmlkZW9UcmFjazpudWxsfWdldCBkdHNCYXNlKCl7Y29uc3QgZT10aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKFwiTVA0X1JFTVVYRVJcIik7cmV0dXJuIGU/ZS5fZHRzQmFzZTowfX10LmRlZmF1bHQ9bH0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3QuZGVmYXVsdD1jbGFzc3tzdGF0aWMgZ2V0U2lsZW50RnJhbWUoZSx0KXtpZihcIm1wNGEuNDAuMlwiPT09ZSl7aWYoMT09PXQpcmV0dXJuIG5ldyBVaW50OEFycmF5KFswLDIwMCwwLDEyOCwzNSwxMjhdKTtpZigyPT09dClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzMzLDAsNzMsMTQ0LDIsMjUsMCwzNSwxMjhdKTtpZigzPT09dClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzAsMjAwLDAsMTI4LDMyLDEzMiwxLDM4LDY0LDgsMTAwLDAsMTQyXSk7aWYoND09PXQpcmV0dXJuIG5ldyBVaW50OEFycmF5KFswLDIwMCwwLDEyOCwzMiwxMzIsMSwzOCw2NCw4LDEwMCwwLDEyOCw0NCwxMjgsOCwyLDU2XSk7aWYoNT09PXQpcmV0dXJuIG5ldyBVaW50OEFycmF5KFswLDIwMCwwLDEyOCwzMiwxMzIsMSwzOCw2NCw4LDEwMCwwLDEzMCw0OCw0LDE1MywwLDMzLDE0NCwyLDU2XSk7aWYoNj09PXQpcmV0dXJuIG5ldyBVaW50OEFycmF5KFswLDIwMCwwLDEyOCwzMiwxMzIsMSwzOCw2NCw4LDEwMCwwLDEzMCw0OCw0LDE1MywwLDMzLDE0NCwyLDAsMTc4LDAsMzIsOCwyMjRdKX1lbHNle2lmKDE9PT10KXJldHVybiBuZXcgVWludDhBcnJheShbMSw2NCwzNCwxMjgsMTYzLDc4LDIzMCwxMjgsMTg2LDgsMCwwLDAsMjgsNiwyNDEsMTkzLDEwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDk0XSk7aWYoMj09PXQpcmV0dXJuIG5ldyBVaW50OEFycmF5KFsxLDY0LDM0LDEyOCwxNjMsOTQsMjMwLDEyOCwxODYsOCwwLDAsMCwwLDE0OSwwLDYsMjQxLDE2MSwxMCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5NF0pO2lmKDM9PT10KXJldHVybiBuZXcgVWludDhBcnJheShbMSw2NCwzNCwxMjgsMTYzLDk0LDIzMCwxMjgsMTg2LDgsMCwwLDAsMCwxNDksMCw2LDI0MSwxNjEsMTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTRdKX1yZXR1cm4gbnVsbH19fSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y2xhc3Mgc3tjb25zdHJ1Y3Rvcigpe3RoaXMubWltZXR5cGU9XCJcIix0aGlzLmluaXQ9bnVsbCx0aGlzLmRhdGE9W119fXQuZGVmYXVsdD1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuc291cmNlcz17fX1nZXRTb3VyY2UoZSl7cmV0dXJuIHRoaXMuc291cmNlc1tlXX1jcmVhdGVTb3VyY2UoZSl7cmV0dXJuIHRoaXMuc291cmNlc1tlXT1uZXcgcyx0aGlzLnNvdXJjZXNbZV19Y2xlYXIoKXt0aGlzLnNvdXJjZXM9e319ZGVzdHJveSgpe3RoaXMuc291cmNlcz17fX19fSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9aSgwKTtjb25zdCByPXtOVU1CRVI6MCxCT09MRUFOOjEsU1RSSU5HOjIsT0JKRUNUOjMsTUlYX0FSUkFZOjgsT0JKRUNUX0VORDo5LFNUUklDVF9BUlJBWToxMCxEQVRFOjExLExPTkVfU1RSSU5HOjEyfTt0LmRlZmF1bHQ9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLm9mZnNldD0wLHRoaXMucmVhZE9mZnNldD10aGlzLm9mZnNldH1yZXNvbHZlKGUsdCl7aWYodDwzKXRocm93IG5ldyBFcnJvcihcIm5vdCBlbm91Z2ggZGF0YSBmb3IgbWV0YWluZm9cIik7Y29uc3QgaT17fSxzPXRoaXMucGFyc2VWYWx1ZShlKSxyPXRoaXMucGFyc2VWYWx1ZShlLHQtcy5ib2R5U2l6ZSk7cmV0dXJuIGlbcy5kYXRhXT1yLmRhdGEsdGhpcy5yZXNldFN0YXR1cygpLGl9cmVzZXRTdGF0dXMoKXt0aGlzLm9mZnNldD0wLHRoaXMucmVhZE9mZnNldD10aGlzLm9mZnNldH1wYXJzZVN0cmluZyhlKXtjb25zdCB0PW5ldyBEYXRhVmlldyhlLHRoaXMucmVhZE9mZnNldCkuZ2V0VWludDE2KDAsIXMuaXNMZSk7bGV0IGk9XCJcIjtpPXQ+MD9zLlVURjguZGVjb2RlKG5ldyBVaW50OEFycmF5KGUsdGhpcy5yZWFkT2Zmc2V0KzIsdCkpOlwiXCI7bGV0IHI9dCsyO3JldHVybiB0aGlzLnJlYWRPZmZzZXQrPXIse2RhdGE6aSxib2R5U2l6ZTp0KzJ9fXBhcnNlRGF0ZShlLHQpe2NvbnN0IGk9bmV3IERhdGFWaWV3KGUsdGhpcy5yZWFkT2Zmc2V0LHQpO2xldCByPWkuZ2V0RmxvYXQ2NCgwLCFzLmlzTGUpO3JldHVybiByKz02MCppLmdldEludDE2KDgsIXMuaXNMZSkqMWUzLHRoaXMucmVhZE9mZnNldCs9MTAse2RhdGE6bmV3IERhdGUociksYm9keVNpemU6MTB9fXBhcnNlT2JqZWN0KGUsdCl7Y29uc3QgaT10aGlzLnBhcnNlU3RyaW5nKGUsdCkscz10aGlzLnBhcnNlVmFsdWUoZSx0LWkuYm9keVNpemUpO3JldHVybntkYXRhOntuYW1lOmkuZGF0YSx2YWx1ZTpzLmRhdGF9LGJvZHlTaXplOmkuYm9keVNpemUrcy5ib2R5U2l6ZSxpc09iakVuZDpzLmlzT2JqRW5kfX1wYXJzZUxvbmdTdHJpbmcoZSl7Y29uc3QgdD1uZXcgRGF0YVZpZXcoZSx0aGlzLnJlYWRPZmZzZXQpLmdldFVpbnQzMigwLCFzLmlzTGUpO2xldCBpPVwiXCI7cmV0dXJuIGk9dD4wP3MuVVRGOC5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoZSx0aGlzLnJlYWRPZmZzZXQrMix0KSk6XCJcIix0aGlzLnJlYWRPZmZzZXQrPXQrNCx7ZGF0YTppLGJvZHlTaXplOnQrNH19cGFyc2VWYWx1ZShlLHQpe2xldCBpPW5ldyBBcnJheUJ1ZmZlcjtpPWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj9lOmUuYnVmZmVyO2NvbnN0e05VTUJFUjphLEJPT0xFQU46bixTVFJJTkc6byxPQkpFQ1Q6ZCxNSVhfQVJSQVk6bCxPQkpFQ1RfRU5EOmgsU1RSSUNUX0FSUkFZOnUsREFURTpjLExPTkVfU1RSSU5HOmZ9PXIscD1uZXcgRGF0YVZpZXcoaSx0aGlzLnJlYWRPZmZzZXQsdCk7bGV0IG09ITE7Y29uc3QgZz1wLmdldFVpbnQ4KDApO2xldCBfPTE7dGhpcy5yZWFkT2Zmc2V0Kz0xO2xldCB5PW51bGw7c3dpdGNoKGcpe2Nhc2UgYTp5PXAuZ2V0RmxvYXQ2NCgxLCFzLmlzTGUpLHRoaXMucmVhZE9mZnNldCs9OCxfKz04O2JyZWFrO2Nhc2Ugbjp5PSEhcC5nZXRVaW50OCgxKSx0aGlzLnJlYWRPZmZzZXQrPTEsXys9MTticmVhaztjYXNlIG86e2NvbnN0IGU9dGhpcy5wYXJzZVN0cmluZyhpKTt5PWUuZGF0YSxfKz1lLmJvZHlTaXplO2JyZWFrfWNhc2UgZDp7eT17fTtsZXQgZT0wO2ZvcigxNjc3NzIxNSZwLmdldFVpbnQzMih0LTQsIXMuaXNMZSkmJihlPTMpO188dC00Oyl7Y29uc3Qgcz10aGlzLnBhcnNlT2JqZWN0KGksdC1fLWUpO2lmKHMuaXNPYmplY3RFbmQpYnJlYWs7eVtzLmRhdGEubmFtZV09cy5kYXRhLnZhbHVlLF8rPXMuYm9keVNpemV9aWYoXzw9dC0zKXs5PT09KDE2Nzc3MjE1JnAuZ2V0VWludDMyKF8tMSwhcy5pc0xlKSkmJih0aGlzLnJlYWRPZmZzZXQrPTMsXys9Myl9YnJlYWt9Y2FzZSBsOnt5PXt9LF8rPTQsdGhpcy5yZWFkT2Zmc2V0Kz00O2xldCBlPTA7Zm9yKDk9PSgxNjc3NzIxNSZwLmdldFVpbnQzMih0LTQsIXMuaXNMZSkpJiYoZT0zKTtfPHQtODspe2NvbnN0IHM9dGhpcy5wYXJzZU9iamVjdChpLHQtXy1lKTtpZihzLmlzT2JqZWN0RW5kKWJyZWFrO3lbcy5kYXRhLm5hbWVdPXMuZGF0YS52YWx1ZSxfKz1zLmJvZHlTaXplfWlmKF88PXQtMyl7OT09PSgxNjc3NzIxNSZwLmdldFVpbnQzMihfLTEsIXMuaXNMZSkpJiYoXys9Myx0aGlzLnJlYWRPZmZzZXQrPTMpfWJyZWFrfWNhc2UgaDp5PW51bGwsbT0hMDticmVhaztjYXNlIHU6e3k9W107Y29uc3QgZT1wLmdldFVpbnQzMigxLCFzLmlzTGUpO18rPTQsdGhpcy5yZWFkT2Zmc2V0Kz00O2ZvcihsZXQgcz0wO3M8ZTtzKyspe2NvbnN0IGU9dGhpcy5wYXJzZVZhbHVlKGksdC1fKTt5LnB1c2goZS5kYXRhKSxfKz1lLmJvZHlTaXplfWJyZWFrfWNhc2UgYzp7Y29uc3QgZT10aGlzLnBhcnNlRGF0ZShpLHQtMSk7eT1lLmRhdGEsXys9ZS5ib2R5U2l6ZTticmVha31jYXNlIGY6e2NvbnN0IGU9dGhpcy5wYXJzZUxvbmdTdHJpbmcoaSx0LTEpO3k9ZS5kYXRhLF8rPWUuYm9keVNpemU7YnJlYWt9ZGVmYXVsdDpfPXR9cmV0dXJue2RhdGE6eSxib2R5U2l6ZTpfLGlzT2JqRW5kOm19fX19LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9e01wNFJlbXV4ZXI6aSgzNykuZGVmYXVsdH19LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcyxyPWkoMCksYT1pKDM4KSxuPShzPWEpJiZzLl9fZXNNb2R1bGU/czp7ZGVmYXVsdDpzfTtjb25zdCBvPXIuRVZFTlRTLlJFTVVYX0VWRU5UUztjbGFzcyBke2NvbnN0cnVjdG9yKCl7dGhpcy5fZHRzQmFzZT0wLHRoaXMuX2lzRHRzQmFzZUluaXRlZD0hMSx0aGlzLl9hdWRpb05leHREdHM9bnVsbCx0aGlzLl92aWRlb05leHREdHM9bnVsbCx0aGlzLl92aWRlb1NlZ21lbnRMaXN0PW5ldyByLk1lZGlhU2VnbWVudExpc3QoXCJ2aWRlb1wiKSx0aGlzLl9hdWRpb1NlZ21lbnRMaXN0PW5ldyByLk1lZGlhU2VnbWVudExpc3QoXCJhdWRpb1wiKTtjb25zdHticm93c2VyOmV9PXIuc25pZmZlcjt0aGlzLl9maWxsU2lsZW5jZUZyYW1lPVwiaWVcIj09PWUsdGhpcy5pc0ZpcnN0VmlkZW89ITAsdGhpcy5pc0ZpcnN0QXVkaW89ITAsdGhpcy52aWRlb0FsbER1cmF0aW9uPTAsdGhpcy5hdWRpb0FsbER1cmF0aW9uPTB9aW5pdCgpe3RoaXMub24oby5SRU1VWF9NRURJQSx0aGlzLnJlbXV4LmJpbmQodGhpcykpLHRoaXMub24oby5SRU1VWF9NRVRBREFUQSx0aGlzLm9uTWV0YURhdGFSZWFkeS5iaW5kKHRoaXMpKSx0aGlzLm9uKG8uREVURUNUX0NIQU5HRV9TVFJFQU0sdGhpcy5yZXNldER0c0Jhc2UuYmluZCh0aGlzKSl9ZGVzdHJveSgpe3RoaXMuX2R0c0Jhc2U9LTEsdGhpcy5fZHRzQmFzZUluaXRlZD0hMSx0aGlzLl92aWRlb05leHREdHM9bnVsbCx0aGlzLl9hdWRpb05leHREdHM9bnVsbCx0aGlzLl92aWRlb1NlZ21lbnRMaXN0LmNsZWFyKCksdGhpcy5fYXVkaW9TZWdtZW50TGlzdC5jbGVhcigpLHRoaXMuX3ZpZGVvU2VnbWVudExpc3Q9bnVsbCx0aGlzLl9hdWRpb1NlZ21lbnRMaXN0PW51bGx9cmVtdXgoKXtjb25zdHthdWRpb1RyYWNrOmUsdmlkZW9UcmFjazp0fT10aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKFwiVFJBQ0tTXCIpOyF0aGlzLl9pc0R0c0Jhc2VJbml0ZWQmJnRoaXMuY2FsY0R0c0Jhc2UoZSx0KSx0aGlzLl9yZW11eFZpZGVvKHQpLHRoaXMuX3JlbXV4QXVkaW8oZSl9cmVzZXREdHNCYXNlKCl7dGhpcy5fZHRzQmFzZT0wLHRoaXMuX2R0c0Jhc2VJbml0ZWQ9ITF9c2Vlaygpe3RoaXMuX3ZpZGVvTmV4dER0cz1udWxsLHRoaXMuX2F1ZGlvTmV4dER0cz1udWxsLHRoaXMuX3ZpZGVvU2VnbWVudExpc3QuY2xlYXIoKSx0aGlzLl9hdWRpb1NlZ21lbnRMaXN0LmNsZWFyKCl9b25NZXRhRGF0YVJlYWR5KGUpe2xldCB0O2lmKFwiYXVkaW9cIj09PWUpe2NvbnN0e2F1ZGlvVHJhY2s6ZX09dGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZShcIlRSQUNLU1wiKTt0PWV9ZWxzZXtjb25zdHt2aWRlb1RyYWNrOmV9PXRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoXCJUUkFDS1NcIik7dD1lfWxldCBpPXRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoXCJQUkVfU09VUkNFX0JVRkZFUlwiKSxzPWkuZ2V0U291cmNlKGUpO3N8fChzPWkuY3JlYXRlU291cmNlKGUpKSxzLm1pbWV0eXBlPXQubWV0YS5jb2RlYyxzLmluaXQ9dGhpcy5yZW11eEluaXRTZWdtZW50KGUsdC5tZXRhKSx0aGlzLmVtaXQoby5JTklUX1NFR01FTlQsZSl9cmVtdXhJbml0U2VnbWVudChlLHQpe2xldCBpPW5ldyByLkJ1ZmZlcixzPW4uZGVmYXVsdC5mdHlwKCksYT1uLmRlZmF1bHQubW9vdih7dHlwZTplLG1ldGE6dH0pO3JldHVybiBpLndyaXRlKHMsYSksaX1jYWxjRHRzQmFzZShlLHQpe2lmKCFlLnNhbXBsZXMubGVuZ3RoJiYhdC5zYW1wbGVzLmxlbmd0aClyZXR1cm47bGV0IGk9MS8wLHM9MS8wO2Uuc2FtcGxlcyYmZS5zYW1wbGVzLmxlbmd0aCYmKGk9ZS5zYW1wbGVzWzBdLmR0cyksdC5zYW1wbGVzJiZ0LnNhbXBsZXMubGVuZ3RoJiYocz10LnNhbXBsZXNbMF0uZHRzKSx0aGlzLl9kdHNCYXNlPU1hdGgubWluKGkscyksdGhpcy5faXNEdHNCYXNlSW5pdGVkPSEwfV9yZW11eFZpZGVvKGUpe2NvbnN0IHQ9ZTtpZighZS5zYW1wbGVzfHwhZS5zYW1wbGVzLmxlbmd0aClyZXR1cm47bGV0e3NhbXBsZXM6aX09dCxzPS0xLGE9bnVsbDtjb25zdCBkPVtdLGw9e3NhbXBsZXM6W119O2Zvcig7aS5sZW5ndGg7KXtjb25zdCBlPWkuc2hpZnQoKSx7aXNLZXlmcmFtZTp0LG9wdGlvbnM6cn09ZTtpZighdGhpcy5pc0ZpcnN0QXVkaW8mJnImJnIubWV0YSl7YT10aGlzLnJlbXV4SW5pdFNlZ21lbnQoXCJ2aWRlb1wiLHIubWV0YSksci5tZXRhPW51bGwsaS51bnNoaWZ0KGUpLHIuaXNDb250aW51ZXx8dGhpcy5yZXNldER0c0Jhc2UoKTticmVha31sZXQgbixvLGg9ZS5kdHMtdGhpcy5fZHRzQmFzZTstMT09PXMmJihzPWgpLHZvaWQgMCE9PWUucHRzJiYobj0obz1lLnB0cy10aGlzLl9kdHNCYXNlKS1oKSx2b2lkIDAhPT1lLmN0cyYmKG89ZS5jdHMraCxuPWUuY3RzKTtsZXQgdT17YnVmZmVyOltdLHNpemU6MH07bC5zYW1wbGVzLnB1c2godSksdS5idWZmZXIucHVzaChlLmRhdGEpLHUuc2l6ZSs9ZS5kYXRhLmJ5dGVMZW5ndGg7bGV0IGM9MDtpZihpLmxlbmd0aD49MSl7Yz1pWzBdLmR0cy10aGlzLl9kdHNCYXNlLWh9ZWxzZSBjPWQubGVuZ3RoPj0xP2RbZC5sZW5ndGgtMV0uZHVyYXRpb246dGhpcy52aWRlb01ldGEucmVmU2FtcGxlRHVyYXRpb247dGhpcy52aWRlb0FsbER1cmF0aW9uKz1jLGQucHVzaCh7ZHRzOmgsY3RzOm4scHRzOm8sZGF0YTplLmRhdGEsc2l6ZTplLmRhdGEuYnl0ZUxlbmd0aCxpc0tleWZyYW1lOnQsZHVyYXRpb246YyxmbGFnczp7aXNMZWFkaW5nOjAsZGVwZW5kc09uOnQ/MjoxLGlzRGVwZW5kZWRPbjp0PzE6MCxoYXNSZWR1bmRhbmN5OjAsaXNOb25TeW5jOnQ/MDoxfSxvcmlnaW5EdHM6aCx0eXBlOlwidmlkZW9cIn0pfWxldCBoPW5ldyByLkJ1ZmZlcjtpZihkLmxlbmd0aCl7Y29uc3QgZT1uLmRlZmF1bHQubW9vZih7aWQ6dC5tZXRhLmlkLHRpbWU6cyxzYW1wbGVzOmR9KSxpPW4uZGVmYXVsdC5tZGF0KGwpO2gud3JpdGUoZSxpKSx0aGlzLndyaXRlVG9Tb3VyY2UoXCJ2aWRlb1wiLGgpfWlmKGEmJih0aGlzLndyaXRlVG9Tb3VyY2UoXCJ2aWRlb1wiLGEpLGkubGVuZ3RoKSlyZXR1cm4gdC5zYW1wbGVzPWksdGhpcy5fcmVtdXhWaWRlbyh0KTt0aGlzLmlzRmlyc3RWaWRlbz0hMSx0aGlzLmVtaXQoby5NRURJQV9TRUdNRU5ULFwidmlkZW9cIik7Y29uc3QgdT1kW2QubGVuZ3RoLTFdO3RoaXMuX3ZpZGVvTmV4dER0cz11LmR0cyt1LmR1cmF0aW9uLHQuc2FtcGxlcz1bXSx0Lmxlbmd0aD0wfV9yZW11eEF1ZGlvKGUpe2NvbnN0e3NhbXBsZXM6dH09ZTtsZXQgaT0tMSxzPVtdLGE9bnVsbDtjb25zdCBkPXtzYW1wbGVzOltdfTtpZighdHx8IXQubGVuZ3RoKXJldHVybjtsZXQgbD0hMTtmb3IoO3QubGVuZ3RoOyl7bGV0IGU9dC5zaGlmdCgpO2NvbnN0e2RhdGE6cixvcHRpb25zOm59PWU7aWYoIXRoaXMuaXNGaXJzdEF1ZGlvJiZuJiZuLm1ldGEpe2E9dGhpcy5yZW11eEluaXRTZWdtZW50KFwiYXVkaW9cIixuLm1ldGEpLG4ubWV0YT1udWxsLHQudW5zaGlmdChlKSxuLmlzQ29udGludWV8fHRoaXMucmVzZXREdHNCYXNlKCk7YnJlYWt9bGV0IG89ZS5kdHMtdGhpcy5fZHRzQmFzZTtjb25zdCBoPW87bHx8KGk9byxsPSEwKTtsZXQgdT0wO2lmKHRoaXMuYXVkaW9NZXRhLnJlZlNhbXBsZUR1cmF0aW9uRml4ZWQpdT10aGlzLmF1ZGlvTWV0YS5yZWZTYW1wbGVEdXJhdGlvbkZpeGVkO2Vsc2UgaWYodC5sZW5ndGg+PTEpe3U9dFswXS5kdHMtdGhpcy5fZHRzQmFzZS1vfWVsc2UgdT1zLmxlbmd0aD49MT9zW3MubGVuZ3RoLTFdLmR1cmF0aW9uOnRoaXMuYXVkaW9NZXRhLnJlZlNhbXBsZUR1cmF0aW9uO3RoaXMuYXVkaW9BbGxEdXJhdGlvbis9dTtjb25zdCBjPXtkdHM6byxwdHM6byxjdHM6MCxzaXplOnIuYnl0ZUxlbmd0aCxkdXJhdGlvbjplLmR1cmF0aW9uP2UuZHVyYXRpb246dSxmbGFnczp7aXNMZWFkaW5nOjAsZGVwZW5kc09uOjIsaXNEZXBlbmRlZE9uOjEsaGFzUmVkdW5kYW5jeTowLGlzTm9uU3luYzowfSxpc0tleWZyYW1lOiEwLG9yaWdpbkR0czpoLHR5cGU6XCJhdWRpb1wifTtsZXQgZj17YnVmZmVyOltdLHNpemU6MH07Zi5idWZmZXIucHVzaChyKSxmLnNpemUrPXIuYnl0ZUxlbmd0aCxkLnNhbXBsZXMucHVzaChmKSxzLnB1c2goYyl9Y29uc3QgaD1uZXcgci5CdWZmZXI7aWYocy5sZW5ndGgpe2NvbnN0IHQ9bi5kZWZhdWx0Lm1vb2Yoe2lkOmUubWV0YS5pZCx0aW1lOmksc2FtcGxlczpzfSkscj1uLmRlZmF1bHQubWRhdChkKTtoLndyaXRlKHQsciksdGhpcy53cml0ZVRvU291cmNlKFwiYXVkaW9cIixoKX1pZihhJiYodGhpcy53cml0ZVRvU291cmNlKFwiYXVkaW9cIixhKSx0Lmxlbmd0aCkpcmV0dXJuIGUuc2FtcGxlcz10LHRoaXMuX3JlbXV4QXVkaW8oZSk7dGhpcy5pc0ZpcnN0QXVkaW89ITEsdGhpcy5lbWl0KG8uTUVESUFfU0VHTUVOVCxcImF1ZGlvXCIsaCk7Y29uc3QgdT1zW3MubGVuZ3RoLTFdO3RoaXMuX3ZpZGVvTmV4dER0cz11LmR0cyt1LmR1cmF0aW9uLGUuc2FtcGxlcz1bXSxlLmxlbmd0aD0wfXdyaXRlVG9Tb3VyY2UoZSx0KXtsZXQgaT10aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKFwiUFJFX1NPVVJDRV9CVUZGRVJcIikscz1pLmdldFNvdXJjZShlKTtzfHwocz1pLmNyZWF0ZVNvdXJjZShlKSkscy5kYXRhLnB1c2godCl9aW5pdFNpbGVudEF1ZGlvKGUsdCl7Y29uc3QgaT1kLmdldFNpbGVudEZyYW1lKHRoaXMuX2F1ZGlvTWV0YS5jaGFubmVsQ291bnQpO3JldHVybntkdHM6ZSxwdHM6ZSxjdHM6MCxkdXJhdGlvbjp0LHVuaXQ6aSxzaXplOmkuYnl0ZUxlbmd0aCxvcmlnaW5EdHM6ZSx0eXBlOlwidmlkZW9cIn19Z2V0IHZpZGVvTWV0YSgpe3JldHVybiB0aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKFwiVFJBQ0tTXCIpLnZpZGVvVHJhY2subWV0YX1nZXQgYXVkaW9NZXRhKCl7cmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0SW5zdGFuY2UoXCJUUkFDS1NcIikuYXVkaW9UcmFjay5tZXRhfXN0YXRpYyBnZXRTaWxlbnRGcmFtZShlKXtyZXR1cm4gMT09PWU/bmV3IFVpbnQ4QXJyYXkoWzAsMjAwLDAsMTI4LDM1LDEyOF0pOjI9PT1lP25ldyBVaW50OEFycmF5KFszMywwLDczLDE0NCwyLDI1LDAsMzUsMTI4XSk6Mz09PWU/bmV3IFVpbnQ4QXJyYXkoWzAsMjAwLDAsMTI4LDMyLDEzMiwxLDM4LDY0LDgsMTAwLDAsMTQyXSk6ND09PWU/bmV3IFVpbnQ4QXJyYXkoWzAsMjAwLDAsMTI4LDMyLDEzMiwxLDM4LDY0LDgsMTAwLDAsMTI4LDQ0LDEyOCw4LDIsNTZdKTo1PT09ZT9uZXcgVWludDhBcnJheShbMCwyMDAsMCwxMjgsMzIsMTMyLDEsMzgsNjQsOCwxMDAsMCwxMzAsNDgsNCwxNTMsMCwzMywxNDQsMiw1Nl0pOjY9PT1lP25ldyBVaW50OEFycmF5KFswLDIwMCwwLDEyOCwzMiwxMzIsMSwzOCw2NCw4LDEwMCwwLDEzMCw0OCw0LDE1MywwLDMzLDE0NCwyLDAsMTc4LDAsMzIsOCwyMjRdKTpudWxsfX10LmRlZmF1bHQ9ZH0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPWkoMCk7Y2xhc3MgcntzdGF0aWMgc2l6ZShlKXtyZXR1cm4gcy5CdWZmZXIud3JpdGVVaW50MzIoZSl9c3RhdGljIGluaXRCb3goZSx0LC4uLmkpe2NvbnN0IGE9bmV3IHMuQnVmZmVyO3JldHVybiBhLndyaXRlKHIuc2l6ZShlKSxyLnR5cGUodCksLi4uaSksYS5idWZmZXJ9c3RhdGljIGV4dGVuc2lvbihlLHQpe3JldHVybiBuZXcgVWludDhBcnJheShbZSx0Pj4xNiYyNTUsdD4+OCYyNTUsMjU1JnRdKX1zdGF0aWMgZnR5cCgpe3JldHVybiByLmluaXRCb3goMjQsXCJmdHlwXCIsbmV3IFVpbnQ4QXJyYXkoWzEwNSwxMTUsMTExLDEwOSwwLDAsMCwxLDEwNSwxMTUsMTExLDEwOSw5NywxMTgsOTksNDldKSl9c3RhdGljIG1vb3Yoe3R5cGU6ZSxtZXRhOnR9KXtsZXQgaSxzPTgsYT1yLm12aGQodC5kdXJhdGlvbix0LnRpbWVzY2FsZSk7aT1cInZpZGVvXCI9PT1lP3IudmlkZW9UcmFrKHQpOnIuYXVkaW9UcmFrKHQpO2xldCBuPXIubXZleCh0LmR1cmF0aW9uLHQudGltZXNjYWxlfHwxZTMsdC5pZCk7cmV0dXJuW2EsaSxuXS5mb3JFYWNoKGU9PntzKz1lLmJ5dGVMZW5ndGh9KSxyLmluaXRCb3gocyxcIm1vb3ZcIixhLGksbil9c3RhdGljIG12aGQoZSx0PTFlMyl7bGV0IGk9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLHQ+Pj4yNCYyNTUsdD4+PjE2JjI1NSx0Pj4+OCYyNTUsMjU1JnQsZT4+PjI0JjI1NSxlPj4+MTYmMjU1LGU+Pj44JjI1NSwyNTUmZSwwLDEsMCwwLDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCw2NCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyNTUsMjU1LDI1NSwyNTVdKTtyZXR1cm4gci5pbml0Qm94KDgraS5sZW5ndGgsXCJtdmhkXCIsbmV3IFVpbnQ4QXJyYXkoaSkpfXN0YXRpYyB2aWRlb1RyYWsoZSl7bGV0IHQ9OCxpPXIudGtoZCh7aWQ6MSxkdXJhdGlvbjplLmR1cmF0aW9uLHRpbWVzY2FsZTplLnRpbWVzY2FsZXx8MWUzLHdpZHRoOmUucHJlc2VudFdpZHRoLGhlaWdodDplLnByZXNlbnRIZWlnaHQsdHlwZTpcInZpZGVvXCJ9KSxzPXIubWRpYSh7dHlwZTpcInZpZGVvXCIsdGltZXNjYWxlOmUudGltZXNjYWxlfHwxZTMsZHVyYXRpb246ZS5kdXJhdGlvbixhdmNjOmUuYXZjYyxwYXJSYXRpbzplLnBhclJhdGlvLHdpZHRoOmUucHJlc2VudFdpZHRoLGhlaWdodDplLnByZXNlbnRIZWlnaHR9KTtyZXR1cm5baSxzXS5mb3JFYWNoKGU9Pnt0Kz1lLmJ5dGVMZW5ndGh9KSxyLmluaXRCb3godCxcInRyYWtcIixpLHMpfXN0YXRpYyBhdWRpb1RyYWsoZSl7bGV0IHQ9OCxpPXIudGtoZCh7aWQ6MixkdXJhdGlvbjplLmR1cmF0aW9uLHRpbWVzY2FsZTplLnRpbWVzY2FsZXx8MWUzLHdpZHRoOjAsaGVpZ2h0OjAsdHlwZTpcImF1ZGlvXCJ9KSxzPXIubWRpYSh7dHlwZTpcImF1ZGlvXCIsdGltZXNjYWxlOmUudGltZXNjYWxlfHwxZTMsZHVyYXRpb246ZS5kdXJhdGlvbixjaGFubmVsQ291bnQ6ZS5jaGFubmVsQ291bnQsc2FtcGxlcmF0ZTplLnNhbXBsZVJhdGUsY29uZmlnOmUuY29uZmlnfSk7cmV0dXJuW2ksc10uZm9yRWFjaChlPT57dCs9ZS5ieXRlTGVuZ3RofSksci5pbml0Qm94KHQsXCJ0cmFrXCIsaSxzKX1zdGF0aWMgdGtoZChlKXtsZXQgdD1lLmlkLGk9ZS5kdXJhdGlvbixzPWUud2lkdGgsYT1lLmhlaWdodCxuPW5ldyBVaW50OEFycmF5KFswLDAsMCw3LDAsMCwwLDAsMCwwLDAsMCx0Pj4+MjQmMjU1LHQ+Pj4xNiYyNTUsdD4+PjgmMjU1LDI1NSZ0LDAsMCwwLDAsaT4+PjI0JjI1NSxpPj4+MTYmMjU1LGk+Pj44JjI1NSwyNTUmaSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCw2NCwwLDAsMCxzPj4+OCYyNTUsMjU1JnMsMCwwLGE+Pj44JjI1NSwyNTUmYSwwLDBdKTtyZXR1cm4gci5pbml0Qm94KDgrbi5ieXRlTGVuZ3RoLFwidGtoZFwiLG4pfXN0YXRpYyBlZHRzKGUpe2xldCB0PW5ldyBzLkJ1ZmZlcixpPWUuZHVyYXRpb24sYT1lLm1lZGlhVGltZTtyZXR1cm4gdC53cml0ZShyLnNpemUoMzYpLHIudHlwZShcImVkdHNcIikpLHQud3JpdGUoci5zaXplKDI4KSxyLnR5cGUoXCJlbHN0XCIpKSx0LndyaXRlKG5ldyBVaW50OEFycmF5KFswLDAsMCwxLGk+PjI0JjI1NSxpPj4xNiYyNTUsaT4+OCYyNTUsMjU1JmksYT4+MjQmMjU1LGE+PjE2JjI1NSxhPj44JjI1NSwyNTUmYSwwLDAsMCwxXSkpLHQuYnVmZmVyfXN0YXRpYyBtZGlhKGUpe2xldCB0PTgsaT1yLm1kaGQoZS50aW1lc2NhbGUsZS5kdXJhdGlvbikscz1yLmhkbHIoZS50eXBlKSxhPXIubWluZihlKTtyZXR1cm5baSxzLGFdLmZvckVhY2goZT0+e3QrPWUuYnl0ZUxlbmd0aH0pLHIuaW5pdEJveCh0LFwibWRpYVwiLGkscyxhKX1zdGF0aWMgbWRoZChlPTFlMyx0KXtsZXQgaT1uZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwLGU+Pj4yNCYyNTUsZT4+PjE2JjI1NSxlPj4+OCYyNTUsMjU1JmUsdD4+PjI0JjI1NSx0Pj4+MTYmMjU1LHQ+Pj44JjI1NSwyNTUmdCw4NSwxOTYsMCwwXSk7cmV0dXJuIHIuaW5pdEJveCgxMitpLmJ5dGVMZW5ndGgsXCJtZGhkXCIsci5leHRlbnNpb24oMCwwKSxpKX1zdGF0aWMgaGRscihlKXtsZXQgdD1bMCwwLDAsMCwwLDAsMCwwLDExOCwxMDUsMTAwLDEwMSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCw4NiwxMDUsMTAwLDEwMSwxMTEsNzIsOTcsMTEwLDEwMCwxMDgsMTAxLDExNCwwXTtyZXR1cm5cImF1ZGlvXCI9PT1lJiYodC5zcGxpY2UoOCw0LDExNSwxMTEsMTE3LDExMCksdC5zcGxpY2UoMjQsMTMsODMsMTExLDExNywxMTAsMTAwLDcyLDk3LDExMCwxMDAsMTA4LDEwMSwxMTQsMCkpLHIuaW5pdEJveCg4K3QubGVuZ3RoLFwiaGRsclwiLG5ldyBVaW50OEFycmF5KHQpKX1zdGF0aWMgbWluZihlKXtsZXQgdD04LGk9XCJ2aWRlb1wiPT09ZS50eXBlP3Iudm1oZCgpOnIuc21oZCgpLHM9ci5kaW5mKCksYT1yLnN0YmwoZSk7cmV0dXJuW2kscyxhXS5mb3JFYWNoKGU9Pnt0Kz1lLmJ5dGVMZW5ndGh9KSxyLmluaXRCb3godCxcIm1pbmZcIixpLHMsYSl9c3RhdGljIHZtaGQoKXtyZXR1cm4gci5pbml0Qm94KDIwLFwidm1oZFwiLG5ldyBVaW50OEFycmF5KFswLDAsMCwxLDAsMCwwLDAsMCwwLDAsMF0pKX1zdGF0aWMgc21oZCgpe3JldHVybiByLmluaXRCb3goMTYsXCJzbWhkXCIsbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMF0pKX1zdGF0aWMgZGluZigpe2xldCBlPW5ldyBzLkJ1ZmZlcjtyZXR1cm4gZS53cml0ZShyLnNpemUoMzYpLHIudHlwZShcImRpbmZcIiksci5zaXplKDI4KSxyLnR5cGUoXCJkcmVmXCIpLG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDEsMCwwLDAsMTIsMTE3LDExNCwxMDgsMzIsMCwwLDAsMV0pKSxlLmJ1ZmZlcn1zdGF0aWMgc3RibChlKXtsZXQgdD04LGk9ci5zdHNkKGUpLHM9ci5zdHRzKCksYT1yLnN0c2MoKSxuPXIuc3RzeigpLG89ci5zdGNvKCk7cmV0dXJuW2kscyxhLG4sb10uZm9yRWFjaChlPT57dCs9ZS5ieXRlTGVuZ3RofSksci5pbml0Qm94KHQsXCJzdGJsXCIsaSxzLGEsbixvKX1zdGF0aWMgc3RzZChlKXtsZXQgdDtyZXR1cm4gdD1cImF1ZGlvXCI9PT1lLnR5cGU/ci5tcDRhKGUpOnIuYXZjMShlKSxyLmluaXRCb3goMTYrdC5ieXRlTGVuZ3RoLFwic3RzZFwiLHIuZXh0ZW5zaW9uKDAsMCksbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDFdKSx0KX1zdGF0aWMgbXA0YShlKXtsZXQgdD1uZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLGUuY2hhbm5lbENvdW50LDAsMTYsMCwwLDAsMCxlLnNhbXBsZXJhdGU+PjgmMjU1LDI1NSZlLnNhbXBsZXJhdGUsMCwwXSksaT1yLmVzZHMoZS5jb25maWcpO3JldHVybiByLmluaXRCb3goOCt0LmJ5dGVMZW5ndGgraS5ieXRlTGVuZ3RoLFwibXA0YVwiLHQsaSl9c3RhdGljIGVzZHMoZT1bNDMsMTQ2LDgsMF0pe2NvbnN0IHQ9ZS5sZW5ndGg7bGV0IGk9bmV3IHMuQnVmZmVyLGE9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMywyMyt0LDAsMSwwLDQsMTUrdCw2NCwyMSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsNV0uY29uY2F0KFt0XSkuY29uY2F0KGUpLmNvbmNhdChbNiwxLDJdKSk7cmV0dXJuIGkud3JpdGUoci5zaXplKDgrYS5ieXRlTGVuZ3RoKSxyLnR5cGUoXCJlc2RzXCIpLGEpLGkuYnVmZmVyfXN0YXRpYyBhdmMxKGUpe2xldCB0PW5ldyBzLkJ1ZmZlcixpPWUud2lkdGgsYT1lLmhlaWdodCxuPWUucGFyUmF0aW8uaGVpZ2h0LG89ZS5wYXJSYXRpby53aWR0aCxkPWUuYXZjYyxsPW5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCxpPj44JjI1NSwyNTUmaSxhPj44JjI1NSwyNTUmYSwwLDcyLDAsMCwwLDcyLDAsMCwwLDAsMCwwLDAsMSwxOCwxMDAsOTcsMTA1LDEwOCwxMjEsMTA5LDExMSwxMTYsMTA1LDExMSwxMTAsNDcsMTA0LDEwOCwxMTUsNDYsMTA2LDExNSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMjQsMTcsMTddKSxoPW5ldyBVaW50OEFycmF5KFswLDI4LDE1NiwxMjgsMCw0NSwxOTgsMTkyLDAsNDUsMTk4LDE5Ml0pLHU9bmV3IFVpbnQ4QXJyYXkoW24+PjI0LG4+PjE2JjI1NSxuPj44JjI1NSwyNTUmbixvPj4yNCxvPj4xNiYyNTUsbz4+OCYyNTUsMjU1Jm9dKTtyZXR1cm4gdC53cml0ZShyLnNpemUoNDArbC5ieXRlTGVuZ3RoK2QuYnl0ZUxlbmd0aCtoLmJ5dGVMZW5ndGgpLHIudHlwZShcImF2YzFcIiksbCxyLnNpemUoOCtkLmJ5dGVMZW5ndGgpLHIudHlwZShcImF2Y0NcIiksZCxyLnNpemUoMjApLHIudHlwZShcImJ0cnRcIiksaCxyLnNpemUoMTYpLHIudHlwZShcInBhc3BcIiksdSksdC5idWZmZXJ9c3RhdGljIHN0dHMoKXtsZXQgZT1uZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwXSk7cmV0dXJuIHIuaW5pdEJveCgxNixcInN0dHNcIixlKX1zdGF0aWMgc3RzYygpe2xldCBlPW5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDBdKTtyZXR1cm4gci5pbml0Qm94KDE2LFwic3RzY1wiLGUpfXN0YXRpYyBzdGNvKCl7bGV0IGU9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMF0pO3JldHVybiByLmluaXRCb3goMTYsXCJzdGNvXCIsZSl9c3RhdGljIHN0c3ooKXtsZXQgZT1uZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdKTtyZXR1cm4gci5pbml0Qm94KDIwLFwic3RzelwiLGUpfXN0YXRpYyBtdmV4KGUsdD0xZTMsaSl7bGV0IGE9bmV3IHMuQnVmZmVyLG49cy5CdWZmZXIud3JpdGVVaW50MzIoZSk7cmV0dXJuIGEud3JpdGUoci5zaXplKDU2KSxyLnR5cGUoXCJtdmV4XCIpLHIuc2l6ZSgxNiksci50eXBlKFwibWVoZFwiKSxyLmV4dGVuc2lvbigwLDApLG4sci50cmV4KGkpKSxhLmJ1ZmZlcn1zdGF0aWMgdHJleChlKXtsZXQgdD1uZXcgVWludDhBcnJheShbMCwwLDAsMCxlPj4yNCxlPj4xNiYyNTUsZT4+OCYyNTUsMjU1JmUsMCwwLDAsMSwwLDAsMCwwLDAsMCwwLDAsMCwxLDAsMV0pO3JldHVybiByLmluaXRCb3goOCt0LmJ5dGVMZW5ndGgsXCJ0cmV4XCIsdCl9c3RhdGljIG1vb2YoZSl7bGV0IHQ9OCxpPXIubWZoZCgpLHM9ci50cmFmKGUpO3JldHVybltpLHNdLmZvckVhY2goZT0+e3QrPWUuYnl0ZUxlbmd0aH0pLHIuaW5pdEJveCh0LFwibW9vZlwiLGkscyl9c3RhdGljIG1maGQoKXtsZXQgZT1zLkJ1ZmZlci53cml0ZVVpbnQzMihyLnNlcXVlbmNlKTtyZXR1cm4gci5zZXF1ZW5jZSs9MSxyLmluaXRCb3goMTYsXCJtZmhkXCIsci5leHRlbnNpb24oMCwwKSxlKX1zdGF0aWMgdHJhZihlKXtsZXQgdD04LGk9ci50ZmhkKGUuaWQpLHM9ci50ZmR0KGUudGltZSksYT1yLnNkdHAoZSksbj1yLnRydW4oZSxhLmJ5dGVMZW5ndGgpO3JldHVybltpLHMsbixhXS5mb3JFYWNoKGU9Pnt0Kz1lLmJ5dGVMZW5ndGh9KSxyLmluaXRCb3godCxcInRyYWZcIixpLHMsbixhKX1zdGF0aWMgdGZoZChlKXtsZXQgdD1zLkJ1ZmZlci53cml0ZVVpbnQzMihlKTtyZXR1cm4gci5pbml0Qm94KDE2LFwidGZoZFwiLHIuZXh0ZW5zaW9uKDAsMCksdCl9c3RhdGljIHRmZHQoZSl7cmV0dXJuIHIuaW5pdEJveCgxNixcInRmZHRcIixyLmV4dGVuc2lvbigwLDApLHMuQnVmZmVyLndyaXRlVWludDMyKGUpKX1zdGF0aWMgdHJ1bihlLHQpe2xldCBpPW5ldyBzLkJ1ZmZlcixhPXMuQnVmZmVyLndyaXRlVWludDMyKGUuc2FtcGxlcy5sZW5ndGgpLG49cy5CdWZmZXIud3JpdGVVaW50MzIoOTIrMTYqZS5zYW1wbGVzLmxlbmd0aCt0KTtyZXR1cm4gaS53cml0ZShyLnNpemUoMjArMTYqZS5zYW1wbGVzLmxlbmd0aCksci50eXBlKFwidHJ1blwiKSxuZXcgVWludDhBcnJheShbMCwwLDE1LDFdKSxhLG4pLGUuc2FtcGxlcy5mb3JFYWNoKGU9Pntjb25zdCB0PWUuZmxhZ3M7aS53cml0ZShuZXcgVWludDhBcnJheShbZS5kdXJhdGlvbj4+PjI0JjI1NSxlLmR1cmF0aW9uPj4+MTYmMjU1LGUuZHVyYXRpb24+Pj44JjI1NSwyNTUmZS5kdXJhdGlvbixlLnNpemU+Pj4yNCYyNTUsZS5zaXplPj4+MTYmMjU1LGUuc2l6ZT4+PjgmMjU1LDI1NSZlLnNpemUsdC5pc0xlYWRpbmc8PDJ8dC5kZXBlbmRzT24sdC5pc0RlcGVuZGVkT248PDZ8dC5oYXNSZWR1bmRhbmN5PDw0fHQuaXNOb25TeW5jLDAsMCxlLmN0cz4+PjI0JjI1NSxlLmN0cz4+PjE2JjI1NSxlLmN0cz4+PjgmMjU1LDI1NSZlLmN0c10pKX0pLGkuYnVmZmVyfXN0YXRpYyBzZHRwKGUpe2xldCB0PW5ldyBzLkJ1ZmZlcjtyZXR1cm4gdC53cml0ZShyLnNpemUoMTIrZS5zYW1wbGVzLmxlbmd0aCksci50eXBlKFwic2R0cFwiKSxyLmV4dGVuc2lvbigwLDApKSxlLnNhbXBsZXMuZm9yRWFjaChlPT57Y29uc3QgaT1lLmZsYWdzLHM9aS5pc0xlYWRpbmc8PDZ8aS5kZXBlbmRzT248PDR8aS5pc0RlcGVuZGVkT248PDJ8aS5oYXNSZWR1bmRhbmN5O3Qud3JpdGUobmV3IFVpbnQ4QXJyYXkoW3NdKSl9KSx0LmJ1ZmZlcn1zdGF0aWMgbWRhdChlKXtsZXQgdD1uZXcgcy5CdWZmZXIsaT04O2Uuc2FtcGxlcy5mb3JFYWNoKGU9PntpKz1lLnNpemV9KSx0LndyaXRlKHIuc2l6ZShpKSxyLnR5cGUoXCJtZGF0XCIpKTtsZXQgYT1uZXcgVWludDhBcnJheShpKSxuPTA7cmV0dXJuIGEuc2V0KHQuYnVmZmVyLG4pLG4rPTgsZS5zYW1wbGVzLmZvckVhY2goZT0+e2UuYnVmZmVyLmZvckVhY2goZT0+e2Euc2V0KGUsbiksbis9ZS5ieXRlTGVuZ3RofSl9KSxhfX1yLnR5cGU9ZT0+bmV3IFVpbnQ4QXJyYXkoW2UuY2hhckNvZGVBdCgwKSxlLmNoYXJDb2RlQXQoMSksZS5jaGFyQ29kZUF0KDIpLGUuY2hhckNvZGVBdCgzKV0pLHIuc2VxdWVuY2U9MSx0LmRlZmF1bHQ9cn0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz17RmV0Y2hMb2FkZXI6aSg0MCkuZGVmYXVsdH19LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBzPWkoMCkuRVZFTlRTLkxPQURFUl9FVkVOVFMscj0wLGE9MSxuPTIsbz0zO3QuZGVmYXVsdD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLmNvbmZpZ3M9T2JqZWN0LmFzc2lnbih7fSxlKSx0aGlzLnVybD1udWxsLHRoaXMuc3RhdHVzPTAsdGhpcy5lcnJvcj1udWxsLHRoaXMuX3JlYWRlcj1udWxsLHRoaXMuX2NhbmNlbGVkPSExLHRoaXMuX2Rlc3Ryb3llZD0hMSx0aGlzLnJlYWR0eXBlPXRoaXMuY29uZmlncy5yZWFkdHlwZSx0aGlzLmJ1ZmZlcj10aGlzLmNvbmZpZ3MuYnVmZmVyfHxcIkxPQURFUl9CVUZGRVJcIix0aGlzLl9sb2FkZXJUYXNrTm89MH1pbml0KCl7dGhpcy5vbihzLkxBREVSX1NUQVJULHRoaXMubG9hZC5iaW5kKHRoaXMpKX1zdGF0aWMgZ2V0IHR5cGUoKXtyZXR1cm5cImxvYWRlclwifWxvYWQoZSx0KXtsZXQgaT10aGlzO3RoaXMudXJsPWUsdGhpcy5fY2FuY2VsZWQ9ITE7bGV0IHI9dGhpcy5nZXRQYXJhbXModCk7cmV0dXJuIGkubG9hZGluZz0hMCxmZXRjaCh0aGlzLnVybCxyKS50aGVuKChmdW5jdGlvbihlKXtpZihlLm9rKXJldHVybiBpLnN0YXR1cz1lLnN0YXR1cyxpLl9vbkZldGNoUmVzcG9uc2UoZSk7aS5sb2FkaW5nPSExLGkuZW1pdChzLkxPQURFUl9FUlJPUixpLlRBRyxuZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlLlwiKSl9KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe3Rocm93IGkubG9hZGluZz0hMSxpLmVtaXQocy5MT0FERVJfRVJST1IsaS5UQUcsZSksbmV3IEVycm9yKGUubWVzc2FnZSl9KSl9X29uRmV0Y2hSZXNwb25zZShlKXtsZXQgdD10aGlzLGk9dGhpcy5fY29udGV4dC5nZXRJbnN0YW5jZSh0aGlzLmJ1ZmZlcik7dGhpcy5fbG9hZGVyVGFza05vKys7bGV0IGQ9dGhpcy5fbG9hZGVyVGFza05vO2lmKCEwPT09ZS5vaylzd2l0Y2godGhpcy5yZWFkdHlwZSl7Y2FzZSBuOmUuanNvbigpLnRoZW4oZT0+e3QubG9hZGluZz0hMSx0Ll9jYW5jZWxlZHx8dC5fZGVzdHJveWVkfHwoaT8oaS5wdXNoKGUpLHQuZW1pdChzLkxPQURFUl9DT01QTEVURSxpKSk6dC5lbWl0KHMuTE9BREVSX0NPTVBMRVRFLGUpKX0pO2JyZWFrO2Nhc2UgYTplLnRleHQoKS50aGVuKGU9Pnt0LmxvYWRpbmc9ITEsdC5fY2FuY2VsZWR8fHQuX2Rlc3Ryb3llZHx8KGk/KGkucHVzaChlKSx0LmVtaXQocy5MT0FERVJfQ09NUExFVEUsaSkpOnQuZW1pdChzLkxPQURFUl9DT01QTEVURSxlKSl9KTticmVhaztjYXNlIG86ZS5hcnJheUJ1ZmZlcigpLnRoZW4oZT0+e3QubG9hZGluZz0hMSx0Ll9jYW5jZWxlZHx8dC5fZGVzdHJveWVkfHwoaT8oaS5wdXNoKG5ldyBVaW50OEFycmF5KGUpKSx0LmVtaXQocy5MT0FERVJfQ09NUExFVEUsaSkpOnQuZW1pdChzLkxPQURFUl9DT01QTEVURSxlKSl9KTticmVhaztjYXNlIHI6ZGVmYXVsdDpyZXR1cm4gdGhpcy5fb25SZWFkZXIoZS5ib2R5LmdldFJlYWRlcigpLGQpfX1fb25SZWFkZXIoZSx0KXtsZXQgaT10aGlzLl9jb250ZXh0LmdldEluc3RhbmNlKHRoaXMuYnVmZmVyKTtpZighaSYmdGhpcy5fcmVhZGVyfHx0aGlzLl9kZXN0cm95ZWQpdHJ5e3RoaXMuX3JlYWRlci5jYW5jZWwoKX1jYXRjaChlKXt9aWYodGhpcy5fcmVhZGVyPWUsITE9PT10aGlzLmxvYWRpbmcpcmV0dXJuO2xldCByPXRoaXM7dGhpcy5fcmVhZGVyJiZ0aGlzLl9yZWFkZXIucmVhZCgpLnRoZW4oKGZ1bmN0aW9uKGEpe2lmKGEuZG9uZSlyZXR1cm4gci5sb2FkaW5nPSExLHIuc3RhdHVzPTAsdm9pZCByLmVtaXQocy5MT0FERVJfQ09NUExFVEUsaSk7aWYoIXIuX2NhbmNlbGVkJiYhci5fZGVzdHJveWVkKXJldHVybiBpLnB1c2goYS52YWx1ZSksci5lbWl0KHMuTE9BREVSX0RBVEFMT0FERUQsaSksci5fb25SZWFkZXIoZSx0KTtpZihyLl9yZWFkZXIpdHJ5e3IuX3JlYWRlci5jYW5jZWwoKX1jYXRjaChlKXt9fSkpLmNhdGNoKGU9PntyLmxvYWRpbmc9ITEsci5lbWl0KHMuTE9BREVSX0VSUk9SLHIuVEFHLGUpfSl9Z2V0UGFyYW1zKGUpe2xldCB0PU9iamVjdC5hc3NpZ24oe30sZSksaT1uZXcgSGVhZGVycyxzPXttZXRob2Q6XCJHRVRcIixoZWFkZXJzOmksbW9kZTpcImNvcnNcIixjYWNoZTpcImRlZmF1bHRcIn07aWYoXCJvYmplY3RcIj09dHlwZW9mIHRoaXMuY29uZmlncy5oZWFkZXJzKXtsZXQgZT10aGlzLmNvbmZpZ3MuaGVhZGVycztmb3IobGV0IHQgaW4gZSllLmhhc093blByb3BlcnR5KHQpJiZpLmFwcGVuZCh0LGVbdF0pfWlmKFwib2JqZWN0XCI9PXR5cGVvZiB0LmhlYWRlcnMpe2xldCBlPXQuaGVhZGVycztmb3IobGV0IHQgaW4gZSllLmhhc093blByb3BlcnR5KHQpJiZpLmFwcGVuZCh0LGVbdF0pfXJldHVybiExPT09dC5jb3JzJiYocy5tb2RlPVwic2FtZS1vcmlnaW5cIiksdC53aXRoQ3JlZGVudGlhbHMmJihzLmNyZWRlbnRpYWxzPVwiaW5jbHVkZVwiKSxzfWNhbmNlbCgpe2lmKHRoaXMuX3JlYWRlcil7dHJ5e3RoaXMuX3JlYWRlci5jYW5jZWwoKX1jYXRjaChlKXt9dGhpcy5fcmVhZGVyPW51bGwsdGhpcy5sb2FkaW5nPSExLHRoaXMuX2NhbmNlbGVkPSEwfX1kZXN0cm95KCl7dGhpcy5fZGVzdHJveWVkPSEwLHRoaXMuY2FuY2VsKCl9fX1dKX0pKTtcbiIsImltcG9ydCBGbHZMaXZlUGxheWVyIGZyb20gJ3hncGxheWVyLWZsdi1saXZlJ1xuaW1wb3J0IEZsdlZvZFBsYXllciBmcm9tICd4Z3BsYXllci1mbHYtdm9kJ1xuXG5jbGFzcyBGbHZQbGF5ZXJ7XG4gIGNvbnN0cnVjdG9yIChjb25maWcpIHtcbiAgICBpZiAoY29uZmlnLmlzTGl2ZSkge1xuICAgICAgcmV0dXJuIG5ldyBGbHZMaXZlUGxheWVyKGNvbmZpZylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBGbHZWb2RQbGF5ZXIoY29uZmlnKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZsdlBsYXllclxuIiwiKGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1tcIlBsYXllclwiXTsgfSgpKTsiXSwic291cmNlUm9vdCI6IiJ9